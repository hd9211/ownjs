<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>824247ed34815f4c3681a0bb985c9cad</guid>
<title>项目中怎样做技术选型？</title>
<link>https://toutiao.io/k/ftrvm6v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引出四个维度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;工作快十五年了，从十年前开始经常会有新项目，需要从头开始做方案和设计。做技术选型很少成为我的难题。不是因为这方面我多有方法，而通常是很少有选择。在做技术选型的场景下基本有以下四个维度：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;维度一&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从系统构成上有两种：&lt;/p&gt;&lt;p&gt;第一种，有之前的老系统，需要重构&lt;/p&gt;&lt;p&gt;第二种，从零开始建的服务&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度二&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从稳定性要求上有三种：&lt;/p&gt;&lt;p&gt;第一种，现在没有什么业务量，将来估计也不会有什么增长，甚至很可能不成&lt;/p&gt;&lt;p&gt;第二种，现在没有什么业务量，将来对稳定性要求很高&lt;/p&gt;&lt;p&gt;第三种，现在对有稳定性要求很高&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度三&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从环境上有三种：&lt;/p&gt;&lt;p&gt;第一种，公司有很多基础设施&lt;/p&gt;&lt;p&gt;第二种，公司有一些基础设施&lt;/p&gt;&lt;p&gt;第三种，公司基本没有基础设施&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;维度四&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从要求上有两种：&lt;/p&gt;&lt;p&gt;第一种，公司有标准化规范，需要用公司的统一组件&lt;/p&gt;&lt;p&gt;第二种，公司没有要求&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;各个维度组合的选项考虑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从零开始项目现在没有什么业务量，将来估计也不会有什么增长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从目标上，遇到这种项目，工作的重心就不在于把项目做好做坏，而在于人员培养。&lt;/p&gt;&lt;p&gt;如果公司对组件上没有什么要求，那我的建议是大家想学什么，就用什么。直接拿学习的试验田来用，一举两得。&lt;/p&gt;&lt;p&gt;如果公司有标准化规范，需要用公司的统一组件。但是公司的组件一般也是开源进行二次开发的，也一样可以想学什么就用什么，弄不明白的，还可以找维护组件的人请教。也可以用公司自研的，但是在业界有一定知名度的产品。研究的好可以作为面试的一个亮点。&lt;/p&gt;&lt;p&gt;瞎举个例子哈：&lt;/p&gt;&lt;p&gt;一六年、一七年做P2P并且不合规的公司，眼看就不行了。有的团队用的kafka，就是为了学习这个东西；有的团队自己搭建redis集群也是为了学习。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从零开始项目现在没有什么业务量，现在或者&lt;/strong&gt;&lt;strong&gt;将来对稳定性要求很高&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从目标上，这个是产生业绩的最佳项目，要精心规划。&lt;/p&gt;&lt;p&gt;做这种项目需要做好调研，包含业界调研和公司调研。业界的同类产品是怎么做的，有哪些缺点和优点。公司有没有同类或者可以登高类比(登高类比是指先找相似度最高的，找不到在逐渐扩大范围)的，那些项目遇到过哪些坑或者问题，是否和架构或者技术选项有关。&lt;/p&gt;&lt;p&gt;在做好调研基础上，如果公司对组件上没有什么要求，那就需要根据项目本身的特点综合比较。举例如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9288590604026845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9CmJJia6SPKn3aiat9bnl33qdT7I2fW1QgJNGNoT5WSwMrNsJjuhG9O1iakIfozicuWhUUeeDhLOsteQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;/p&gt;&lt;p&gt;不考虑项目本身特性，使用技术通用的考察项主要有：优势、劣势、技术成熟度、社区活跃度、资料丰富程度、是否有大牌公司在持续维护。&lt;/p&gt;&lt;p&gt;可参考我之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484754&amp;amp;idx=1&amp;amp;sn=06ef4e22d3d113f213171330cd5c132c&amp;amp;chksm=fafdeffccd8a66ea04c16e30f75bb09dfad34a1c4866cb14a5783a3450d84a02fe156b67464f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《SpringBoot整合web容器》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《SpringBoot整合web容器》&lt;/a&gt;里面有介绍我当初对tomcat还是jetty选择的考虑点。&lt;/p&gt;&lt;p&gt;如果公司有标准化规范，需要用公司的统一组件。&lt;/p&gt;&lt;p&gt;这时候，如果公司的组件可选性很多，比如之前美团的监控告警组件就有cat、digger、tracing、大白等。这时候一方面考虑各个组件的侧重点和自身是否切合，最重要的是要看其他团队都用什么。周围团队用的很少，咱们也不要用了。兄弟团队有福同享有难同当，如果大家都用这个，组件稳定性有问题了，影响的不止一个团队，也相互有个依靠。就自己用了还出事了，额，让我想起一句歌词：“多少秘密在其中 欲诉无人能懂”-----一帘幽梦。暴露年龄了。&lt;/p&gt;&lt;p&gt;如果公司的组件只有一个，也要看看兄弟团队有没有在用，还需要组件团队给提供相应的SLA，对于还在推广中的组件要谨慎。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;strong&gt;现&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;没有什么业&lt;/strong&gt;&lt;strong&gt;务量，将来估计也不会有什么增长&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;建议放弃重构！&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;strong&gt;现&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;没有什么业&lt;/strong&gt;&lt;strong&gt;务量，&lt;strong&gt;将来对稳定性要求很高&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;参考从零开始项目现在没有什么业务量，现在或者将来对稳定性要求很高的方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重构老系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;，现在&lt;strong&gt;对稳定性要求很高&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;建议选型尽量和之前保持一致，以便于和之前的逻辑尽量一致。避免踩到特殊需求导致的特殊逻辑等坑。&lt;/p&gt;&lt;p&gt;实在不能一致，比如十二年前我们有个“新鲜事”中间件，类似于网页版的发朋友圈吧。之前是用c++写的，后来c++的同事都离职了，要求我们改成java。这时候要考虑的主要是技术的成熟度。这个成熟度包含业界技术本身的成熟度和团队成员对技术的熟练度。&lt;/p&gt;&lt;p&gt;对于这种类型，还有几句忠告：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不要特立独行，要合群！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用成熟的技术！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用成熟技术的成熟功能！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;最后对使用成熟技术的成熟功能做个解释说明：比如redis很成熟了，redis有很多高级特性，比如订阅转发，稳定性要求高的不要用。用更加成熟的常用做订阅转发的比如MQ!&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf7a650e72453bd78df1397ca31de218</guid>
<title>脑洞：让页面白屏的 8 种方式和防御方法</title>
<link>https://toutiao.io/k/xsdoi2k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在页面上加些代码，让页面白屏幕，有哪些方式呢？如何防御呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了 8 种让页面白屏的方法。在防御方法中，包含了一些你可能不知道的冷知识，如：判断元素是否被遮挡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法1: 隐藏根节点&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;display&lt;/span&gt;:none &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择器用 &lt;code&gt;body&lt;/code&gt; 也能达到一样的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当页面是深色模式时，添加上面的代码页面后，页面是黑色的。需要取消深色模式：删除下面的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;color-scheme&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;dark&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法2: 让根节点不可见&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置可见性的属性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;visibility&lt;/span&gt;: hidden &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，设置透明度为完全透明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法3: 大小设为0，超出隐藏&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;body&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;overflow&lt;/span&gt;: hidden &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择器用 &lt;code&gt;html&lt;/code&gt; 没有效果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法4: 偏移出屏幕&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 &lt;code&gt;fixed&lt;/code&gt; 定位：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;: -&lt;span&gt;99999px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，用 &lt;code&gt;transform&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;translateX&lt;/span&gt;(-&lt;span&gt;99999px&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法5: 遮挡页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用全屏的白色元素遮挡页面。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;::before&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;content&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;  &lt;span&gt;z-index&lt;/span&gt;: &lt;span&gt;999999&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100vw&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100vh&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;background&lt;/span&gt;: &lt;span&gt;#fff&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法6: 缩小&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;html&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.0000000000001&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法7: 清空页面内容&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;document&lt;/span&gt;.documentElement.innerHTML = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法8: 页面跳转到一个空白页面&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;location.href = &lt;span&gt;&#x27;空白页面URL&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法有点皮~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防御&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;检测白屏的样式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过轮训检查根节点上，是否有导致白屏的样式。如果有，则刷新页面。例如:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(hasWhitePageStyle()) {&lt;br/&gt;        location.reload()&lt;br/&gt;    }&lt;br/&gt;},  &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方式，可以防御方法 1 ~ 6。我们来看具体的检查方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根节点是否隐藏检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; root = &lt;span&gt;document&lt;/span&gt;.documentElement&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; body = &lt;span&gt;document&lt;/span&gt;.body&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).display === &lt;span&gt;&#x27;none&#x27;&lt;/span&gt; ||&lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).display === &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 根节点被隐藏&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;根节点是否可见检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).visibility === &lt;span&gt;&#x27;hidden&#x27;&lt;/span&gt; ||&lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).visibility === &lt;span&gt;&#x27;hidden&#x27;&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 不可见&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  getComputedStyle(root, &lt;span&gt;null&lt;/span&gt;).opacity &amp;lt; &lt;span&gt;0.1&lt;/span&gt; || &lt;br/&gt;  getComputedStyle(body, &lt;span&gt;null&lt;/span&gt;).opacity &amp;lt; &lt;span&gt;0.1&lt;/span&gt; ||&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 不可见&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大小为 0 检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; {width, height } = body.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(width === &lt;span&gt;0&lt;/span&gt; || height === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 大小为 0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;偏移出屏幕检查&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; {left, right, top, bottom } = body.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  left &amp;gt; &lt;span&gt;window&lt;/span&gt;.innerWidth || &lt;br/&gt;  right &amp;lt; &lt;span&gt;0&lt;/span&gt; || &lt;br/&gt;  top &amp;gt; &lt;span&gt;window&lt;/span&gt;.innerHeight || &lt;br/&gt;  bottom &amp;lt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 偏移出屏幕&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;遮挡检查&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;document.elementFromPoint(x, y)&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 返回某个坐标点下最上层的元素。如果元素没有被遮挡，则在该 API 中传入元素的上下左右四个坐标点，返回的均为该元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设页面上有个 id 为 tar 的元素，如果该元素未被遮挡，则认为页面被遮挡。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; tarElem = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;tar&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; {left, right, top, bottom} = tarElem.getBoundingClientRect()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(left, top) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(left, bottom) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(right, top) === tar &amp;amp;&amp;amp;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.elementFromPoint(right, bottom) === tar &amp;amp;&amp;amp;&lt;br/&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;// 未被遮挡&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防止修改 DOM&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MutationObserver API&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 可以监控 DOM 的变动。用该 API 可以防御页面内容被清空。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 监控 属性，子节点和后代节点的变动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; config = { &lt;span&gt;attributes&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;childList&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;subtree&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; MutationObserver(&lt;span&gt;(&lt;span&gt;mutationsList&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; mutation &lt;span&gt;of&lt;/span&gt; mutationsList) {&lt;span&gt;// 页面DOM变动&lt;/span&gt;&lt;br/&gt;    location.reload()&lt;br/&gt;  }&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;DOMContentLoaded&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  observer.observe(&lt;span&gt;document&lt;/span&gt;.documentElement, config);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防止页面跳转&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前没有找到防御的方法。尝试过以下方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重置 window.location&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;window&lt;/span&gt; = {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;window.location 仍然在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; location = &lt;span&gt;&#x27;&#x27;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;location&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都会报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;window.location = {} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面直接跳转了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将 window.location 设置为只读&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了如下尝试，均不行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;.freeze(&lt;span&gt;window&lt;/span&gt;) &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.freeze(&lt;span&gt;window&lt;/span&gt;.location) &lt;span&gt;// 无效&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(&lt;span&gt;window&lt;/span&gt;, &lt;span&gt;&quot;location&quot;&lt;/span&gt;, {&lt;span&gt;&quot;writable&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(location, &lt;span&gt;&quot;false&quot;&lt;/span&gt;, {&lt;span&gt;&quot;writable&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还有其他让页面白屏的方法吗？公众号留言告诉我吧~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;document.elementFromPoint(x, y): &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;MutationObserver API: &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>940e34cc825342fe77f340069c1308fd</guid>
<title>[译] 在嵌入式系统中运行 eBPF</title>
<link>https://toutiao.io/k/rby5frf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：Adrian Ratiu&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;译者：狄卫华&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;注：本文已取得作者本人的翻译授权！&lt;/p&gt;&lt;p&gt;原文链接：https://www.collabora.com/news-and-blog/blog/2019/05/06/an-ebpf-overview-part-4-working-with-embedded-systems/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本系列的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247493590&amp;amp;idx=1&amp;amp;sn=69f5272cc486fc0f72d84da01fabbe7d&amp;amp;chksm=cfa5fe6bf8d2777dfe1b208fa55e1603e28896878f84c5458df6281988985f8d081b823a7b15&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 1 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 1 部分&lt;/span&gt;&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247493681&amp;amp;idx=1&amp;amp;sn=497f67295144231d9ba3d3c53260328d&amp;amp;chksm=cfa5f18cf8d2789a7188f2f83cca93ced881b6cc04cd3f9ad53de7775b726b79fa594af2817b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 2 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 2 部分&lt;/span&gt;&lt;/a&gt;，我们介绍了 eBPF 虚拟机内部工作原理，在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247494118&amp;amp;idx=1&amp;amp;sn=0f48c98e52834660e460c4040fd7148b&amp;amp;chksm=cfa5f05bf8d2794d78418cda5568c26a3e0dce8a9ca16c691acd0037e2f17dd35bc6c85ac7b8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 3 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 3 部分&lt;/span&gt;&lt;/a&gt;我们研究了基于底层虚拟机机制之上开发和使用 eBPF 程序的主流方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这一部分中，我们将从另外一个视角来分析项目，尝试解决嵌入式 Linux 系统所面临的一些独特的问题：如需要非常小的自定义操作系统镜像，不能容纳完整的 BCC LLVM 工具链/python 安装，或试图避免同时维护主机的交叉编译（本地）工具链和交叉编译的目标编译器工具链，以及其相关的构建逻辑，即使在使用像 OpenEmbedded/Yocto 这样的高级构建系统时也很重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 关于可移植性&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NTU0MzEyMg==&amp;amp;mid=2247494118&amp;amp;idx=1&amp;amp;sn=0f48c98e52834660e460c4040fd7148b&amp;amp;chksm=cfa5f05bf8d2794d78418cda5568c26a3e0dce8a9ca16c691acd0037e2f17dd35bc6c85ac7b8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第 3 部分&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;第 3 部分&lt;/span&gt;&lt;/a&gt;研究的运行 eBPF/BCC 程序的主流方式中，可移植性并不是像在嵌入式设备上面临的问题那么大：eBPF 程序是在被加载的同一台机器上编译的，使用已经运行的内核，而且头文件很容易通过发行包管理器获得。嵌入式系统通常运行不同的 Linux 发行版和不同的处理器架构，与开发人员的计算机相比，有时具有重度修改或上游分歧的内核，在构建配置上也有很大的差异，或还可能使用了只有二进制的模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eBPF 虚拟机的字节码是通用的（并未与特定机器相关），所以一旦编译好 eBPF 字节码，将其从 x86_64 移动到 ARM 设备上并不会引起太多问题。当字节码探测内核函数和数据结构时，问题就开始了，这些函数和数据结构可能与目标设备的内核不同或者会不存在，所以至少目标设备的内核头文件必须存在于构建 eBPF 程序字节码的主机上。新的功能或 eBPF 指令也可能被添加到以后的内核中，这可以使 eBPF 字节码向前兼容，但不能在内核版本之间向后兼容（参见&lt;span&gt;内核版本与 eBPF 功能&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;）。建议将 eBPF 程序附加到稳定的内核 ABI 上，如跟踪点（tracepoint），这可以缓解常见的可移植性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近一个重要的工作已经开始，通过在 LLVM 生成的 eBPF 对象代码中嵌入数据类型信息，通过增加 BTF（BTF 类型格式）数据，以增加 eBPF 程序的可移植性（CO-RE 一次编译，到处运行）。更多信息见这里的&lt;span&gt;补丁&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;和&lt;span&gt;文章&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。这很重要，因为 BTF 涉及到 eBPF 软件技术栈的所有部分（内核虚拟机和验证器、clang/LLVM 编译器、BCC 等），但这种方式可带来很大的便利，允许重复使用现有的 BCC 工具，而不需要特别的 eBPF 交叉编译和在嵌入式设备上安装 LLVM 或运行 BPFd。截至目前，CO-RE BTF 工作仍处于早期开发阶段，还需要付出相当多的工作才能可用【译者注：当前在高版本内核已经可以使用或者编译内核时启用了 BTF 编译选项】。也许我们会在其完全可用后再发表一篇博文。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. BPFd&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;BPFd&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;（项目地址 &lt;span&gt;👉&lt;/span&gt;https://github.com/joelagnel/bpfd）更像是一个为 Android 设备开发的概念验证，后被放弃，转而通过 &lt;span&gt;adeb&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 包运行一个完整的设备上的 BCC 工具链【译者注：BCC 在 adeb 的编译文档参见&lt;span&gt;这里&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;】。如果一个设备足够强大，可以运行 Android 和 Java，那么它也可能可以安装 BCC/LLVM/python。尽管这个实现有些不完整（通信是通过 Android USB 调试桥或作为一个本地进程完成的，而不是通过一个通用的传输层），但这个设计很有趣，有足够时间和资源的人可以把它拿起来合并，继续搁置的 &lt;span&gt;PR 工作&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，BPFd 是一个运行在嵌入式设备上的守护程序，作为本地内核/libbpf 的一个远程过程调用（RPC）接口。Python 在主机上运行，调用 BCC 来编译/部署 eBPF 字节码，并通过 BPFd 创建/读取 map。BPFd 的主要优点是，所有的 BCC 基础设施和脚本都可以工作，而不需要在目标设备上安装 BCC、LLVM 或 python，BPFd 二进制文件只有 100kb 左右的大小，并依赖 libc。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;102&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.17647058823529413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAsMHkxosSoickkhWfxHbuJGWhSjv9EUTIlBhemQBIHfh7pdcSOUiajA7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Ply&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ply&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt; 项目实现了一种与 BPFtrace 非常相似的高级领域特定语言（受到 AWK 和 C 的启发），其明确的目的是将运行时的依赖性降到最低。它只依赖于一个现代的 libc（不一定是 GNU 的 libc）和 shell（与 sh 兼容）。Ply 本身实现了一个 eBPF 编译器，需要根据目标设备的内核头文件进行构建，然后作为一个单一的二进制库和 shell 包装器部署到目标设备上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;104&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.18030690537084398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAlyoU5JxUhiaziaGw4dqJoHu2Ltf5P1HcDRIYYIDCl0OPgQBVffy6RDnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好解释 ply，我们把第 3 部分中的 BPFtrace 例子和与 ply 实现进行对比：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BPFtrace：要运行该例子，你需要数百 MB 的 LLVM/clang、libelf 和其他依赖项：&lt;/p&gt;&lt;p&gt;&lt;code&gt;bpftrace -e &#x27;tracepoint:raw_syscalls:sys_enter {@[pid, comm] = count();}&#x27;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ply：你只需要一个 ~50kb 的二进制文件，它产生的结果是相同的，语法几乎相同：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ply &#x27;tracepoint:raw_syscalls/sys_enter {@[pid, comm] = count();}&#x27;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ply 仍在大量开发中（最近的 v2.0 版本是完全重写的）【译者注：当前最新版本为 2.1.1，最近一次代码提交是 8 个月前，活跃度一般】，除了一些示例之外，该语言还不不稳定或缺乏文档，它不如完整的 BCC 强大，也没有 BPFtrace 丰富的功能特性，但它对于通过 ssh 或串行控制台快速调试远程嵌入式设备仍然非常有用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Gobpf&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Gobpf&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt; 及其合并的子项目（goebpf, gobpf-elf-loader），是 IOVisor 项目的一部分，为 BCC 提供 Golang 语言绑定。eBPF 的内核逻辑仍然用 &quot;限制性 C&quot; 编写，并由 LLVM 编译，只有标准的 python/lua 用户空间脚本被 Go 取代。这个项目对嵌入式设备的意义在于它的 eBPF &lt;span&gt;elf 加载模块&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，其可以被交叉编译并在嵌入式设备上独立运行，以加载 eBPF 程序至内核并与与之交互。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;121&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.20971867007672634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/u5Pibv7AcsEUeica6doRh2mEQA4DWhOruAtkAfY0QXls6cJpicLBYKOTkTmJia6b3rMpKibneJgyBm7qVTCBMqhUMEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，go 加载器可以被写成通用的（我们很快就会看到），因此它可以加载和运行任何 eBPF 字节码，并在本地重新用于多个不同的跟踪会话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 gobpf 很痛苦的，主要是因为缺乏文档。目前最好的 &quot;文档&quot; 是 &lt;span&gt;tcptracer 源码&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;，它相当复杂（他们使用 kprobes 而不依赖于特定的内核版本！），但从它可以学到很多。Gobpf 本身也是一项正在进行的工作：虽然 elf 加载器相当完整，并支持加载带有套接字、(k|u)probes、tracepoints、perf 事件等加载的 eBPF ELF 对象，但 bcc go 绑定模块还不容易支持所有这些功能。例如，尽管你可以写一个 socket_ilter ebpf 程序，将其编译并加载到内核中，但你仍然不能像 BCC 的 python 那样从 go 用户空间轻松地与 eBPF 进行交互，BCC 的 API 更加成熟和用户友好。无论如何，gobpf 仍然比其他具有类似目标的项目处于更好的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们研究一个简单的例子来说明 gobpf 如何工作的。首先，我们将在本地 x86_64 机器上运行它，然后交叉编译并在 32 位 ARMv7 板上运行它，比如流行的 Beaglebone 或 Raspberry Pi。我们的文件目录结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ find . -&lt;span&gt;type&lt;/span&gt; f&lt;br/&gt;./src/open-example.go&lt;br/&gt;./src/open-example.c&lt;br/&gt;./Makefile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;open-example.go&lt;/strong&gt;：这是建立在 gobpf/elf 之上的 eBPF ELF 加载器。它把编译好的 &quot;限制性 C&quot; ELF 对象作为参数，加载到内核并运行，直到加载器进程被杀死，这时内核会自动卸载 eBPF 逻辑【译者注：通常情况是这样的，也有场景加载器退出，ebpf 程序继续运行的】。我们有意保持加载器的简单性和通用性（它加载在对象文件中发现的任何探针），因此加载器可以被重复使用。更复杂的逻辑可以通过使用 &lt;span&gt;gobpf 绑定&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt; 模块添加到这里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os/signal&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;github.com/iovisor/gobpf/elf&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {mod := elf.NewModule(os.Args[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;    err := mod.Load(&lt;span&gt;nil&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {fmt.Fprintf(os.Stderr, &lt;span&gt;&quot;Error loading&#x27;%s&#x27;ebpf object: %v\n&quot;&lt;/span&gt;, os.Args[&lt;span&gt;1&lt;/span&gt;], err)os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    err = mod.EnableKprobes(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {fmt.Fprintf(os.Stderr, &lt;span&gt;&quot;Error loading kprobes: %v\n&quot;&lt;/span&gt;, err)&lt;br/&gt;        os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    sig := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; os.Signal, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    signal.Notify(sig, os.Interrupt, os.Kill)&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;open-example.c&lt;/strong&gt;：这是上述加载器加载至内核的 &quot;限制性 C&quot; 源代码。它挂载在 do_sys_open 函数，并根据 &lt;span&gt;ftrace format&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt; 将进程命令、PID、CPU、打开文件名和时间戳打印到跟踪环形缓冲区，（详见 &quot;输出格式&quot; 一节）。打开的文件名作为 &lt;span&gt;do_sys_open call&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt; 的第二个参数传递，可以从代表函数入口的 CPU 寄存器的上下文结构中访问。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;uapi/linux/bpf.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;uapi/linux/ptrace.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;SEC(&lt;span&gt;&quot;kprobe/do_sys_open&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;kprobe__do_sys_open&lt;/span&gt;&lt;span&gt;(struct pt_regs *ctx)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;span&gt;char&lt;/span&gt; file_name[&lt;span&gt;256&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    bpf_probe_read(file_name, &lt;span&gt;sizeof&lt;/span&gt;(file_name), PT_REGS_PARM2(ctx));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; fmt[] = &lt;span&gt;&quot;file %s\n&quot;&lt;/span&gt;;&lt;br/&gt;    bpf_trace_printk(fmt, &lt;span&gt;sizeof&lt;/span&gt;(fmt), &amp;amp;file_name);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; _license[] SEC(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;__u32 _version &lt;span&gt;SEC&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;version&quot;&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;= &lt;span&gt;0xFFFFFFFE&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，我们定义了特定的 &quot;SEC&quot; 区域，这样 gobpf 加载器就可获取到哪里查找或加载内容的信息。在我们的例子中，区域为 kprobe、license 和 version。特殊的 0xFFFFFFFE 值告诉加载器，这个 eBPF 程序与任何内核版本都是兼容的，因为打开系统调用而破坏用户空间的机会接近于 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Makefile&lt;/strong&gt;：这是上述两个文件的构建逻辑。注意我们是如何在 include 路径中加入 &quot;arch/x86/...&quot; 的；在 ARM 上它将是 &quot;arch/arm/...&quot;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SHELL=/bin/bash -o pipefail&lt;br/&gt;LINUX_SRC_ROOT=&lt;span&gt;&quot;/home/adi/workspace/linux&quot;&lt;/span&gt;&lt;br/&gt;FILENAME=&lt;span&gt;&quot;open-example&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ebpf-build: clean go-build&lt;/span&gt;&lt;br/&gt; clang \&lt;br/&gt; -D__KERNEL__ -fno-stack-protector -Wno-int-conversion \&lt;br/&gt; -O2 -emit-llvm -c &lt;span&gt;&quot;src/${FILENAME}.c&quot;&lt;/span&gt; \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/tools/testing/selftests \&lt;br/&gt; -I ${LINUX_SRC_ROOT}/arch/x86/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt; -o - | llc -march=bpf -filetype=obj -o &lt;span&gt;&quot;${FILENAME}.o&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go-build:&lt;/span&gt;&lt;br/&gt; go build -o ${FILENAME} src/${FILENAME}.go&lt;br/&gt;&lt;br/&gt;&lt;span&gt;clean:&lt;/span&gt;&lt;br/&gt; rm -f ${FILENAME}*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上述 makefile 在当前目录下产生两个新文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;open-example：这是编译后的 src/*.go 加载器。它只依赖于 libc 并且可以被复用来加载多个 eBPF ELF 文件运行多个跟踪。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;open-example.o：这是编译后的 eBPF 字节码，将在内核中加载。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“open-example&quot; 和 &quot;open-example.o&quot; ELF 二进制文件可以进一步合并成一个；加载器可以包括 eBPF 二进制文件作为资产，也可以像 &lt;span&gt;tcptracer&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt; 那样在其源代码中直接存储为字节数。然而，这超出了本文的范围。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行例子显示以下输出（见 [ftrace 文档](&amp;lt;(https://raw.githubusercontent.com/torvalds/linux/v4.20/Documentation/trace/ftrace.rst &quot;ftrace 文档&quot;)&amp;gt;) 中的 &quot;输出格式&quot; 部分）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# (./open-example open-example.o &amp;amp;) &amp;amp;&amp;amp; cat /sys/kernel/debug/tracing/trace_pipe&lt;/span&gt;&lt;br/&gt;electron-17494 [007] ...3 163158.937350: 0: file /proc/self/maps&lt;br/&gt;systemd-1      [005] ...3 163160.120796: 0: file /proc/29261/cgroup&lt;br/&gt;emacs-596      [006] ...3 163163.501746: 0: file /home/adi/&lt;br/&gt;(...)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沿用我们在本系列的第 3 部分中定义的术语，我们的 eBPF 程序有以下部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt;：是 open-example.o ELF 对象。它将数据写入内核跟踪环形缓冲区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;加载器&lt;/strong&gt;：这是编译过的 open-example 二进制文件，包含 gobpf/elf 加载器模块。只要它运行，数据就会被添加到跟踪缓冲区中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;：这就是 &lt;code&gt;cat /sys/kernel/debug/tracing/trace_pipe&lt;/code&gt;。非常 UNIX 风格。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据结构&lt;/strong&gt;：内核跟踪环形缓冲区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在将我们的例子交叉编译为 32 位 ARMv7。基于你的 ARM 设备运行的内核版本：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内核版本&amp;gt;=5.2：只需改变 makefile，就可以交叉编译与上述相同的源代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内核版本&amp;lt;5.2：除了使用新的 makefile 外，还需要将 PT_REGS_PARM* 宏从 &lt;span&gt;这个 patch&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt; 复制到 &quot;受限制 C&quot; 代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的 makefile 告诉 LLVM/Clang，eBPF 字节码以 ARMv7 设备为目标，使用 32 位 eBPF 虚拟机子寄存器地址模式，以便虚拟机可以正确访问本地处理器提供的 32 位寻址内存（还记得第 2 部分中介绍的所有 eBPF 虚拟机寄存器默认为 64 位宽），设置适当的包含路径，然后指示 Go 编译器使用正确的交叉编译设置。在运行这个 makefile 之前，需要一个预先存在的交叉编译器工具链，它被指向 CC 变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SHELL=/bin/bash -o pipefail&lt;br/&gt;LINUX_SRC_ROOT=&lt;span&gt;&quot;/home/adi/workspace/linux&quot;&lt;/span&gt;&lt;br/&gt;FILENAME=&lt;span&gt;&quot;open-example&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ebpf-build: clean go-build&lt;/span&gt;&lt;br/&gt; clang \&lt;br/&gt;  --target=armv7a-linux-gnueabihf \&lt;br/&gt;  -D__KERNEL__ -fno-stack-protector -Wno-int-conversion \&lt;br/&gt;  -O2 -emit-llvm -c &lt;span&gt;&quot;src/${FILENAME}.c&quot;&lt;/span&gt; \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/tools/testing/selftests \&lt;br/&gt;  -I ${LINUX_SRC_ROOT}/arch/arm/&lt;span&gt;include&lt;/span&gt; \&lt;br/&gt;  -o - | llc -march=bpf -filetype=obj -o &lt;span&gt;&quot;${FILENAME}.o&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go-build:&lt;/span&gt;&lt;br/&gt; GOOS=linux GOARCH=arm CGO_ENABLED=1 CC=arm-linux-gnueabihf-gcc \&lt;br/&gt; go build -o ${FILENAME} src/${FILENAME}.go&lt;br/&gt;&lt;br/&gt;&lt;span&gt;clean:&lt;/span&gt;&lt;br/&gt; rm -f ${FILENAME}*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行新的 makefile，并验证产生的二进制文件已经被正确地交叉编译：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[adi@iwork]$ file open-example*&lt;br/&gt;open-example:   ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter (...), stripped&lt;br/&gt;open-example.o: ELF 64-bit LSB relocatable, *unknown arch 0xf7* version 1 (SYSV), not stripped&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将加载器和字节码复制到设备上，与在 x86_64 主机上使用上述相同的命令来运行。记住，只要修改和重新编译 C eBPF 代码，加载器就可以重复使用，用于运行不同的跟踪。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@ionelpi adi]&lt;span&gt;# (./open-example open-example.o &amp;amp;) &amp;amp;&amp;amp; cat /sys/kernel/debug/tracing/trace_pipe&lt;/span&gt;&lt;br/&gt;ls-380     [001] d..2   203.410986: 0: file /etc/ld-musl-armhf.path&lt;br/&gt;ls-380     [001] d..2   203.411064: 0: file /usr/lib/libcap.so.2&lt;br/&gt;ls-380     [001] d..2   203.411922: 0: file /&lt;br/&gt;zcat-397   [002] d..2   432.676010: 0: file /etc/ld-musl-armhf.path&lt;br/&gt;zcat-397   [002] d..2   432.676237: 0: file /usr/lib/libtinfo.so.5&lt;br/&gt;zcat-397   [002] d..2   432.679431: 0: file /usr/bin/zcat&lt;br/&gt;gzip-397   [002] d..2   432.693428: 0: file /proc/&lt;br/&gt;gzip-397   [002] d..2   432.693633: 0: file config.gz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于加载器和字节码加起来只有 2M 大小，这是一个在嵌入式设备上运行 eBPF 的相当好的方法，而不需要完全安装 BCC/LLVM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本系列的第 4 部分，我们研究了可以用于在小型嵌入式设备上运行 eBPF 程序的相关项目。不幸的是，当前使用这些项目还是比较很困难的：它们有的被遗弃或缺乏人力，在早期开发时一切都在变化，或缺乏基本的文档，需要用户深入到源代码中并自己想办法解决。正如我们所看到的，gobpf 项目作为 BCC/python 的替代品是最有活力的，而 ply 也是一个有前途的 BPFtrace 替代品，其占用空间最小。随着更多的工作投入到这些项目中以降低使用者的门槛，eBPF 的强大功能可以用于资源受限的嵌入式设备，而无需移植/安装整个 BCC/LLVM/python/Hover 技术栈。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引用链接&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;内核版本与 eBPF 功能: &lt;em&gt;https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;补丁: &lt;em&gt;https://lwn.net/Articles/750695/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;文章: &lt;em&gt;https://lwn.net/Articles/773198/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;BPFd: &lt;em&gt;https://lwn.net/Articles/744522/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;adeb: &lt;em&gt;https://github.com/joelagnel/adeb&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;这里: &lt;em&gt;https://github.com/joelagnel/adeb/blob/master/BCC.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;PR 工作: &lt;em&gt;https://github.com/iovisor/bcc/pull/1675&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;ply: &lt;em&gt;https://wkz.github.io/ply/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Gobpf: &lt;em&gt;https://github.com/iovisor/gobpf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;elf 加载模块: &lt;em&gt;https://github.com/iovisor/gobpf/tree/master/elf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;tcptracer 源码: &lt;em&gt;https://github.com/weaveworks/tcptracer-bpf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;gobpf 绑定: &lt;em&gt;https://github.com/iovisor/gobpf/blob/master/bcc/module.go&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;ftrace format: &lt;em&gt;https://raw.githubusercontent.com/torvalds/linux/v4.20/Documentation/trace/ftrace.rst&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;do_sys_open call: &lt;em&gt;https://github.com/torvalds/linux/blob/v4.20/fs/open.c#L1048&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;tcptracer: &lt;em&gt;https://github.com/weaveworks/tcptracer-bpf/blob/master/pkg/tracer/tcptracer-ebpf.go#L80&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;这个 patch: &lt;em&gt;https://lore.kernel.org/bpf/20190304205019.15071-1-adrian.ratiu@collabora.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc34029022719ec4a55af60d9585f6b6</guid>
<title>网易开源运维诊断框架 KubeDiag 技术解析</title>
<link>https://toutiao.io/k/mcc46wh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;KubeDiag 是基于 Kubernetes 云原生基础设施能力打造的开源框架，旨在解决云原生体系中运维诊断的自动化问题，帮助用户更加平滑地完成容器化落地。本文将为大家解读 KubeDiag 整体框架设计。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Kubernetes 是一个生产级的容器编排引擎，但是 Kubernetes 仍然存在系统复杂、故障诊断成本高等问题。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MzM3MzkyMg==&amp;amp;mid=2247492500&amp;amp;idx=1&amp;amp;sn=b56a351eecba9949081079b24a194c33&amp;amp;chksm=eabe7699ddc9ff8f16dde16ab87456d2b61764ba5dc784c9209357942c260895a85648f2333a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;网易数帆近期开源的 KubeDiag&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;网易数帆近期开源的 KubeDiag&lt;/a&gt;，是基于 Kubernetes 云原生基础设施能力打造的框架，旨在解决云原生体系中故障诊断、运维恢复的自动化问题。主要包括以下几个维度：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.27890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSxBJ9RuGZNX77RgHg75dFrLajD8OoLnOyhN9dI10FILvwIwfRTBEicXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/kubediag/kubediag&lt;/p&gt;&lt;h2&gt;&lt;span&gt;设计目标&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KubeDiag 的设计目标包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可移植性：&lt;/strong&gt;可以在部署 Kubernetes 的 Linux 标准环境下运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可扩展性：&lt;/strong&gt;用户可以集成自定义的诊断功能。模块之间通过松耦合接口交互并且各功能模块均是可插拔式的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;自动化：&lt;/strong&gt;极大降低问题诊断的人力成本。用户可以通过声明式 API 定义诊断工作流并且在问题发生时自动运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;易用性：&lt;/strong&gt;内置常见问题诊断逻辑以提供开箱即用的体验。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;架构设计&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KubeDiag 由 Master 和 Agent 组成，并且从 APIServer 以及 Prometheus 等组件获取数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4435483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSBL29NBljACY91ccb55PC5GAicG9Re4swibJWdFfUg6ibfRFLIGribssTXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;h3&gt;KubeDiag Master 设计&lt;/h3&gt;&lt;p&gt;KubeDiag Master 负责管理 Operation、OperationSet、Trigger 和 Diagnosis 对象。当 OperationSet 创建后，KubeDiag Master 会进行合法性检查并基于用户定义生成有向无环图，所有的诊断路径被更新至 OperationSet 的元数据中。如果 OperationSet 中某个 Operation 的前置依赖诊断操作不存在，则该 OperationSet 会被标记为异常。&lt;/p&gt;&lt;p&gt;KubeDiag Master 会校验 Diagnosis 的 PodReference 或 NodeName 是否存在，如果 Diagnosis 中只定义了 PodReference，则根据 PodReference 计算并更新 NodeName。KubeDiag Master 会查询被 Diagnosis 引用的 OperationSet 状态，如果被引用的 OperationSet 异常，则标记 Diagnosis 失败。Diagnosis 可以由用户直接手动创建，也可以通过配置 Prometheus 报警模板或 Kubernetes 事件模板自动创建。&lt;/p&gt;&lt;p&gt;KubeDiag Master 由下列部分组成：&lt;/p&gt;&lt;h4&gt;图构建器&lt;/h4&gt;&lt;p&gt;图构建器基于 OperationSet 对象生成诊断运行流程图。图构建器根据 OperationSet 中包含的边生成有向无环图并计算出所有的诊断路径。&lt;/p&gt;&lt;h4&gt;Prometheus 报警管理器&lt;/h4&gt;&lt;p&gt;Prometheus 报警管理器接收 Prometheus 报警并创建 Diagnosis 对象。Prometheus 报警管理器可以接收 Prometheus 报警并与 Trigger 中定义的模板进行匹配，如果匹配成功则根据 Trigger 的元数据创建 Diagnosis 对象。&lt;/p&gt;&lt;h4&gt;Kafka 消息管理器&lt;/h4&gt;&lt;p&gt;Kafka 消息管理器接收 Kafka 消息并创建 Diagnosis 对象。Kafka 消息的值必须是一个 JSON 对象并且包含创建 Diagnosis 所需的元信息。&lt;/p&gt;&lt;h4&gt;事件管理器&lt;/h4&gt;&lt;p&gt;事件管理器接收 Kubernetes 事件并创建 Diagnosis 对象。事件管理器可以接收 Kubernetes 事件并与 Trigger 中定义的模板进行匹配，如果匹配成功则根据 Trigger 的元数据创建 Diagnosis 对象。&lt;/p&gt;&lt;h3&gt;KubeDiag Agent 设计&lt;/h3&gt;&lt;p&gt;KubeDiag Agent 负责实际诊断工作的执行并内置多个常用诊断操作。当 Diagnosis 创建后，KubeDiag Agent 会根据 Diagnosis 引用的 OperationSet 执行诊断工作流，诊断工作流是包括多个诊断操作的集合。&lt;/p&gt;&lt;p&gt;KubeDiag Agent 组件由下列部分组成：&lt;/p&gt;&lt;h4&gt;执行器&lt;/h4&gt;&lt;p&gt;执行器负责执行诊断工作流。Diagnosis 引用的 OperationSet 元数据中包含表示诊断工作流的有向无环图和所有的诊断路径。诊断路径表示诊断过程中的排查路径，通过执行某个诊断路径中每个顶点的诊断操作可以对问题进行排查。如果某个诊断路径的所有诊断操作均执行成功，则该次诊断被标记为成功。如果所有诊断路径均执行失败，则该次诊断被标记为失败。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;实现细节&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KubeDiag 通过实现 Operation、OperationSet、Trigger 和 Diagnosis 自定义资源对一次运维诊断的过程进行抽象。&lt;/p&gt;&lt;h3&gt;对于诊断的管理&lt;/h3&gt;&lt;p&gt;KubeDiag 通过支持下列功能来满足用户管理诊断的需求：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;指定诊断的目标 Node 或 Pod。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看当前诊断的阶段。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过参数扩展诊断的状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;诊断成功时查看诊断的结果以及排查路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;诊断失败时查看失败的原因以及排查路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看诊断过程中某个阶段的详细信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Diagnosis 对象&lt;/h4&gt;&lt;p&gt;Diagnosis 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// DiagnosisSpec 定义了 Diagnosis 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisSpec &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// OperationSet 是待执行诊断流水线的 OperationSet 名。&lt;/span&gt;&lt;br/&gt;    OperationSet &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;operationSet&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 必须指定 NodeName 或 PodReference 其中的一个字段。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// NodeName 是诊断执行的节点。&lt;/span&gt;&lt;br/&gt;    NodeName &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;nodeName,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// PodReference 包含目标 Pod 的详细信息。&lt;/span&gt;&lt;br/&gt;    PodReference *PodReference &lt;span&gt;`json:&quot;podReference,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Parameters 包含诊断过程中需要传入的参数。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 通常该字段的键为 OperationSet 中顶点的序号，值为执行该顶点诊断操作需要的参数。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Parameters 和 OperationResults 会被序列化为 JSON 对象并在运行诊断的过程中发送给故障处理器。&lt;/span&gt;&lt;br/&gt;    Parameters &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;parameters,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// PodReference 包含目标 Pod 的详细信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PodReference &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    NamespacedName &lt;span&gt;`json:&quot;,inline&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Container 是目标容器名。&lt;/span&gt;&lt;br/&gt;    Container &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;container,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NamespacedName 表示 Kubernetes API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; NamespacedName &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Namespace 是 Kubernetes API 对象命名空间。&lt;/span&gt;&lt;br/&gt;    Namespace &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;namespace&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Namespace 是 Kubernetes API 对象名。&lt;/span&gt;&lt;br/&gt;    Name &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;name&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisStatus 定义了 Diagnosis 的实际状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisStatus &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Phase 是 Diagnosis 在其生命周期中所处位置的简单宏观概述。状况列表包含更多关于 Diagnosis 状态的信息。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 阶段可能存在五种不同的值：&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Pending：Diagnosis 已被系统接受，但诊断执行前的准备工作还未完成。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Running：Diagnosis 已经绑定到了某个节点，至少有一个诊断操作正处于运行状态。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Succeeded：诊断流水线中某个路径中的所有诊断操作均执行成功。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Failed：诊断流水线中的所有路径失败。也就是说，所有路径中最后一个执行的诊断操作返回码非 200。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Unknown：因为某些原因无法取得 Diagnosis 的状态。这种情况通常是因为与 Diagnosis 所在主机通信失败。&lt;/span&gt;&lt;br/&gt;    Phase DiagnosisPhase &lt;span&gt;`json:&quot;phase,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Conditions 包含 Diagnosis 当前的服务状态。&lt;/span&gt;&lt;br/&gt;    Conditions []DiagnosisCondition &lt;span&gt;`json:&quot;conditions,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// StartTime 是对象被系统接收的 RFC 3339 日期和时间。&lt;/span&gt;&lt;br/&gt;    StartTime metav1.Time &lt;span&gt;`json:&quot;startTime,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// FailedPaths 包含诊断流水线中所有运行失败的路径。路径的最后一个顶点是操作执行失败的顶点。&lt;/span&gt;&lt;br/&gt;    FailedPaths []Path &lt;span&gt;`json:&quot;failedPath,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// SucceededPath 是诊断流水线中运行成功的路径。&lt;/span&gt;&lt;br/&gt;    SucceededPath Path &lt;span&gt;`json:&quot;succeededPath,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// OperationResults 包含诊断运行过程中操作的结果。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Parameters 和 OperationResults 会被序列化为 JSON 对象并在运行诊断的过程中发送给故障处理器。&lt;/span&gt;&lt;br/&gt;    OperationResults &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;operationResults,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Checkpoint 是恢复未完成诊断的检查点。&lt;/span&gt;&lt;br/&gt;    Checkpoint *Checkpoint &lt;span&gt;`json:&quot;checkpoint,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisCondition 包含 Diagnosis 当前的服务状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisCondition &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Type 是状况的类型。&lt;/span&gt;&lt;br/&gt;    Type DiagnosisConditionType &lt;span&gt;`json:&quot;type&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Status 是状况的状态。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 可以是 True、False、Unknown。&lt;/span&gt;&lt;br/&gt;    Status corev1.ConditionStatus &lt;span&gt;`json:&quot;status&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// LastTransitionTime 描述了上一次从某个状况迁移到另一个状况的时间。&lt;/span&gt;&lt;br/&gt;    LastTransitionTime metav1.Time &lt;span&gt;`json:&quot;lastTransitionTime,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Reason 是对上一次状况迁移的描述，该原因描述是唯一的、只包含单个词语的、符合驼峰命名法的。&lt;/span&gt;&lt;br/&gt;    Reason &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;reason,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Message 是描述上一次状况迁移细节的信息。&lt;/span&gt;&lt;br/&gt;    Message &lt;span&gt;string&lt;/span&gt; &lt;span&gt;`json:&quot;message,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Checkpoint 是恢复未完成诊断的检查点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Checkpoint &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// PathIndex 是当前路径在 OperationSet 状态中的序号。&lt;/span&gt;&lt;br/&gt;    PathIndex &lt;span&gt;int&lt;/span&gt; &lt;span&gt;`json:&quot;pathIndex&quot;`&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// NodeIndex 是当前顶点在路径中的序号。&lt;/span&gt;&lt;br/&gt;    NodeIndex &lt;span&gt;int&lt;/span&gt; &lt;span&gt;`json:&quot;nodeIndex&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisPhase 是描述当前 Diagnosis 状况的标签。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisPhase &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DiagnosisConditionType 是 Diagnosis 状况类型的合法值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; DiagnosisConditionType &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Diagnosis 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Diagnosis &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    metav1.TypeMeta   &lt;span&gt;`json:&quot;,inline&quot;`&lt;/span&gt;&lt;br/&gt;    metav1.ObjectMeta &lt;span&gt;`json:&quot;metadata,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Spec   DiagnosisSpec   &lt;span&gt;`json:&quot;spec,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;    Status DiagnosisStatus &lt;span&gt;`json:&quot;status,omitempty&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;管理诊断状态的迁移&lt;/h4&gt;&lt;p&gt;诊断实际上是一个有状态的任务，在诊断的生命周期中其状态可能发生多次迁移，管理诊断状态迁移的能力在很多场景中是必不可少的。&lt;/p&gt;&lt;p&gt;某个操作可能依赖特定格式的输入。Diagnosis 中的 &lt;code&gt;.spec.parameters&lt;/code&gt; 字段用于指定诊断过程中需要传入的参数。该字段是一个键值对，键和值均必须为 String 类型。当执行的操作依赖特定格式的输入时，用户可以在该字段中定义操作执行时需要输入的参数，操作处理器在获取参数后执行诊断操作。&lt;/p&gt;&lt;p&gt;某个操作可能依赖某个之前操作的输出。Diagnosis 中的 &lt;code&gt;.status.operationResults&lt;/code&gt; 字段用于记录诊断运行过程中操作的结果。该字段是一个键值对，键和值均必须为 String 类型。当前操作执行的结果必须以 JSON 对象的形式返回，返回结果会被更新到该字段中，如果后续操作的执行依赖当前操作的输出，那么后续操作处理器可以从 &lt;code&gt;.status.operationResults&lt;/code&gt; 中获取当前操作的结果。值得注意的是，如果在排查路径中如果有两个相同的操作对同一个键进行了更新，那么后执行操作的结果会覆盖先执行操作的结果。&lt;/p&gt;&lt;p&gt;用户需要分析排查路径中某个操作的结果并进行优化。Diagnosis 中的 &lt;code&gt;.status.failedPath&lt;/code&gt; 字段和 &lt;code&gt;.status.succeededPath&lt;/code&gt; 字段分别记录了所有运行失败的路径和成功的路径。每条路径由一个数组表示，数组的元素中包含顶点的序号和操作名。通过遍历路径可以还原操作执行的顺序，每个操作结果的访问信息被记录在 Operation 中的 &lt;code&gt;.spec.storage&lt;/code&gt; 字段。&lt;/p&gt;&lt;h4&gt;Diagnosis 阶段&lt;/h4&gt;&lt;p&gt;Diagnosis 包含 &lt;code&gt;.status.phase&lt;/code&gt; 字段，该字段是 Diagnosis 在其生命周期中所处位置的简单宏观概述。该阶段并不是对 Diagnosis 状态的综合汇总，也不是为了成为完整的状态机。Diagnosis 阶段的数量和含义是严格定义的。除了本文档中列举的内容外，不应该再假定 Diagnosis 有其他的阶段值。&lt;/p&gt;&lt;p&gt;下面是 &lt;code&gt;.status.phase&lt;/code&gt; 可能的值：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Pending：Diagnosis 已被系统接受，但诊断执行前的准备工作还未完成。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Running：Diagnosis 已经绑定到了某个节点，至少有一个诊断操作正处于运行状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Succeeded：诊断流水线中某个路径中的所有诊断操作均执行成功。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Failed：诊断流水线中的所有路径失败。也就是说，所有路径中最后一个执行的诊断操作返回码非 200。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Unknown：因为某些原因无法取得 Diagnosis 的状态。这种情况通常是因为与 Diagnosis 所在主机通信失败。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;基于图的诊断流水线&lt;/h3&gt;&lt;p&gt;我们在设计基于图的诊断流水线时主要考虑了以下假设条件：&lt;/p&gt;&lt;p&gt;KubeDiag 通过引入下列 API 对象实现了基于图的诊断流水线：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Operation：描述如何在诊断流水线中加入处理顶点以及如何存储该处理顶点产生的结果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;OperationSet：表示诊断过程状态机的有向无环图。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Trigger：描述如何通过 Prometheus 报警或 Kubernetes 事件触发一次诊断。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Operation 对象&lt;/h4&gt;&lt;p&gt;Operation 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// OperationSpec 定义了 Operation 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSpec&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Processor 描述了如何在 KubeDiag 中注册一个操作处理器。&lt;/span&gt;&lt;br/&gt;    Processor Processor `json:&lt;span&gt;&quot;processor&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Dependences 是所有被依赖且必须预先执行的诊断操作列表。&lt;/span&gt;&lt;br/&gt;    Dependences []string `json:&lt;span&gt;&quot;dependences,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Storage 表示操作处理结果的存储类型。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么操作处理结果不会被保存。&lt;/span&gt;&lt;br/&gt;    Storage *Storage `json:&lt;span&gt;&quot;storage,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Processor 描述了如何在 KubeDiag 中注册一个操作处理器。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Processor&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ExternalAddress 是操作处理器的监听地址。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么默认为 KubeDiag Agent 的地址。&lt;/span&gt;&lt;br/&gt;    ExternalAddress *string `json:&lt;span&gt;&quot;externalAddress,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// ExternalPort 是操作处理器的服务端口。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么默认为 KubeDiag Agent 的服务端口。&lt;/span&gt;&lt;br/&gt;    ExternalPort *int32 `json:&lt;span&gt;&quot;externalPort,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Path 是操作处理器服务的 HTTP 路径。&lt;/span&gt;&lt;br/&gt;    Path *string `json:&lt;span&gt;&quot;path,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Scheme 是操作处理器服务的协议。&lt;/span&gt;&lt;br/&gt;    Scheme *string `json:&lt;span&gt;&quot;scheme,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// 操作处理器超时的秒数。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 默认为 30 秒。最小值为 1。&lt;/span&gt;&lt;br/&gt;    TimeoutSeconds *int32 `json:&lt;span&gt;&quot;timeoutSeconds,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Storage 表示操作结果的存储类型。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Storage&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// HostPath 表示宿主机上的目录。&lt;/span&gt;&lt;br/&gt;    HostPath *HostPath `json:&lt;span&gt;&quot;hostPath,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// HostPath 表示宿主机上的目录。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;HostPath&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 宿主机上目录的路径。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果该字段为空，那么默认为 KubeDiag Agent 的数据根目录。&lt;/span&gt;&lt;br/&gt;    Path string `json:&lt;span&gt;&quot;path&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Operation 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Operation&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    metav1.TypeMeta   `json:&lt;span&gt;&quot;,inline&quot;&lt;/span&gt;`&lt;br/&gt;    metav1.ObjectMeta `json:&lt;span&gt;&quot;metadata,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    Spec OperationSpec `json:&lt;span&gt;&quot;spec,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;OperationSet 对象&lt;/h4&gt;&lt;p&gt;OperationSet 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// OperationSetSpec 定义了 OperationSet 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSetSpec&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// AdjacencyList 包含有向无环图中所有表示诊断操作的顶点。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 数组的第一个顶点表示诊断的开始而不是某个特定的诊断操作。&lt;/span&gt;&lt;br/&gt;    AdjacencyList []Node `json:&lt;span&gt;&quot;adjacencyList&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Node 是有向无环图中的一个顶点。它包含序号和操作名。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ID 是该顶点的唯一标识符。&lt;/span&gt;&lt;br/&gt;    ID int `json:&lt;span&gt;&quot;id&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// To 是从该顶点能够直接到达的顶点序号列表。&lt;/span&gt;&lt;br/&gt;    To NodeSet `json:&lt;span&gt;&quot;to,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Operation 是在该顶点运行的操作名。&lt;/span&gt;&lt;br/&gt;    Operation string `json:&lt;span&gt;&quot;operation&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Dependences 是所有被依赖且必须预先执行的诊断操作 ID 列表。&lt;/span&gt;&lt;br/&gt;    Dependences []int `json:&lt;span&gt;&quot;dependences,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NodeSet 是一组顶点序号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;NodeSet&lt;/span&gt;&lt;/span&gt; []int&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// OperationSetStatus 定义了 OperationSet 的实际状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSetStatus&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Paths 是有向无环图中所有诊断路径的集合。&lt;/span&gt;&lt;br/&gt;    Paths []Path `json:&lt;span&gt;&quot;paths,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// 表示定义中提供的顶点是否能生成合法的有向无环图。&lt;/span&gt;&lt;br/&gt;    Ready &lt;span&gt;bool&lt;/span&gt; `json:&lt;span&gt;&quot;ready,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Path 表示与所有边方向一致的顶点线性顺序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Path&lt;/span&gt;&lt;/span&gt; []Node&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// OperationSet 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;OperationSet&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    metav1.TypeMeta   `json:&lt;span&gt;&quot;,inline&quot;&lt;/span&gt;`&lt;br/&gt;    metav1.ObjectMeta `json:&lt;span&gt;&quot;metadata,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    Spec OperationSetSpec `json:&lt;span&gt;&quot;spec,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    Status OperationSetStatus `json:&lt;span&gt;&quot;status,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Trigger 对象&lt;/h4&gt;&lt;p&gt;Trigger 对象的数据结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// TriggerSpec 定义了 Trigger 的目标状态。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;TriggerSpec&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// OperationSet 是生成 Diagnosis 中引用的 OperationSet 名。&lt;/span&gt;&lt;br/&gt;    OperationSet string `json:&lt;span&gt;&quot;operationSet&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// SourceTemplate 是用于生成 Diagnosis 的模板源。&lt;/span&gt;&lt;br/&gt;    SourceTemplate SourceTemplate `json:&lt;span&gt;&quot;sourceTemplate&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// SourceTemplate 描述用于生成 Diagnosis 的信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;SourceTemplate&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 下列源中必须指定一个唯一的模板源。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// PrometheusAlertTemplate 声明基于 Prometheus 报警创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;    PrometheusAlertTemplate *PrometheusAlertTemplate `json:&lt;span&gt;&quot;prometheusAlertTemplate,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// KubernetesEventTemplate 声明基于 Event 创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;    KubernetesEventTemplate *KubernetesEventTemplate `json:&lt;span&gt;&quot;kubernetesEventTemplate,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// PrometheusAlertTemplate 声明基于 Prometheus 报警创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;PrometheusAlertTemplate&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Regexp 是用于匹配 Prometheus 报警模板的正则表达式。&lt;/span&gt;&lt;br/&gt;    Regexp PrometheusAlertTemplateRegexp `json:&lt;span&gt;&quot;regexp&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// NodeNameReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.nodeName&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    NodeNameReferenceLabel model.LabelName `json:&lt;span&gt;&quot;nodeNameReferenceLabel&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// PodNamespaceReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.podReference.namespace&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    PodNamespaceReferenceLabel model.LabelName `json:&lt;span&gt;&quot;podNamespaceReferenceLabel,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// PodNameReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.podReference.name&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    PodNameReferenceLabel model.LabelName `json:&lt;span&gt;&quot;podNameReferenceLabel,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// ContainerReferenceLabel 指定用于设置 Diagnosis 的 &quot;.spec.podReference.container&quot; 字段的标签键。&lt;/span&gt;&lt;br/&gt;    ContainerReferenceLabel model.LabelName `json:&lt;span&gt;&quot;containerReferenceLabel,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// ParameterInjectionLabels 指定需要注入到 &quot;.spec.parameters&quot; 字段的标签键列表。&lt;/span&gt;&lt;br/&gt;    ParameterInjectionLabels []model.LabelName `json:&lt;span&gt;&quot;parameterInjectionLabels,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// PrometheusAlertTemplateRegexp 是用于匹配 Prometheus 报警模板的正则表达式。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所有的正则表达式必须遵循 RE2 规范，详情可参考 https://golang.org/s/re2syntax。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;PrometheusAlertTemplateRegexp&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// AlertName 是用于匹配 Prometheus 报警的 AlertName 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    AlertName string `json:&lt;span&gt;&quot;alertName,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Labels 是用于匹配 Prometheus 报警的 Labels 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 只有标签的值为正则表达式并且所有标签均与 Prometheus 报警一致时才可以成功匹配。&lt;/span&gt;&lt;br/&gt;    Labels model.LabelSet `json:&lt;span&gt;&quot;labels,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Annotations 是用于匹配 Prometheus 报警的 Annotations 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 只有注解的值为正则表达式并且所有注解均与 Prometheus 报警一致时才可以成功匹配。&lt;/span&gt;&lt;br/&gt;    Annotations model.LabelSet `json:&lt;span&gt;&quot;annotations,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// StartsAt 是用于匹配 Prometheus 报警的 StartsAt 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    StartsAt string `json:&lt;span&gt;&quot;startsAt,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// EndsAt 是用于匹配 Prometheus 报警的 EndsAt 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    EndsAt string `json:&lt;span&gt;&quot;endsAt,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// GeneratorURL 是用于匹配 Prometheus 报警的 GeneratorURL 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    GeneratorURL string `json:&lt;span&gt;&quot;generatorURL,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// KubernetesEventTemplate 声明基于 Event 创建 Diagnosis 的模板。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;KubernetesEventTemplate&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Regexp 是用于匹配 Event 模板的正则表达式。&lt;/span&gt;&lt;br/&gt;    Regexp KubernetesEventTemplateRegexp `json:&lt;span&gt;&quot;regexp&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// KubernetesEventTemplateRegexp 是用于匹配 Event 模板的正则表达式。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所有的正则表达式必须遵循 RE2 规范，详情可参考 https://golang.org/s/re2syntax。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;KubernetesEventTemplateRegexp&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Name 是用于匹配 Event 的 Name 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Name string `json:&lt;span&gt;&quot;name,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Namespace 是用于匹配 Event 的 Namespace 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Namespace string `json:&lt;span&gt;&quot;namespace,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Reason 是用于匹配 Event 的 Reason 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Reason string `json:&lt;span&gt;&quot;reason,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Message 是用于匹配 Event 的 Message 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    Message string `json:&lt;span&gt;&quot;message,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;span&gt;// Source 是用于匹配 Event 的 Source 字段的正则表达式。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所有 Source 中的字段均为正则表达式。&lt;/span&gt;&lt;br/&gt;    Source corev1.EventSource `json:&lt;span&gt;&quot;source,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Trigger 的 API 对象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Trigger&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    metav1.TypeMeta   `json:&lt;span&gt;&quot;,inline&quot;&lt;/span&gt;`&lt;br/&gt;    metav1.ObjectMeta `json:&lt;span&gt;&quot;metadata,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    Spec TriggerSpec `json:&lt;span&gt;&quot;spec,omitempty&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;注册诊断操作&lt;/h4&gt;&lt;p&gt;诊断操作表示在诊断流水线中运行的某个逻辑，是对诊断流水线管理的最小单元，例如获取节点信息、对日志中的关键字进行匹配、对进程进行性能剖析等。通过创建 Operation 对象可以注册诊断操作。诊断操作的后端是一个 HTTP 服务器。注册诊断操作时需要指定 HTTP 服务器监听的地址、路径、诊断结果的存储类型等。&lt;/p&gt;&lt;h4&gt;注册诊断流水线&lt;/h4&gt;&lt;p&gt;诊断流水线是多个诊断操作的集合，通常一次诊断可能有多个排查路径，所以一次诊断的状态机通过有向无环图进行抽象。通过创建 OperationSet 对象可以定义表示诊断状态机的有向无环图。诊断开始的状态为有向无环图的起点，有向无环图中的路径均为诊断过程中的排查路径，当某条路径可以成功运行到终点时则表示诊断运行成功。诊断流水线的生成逻辑如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户创建 OperationSet 资源并定义有向无环图中所有的边。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据 OperationSet 的定义构建有向无环图。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果无法构建合法的有向无环图，则将注册失败的状态和失败原因更新到 OperationSet 中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;枚举 OperationSet 中所有的诊断路径并更新到 OperationSet 中。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;表示诊断流水线的有向无环图必须只包含一个源顶点（Source Node），该顶点用于表示诊断的开始状态且不包含任何诊断操作。诊断路径是任何从源顶点到任意阱顶点（Sink Node）的路径。诊断路径不包括表示诊断的开始状态的源顶点。图构建器通过搜索出有向无环图中所有的诊断路径并更新至 OperationSet 的 &lt;code&gt;.status.paths&lt;/code&gt; 字段。&lt;/p&gt;&lt;h4&gt;触发诊断&lt;/h4&gt;&lt;p&gt;Diagnosis 对象的元数据中包含了需要执行的 OperationSet。触发诊断包括手动和自动两种方式。通过手动创建 Diagnosis 对象可以直接触发诊断。通过创建 Trigger 对象并配置 Prometheus 报警模板或 Event 模板可以基于 Prometheus 或 Event 自动生成 Diagnosis 以触发诊断流水线。&lt;/p&gt;&lt;h4&gt;运行诊断流水线&lt;/h4&gt;&lt;p&gt;Diagnosis 对象的元数据中记录了诊断流水线的运行状态。诊断流水线的运行逻辑如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获取被 Diagnosis 引用的 OperationSet 中所有的诊断路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;按照诊断执行路径中 Operation 定义的诊断操作，将 Operation 运行的结果更新到 Diagnosis 中并持久化到 Operation 中相应的存储类型。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果路径中定义的某个诊断操作执行失败，则执行下一条诊断路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果路径中定义的所有诊断操作均执行成功，则该次诊断成功。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果所有路径均无法成功，则该次诊断失败。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3493975903614458&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSJxhDBBypKiaKTcOibiaq8tkxeUS00Pk1SAcQ4ZaxsaUXjGFqvwbEEzZJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;上列为一个表示诊断流水线的有向无环图，每个节点代表一个 Operation，该图的诊断路径表示多个可执行的排查路径：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;数据收集 1、数据分析 1、恢复 1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据收集 1、数据分析 1、恢复 2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据收集 2、数据分析 2、恢复 2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据收集 3、数据收集 4&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;典型用例&lt;/h3&gt;&lt;p&gt;下列文件定义了一个用于处理 Docker 问题的 OperationSet：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;diagnosis.kubediag.org/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;OperationSet&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;docker-debugger&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;adjacencyList:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;docker-info-collector&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;dockerd-goroutine-collector&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;containerd-goroutine-collector&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;to:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;node-cordon&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一次通过 KubeletPlegDurationHigh 报警触发 Docker 问题诊断的流程如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户成功创建处理 Docker 问题的 OperationSet。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户成功创建基于 KubeletPlegDurationHigh 报警触发诊断的 Trigger&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KubeletPlegDurationHigh 报警被发送至 KubeDiag Master。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KubeDiag Master 根据报警中的信息创建 Diagnosis。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Diagnosis 在触发报警的节点上执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;诊断执行结束。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.638594802694899&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/iaOz7l1bIBYA2ibCpPz4SSMpB7emIibZtQSd97pOP0V8bFicY1ZEs7y6ibAQiaqO7wbtg4zpWQPE12eTeMZpcQic1rfpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4156&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;欢迎加入 KubeDiag 社区&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;最后，KubeDiag 社区目前还在草创阶段，欢迎大家踊跃加入 KubeDiag 社区，共同提升 Kubernetes 的自动化程度，解决后容器时代的使用难题，推动云原生技术在全球落地应用。&lt;/p&gt;&lt;p&gt;&lt;span&gt;KubeDiag 项目主页：https://kubediag.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;KubeDiag 项目地址：https://github.com/kubediag/kubediag&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫码加入 KubeDiag 微信群：https://kubediag.nos-eastchina1.126.net/QR%20Code.jpeg&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易数帆开源开源主页：https://sf.163.com/opensource&lt;/span&gt;&lt;/p&gt;&lt;p&gt;作者：黄久远，网易数帆云原生技术专家，KubeDiag Maintainer。&lt;/p&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934821&quot; data-style-type=&quot;&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-xmtstyleindex=&quot;0&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1058.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-style=&quot;margin-top: -10px; padding-right: 10px; padding-left: 10px; font-size: 16px; color: black; line-height: 1.6; letter-spacing: 0px; word-break: break-word; overflow-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif;&quot; data-xmt-x1=&quot;381.5&quot; data-xmt-y1=&quot;4647.640625&quot; data-xmt-x2=&quot;1038.5&quot; data-xmt-y2=&quot;5940.220625&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); font-family: 微软雅黑; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;paragraph&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot; data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot; data-xmt-x1=&quot;391.5&quot; data-xmt-y1=&quot;5894.640625&quot; data-xmt-x2=&quot;1048.5&quot; data-xmt-y2=&quot;5940.218725&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-color-16026770102743=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16026770102743=&quot;rgb(0,0,0)&quot; data-darkmode-bgcolor-16026770102743=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16026770102743=&quot;rgb(255, 255, 255)&quot;&gt;&lt;h4&gt;关于云原生社区&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3934837&quot; data-style-type=&quot;&quot;&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section data-id=&quot;90196&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。云原生社区基于成员兴趣创建了多个 SIG（特别兴趣小组），如 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649382008&amp;amp;idx=2&amp;amp;sn=8329de15872f67151e76e4dc2ece84eb&amp;amp;chksm=f224d617c5535f015e3d71a3d21c234bc333653792c85646c13b2a260a4ac2381e06fc0bf8f4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kubernetes&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384221&amp;amp;idx=2&amp;amp;sn=04c5062a448e9696e9296a02e82837c3&amp;amp;chksm=f224ef72c553666444b33121ae42dbf4e7609574c29e4c55b84f9f6e2cb5bae88a037f2248d2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Istio&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=2&amp;amp;sn=6188dfb44c7a7313a252879a0044b406&amp;amp;chksm=f224ef1bc553660df3b77ff63bd969a4aec56fc5a64a5cf202fb56a507fa0b13588f56384b4e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Envoy&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384308&amp;amp;idx=3&amp;amp;sn=c144874967206a7d0abe0b66e36cc03f&amp;amp;chksm=f224ef1bc553660d9f32e206c5a9e1424a60f49ced76b3d5925d0bffa09eacbe14b1da8b512a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Dapr&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384269&amp;amp;idx=2&amp;amp;sn=baaa3c95835c663c7141406b8ac1293b&amp;amp;chksm=f224ef22c553663436fcbeab26d97abe166f82b8880fc5531d2157ab89b760457ba8664a1d39&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;OAM&lt;/a&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384175&amp;amp;idx=1&amp;amp;sn=ea9058418afd668967e28a3ba211d649&amp;amp;chksm=f224ee80c5536796af57f48c8ee7e242a2b1478645ce823d711be263587576362744eac8121d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;边缘计算&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384137&amp;amp;idx=1&amp;amp;sn=d14055b1b5408a30db96d8e132a046ab&amp;amp;chksm=f224eea6c55367b0058a971ea579e9b1f7cb70e3d39eb4f36b64f9cab924a2b4c3fc845681f2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;机器学习&lt;/a&gt;&lt;span&gt;、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383872&amp;amp;idx=1&amp;amp;sn=b6a3c43ce750ea923fed04592c5b7cfd&amp;amp;chksm=f224e9afc55360b912fd2e0d1a9ab4cc66a22deb81db8f07bc3a83146f370cb388ae53c44ef6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;可观察性&lt;/a&gt;&lt;span&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649384467&amp;amp;idx=3&amp;amp;sn=9a8fe5c24d9458d0113c59604b6ab5e8&amp;amp;chksm=f224ec7cc553656aa33f3304608cc24423d3aca7f0d64ae9e50da2850ce5c4df0d4ff9cc013f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;稳定性&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;稳定性&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649385565&amp;amp;idx=2&amp;amp;sn=e3a6a1adf84c3ac9e552ba0c2b18d162&amp;amp;chksm=f224e032c5536924c330945872154b83245b19f91c401e21eddd882791c64b914d68fd51a93e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;安全&lt;/a&gt;等&lt;/span&gt;&lt;span&gt;。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NTE2NDE2MA==&amp;amp;mid=2649383149&amp;amp;idx=3&amp;amp;sn=6012d51c80d0b8f84db58e514448ad11&amp;amp;chksm=f224ea82c553639460af375bb1f172ba94502c5599eb2a4e4df52287f98db29e3858ae09373d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击了解我们&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;点击了解我们&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1NTE2NDE2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/06ULcDvaIGmqt5TicIcR8qFEjicfezMe4YuBlNbN8vl8Mh1fePHOrPibvlqJseGaG4ctibamAhKHMP3xOEW3ByibOjw/0?wx_fmt=png&quot; data-nickname=&quot;Cloud Native Community&quot; data-alias=&quot;CloudNativeCN&quot; data-signature=&quot;云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。社区官网 https://cloudnative.to&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-v-09862f0b=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;点击下方“阅读原文”查看更多&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>52fbda1aec8ad2a138f46a09eb0a3c64</guid>
<title>大前端开发中的路由管理（三）：Android 篇</title>
<link>https://toutiao.io/k/jjix6xq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        我们通常认为Android开发中的路由管理主要分为两部分，Android原生页面栈和混合开发页面栈。&lt;/span&gt;&lt;span&gt;在native原生页面中，使用最多的是四大组件之一的Activity和依托于其的Fragment。&lt;/span&gt;&lt;span&gt;在混合开发页面中，通常又分为Activity-H5(WebView)，Activity-Weex/React-Native，和Activity-Flutter这几种跨平台的页面交互方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;1、原生之Activity的页面跳转与管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1.1&lt;span/&gt;从Activity启动模式入手&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在Android开发中，在默认的情况下（Standard 标准启动模式），如果我们多次启动同一个Activity，系统会创建多个实例并把它们一一放入任务栈中。当我们点击返回键进行页面切换时，会将这些Activity实例从任务栈中逐个移除，遵循先进后出的原则。出于多次启动同一个Activity，系统创建多个实例放入任务栈中会耗费内存资源的考虑，Android为Actiivty提供了启动模式，不同的模式会影响Activity返回时的页面跳转行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        我们知道Activity的启动模式有4种，具体如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0950226244343892&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCEYG6OPcFjQGYR077aOrUmTeLgDmxiaWhSEfkibXc4ATV414Y4A363C3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;442&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        Standard 标准启动模式。每启动Activity都会创建一个新的实例置于任务栈栈顶。如图当页面返回时，Activity B出栈销毁，会进入当前Activity A任务栈新的栈顶Activity。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;198&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCJuKHQaaLDmdLF42icxpyK0VCYrXeGK5BvdWUJg7EpGaqaic0HKgWib2cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        Single Top 栈顶复用模式。当需要新建的Activity处于栈顶，则重用该Activity实例，否则新建该Activity并将其置于栈顶。该模式不会对任务栈中存在的Activity实例造成顺序上的影响，当页面返回时，会按照先进后出的顺序跳转进新的栈顶Activity。     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;250&quot; data-backw=&quot;571&quot; data-ratio=&quot;0.437046004842615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCH7ic9zcOdVcDqq5FzhjTN9nwvzRsUBHYW5RKvGHKuMuPsgkIOHkAcAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        Single Task 栈内复用模式。当需要新建的Activity想要的任务栈（通过TaskAffinity指定）不存在，则先创建该任务栈，新建该Activity实例并将其置于栈顶；若该任务栈存在，判断该Activity是否存在于栈中，若存在，则将其之上的Activity实例全部出栈，使其置于栈顶，重用该Activity实例；否则新建该Activity并将其置于栈顶。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        该模式可能会对任务栈中存在的Activity实例造成顺序上的影响，若将目标Activity之上的实例全部出栈，当页面返回时，会按照先进后出的顺序跳转进剩余的任务栈实例中。&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0852017937219731&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCkWDfYBp9bZ8XOGK1B2RRtluib0zjricX8WeFzZicGTwjgPmhhJr1Cy8rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;446&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        &lt;span&gt;Single Instance 单例复用模式。新建一个任务栈B并新建该Activity实例并置于栈顶。&lt;/span&gt;&lt;span&gt;当页面返回时，会返回并使用打开该Activity之前的任务栈A，按照先进后出的顺序跳转进任务栈A的栈顶Activity。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        可以看到，不同的启动模式会影响Activity返回时的页面跳转行为，一些模式下会对任务栈及其内的Activity顺序产生改变，开发过程中需要根据不同场景选择不同模式，同时充分考虑其产生的对返回时页面跳转行为的影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;        在Activity页面之间的跳转管理中，对于这些Activity的创建、回退、跳转、复用等，Android提供了完备的AMS(ActivityManagerService)管理机制。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;558&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9656992084432717&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwC6JlUzAQDYSHZB45mkmdq0ebkYNyiciaWsQvstoGO2fPiaCzAbNBxWzxSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;        ActivityManagerService被用来管理Android四大组件，在对于Activity的管理中，主要体现在任务栈上。主要的任务栈管理模型如上图，可以从中看出ctivityRecord、TaskRecord和ActivityStack三者间的管理、包含关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;255&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44166666666666665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCbnCOI9MKgTtiaSj0tY2jbnbPzg2zia6jNMPq23AQXLNJYQWfGicXdBVkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;        上图是三者的UML类图。根据图中的主要关系与类方法，我们更加容易理解其主要职责：ActivityRecord 是应用层Activity组件在AMS的代表，每个启动的Activity都有一个与之对应的ActivityRecord实例。TaskRecord 是任务栈（也叫做返回栈），遵循先进后出的栈原则，栈内用来记录APP跳转过程中的ActivityRecord集合。ActivityStack 是用于管理任务栈TaskRecord而维护的集合，一般情况下栈内管理着位于前台的TaskRecord和数个后台TaskRecord。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        可以看到，此三者贯穿AMS管理Activity的整个逻辑，任务栈管理模型为我们提供了灵活的Activity的创建、回退、跳转、复用等页面栈操作的实现。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;1.2&lt;span/&gt;Activity间的页面桥梁-Intent&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        当我们需要进行不同Activity之间的跳转时，需要用到启动Activity的桥梁：显式Intent &amp;amp; 隐式Intent。下面以两个Activity之间的跳转为例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Intent intent = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Intent(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, SecondActivity.class); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; startActivity(intent);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Intent intent = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Intent(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; intent.addCategory(Intent.CATEGORY_DEFAULT); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; intent.setAction(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com.test.action&quot;&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; startActivity(intent);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_VIEW, Uri.parse(Url))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        可以看到，显式调用需要明确指定被启动对象的组件信息，包括包名和类名。一般是在同一个应用程序内部使用的。隐式调用通过Intent Filter来实现，Android系统会根据在隐式意图中设置的动作（action）、类别（category）、Data（URI和数据类型）找到合适的组件来处理这个意图。一般用于不同的应用程序之间。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        从启动对象来看，显式Intent通过明确启动对象的组件信息使得有固定的接收方，隐式Intent通过Intent Filter过滤匹配合适的启动对象；从使用场景上看，在同一项目下的页面跳转可以使用显式Intent，跨项目的页面跳转官方推荐使用隐式Intent；对于同一个Intent既有显式又有隐式调用，则以显式调用为主。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、原生之Fragment的页面跳转与管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.1&lt;span/&gt;Fragment与Activity间的页面跳转&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;        Fragment 的发明是为了灵活的布局和复用布局，比如在屏幕较大的 Pad 上，可以一个 Activity 左边呈现 A，右边呈现 B。下图是其生命周期：&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;657&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1367713004484306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCYO1zoibRiae7bdINW5xUUOvQJQSZzVVkgSUia0ia6s6rsqOBDjTwu5GwBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+11*2*3*4*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;考虑到Fragment与Activity之间的页面跳转，无非在于以下四种：\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:5}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        考虑到Fragment与Activity之间的页面跳转，无非在于以下四种：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ①  activity1_fragment1 -&amp;gt; fragment2  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ②  activity1_fragment1 -&amp;gt; activity2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ③  activity1_fragment1 -&amp;gt; activity2_fragment2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ④  activity1 -&amp;gt; activity2_fragment2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+4h*0*1*2+16*0*1+4*0*1*2+1*3*4*5*6*0*1+1*0*1+1w*7*8*9*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;可以看到包含单Activity多Fragment跳转、多Activity多Fragment跳转，以及Activity与Fragment相互跳转。由于Fragment 没有继承 View，是被添加到 Activity 的某个 ViewGroup 中，并且具有完整的生命周期，其生命周期受宿主 Activity 生命周期影响。可以简单地理解，Fragment 是具有类似于 Activity 生命周期和返回栈的视图容器。\\b所以对于Fragment与Activity之间进行页面跳转时，只需要理清其生命周期的对应关系和依赖关系，处于复杂情况下仍然万变不离其宗。\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;ch-comments\&amp;quot;,\&amp;quot;4mr7wn\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;custom-box-type\&amp;quot;,\&amp;quot;comment_placeholder\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;custom-box-data\&amp;quot;,\&amp;quot;4mr7wn\&amp;quot;],\&amp;quot;5\&amp;quot;:[\&amp;quot;drawing-c-type\&amp;quot;,\&amp;quot;embedcomment\&amp;quot;],\&amp;quot;6\&amp;quot;:[\&amp;quot;container-type\&amp;quot;,\&amp;quot;drawing\&amp;quot;],\&amp;quot;7\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;8\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;9\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:10}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        可以看到包含单Activity多Fragment跳转、多Activity多Fragment跳转，以及Activity与Fragment相互跳转。由于Fragment 没有继承 View，是被添加到 Activity 的某个 ViewGroup 中，并且具有完整的生命周期，其生命周期受宿主 Activity 生命周期影响。可以简单地理解，Fragment 是具有类似于 Activity 生命周期和返回栈的视图容器。所以对于Fragment与Activity之间进行页面跳转时，只需要理清其生命周期的对应关系和依赖关系，处于复杂情况下仍然万变不离其宗。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.2&lt;span/&gt;Navigation路由框架&lt;/span&gt;&lt;/h2&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+28*0*1*2*3+8*4*5*6*7*0*1*2+1*0*1+j*8*9*a*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;Navigation是一个页面路由导航框架，简化了单Activity多Fragment之间的跳转，本质上是封装的一套跳转逻辑，我们在使用时只要将所有的需要跳转的Fragment\\b全部放到布局里面后通过简单的调用即可。\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;background-color\&amp;quot;,\&amp;quot;transparent\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;ch-comments\&amp;quot;,\&amp;quot;ss8rwy\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;custom-box-type\&amp;quot;,\&amp;quot;comment_placeholder\&amp;quot;],\&amp;quot;5\&amp;quot;:[\&amp;quot;custom-box-data\&amp;quot;,\&amp;quot;ss8rwy\&amp;quot;],\&amp;quot;6\&amp;quot;:[\&amp;quot;drawing-c-type\&amp;quot;,\&amp;quot;embedcomment\&amp;quot;],\&amp;quot;7\&amp;quot;:[\&amp;quot;container-type\&amp;quot;,\&amp;quot;drawing\&amp;quot;],\&amp;quot;8\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;9\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;10\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:11}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        Navigation是一个页面路由导航框架，简化了单Activity多Fragment之间的跳转，本质上是封装的一套跳转逻辑，我们在使用时只要将所有的需要跳转的&lt;/span&gt;&lt;span&gt;Fragment&lt;/span&gt;&lt;span&gt;全部放到布局里面后通过简单的调用即可。&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;696&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2037037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwC8iboXpqichrIYMzfMWWm8dr6KrTsLfXicP7CNOFY1j8bxrgiaOZe0lFsZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+51*2*3*4*0*1+1*0*1+f*2*3*4*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;Navigation和Flutter的路由有一定的相似性，这里是将frament作为跳转点，在开发时，可以清晰地看到每个界面的跳转路径。同时，Navigation 组件提供管理所有返回堆栈的功能，堆栈的顶部为当前屏幕，堆栈中记录着访问的目的地顺序，堆栈的底部是应用的起始地，同时提供了相关更改返回栈的方法，使得我们可以灵活在不同Fragment之间实现页面跳转。\\n其实现页面栈跳转的原理主要是：\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:5}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        Navigation和Flutter的路由有一定的相似性，这里是将frament作为跳转点，在开发时，可以清晰地看到每个界面的跳转路径。同时，Navigation 组件提供管理所有返回堆栈的功能，堆栈的顶部为当前屏幕，堆栈中记录着访问的目的地顺序，堆栈的底部是应用的起始地，同时提供了相关更改返回栈的方法，使得我们可以灵活在不同Fragment之间实现页面跳转。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        其实现页面栈跳转的原理主要是：&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;288&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4981481481481482&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwC9QC2J2v4uvHwtWpaYkrBW1kCaic2BiclZjaZqz0XeRvNrHoCNRxpOrgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;3、混合开发的页面跳转与管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+2w*2*3*4*0*1+1*0*1+m*0*1*5+6*6*7*8*9*0*1+1*0*1*a+o*0*1+o*2*3*4*0*1+1*0*1+1s*2*3*4*0*1+1*0*1+1p*2*3*4*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;跨平台层作为前端与Native的中间混合层，主要目标是为Hybrid/Weex/Fultter/RN（或者其他跨平台方案）提供更好的服务能力或者互动能力（比如获取地理位置信息或者设置容器导航标题与按钮等等）。\\nWeb技术：主要依赖于WebView的技术，功能支持受限\\b（如在需要频繁拖拽且显示动画的场景下流畅度下降），比如PhoneGap、Cordova、小程序。\\n原生渲染：使用JavaScript做为编程语言，经过中间层转化为原生控件来渲染UI界面，比如React Native、Weex。\\n自渲染技术：自行实现一套渲染框架，可经过调用skia等方式完成自渲染，而不依赖于原生控件，比如Flutter、Unity。\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;],\&amp;quot;5\&amp;quot;:[\&amp;quot;ch-comments\&amp;quot;,\&amp;quot;xgnwtb\&amp;quot;],\&amp;quot;6\&amp;quot;:[\&amp;quot;custom-box-type\&amp;quot;,\&amp;quot;comment_placeholder\&amp;quot;],\&amp;quot;7\&amp;quot;:[\&amp;quot;custom-box-data\&amp;quot;,\&amp;quot;xgnwtb\&amp;quot;],\&amp;quot;8\&amp;quot;:[\&amp;quot;drawing-c-type\&amp;quot;,\&amp;quot;embedcomment\&amp;quot;],\&amp;quot;9\&amp;quot;:[\&amp;quot;container-type\&amp;quot;,\&amp;quot;drawing\&amp;quot;],\&amp;quot;10\&amp;quot;:[\&amp;quot;background-color\&amp;quot;,\&amp;quot;transparent\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:11}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        跨平台层作为前端与Native的中间混合层，主要目标是为Hybrid/Weex/Fultter/RN（或者其他跨平台方案）提供更好的服务能力或者互动能力（比如获取地理位置信息或者设置容器导航标题与按钮等等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        Web技术：主要依赖于WebView的技术，功能支持受限（如在需要频繁拖拽且显示动画的场景下流畅度下降），比如PhoneGap、Cordova、小程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        原生渲染：使用JavaScript做为编程语言，经过中间层转化为原生控件来渲染UI界面，比如React Native、Weex。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        自渲染技术：自行实现一套渲染框架，可经过调用skia等方式完成自渲染，而不依赖于原生控件，比如Flutter、Unity。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;270&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;29&quot; data-cropselx2=&quot;535&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;236&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4180478821362799&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwC0DbHY4tF1jwWQMrrqJoZibSkPL8dI9h16s1FKaHvncP3C98ocKmtHsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/p&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;3.1&lt;span/&gt;Activity-H5(webview)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        我们知道在Android原生控件与WebView的混合开发中，Activity通过在布局内置WebView控件来加载目标H5；WebView通过显式/隐式调用Intent实现跳转到native页面，WebView本身可以通过常见的工具类如WebSettings、WebViewClient、WebChromeClient实现配置、加载与请求处理。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;121&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20910780669144982&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCyGfRuibyPiboR7pfL2D6X44fw5QylCubDuaK2L4juMYnH4mtETq9tcTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;需&lt;/span&gt;&lt;span&gt;要关注的是，当由Activity跳转进入WebView，伴随着从Activity任务栈进入H5任务栈，如果我们希望接下来在H5内做页面前进或后退页面跳转，如按下返回键后不返回Activity任务栈，而是实现WebView任务栈的后退，则需要根据WebView提供的一些判断网页是否可以前进后退的api，&lt;/span&gt;&lt;span&gt;拦截对于返回键的监听以实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Webview.canGoBack &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Webview.goBack &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Webview.canGoForward &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Webview.goForward &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; boolean &lt;span class=&quot;code-snippet__title&quot;&gt;onKeyDown&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; keyCode, KeyEvent &lt;span class=&quot;code-snippet__keyword&quot;&gt;event&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((keyCode == KEYCODE_BACK) &amp;amp;&amp;amp; mWebView.canGoBack) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mWebView.goBack;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; super.onKeyDown(keyCode, &lt;span class=&quot;code-snippet__keyword&quot;&gt;event&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3.2&lt;span/&gt;Activity-Weex、React-Native&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+2v*2*3*4*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;Weex和React-Native经过中间层转化为原生控件来渲染UI界面(通过一套规则，映射到原生控件)。Activity-Weex之间的页面跳转和Activity-React Native原理上是类似的。\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:5}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        Weex和React-Native经过中间层转化为原生控件来渲染UI界面(通过一套规则，映射到原生控件)。Activity-Weex之间的页面跳转和Activity-React Native原理上是类似的。&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;156&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26963906581740976&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwC1sK4YLpibA300C3JTb4FU3icylkAG6WVaWAXbqWcicGw8LtbnVx0yRTibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/p&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+2p*2*3*4*0*1+1*0*1+15*2*3*4*0*1+1*0*1+18*2*3*4*0*1+1*0*1+5b*2*3*4*0*1+1*0*1+29*2*3*4*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;我们知道Android的页面跳转是通过Intent、RN是通过路由，而两者直接的页面互相跳转是需要原生借助JS暴露接口给RN来实现。在Android原生页面与RN之间的页面管理中，主要分为三类：\\n① 以Intent实现的原生跳转到RN，此时页面栈交由Activity任务栈管理；\\n② 以路由Navigation实现的RN跳转到RN，此时页面栈交由路由导航中的堆栈管理；\\n③ 以及RN跳转到原生，主要包含三步：定义Module类，继承ReactContextBaseJavaModule、定义Package类，实现接口ReactPackage、定义Application类，继承android的Application，并实现ReactApplication接口，其实是在原生端创建Module类通过桥接的方式导出到JS端供JS代码调用原生端代码来实现的。\\n由此可知，对于更加复杂的如RN-RN-原生-RN-原生-原生页面间跳转等情况，都可拆分为由任务栈管理、由Navigation路由管理、以及由桥接方式实现路由管理。\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:5}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        我们知道Android的页面跳转是通过Intent、RN是通过路由，而两者直接的页面互相跳转是需要原生借助JS暴露接口给RN来实现。在Android原生页面与RN之间的页面管理中，主要分为三类：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ① 以Intent实现的原生跳转到RN，此时页面栈交由Activity任务栈管理；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ② 以路由Navigation实现的RN跳转到RN，此时页面栈交由路由导航中的堆栈管理；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ③以及RN跳转到原生，主要包含三步：定义Module类，继承ReactContextBaseJavaModule、定义Package类，实现接口ReactPackage、定义Application类，继承android的Application，并实现ReactApplication接口，其实是在原生端创建Module类通过桥接的方式导出到JS端供JS代码调用原生端代码来实现的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        由此可知，对于更加复杂的如RN-RN-原生-RN-原生-原生页面间跳转等情况，都可拆分为由任务栈管理、由Navigation路由管理、以及由桥接方式实现&lt;/span&gt;&lt;span&gt;路由管理&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3.3&lt;span/&gt;Activity-Flutter&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+2j*2*3*4*0*1+1*5*6*7*8*9*a*b*c*d*e*0+1*f*2*3*4*0+1*0*1+3h*2*3*4*0*1+1*0*1+2q*2*3*4*0*1+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;简单地来说，Flutter是使用跨平台的图形渲染引擎在view上画控件，Activity-Flutter之间的页面跳转和Activity-React Native原理大体上是类似的。\\n*\\n我们知道Android的页面跳转是通过Intent、Flutter是通过Widget进行路由管理，在Android原生页面与Flutter之间的页面管理如图所示。更多的关于Flutter Widget、Channel的内容可以在下文的该部分进行查看。\\n由此可知，对于更加复杂的如Flutter-Flutter-原生-Flutter-原生-原生页面间跳转等情况，同样可拆分为由任务栈管理、由Widget路由管理、以及由Channel方式实现路由管理。\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;],\&amp;quot;5\&amp;quot;:[\&amp;quot;img\&amp;quot;,\&amp;quot;https://docimg3.docs.qq.com/image/68xJmTMA-5gl7R6ZyT-h8Q.png?w=1050&amp;amp;h=262\&amp;quot;],\&amp;quot;6\&amp;quot;:[\&amp;quot;image-width\&amp;quot;,\&amp;quot;468px\&amp;quot;],\&amp;quot;7\&amp;quot;:[\&amp;quot;image-height\&amp;quot;,\&amp;quot;117px\&amp;quot;],\&amp;quot;8\&amp;quot;:[\&amp;quot;image-blipFill-srcRect-t\&amp;quot;,\&amp;quot;0\&amp;quot;],\&amp;quot;9\&amp;quot;:[\&amp;quot;image-blipFill-srcRect-b\&amp;quot;,\&amp;quot;0\&amp;quot;],\&amp;quot;10\&amp;quot;:[\&amp;quot;image-blipFill-srcRect-l\&amp;quot;,\&amp;quot;0\&amp;quot;],\&amp;quot;11\&amp;quot;:[\&amp;quot;image-blipFill-srcRect-r\&amp;quot;,\&amp;quot;0\&amp;quot;],\&amp;quot;12\&amp;quot;:[\&amp;quot;drawing-c-type\&amp;quot;,\&amp;quot;image\&amp;quot;],\&amp;quot;13\&amp;quot;:[\&amp;quot;container-anchor-id\&amp;quot;,\&amp;quot;1633634084856-269d406c52f7e34c\&amp;quot;],\&amp;quot;14\&amp;quot;:[\&amp;quot;container-type\&amp;quot;,\&amp;quot;drawing\&amp;quot;],\&amp;quot;15\&amp;quot;:[\&amp;quot;textalign\&amp;quot;,\&amp;quot;center\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:16}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        简单地来说，Flutter是使用跨平台的图形渲染引擎在view上画控件，Activity-Flutter之间的页面跳转和Activity-React Native原理大体上是类似的。&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;144&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24952380952380954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6GYDCe0a268t4f6GbMdUElnDCSBAyxwCx53081Zsibt2niaonAcibrLHp2q2vibWGkl6DBQGHicyHaz0NaTM0OnCia3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        我们知道Android的页面跳转是通过Intent、Flutter是通过Widget进行路由管理，在Android原生页面与Flutter之间的页面管理如图所示。更多的关于Flutter Widget、Channel的内容可以在后续系列文章的该部分进行查看。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        由此可知，对于更加复杂的如Flutter-Flutter-原生-Flutter-原生-原生页面间跳转等情况，同样可拆分为由任务栈管理、由Widget路由管理、以及由Channel方式实现路由管理。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、小结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;melo-data data-src=&quot;{&amp;quot;mainAtext&amp;quot;:&amp;quot;{\&amp;quot;atext\&amp;quot;:{\&amp;quot;attribs\&amp;quot;:\&amp;quot;*0*1+1u*2*3*4*0*1+1*0*1+5z*2*3*4*0+1\&amp;quot;,\&amp;quot;text\&amp;quot;:\&amp;quot;通过上述对于Android开发中的路由管理的介绍，可以看出Android原生页面栈和混合开发页面栈的相关实现在实际应用中极具灵活性。\\n在原生页面中，通过理解AMS，重点关注Activity的启动模式、Fragment的Navigation路由框架以及两者之间涉及到的页面栈跳转方式；在混合开发页面中，从native方-跨平台方-双方交互这三个角度简化路由管理，分别梳理了native-H5(WebView)、native-Weex/React-Native、native-Flutter这几种常见的跨平台的页面交互方式，使得在更加复杂的页面管理下仍可万变不离其宗。\\n\&amp;quot;},\&amp;quot;apool\&amp;quot;:{\&amp;quot;numToAttrib\&amp;quot;:{\&amp;quot;0\&amp;quot;:[\&amp;quot;author\&amp;quot;,\&amp;quot;p.158926675005\&amp;quot;],\&amp;quot;1\&amp;quot;:[\&amp;quot;font-family\&amp;quot;,\&amp;quot;SimSun,\\\&amp;quot;Songti SC\\\&amp;quot;,宋体,sans-serif\&amp;quot;],\&amp;quot;2\&amp;quot;:[\&amp;quot;pap-specialIndent\&amp;quot;,\&amp;quot;2em\&amp;quot;],\&amp;quot;3\&amp;quot;:[\&amp;quot;pap-stylesheet-name\&amp;quot;,\&amp;quot;normal\&amp;quot;],\&amp;quot;4\&amp;quot;:[\&amp;quot;pap-list-task\&amp;quot;,\&amp;quot;\&amp;quot;]},\&amp;quot;nextNum\&amp;quot;:5}}&amp;quot;,&amp;quot;storyAtexts&amp;quot;:[],&amp;quot;srcGlobalPadId&amp;quot;:&amp;quot;300000000$JFkLzPqGHcrI&amp;quot;}&quot; data-version=&quot;2.1.0&quot;/&gt;&lt;p&gt;&lt;span&gt;        通过上述对于Android开发中的路由管理的介绍，可以看出Android原生页面栈和混合开发页面栈的相关实现在实际应用中极具灵活性。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;        在原生页面中，通过理解AMS，重点关注Activity的启动模式、Fragment的Navigation路由框架以及两者之间涉及到的页面栈跳转方式；在混合开发页面中，从native方-跨平台方-双方交互这三个角度简化路由管理，分别梳理了native-H5(WebView)、native-Weex/React-Native、native-Flutter这几种常见的跨平台的页面交互方式，使得在更加复杂的页面管理下仍可万变不离其宗。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;        至此，我们了解到了&lt;span&gt;Android&lt;/span&gt;端是如何去实现路由管理的，那么，就请期待我们下一篇文章&lt;/span&gt;&lt;strong&gt;&lt;span&gt;《大前端开发中的路由管理之四：iOS篇》&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;吧，下篇文章将为大家揭秘iOS端是如何去做路由管理的。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;参考资料&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;span&gt;Activity启动模式与页面管理&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;https://www.jianshu.com/p/32938446e4e0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;span&gt;Fragment页面管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/fef256de6364&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;span&gt; 从AMS理解Android任务栈&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/fdd80e9a0bdc&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;span&gt;Navigation路由框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/95796d895cfc&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;span&gt;混合开发发展史&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/6856414014948900877&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;span&gt;Flutter原生混合开发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/6844903929625444359#heading-12&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;QQ音乐招聘 Android / iOS 客户端开发，点击左下方“查看原文”投递简历～&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可将简历发送至邮箱：tmezp@tencent.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;文末为大家推荐一个技术号《腾讯音乐天琴实验室》，TME天琴实验室致力于对业内前沿科技如AI等方向进行相关研发，持续推出新技术提升TME旗下QQ音乐等平台的音乐视听体验，对音视频相关AI研发感兴趣的同仁们一起交流学习起来吧！！！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;↓   ↓   ↓&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxOTgxODUxOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8jtd0kic4icicmwBY4OkjCo2WgK9S8GR9PNO6FVD2zX94xdlVeOrg11DWWQLcBqdaMCgYd46I2YXqRVCfO8JTyYSw/0?wx_fmt=png&quot; data-nickname=&quot;腾讯音乐天琴实验室&quot; data-alias=&quot;TME_Multimedia&quot; data-signature=&quot;TME天琴实验室，负责音视频相关AI研究，研发听歌识曲、TTS、歌唱评价、视频理解生成、视频质量优化、视觉渲染等业内领先的技术，为用户提供全方位的优质音乐视听体验。天琴实验室取名寓意神话中悬挂于天穹的七弦琴，让用户体验音乐娱乐更美好。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>