<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/9f0514g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c0594cc4ed364ad2e72edd824e2fcfc2</guid>
<title>【超赞】技术架构的战略和战术原则</title>
<link>https://toutiao.io/k/j9872pc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUyMDA4OTY3MQ==&amp;amp;action=getalbum&amp;amp;album_id=1847433240647614467#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1847433240647614467&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据中台&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;12个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMDA4OTY3MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXdtvHKjv7OHYYSTQ2QOVuyAia3LaU56kibxKLlX5Lo9bgeUfz1R4JDmdW7ZGYSLqsiaBl3nTOwOmFOFQ/0?wx_fmt=png&quot; data-nickname=&quot;浪尖聊大数据&quot; data-alias=&quot;bigdatatip&quot; data-signature=&quot;主要分享大数据框架，如spark，flink，kafka，hbase原理源码，同时会分享数据仓库，图计算等浪尖擅长领域。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;技术架构，是将产品需求转变为技术实现的过程。技术架构解决的问题包括了如何进行纯技术层面的分层、开发框架选择、语言选择（这里以 JAVA 语言为主）、涉及到各自非功能性需求的技术点（安全、性能、大数据）。技术架构是确定组成应用系统实际运行的技术组件、技术组件之间的关系，以及部署到硬件的策略。&lt;/p&gt;&lt;p&gt;技术架构面临最大的挑战是“不确定性”。在技术架构上，很多时候就会面临这种选择。是要选择业界最新的技术？还是选择团队最熟悉的技术？如果选择最新的技术，遇到新技术出了问题怎么解决？如果选择目前熟悉的技术，后续技术演进怎么办？这些都是架构师在做技术架构过程中需要考虑的。&lt;/p&gt;&lt;p&gt;业务在千变万化、技术在层出不穷，没有一套通用的技术架构模式来适用所有的系统。那么，我们如何保证在做技术架构时，能够实现一个稳定、出色的系统。面对这些“不确定性”时的架构设计问题，这里从战略和战术两个层面来提供一些设计原则。战略层提供的是技术架构的方法和思路，属于顶层设计；战术层提供的是技术架构的技术实践方式，更偏向详细设计。&lt;/p&gt;&lt;p&gt;&lt;span&gt;战&lt;/span&gt;&lt;span&gt;略层设计原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;战略层的设计原则就是：合适原则、简单原则、演化原则。&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.1 合适原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;技术人员有一种很强的技术情怀，就是在做设计的过程中，很希望挑战新的技术、在项目中采用最新的框架、或者自己重造一个比业界的还要牛的轮子。这样才能够显示出自己的优秀，以至于不让自己显的那么平庸。比如，在项目中重新造一个能够解决亿万级数据的新的 xx 流式计算技术，比 flink 还要牛一百倍；有或者在项目中使用最新的 xx 技术，能让系统承担亿级用户的访问。&lt;/p&gt;&lt;p&gt;那么现实是，如果在设计过程中一味追求新技术，往往失败的可能性很高。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;没有那么多人，却想干那么多活&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;现实环境中我们一个业务团队可能就十几个人，项目工期短、上线要求快。在这种情况下，如果还要抽调几个人去研究、搭建、维护新的技术框架，对于项目势必会造成延期的影响。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;没有那么多积累，却想一步登天&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;很多业界领先的方案，不是一帮优秀的开发加在一起，加班加点就能做出来的。而是经过几年时间的发展才逐步完善和初具规模。如果我们也想自己做一套类似的技术，不是说不可能。我们需要集合当下的技术实力、技术积累，做出适合自己团队情况的技术评估。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;没有最新，只要最合适&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所有新的技术刚出来都是打着比旧技术拥有更加出色的性能、提供更加优秀的扩展性。是不是使用新技术，就能解决一切问题了？新技术的出道，势必是解决某一场景下的问题，并不是一味万能良药。只有了解清楚每种技术的产生背景，适用场景，才能出一个对自己项目最优的选择。技术选型没有最新，只有最合适。&lt;/p&gt;&lt;p&gt;总结一下，合适原则就是适合优于业界领先。&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.2 简单原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们总是希望能将我们的软件设计的精美、宏大，这样才能彰显我们系统的复杂度和难度。我们是不是会遇到这样的场景，在做设计方案的时候，如果一个解决方案很简单，而且能很快的满足需求。在评审方案时，就会有人觉得这个方案是不是太简单了，没有什么技术含量，是不是需要再设计的复杂一点。&lt;/p&gt;&lt;p&gt;系统是不是一定要设计的复杂？在回答这个问题前，我们先看下软件领域的结构复杂性和逻辑复杂性。&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）结构复杂性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结构复杂的系统有两个特点：&lt;/span&gt;&lt;span&gt;第一，组成的组件数量很多；&lt;/span&gt;&lt;span&gt;第二，这些组件之间的关系很复杂。&lt;/span&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26835043409629045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOjoNXrahuic8dvLOo1r958Az7miaDhVrDYJicr9p0EukwAxgHoz84xwEEDTrqU8uLkkjZVzR1icEyDpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 1&lt;/p&gt;&lt;p&gt;结构上的复杂性存在的第一个问题是，组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。假设组件的故障概率是 1%（有 1% 的时间不可用），那么 2 个组件的系统可用性是 99%&lt;span&gt;*&lt;/span&gt;&lt;span&gt;99%=98%，5 个组件的系统可用性是 99%&lt;span&gt;*&lt;/span&gt;&lt;/span&gt;99%&lt;span&gt;*&lt;/span&gt;&lt;span&gt;99%&lt;span&gt;*&lt;/span&gt;&lt;/span&gt;99%*99%=95%，两者相差 3%。说明组件越多，系统稳定性就越差。&lt;/p&gt;&lt;p&gt;结构上的复杂性存在的第二个问题是，某个组件改动，会影响关联的组件。比如上图中 C 组件发生改动，会影响 A、B、D，而 A 有会影响 E。这样就会形成一连串的多比诺效应。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; （2）逻辑复杂性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;意识到结构复杂性的问题后，只要减少组件就能让系统结构变简单？&lt;/span&gt;&lt;span&gt;这样做还是行不通，原因在于除了结构的复杂性，还有逻辑的复杂性，如果一个组件的逻辑太复杂，通用会带来问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们试想一下，把淘宝的所有功能都在一个组件中实现，可以想象这个系统要有多庞大：几百人维护一个系统、代码分支几十个、需求变更应接不暇、不同分支的回归测试、修改一段代码可能影响整个系统的运行等等。这些场景相信大家都不希望看到的。&lt;/p&gt;&lt;p&gt;总结一下，简单原则就是大道至简。&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.3 演化原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;软件架构和建筑架构很多相同的地方，架构这个词也是从建筑领域借鉴过来的。比如，软件架构描述的是系统的结构、以及各模块之间的关系。而建筑结构描述的是一幢建筑的结构，以及建筑内部各部件如何有机的组成。&lt;/p&gt;&lt;p&gt;但是，软件架构和建筑架构有一个本质上的差异：那就是建筑一旦完成就不会再变，而软件却需要根据业务的发展不断的变化。对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。&lt;/p&gt;&lt;p&gt;如果没有意识到“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候很容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。如果是按照这样的目标是设计，一开始上来就做出一套看似是终极的方案，投入庞大的资源做各种预测、分析。结果是投入巨大的资源、开发周期漫长，最终跌跌撞撞落地的系统，却发现已经无法很好的满足现有的业务。&lt;/p&gt;&lt;p&gt;所以技术架构设计需要一个过程：&lt;/p&gt;&lt;p&gt;首先，要满足当前的业务需求进行技术架构设计&lt;/p&gt;&lt;p&gt;其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使架构逐渐完善。&lt;/p&gt;&lt;p&gt;第三，当业务发生变化时，架构要扩展、重构、甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计却可以在新架构中延续。&lt;/p&gt;&lt;p&gt;总结一下，演化原则就是演化优于一步到位。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;战术层设计原则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;战术层的设计原则分为 3 部分：&lt;/span&gt;&lt;span&gt;高并发原则、高可用原则、业务设计原则。&lt;/span&gt;&lt;span&gt;这些原则是对技术架构设计过程中提供详细的指导思路，帮助你做技术选型、技术拆分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.1 高并发原则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计高并发的系统，需要考虑以下几个方面的设计：&lt;/span&gt;&lt;span&gt;无状态、拆分、服务化、消息队列、数据异构、缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;（1）无状态&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无状态应用，&lt;/span&gt;&lt;span&gt;便于水平&lt;/span&gt;&lt;span&gt;扩展&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;状态配置可通过配置中心实现无状&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;（2） 拆分&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;系统维度：按照系统功能、业务拆分，比如购物车、结算、订单等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;功能维度：对系统功能再做细粒度拆分。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读写维度：根据读写比例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;AOP 维度：根据访问特征，按照 AOP 进行拆分.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;模块维度：对整体代码结构划分 web、service、dao。&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）服务化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务&lt;/span&gt;&lt;span&gt;化演进：&lt;/span&gt;&lt;span&gt;进程内服务 - 单机远程服务 - 集群手动注&lt;/span&gt;&lt;span&gt;册服务 - 自动注册和发现服务 - 服务的分组、隔离、路由 - 服务治理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;考虑服务分组、隔离、限流、黑白名单、超时、重试机制、路由、故障补偿等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（4）消&lt;/span&gt;&lt;span&gt;息队列&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5&lt;/span&gt;&lt;span&gt;）数&lt;/span&gt;&lt;span&gt;据异构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; （6）缓存&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户层：DNS 缓存、浏览器 DNS 缓存、操作系统 DNS 缓存、本地 DNS 服务商缓存、DNS 服务器缓存、客户端缓存、浏览器缓存、APP 客户端缓存。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代理层：CDN 缓存（一般基于 ATS、Varnish、Nginx、Squid 等构建，边缘节点 - 二级节点 - 中心节点 - 源站）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;接入层：Nginx 的 Proxy_cache 代理缓存，或者 Nginx+Lua+Redis 做业务数据缓存。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用层：页面静态化、业务数据缓存（Redis/Memcache/ 本地文件等）、消息队列&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据层：NoSQL（Redis、Memcache、SSDB 等）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.2 高可用原则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 降级&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;降级开关集中化管理：将开关配置信息推送到各个应用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可降级的多级读服务：如服务调用降级为只读本地缓存。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开关前置化：如 Nginx+Lua 配置降级策略，引流流量；可基于此做灰度策略。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务降级：高并发下，保证核心功能，次要功能可由同步改为异步策略或屏蔽功能。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 限流&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3. 可回滚&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.3 业务设计原则&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;防重设计&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;幂等设计&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;流程定义&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;状态与状态机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后台系统操作可反馈&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后台系统审批化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;文档注释&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;备份&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;技术架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;技术架构图是将系统的技术方案、技术选型通过视图的方式进行展现。技术架构图分为两类：一类，功能需求技术架构图（逻辑架构图），是描绘如何通过技术组件来实现系统产品功能的图。另一来，非功能需求技术架构图（物理架构图），是描绘如何通过物理部署的来实现系统运行的图。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.1 逻辑架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;功能需求技术架构图以产品架构图和应用架构图为基础。实现每个功能点需要使用什么技术、技术实现逻辑如何，就提现在技术架构图上。功能需要技术架构图绘制可以按照“整体 - 局部 - 整体”的思路实现。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; 1. 整体&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先可以按照应用架构图的应用分布得到应用分布框架。如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.584375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOjoNXrahuic8dvLOo1r958ASqzB3ickhoXSI1NW5edw8ofWMh4IsgprWPtia23U8Ouk8Cic6gB9HH8XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 局部&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在整体框架的基础上，对每一个局部的子系统进行详细的技术实现的表达。子系统的技术架构图中需要展示每个子系统使用的技术组件，比如（缓存技术、消息中间件、流程引擎、流式计算框架等等）。同时，这些技术组件是如何实现业务功能，需要清晰的展示技术实现逻辑。&lt;/p&gt;&lt;p&gt;下图是对风控系统中的实时引擎、离线引擎、准实时引擎三个子系统的进行的技术架构。在实时引擎中，主要使用 RuleEngine（规则引擎）作为技术特点，这里就重点列出 RuleEngine。准实时引擎使用 Blink 作为流计算的技术框架，并概要的展示了计算逻辑。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5576619273301737&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOjoNXrahuic8dvLOo1r958A6zsDY3BVLB47AcEVhuvYnsOVwPLG5A2ra3AcLsuTFWuK9qyOXgsxCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; 3. 整体&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在完成每个子系统的技术实现后，最终进行一次整合，绘制一张总体的系统技术架构图。各子系统之间通过服务接口、数据库、缓存或消息中间等技术实现数据交互，以此将打通各个子系统，实现最终整个产品从数据、技术的串联。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5803149606299213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOjoNXrahuic8dvLOo1r958AWI6GaIicx63pUauFjte2CL9jKX5ia1uNXwgZ5G12EETaNX9BpVp3z3Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3.2 物理架构图&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;物理架构偏重于网络设计、集群设计、中间件设计、数据存储设计等基础软硬件的设计架构。非功能需求的技术架构图重点在于展示企业系统在物理上是如何部署。物理架构规定了组成系统的物理元素、物理元素之间的关系以及他们的部署策略。物理架构反映出软件系统动态运行时的组织情况。从物理架构图中，我们能够全局的得知整个系统是如何从流量访问、数据流转、数据存储到技术组件的运转。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8264984227129337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOjoNXrahuic8dvLOo1r958AySEjrTcwCj7lewmvN5fUgdpCnq1e0QWhEzNGQic3k5LBic8gk8OcmH4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;总  结&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们从架构的本质开始，分别对业务架构、产品架构、数据架构、应用架构、技术架构的设计提供了一些思路和原则。这些思路和原则在进行架构设计和画架构图的过程中提供一些指导帮助。最后我们再来思考一个问题，好的软件架构是规划还是演化出来？&lt;/p&gt;&lt;p&gt;架构规划对架构的影响是很重大的。首先，好的架构是设计出来的。好的架构，系统的性能和质量都将很高。架构设计的质量直接影响架构后续向好的方向演化的难易程度。架构设计如同城市规划一样，缺少规划将难于演化。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34490923441199683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOjoNXrahuic8dvLOo1r958A3fJARZKlibOSQXfL937NC81HBaCia68DZHgzMnTQ3Eh4l0h9EPWnNRsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;演化是一个过程，这个过程或长或短，所以演化需要考虑系统的生命周期。如果演化的过程非常漫长，超出了软件的生命周期，即使架构越来越优化，对于产品或者项目的帮助也将有限，所以时间这个约束条件是非常苛刻的。&lt;/p&gt;&lt;p&gt;在现有规划的基础上进行演化，我们无法得到普适的架构，但可以得到确定领域的通用架构，可以在特定领域通过演化使架构逐步优化，帮助业务快速的发展。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; 作者简介&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;胡斌，菜鸟网络技术专家，目前负责菜鸟风控系统的建设。曾在淘宝技术部先后负责卖家平台、商家运营等领域。在大规模分布式应用、大数据、架构领域有多年的开发和管理经验。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6764091858037579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXd78W49nBaME6TkGc8gv8DBzMJvytIYy9Dibfsl7qq5ibATfYh9BN1xQO5qU1OejK3Gic6dfl8iafXwGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;&lt;/p&gt;&lt;pre/&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c70ffbf08e8b4c8eb1dc07e4227347b9</guid>
<title>Windows 是最安全的操作系统</title>
<link>https://toutiao.io/k/66e0ect</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;建了一个用户交流群，我在群里说：“Windows 是最安全的操作系统。” 立刻引发了很多有意思的观点。我在群里一个人说不过大家，先篇文章把自己的论点罗列一下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对操作系统攻击的方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有5类基本的攻击方式：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1、 系统口令攻击：猜测攻击、字典攻击、穷举攻击、混合攻击、直接破译攻击、网络嗅探、键盘记录、中间人攻击、社会工程学&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2、 SMB/NetBIOS协议攻击：空会话攻击&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3、 脚本攻击：SQL注入技术、PHP+MySQL注入技术、跨站脚本攻击技术、cookie攻击技术、WebShell提权技术&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4、 恶意代码攻击：木马技术、Rootkit技术、病毒技术、蠕虫技术、网页恶意代码&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;5、 网络安全设备攻击：路由技术、Dos攻击、防火墙攻击&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一项对参加了 DEFCON 会议的黑客的调查表明，“84％ 的人使用社会工程学作为攻击策略的一部分。” 社会工程学又叫社交工程学，发起“社会工程学”攻击的人也有一个被美化的称号是&lt;span&gt;社工工程师&lt;/span&gt;。Windows 系统因为用户基础的关系，社会工程学的攻击主要也是针对 Windows 系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面大家来做一道单选题，&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Windows 、macOS 和 Linux 三个用户最多的系统中，Windows 在安全方面做了更多的工作。因为其用户量不但碾压其他两个系统，其用户的技术水平也最为参差。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然这只是个人观点。目前业界并没有全面的统计数据。甚至安全的指标都不明确。到底什么才是安全的指标呢？是 攻击成功率、被攻破次数？到底是以那个时间段作为衡量指标？衡量覆盖范围到底涉及哪些？统统没有定论，所以没有标准答案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业界影响较大的攻击举例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;案例一 Equifax 数据安全事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2017 年 9 月，美国征信巨头 Equifax 承认 1.45 亿美国居民个人隐私信息泄露，这是该国历史上最严重的数据安全事件，以美国人口 3.2 亿计算，受影响的超过 40%。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于征信局采集的数据涉及到消费、贷款等大量隐私数据，这让征信局成了黑客眼中的香馍馍，偏偏本次事件的主角 Equifax 的安全防范系统实在不堪一击，让犯罪分子得以利用其漏洞获取对部分文件的访问权，于是 1.45 亿用户的姓名、社会安全号码（SSN）、出生日期、地址、驾驶证号码(这相当于是中国的身份证号码)等信息就这样泄露了出去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个漏洞是 Apache Struts 的低版本安全漏洞引起的，其实只要及时升级版本，问题可以避免。但是特别是这种重要的应用，版本升级等变更就越困难。所以在一个新应用投产时，特别是边界应用，尽量选择无高危漏洞的版本。而事实上，新应用在选择版本时，架构师们往往并不根据实际情况，而是采取“跟随策略”。就是使用其他应用在长期稳定运行的版本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题是首先要考虑，如果自己的应用边界应用，并且是很多黑客觊觎的产品的一部分，安全是第一重要的，应该尽量选用无已经被发现漏洞的高级版本。因为像 Equifax 被攻击这种事情，30年也就发生一次。作为边界应用被攻击成功，不会有其他应用给做背书，一损俱损。后果还是自己扛。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;案例二 Log4j2 lookup 漏洞&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2021年12月9日，国内多家机构监测到 Apache Log4j2 存在任意代码执行漏洞，并紧急通报相关情况。由于Apache Log4j存在递归解析功能，未取得身份认证的用户，可以从远程发送数据请求输入数据日志，轻松触发漏洞，最终在目标上执行任意代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然有这个漏洞，目前还没有对企业造成任何损失。并且如果没有用到 Message Pattern Lookups&lt;/p&gt;&lt;p&gt;的程序，可以使用 - Dlog4j2.formatMsgNoLookups=true 禁用它解决问题。而且 log4j2 官方也已经为此漏洞打上补丁。其实我很想为 log4j2 说两句话。高版本的 log4j2 相比logback等其他主流日志框架更加强大，它提供了更加强大优雅的API、默认无垃圾模式运行、更强的异步性能。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5257595772787318&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8EdcKu0AX9ibfAdTpVDtD7As9JgNYEz2c0piapAg751ChWlqWuUDtOMiaYoGTibwwMIRuFUjQHibTQjRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Log4j2 在安全方面给我的启迪有两点：第一，尽量使用官方还在维护的软件版本。现在设想一下：假如发现 log4j2 漏洞之后，log4j2 开发者明确表示不会修复此漏洞，使用的公司们打算怎么办？第二，不要在不需要的情况下开启软件的高级特性，增加引入漏洞的几率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;近年来，由于操作系统本身的问题引起的漏洞要少了上面运行的软件的漏洞。而 Windows 操作系统由于拥有更多的用户量，配套的软件也更多更全，很多都很难从官方渠道免费使用，使得携带病毒的软件有可乘之机。而MacOS由于基本只能通过官方应用商店下载；而 linux 系统上运行大多是开源软件，完全可以通过官方渠道免费下载。所以这其实使得 Windows 系统不如其他两个系统安全，这个是 Windows 从一开始的设计理念决定，这个锅 Windows 得背。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;春节前我建了一个群，旨在答谢用户，用了全年收入的 1800% 给大家发了红包。之后还有很多朋友说要入群交流，不是为红包来的。非常欢迎。给出入【编程一生】用户交流群官方渠道：加微信 brmayi 注明入群。或者已经是好友的朋友可以私信我：入群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;今年红包已经发完了，要增加明年红包的预算要靠大家了。关注、点赞、在看、点广告。明年收入多少我发多少。不过目前为止大家的预算堪忧啊。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.932475884244373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8EdcKu0AX9ibfAdTpVDtD7AXE4UWAH9QsZAETvUFQjDQ6KLZPY0xq1ibdZwwDiaAAf1rhfibBKZhNk9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1d0c99a4d209490788d0b82e0342230</guid>
<title>20张图助你了解JVM运行时数据区，你还觉得枯燥吗？</title>
<link>https://toutiao.io/k/6hsbqkc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;181&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32344763670064874&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOjRJj3rEmVIcZ4cxnPGXMbOToA3HQiafTrfmjfvOVQH0fLtCJwj3DkfC1GoPIRVmLY5oTemAhXibRQ/640?wx_fmt=png&quot;/&gt;&lt;span&gt;我们的JVM系&lt;/span&gt;&lt;span&gt;列已经断更好几天了，小伙伴们在后台疯狂私信阿Q，想看后续内容，今天它来了。&lt;/span&gt;&lt;span&gt;相信大家在上篇文章中已经对类加载子系统有了清晰的认识，接下来就让我们来揭开“运行时数据区”的神秘面纱吧。&lt;/span&gt;&lt;span&gt;（文章可能有点长，建议先收藏一波&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;运行时数据区总览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存是非常重要的系统资源，是硬盘和&lt;code&gt;CPU&lt;/code&gt;的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。下图就是&lt;code&gt;HotSpot&lt;/code&gt;的经典的内存布局：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49345417925478346&quot; data-type=&quot;png&quot; data-w=&quot;993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8cib59ic37ucY5Jibmw0EBjNZBsTjQTXRiaZ0h7ibUBDalGkQNQTE3j2ia4kQ/640?wx_fmt=png&quot;/&gt;图中的&lt;code&gt;CodeCache&lt;/code&gt;在JVM官方文档中被归于元空间，而在阿里的官方文档中被单独摘了出来，此处区别并不影响我们对它的学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机在执行Java程序的过程中，会将涉及到的数据划分到不同的内存区域去管理，而这部分区域就是我们接下来要讲的Java虚拟机的运行时数据区。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42424242424242425&quot; data-type=&quot;png&quot; data-w=&quot;924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8PhIwKHKx2Jx7BmBiaWPMrY1gS9S1UvGa7pI9C2EYYBTHUkdjzWlpyRA/640?wx_fmt=png&quot;/&gt;如上图所示，我们的运行时数据区分为PC寄存器、方法区、堆、本地方法栈和虚拟机栈五个部分。其中上文中所说的元空间就是方法区的具体落地实现。估计有的老铁会问：不是还有直接内存吗？其实直接内存并不属于运行时数据区的一部分，也不是java虚拟机规范中的区域，它的大小不受java堆大小的限制，是使用&lt;code&gt;Native&lt;/code&gt;函数库直接分配的堆外内存，会被频繁使用。它存储着堆与本地方法相关的数据，可以避免在Java堆和&lt;code&gt;Native&lt;/code&gt;堆中来回复制数据，能够提高效率。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9791666666666666&quot; data-type=&quot;png&quot; data-w=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8y4RN6OHBgVcOQvd9mOmdpOaHiag6mJkLdNsoMzibmjqr6Qk0Gxj9jzLw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的老铁应该会发现，上图中阿Q用了红蓝两种颜色来区分五个部分，其中红色的方法区和堆是线程间共享的，即它们会随着虚拟机启动而创建，随着虚拟机退出而销毁；而蓝色的部分为每个线程单独享有的，即它们与线程是一一对应的，会随着线程开始和结束而创建和销毁。在&lt;code&gt;HotSpot JVM&lt;/code&gt;中，每个线程都与操作系统的本地线程直接映射：当一个java线程准备好执行之后，此时一个操作系统的本地线程也同时创建，java线程执行终止后，本地线程也会回收。操作系统负责所有线程的安排调度到任何一个可用的&lt;code&gt;CPU&lt;/code&gt;上，一旦本地线程初始化成功，它就会调用Java现成的&lt;code&gt;run()&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以翻看官方文档了解一下&lt;code&gt;Runtime&lt;/code&gt;类：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the getRuntime method.&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;译：&lt;/strong&gt; 每个Java应用程序都有一个类运行时实例，该实例允许应用程序与运行应用程序的环境交互。当前运行时可以从&lt;code&gt;getRuntime&lt;/code&gt;方法获得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这如果大家对运行数据区还没有大致的概念的话，给大家举个小例子，大家一看便知：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7905511811023622&quot; data-type=&quot;png&quot; data-w=&quot;635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8YF13axZwfG9yWrOIViaTFGtQKOXtDkeNOhVfrz6kS88uSBjuiapZoWJQ/640?wx_fmt=png&quot;/&gt;如上图所示，厨师正在烹饪佳肴，我们如果把厨师炒菜比作我们的虚拟机执行代码的话，厨师就是我们后文中将要提到的执行引擎，而厨师后方的工具类和食材就相当于我们的运行时数据区。&lt;strong&gt;在写这篇文章的过程中发现知识点有点多，所以阿Q把它分为两部分进行讲解，该篇文章先说一下线程的私有区域：PC寄存器、本地方法栈和虚拟机栈。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PC寄存器（程序计数器）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的寄存器并不是广义上所指的物理寄存器，而是对物理寄存器的抽象模拟，把它称为PC计数器（或指令计数器）更为合适。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机可以一次支持多个执行线程，每个Java虚拟机线程都有其自己的PC寄存器即为线程独有。PC寄存器会随着线程的创建而创建，会随着线程的结束而死亡。正因为程序计数器记录的是指令地址，所以它占用的内存空间较少，因此它是运行速度最快的存储区域，也是唯一一个在Java虚拟机规范中没有规定任何&lt;code&gt;OutOtMemoryError（内存溢出）&lt;/code&gt;情况的区域。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法。如果线程当前正在执行的方法不是&lt;code&gt;native&lt;/code&gt;，则该pc寄存器包含当前正在执行的Java虚拟机指令的地址；如果线程当前正在执行的方法是&lt;code&gt;native&lt;/code&gt;，则Java虚拟机的pc寄存器值未定义&lt;code&gt;undefned&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;作用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PC寄存器的作用就是用来存储指向下一条指令的地址，也就是即将要执行的指令代码，由执行引擎读取该指令并交由&lt;code&gt;cpu&lt;/code&gt;执行。它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。我们可以把PC寄存器理解为一个记录着当前线程所执行的字节码的行号指示器，也可以理解为一个游标，来告诉程序按照我指定的顺序执行。接下来用例子来演示下它所处的位置与作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;例：&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5945399393326593&quot; data-type=&quot;png&quot; data-w=&quot;989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8neDxVEUxQoR8O4kGAZRqLS2QV7R9uBlDW1n3qghn7ZbXmH55htko8A/640?wx_fmt=png&quot;/&gt;如图所示，PC寄存器中存储着指向“操作指令”的“指令地址”。假如现在PC寄存器中存储的指令地址是“5”，则执行引擎会取出对应的操作指令，然后做两件事：一是操作局部变量表、操作数栈等完成数据的存、取、加减等操作；二是将操作指令翻译成CPU能识别的机器指令，最后由CPU执行；此时字节码解释器就会改变PC寄存器中的值为“6”，以此类推。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;面试题分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）为什么要使用PC寄存器记录当前线程的执行地址呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，这时候就需要PC寄存器来记录某个线程的字节码执行位置，如果虚拟机是单线程也就没必要用程序计数器记录每个线程的位置了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）PC寄存器为什么会被设定为线程私有呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于jvm的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然就是为每一个线程都分配一个PC寄存器。这样各条线程之间计数器互不影响，独立存储。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;虚拟机栈&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;栈的介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5MDg2NjEzNA==&amp;amp;mid=2247484144&amp;amp;idx=1&amp;amp;sn=e72de4228cfc81e223b7c9c59e2585c9&amp;amp;chksm=ec181449db6f9d5f596ae07c8d3604b1d20060efe89a2974ccdd08e488c45e8222b4f1e9e1cc&amp;amp;token=1106029044&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《JVM集合之开篇点题》&lt;/a&gt;中所说，由于跨平台性的设计，Java的指令都是根据栈来设计的，它遵循“先进先出、后进后出”的原则。它的优点就是跨平台、指令集小，编译器更容易实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我们要对“栈”和“堆”做一个简单的区分，其中栈是运行时的单位，它解决的是程序运行的问题，即程序如何执行，或者说是如何处理数据；堆是存储的单位，它解决的是数据存储的问题，即数据怎么放、放在哪。我们举个简单的例子：假如你正在修理汽车，我们可以把修车的操作步骤看做是栈操作，而把汽车的零件一个个放到汽车中就可以看做是堆存储。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟机栈介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机栈，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，所以虚拟机栈是线程私有的，当线程结束时虚拟机栈也就结束了。JVM对虚拟机栈的操作只有进栈和出栈，所以它的访问速度仅次于程序计数器，也是一种快速有效的分配存储方式。对于虚拟机栈来说它不存在垃圾回收问题，但是虚拟机栈的大小是动态的或者固定不变的，所以它会存在栈溢出或者内存溢出问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;栈溢出：如果采用固定大小的虚拟机栈，那每一个线程的虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过虚拟机栈允许的最大容量，虚拟机栈会抛出&lt;code&gt;StackOverflowError&lt;/code&gt;异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存溢出：如果虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那虚拟机将会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;异常。栈的大小直接决定了函数调用的最大可达深度，我们可以通过&lt;code&gt;-Xss&lt;/code&gt;参数来配置栈内存，追加字母k或K表示KB，m或M表示MB，g或G表示GB，示例:&lt;code&gt;-Xss1m&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;栈帧的运行原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机栈主管Java程序的运行，保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回，那它内部到底是什么构造呢？虚拟机栈内部保存着一个一个的栈帧（&lt;code&gt;Stack Frame&lt;/code&gt;），每个栈帧与该线程正在执行的每个方法都是一一对应的。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧 (&lt;code&gt;Current Frame&lt;/code&gt;)，与当前栈帧相对应的方法就是当前方法(&lt;code&gt;Current Method&lt;/code&gt;)，定义这个方法的类就是当前类(&lt;code&gt;Current Class&lt;/code&gt;)。执行引擎运行的所有字节码指令只针对当前栈帧进行操作。执行过程如下图：&lt;img data-ratio=&quot;0.4565727699530516&quot; data-type=&quot;png&quot; data-w=&quot;852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8vGSIfk2uyDUcNey1ibJPjSfdnPA9ibBL5z9IiareEpBlcpQyrT8CicbvVg/640?wx_fmt=png&quot;/&gt;程序开始执行，首先方法1入栈，为栈帧1，此时栈帧1为当前栈帧；随后方法1调用方法2，方法2入栈，为栈帧2，此时栈帧2为当前栈帧，以此类推；当方法4入栈成为栈帧4并且执行代码，在方法4返回之际，栈帧4会传回方法4的执行结果给栈帧3，接着，虚拟机会丢弃栈帧4即栈帧4出栈，使得栈帧3重新成为当前栈帧，以此类推，直到方法1执行完成，栈帧1出栈，虚拟机栈被回收。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令（包含&lt;code&gt;void&lt;/code&gt;返回类型）;一种是抛出异常（指的是未处理的异常，如果是&lt;code&gt;try...catch&lt;/code&gt;过了，算第一种）。不管使用哪种方式，都会导致栈帧出栈。不同线程中所包含的栈帧是不允许存在互相引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5017964071856288&quot; data-type=&quot;png&quot; data-w=&quot;835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8CdIhX8CFq5VOdicFHUX2juURaAEECuKJ1WB4WYL0U2exb63UuO4c7CA/640?wx_fmt=png&quot;/&gt;如图所示，栈帧由局部变量表、操作数栈、动态链接、方法返回地址和一些附加信息组成，接下来就让我们逐个来了解一下吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;局部变量表 Local Variables&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部变量表也被称之为局部变量数组或本地变量表，实际上是一个“数字”数组，主要用于存储方法的参数和定义在方法体内的局部变量（包括各类基本数据类型、对象引用、&lt;code&gt;returnAddress&lt;/code&gt;类型），虚拟机使用局部变量表完成方法返回。因为局部变量表是建立在线程的虚拟机栈上，是线程的私有数据，所以不会存在数据安全问题。另外栈帧的大小主要受局部变量表的影响，而局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的&lt;code&gt;Code&lt;/code&gt;属性的&lt;code&gt;maxmum_local_variables&lt;/code&gt;数据项中，所以在方法运行期间是不会改变局部变量表的大小的，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。一般来说在，在虚拟机栈大小固定的前提下，它的局部变量表越大，它的栈帧就越大，那它的嵌套调用次数（方法调用数）也就越少，即栈的深度越浅。用几张字节码的图来说明一下局部变量表中的内容：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39246263807667314&quot; data-type=&quot;png&quot; data-w=&quot;1539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8F1KUMN2mBcFTO6Y8vAvnrmBJot4rMLbibw427EBffsHicNwa7UIJ0nibg/640?wx_fmt=png&quot;/&gt;&lt;img data-ratio=&quot;0.17939733707077785&quot; data-type=&quot;png&quot; data-w=&quot;1427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8Z3AH861grV5RibhMlf3ovkrvYaKK0eO2IyvJpRTaJK7tibDrAwhpSKwg/640?wx_fmt=png&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5220820189274448&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8WHIao1fITLibXwKNU98OyXdpo7FdGsqtr849uTchF6U6Oka3fzy8Urg/640?wx_fmt=png&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2032054951345163&quot; data-type=&quot;png&quot; data-w=&quot;1747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb89a2t5Bay874FBqqJQ4EKf4jOibLbMOVzjDe1YlQRTxPfZHVMJnJFW8g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;局部变量表中的数据只有在当前方法中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Slot&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数的存放总是在局部变量数组的索引0开始，到数组长度减1的索引结束，它最基本的存储单元就是&lt;code&gt;Slot&lt;/code&gt;（变量槽）。当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个&lt;code&gt;Slot&lt;/code&gt;上。JVM会为局部变量表中的每个&lt;code&gt;Slot&lt;/code&gt;都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。其中32位以内的类型只占用一个&lt;code&gt;slot&lt;/code&gt;（包含&lt;code&gt;returnAddress&lt;/code&gt;类型，&lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;都转化为&lt;code&gt;int&lt;/code&gt;类型，而&lt;code&gt;boolean&lt;/code&gt;类型是0为&lt;code&gt;false&lt;/code&gt;，非0为&lt;code&gt;true&lt;/code&gt;），64位的类型（&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;）占用两个&lt;code&gt;slot&lt;/code&gt;。如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.146341463414634&quot; data-type=&quot;png&quot; data-w=&quot;451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8RJ2vjUv7QwYcWEMKgt8q1ibkT97ABUNibZzKJZZDiaFtzqnHVy79wiaGiaA/640?wx_fmt=png&quot;/&gt;如果当前帧是由构造方法或者实例方法创建的，那么该对象的引用&lt;code&gt;this&lt;/code&gt;将会存放在&lt;code&gt;index&lt;/code&gt;为0的&lt;code&gt;slot&lt;/code&gt;处，其余的参数按照参数表顺序继续排列，而&lt;code&gt;this&lt;/code&gt;变量不存在于静态方法的局部变量表中，所以上文中的&lt;code&gt;main&lt;/code&gt;方法中不存在&lt;code&gt;this&lt;/code&gt;变量。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2693831352574986&quot; data-type=&quot;png&quot; data-w=&quot;1767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb818kUpiciboES9wl0eOzJ41tYmHjYbaWDA0fuVOSCAiapfYicE64KgyFuNA/640?wx_fmt=png&quot;/&gt;另外&lt;code&gt;Slot&lt;/code&gt;是可以复用的，如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就很有可能会复用该局部变量的slot，从而达到节省资源的目的。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19186046511627908&quot; data-type=&quot;png&quot; data-w=&quot;1720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8kNico8f1QroqB4WFcd67tvZw7SA2LibwgfjdUgZKm1W8s9fIL5sarwjQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;补充知识点：&lt;/strong&gt;变量按照在类中的位置可以分为成员变量和局部变量，其中成员变量又分为类变量和实例变量。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;成员变量在使用前，都会默认初始化赋值，其中类变量是在类加载子系统的准备阶段进行默认赋值，在初始化阶段显示赋值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实例变量会随着对象的创建，在堆空间中分配实例变量空间，并进行默认赋值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;局部变量是不会进行默认赋值的，所以在使用前必须进行显示赋值，否则编译不通过。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;操作数栈 Operand Stack&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作数栈又称为表达式栈，在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈和出栈。操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。每一个操作数栈都会拥有一个明确的栈深度用于存储数据值，其所需要的最大深度在编译期间就定义好了，保存在方法的&lt;code&gt;code&lt;/code&gt;属性中，为&lt;code&gt;max_stack&lt;/code&gt;的值（与上边局部变量表类似）。栈中的元素可以是任意的Java数据类型，其中32bit的用一个栈单位深度，64bit的用两个栈单位深度。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。我们所说的Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。有了上述的理论，估计你会是这样的&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5234899328859061&quot; data-type=&quot;other&quot; data-w=&quot;596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8jcIxic835cN9gsDMfxT0lvWRWE1BJGUowItdeM1dOszkrQ9ibbvmicuWg/640?wx_fmt=other&quot;/&gt;阿Q特地制作了一张动态图来说明一下字节码指令执行时PC寄存器、局部变量表和操作数栈的运行过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;byte&lt;/span&gt; i = &lt;span&gt;15&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; k = i + j;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.705&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8hNLbj7IyiccV2kkavkicknE0se4FKQSaZu3SC8NSAiaVHyqbpnk6aN0sg/640?wx_fmt=gif&quot;/&gt;在编译期间局部变量表和操作数栈的大小已经确定了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先将要执行的指令地址&lt;code&gt;0&lt;/code&gt;存放到PC寄存器中，此时，局部变量表和操作数栈的数据为空；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当执行第一条指令&lt;code&gt;bipush&lt;/code&gt;时，将操作数&lt;code&gt;15&lt;/code&gt;放入操作数栈中，然后将PC寄存器的值置为下一条指令的执行地址，即&lt;code&gt;2&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当执行指令地址为&lt;code&gt;2&lt;/code&gt;的操作指令时，将操作数栈中的数据取出来，存到局部变量表的&lt;code&gt;1&lt;/code&gt;位置，因为该方法是实例方法，所以&lt;code&gt;0&lt;/code&gt;位置存的是&lt;code&gt;this&lt;/code&gt;的值，PC寄存器中的值变为&lt;code&gt;3&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同步骤2和3将&lt;code&gt;8&lt;/code&gt;先放入操作数栈，然后取出来存到局部变量表中，PC寄存器中的值也由&lt;code&gt;3&lt;/code&gt;-&amp;gt;&lt;code&gt;5&lt;/code&gt;-&amp;gt;&lt;code&gt;6&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当执行到地址指令为&lt;code&gt;6&lt;/code&gt;、&lt;code&gt;7&lt;/code&gt;、&lt;code&gt;8&lt;/code&gt;时，将局部变量表中索引位置为&lt;code&gt;1&lt;/code&gt;和&lt;code&gt;2&lt;/code&gt;的数据重新加载到操作数栈中并进行&lt;code&gt;iadd&lt;/code&gt;加操作，将得到的结果值存到操作数栈中，PC寄存器中的值也由&lt;code&gt;6&lt;/code&gt;-&amp;gt;&lt;code&gt;7&lt;/code&gt;-&amp;gt;&lt;code&gt;8&lt;/code&gt;-&amp;gt;&lt;code&gt;9&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行操作指令&lt;code&gt;istore_3&lt;/code&gt;，将操作数栈中的数据取出存到局部变量表中索引为&lt;code&gt;3&lt;/code&gt;的位置，执行return指令，方法结束。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果被调用的方法带有返回值，其返回值会被压入当前栈帧的操作数栈中，并更新pc寄存器中下一条需要执行的字节码指令。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;栈顶缓存技术：将栈顶的元素全部缓存到物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;动态链接 Dynamic Linking&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6544117647058824&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8ZDIpfMjuum0381k5ajLJLjdO13AywrwSianr4yVjvMuzmO6icC23a6NA/640?wx_fmt=png&quot;/&gt;当字节码文件被加载到虚拟机后，字节码文件中的一些数据，如类型信息、域信息、方法信息等，就会被放置到方法区中，而字节码文件中的常量池则会进入方法区中的运行时常量池。每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。动态链接就是在“类加载”中“链接”的“解析阶段”将符号引用转化为直接引用的过程。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47898230088495575&quot; data-type=&quot;png&quot; data-w=&quot;904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8EO2iaibEaoufjHUb0Cmic8jyicQO6e1Z8BKZeib6LZbbP9z7K4JrUrvwFng/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么字节码文件需要常量池？因为字节码文件需要数据支持，通常这种数据会很大，以至于不能直接存放到字节码中，换一种方式，可以将指向这些数据的符号引用存到字节码文件的常量池中，这样字节码只需使用常量池就可以在运行时通过动态链接找到相应的数据并使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法返回地址 Return Address&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法返回地址是用来存放调用该方法的PC寄存器的值的。我们都知道，方法的结束有两种方式：一种是正常执行完成；一种是出现未处理的异常，非正常退出。无论哪种方式退出，在方法退出后都返回到该方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。方法正常退出时，当前线程的pc寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器的值等，让调用者方法继续执行下去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照方法完成出口方式的不同又分为正常完成出口和异常完成出口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正常完成出口的字节码指令中的返回值类型为&lt;code&gt;ireturn&lt;/code&gt;（&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;）、&lt;code&gt;lreturn&lt;/code&gt;（&lt;code&gt;long&lt;/code&gt;）、&lt;code&gt;freturn&lt;/code&gt;（&lt;code&gt;float&lt;/code&gt;）、&lt;code&gt;dreturn&lt;/code&gt;（&lt;code&gt;double&lt;/code&gt;）、&lt;code&gt;areturn&lt;/code&gt;（引用类型）和&lt;code&gt;return&lt;/code&gt;（void、实例初始化方法、类和接口的初始化方法）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在方法执行过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常处理表中没有搜索到匹配的异常处理器，就会导致方法的退出，简称异常完成出口。异常处理表是用来存储方法执行过程中抛出异常时的异常处理的，方便在发生异常的时候找到处理异常的代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;两种方式的本质区别就是异常完成出口退出时不会给他的上层调用者产生任何的返回值。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一些附加信息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈帧中还允许携带与Java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本地方法栈&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说起本地方法栈，我们先来介绍一下本地方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;本地方法 Native Method&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先本地方法是不在运行时数据区中的，它的位置如图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5965978128797084&quot; data-type=&quot;png&quot; data-w=&quot;823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb88Byxno7shqibPP4q06fDXP49gB5K5aibY34vyTmNwgdvo9yhbg8MdHGQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地方法其实就是java调用非java代码的接口，该接口由非java语言实现。本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C/C++程序。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7718978102189781&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNGjCQGXxZtpH2AcnXBibhb8RdwBfpSXTEoYv0o5lODGHTSw7IV7GnxsG8hell4YJlFIXkVCdQyticw/640?wx_fmt=png&quot;/&gt;&lt;code&gt;native&lt;/code&gt;可以与所有其他的java标识符连用，但是&lt;code&gt;abstract&lt;/code&gt;除外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要使用&lt;code&gt;Native Method&lt;/code&gt;？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与Java环境外交互：有时候java应用需要与java外边的环境进行交互；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与操作系统进行交互：使用本地方法，我们可以用java实现jre与底层系统的交互；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sun&#x27;s Java:Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;本地方法栈 Native Method Stack&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地方法栈是用来管理本地方法的调用的，也是线程私有的。他也允许被实现成固定或者可动态扩展的内存大小，在内存溢出方面与虚拟机栈类似。本地方法栈的具体做法是&lt;code&gt;Native Method Stack&lt;/code&gt;中登记&lt;code&gt;native&lt;/code&gt;方法，在&lt;code&gt;Execution Engine&lt;/code&gt;执行时加载本地方法库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当某个线程调用本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界，他和虚拟机拥有同样的权限：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以直接使用本地处理器中的寄存区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接从本地内存的堆中分配任意数量的内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是今天的全部内容了，如果你感兴趣的话，可以关注微信公众号“阿Q说代码”！你也可以后台留言领取&lt;code&gt;java&lt;/code&gt;干货资料:学习笔记与大厂面试题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;内容推荐&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5MDg2NjEzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMAn4Ha81WVBfsKnC9ficVemZff27LiaSoKX83JqwnNmrNhb4D4oAjW7wiaDwtkLTTCRs1A1hanfNu9g/0?wx_fmt=png&quot; data-nickname=&quot;阿Q说代码&quot; data-alias=&quot;AQ_Shuo&quot; data-signature=&quot;每天带给你不一样的精彩！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;觉得还不错？&lt;/span&gt;&lt;span&gt;记得一键四连呦👇&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>499e498add8381eb0fa5976d0d608243</guid>
<title>结合SQL解析的ClickHouse表生命周期管理</title>
<link>https://toutiao.io/k/gu1652m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3MTU2MTY5Nw==&amp;amp;action=getalbum&amp;amp;album_id=1812289408469925890#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1812289408469925890&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#ClickHouse企业级最佳实践&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;16个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 问题背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在我们日常的业务中，数据往往以库表的形式呈现，数据生产和数据消费则分别对应着库表的创建和查询。对于&lt;/span&gt;ClickHouse而言，数据的生成是上游库表的同步导入，数据的消费是用户通过诸如BI平台等服务对库表进行查询。理论上，按照业务的需求，每个ClickHouse的表都应该有一个相应的生命周期，假设所有的表都以天粒度为分区，则某些表往往只需要保留一周或一个月的数据，其它有一些表可能需要保留三个月或半年，可见不同的表生命周期应该是不一样的。但&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;问题在于如何为每个表设定合适的生命周期？过长的生命周期会造成存储资源的浪费，占满&lt;/span&gt;ClickHouse集群的磁盘空间，而过短的生命周期可能不能满足业务方的需求，导致查不出需要的数据。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;我们过往的做法是，在&lt;/span&gt;ClickHouse入库前，让用户填写生命周期。但这样的做法并未能从根本上解决问题，究其原因总结下来有以下几点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着业务发展，业务方对于同一张表的生命周期的需求也在不断地发生变化。一开始需要存储一年的数据，经过一段时间之后可能只需要一个月甚至已经逐渐废弃无人问津，但业务方可能并不会去修改这个生命周期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;业务方有时候自己也并不知道生命周期要设多久才合适，这种情况下用户一般会选择偏大的生命周期，但最终使用的时候其实只用了最近几天的数据，以致于造成&lt;/span&gt;ClickHouse集群磁盘空间的浪费。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;最初建表的用户并不一定是查询数据的用户，通常某一张表建立之后，会有多个用户同时使用这一张表，真正使用该表的用户往往对生命周期是无感的，他们不一定有义务或者并不一定能意识到表生命周期的问题。最初填写生命周期的用户可能在一段时间之后也离职了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;综合上述的几个因素，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;我们需要一套自动探测&lt;/span&gt;ClickHouse库表生命周期的解决方案，降低生命周期的人工干预成本，做到更精确地评估库表生命周期，从而进一步提高ClickHouse集群磁盘空间利用率，降低查询响应时延（减少不必要的数据扫描时间）。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;为了解决这一问题，我们从&lt;/span&gt;ClickHouse的审计日志中对历史SQL进行分析，得出一段时间内每个表在查询时所涉及到的最大分区范围（SQL所覆盖的分区字段的天数），进而根据分区范围作为表的生命周期。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 解决方案: 结合历史SQL解析的表生命周期管理方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 整体思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;整体思路可以拆解为以下几步：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从审计日志中筛选出近10天内接受过的所有SQL请求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt; 利用AST Parser对SQL进行解析，找出每个SQL所涉及到的表及其分区范围。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt; 统计所有的表所涉及到的最大分区范围，将最大分区范围设置为该表的生命周期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;上述的几个步骤中，最为关键的是第二步，需要根据&lt;/span&gt;SQL解析出所涉及到的分区范围。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 基于AST Parser解析SQL的分区范围&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;为了解析&lt;/span&gt;SQL的分区范围，在实现层面首先要将SQL解析成AST，随后再对AST进行遍历找到所涉及到的分区范围，如图1所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7512562814070352&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qaWuZTGK0vyYLeCe7CADpXic76DSSzbHy33t9SqqjJGd8l5l4GguZuoeibDRiczEicqFv7guPu9e0ichfQdfDsFpnJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;图&lt;/span&gt;1 解析SQL分区范围的过程&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;其中，遍历&lt;/span&gt;AST时有以下几个关键的步骤需要实现：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;遍历AST，遍历过程中需要获取到ClickHouse的元数据信息（包括表的分区字段名等），最后在遍历AST的对比表达式节点时，解析出所有与分区字段名相关的过滤条件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;合并过滤条件得出最终的分区范围。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;举例来说，下面的这一段&lt;/span&gt;SQL，在经过第二步之后会得出如图2所示左右两边的两个分区范围，进一步合并之后得到一个完整的分区范围。需要注意的是，合并的过程需要考虑到到底是要取并集还是交集。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FROM t1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;WHERE&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    (ftime &amp;gt;= &#x27;2021-09-01&#x27; AND ftime &amp;lt;= &#x27;2021-09-10&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    OR ftime IN (&#x27;2021-08-01&#x27;, &#x27;2021-08-02&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15254237288135594&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qaWuZTGK0vyYLeCe7CADpXic76DSSzbHyfLf06vUkOVFK5y0UqWicia4aC5BwCK84ficO2Et6VHgA8fY6AvgttZDWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;413&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;图&lt;/span&gt;2 分区范围合并&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;所涉及到的&lt;/span&gt;AST解析的代码已经抽取成ClickHouse AST Parser，有需要的同学可以参考使用 &lt;/span&gt;&lt;span&gt;&lt;span&gt;https://github.com/JiamingMai/clickhouse-ast-parser&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3 ClickHouse AST Parser的使用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;ClickHouse AST Parser不仅仅是一个SQL语法的解析器，而是一个提供了AST 相关搜索功能的工具，主要的应用场景在于将SQL语句转换为 AST，并进一步利用解析后的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;目前&lt;/span&gt;ClickHouse AST Parser实现了以下几种场景：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;给定SQL语句，找出与该SQL相关的表名。基于它可以实现热点表分析、缓存机制等功能。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;String sql = &quot;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; t1.id, &lt;span class=&quot;code-snippet__keyword&quot;&gt;count&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; total_count &lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; my_db1.table1 t1 &lt;span class=&quot;code-snippet__keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;JOIN&lt;/span&gt; my_db2.table2 t2 &lt;span class=&quot;code-snippet__keyword&quot;&gt;ON&lt;/span&gt; t1.id = t2.id &lt;span class=&quot;code-snippet__keyword&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt; t1.id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;AstParser astParser = new AstParser();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;INode ast = (INode) astParser.parse(sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ReferredTablesDetector referredTablesDetector = new ReferredTablesDetector();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// tables should be [&quot;&lt;/span&gt;my_db1.table1&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, &quot;&lt;/span&gt;my_db2.table2&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;] in this caseList&amp;lt;String&amp;gt; tables = referredTablesDetector.searchTables(ast);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;其中，&lt;/span&gt;AstParser可以解析SQL，得到对应的AST。ReferredTablesDetector用于检测SQL中所涉及到的所有表&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MetadataService metadataService = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MetadataService() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; getPartitionColName(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; tableFullName) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; getTables() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// &lt;span class=&quot;code-snippet__doctag&quot;&gt;TODO:&lt;/span&gt; implement this method&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; todayDate = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2022-01-01&quot;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// for parsing UDF like today() and yesterday() in the SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; targetIP = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// the node to get metadata&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ReferredPartitionsDetector referredPartitionsDetector = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ReferredPartitionsDetector(todayDate, targetIp, metadataService);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;List&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; partitionRangeList = referredPartitionsDetector.searchTablePartitions(ast);&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;其中，&lt;/span&gt;ReferredPartitionsDetector用于检测SQL中所涉及到的所有表及其分区范围，使用时需要传入一个MetadataService的实现类，用于获取ClickHouse的元数据。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public interface MetadataService {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String getPartitionColName(String tableFullName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;String&amp;gt; getTables();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;抽取Distributed引擎表的参数信息。ClickHouse的&lt;/span&gt;&lt;span&gt;Distributed引擎给予了我们灵活的数据组织方式，但有时我们确实需要提取Distributed引擎表里的相关信息，比如所涉及到的cluster、database和table。单纯使用正则表达式来提取很容易出错，尤其是当CREATE TABLE建表语句中有复杂的注释时，容易抽取出注释的内容。通过AST解析可以比较好地解决这个问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;String sql = &quot;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; my_db.my_tbl (&lt;span class=&quot;code-snippet__built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;String&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;Engine&lt;/span&gt; = &lt;span class=&quot;code-snippet__keyword&quot;&gt;Distributed&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;my_cluster&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;my_db&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;my_tbl_local&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;rand&lt;/span&gt;())&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DistributedTableInfoDetector distributedTableInfoDetector = new DistributedTableInfoDetector();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// clusterName is &quot;&lt;/span&gt;my_cluster&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;String clusterName = distributedTableInfoDetector.searchCluster(sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// tableFullName is &quot;&lt;/span&gt;my_db.my_tbl_local&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;String tableFullName = distributedTableInfoDetector.searchLocalTableFullName(sql);&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;改写SQL，优化效率。目前只实现了对JOIN操作增加GLOBAL关键字，更多的改写逻辑可以在日后更新，帮助提高SQL效率，在解析层屏蔽掉慢查询SQL。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; sql = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SELECT t1.id, count(1) as total_count FROM my_db1.table1 t1 LEFT JOIN my_db2.table2 t2 ON t1.id = t2.id GROUP BY t1.id&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;AstParser astParser = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; AstParser(&lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SelectUnionQuery ast = (SelectUnionQuery) astParser.parse(sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GlobalJoinAstRewriter globalJoinAstRewriter = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; GlobalJoinAstRewriter();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; rewrittenSql =  globalJoinAstRewriter.visit((INode) ast);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// the rewritten SQL should be:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// SELECT t1.id, count(1) as total_count FROM my_db1.table1 t1 GLOBAL LEFT JOIN my_db2.table2 t2 ON t1.id = t2.id GROUP BY t1.id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;各个使用的方法也可以测试用例中找到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 效果表现及后续工作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;通过本文方法对&lt;/span&gt;ClickHouse库表生命周期进行梳理后，我们发现了大量的表设置了过长的生命周期，最终集群内有大概1/3的冗余数据可以清理，大幅度减少了整体的磁盘空间占用率，降低了查询时延。目前对于较为复杂的SQL还没有办法解析出分区范围，还需要进一步完善，也欢迎各位同学一起参与完善。也可以基于本文方法将估算&lt;/span&gt;&lt;span&gt;得出的生命周期推送给业务方，让业务方确认，询问生命周期是否合理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;作者介绍：麦嘉铭，前后就职于阿里云和BIGO，目前在腾讯音乐参与大数据分析平台建设，主要负责Clickhouse和Presto的运维和开发&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;69&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;作者介绍：麦嘉铭，前后就职于阿里云和BIGO，目前在腾讯音乐参与大数据分析平台建设，主要负责Clickhouse和Presto的运维和开发&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45698166431593795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qaWuZTGK0vw7z5BmWCugw8u4jEtuIdzUy1kLSOJMwddpB7HuKRnuuFdClBVeFU51VOgKicjTY7PM5icUrZc8qOkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;709&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3MTU2MTY5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/qaWuZTGK0vyyol5c8Ghtg2YFBKehLlXUcSPHrJuFTSHWGFia5ecvBtAoyG6fAZk1W4ouzBGkYPHFUYibibIYZSr3g/0?wx_fmt=png&quot; data-nickname=&quot;ClickHouse开发者&quot; data-alias=&quot;ClickHouseGroup&quot; data-signature=&quot;华人ClickHouse社区订阅号，同步一些ClickHouse最新的技术，使用经验，Meetup信息。详情参见 www.clickhouse.com.cnby guodaxia2999&quot; data-from=&quot;1&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>