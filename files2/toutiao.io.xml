<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6c6b5c685e9a58703762624e865fb054</guid>
<title>五一假期不想人挤人？来这里！</title>
<link>https://toutiao.io/k/ok4mp6n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;调休凑的五一小长假终于要来了！&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;抛开 “实际只放了半天” 的小情绪，好好放松一下吧！&lt;/strong&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34841628959276016&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNaviceqLPCc4PwSgmSN5yTT69y8dECkDGSCSY210dpIOoKk2e5syPmOeu4yLlDpO4YgibWhYgbFAkHgSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;884&quot;/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;假期去哪玩呢？小心人从众哦！&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/c2Sib3Mp7pOMic7Juicyxo7vsjvhibIibiayDib5VMxsrWKHhm3RvF4ZciambwKWKBaYwa9KRvzOnyDck4TOwLs0JcPcHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.7556270096463023&quot; data-w=&quot;311&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;宅吗？怕无聊的话，继续往下看！五一小长假，周刊菌陪你哦！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4517453798767967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AjN1jquNaviceqLPCc4PwSgmSN5yTT69yXsQGL1BvcduO2ZWcCfyE5ArUSic5pRxon4ia7M9Dn5vpRdia6573OQjhg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;487&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>734d79122729ad59f3366876001848ee</guid>
<title>[译] Pulsar 和 Kafka 架构对比</title>
<link>https://toutiao.io/k/jpoc824</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;本文作者是 David Kjerrumgaard，目前任职于 Splunk，Apache Pulsar 和 Apache NiFi 项目贡献者。译者为 Sijia@StreamNative。原文链接：https://searchdatamanagement.techtarget.com/post/Apache-Pulsar-vs-Kafka-and-other-data-processing-technologies，翻译已获授权。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;h1&gt;关于 Apache Pulsar&lt;/h1&gt;&lt;p&gt;Apache Pulsar 是 Apache 软件基金会顶级项目，是下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&lt;br/&gt;GitHub 地址：http://github.com/apache/pulsar/&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;相比于 Kafka 等数据处理中间件，分布式消息平台 Apache Pulsar 如何存储数据？本文基于架构，对比了 Apache Kafka 等传统数据处理中间件和分布式消息平台 Apache Pulsar 的优劣势，供大家参考。&lt;/p&gt;&lt;h1&gt;存储可扩展&lt;/h1&gt;&lt;p&gt;Apache Pulsar 的多层架构将消息服务层与存储层完全解耦，从而使各层可以独立扩展。传统的分布式数据处理中间件（如 Hadoop、Spark）则在同一集群节点/实例上处理和存储数据。这种设计可以降低通过网络进行传输的数据量，使得架构更简洁，性能也有所提升，但同时扩展性、弹性、运维受到了影响。&lt;/p&gt;&lt;p&gt;Pulsar 的分层架构在云原生解决方案中独树一帜。如今，大幅提升的网络带宽为此架构提供了坚实基础，有利于计算和存储的分离。Pulsar 的架构将服务层与存储层解耦：无状态 broker 节点负责数据服务；bookie 节点负责数据存储（如图 1）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;353&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6114285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0YDVgeYRaWbLcqBpCc6TQ9D0tNg29uiarTbydsichIwng5IUlU5AUQaex0u1fO0jPC3OBgXiaeuncsAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 1. 服务层与存储层解耦&lt;/p&gt;&lt;p&gt;服务层与存储层解耦的架构有很多优势。首先，各层都可以弹性扩展，彼此之间互不影响。借助云和容器等环境的弹性能力，各层可以自动扩缩容，动态适应流量高峰。其次，通过显著降低集群扩展和升级复杂性，提高了系统可用性和可管理性。再次，这种设计还属于容器友好型设计，使 Pulsar 成为托管云原生流系统的最佳方案。Apache Pulsar 使用高可扩展的 BookKeeper 作为存储层，实现了强大的持久保证与分布式数据存储和复制，并原生支持跨地域复制。&lt;/p&gt;&lt;p&gt;多层设计可以轻松实现分层存储，从而可以将访问频率较低的数据卸载到低成本的持久化存储（如 AWS S3、Azure 云）中。Pulsar 支持配置预定义的存储大小或时间段，自动将存储在本地磁盘的数据卸载至云存储平台，释放本地磁盘，同时安全备份事件数据。&lt;/p&gt;&lt;h1&gt;Pulsar vs. Kafka&lt;/h1&gt;&lt;p&gt;Apache Pulsar 和 Apache Kafka 都具有类似的消息传递概念。客户端通过 topic（逻辑上分为多个分区）与二者进行交互。通常而言，写入 topic 的无限数据流会被分为分区（特定数量、大小相等的分组），从而使数据均匀分布在系统中，并被多个客户端同时使用。&lt;/p&gt;&lt;p&gt;Apache Pulsar 和 Apache Kafka 之间的本质区别在于存储分区的基础架构。Apache Kafka 是基于分区的发布/订阅系统，旨在作为整体架构运行，服务层和存储层位于同一节点上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;161&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2785714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0YDVgeYRaWbLcqBpCc6TQ9DB78UzmcyU62RxWKt5QrklibvxYLoT9Wjibv9KcWL8oUxXXrj2AdQASyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 2. Kafka 分区&lt;/p&gt;&lt;h1&gt;Kafka 存储：基于分区&lt;/h1&gt;&lt;p&gt;在 Kafka 中，分区数据作为 leader 节点上的单个连续数据存储，然后复制到副本节点上（副本节点可预配置），实现数据多副本。这种设计通过两种方式限制了分区的容量，并扩展了 topic。首先，由于分区只能存储在本地磁盘中，分区大小取决于主机上最大的单个磁盘大小（“新”安装用户的磁盘大小约为 4 TB）；其次，由于必须复制数据，所以分区的大小不能超过副本节点上最小磁盘空间的大小。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;597&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.032857142857143&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0YDVgeYRaWbLcqBpCc6TQ9DksM9HJd3yYU3Cf0cEuxxzPOMTvEKamJGP4OhFh5PSNPSCSpPNlaD4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 3. Kafka 故障和扩容&lt;/p&gt;&lt;p&gt;假设可以将 leader 存储在新节点上，磁盘大小为 4 TB 且只用于分区存储，两个副本节点的存储容量都为 1 TB 。在向 topic 发布 1 TB 数据后，Kafka 将检测到副本节点无法继续接收数据，并且在副本节点释放空间之前，不能继续向该 topic 发布消息（如图 3）。如果 producer 在中断期间无法缓冲消息，则可能会造成数据丢失。&lt;/p&gt;&lt;p&gt;面对这一问题，有两种解决方案：删除磁盘上的数据，存储现有副本节点，但由于来自其他 topic 的数据可能还没有被消费，可能会导致数据丢失；或为 Kafka 集群添加新节点并“重平衡”分区，将新增节点用作副本节点。但是这需要重新复制整个 1 TB 的分区，耗时、易出错，对网络带宽和磁盘 IO 要求高，且代价高昂。此外，对于具有严格 SLA 的程序而言，离线复制的方案并不可取。&lt;/p&gt;&lt;p&gt;使用 Kafka，不仅在扩展集群时需要重新复制分区数据，其他故障也可能需要重新复制分区数据，如副本故障、磁盘故障、计算机故障等。如果没有在生产环境中出现故障，我们通常会忽视 Kafka 的这一弊端。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;388&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6714285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0YDVgeYRaWbLcqBpCc6TQ9DYkUeUwEgQgY33qMKq2M0n23HoJMxejice5qJSbgGs1icDE2C3bNPll0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 4. Pulsar 分片&lt;/p&gt;&lt;h1&gt;Pulsar 存储：基于分片&lt;/h1&gt;&lt;p&gt;在基于分片的存储架构（如 Apache Pulsar 使用的架构）中，分区被进一步分成分片，可以根据预先配置的时间或大小进行滚动。分片均匀分布在存储层的 bookie 中，实现数据多副本和扩容。&lt;/p&gt;&lt;p&gt;当 bookie 磁盘空间用尽，不能继续向其中写入数据时，Kafka 需要重新复制数据，Pulsar 如何应对这种场景呢？由于分区被进一步分成分片，因此无需复制整个 bookie 的内容到新增 bookie 中。在添加新 bookie 前，Pulsar 可以继续接收新数据分片，并写入存储容量未满的 bookie 中。添加新 bookie 时，新节点和新分区上的流量立即自动增加，无需重新复制旧数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;397&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6871428571428572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0YDVgeYRaWbLcqBpCc6TQ9Dn56ZjUlJ8rCTc6zG4MPics1VPhlFRr1cJiaB44k2c8Y62eQZpd0k2WcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 5. Pulsar 故障和扩容&lt;/p&gt;&lt;p&gt;如图 5 所示，在第 4 个 bookie 节点不再继续接收新消息分片时，消息分片 4-7 被路由到其他活跃 bookie 上。新增 bookie 后，分片自动被路由到新 bookie 上。整个过程中，Pulsar 始终在运行，并且可以为 producer 和 consumer 提供服务。在这种情况下，Pulsar 的存储系统更加灵活，高可扩展。&lt;/p&gt;&lt;h1&gt;相关阅读&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247487469&amp;amp;idx=1&amp;amp;sn=0e741c229fb8d3d4947eeef7a637622c&amp;amp;scene=21#wechat_redirect&quot; title=&quot;Apache Pulsar 在自研数据管道中的技术实践&quot; data-linktype=&quot;2&quot;&gt;Apache Pulsar 在自研数据管道中的技术实践&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247487414&amp;amp;idx=1&amp;amp;sn=850ec2ccc4d2847066a98a899bd0ce1f&amp;amp;scene=21#wechat_redirect&quot; title=&quot;多图详解 Apache Pulsar 消息存储模型&quot; data-linktype=&quot;2&quot;&gt;多图详解 Apache Pulsar 消息存储模型&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247487170&amp;amp;idx=1&amp;amp;sn=8d62cc438683565f31d0f2ed390e4c98&amp;amp;scene=21#wechat_redirect&quot; title=&quot;译文｜借助 Pulsar Functions 迁移到无服务应用程序&quot; data-linktype=&quot;2&quot;&gt;译文｜借助 Pulsar Functions 迁移到无服务应用程序&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMjkzMjA1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0Y7icPiahxgXFRw8a0xAIxOhPqYtRDr0IRNpGRl2oSfGHuvkG9VtahW9thH3btBGXJu9y2dZgb3oOuQ/0?wx_fmt=png&quot; data-nickname=&quot;ApachePulsar&quot; data-alias=&quot;ApachePulsar&quot; data-signature=&quot;Apache 软件基金会顶级项目，下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4ibRRsibIGr0bRQVIYKG8oca1d6kIhdq4om9LWuRZicrc5kIexZhRG7icPuvx2lZFU6ia9Eib3G0yWrHQUYKqMQM6JQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击“阅读原文”，获取 Apache Pulsar 硬核干货资料！&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>736756c460d9f7037c30eecca095673c</guid>
<title>[译] Linux 系统安全强化指南</title>
<link>https://toutiao.io/k/4fpatsr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本指南旨在说明如何尽可能地加强Linux的安全性和隐私性，并且不限于任何特定的指南。&lt;/p&gt;&lt;p&gt;免责声明：如果您不确定自己在做什么，请不要尝试在本文中使用任何内容。&lt;/p&gt;&lt;p&gt;本指南仅关注安全性和隐私性，而不关注性能，可用性或其他内容。列出的所有命令都将需要root特权。以“$”符号开头的单词表示一个变量，不同终端之间可能会有所不同。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;选择正确的Linux发行版&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择一个好的Linux发行版有很多因素。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;避免分发冻结程序包，因为它们在安全更新中通常很落后&lt;/p&gt;&lt;p&gt;不使用与Systemd机制的发行版。 Systemd包含许多不必要的攻击面；它尝试做的事情远远超出了必要，并且超出了初始化系统应做的事情。&lt;/p&gt;&lt;p&gt;使用musl作为默认的C库。 Musl专注于最小化，这会导致很小的攻击面，而其他C库（例如glibc）过于复杂，容易产生漏洞。例如，与musl中的极少数漏洞相比，glibc中的一百多个漏洞已被公开披露。尽管仅靠披露的CVE本身通常是不准确的统计信息，但有时这种情况有时可以用来表示过分的问题。 Musl还具有不错的漏洞利用缓解措施，尤其是其新的强化内存分配器。&lt;/p&gt;&lt;p&gt;最好默认情况下使用LibreSSL而不是OpenSSL的发行版。OpenSSL包含大量完全不必要的攻击面，并且遵循不良的安全做法。例如，它仍然保持OS / 2和VMS支持这些已有数十年历史的古老操作系统。这些令人讨厌的安全做法导致了可怕的Heartbleed漏洞。LibreSSL是OpenBSD团队的OpenSSL分支，它采用了出色的编程实践并消除了很多攻击面。在LibreSSL成立的第一年内，它缓解了许多漏洞，其中包括一些高严重性的漏洞。&lt;/p&gt;&lt;p&gt;用作强化操作系统基础的最佳发行版是Gentoo Linux，因为它可以让您精确地配置系统，以达到理想的效果，这将非常有用，尤其是参考我们在后面的章节中使用更安全的编译标志。&lt;/p&gt;&lt;p&gt;但是，由于Gentoo的巨大可用性缺陷，它对于许多人来说可能并不顺手。在这种情况下，Void Linux的Musl构建是一个很好的折衷方案。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内核&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核是操作系统的核心，不幸的是很容易受到攻击。正如Brad Spengler曾经说过的那样，可以将其视为系统上最大，最易受攻击的setuid根二进制文件。因此，对内核进行尽可能多的强化非常重要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Stable vs LTS 内核&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux内核以两种主要形式发布：稳定和长期支持（LTS）。稳定版本是较新的版本，而LTS发行版本是较老的稳定版本，长期以来一直受支持。选择上述任何一个发行版本都有许多后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux内核未使用CVE标识安全漏洞。这意味着大多数安全漏洞的修复程序不能向后移植到LTS内核。但是稳定版本包含到目前为止进行的所有安全修复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，有了这些修复程序，稳定的内核将包含更多新功能，因此大大增加了内核的攻击面，并引入了大量新错误。相反，LTS内核的受攻击面较小，因为这些功能没有被不断添加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，稳定的内核还包括更新的强化功能，以减轻LTS内核没有的某些利用。此类功能的一些示例是Lockdown LSM和STACKLEAK GCC插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总而言之，在选择稳定或LTS内核时需要权衡取舍。LTS内核具有较少的强化功能，并且并非当时所有的公共错误修复都已向后移植，但是通常它的攻击面更少，并且引入未知错误的可能性也较小。稳定的内核具有更多的强化功能，并且包括所有已知的错误修复，但它也具有更多的攻击面以及引入更多未知错误的机会更大。最后，最好使用较新的LTS分支（如4.19内核）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Sysctl&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sysctl是允许用户配置某些内核设置并启用各种安全功能或禁用危险功能以减少攻击面的工具。要临时更改设置，您可以执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sysctl -w &lt;span&gt;$tunable&lt;/span&gt; = &lt;span&gt;$value&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要永久更改sysctls，您可以将要更改的sysctls添加到/etc/sysctl.conf或/etc/sysctl.d中的相应文件，具体取决于您的Linux发行版。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是您应更改的建议sysctl设置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kernel self-protection&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.kptr_restrict=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核指针指向内核内存中的特定位置。这些在利用内核方面可能非常有用，但是默认情况下不会隐藏内核指针，例如，通过读取/proc/kallsyms的内容即可轻松发现它们。此设置旨在减轻内核指针泄漏。另外，您可以设置kernel.kptr_restrict = 1以仅从没有CAP_SYSLOG功能的进程中隐藏内核指针。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.dmesg_restrict=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dmesg是内核日志，它公开了大量有用的内核调试信息，但这通常会泄漏敏感信息，例如内核指针。更改上述sysctl设置会将内核日志限制为CAP_SYSLOG功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.printk=3 3 3 3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管dmesg_restrict的值，启动过程中内核日志仍将显示在控制台中。能够在引导过程中记录屏幕的恶意软件可能会滥用此恶意软件以获得更高的特权。此选项可防止这些信息泄漏。必须将其与下面描述的某些引导参数结合使用才能完全有效。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.unprivileged_bpf_disabled=1&lt;br/&gt;net.core.bpf_jit_harden=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;eBPF暴露了很大的攻击面，因此需加以限制。这些系统将eBPF限制为CAP_BPF功能（在5.8之前的内核版本上为CAP_SYS_ADMIN），并启用JIT强化技术，例如常量绑定。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dev.tty.ldisc_autoload=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将加载TTY行规则限制为CAP_SYS_MODULE功能，以防止非特权的攻击者使用TIOCSETD ioctl加载易受攻击的线路规则，而该TIOCSETD ioctl之前已在许多漏洞利用中被滥用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vm.unprivileged_userfaultfd=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;userfaultfd() 系统调用经常被滥用以利用“事后使用(use-after-free)”缺陷。因此，该sysctl用于将此syscall限制为CAP_SYS_PTRACE功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.kexec_load_disabled=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kexec是一个系统调用，用于在运行时引导另一个内核。可以滥用此功能来加载恶意内核并在内核模式下获得任意代码执行能力，因此该sysctl设置将被禁用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.sysrq=4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SysRq密钥向非特权用户公开了许多潜在的危险调试功能。与通常的假设相反，SysRq不仅是物理攻击的问题，而且还可以远程触发。该sysctl的值使其可以使用户只能使用SAK密钥，这对于安全地访问root是必不可少的。或者，您可以简单地将值设置为0以完全禁用SysRq。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.unprivileged_userns_clone=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户名称空间是内核中的一项功能，旨在改善沙箱并使非特权用户易于访问它，但是，此功能公开了重要的内核攻击面，以进行特权升级，因此该sysctl将用户名称空间的使用限制为CAP_SYS_ADMIN功能。对于无特权的沙箱，建议使用具有很少攻击面的setuid二进制文件，以最大程度地减少特权升级的可能性。沙箱章节部分将进一步讨论此主题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，尽管该sysctl仅在某些Linux发行版中存在，因为它需要内核补丁。如果您的内核不包含此补丁，则可以通过设置user.max_user_namespaces = 0来完全禁用用户名称空间（包括root用户）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.perf_event_paranoid=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能事件会增加大量内核攻击面，并导致大量漏洞。此sysctl设置将性能事件的所有使用限制为CAP_PERFMON功能（5.8之前的内核版本为CAP_SYS_ADMIN）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，此sysctl设置需要在某些发行版中具备相关的内核补丁。否则，此设置等效于kernel.perf_event_paranoid = 2，它仅限制此功能的子集。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网络&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.tcp_syncookies=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这有助于防止SYN泛洪攻击，这种攻击是拒绝服务攻击的一种形式，在这种攻击中，攻击者发送大量虚假的SYN请求，以尝试消耗足够的资源以使系统对合法流量不响应。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.tcp_rfc1337=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这通过丢弃处于时间等待状态的套接字的RST数据包来防止time-wait状态。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.conf.all.rp_filter=1&lt;br/&gt;net.ipv4.conf.default.rp_filter=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些启用了源验证，以验证从计算机所有网络接口接收到的数据包。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.conf.all.accept_redirects=0&lt;br/&gt;net.ipv4.conf.default.accept_redirects=0&lt;br/&gt;net.ipv4.conf.all.secure_redirects=0&lt;br/&gt;net.ipv4.conf.default.secure_redirects=0&lt;br/&gt;net.ipv6.conf.all.accept_redirects=0&lt;br/&gt;net.ipv6.conf.default.accept_redirects=0&lt;br/&gt;net.ipv4.conf.all.send_redirects=0&lt;br/&gt;net.ipv4.conf.default.send_redirects=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些设置禁用了ICMP重定向，以防止中间人攻击并最大程度地减少信息泄露。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.icmp_echo_ignore_all=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此设置使您的系统忽略所有ICMP请求，以避免Smurf攻击，使设备更难以在网络上枚举，并防止通过ICMP时间戳识别时钟指纹。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.conf.all.accept_source_route=0&lt;br/&gt;net.ipv4.conf.default.accept_source_route=0&lt;br/&gt;net.ipv6.conf.all.accept_source_route=0&lt;br/&gt;net.ipv6.conf.default.accept_source_route=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源路由是一种允许用户重定向网络流量的机制。由于这可用于执行中间人攻击，在中间人攻击中，出于恶意目的将流量重定向，因此上述设置将会禁用此功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv6.conf.all.accept_ra=0&lt;br/&gt;net.ipv6.conf.default.accept_ra=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恶意的IPv6路由广告可能会导致中间人攻击，因此应将其禁用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.tcp_sack=0&lt;br/&gt;net.ipv4.tcp_dsack=0&lt;br/&gt;net.ipv4.tcp_fack=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;禁用TCP SACK。ACK通常被利用，并且在许多情况下是不必要的，因此如果您不需要它，则应将其禁用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用户空间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.yama.ptrace_scope=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ptrace是一个系统调用，它允许程序调试、修改和检查另一个正在运行的进程，从而使攻击者可以轻易修改其他正在运行的程序的内存。设置将ptrace的使用限制为仅具有CAP_SYS_PTRACE功能的进程。或者，将sysctl设置为3以完全禁用ptrace。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vm.mmap_rnd_bits=32&lt;br/&gt;vm.mmap_rnd_compat_bits=16&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ASLR是一种常见的漏洞利用缓解措施，它可以使进程的关键部分在内存中的位置随机化。这可能会使各种各样的漏洞利用更困难，因为它们首先需要信息泄漏。上述设置增加了用于mmap ASLR的熵的位数，从而提高了其有效性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这些sysctls的值必须根据CPU体系结构进行设置。以上值与x86兼容，但其他体系结构可能有所不同。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fs.protected_symlinks=1&lt;br/&gt;fs.protected_hardlinks=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅当在可全局写入的粘性目录之外，当符号链接和关注者的所有者匹配或目录所有者与符号链接的所有者匹配时，才允许遵循符号链接。这还可以防止没有对源文件的读/写访问权限的用户创建硬链接。这两者都阻止了许多常见的TOCTOU漏洞（time-of-check-to-time-of-use）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fs.protected_fifos=2&lt;br/&gt;fs.protected_regular=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些阻止了在可能由攻击者控制的环境（例如，全局可写目录）中创建文件，从而使数据欺骗攻击更加困难。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引导参数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引导参数在引导时使用引导加载程序（bootloader）将设置传递给内核。类似于sysctl，可以使用某些设置来提高安全性。引导加载程序通常在引导参数设置方式上有所不同。下面列出了一些示例，但是您应该研究特定bootloader的修改参数的必要步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用GRUB作为引导程序，请编辑/etc /default/grub并将参数添加到GRUB_CMDLINE_LINUX_DEFAULT=line。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用Syslinux，请编辑/boot/syslinux/syslinux.cfg并将它们添加到APPEND行中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用systemd-boot，请编辑您的加载程序条目，并将其附加到linux行的末尾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议使用以下设置以提高安全性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kernel self-protection&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;slab_nomerge&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将禁用slab合并，这将通过防止覆盖合并的缓存中的对象并使其更难以影响slab缓存的布局，从而大大增加了堆利用的难度。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;slub_debug=FZ&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些启用健全性检查（F）和重新分区（Z）。健全性检查会添加各种检查，以防止某些slab操作中的损坏。重新分区会在slab周围添加额外的区域，以检测slab何时被覆盖超过其实际大小，从而有助于检测溢出。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;init_on_alloc=1 init_on_free=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可以在分配和空闲时间期间将内存清零，这可以帮助减轻使用后使用的漏洞并清除内存中的敏感信息。如果您的内核版本低于5.3，则这些选项不存在。而是在上述slub_debug选项后面附加“ P”，以获得slub_debug=FZP并添加page_poison=1。由于它们实际上是一种调试功能，刚好具有一些安全性，因此它们在释放时提供的内存擦除形式较弱。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;page_alloc.shuffle=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此选项使页分配器空闲列表随机化，从而通过降低页分配的可预测性来提高安全性，同时这也提高了性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pti=on&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将启用内核页表隔离，从而减轻崩溃并防止某些KASLR绕过。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vsyscall=none&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将禁用vsyscall，因为它们已过时且已被vDSO取代。 vsyscall也在内存中的固定地址上，使其成为ROP攻击的潜在目标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;debugfs=off&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将禁用debugfs，它会公开许多有关内核的敏感信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;oops=panic&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时某些内核漏洞利用会导致所谓的“oops”。此参数将引发内核对此类事件panic，从而防止这些攻击。但是，有时错误的驱动程序会导致无害的操作，这会导致系统崩溃，这意味着此引导参数只能在某些硬件上使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;module.sig_enforce=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这仅允许加载已使用有效密钥签名的内核模块，使加载恶意内核模块更加困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以防止加载所有树外内核模块（包括DKMS模块），除非您已对其进行签名，这意味着诸如VirtualBox或Nvidia驱动程序之类的模块可能不可用，但根据您的设置可能并不重要。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;lockdown=confidentiality&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核锁定LSM可以消除用户空间代码滥用以升级为内核特权并提取敏感信息的许多方法。为了在用户空间和内核之间实现清晰的安全边界，此LSM是必需的。上面的选项在confidentiality模式（最严格的选项）中启用此功能。这意味着module.sig_enforce=1。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mce=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将导致内核对ECC内存中无法利用的错误panic，而这些错误可能会被利用。对于没有ECC内存的系统，这是不必要的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;quiet loglevel=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些参数可防止引导期间信息泄漏，并且必须与上面的kernel.printk sysctl结合使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CPU缓解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好启用适用于您的CPU的所有CPU缓解措施，以确保您不受已知漏洞的影响。这是启用所有内置缓解措施的列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;spectre_v2=on spec_store_bypass_disable=on tsx=off tsx_async_abort=full,nosmt mds=full,nosmt l1tf=full,force nosmt=force kvm.nx_huge_pages=force&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您必须研究系统受其影响的CPU漏洞，并相应地选择上述缓解措施。请记住，您将需要安装微代码更新，以完全免受这些漏洞的影响。但所有这些操作都可能导致性能显着下降。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果遵循了以上所有建议（不包括特定的CPU缓解措施），则将具有：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;slab_nomerge slub_debug=FZ init_on_alloc=1 init_on_free=1 page_alloc.shuffle=1 pti=on vsyscall=none debugfs=off oops=panic module.sig_enforce=1 lockdown=confidentiality mce=0 quiet loglevel=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将GRUB用作引导加载程序，则可能需要重新生成GRUB配置文件才能应用这些文件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;hidepid&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;proc是一个伪文件系统，其中包含有关系统上当前正在运行的所有进程的信息。默认情况下，所有用户都可以访问此程序，这可能使攻击者可以窥探其他进程。要只允许用户看到自己的进程，而不能看到其他用户的进程，则必须使用hidepid=2，gid=proc挂载选项来挂载/proc。gid=proc将proc组从此功能中排除，因此您可以将特定的用户或进程列入白名单。添加这些选项的一种方法是编辑/etc/fstab并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;proc /proc proc nosuid,nodev,noexec,hidepid=2,gid=proc 0 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;systemd-logind仍然需要查看其他用户的进程，因此，要使用户会话在systemd系统上正常工作，必须创建/etc/systemd/system/systemd-logind.service.d/hidepid.conf并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Service]&lt;br/&gt;SupplementaryGroups=proc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;减少内核攻击面&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好禁用不是绝对必要的任何功能，以最大程度地减少潜在的内核攻击面。这些功能不必一定很危险，它们可以只是被删除以减少攻击面的良性代码。切勿禁用您不了解的随机事物。以下是一些可能有用的示例，具体取决于您的设置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引导参数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引导参数通常可以用来减少攻击面，这样的例子之一是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ipv6.disable=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将禁用整个IPv6堆栈，如果您尚未迁移到该堆栈，则可能不需要该堆栈。如果正在使用的IPv6，请不要使用此引导参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;####将内核模块列入黑名单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核允许非特权的用户通过模块自动加载来间接导致某些模块被加载。这使攻击者可以自动加载易受攻击的模块，然后加以利用。一个这样的示例是CVE-2017-6074，其中攻击者可以通过启动DCCP连接来触发DCCP内核模块的加载，然后利用该内核模块中的漏洞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过将文件插入/etc/modprobe.d并将指定的内核模块列入黑名单的方法，将特定的内核模块列入黑名单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Install参数告诉modprobe运行特定命令，而不是像往常一样加载模块。 /bin/false是仅返回1的命令，该命令实际上不会执行任何操作。两者都告诉内核运行/bin/false 而不是加载模块，这将防止攻击者利用该模块。以下是最有可能不需要的内核模块：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;install dccp /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install sctp /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install rds /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install tipc /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install n-hdlc /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install ax25 /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install netrom /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install x25 /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install rose /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install decnet /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install econet /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install af_802154 /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install ipx /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install appletalk /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install psnap /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install p8023 /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install p8022 /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install can /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install atm /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别是模糊的网络协议会增加大量的远程攻击面。此黑名单：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DCCP — Datagram Congestion Control Protocol&lt;/p&gt;&lt;p&gt;SCTP — Stream Control Transmission Protocol&lt;/p&gt;&lt;p&gt;RDS — Reliable Datagram Sockets&lt;/p&gt;&lt;p&gt;TIPC — Transparent Inter-process Communication&lt;/p&gt;&lt;p&gt;HDLC — High-Level Data Link Control&lt;/p&gt;&lt;p&gt;AX25 — Amateur X.25&lt;/p&gt;&lt;p&gt;NetRom&lt;/p&gt;&lt;p&gt;X25&lt;/p&gt;&lt;p&gt;ROSE&lt;/p&gt;&lt;p&gt;DECnet&lt;/p&gt;&lt;p&gt;Econet&lt;/p&gt;&lt;p&gt;af_802154 — IEEE 802.15.4&lt;/p&gt;&lt;p&gt;IPX — Internetwork Packet Exchange&lt;/p&gt;&lt;p&gt;AppleTalk&lt;/p&gt;&lt;p&gt;PSNAP — Subnetwork Access Protocol&lt;/p&gt;&lt;p&gt;p8023 — Novell raw IEEE 802.3&lt;/p&gt;&lt;p&gt;p8022 — IEEE 802.2&lt;/p&gt;&lt;p&gt;CAN — Controller Area Network&lt;/p&gt;&lt;p&gt;ATM&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;install cramfs /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install freevxfs /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install jffs2 /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install hfs /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install hfsplus /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install squashfs /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install udf /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将各种稀有文件系统列入黑名单。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;install cifs /bin/&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;install nfs /bin/&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;install nfsv3 /bin/&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;install nfsv4 /bin/&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;install gfs2 /bin/&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不使用网络文件系统，也可以将其列入黑名单。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;install vivid /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vivid driver&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;驱动程序仅用于测试目的，并且是特权提升漏洞的原因，因此应禁用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;install bluetooth /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install btusb /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;禁用具有安全问题历史记录的蓝牙。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;install uvcvideo /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会禁用网络摄像头，以防止其被用来监视您。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您也可以将麦克风模块列入黑名单，但这在系统之间可能会有所不同。要查找模块的名称，请在/proc/asound/modules中查找并将其列入黑名单。例如，一个这样的模块是snd_hda_intel。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，尽管有时麦克风的内核模块与扬声器的模块相同。这意味着像这样禁用麦克风也可能会无意中禁用任何扬声器，虽然扬声器也有可能变成麦克风，所以这不一定是消极的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好从物理上删除这些设备，或者至少在BIOS/UEFI中禁用它们。禁用内核模块并不总是那么有效。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;rfkill&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过rfkill将无线设备列入黑名单，以进一步减少远程攻击面。要将所有无线设备列入黑名单，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rfkill block all&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WiFi可以通过以下方式解锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rfkill unblock wifi&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用systemd的系统上，rfkill在所有会话中均保持不变，但是，在使用其他init系统的系统上，您可能必须创建一个init脚本以在引导时执行这些命令。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他内核指针泄漏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的部分已经防止了一些内核指针泄漏，但是还有更多泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文件系统上，/boot中存在内核映像和System.map文件。/usr/src和/{,usr/} lib/modules目录中还有其他敏感的内核信息。您应该限制这些目录的文件权限，以使它们只能由root用户读取。您还应该删除System.map文件，因为除高级调试外，它们都不需要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，某些日志记录守护程序（例如systemd的journalctl）包括内核日志，可用于绕过上述dmesg_restrict保护。从adm组中删除用户通常足以撤销对以下日志的访问：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;gpasswd -d &lt;span&gt;$user&lt;/span&gt; adm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制对sysfs的访问&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sysfs是伪文件系统，可提供大量的内核和硬件信息。它通常安装在/sys上。 sysfs导致大量信息泄漏，尤其是内核指针泄漏。Whonix的security-misc软件包包括hide-hardware-info脚本，该脚本限制访问此目录以及/proc中的一些脚本，以试图隐藏潜在的硬件标识符并防止内核指针泄漏。该脚本是可配置的，并允许基于组将特定的应用程序列入白名单。建议应用此方法，并使其在启动时使用init脚本执行。或者这样&lt;span&gt;做成systemd服务&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了使基本功能在使用systemd的系统上运行，必须将一些系统服务列入白名单。这可以通过创建/etc/systemd/system/user@.service.d/sysfs.conf并添加以下内容来完成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Service]&lt;br/&gt;SupplementaryGroups=sysfs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这不能解决所有问题。许多应用程序可能仍会中断，您需要将它们正确列入白名单。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux强化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些发行版（例如Arch Linux）包括强化的内核程序包。它包含许多强化补丁程序和更注重安全性的内核配置。如果可能的话，建议安装它。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Grsecurity&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Grsecurity是一组内核修补程序，可以大大提高内核安全性。这些补丁曾经可以免费获得，但是现在&lt;span&gt;需要购买&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;了。如果可用，则强烈建议您获取它。Grsecurity提供了最新的内核和用户空间保护。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内核运行时防护&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux Kernel Runtime Guard（LKRG）是一个内核模块，可确保运行时内核的完整性并检测漏洞。它可以杀死整个类别的内核漏洞。但这并不是一个完美的缓解方法，因为LKRG在设计上可以绕开。它仅适用于现成的恶意软件。但是，尽管可能性不大，但LKRG本身可能会像其他任何内核模块一样公开新的漏洞。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自编译内核&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议编译您自己的内核，同时启用尽可能少的内核模块和尽可能多的安全性功能，以将内核的受攻击面保持在绝对最低限度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，应用内核强化补丁，例如如上所述的linux-hardened或grsecurity。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发行版编译的内核还具有公共内核指针/符号，这对于漏洞利用非常有用。编译自己的内核将为您提供独特的内核符号，连同kptr_restrict，dmesg_restrict和其他针对内核指针泄漏的强化措施，将使攻击者更加难以创建依赖于内核指针知识的漏洞利用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您就可以从&lt;span&gt;Whonix的强化内核&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;中汲取灵感或使用它。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强制访问措施&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;强制访问控制（MAC）系统对程序可以访问的内容进行细粒度的控制。这意味着您的浏览器将无权访问您的整个主目录或类似目录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常用的MAC措施是SELinux和AppArmor。SELinux比AppArmor更安全，因为它的粒度更细。例如，它是基于inode而不是基于路径的，允许强制执行明显更严格的限制，可以过滤内核ioctl等。不幸的是，这是以难以使用和难以学习为代价的，因此某些人可能会首选AppArmor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要在内核中启用AppArmor，必须设置以下引导参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;apparmor=1 security=apparmor&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要启用SELinux，请设置以下参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;selinux=1 security=selinux&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请记住，仅启用MAC措施本身并不能神奇地提高安全性。您必须制定严格的政策才能充分利用它。例如，要创建AppArmor配置文件，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;aa-genprof &lt;span&gt;$path_to_program&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开程序，然后像往常一样开始使用它。AppArmor将检测需要访问哪些文件，并将它们添加到配置文件中（如果您选择的话）。但是，仅凭这一点不足以提供高质量的配置文件。请参阅&lt;span&gt;AppArmor文档&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;以获取更多详细信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您想更进一步，则可以通过实施initramfs勾子来设置一个完整的系统MAC策略，该策略限制每个单个用户空间进程，该挂钩对init系统强制实施MAC策略。这就是Android使用SELinux的方式，以及Whonix未来将如何使用AppArmor的方式。对于加强实施最小特权原则的强大安全模型是必要的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;沙箱&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用沙箱&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沙箱可让您在隔离的环境中运行程序，该环境对系统的其余部分具有有限的访问权限或完全没有访问权限。您可以使用它们来保护应用程序安全或运行不受信任的程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议与AppArmor或SELinux一起在单独的用户帐户中使用&lt;span&gt;Bubblewrap&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;到沙箱程序。您也可以考虑改用gVisor，它的优点是为每个来宾提供了自己的内核。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些方法中的任何一个都可以用来创建一个功能强大的沙箱，并且暴露的攻击面最小。如果您不想自己创建沙箱，请在完成后考虑使用Whonix的sandbox-app-launcher。&lt;span&gt;您不应该使用Firejail&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诸如Docker和LXC之类的容器解决方案经常被误导为沙盒形式。它们太宽松了，无法广泛支持各种应用程序，因此不能认为它们是强大的应用程序沙箱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;###常见沙箱逃逸&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PulseAudio&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PulseAudio是一种常见的声音服务器，但在编写时并未考虑隔离或沙盒的问题，这使其成为重复出现的沙盒逃逸漏洞。为了防止这种情况，建议您从沙箱中阻止对PulseAudio的访问，或者从系统中完全卸载它。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;D-Bus&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D-Bus是台式机Linux上最流行的进程间通信形式，但它也是沙箱逃逸的另一种常见途径，因为它允许与服务自由交互。这些漏洞的一个例子就是Firejail。您应该从沙箱中阻止对D-Bus的访问，或者通过MAC以细粒度的规则进行调解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GUI隔离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何Xorg窗口都可以访问另一个窗口。这允许琐碎的键盘记录或屏幕截图程序，甚至可以记录诸如root密码之类的内容。您可以使用嵌套的X11服务器（例如Xpra或Xephyr和bubblewrap）将Xorg窗口沙箱化。默认情况下，Wayland将窗口彼此隔离，这将是一个比Xorg更好的选择，尽管Wayland可能不如Xorg普遍可用，因为它在开发中较早。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ptrace&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，ptrace是一个系统调用，可能会被滥用破坏在沙箱外部运行的进程。为避免这种情况，您可以通过sysctl启用内核YAMA ptrace限制，也可以在seccomp过滤器中将ptrace syscall列入黑名单。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TIOCSTI&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIOCSTI是一个ioctl，它允许注入终端命令，并为攻击者提供了一种简单的机制，可以在同一用户会话内的其他进程之间横向移动。可以通过将seccomp过滤器中的ioctl列入黑名单或使用bubblewrap的--new-session参数来缓解这种攻击。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Systemd沙箱&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然不建议使用systemd，但有些系统可能无法切换。这些人至少可以使用沙盒服务，因此他们只能访问所需的内容。这是一个沙箱化systemd服务的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Service]&lt;br/&gt;CapabilityBoundingSet=CAP_NET_BIND_SERVICE&lt;br/&gt;ProtectSystem=strict&lt;br/&gt;ProtectHome=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;ProtectKernelTunables=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;ProtectKernelModules=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;ProtectControlGroups=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;ProtectKernelLogs=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;ProtectHostname=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;ProtectClock=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;ProtectProc=invisible&lt;br/&gt;ProcSubset=pid&lt;br/&gt;PrivateTmp=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;PrivateUsers=yes&lt;br/&gt;PrivateDevices=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;MemoryDenyWriteExecute=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;NoNewPrivileges=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;LockPersonality=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;RestrictRealtime=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;RestrictSUIDSGID=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;RestrictAddressFamilies=AF_INET&lt;br/&gt;RestrictNamespaces=yes&lt;br/&gt;SystemCallFilter=write &lt;span&gt;read&lt;/span&gt; openat close brk fstat lseek mmap mprotect munmap rt_sigaction rt_sigprocmask ioctl nanosleep select access execve getuid arch_prctl set_tid_address set_robust_list prlimit64 pread64 getrandom&lt;br/&gt;SystemCallArchitectures=native&lt;br/&gt;UMask=0077&lt;br/&gt;IPAddressDeny=any&lt;br/&gt;AppArmorProfile=/etc/apparmor.d/usr.bin.example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有选项的说明：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;CapabilityBoundingSet=&lt;/code&gt;— Specifies the &lt;span&gt;capabilities&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;the process is given.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectHome=true&lt;/code&gt;— Makes all home directories inaccessible.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectKernelTunables=true&lt;/code&gt;— Mounts kernel tunables such as those modified through&lt;code&gt;sysctl&lt;/code&gt;as read-only.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectKernelModules=true&lt;/code&gt;— Denies module loading and unloading.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectControlGroups=true&lt;/code&gt;— Mounts all control group hierarchies as read-only.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectKernelLogs=true&lt;/code&gt;— Prevents accessing the kernel logs.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectHostname=true&lt;/code&gt;— Prevents changes to the system hostname.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectClock&lt;/code&gt;— Prevents changes to the system clock.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProtectProc=invisible&lt;/code&gt;— Hides all outside processes.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ProcSubset=pid&lt;/code&gt;— Permits access to only the pid subset of&lt;code&gt;/proc&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;code&gt;PrivateTmp=true&lt;/code&gt;— Mounts an empty tmpfs over&lt;code&gt;/tmp&lt;/code&gt;and&lt;code&gt;/var/tmp&lt;/code&gt;, therefore hiding their previous contents.&lt;/p&gt;&lt;p&gt;&lt;code&gt;PrivateUsers=true&lt;/code&gt;— Sets up an empty user namespace to hide other user accounts on the system.&lt;/p&gt;&lt;p&gt;&lt;code&gt;PrivateDevices=true&lt;/code&gt;— Creates a new&lt;code&gt;/dev&lt;/code&gt;mount with minimal devices present.&lt;/p&gt;&lt;p&gt;&lt;code&gt;MemoryDenyWriteExecute=true&lt;/code&gt;— Enforces a memory W^X policy.&lt;/p&gt;&lt;p&gt;&lt;code&gt;NoNewPrivileges=true&lt;/code&gt;— Prevents escalating privileges.&lt;/p&gt;&lt;p&gt;&lt;code&gt;LockPersonality=true&lt;/code&gt;— Locks down the&lt;code&gt;personality()&lt;/code&gt;syscall to prevent switching execution domains.&lt;/p&gt;&lt;p&gt;&lt;code&gt;RestrictRealtime=true&lt;/code&gt;— Prevents attempts to enable realtime scheduling.&lt;/p&gt;&lt;p&gt;&lt;code&gt;RestrictSUIDSGID=true&lt;/code&gt;— Prevents executing setuid or setgid binaries.&lt;/p&gt;&lt;p&gt;&lt;code&gt;RestrictAddressFamilies=AF_INET&lt;/code&gt;— Restricts the usable socket address families to IPv4 only (&lt;code&gt;AF_INET&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;&lt;code&gt;RestrictNamespaces=true&lt;/code&gt;— Prevents creating any new namespaces.&lt;/p&gt;&lt;p&gt;&lt;code&gt;SystemCallFilter=...&lt;/code&gt;— Restricts the allowed syscalls to the absolute minimum. If you aren&#x27;t willing to maintain your own custom seccomp filter, then systemd provides many [predefined system call sets](https://www.freedesktop.org/software/systemd/man/systemd.exec.html#System Call Filtering &quot;predefined system call sets&quot;) that you can use.&lt;code&gt;@system-service&lt;/code&gt;will be suitable for many use cases.&lt;/p&gt;&lt;p&gt;&lt;code&gt;SystemCallArchitectures=native&lt;/code&gt;— Prevents executing syscalls from other CPU architectures.&lt;/p&gt;&lt;p&gt;&lt;code&gt;UMask=0077&lt;/code&gt;— Sets the &lt;span&gt;umask&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;to a more restrictive value.&lt;/p&gt;&lt;p&gt;&lt;code&gt;IPAddressDeny=any&lt;/code&gt;— Blocks all incoming and outgoing traffic to/from any IP address. Set&lt;code&gt;IPAddressAllow=&lt;/code&gt;to configure a whitelist. Alternatively, setup a network namespace with&lt;code&gt;PrivateNetwork=true&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;code&gt;AppArmorProfile=...&lt;/code&gt;— Runs the process under the specified AppArmor profile.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您不能仅将此示例配置复制到您的配置中，每种服务的要求各不相同，并且必须针对每种服务微调沙箱。要了解有关您可以设置的所有选项的更多信息，请阅读&lt;span&gt;systemd.exec手册页&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您使用的系统不是systemd而是init，那么可以使用bubblewrap轻松复制所有这些选项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1619859492195&quot; data-category_id_list=&quot;48|32|26|49|1|27|28|45|46|55|39|8|3|47|35|41|5|31|6|7|24|37|22|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1619859492195&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;gVisor&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通沙箱固有地与主机共享同一内核。您信任我们已经评估为不安全的内核，可以正确限制这些程序。由于主机内核的整个攻击面已完全暴露，因此沙盒中的内核利用程序可以绕过任何限制。已经进行了一些努力来限制使用seccomp的攻击面，但不足以完全解决此问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GVisor是解决此问题的方法。它为每个应用程序提供了自己的内核，该内核以内存安全的语言重新实现了Linux内核的大部分系统调用，从而提供了明显更强的隔离性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;虚拟机&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然不是传统的“沙盒”，但虚拟机通过虚拟化全新系统来分离进程，从而提供了非常强大的隔离性。KVM是内核模块，它允许内核充当管理程序，而QEMU是利用KVM的仿真器。Virt-manager和GNOME Boxs都是良好且易于使用的GUI，用于管理KVM / QEMU虚拟机。不建议使用Virtualbox的&lt;span&gt;原因&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;有很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强化内存分配器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hardened_malloc是一种硬化的内存分配器，可为堆内存损坏漏洞提供实质性的保护。它很大程度上基于OpenBSD的malloc设计，但具有许多改进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过LD_PRELOAD环境变量针对每个应用程序使用hardened_malloc。例如，假设您编译的库位于/usr/lib/libhardened_malloc.so，则可以执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LD_PRELOAD=&lt;span&gt;&quot;/usr/lib/libhardened_malloc.so&quot;&lt;/span&gt; &lt;span&gt;$program&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过全局预加载该库，也可以在系统范围内使用它，这是使用它的推荐方法。为此，请编辑/etc/ld.so.preload并插入：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/usr/lib/libhardened_malloc.so&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管大多数应用程序都可以正常工作，但hardened_malloc可能会破坏某些应用程序。建议使用以下选项编译hardened_malloc以最大程度地减少损坏：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CONFIG_SLAB_QUARANTINE_RANDOM_LENGTH=0 CONFIG_SLAB_QUARANTINE_QUEUE_LENGTH=0 CONFIG_GUARD_SLABS_INTERVAL=8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您还应该使用sysctl设置以下内容，以适应hardened_malloc创建的大量保护页：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vm.max_map_count=524240&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Whonix项目&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;为基于Debian的发行版提供了hardened_malloc软件包。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强化编译标志&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译自己的程序可以带来很多好处，因为它使您能够优化程序的安全性。但是，执行完全相反的操作并降低安全性很容易，如果您不确定自己在做什么，请跳过本节。在基于源的发行版（例如Gentoo）上，这将是最简单的，但也可以在其他发行版上这样做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些编译选项可用于添加其他漏洞利用缓解措施，从而消除整个类别的常见漏洞。您可能听说过常规保护，例如位置独立可执行文件，堆栈粉碎保护程序，立即绑定，只读重定位和FORTIFY_SOURCE，但是本节将不做介绍，因为它们已被广泛采用。相反，它将讨论诸如控制流完整性和影子堆栈之类的现代漏洞利用缓解措施。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节涉及主要用C或C ++编写的本机程序。您必须使用Clang编译器，因为这些功能在GCC上不可用。请记住，由于未广泛采用这些缓解措施，因此某些应用程序在启用它们后可能无法运行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;控制流完整性（CFI）是一种缓解漏洞利用的方法，旨在防止诸如ROP或JOP之类的代码重用攻击。由于更广泛采用的缓解措施（例如NX）使过时的利用技术过时了，因此使用这些技术利用了很大一部分漏洞。Clang支持细粒度的前沿CFI，这意味着它可以有效缓解JOP攻击。Clang的CFI本身并不能减轻ROP；您还必须使用下面记录的单独机制。要启用此功能，必须应用以下编译标志： -flto -fvisibility=hidden -fsanitize=cfi&lt;/p&gt;&lt;p&gt;影子堆栈通过将程序复制到其他隐藏堆栈中来保护程序的返回地址。然后比较主堆栈和影子堆栈中的返回地址，看两者是否不同。如果是这样，则表明存在攻击，程序将中止，从而减轻了ROP攻击。Clang具有称为ShadowCallStack的功能，可以完成此操作，但是，仅在ARM64上可用。要启用此功能，必须应用以下编译标志： -fsanitize=shadow-call-stack&lt;/p&gt;&lt;p&gt;如果上述ShadowCallStack不是一个选项，则可以选择使用具有相似目标的SafeStack。但是，不幸的是，此功能有许多漏洞，因此效果不甚理想。如果仍然希望启用此功能，则必须应用以下编译标志： -fsanitize=safe-stack&lt;/p&gt;&lt;p&gt;最常见的内存损坏漏洞之一是未初始化的内存。Clang有一个选项可以使用零或特定模式自动初始化变量。建议将变量初始化为零，因为使用其他模式比利用漏洞缓解功能更适合发现错误。要启用此功能，必须应用以下编译标志： -ftrivial-auto-var-init=zero -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang 但该选项的存在目前正在&lt;span&gt;辩论&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存安全语言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用内存安全语言编写的程序会自动受到保护，免受各种安全漏洞的影响，这些安全漏洞包括缓冲区溢出，未初始化的变量，售后使用等。Microsoft和Google的安全研究人员进行的研究证明，已发现的大多数漏洞都是内存安全问题。这样的内存安全语言的示例包括Rust，Swift和Java，而内存不安全语言的示例包括C和C ++。如果可行，应使用内存安全替代品替换尽可能多的程序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Root账户&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;root可以执行任何操作，并且可以访问您的整个系统。因此，应尽可能将其锁定，以使攻击者无法轻松获得root用户访问权限。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;/etc/securetty&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;/etc/securetty文件指定允许您以root用户身份登录的位置。该文件应保留为空，以便任何人都不能从终端上这样做。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制su&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;su可让您从终端切换用户。默认情况下，它尝试以root用户身份登录。要将su的使用限制在wheel组中，请编辑/etc/pam.d/su和/etc/pam.d/su-l并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;auth required pam_wheel.so use_uid&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您应该在wheel组中拥有尽可能少的用户。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;锁定root账户&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要锁定root帐户以防止任何人以root身份登录，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;passwd -l root&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行此操作之前，请确保您具有获取根的替代方法（例如，从活动USB引导并更改为文件系统的chroot），以免您无意中将自己锁定在系统之外。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;拒绝通过SSH的远程root登陆&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止某人通过SSH以root身份登录，请编辑/etc/ssh/sshd_config并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PermitRootLogin no&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;增加散列回合数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您可以增加shadow使用的哈希回合数，从而通过迫使攻击者计算更多的哈希值来破解您的密码，从而提高哈希密码的安全性。默认情况下，shadow使用5000次回合，但是您可以将其增加到任意数量。尽管配置的回合越多，登录速度就越慢。编辑/etc/pam.d/passwd并添加回合选项。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;password required pam_unix.so sha512 shadow nullok rounds=65536&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这使shadow执行65536次散列回合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用此设置后，密码不会自动重新加密，因此您需要使用以下方法重置密码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;passwd &lt;span&gt;$username&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制Xorg root访问&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，某些发行版以root用户身份运行Xorg，这是一个问题，因为Xorg包含大量古老而又复杂的代码，这增加了巨大的攻击面，并使其更有可能拥有可以获取root特权的漏洞利用程序。要阻止它作为root用户执行，请编辑/etc/X11/Xwrapper.config并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;needs_root_rights = no&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安全访问root&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恶意软件可以使用多种方法来嗅探root帐户的密码。因此，访问根帐户的传统方式是不安全的，最好根本不访问根，但这实际上是不可行的。本节详细介绍了访问根帐户的最安全方法。在安装操作系统后，应立即应用这些说明，以确保该软件不含恶意软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您绝对不能使用普通用户帐户访问root，因为root可能已被盗用。您也不能直接登录到根帐户。通过执行以下操作，创建一个单独的“管理员”用户帐户，该帐户仅用于访问root用户，而不能用于访问其他用户：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;useradd admin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行并来设置一个非常强的密码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;passwd admin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅允许该帐户使用您首选的权限提升机制。例如，如果使用sudo，则通过执行以下命令来添加sudoers异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;visudo -f /etc/sudoers.d/admin-account&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后输入：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;admin ALL=(ALL) ALL&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保没有其他帐户可以访问sudo（或您的首选机制）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，要实际登录到该帐户，请先重新启动-例如，这可以防止受损的窗口管理器执行登录欺骗。当提供登录提示时，请通过按键盘上的以下组合键来激活安全注意键：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Alt + SysRq + k&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将杀死当前虚拟控制台上的所有应用程序，从而克服登录欺骗攻击。现在，您可以安全地登录到您的管理员帐户，并使用root用户执行任务。完成后，注销管理员帐户，然后重新登录到非特权用户帐户。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;防火墙&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防火墙可以控制传入和传出的网络流量，并且可以用来阻止或允许某些类型的流量。除非有特殊原因，否则应始终阻止所有传入流量。建议设置严格的iptables或nftables防火墙。火墙必须针对您的系统进行微调，并且没有一个适合所有防火墙的规则集。建议您熟悉创建防火墙规则。&lt;span&gt;Arch Wiki&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;和&lt;span&gt;手册页&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;都是很好的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是基本iptables配置的示例，该配置禁止所有传入的网络流量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*filter&lt;br/&gt;:INPUT DROP [0:0]&lt;br/&gt;:FORWARD DROP [0:0]&lt;br/&gt;:OUTPUT ACCEPT [0:0]&lt;br/&gt;:TCP - [0:0]&lt;br/&gt;:UDP - [0:0]&lt;br/&gt;-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT&lt;br/&gt;-A INPUT -i lo -j ACCEPT&lt;br/&gt;-A INPUT -m conntrack --ctstate INVALID -j DROP&lt;br/&gt;-A INPUT -p udp -m conntrack --ctstate NEW -j UDP&lt;br/&gt;-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP&lt;br/&gt;-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable&lt;br/&gt;-A INPUT -p tcp -j REJECT --reject-with tcp-reset&lt;br/&gt;-A INPUT -j REJECT --reject-with icmp-proto-unreachable&lt;br/&gt;COMMIT&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，您不应尝试在实际系统上使用此示例。它仅适用于某些台式机系统。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;身份标识&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保护隐私，最好最大程度地减少可追溯到您的信息量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主机名和用户名&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请勿在主机名或用户名中添加唯一标识的内容。将它们保留为通用名称，例如“host”和“user”，以便它们无法识别您。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Timezones / Locales / Keymaps&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果可能，应将您的时区设置为“ UTC”，将区域设置和键盘映射设置为“ US”。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;机器ID&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个独一无二的机器ID被存储在/var/lib/dbus/machine-id （systemd系统是保存在/etc/machine-id）这些应编辑为通用名称，例如&lt;span&gt;Whonix ID&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;b08dfa6083e7567a1921a715000001fb&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MAC地址欺骗&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MAC地址是分配给网络接口控制器（NIC）的唯一标识符。每次您连接到网络时（WIFI或以太网）则您的MAC地址已暴露。这使人们可以使用它来跟踪您并在本地网络上唯一地标识您。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但您不应该完全随机化MAC地址。拥有完全随机的MAC地址是显而易见的，并且会对您脱颖而出的行为产生不利影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MAC地址的OUI（组织唯一标识符）部分标识芯片组的制造商。对MAC地址的这一部分进行随机化处理可能会为您提供以前从未使用过的OUI，数十年来从未使用过的OUI或在您所在的地区极为罕见的OUI，因此使您脱颖而出，很明显地表明您在欺骗MAC地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MAC地址的末尾标识您的特定设备，并且可以用来跟踪您的设备。仅对MAC地址的这一部分进行随机化可防止您被跟踪，同时仍使MAC地址看起来可信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要欺骗这些地址，请首先执行以下命令找出您的网络接口名称：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ip a&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，安装macchanger并执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;macchanger -e &lt;span&gt;$network_interface&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要在每次引导时随机分配MAC地址，您应该为您的特定初始化系统创建一个初始化脚本。这是systemd的一个示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Unit]&lt;br/&gt;Description=macchanger on eth0&lt;br/&gt;Wants=network-pre.target&lt;br/&gt;Before=network-pre.target&lt;br/&gt;BindsTo=sys-subsystem-net-devices-eth0.device&lt;br/&gt;After=sys-subsystem-net-devices-eth0.device&lt;br/&gt;&lt;br/&gt;[Service]&lt;br/&gt;ExecStart=/usr/bin/macchanger -e eth0&lt;br/&gt;Type=oneshot&lt;br/&gt;&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的示例在启动时欺骗了eth0接口的MAC地址。将eth0替换为您的网络接口。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间攻击&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几乎每个系统都有不同的时间。这可用于时钟偏斜指纹攻击，几毫秒的差异足以使用户被暴露识别。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ICMP时间戳&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ICMP时间戳会在查询答复中泄漏系统时间。阻止这些攻击的最简单方法是利用防火墙阻止传入连接，或者使内核忽略ICMP请求。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TCP时间戳&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP时间戳也会泄漏系统时间。内核尝试通过对每个连接使用随机偏移量来解决此问题，但&lt;span&gt;这不足以解决问题&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;。因此应该禁用TCP时间戳，可以通过使用sysctl设置以下内容来完成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv4.tcp_timestamps=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;TCP初始化序号&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP初始序列号（ISN）是泄漏系统时间的另一种方法。为了减轻这种情况，您必须&lt;span&gt;安装tirdad内核模块&lt;/span&gt;&lt;sup&gt;[18]&lt;/sup&gt;，该模块会生成用于连接的随机ISN。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间同步&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间同步对于匿名性和安全性至关重要。错误的系统时钟可能使您遭受时钟偏斜指纹攻击，或者可以用来为您提供过时的HTTPS证书，从而绕过证书到期或吊销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最流行的时间同步方法NTP是不安全的，因为它未经加密和未经身份验证，因此攻击者可以轻易地拦截和修改请求。NTP还会以NTP时间戳格式泄漏本地系统时间，该格式可用于时钟偏斜指纹识别，如前所述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，您应该卸载所有NTP客户端并禁用systemd-timesyncd（如果正在使用）。您可以通过安全连接（HTTPS或最好是Torion服务）连接到受信任的网站，而不是NTP，并从HTTP标头中提取当前时间。达到此目的的工具是sdwdate或我自己的&lt;span&gt;安全时间同步工具&lt;/span&gt;&lt;sup&gt;[19]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;按键指纹&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过他们在键盘上输入键的方式来对人进行指纹识别。您可以通过键入速度，在两次按键之间的暂停，每次按键被按下和释放的确切时间等方式来唯一地进行指纹识别。可以使用&lt;span&gt;KeyTrac&lt;/span&gt;&lt;sup&gt;[20]&lt;/sup&gt;在线进行测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kloak&lt;/span&gt;&lt;sup&gt;[21]&lt;/sup&gt;是一种工具，旨在通过混淆按键和释放事件之间的时间间隔来克服这种跟踪方法。当按键被按下时，它会引入随机延迟，然后由应用程序选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件权限&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，文件的权限是非常宽松的。您应该在整个系统中搜索权限不当的文件和目录，并对其进行限制。例如，在诸如Debian之类的某些发行版中，用户的Home目录是全局可读的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以通过执行以下操作来限制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod 700 /home/&lt;span&gt;$user&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一些示例是/boot，/usr /src和/ {,usr /} lib/modules 它们包含内核映像，System.map和其他各种文件，所有这些文件都可能泄漏有关内核的敏感信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod 700 /boot /usr/src /lib/modules /usr/lib/modules&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在基于Debian的发行版中，必须使用dpkg-statoverride保留文件许可权。否则，它们将在更新期间被覆盖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Whonix的&lt;span&gt;SUID Disabler和Permission Hardener&lt;/span&gt;&lt;sup&gt;[22]&lt;/sup&gt;会自动应用本节中详细介绍的步骤。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;setuid / setgid&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Setuid / SUID允许用户使用二进制文件所有者的特权执行二进制文件。这通常用于允许非特权用户使用通常仅为root用户保留的某些功能。因此，许多SUID二进制文件都有特权升级安全漏洞的历史记录。 Setgid / SGID类似，但适用于组而不是用户。要使用setuid或setgid位查找系统上的所有二进制文件，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;find / -&lt;span&gt;type&lt;/span&gt; f \( -perm -4000 -o -perm -2000 \)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，您应该删除不使用的程序上的所有不必要的setuid / setgid位，或将其替换为功能。要删除setuid位，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod u&lt;span&gt;-s&lt;/span&gt; &lt;span&gt;$path_to_program&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要删除setgid位，执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod g&lt;span&gt;-s&lt;/span&gt; &lt;span&gt;$path_to_program&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要向文件添加功能，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;setcap&lt;/span&gt; &lt;span&gt;$capability&lt;/span&gt;+ep &lt;span&gt;$path_to_program&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，要删除不必要的功能，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;setcap&lt;/span&gt; -r &lt;span&gt;$path_to_program&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;umask&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;umask设置新创建文件的默认文件权限。默认的umask是0022，它不是很安全，因为它为系统上的每个用户提供了对新创建文件的读取访问权限。要使所有者以外的任何人都不可读新文件，请编辑/etc/profile并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;umask&lt;/span&gt; 0077&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心转储&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心转储包含特定时间（通常是该程序崩溃时）该程序的已记录内存。它们可能包含敏感信息，例如密码和加密密钥，因此必须将其禁用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;禁用它们的方法主要有三种：sysctl，systemd和ulimit&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;sysctl&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过sysctl设置以下设置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kernel.core_pattern=|/bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;systemd&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建/etc/systemd/coredump.conf.d/disable.conf并添加如下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Coredump]&lt;br/&gt;Storage=none&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ulimit&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑/etc/security/limits.conf并添加如下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;* hard core 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;setuid进程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使在进行了这些设置之后，以提升的特权运行的进程仍可能会转储其内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止他们这样做，请通过sysctl设置以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fs.suid_dumpable=0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Swap&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与核心转储类似，交换或分页将部分内存复制到磁盘，其中可能包含敏感信息。应该将内核配置为仅在绝对必要时进行交换，相应的sysctl设置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;vm.swappiness=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;PAM&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAM是用于用户身份验证的框架。这就是您登录时使用的机制。您可以通过要求使用强密码或在失败的登录尝试后强制执行延迟验证来使其更加安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要强制使用强密码，可以使用pam_pwquality。它强制执行密码的可配置策略。例如，如果您希望密码至少包含16个字符（最小），与旧密码（difok）至少6个不同的字符，至少3个数字（dcredit），至少2个大写字母（ucredit），至少2个字符小写字母（lcredit）和至少3个其他字符（ocredit），然后编辑/etc/pam.d/passwd并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;password required pam_pwquality.so retry=2 minlen=16 difok=6 dcredit=-3 ucredit=-2 lcredit=-2 ocredit=-3 enforce_for_root&lt;br/&gt;password required pam_unix.so use_authtok sha512 shadow&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要强制执行延迟验证，可以使用pam_faildelay。要在两次失败的登录尝试之间添加至少4秒的延迟以阻止暴力破解尝试，请编辑/etc/pam.d/system-login并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;auth optional pam_faildelay.so delay=4000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4000000 是4秒（以微秒为单位）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Microcode更新&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Microcode更新对于修复关键的CPU漏洞（如Meltdown和Spectre等）至关重要。大多数发行版都将这些发行版包含在其软件仓库中，例如&lt;span&gt;Arch Linux&lt;/span&gt;&lt;sup&gt;[23]&lt;/sup&gt;和&lt;span&gt;Debian&lt;/span&gt;&lt;sup&gt;[24]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IPv6隐私扩展&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IPv6地址是从计算机的MAC地址生成的，从而使您的IPv6地址是唯一的，并直接绑定到计算机。隐私扩展会生成一个随机的IPv6地址，以减轻这种形式的跟踪。请注意，如果您开启了MAC地址欺骗机制或禁用了IPv6，则无需执行这些步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要启用这些功能，请通过sysctl设置以下设置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;net.ipv6.conf.all.use_tempaddr=2&lt;br/&gt;net.ipv6.conf.default.use_tempaddr=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NetworkManager&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要为NetworkManager启用隐私扩展，请编辑/etc/NetworkManager/NetworkManager.conf并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[connection]&lt;br/&gt;ipv6.ip6-privacy=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;systemd-networkd&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要为systemd-networkd启用隐私扩展，请创建/etc/systemd/network/ipv6-privacy.conf并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Network]&lt;br/&gt;IPv6PrivacyExtensions=kernel&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分区和挂载选项&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件系统应分为多个分区，以对其权限进行细粒度控制。可以添加不同的安装选项以限制可以执行的操作：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;nodev - 禁止使用设备&lt;/p&gt;&lt;p&gt;nosuid - 禁止setuid或setgid位&lt;/p&gt;&lt;p&gt;noexec - 禁止执行任何二进制文件&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些安装选项应在/etc/fstab中尽可能设置。如果您不能使用单独的分区，请创建绑定挂载。一个更安全的/etc/fstab的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/        /          ext4    defaults                              1 1&lt;br/&gt;/home    /home      ext4    defaults,nosuid,noexec,nodev          1 2&lt;br/&gt;/tmp     /tmp       ext4    defaults,&lt;span&gt;bind&lt;/span&gt;,nosuid,noexec,nodev     1 2&lt;br/&gt;/var     /var       ext4    defaults,&lt;span&gt;bind&lt;/span&gt;,nosuid                  1 2&lt;br/&gt;/boot    /boot      ext4    defaults,nosuid,noexec,nodev          1 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，可以&lt;span&gt;通过shell脚本绕过noexec&lt;/span&gt;&lt;sup&gt;[25]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;熵&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熵基本上反应操作系统信息收集的随机程度，对于诸如加密之类的事情至关重要。因此，最好通过安装其他随机数生成器（如&lt;span&gt;haveged&lt;/span&gt;&lt;sup&gt;[26]&lt;/sup&gt;和&lt;span&gt;jitterentropy&lt;/span&gt;&lt;sup&gt;[27]&lt;/sup&gt;）从各种来源收集尽可能多的熵。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了使jitterentropy正确运行，必须通过创建/usr/lib/modules-load.d/jitterentropy.conf并添加以下内容尽早加载内核模块：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jitterentropy_rng&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RDRAND&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDRAN是提供随机数的CPU指令。如果可用，内核会自动将其用作熵源。但是由于它是专有的并且是CPU本身的一部分，因此无法审核和验证其安全性。您甚至无法对代码进行反向工程。该RNG以前曾遭受过漏洞的攻击，其中有些可能是后门攻击。通过设置以下引导参数可以不信任此功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;random.trust_cpu=off&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;以root身份编辑文件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议不要以root用户身份运行普通的文本编辑器。大多数文本编辑器可以做的不仅仅是简单地编辑文本文件，而且还可以被利用。例如，以root身份打开vi并输入：sh。现在，您具有一个可以访问整个系统的root shell，攻击者可以轻松利用该shell。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方案是使用sudoedit。这会将文件复制到一个临时位置，以普通用户身份打开文本编辑器，编辑该临时文件并以root用户身份覆盖原始文件。这样，实际的编辑器就不会以root身份运行。要使用sudoedit，执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudoedit &lt;span&gt;$path_to_file&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，它使用vi，但是可以通过EDITOR或SUDO_EDITOR环境变量来切换默认编辑器。例如，要使用nano，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;EDITOR=nano sudoedit &lt;span&gt;$path_to_file&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在/etc/environment中全局设置此环境变量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;特定发行版的安全强化&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP包管理器镜像&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，Linux发行版通常使用HTTP或HTTP和HTTPS镜像的混合来从其软件存储库下载软件包。人们认为这很好，因为程序包管理器会在安装前验证程序包的签名。但是，从历史上看，已经有很多绕过此方法的地方。您应将软件包管理器配置为从HTTPS镜像专门下载以进行深度防御。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;APT seccomp-bpf&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自软件包管理器Debian Buster以来，APT已支持可选的seccomp-bpf过滤。这限制了允许执行APT的系统调用，这可能严重限制攻击者尝试利用APT中的漏洞时对系统造成危害的能力。要启用此功能，请创建/etc/apt/apt.conf.d/40sandbox并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;APT::Sandbox::Seccomp &lt;span&gt;&quot;true&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;物理安全&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全盘加密可确保对驱动器上的所有数据进行加密，并且不会被物理攻击者读取。大多数发行版都支持在安装过程中启用加密，请确保设置了强密码。您也可以使用&lt;span&gt;dm-crypt&lt;/span&gt;&lt;sup&gt;[28]&lt;/sup&gt;手动加密驱动器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，全盘加密不包括/boot，这样仍然可以修改内核、引导加载程序和其他关键文件。为了完全防止篡改，您还必须实施经过验证的引导。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;BIOS / UEFI强化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您仍在使用旧版BIOS，则应迁移到UEFI，以利用较新的安全功能。大多数BIOS或UEFI实现都支持设置密码。最好启用它并设置一个非常强壮的密码。虽然这是很弱的保护，因为重置密码很简单。它通常存储在易失性内存中，因此攻击者只需要能够卸下CMOS电池几秒钟，或者他们就可以使用某些主板上的跳线将其重置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您还应该禁用所有未使用的设备和引导选项，例如USB引导，以减少攻击面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别忽略BIOS或UEFI的更新，确保将其更新。将其与常规操作系统更新一样重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，请参阅&lt;span&gt;《NSA的硬件和固件安全指南》&lt;/span&gt;&lt;sup&gt;[29]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Bootloader密码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引导加载程序会在引导过程的早期执行，并负责加载操作系统。保护它非常重要，否则，它可能会被篡改。例如，本地攻击者可以通过在启动时使用init=/bin/bash作为内核参数来轻松获得root shell，该命令告诉内核执行/bin/bash而不是常规的init系统。您可以通过为引导加载程序设置密码来防止这种情况。仅设置引导程序密码不足以完全保护它。还必须按照以下说明设置经过验证的启动。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Grub&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要为GRUB设置密码，请执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;grub-mkpasswd-pbkdf2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入您的密码，该密码将生成一个字符串。它将类似于“ grub.pbkdf2.sha512.10000.C4009... “ 。创建/etc/grub.d/40_password并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; superusers=&lt;span&gt;&quot;&lt;span&gt;$username&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;password_pbkdf2 &lt;span&gt;$username&lt;/span&gt; &lt;span&gt;$password&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用grub-mkpasswd-pbkdf2生成的字符串替换“ &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot; password”。 “ &quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 6542.6 950&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;70&quot; d=&quot;M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(503, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1032, 0)&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1501, 0)&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1970, 0)&quot;&gt;&lt;path data-c=&quot;77&quot; d=&quot;M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2686, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3171, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3622, 0)&quot;&gt;&lt;path data-c=&quot;64&quot; d=&quot;M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4142, 0)&quot;&gt;&lt;path data-c=&quot;201D&quot; d=&quot;M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4919.8, 0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;845.3px&quot; font-family=&quot;serif&quot;&gt;。&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6042.6, 0)&quot;&gt;&lt;path data-c=&quot;201C&quot; d=&quot;M128 494Q128 528 137 560T158 616T185 658T209 685T223 694T236 685T245 670Q244 668 231 654T204 622T178 571T164 501Q164 489 165 489T170 491T183 497T201 500Q226 500 244 483T262 440T245 397T202 379Q173 379 151 405T128 494ZM332 494Q332 528 341 560T362 616T389 658T413 685T427 694T439 685T449 672Q449 669 437 656T411 625T383 573T368 501Q368 489 369 489T374 491T387 497T405 500Q430 500 448 483T466 440T449 397T406 379Q377 379 355 405T332 494Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; username”将用于被允许使用GRUB命令行，编辑菜单项和执行任何菜单项的超级用户。对于大多数人来说，这只是“root”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新生成您的配置文件，GRUB现在将受到密码保护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要仅限制编辑引导参数并访问GRUB控制台，同时仍然允许您引导，请编辑 /boot/grub/grub.cfg并在 “menuentry &#x27;$OSName&#x27; ”旁边添加“ --unrestricted”参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;menuentry &lt;span&gt;&#x27;Arch Linux&#x27;&lt;/span&gt; --unrestricted&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您将需要再次重新生成配置文件以应用此更改。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Syslinux&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Syslinux可以设置主密码或菜单密码。引导任何条目都需要主密码，而引导特定条目仅需要菜单密码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要为Syslinux设置主密码，请编辑/boot/syslinux/syslinux.cfg并添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;MENU MASTER PASSWD &lt;span&gt;$password&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要设置菜单密码，请编辑/boot/syslinux/syslinux.cfg，并在带有您要密码保护的项目的标签内，添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;MENU PASSWD &lt;span&gt;$password&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将“ $password”替换为您要设置的密码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些密码可以是纯文本，也可以使用MD5，SHA-1，SHA-256或SHA-512进行散列。建议先使用强哈希算法（例如SHA-256或SHA-512）对密码进行哈希处理，以避免将其存储为明文形式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;systemd-boot&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;systemd-boot具有防止在引导时编辑内核参数的选项。在loader.conf文件中，添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;editor no&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;systemd-boot并不正式支持保护内核参数编辑器的密码，但是您可以&lt;span&gt;使用systemd-boot-password来实现&lt;/span&gt;&lt;sup&gt;[30]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;验证引导&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过验证的引导通过密码验证来确保引导链和基本系统的完整性。这可用于确保物理攻击者无法修改设备上的软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有经过验证的引导，则一旦获得物理访问权限，就可以轻松绕过上述所有预防措施。经过验证的引导不仅像许多人认为的那样是为了物理安全。它还可以用于防止远程恶意软件持久化——如果攻击者设法破坏了整个系统并获得了很高的特权，则经过验证的引导将在重新引导后还原其更改，并确保它们无法持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过验证的最常见的引导实现是UEFI安全引导，但是它本身并不是一个完整的实现，因为它仅会验证引导加载程序和内核，这意味着可以通过以下方法：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;仅UEFI安全启动就没有一成不变的信任根，因此物理攻击者仍然可以刷新设备的固件。为了减轻这种情况，请结合使用UEFI安全启动和Intel Boot Guard或AMD Secure Boot。&lt;/p&gt;&lt;p&gt;远程攻击者（或不使用加密的物理攻击者）可以简单地修改操作系统的任何其他特权部分。例如，如果他们有修改内核的特权，那么他们也可以修改/sbin/init来有效地获得相同的结果。因此，仅验证内核和引导加载程序不会对远程攻击者产生任何影响。为了减轻这种情况，您必须使用&lt;span&gt;dm-verity&lt;/span&gt;&lt;sup&gt;[31]&lt;/sup&gt;验证基本操作系统，尽管由于传统Linux发行版的布局，这非常困难且笨拙。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，很难在传统Linux上实现可靠的经过验证的引导实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;USBs&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;USB设备为物理攻击提供了重要的攻击面。例如&lt;span&gt;BadUSB&lt;/span&gt;&lt;sup&gt;[32]&lt;/sup&gt;和&lt;span&gt;Stuxnet&lt;/span&gt;&lt;sup&gt;[33]&lt;/sup&gt;是此类攻击的范例。最佳实践是禁止所有新连接的USB且仅将受信任设备列入白名单，&lt;span&gt;USBGuard&lt;/span&gt;&lt;sup&gt;[34]&lt;/sup&gt;对此非常有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您也可以将nousb用作内核引导参数，以禁用内核中的所有USB支持。可以sysctl设置kernel.deny_new_usb=1&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;DMA攻击&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接内存访问（DMA）攻击涉及通过插入某些物理设备来完全访问所有系统内存。这可以通过控制设备可访问的内存区域的&lt;span&gt;IOMMU&lt;/span&gt;&lt;sup&gt;[35]&lt;/sup&gt;或将特别易受攻击的内核模块列入黑名单来缓解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要启用IOMMU，请设置以下内核引导参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;intel_iommu=on amd_iommu=on&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您只需要为特定的CPU制造商启用该选项，但同时启用这两个选项就没有问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;efi=disable_early_pci_dma&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过在非常早的启动过程中禁用所有PCI桥接器上的busmaster位，此选项可&lt;span&gt;修复上述IOMMU中的漏洞&lt;/span&gt;&lt;sup&gt;[36]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Thunderbolt和FireWire通常容易受到DMA攻击。要禁用它们，请将这些内核模块列入黑名单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;install firewire-core /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;install thunderbolt /bin/&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;冷启动攻击&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当攻击者在擦除RAM中的数据之前对其进行分析时，就会发生&lt;span&gt;冷启动攻击&lt;/span&gt;&lt;sup&gt;[37]&lt;/sup&gt;。使用现代RAM时，冷启动攻击不太实用，因为RAM通常会在几秒钟或几分钟内清除，除非将其放入冷却液（如液氮或冷冻机）中。攻击者必须在几秒钟内将设备中的RAM棒拔出并将其暴露于液氮中，而且确保用户不会注意到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果冷启动攻击是威胁模型的一部分，请在关机后保护计算机几分钟，以确保没有人可以访问您的RAM记忆棒。您也可以将RAM棒焊接到主板上，以使其更难以卡住。如果使用笔记本电脑，请取出电池，然后直接用充电电缆供电。关机后请拔出电缆，以确保RAM彻底断电无法访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核自我保护启动参数部分中，空闲时内存清零选项将用零覆盖内存中的敏感数据。此外，强化的内存分配器可以通过CONFIG_ZERO_ON_FREE配置选项清除用户空间堆内存中的敏感数据。尽管如此，某些数据仍可能保留在内存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，现代内核还包括&lt;span&gt;复位攻击缓解&lt;/span&gt;&lt;sup&gt;[38]&lt;/sup&gt;措施，该命令可命令固件在关机时擦除数据，尽管这需要&lt;span&gt;固件支持&lt;/span&gt;&lt;sup&gt;[39]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保正常关闭计算机，以使上述缓解措施可以开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果以上都不适用您的威胁模型，则可以实施&lt;span&gt;Tails的内存擦除过程&lt;/span&gt;&lt;sup&gt;[40]&lt;/sup&gt;，该过程将擦除大部分内存（视频内存除外），并且已被证明是有效的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最佳实践&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦对系统进行了尽可能多的加固，就应该遵循良好的隐私和安全性惯例：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;禁用或删除不需要的东西以最小化攻击面。&lt;/p&gt;&lt;p&gt;保持更新。配置cron任务或init脚本以每天更新系统。&lt;/p&gt;&lt;p&gt;不要泄漏有关您或您的系统的任何信息，无论它看起来多么渺小。&lt;/p&gt;&lt;p&gt;遵循&lt;span&gt;常规的安全和隐私建议&lt;/span&gt;&lt;sup&gt;[41]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管已经进行了强化，但您必须记住Linux仍然是一个有缺陷的操作系统，没有任何强化可以完全修复它。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他指南&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您应该进行尽可能多的研究，而不要依赖单一的信息来源。最大的安全问题之一就是用户。这些是我认为有价值的其他指南的链接：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Arch Linux Security wiki page&lt;/span&gt;&lt;sup&gt;[42]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Whonix Documentation&lt;/span&gt;&lt;sup&gt;[43]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NSA RHEL 5 Hardening Guide&lt;/span&gt;&lt;sup&gt;[44]&lt;/sup&gt;(稍有过时，但仍包含有用的信息）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;KSPP recommended kernel settings&lt;/span&gt;&lt;sup&gt;[45]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;kconfig-hardened-check&lt;/span&gt;&lt;sup&gt;[46]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;术语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您可能需要重新生成GRUB配置，以应用对引导加载程序所做的某些更改。在不同的发行版之间，执行此操作的步骤有时可能会有所不同。例如，在诸如Arch Linux之类的发行版上，应通过执行以下命令来重新生成配置文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;grub-mkconfig -o &lt;span&gt;$path_to_grub_config&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;$path_to_grub_config&quot; 取决于您如何设置系统。它通常是/boot/grub/grub.cfg或/boot/EFI/grub/grub.cfg，但是在执行此命令之前，请务必确保正确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在Debian或Ubuntu等发行版上，您应该执行以下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;update-grub&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;能力&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Linux内核中，“ root特权”分为各种不同的能力（&lt;span&gt;capabilities&lt;/span&gt;&lt;sup&gt;[47]&lt;/sup&gt;）。这在应用最小特权原则时很有帮助——可以给它们仅授予特定的子集，而不是授予进程总的root特权。例如，如果程序只需要设置系统时间，则只需要CAP_SYS_TIME而不是root所有能力。这会限制可能造成的损害，但是，您仍必须谨慎授予能力，因为无论如何，其中许多能力&lt;span&gt;可能会被滥用以获取完整的root特权&lt;/span&gt;&lt;sup&gt;[48]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;vivid driver: &lt;em&gt;https://www.kernel.org/doc/html/v4.12/media/v4l-drivers/vivid.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;做成systemd服务: &lt;em&gt;https://github.com/Whonix/security-misc/blob/master/lib/systemd/system/hide-hardware-info.service&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;需要购买: &lt;em&gt;https://grsecurity.net/passing_the_baton&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;Whonix的强化内核: &lt;em&gt;https://www.whonix.org/wiki/Hardened-kernel&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;p&gt;AppArmor文档: &lt;em&gt;https://gitlab.com/apparmor/apparmor/-/wikis/Documentation&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;p&gt;Bubblewrap: &lt;em&gt;https://github.com/containers/bubblewrap&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;p&gt;您不应该使用Firejail: &lt;em&gt;https://madaidans-insecurities.github.io/linux.html#firejail&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8] &lt;/span&gt;&lt;p&gt;capabilities: &lt;em&gt;https://madaidans-insecurities.github.io/guides/linux-hardening.html#capabilities&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9] &lt;/span&gt;&lt;p&gt;umask: &lt;em&gt;https://madaidans-insecurities.github.io/guides/linux-hardening.html#umask&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10] &lt;/span&gt;&lt;p&gt;systemd.exec手册页: &lt;em&gt;https://www.freedesktop.org/software/systemd/man/systemd.exec.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11] &lt;/span&gt;&lt;p&gt;原因: &lt;em&gt;https://www.whonix.org/wiki/KVM#Why_Use_KVM_Over_VirtualBox.3F&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12] &lt;/span&gt;&lt;p&gt;Whonix项目: &lt;em&gt;https://www.whonix.org/wiki/Hardened_Malloc&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13] &lt;/span&gt;&lt;p&gt;辩论: &lt;em&gt;https://lists.llvm.org/pipermail/cfe-dev/2020-April/065221.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14] &lt;/span&gt;&lt;p&gt;Arch Wiki: &lt;em&gt;https://wiki.archlinux.org/index.php/Iptables&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15] &lt;/span&gt;&lt;p&gt;手册页: &lt;em&gt;https://linux.die.net/man/8/iptables&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16] &lt;/span&gt;&lt;p&gt;Whonix ID: &lt;em&gt;https://github.com/Whonix/dist-base-files/blob/master/etc/machine-id&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17] &lt;/span&gt;&lt;p&gt;这不足以解决问题: &lt;em&gt;https://forums.whonix.org/t/do-ntp-and-tcp-timestamps-really-leak-your-local-time/7824/10&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[18] &lt;/span&gt;&lt;p&gt;安装tirdad内核模块: &lt;em&gt;https://github.com/0xsirus/tirdad&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[19] &lt;/span&gt;&lt;p&gt;安全时间同步工具: &lt;em&gt;https://gitlab.com/madaidan/secure-time-sync&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[20] &lt;/span&gt;&lt;p&gt;KeyTrac: &lt;em&gt;https://www.keytrac.net/en/tryout&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[21] &lt;/span&gt;&lt;p&gt;Kloak: &lt;em&gt;https://github.com/vmonaco/kloak&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[22] &lt;/span&gt;&lt;p&gt;SUID Disabler和Permission Hardener: &lt;em&gt;https://www.whonix.org/wiki/SUID_Disabler_and_Permission_Hardener&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[23] &lt;/span&gt;&lt;p&gt;Arch Linux: &lt;em&gt;https://wiki.archlinux.org/index.php/Microcode&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[24] &lt;/span&gt;&lt;p&gt;Debian: &lt;em&gt;https://wiki.debian.org/Microcode&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[25] &lt;/span&gt;&lt;p&gt;通过shell脚本绕过noexec: &lt;em&gt;https://chromium.googlesource.com/chromiumos/docs/+/master/security/noexec_shell_scripts.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[26] &lt;/span&gt;&lt;p&gt;haveged: &lt;em&gt;http://www.issihosts.com/haveged/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[27] &lt;/span&gt;&lt;p&gt;jitterentropy: &lt;em&gt;https://github.com/smuellerDD/jitterentropy-rngd&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[28] &lt;/span&gt;&lt;p&gt;dm-crypt: &lt;em&gt;https://wiki.archlinux.org/index.php/Dm-crypt&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[29] &lt;/span&gt;&lt;p&gt;《NSA的硬件和固件安全指南》: &lt;em&gt;https://github.com/nsacyber/Hardware-and-Firmware-Security-Guidance&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[30] &lt;/span&gt;&lt;p&gt;使用systemd-boot-password来实现: &lt;em&gt;https://github.com/kitsunyan/systemd-boot-password&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[31] &lt;/span&gt;&lt;p&gt;dm-verity: &lt;em&gt;https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/verity.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[32] &lt;/span&gt;&lt;p&gt;BadUSB: &lt;em&gt;https://srlabs.de/bites/badusb/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[33] &lt;/span&gt;&lt;p&gt;Stuxnet: &lt;em&gt;https://en.wikipedia.org/wiki/Stuxnet&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[34] &lt;/span&gt;&lt;p&gt;USBGuard: &lt;em&gt;https://usbguard.github.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[35] &lt;/span&gt;&lt;p&gt;IOMMU: &lt;em&gt;https://en.wikipedia.org/wiki/Input–output_memory_management_unit&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[36] &lt;/span&gt;&lt;p&gt;修复上述IOMMU中的漏洞: &lt;em&gt;https://mjg59.dreamwidth.org/54433.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[37] &lt;/span&gt;&lt;p&gt;冷启动攻击: &lt;em&gt;https://en.wikipedia.org/wiki/Cold_boot_attack&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[38] &lt;/span&gt;&lt;p&gt;复位攻击缓解: &lt;em&gt;https://lwn.net/Articles/730006/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[39] &lt;/span&gt;&lt;p&gt;固件支持: &lt;em&gt;https://www.trustedcomputinggroup.org/wp-content/uploads/Platform-Reset-Attack-Mitigation-Specification.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[40] &lt;/span&gt;&lt;p&gt;Tails的内存擦除过程: &lt;em&gt;https://tails.boum.org/contribute/design/memory_erasure/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[41] &lt;/span&gt;&lt;p&gt;常规的安全和隐私建议: &lt;em&gt;https://madaidans-insecurities.github.io/security-privacy-advice.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[42] &lt;/span&gt;&lt;p&gt;Arch Linux Security wiki page: &lt;em&gt;https://wiki.archlinux.org/index.php/Security&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[43] &lt;/span&gt;&lt;p&gt;Whonix Documentation: &lt;em&gt;https://www.whonix.org/wiki/Documentation&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[44] &lt;/span&gt;&lt;p&gt;NSA RHEL 5 Hardening Guide: &lt;em&gt;https://apps.nsa.gov/iaarchive/library/ia-guidance/security-configuration/operating-systems/guide-to-the-secure-configuration-of-red-hat-enterprise.cfm&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[45] &lt;/span&gt;&lt;p&gt;KSPP recommended kernel settings: &lt;em&gt;https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[46] &lt;/span&gt;&lt;p&gt;kconfig-hardened-check: &lt;em&gt;https://github.com/a13xp0p0v/kconfig-hardened-check/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[47] &lt;/span&gt;&lt;p&gt;capabilities: &lt;em&gt;https://man7.org/linux/man-pages/man7/capabilities.7.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[48] &lt;/span&gt;&lt;p&gt;可能会被滥用以获取完整的root特权: &lt;em&gt;https://forums.grsecurity.net/viewtopic.php?t=2522&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>339ebd1316117ffef7cc498af4647b79</guid>
<title>学就完事了！万星项目带你做 3D 游戏：GitHub 热点速览</title>
<link>https://toutiao.io/k/2evvnnn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNN29hPlTneibyzZUZyPeBxja8kSdYL1g3Y4kF7HLiaej1apwHX2zWicfdicULX2mMYIBZye4MibNy6nfjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新手开始学习的时候，都会遇到一个问题：如何开始学 xx？See，这周的 GitHub 热榜项目们就是带你来学习新技术的，在这个五一假期学习下 3D 游戏的着色、阴影处理，了解下 3D 游戏的开发过程如何？实在不行，很多 HG 小伙伴说过的问过如何写一个操作系统？rust-raspberrypi-OS-tutorials 带你从写个可用于 ARM 架构的操作系统开始。此外，clean-code-javascript 教你写出优雅、可读性高的代码，Just Try it~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;&lt;section&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjaBOzrtK33XjZiaQyRcHHO9lLwUTXylbVXiaIo4GHp4HP9j9wyZkGZEYZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.46386333771353483&quot; data-w=&quot;761&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始本周的特推之前，如果你有什么想要的 GitHub 项目，记得留言呀~你的留言超重要 (≧▽≦)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 手把手教你做 3D 游戏：3d-game-shaders-for-beginners&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3d-game-shaders-for-beginners 是一个手把手教你一步步实践，从 SSAO、着色、光影处理、法线贴图（凸凹贴图的一种表现）带你体验 3D 游戏的制作。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/lettier/3d-game-shaders-for-beginners&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7505668934240363&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjauqIwice9icKd6zZjXVV3fzLHbHysZsPSOvk6n6GDz7PLsspkVh6hGicUg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;882&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 写个操作系统：rust-raspberrypi-OS-tutorials&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rust-raspberrypi-OS-tutorials 是一个手把手教你写个树莓派操作系统的教程，它详细地介绍了如何从零开始为嵌入式系统编写独立的操作系统内核，如果你是 ARM 64 位 ARMv8-A 的新手不妨来跟着它学习下。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjaz6n5hyklcFo7HbKUTvbUqm78ZRMiajjDeicch2YLOs8jBJmcdamoy5GQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.4542483660130719&quot; data-w=&quot;918&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Python 函数秒变微服务：opyrator&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：900+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Opyrator 可快速将你的 Python 函数变为可在生产环境使用的微服务，你可以通过 HTTP API /可交互的 UI 来部署和访问你的服务。Opyrator 由 FastAPI、Streamlit 和 Pydantic 提供服务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/ml-tooling/opyrator&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjaicDUdrgRwqgh4DicGQXnvcMg4sdMVMhLYrW9vib5zOGvJ7d1jth2TqM5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5407407407407407&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 终端命令校对器：thefuck&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,050+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;The Fuck 是个优秀的命令输出校验工具，它能自动帮你校对输入命令并执行正确的指令，当你输 &lt;code&gt;git brnch&lt;/code&gt; 再也不会看到该死的提示语 &lt;code&gt;git: &#x27;brnch&#x27; is not a git command. See &#x27;git --help&#x27;.&lt;/code&gt; The Fuck 会自动帮你执行 &lt;code&gt;git branch&lt;/code&gt; 命令，更别提写错的 puthon 它已经能理解为是 python，是不是很棒。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/nvbn/thefuck&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjaVR6IdtVJfve22QF1J1dxRyHH9qGxHpFYppWErHsxl1F0j2MHlF4QgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.5524781341107872&quot; data-w=&quot;686&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 HTML5 窗口管理器：winbox&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：2,150+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;New&lt;/code&gt; WinBox 是一个专业的 HTML5 Web 窗口管理器，它具有轻量、出色性能、无依赖、支持定制化开发等特性，可用于桌面应用、窗口、弹窗等场景下。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/nextapps-de/winbox&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjafDria6CG5Phgd4lBajYbDfjx7CmYFd6hkX9011p3W78voU2jliaRTVag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7318918918918919&quot; data-w=&quot;925&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 Firebase 替代品：supabase&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,950+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Supabase 使用企业级的开源工具构建 Firebase 特性，它是一个开源的 Firebase 替代品。特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Postgres 托管&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时订阅&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;身份验证和授权&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动生成 API&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面板&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/supabase/supabase&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjaeALxLqszpSFIc5bEFLUbcwYbHSE3FE4wx8KI9MpwjhAX3vtZElAmJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5846938775510204&quot; data-w=&quot;980&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 JS 代码整洁之道：clean-code-javascript&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：900+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想写出优雅、阅读性高的 JS 代码吗？clean-code-javascript 收录了适用 JavaScript 的整洁代码之法，旨在教你写出可读、可复用、可重构的优雅代码。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/ryanmcdermott/clean-code-javascript&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNN29hPlTneibyzZUZyPeBxjauLzrFI3swrW9mq0AHOYQLBBp69GJEwC1sWjXF5laXmicnJDdkIcAHDA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.942&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：AI 换头。👀 和之前的送书活动类似，留言点赞 Top5 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上为 2021 年第 18 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆「点击关注」&lt;/span&gt;&lt;/strong&gt;更多惊喜等待你的发现&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0f6e7f64a9e79f676b07e4a780cd1852</guid>
<title>58 集团白盒代码审计系统建设实践（二）：深入理解 SAST</title>
<link>https://toutiao.io/k/n05y7h2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102526&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;386:216&quot;&gt;&lt;span&gt;点击蓝字关注，第一时间获取最新消息&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99864&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;背 景&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;源代码安全检测是安全开发流程（SDL）中非常重要的一部分，在58集团的CI/CD流程中每天有数千次量级的构建及发布，白盒检测的自动化能力显得极为重要。企业级的白盒代码审计系统就不仅仅面临漏洞发现的需求，也需要适应企业CI/CD流程。由于58集团大部分业务使用自研的Java框架，本系列文章会重点介绍我们在Java白盒能力建设过程中的实践。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文是&lt;strong&gt;58白盒扫描建设之路系列文章第二篇&lt;/strong&gt;，主要介绍SAST的一些技术原理及应用、CodeQL的官方教程中文翻译及实践用法。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102512&quot;&gt;&lt;section hm_fix=&quot;259:282&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;技术原理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h1 cid=&quot;n5&quot; mdtype=&quot;heading&quot;&gt;&lt;em&gt;&lt;span&gt;01 理解AST抽象语法树&lt;/span&gt;&lt;/em&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有三个分支的节点来表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树，然后从分析树生成AST。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;抽象语法树是程序源代码结构的树状表示。程序源代码经过词法分析器（Lexer）得到各种不同种类的单词（Token），再由语法分析器（Parser）分析和语法检查后得到抽象语法树(AST)。抽象语法树的根节点表示整个程序，内部节点是抽象语法结构或者单词。AST的核心在于它能与输入源代码中的各个语法元素一一对应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如以下的C语言代码如图所示：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;while (i&amp;lt;n){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sum + = A[i++];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.973384030418251&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleuibATv3APXhzDUFtYSnmI9TicldjlXomfFUaBkClFbWtntaHbias6nw7vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;263&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;02 Java AST抽象语法树&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;h3 cid=&quot;n14&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;Spoon&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Spoon是一个开放源代码库，用于分析，重写，转换，翻译Java源代码。它解析源文件以构建具有强大分析和转换API的精心设计的AST。它完全支持Java 11、12、13、14之前的现代Java版本。Spoon是Inria的一个官方开源项目，并且是OW2开源联盟的成员。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;git地址：&lt;/span&gt;&lt;span&gt;https://github.com/INRIA/spoon&lt;/span&gt;&lt;/section&gt;&lt;h3 cid=&quot;n17&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;JAVA项目进行AST分析&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;可以通过自行编译Spoon源代码或者去：https://search.maven.org/artifact/fr.inria.gforge.spoon/spoon-core maven仓库下载已经编译好的Spoon的jar包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过以下命令进行GUI的语法树分析：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;java -cp /Users/58src/IDEA/spoon/target/spoon-core-8.4.0-SNAPSHOT-jar-&lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt;-dependencies.jar spoon.Launcher -i /&lt;span class=&quot;code-snippet__keyword&quot;&gt;Users&lt;/span&gt;/&lt;span class=&quot;code-snippet__number&quot;&gt;58&lt;/span&gt;src/IDEA/springboot-mybatis/src/&lt;span class=&quot;code-snippet__keyword&quot;&gt;main&lt;/span&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;java&lt;/span&gt;/cn/no7player/controller/HelloController.java  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对 Spring demo的 hello.java进行AST分析：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cn&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.no7player&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.controller&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.stereotype&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Controller&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.ui&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Model&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.web&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.bind&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.annotation&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.RequestMapping&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.web&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.bind&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.annotation&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.RequestParam&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__keyword&quot;&gt;Controller&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class HelloController {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @&lt;span class=&quot;code-snippet__keyword&quot;&gt;RequestMapping&lt;/span&gt;(&quot;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;hello&lt;/span&gt;&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public String greeting(@RequestParam(value=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;name&quot;&lt;/span&gt;, required=false, defaultValue=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;World&quot;&lt;/span&gt;) String name, Model model) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.addAttribute&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;&quot;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;return&lt;/span&gt; &quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;hello&lt;/span&gt;&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分析结果：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.53359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleu8VrHMGia1Ysb2sUS96icbWupQu9lchUEIYib89lkkUoQNkLeIg066tic0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;编程语言可以具有不同的元模型。抽象语法树（AST）或模型是元模型的实例。每个元模型（因此每个AST）或多或少都取决于手头的任务。例如，已针对Sun编译器（javac）的Java元模型进行了设计和优化，以将其编译为字节码，而Eclipse IDE（JDT）的Java元模型的主要目的是在一个软件中支持软件开发的不同任务。集成方式（代码完成，编译错误的快速修复，调试等）。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与基于编译器的AST（例如来自javac）不同，Java的Spoon元模型被设计为普通Java开发人员易于理解，因此他们可以编写自己的程序分析和转换。Spoon元模型是完整的，因为它包含派生可编译和可执行Java程序所需的所有信息（因此包含批注，泛型和方法体）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spoon元模型可以分为三个部分：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;①结构部分包含程序元素的声明，例如接口，类，变量，方法，注释和枚举声明。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;②代码部分包含可执行的Java代码，例如在方法主体中找到的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;③参考部分对对程序元素的引用（例如，对类型的引用）进行建模。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图所示，所有元素都继承自CtElement（javadoc），后者声明一个父元素，该父元素表示源文件中的包含关系。例如，方法节点的父级是类节点。所有名称均以“ CT”为前缀，表示“编译时”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从Spoon 6.1.0开始，Spoon元模型包含CtModule元素表示Java 9中的模块，以及CtModuleDirective表示模块的不同指令。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;提示：模型的根不再是未命名的包，而是未命名的模块。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6983914209115282&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleu8gWLbIYv0sjffoO7I60e5bY8KKJeP7iczVu4jXH06pvq6ICial2CTWAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;746&quot;/&gt;&lt;/p&gt;&lt;h2 cid=&quot;n35&quot; mdtype=&quot;heading&quot;&gt;&lt;em&gt;&lt;span&gt;03 SAST静态扫描&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;基本原理&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 cid=&quot;n36&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;SAST原理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.10625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleueCjPHzVdg8rs1NgY0SpMzBhp2g0QOxeTJp3JjiaESvy9sJMKMWgFL3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul cid=&quot;n38&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过调用语言的编译器或者解释器把前端的语言代码（如JAVA，C/C++源代码）转换成中间代码(IR，intermediaterepresentation)，将其源代码之间的调用关系、执行环境、上下文等分析清楚。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;语义分析：分析程序中不安全的函数，方法的使用的安全问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据流分析：跟踪，记录并分析程序中的数据传递过程所产生的安全问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;控制流分析：分析程序特定时间，状态下执行操作指令的安全问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;配置分析：分析项目配置文件中的敏感信息和配置缺失的安全问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;结构分析：分析程序上下文环境，结构中的安全问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;结合2~6步的结果，匹配所有规则库中的漏洞特征，一旦发现漏洞就抓取出来。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最后形成包含详细漏洞信息的漏洞检测报告，包括漏洞的具体代码行数以及漏洞修复的建议。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102512&quot;&gt;&lt;section hm_fix=&quot;259:282&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;简单理解污点分析技术&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当我们通过AST技术拿到了源码的抽象语法树，并将其数据格式化存储之后，需要一套高效的算法对漏洞模型进行匹配，在漏洞模型的建立上我们需要引入污点分析技术来对漏洞进行定义。&lt;/span&gt;&lt;/section&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n59&quot; mdtype=&quot;heading&quot;&gt;&lt;em&gt;&lt;span&gt;01 污点分析定义&lt;/span&gt;&lt;/em&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;污点分析可以抽象成一个三元组&amp;lt;sources,sinks,sanitizers&amp;gt;的形式,其中,source 即污点源,代表直接引入不受信任的数据或者机密数据到系统中;sink即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性);sanitizer即无害处理,代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害.污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点.如果不能,说明系统是信息流安全的;否则,说明系统产生了隐私数据泄露或危险数据操作等安全问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单的说：污点分析是默认不信任本地/外部输入，将本地及外部输入的控制/数据流过程进行分析，如果没有经过无害化处理，即认为存在漏洞的漏洞模型。&lt;/span&gt;&lt;/section&gt;&lt;h2 cid=&quot;n64&quot; mdtype=&quot;heading&quot;&gt;&lt;em&gt;&lt;span&gt;02 污点分析的处理过程&lt;/span&gt;&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;污点分析的处理过程可以分为三个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5559174809989142&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleuusOx6cJAibHw1H9QPNkcDnygaQWFdmHiaOUVgKbiaHoe98D3yyib47E6nQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;识别污点源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;识别污点源和污点汇聚点是污点分析的前提。目前，在不同的应用程序中识别污点源和汇聚点的方法各不&lt;/span&gt;&lt;span&gt;相同，缺乏通用方法的原因一方面来自系统模型、编程语言之间的差异。另一方面，污点分析关注的安全漏洞类型不同,也会导致对污点源和污点汇聚点的收集方法迥异。表 1 所示为在 Web 应用程序漏洞检测中的污点源示例[29]，它们是 Web 框架中关键对象的属性。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28816986855409504&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleuk5GBtf1hzMU2KbRdd8IoibHXuQb45OkLSmVIiaXUm90LK0nE7K3Bb8sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;现有的识别污点源和汇聚点的方法可以大致分成 3 类:&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul cid=&quot;n81&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用启发式的策略进行标记，例如把来自程序外部输入的数据统称为“污点”数据,保守地认为这些数据有可能包含恶意的攻击数据(如 PHP Aspis);&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据具体应用程序调用的 API 或者重要的数据类型,手工标记源和汇聚点(如 DroidSafe);&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用统计或机器学习技术自动地识别和标记污点源及汇聚点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 cid=&quot;n89&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;污点传播分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;污点传播分析就是分析污点标记数据在程序中的传播途径。按照分析过程中关注的程序依赖关系的不同，可以将污点传播分析分为显式流分析和隐式流分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 cid=&quot;n91&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;显示流分析&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;污点传播分析中的显式流分析就是分析污点标记如何随程序中变量之间的数据依赖关系传播。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7085828343313373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleug1aXIW8XZ3ywib3kTQDfyOawJJWCXAl5xF52ibcpMiaZUsOFEcjef2EiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;501&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以图 3 所 示的程序为例，变量 a 和 b 被预定义的污点源函数 source 标记为污点源。假设 a 和 b 被赋予的污点标记分别为taint_a 和 taint_b。由于第 5 行的变量 x 直接数据依赖于变量 a,第 6 行的变量 y 直接数据依赖于变量 b，显式流分析会分别将污点标记 taint_a 和 taint_b 传播给第 5 行的变量 x 和第 6 行的变量 y。又由于 x 和 y 分别可以到达第 7 行和第 8 行的污点汇聚点(用预定义的污点汇聚点函数 sink 标识)，图 3 所示的代码存在信息泄漏的问题。我们将在后面具体介绍目前污点传播分析中显式流分析面临的主要挑战和解决方法。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 cid=&quot;n95&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;隐式流分析&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;污点传播分析中的隐式流分析是分析污点标记如何随程序中变量之间的控制依赖关系传播，也就是分析污点标记如何从条件指令传播到其所控制的语句。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7504363001745201&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleuSmT7rf0qRI2iahnFFsoWIMyzucq3EwgUzRFI2sj1ibmyuF2n3dibGLOvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;573&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在图 4 所示的程序中，变量 X 是被污点标记的字符串类型变量，变量 Y 和变量 X 之间并&lt;strong&gt;没有直接或间接的数据依赖关系(显式流关系)，但 X 上的污点标记可以经过控制依赖隐式地传播到 Y。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体来说，由第 4 行的循环条件控制的外层循环顺序地取出 X 中的每一个字符，转化成整型后赋给变量 x，再由第 7 行的循环条件控制的内层循环以累加的方式将 x 的值赋给 y，最后由外层循环将 y 逐一传给 Y。最终，第 12 行的 Y 值和 X 值相同,程序存在信息泄漏问题。但是,如果不进行隐式流污点传播分析，第 12 行 的变量 Y 将不会被赋予污点标记,程序的信息泄漏问题被掩盖。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;隐式流污点传播一直以来都是一个重要的问题,和显式流一样，如果不被正确处理，会使污点分析的结果不精确。由于对隐式流污点传播处理不当导致本应被标记的变量没有被标记的问题称为欠污染(under-taint)问题。相反地，由于污点标记的数量过多而导致污点变量大量扩散的问题称为过污染(over-taint)问题。目前，针对隐式流问题的研究重点是尽量减少欠污染和过污染的情况，我们将在后面具体介绍现有技术是如何解决上述问题的。&lt;/span&gt;&lt;/section&gt;&lt;h3 cid=&quot;n102&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;无害处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;污点数据在传播的过程中可能会经过无害处理模块，无害处理模块是指污点数据经过该模块的处理后，数据本身不再携带敏感信息或者针对该数据的操作不会再对系统产生危害。换言之，带污点标记的数据在经过无害处理模块后，污点标记可以被移除。&lt;strong&gt;正确地使用无害处理可以降低系统中污点标记的数量，提高污点分析的效率，并且避免由于污点扩散导致的分析结果不精确的问题。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在应用过程中，为了防止敏感数据被泄露(保护保密性)，通常会对敏感数据进行加密处理。此时，&lt;strong&gt;加密库函数应该被识别成无害处理模块&lt;/strong&gt;。这一方面是由于库函数中使用了大量的加密算法，导致攻击者很难有效地计算出密码的可能范围；另一方面是加密后的数据不再具有威胁性，继续传播污点标记没有意义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，为了防止外界数据因为携带危险操作而对系统关键区域产生危害(保护完整性)，通常会对输入的数据进行验证。此时，&lt;strong&gt;输入验证(input validation)模块应当被识别成无害处理模块。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，为了防止代码注入漏洞，PHP 提供的 htmlentities 函数可以将特殊含义的 HTML 字符串转化成HTML实体(例如,将’&amp;lt;’转化成’&amp;lt;’).输入字符串经过上述转化后不会再携带可能产生危害的代码，可以安全地 发送给用户使用。除了语言自带的输入验证函数外，&lt;strong&gt;一些系统还提供了额外的输入验证工具，比如ScriptGard,CSAS,XSS Auditor,Bek.这些工具也应被识别成无害处理模块。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，目前对污点源、污点汇聚点以及无害处理模块的识别通常根据系统或漏洞类型使用定制的方法。由于这些方法都比较直接，本文将不再进行更深入的探讨，下一节将重点介绍污点传播中的关键技术。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;tips：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;更多的污点分析技术可参考以下链接及其参考链接：https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102512&quot;&gt;&lt;section hm_fix=&quot;259:282&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;理解CodeQL漏洞分析过程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2 cid=&quot;n111&quot; mdtype=&quot;heading&quot;&gt;&lt;em&gt;&lt;span&gt;01 整体流程&lt;/span&gt;&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;ul cid=&quot;n112&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过适配各个语言的AST解析器，并将代码的AST解析结果按照预设好的数据模型将代码AST数据及其依赖关系存储到CodeDB里；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过QL语言定义污点追踪漏洞模型；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;执行QL时通过高效的搜索算法对CodeDB的AST元数据进行高效查询，从而在代码中搜索出漏洞结果。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5343383584589615&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleukFhh4Sricmic8gibLsB609hcZ9raUdI0U6iayLTCq0jxHLLicS6wsibGH5ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;597&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleuJzIK2tDrf7kTf6o3xUcWVibmmibjichjDcicoanLbNm6wDzqlznDmbYCLQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;02 QL中的污点分析模型&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们以命令执行的QL作为例子来看在Codeql Rules里的污点分析是如何使用的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，Codeql也是使用&amp;lt;sources,sinks,sanitizers&amp;gt;三元组对污点分析过程进行三个阶段的定义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文件目录：/java/ql/src/Security/CWE/CWE-078/ExecTainted.ql&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @name Uncontrolled command line&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @description Using externally controlled strings in a command line is vulnerable to malicious&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; *              changes in the strings.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @kind path-problem&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @problem.severity error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @precision high&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @id java/command-line-injection&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @tags security&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; *       external/cwe/cwe-078&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; *       external/cwe/cwe-088&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import java /** 导入codeql的java依赖 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.FlowSources /** 导入java的Sources定义模块 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.security.ExternalProcess /** 导入定义java中执行系统命令模块 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import ExecCommon  /** 导入对java中命令执行的 sources、sink、sanitizer定义模块 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import DataFlow::PathGraph /** 导入java的数据流控制模块 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** 从DataFlow里导入 source、 sink、并且定义命令执行的参数为execArg **/    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;from DataFlow::PathNode source, DataFlow::PathNode sink, ArgumentToExec execArg&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** source、 sink、execArg 满足 execTainted的参数定义 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;where execTainted(source, sink, execArg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** 搜索满足execTainted谓词定义的参数、污染源及sink点并输出（可以理解成取交集的过程） **/    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;select execArg, source, sink, &quot;$@ flows to here and is used in a command.&quot;, source.getNode(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;User-provided value&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们再来看一下 ExecCommon 里是如何定义满足条件的 source、sink 及 sanitizer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文件目录：/java/ql/src/Security/CWE/CWE-078/ExecCommon.qll&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** 导入各种所依赖的配置 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.FlowSources&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.security.ExternalProcess&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.security.CommandArguments&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** 定义一个私有的Class作为远程命令执行的dataflow Config配置，并且这个Config配置继承自基础的Configuration **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private class RemoteUserInputToArgumentToExecFlowConfig extends TaintTracking::Configuration {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  RemoteUserInputToArgumentToExecFlowConfig() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  /** 定义该Config的别名为ExecCommon **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this = &quot;ExecCommon::RemoteUserInputToArgumentToExecFlowConfig&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  /** 重写对Source的定义，满足Source是远程数据输入，instanceof语句为满足后续谓词条件，依旧是取交集操作 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  /** 重写对Sink的定义，sink.asExpr为sink的表达式需要满足于ArgumentToExec的谓词定义 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  override predicate isSink(DataFlow::Node sink) { sink.asExpr() instanceof ArgumentToExec }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  /** 重写对Sanitizer的定义，节点的数据类型满足PrimitiveType，BoxedType 或者是安全的命令调用方式，便认为是经过了净化**/ &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  override predicate isSanitizer(DataFlow::Node node) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    node.getType() instanceof PrimitiveType&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    or&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    node.getType() instanceof BoxedType&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    or&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    isSafeCommandArgument(node.asExpr())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * Implementation of `ExecTainted.ql`. It is extracted to a QLL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * so that it can be excluded from `ExecUnescaped.ql` to avoid&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * reporting overlapping results.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/** 定义谓词 execTainted满足于RemoteUserInputToArgumentToExecFlowConfig条件，并且存在Source到Sink点的数据流 **/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;predicate execTainted(DataFlow::PathNode source, DataFlow::PathNode sink, ArgumentToExec execArg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  exists(RemoteUserInputToArgumentToExecFlowConfig conf |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    conf.hasFlowPath(source, sink) and sink.getNode() = DataFlow::exprNode(execArg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以看到CodeQL 使用结构化的查询，通过分别定义三元组&amp;lt;sources,sinks,sanitizers&amp;gt;，对满足其定义的所有AST元数据进行交集，并判断source到sink之间是否存在可达路径，如果存在可达路径即判断存在相关漏洞。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102512&quot;&gt;&lt;section hm_fix=&quot;259:282&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;在实际应用场景里的QL使用案例&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2 cid=&quot;n132&quot; mdtype=&quot;heading&quot;&gt;&lt;em&gt;&lt;span&gt;01 如何通过QL获取Spring项目的 Web Path&lt;/span&gt;&lt;/em&gt;&lt;/h2&gt;&lt;h3 cid=&quot;n133&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;规则分析&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;新建规则路径：java/ql/src/Security/CUSTOM/query/spring/SpringPath.ql&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @name Spring controller bind path &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @description list all Spring controller path in method bind and class bind.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @kind path-list&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @problem.severity information&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @precision Null&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @id java/Spring-path&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @tags Information-path&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import java&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.frameworks.spring.SpringCustomController&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.FlowSources&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;from SpringWebApiBindMethod m&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;select &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;m as controllerMethod, m.getLocation() as location,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;m.getBindPath() as methodBindPath,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;m.getControllerClassBindPath() as classBindPath, &quot;Spring bindPath&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;扫描结果，classBindPath + methodBindPath为Spring的Web path。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleu32QVJ8QHhQJ09Zh5nVD2XWW1eBzC2uqQfAib2U2xoL36qAe2oVA0n5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Spring Web Path的模块 ：java/ql/src/semmle/code/java/frameworks/spring/SpringCustomController.qll&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import java&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.Maps&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import SpringController&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * Sping框架web请求绑定方法&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class SpringWebApiBindMethod extends SpringMvcControllerMethod {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SpringWebApiBindMethod() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getAnAnnotation() instanceof SpringRequsetMappingCustomAnnotation&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        or &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getAnAnnotation() instanceof SpringRestMappingCustomAnnotation&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 获取方法绑定的路径RequsteMapping&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Expr getBindPath(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        result = getAnAnnotation().(SpringRequsetMappingCustomAnnotation).getValue(&quot;value&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        or &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        result = getAnAnnotation().(SpringRestMappingCustomAnnotation).getValue(&quot;value&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 获取mvc控制器类绑定的路径，不存在返回空字符串&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    string getControllerClassBindPath(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if this.isSpringMvcControllerBindPath() then &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        result = this.getDeclaringType().getAnAnnotation().(SpringRequsetMappingCustomAnnotation).getValue(&quot;value&quot;).toString()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        else result = &quot;&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 该方法的mvc控制器是否绑定了路径前缀&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    predicate isSpringMvcControllerBindPath() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        exists(SpringRequsetMappingCustomAnnotation a| this.getDeclaringType().getAnAnnotation() = a &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        and this.getDeclaringType().getAnAnnotation().(SpringRequsetMappingCustomAnnotation).getValue(&quot;value&quot;).toString().length()&amp;gt;0  )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 该方法的声明类型的直接类型或者间接类型满足Spring Controller的谓词定义&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class SpringMvcControllerMethod extends Method {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SpringMvcControllerMethod() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getDeclaringType().getAnAncestor() instanceof SpringController&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /** &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 该方法的声明类型名称包含Spring Request Mapping的注解&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class SpringRequsetMappingCustomAnnotation extends Annotation {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SpringRequsetMappingCustomAnnotation() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getType().getAnAncestor().hasQualifiedName(&quot;org.springframework.web.bind.annotation&quot;, &quot;RequestMapping&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        or&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getType().getAnAncestor().hasQualifiedName(&quot;org.springframework.web.bind.annotation&quot;, &quot;RestController&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /** &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     * 该方法的声明类型名称包含Spring Rest Mapping的注解&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class SpringRestMappingCustomAnnotation extends Annotation {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SpringRestMappingCustomAnnotation() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getType().getAnAncestor().hasQualifiedName(&quot;org.springframework.web.bind.annotation&quot;, &quot;GetMapping&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        or&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getType().getAnAncestor().hasQualifiedName(&quot;org.springframework.web.bind.annotation&quot;, &quot;PostMapping&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        or&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getType().getAnAncestor().hasQualifiedName(&quot;org.springframework.web.bind.annotation&quot;, &quot;PutMapping&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        or&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getType().getAnAncestor().hasQualifiedName(&quot;org.springframework.web.bind.annotation&quot;, &quot;DeleteMapping&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        or&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        getType().getAnAncestor().hasQualifiedName(&quot;org.springframework.web.bind.annotation&quot;, &quot;PatchMapping&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过对Spring框架对Web Controller的使用方法及注解的使用方法，定义了SpringWebApiBindMethod类，并通过getControllerClassBindPath()、getBindPath() 获取方法绑定的路径RequsteMapping及该方法的mvc控制器是否绑定了路径前缀。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再新建一个FlowSourceCustom.qll。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * 输入源和数据流定义&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import java&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.FlowSources&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.frameworks.spring.SpringComponentScan&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.frameworks.spring.SpringCustomController&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * Spring框架Servlet Input参数输入源&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class SpringCustomServletInputParameterSource extends RemoteFlowSource {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SpringCustomServletInputParameterSource() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      this.asParameter() = any(SpringRequestMappingParameter srmp | srmp.isTaintedInput())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    override string getSourceType() { result = &quot;Spring servlet input parameter&quot; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * Spring框架Multipart FileS参数输入源&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class SpringCustomMultipartFileSource extends RemoteFlowSource {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SpringCustomMultipartFileSource() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      exists(MethodAccess ma, Method m |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ma = this.asExpr() and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        m = ma.getMethod() and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        m.getDeclaringType()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .getASourceSupertype*()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .hasQualifiedName(&quot;org.springframework.web.multipart&quot;, &quot;MultipartFile&quot;) and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        m.getName().matches(&quot;get%&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    override string getSourceType() { result = &quot;Spring MultipartFile getter&quot; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * Spring框架Multipart request参数输入源&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class SpringCustomMultipartRequestSource extends RemoteFlowSource {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SpringCustomMultipartRequestSource() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      exists(MethodAccess ma, Method m |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ma = this.asExpr() and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        m = ma.getMethod() and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        m.getDeclaringType()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .getASourceSupertype*()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            .hasQualifiedName(&quot;org.springframework.web.multipart&quot;, &quot;MultipartRequest&quot;) and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        m.getName().matches(&quot;get%&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    override string getSourceType() { result = &quot;Spring MultipartRequest getter&quot; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后将FlowSourceCustom.qll  import至 /java/ql/src/semmle/code/java/dataflow/FlowSources.qll就可以使用SpringPath.ql进行Spring的path查询。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们来看一个实际的例子fastjson.java文件：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package org.joychou.controller;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import com.alibaba.fastjson.JSON;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import com.alibaba.fastjson.JSONObject;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import com.alibaba.fastjson.parser.Feature;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.RequestBody;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.RequestMethod;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.ResponseBody;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Controller&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@RequestMapping(&quot;/fastjson&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class Fastjson {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @RequestMapping(value = &quot;/deserialize&quot;, method = {RequestMethod.POST})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @ResponseBody&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public String Deserialize(@RequestBody String params) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 如果Content-Type不设置application/json格式，post数据会被url编码&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 将post提交的string转换为json&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            JSONObject ob = JSON.parseObject(params);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return ob.get(&quot;name&quot;).toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return e.toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n147&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;controllerMethod&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;controllerMethod.getLocation&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;methodBindPath&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;classBindPath&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Type&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n153&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;Deserialize&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Fastjson:19[19-29]&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&quot;/deserialize&quot;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&quot;/fastjson&quot;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Spring bindPath&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span&gt;QL对该文件扫描结果如上表，&lt;/span&gt;&lt;span&gt;我们可以看到 /fastjson/deserialize 即是该方法的Web Path。&lt;/span&gt;&lt;/section&gt;&lt;h2 cid=&quot;n161&quot; mdtype=&quot;heading&quot;&gt;&lt;em&gt;&lt;span&gt;02 结合SCA判断fastjson是否可利用&lt;/span&gt;&lt;/em&gt;&lt;/h2&gt;&lt;h3 cid=&quot;n162&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;Fastjson不安全使用&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;Fastjson不安全的使用需要满足以下三个条件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、项目中导入了不安全的Fastjson版本；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、项目中使用了Fastsjon不安全的反序列化方法去反序列化外部传入的Json数据；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、项目中存在利用Fastjson反序列化利用方法的反序列化调用链。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、3 通过SCA的能力去解决，2可以通过QL分析源代码拿到FastJson在项目中的使用情况，下面我们来分析一下如何使用QL查询Fastjson是否在在代码中被安全使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;java-sec-code里的fastjson反序列化demo：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package org.joychou.controller;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import com.alibaba.fastjson.JSON;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import com.alibaba.fastjson.JSONObject;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import com.alibaba.fastjson.parser.Feature;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.RequestBody;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.RequestMethod;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.web.bind.annotation.ResponseBody;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Controller&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@RequestMapping(&quot;/fastjson&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class Fastjson {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @RequestMapping(value = &quot;/deserialize&quot;, method = {RequestMethod.POST})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @ResponseBody&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public String Deserialize(@RequestBody String params) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 如果Content-Type不设置application/json格式，post数据会被url编码&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 将post提交的string转换为json&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            JSONObject ob = JSON.parseObject(params);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return ob.get(&quot;name&quot;).toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } catch (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return e.toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在来看看QL里的Fastjson查询：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @name FastJson deserializing of user-controlled data&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @description FastJson deserializing user-controlled data may allow attackers to&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; *              execute arbitrary code.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @kind path-problem&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @problem.severity error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @precision high&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @id java/unsafe-fastjson-deserialization&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * @tags security&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; *       external/cwe/cwe-502/Fastjson deserialization&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import java&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.FlowSources&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.security.FastJson&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import DataFlow::PathGraph&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class UnsafeFastJsonSinkConfig extends TaintTracking::Configuration {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  UnsafeFastJsonSinkConfig() { this = &quot;UnsafeFastJsonConfig&quot; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  override predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  override predicate isSink(DataFlow::Node sink) { sink instanceof UnSafeFastJsonSink }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;from DataFlow::PathNode source, DataFlow::PathNode sink, UnsafeFastJsonSinkConfig conf&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;where conf.hasFlowPath(source, sink)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;select sink.getNode().(UnSafeFastJsonSink).getMethodAccess(), source, sink,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;Unsafe fastjson deserialization of $@.&quot;, source.getNode(), &quot;user input&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先我们定义了一个继承Configuration的 UnsafeFastJsonSinkConfig类，其需要满足于 dataFlow里的source满足RemoteFlowSource（远程用户输入）的谓词定义、sink点需要满足UnSafeFastJsonSink（不安全的Fastjson使用）的谓词定义。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过搜索where conf.hasFlowPath(source, sink) 满足UnsafeFastJsonSinkConfig条件的sources和sink并且source和sink之间是可达的，那我们就认为该处存在fastjson的不安全使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们再来看看Fastjson.qll是如何定义UnSafeFastJsonSink。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.DataFlow&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.DataFlow2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.dataflow.DataFlow3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import semmle.code.java.frameworks.FastJson&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;predicate unsafeFastjson(MethodAccess ma, Expr sink) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  exists(Method m | m = ma.getMethod() |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ma.getMethod() instanceof FastJsonParseMethod and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    not fastJsonLooksSafe() and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sink = ma.getArgument(0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class UnSafeFastJsonSink extends DataFlow::ExprNode {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    UnSafeFastJsonSink() { unsafeFastjson(_, this.getExpr()) }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  MethodAccess getMethodAccess() { unsafeFastjson(result, this.getExpr()) }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;谓词unsafeFastjson需要满足于存在fastjson的调用方法并且未配置safety配置的方法。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们再来看看 FastJsonParseMethod、和fastJsonLooksSafe是如何编写的：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * The class `com.alibaba.fastjson.JSON`.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class FastJson extends RefType {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  FastJson() { this.hasQualifiedName(&quot;com.alibaba.fastjson&quot;, &quot;JSON&quot;) }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * A FastJson parse method. This is either `JSON.parse` or `JSON.parseObject`.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class FastJsonParseMethod extends Method {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  FastJsonParseMethod() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this.getDeclaringType() instanceof FastJson and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    this.hasName([&quot;parse&quot;, &quot;parseObject&quot;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * A call to `ParserConfig.setSafeMode`.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class FastJsonSetSafeMode extends MethodAccess {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  FastJsonSetSafeMode() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    exists(Method m |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      this.getMethod() = m and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      m.hasName(&quot;setSafeMode&quot;) and&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      m.getDeclaringType().hasQualifiedName(&quot;com.alibaba.fastjson.parser&quot;, &quot;ParserConfig&quot;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到我们将JSON.parse和JSON.parseObject定义为危险函数，&lt;/span&gt;&lt;span&gt;而使用setSafeMode配置的，我们认为是安全的。&lt;/span&gt;&lt;span&gt;通过查询我们可以成功搜索出代码里的不安全的fastjson使用方式。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.65703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6b7G0YdALRz9BC0h9gcAgTRibwMsgrleuERaPayaV9Qn8jWpYricvAL3lWI5HMxr8CsFhicwhu5ht1jBrI699x34g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;结合SCA我们可以完成以上三个条件对fastjson安全风险的发现。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>