<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>67446a5d410767d92071bc0e2a2a95b3</guid>
<title>俞敏洪：我的退与进；架构师必须了解的5种最佳软件架构模式；Redis夺命52连问｜码农周刊VIP会员专属邮件周报 Vol.096</title>
<link>https://toutiao.io/k/au2ts9v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;本文内容节选自&lt;strong&gt;「码农周刊VIP会员专属邮件周报 Vol.096」&lt;/strong&gt;，感谢阅读。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;想邮件订阅周报？扫码即刻订阅！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;↓↓↓&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;俞敏洪：我的退与进&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;em&gt;https://mp.weixin.qq.com/s/EEuSCgUX-ngOj6akUreuhQ&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;在未来的岁月中，对自身生命要有什么样的交代。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;AOL：Web1.0时代的一件往事&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://mp.weixin.qq.com/s/Ay4VXw5pOsBEKaEP-qPxsg&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;进化永远不会停止，这是互联网的本质。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;架构师必须了解的 5 种最佳软件架构模式&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/knun5wy&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;架构模式是针对特定环境中常见软件架构问题的通用且可重用的解决方案&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;哈啰推荐引擎搭建实战&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/fnlspfp&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;推荐引擎本质上是一种信息过滤系统，特点是用户无明确意图。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Java、Go 和 Python 的多线程性能对比&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/qac29q3&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;供参考&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Golang中泛型的使用&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/68j23an&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;全面解读&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;3000帧动画图解MySQL为什么需要binlog、redo log和undo log&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/b0g4460&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;图文并茂&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Redis夺命52连问&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/he3fzao&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;供参考&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Kubernetes网络难懂？快来看这篇文章&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/cgk9ym2&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;图文并茂&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;如何做好CodeReview&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://toutiao.io/k/v5nrj6u&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;经验总结&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;想邮件订阅周报？扫码即刻订阅！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;↓↓↓&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cdc9d2e211037d6d3e0ede9d78bdb650</guid>
<title>[推荐] Redis夺命52连问</title>
<link>https://toutiao.io/k/he3fzao</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是苏三，&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247491359&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭系列&lt;/a&gt;继续，这节我们来搞定Redis——不会有人假期玩去了吧？不会吧？&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.说说什么是Redis?&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7284263959390863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat60I3icga9By11qSyNsNe8IvaoJAhsvjP4uBaCFDOoXCiaNGffUAcYKKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;figcaption&gt;Redis图标&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis是一种基于键值对（key-value）的NoSQL数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比一般键值对数据库强大的地方，Redis中的value支持string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构，因此 Redis可以满足很多的应用场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常出色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，Redis是一款强大的性能利器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.Redis可以用来干什么？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8396624472573839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatrrBMiatBgLc3eGcIXxSwu5vc3l8LAgNDh68pd4OPiapR25nzaUVmvp6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;figcaption&gt;Redis&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存&lt;/p&gt;&lt;p&gt;这是Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6151797603195739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatV11TnNia9h4ktQNHNyhcpGlzicVj1p0XYib1EqFiaZMXtXxGwQnW77SWMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;751&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;计数器
Redis天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞量等等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;排行榜
Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;社交网络
赞/踩、粉丝、共同好友/喜好、推送、下拉刷新。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消息队列
Redis提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分布式锁
分布式环境下，利用Redis实现分布式锁，也是Redis常见的应用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis的应用一般会结合项目去问，以一个电商项目的用户服务为例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Token存储：用户登录成功之后，使用Redis存储Token&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;地址缓存：对省市区数据的缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式锁：分布式环境下登录、注册等操作加分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;……&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.Redis 有哪些数据结构？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9119804400977995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatGE9iatwDjj6iavP6gcrD5XXNyrry9WExaUTKSeWbraodiaq3PcoNwFK7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;Redis有五种基本数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;string&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串主要有以下几个典型使用场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;hash&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈希类型是指键值本身又是一个键值对结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈希主要有以下典型应用场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;list&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表主要有以下几种使用场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;set&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集合主要有如下使用场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;sorted set&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有序集合主要应用场景：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Redis为什么快呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;完全基于内存操作&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使⽤单线程，避免了线程切换和竞态产生的消耗&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于⾮阻塞的IO多路复⽤机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.600297176820208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iate5JX63hdYxPoS2Bjb0IdZ6sC9uJvyXOPphuCwicKPtMpVj3EGFbjKSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.能说一下I/O多路复用吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。这种类似于为每一个用户创建一个进程或者- 线程处理连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种就是阻塞IO模型，第三种就是I/O复用模型。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4407894736842106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatjroOrgleGiajcJA9HBdYiayXu8C3paazf4E9tnaXKO9o90pcqVkFqdWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;figcaption&gt;多路复用模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux系统有三种方式实现IO多路复用：select、poll和epoll。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如epoll方式是将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，整个过程只在进行select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. Redis为什么早期选择单线程？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方解释：https://redis.io/topics/faq&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3741648106904232&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat4MvZX6nFmahmj9ayY3tibBCkice6Jmu7E2Oz2k8LFzj6gnpcYKxZA0lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;官方FAQ表示，因为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，Redis的瓶颈最有可能是内存的大小或者网络限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要最大程度利用CPU，可以在一台机器上启动多个Redis实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：网上有这样的回答，吐槽官方的解释有些敷衍，其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时FAQ里还提到了， Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.Redis6.0使用多线程是怎么回事?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis不是说用单线程的吗？怎么6.0成了多线程的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis6.0的多线程是用多线程来处理数据的&lt;strong&gt;读写和协议解析&lt;/strong&gt;，但是Redis&lt;strong&gt;执行命令&lt;/strong&gt;还是单线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5530216647662486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatfXs2ibCve6tkIibiaGLCSKlrOUWGDuDkAdBvEyWEFMux4wwFDtXjPMyHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;持久化&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.Redis持久化⽅式有哪些？有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis持久化⽅案分为RDB和AOF两种。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6568144499178982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatC0JaRKGIZCJ5GaU7ds87F5XJiaGtbgCMwzZVtOv1ulowcH7j5BvHzkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RDB&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB持久化是把当前进程数据生成&lt;strong&gt;快照&lt;/strong&gt;保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手动触发分别对应save和bgsave命令:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7001934235976789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatdugl54WNVlDxfuibk0YBalxl9UpytvdtpiadkazRUHFx8ud95TuKBGzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下场景会自动触发RDB持久化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行debug reload命令重新加载Redis时，也会自动触发save操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AOF&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5910878112712975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatbtvG9zPSELQztyKaKmtWhSico3c1wDgdP8d18IPjcpOHMyAcRUVoG5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;流程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）所有的写入命令会追加到aof_buf（缓冲区）中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）AOF缓冲区根据对应的策略向硬盘做同步操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.RDB 和 AOF 各自有什么优缺点？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RDB | 优点&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;只有一个紧凑的二进制文件 &lt;code&gt;dump.rdb&lt;/code&gt;，非常适合备份、全量复制的场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;容灾性好&lt;/strong&gt;，可以把RDB文件拷贝道远程机器或者文件系统张，用于容灾恢复。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;恢复速度快&lt;/strong&gt;，RDB恢复数据的速度远远快于AOF的方式&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RDB | 缺点&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实时性低&lt;/strong&gt;，RDB 是间隔一段时间进行持久化，没法做到实时持久化/秒级持久化。如果在这一间隔事件发生故障，数据会丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;存在兼容问题&lt;/strong&gt;，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AOF | 优点&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实时性好&lt;/strong&gt;，aof 持久化可以配置 &lt;code&gt;appendfsync&lt;/code&gt; 属性，有 &lt;code&gt;always&lt;/code&gt;，每进行一次命令操作就记录到 aof 文件中一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AOF | 缺点&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AOF 文件比 RDB &lt;strong&gt;文件大&lt;/strong&gt;，且 &lt;strong&gt;恢复速度慢&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据集大&lt;/strong&gt; 的时候，比 RDB &lt;strong&gt;启动效率低&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.RDB和AOF如何选择？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一般来说， 如果想达到足以媲美数据库的 &lt;strong&gt;数据安全性&lt;/strong&gt;，应该 &lt;strong&gt;同时使用两种持久化功能&lt;/strong&gt;。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;strong&gt;可以接受数分钟以内的数据丢失&lt;/strong&gt;，那么可以 &lt;strong&gt;只使用 RDB 持久化&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果只需要数据在服务器运行的时候存在，也可以不使用任何持久化方式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.Redis的数据恢复？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Redis发生了故障，可以从RDB或者AOF中恢复数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恢复的过程也很简单，把RDB或者AOF文件拷贝到Redis的数据目录下，如果使用AOF恢复，配置文件开启AOF，然后启动redis-server即可。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6632124352331606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat249sYDPh3TX3FnXIjo8kH7Tk14uEzpR85GQibRGqYPtuW9xqz9vy0FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;772&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis&lt;/strong&gt; 启动时加载数据的流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AOF持久化开启且存在AOF文件时，优先加载AOF文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF关闭或者AOF文件不存在时，加载RDB文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载AOF/RDB文件成功后，Redis启动成功。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.Redis 4.0 的混合持久化了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重启 Redis 时，我们很少使用 &lt;code&gt;RDB&lt;/code&gt; 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 &lt;code&gt;RDB&lt;/code&gt; 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis 4.0&lt;/strong&gt; 为了解决这个问题，带来了一个新的持久化选项——&lt;strong&gt;混合持久化&lt;/strong&gt;。将 &lt;code&gt;rdb&lt;/code&gt; 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 &lt;strong&gt;自持久化开始到持久化结束&lt;/strong&gt; 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4924698795180723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatvIxGkkHicQxEInSIYDYnr4icJbmO1Iw7ibf1s7KuMJwtia6eicHoicKGbsibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是在 Redis 重启的时候，可以先加载 &lt;code&gt;rdb&lt;/code&gt; 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis保证高可用主要有三种方式：主从、哨兵、集群。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.主从复制了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45887961859356374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatLD7fUVicic3VU2RSul8o5FtwMHysK4Da9wOPicD1XOicy0IcsVgSgjjE0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;839&quot;/&gt;&lt;figcaption&gt;Redis主从复制简图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主从复制&lt;/strong&gt;，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 &lt;strong&gt;单向&lt;/strong&gt; 的，只能由主节点到从节点。Redis 主从复制支持 &lt;strong&gt;主从同步&lt;/strong&gt; 和 &lt;strong&gt;从从同步&lt;/strong&gt; 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主从复制主要的作用?&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据冗余：&lt;/strong&gt; 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;故障恢复：&lt;/strong&gt; 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;负载均衡：&lt;/strong&gt; 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 &lt;em&gt;（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）&lt;/em&gt;，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高可用基石：&lt;/strong&gt; 除了上述作用以外，主从复制还是哨兵和集群能够实施的 &lt;strong&gt;基础&lt;/strong&gt;，因此说主从复制是 Redis 高可用的基础。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.Redis主从有几种常见的拓扑结构？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从、树状主从结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.一主一从结构&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2559055118110236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatHxPZOg5XsibcVUgTvFpGMpmkspmDU5J6YSxzwX1kzZdUp1T2l1Rj7Kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;254&quot;/&gt;2.一主多从结构&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离（见图6-5）。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5201938610662359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatD0icwxuse1PEIC5Cp5j05rnOTowEbpHk1ZVCgkLnUAzRpn5ICxg7QTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;619&quot;/&gt;3.树状主从结构&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8123861566484517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatxJyAKPUIsZ16zUev1iaA7p7ErWl6ic8w8r3mc1Is4JhNSFpzTeDTurZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.Redis的主从复制原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis主从复制的工作流程大概可以分为如下几步：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1471103327495622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatdLfBBpjkqBBvvybykECPRnuLtWnicXFYicpibHokIYKQqnwlbh08oiaojg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;保存主节点（master）信息
这一步只是保存主节点信息，保存主节点的ip和port。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主从建立连接
从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送ping命令
连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;权限验证
如果主节点要求密码验证，从节点必须正确的密码才能通过验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同步数据集
主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令持续复制
接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.说说主从数据同步的方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49500998003992014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatLJzBeK53bsgiag8Aian4YnRz7tkXERjJvxicUSpCeflo2yQVujKW8t7tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;501&quot;/&gt;&lt;figcaption&gt;主从数据同步方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;全量复制&lt;/strong&gt;一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全量复制的完整运行流程如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.023407022106632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatwNQCoum33fibkje6YGrTSRz3oxF3locibbviaKOy4ragpfgAJOdArYEGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从节点接收主节点的响应数据保存运行ID和偏移量offset&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点执行bgsave保存RDB文件到本地&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从节点接收完主节点传送来的全部数据后会清空自身旧数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从节点清空数据后开始加载RDB文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;部分复制&lt;/strong&gt;部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5235294117647059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatdWayjn1GFXQHbY2y9iaBPBnTvicE2ibbIPeBwm8lZE0YG4pbvldFqvFEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当主从节点网络恢复后，从节点会再次连上主节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.主从复制存在哪些问题呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从复制虽好，但也存在一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点的写能力受到单机的限制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主节点的存储能力受到单机的限制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.Redis Sentinel（哨兵）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从复制存在一个问题，没法完成自动故障转移。所以我们需要一个方案来完成自动故障转移，它就是Redis Sentinel（哨兵）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5148648648648648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatDhyqn6WPRQ3Ta4icUibKKFGxp3m0sAAaOvWwH34cBemGnaJ1LgRcFXgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;figcaption&gt;Redis Sentinel&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Sentinel ，它由两部分组成，哨兵节点和数据节点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;哨兵节点：&lt;/strong&gt; 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据节点：&lt;/strong&gt; 主节点和从节点都是数据节点；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在复制的基础上，哨兵实现了 &lt;strong&gt;自动化的故障恢复&lt;/strong&gt; 功能，下面是官方对于哨兵功能的描述：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监控（Monitoring）：&lt;/strong&gt; 哨兵会不断地检查主节点和从节点是否运作正常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自动故障转移（Automatic failover）：&lt;/strong&gt; 当 &lt;strong&gt;主节点&lt;/strong&gt; 不能正常工作时，哨兵会开始 &lt;strong&gt;自动故障转移操作&lt;/strong&gt;，它会将失效主节点的其中一个 &lt;strong&gt;从节点升级为新的主节点&lt;/strong&gt;，并让其他从节点改为复制新的主节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置提供者（Configuration provider）：&lt;/strong&gt; 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;通知（Notification）：&lt;/strong&gt; 哨兵可以将故障转移的结果发送给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.Redis Sentinel（哨兵）实现原理知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哨兵模式是通过哨兵节点完成对数据节点的监控、下线、故障转移。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1650390625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatc1AjIvbQrbSATQGFTMvpYne2eKO6k3bv9P2iapvbqkFoiaKo5qH0ufoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;定时监控&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34628378378378377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatHibtYGcHECOScJNUQhzEHZnvqhJo4ajicL0OGFKUiciaQA0lyEWPQzBNKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;Redis Sentinel通过三个定时监控任务完成对各个节点发现和监控：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主观下线和客观下线&lt;/strong&gt;主观下线就是哨兵节点认为某个节点有问题，客观下线就是超过一定数量的哨兵节点认为主节点有问题。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.904424778761062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatneYKyvY5q9tTMfaF1uUlLibgcqkEpY3tYWpCJhH282l5V77gLMrtRcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;565&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主观下线
每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过 down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客观下线
当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is- master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过 &amp;lt;quorum&amp;gt;个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;领导者Sentinel节点选举&lt;/strong&gt;Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;领导者选举出的Sentinel节点负责故障转移，过程如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1755813953488372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatgaXAicWYwiaVdF0ljoRyDtcsAVY2T6ejosguCF7doMfMJKEicpib4PPVSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在从节点列表中选出一个节点作为新的主节点，这一步是相对复杂一些的一步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.领导者Sentinel节点选举了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis使用了Raft算法实 现领导者选举，大致流程如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47058823529411764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iathcSqmUaclc8aBLwG8ibolibyOHTRPJjE4DViaBeyxcFgr4rKU542fSdPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将自己设置为领导者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果该Sentinel节点发现自己的票数已经大于等于max（quorum， num（sentinels）/2+1），那么它将成为领导者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此过程没有选举出领导者，将进入下一次选举。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.新的主节点是怎样被挑选出来的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选出新的主节点，大概分为这么几步：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1008064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatW3IOTg4KqhlVtXTG0a0XH1cgLpURicx15S6zm3akfMmCNk8NE3edf6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节 点ping响应、与主节点失联超过down-after-milliseconds*10秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择复制偏移量最大的从节点（复制的最完整），如果存在则返 回，不存在则继续。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择runid最小的从节点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.Redis 集群了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说到了主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5956006768189509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatEIOYok9At3ibmfjUiccacbWp2uX8GynibWHElDaRWAUUIib9KYUibrMx8iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据分区：&lt;/strong&gt; 数据分区 &lt;em&gt;(或称数据分片)&lt;/em&gt; 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，&lt;strong&gt;存储容量大大增加&lt;/strong&gt;；&lt;strong&gt;另一方面&lt;/strong&gt; 每个主节点都可以对外提供读服务和写服务，&lt;strong&gt;大大提高了集群的响应能力&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;高可用：&lt;/strong&gt; 集群支持主从复制和主节点的 &lt;strong&gt;自动故障转移&lt;/strong&gt; &lt;em&gt;（与哨兵类似）&lt;/em&gt;，当任一节点发生故障时，集群仍然可以对外提供服务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.集群中数据如何分区？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式的存储中，要把数据集按照分区规则映射到多个节点，常见的数据分区规则三种：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4953271028037383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatAPCyCVibX6qL4M7L2eszC61Ug0sBdiaa2qfiasCWcfNNXynPib2iayaCDCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方案一：节点取余分区&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点取余分区，非常好理解，使用特定的数据，比如Redis的键，或者用户ID之类，对响应的hash值取余：hash（key）%N，来确定数据映射到哪一个节点上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过该方案最大的问题是，当节点数量变化时，如扩容或收缩节点，数据节点映射关 系需要重新计算，会导致数据的重新迁移。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37553956834532376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatdHXa7W0hGVSuorImJZEJB3vz5CZmpiaTflRWnxEG1ta2gLutvIcibK3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;figcaption&gt;节点取余分区&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方案二：一致性哈希分区&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当我们需要确定某一个 Key 需 要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说下面 这张图里面，Key 1 和 Key 2 会落入到 Node 1 中，Key 3、Key 4 会落入到 Node 2 中，Key 5 落入到 Node 3 中，Key 6 落入到 Node 4 中。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9488054607508533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat8F63Bq2pNhC5atuWHBImfyrv6zt1Pr0AE0miaTPyvyr6qsJkoUeJGpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中 相邻的节点，对其他节点无影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它还是存在问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方案三：虚拟槽分区&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案 一致性哈希分区的基础上，引入了 &lt;strong&gt;虚拟节点&lt;/strong&gt; 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 &lt;strong&gt;槽（slot）&lt;/strong&gt;。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4842639593908629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatPjVvgOy72Jq4psUlbBvIUTxWicWaY0R7Rvab0mRDUBefvAK9rd1W8sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 &lt;code&gt;4&lt;/code&gt; 个实际节点，假设为其分配 &lt;code&gt;16&lt;/code&gt; 个槽(0-15)；&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;槽 0-3 位于 node1；4-7 位于 node2；以此类推....&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时删除 &lt;code&gt;node2&lt;/code&gt;，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 &lt;code&gt;node1&lt;/code&gt;，槽 6 分配给 &lt;code&gt;node3&lt;/code&gt;，槽 7 分配给 &lt;code&gt;node4&lt;/code&gt;，数据在其他节点的分布仍然较为均衡。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.能说说Redis集群的原理吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;集群创建&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据分区是在集群创建的时候完成的。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3050847457627119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatkzChL0MNR008L5aIfiaE3oTjZPcjvOcuFKvlfleOQWtD27K6mZDddrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设置节点&lt;/strong&gt;Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4022140221402214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatc79fO31FZYNlhoxBXZ237XF31ASCekjum1tjpsTA6DRdyZbXYWWtGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;strong&gt;节点握手&lt;/strong&gt;节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分配槽（slot）&lt;/strong&gt;Redis集群把所有的数据映射到16384个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatylJfacMu4zpFK7zcxrygmSIyrGZaPmiaICMGQDib0ovspfuiaa3w9ku0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;figcaption&gt;分配槽&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;故障转移&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中所有的节点都要承担状态维护的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;故障发现&lt;/strong&gt;Redis集群内节点通过ping/pong消息实现节点通信，集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong 消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45824847250509165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatxkibaNUVTkZz7hs6icfTMdLQzpFhszOZiciaT1Fic1ickbNgmWRN9cEwJtZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot;/&gt;当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6456494325346784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatK447hYI8W5ugzWowQ6TRZtsuEHh4m1jQ0sxq2VZz1kl4jTmnictwuHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;793&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;故障恢复&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它 的从节点中选出一个替换它，从而保证集群的高可用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7962962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatJ6VpUzQ5Uz9hq24BsnqseiataQ8x6ToCk41QnqrMbAw8iahYD3JUQic9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;270&quot;/&gt;&lt;figcaption&gt;故障恢复流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;资格检查
每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障 的主节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;准备选举时间
当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该 时间后才能执行后续流程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发起选举
当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选举投票
持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有N个持有槽的主节 点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N/2+1的选票，保证能够找出唯一的从节点。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5134788189987163&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatbeOyjLjqq4eBSyBibGr3RCC1UHre5ianicxW1PmL9PtGibuNFcicGUfyJ8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;替换主节点
当从节点收集到足够的选票之后，触发替换主节点操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;部署Redis集群至少需要几个物理节点？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是3主3从，其中有2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3/2+1个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在3台物理机上才能避免单点问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.说说集群的伸缩？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis集群提供了灵活的节点扩容和收缩方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容也可以下线部分节点进行缩容。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8639455782312925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat3uKicss6vvWDaKlvdl5r9icVlIX1tDFlr1SxL5AXqr2iblFkkstP4dAyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;588&quot;/&gt;其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分&lt;code&gt;槽&lt;/code&gt;和&lt;code&gt;数据&lt;/code&gt;迁移给新节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如下面一个集群，每个节点对应若干个槽，每个槽对应一定的数据，如果希望加入1个节点希望实现集群扩容时，需要通过相关命令把一部分槽和内容迁移给新节点。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6032745591939547&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iaticNQ11jaT3GcEoJbDNicRu9Uy981Xd1kronU0KyAYticnRTzheClBUOwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;缩容也是类似，先把槽和数据迁移到其它节点，再把对应的节点下线。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存设计&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.什么是缓存击穿、缓存穿透、缓存雪崩？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:这是多年黄历的老八股了，一定要理解清楚。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓存击穿&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在DB上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3797814207650274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatWKoiaoOQySeo234H3K5Lv4MEjQicneHdgLnxNXQUj6c1dafTL2Jy7FTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;366&quot;/&gt;解决⽅案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加锁更新，⽐如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3012658227848102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatfqMRIyrXG3pmI8ujBSWC1mHpHBcbAemyNribPvMYHibLHNWvhwaGiaU0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;395&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将过期时间组合写在value中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓存穿透&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存穿透指的查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4027777777777777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatAXn9jlfeI37cicYOw42CPT7KBHv7RpseMDngk7USFnEAwHBEzibE1LVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;360&quot;/&gt;缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存穿透可能会使后端存储负载加大，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存穿透可能有两种原因：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自身业务代码问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;恶意攻击，爬虫造成空命中&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它主要有两种解决办法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3631436314363143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatcGrZyPJRB8x672PjPvfOkmbgm1QF8Rc0weGxScd1pmB9XnPoXuRjAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;369&quot;/&gt;&lt;figcaption&gt;缓存空值/默认值&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存空值有两大问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;布隆过滤器&lt;/strong&gt;除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;布隆过滤器里会保存数据是否存在，如果判断数据不不能再，就不会访问存储。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.263157894736842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatN5e8CnCW7ZiahxJdfkYQH0dgFxHYOGT9haBen1jRpsAB5mM4nuGIzvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;399&quot;/&gt;两种解决方案的对比：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3807829181494662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatBgtaKbepG49tWUZR0HuzwP1HRzGlz5H6RIQn5gHMbbXn1kBS3z3opQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓存雪崩&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某⼀时刻发⽣⼤规模的缓存失效的情况，例如缓存服务宕机、大量key在同一时间过期，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6021765417170496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatIAzIRQic3bqbkGPDF3xFOQ2WU9rp1rLicSA8f1QzLb4hLCPF3ap1fTjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;缓存雪崩是三大缓存问题里最严重的一种，我们来看看怎么预防和处理。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集群部署：通过集群来提升缓存的可用性，可以利用Redis本身的Redis Cluster或者第三方集群方案如Codis等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多级缓存：设置多级缓存，第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;均匀过期：为了避免大量的缓存在同一时间过期，可以把不同的 key 过期时间随机生成，避免过期时间太过集中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;热点数据永不过期。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务熔断：当缓存服务器宕机或超时响应时，为了防止整个系统出现雪崩，暂时停止业务服务访问缓存系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务降级：当出现大量缓存失效，而且处在高并发高负荷的情况下，在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.能说说布隆过滤器吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;布隆过滤器，它是一个连续的数据结构，每个存储位存储都是一个&lt;code&gt;bit&lt;/code&gt;，即&lt;code&gt;0&lt;/code&gt;或者&lt;code&gt;1&lt;/code&gt;, 来标识数据是否存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储数据的时时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2522202486678508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatz5MOSAkILiafhFxSQbzcM7p2mj8Ozib2wSGHcblEuoH6GkCbQPGLnDDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;我们判断缓存key是否存在，同样，K个哈希函数，映射到bit列表上的K个点，判断是不是1：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果全不是1，那么key不存在；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果都是1，也只是表示key可能存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;布隆过滤器也有一些缺点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;它在判断元素是否在集合中时是有一定错误几率，因为哈希算法有一定的碰撞的概率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持删除元素。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.如何保证缓存和数据库数据的⼀致性？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据CAP理论，在保证可用性和分区容错性的前提下，无法保证一致性，所以缓存和数据库的绝对一致是不可能实现的，只能尽可能保存缓存和数据库的最终一致性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;选择合适的缓存更新策略&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 删除缓存而不是更新缓存&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个线程对缓存的key进行写操作的时候，如果其它线程进来读数据库的时候，读到的就是脏数据，产生了数据不一致问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比较而言，删除缓存的速度比更新缓存的速度快很多，所用时间相对也少很多，读脏数据的概率也小很多。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4945736434108527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatVq2vLguBpsNTgqM8icBQl3Wm8Jzp5OpFgDvB8xo0B4g7LDFVJgjkVvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;645&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;先更数据，后删缓存&lt;/strong&gt;先更数据库还是先删缓存？这是一个问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新数据，耗时可能在删除缓存的百倍以上。在缓存中不存在对应的key，数据库又没有完成更新的时候，如果有线程进来读取数据，并写入到缓存，那么在更新成功之后，这个key就是一个脏数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毫无疑问，先删缓存，再更数据库，缓存中key不存在的时间的时间更长，有更大的概率会产生脏数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5501379944802208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatUn4SAD0PBGZWWOAibr7DyIic5qaU7CLV5mVE8EQo2QOKj98QlHicCrrCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;目前最流行的缓存读写策略cache-aside-pattern就是采用先更数据库，再删缓存的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓存不一致处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不是并发特别高，对缓存依赖性很强，其实一定程序的不一致是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果对一致性要求比较高，那就得想办法保证缓存和数据库中数据一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存和数据库数据不一致常见的两种原因：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6151515151515151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat6hXOfsldfK64ZpSOglmlA1Px5zUR1QVwEAIeicKfUQIWQwmibt3rHTdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;figcaption&gt;缓存一致性&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息队列保证key被删除&lt;/strong&gt;可以引入消息队列，把要删除的key或者删除失败的key丢尽消息队列，利用消息队列的重试机制，重试删除对应的key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4825511432009627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatoj63OspwzlmDafTYkKpqILjXrgXmWb1noaoTkmTABNGibpMnUFUCT8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;这种方案看起来不错，缺点是对业务代码有一定的侵入性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库订阅+消息队列保证key被删除&lt;/strong&gt;可以用一个服务（比如阿里的 canal）去监听数据库的binlog，获取需要操作的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除操作。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6075949367088608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatwDibUoWsEiaXLBRLsliaPsRmIsibNQbjEiaIQibgo3xtGVOH9DEm2F1PxtibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;这种方式降低了对业务的侵入，但其实整个系统的复杂度是提升的，适合基建完善的大厂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;延时双删防止脏数据&lt;/strong&gt;还有一种情况，是在缓存不存在的时候，写入了脏数据，这种情况在先删缓存，再更数据库的缓存更新策略下发生的比较多，解决方案是延时双删。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，就是在第一次删除缓存之后，过了一段时间之后，再次删除缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3425742574257427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat3DUJMqWzHibkd1Q06Wmje3FY2lbkRmDH6thJLiaxyyR2oQtltZOBefvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;505&quot;/&gt;&lt;figcaption&gt;延时双删&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的延时时间设置需要仔细考量和测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设置缓存过期时间兜底&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个朴素但是有用的办法，给缓存设置一个合理的过期时间，即使发生了缓存数据不一致的问题，它也不会永远不一致下去，缓存过期的时候，自然又会恢复一致。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.如何保证本地缓存和分布式缓存的一致？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:这道题面试很少问，但实际工作中很常见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常的开发中，我们常常采用两级缓存：本地缓存+分布式缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓本地缓存，就是对应服务器的内存缓存，比如Caffeine，分布式缓存基本就是采用Redis。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，本地缓存和分布式缓存怎么保持数据一致？&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1459537572254335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatHAXJxmgpqcXzCcaOE53Rh0v3ZqhddXiayLQOnica3grsJMBz8fgYp3LQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;Redis缓存，数据库发生更新，直接删除缓存的key即可，因为对于应用系统而言，它是一种中心化的缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是本地缓存，它是非中心化的，散落在分布式服务的各个节点上，没法通过客户端的请求删除本地缓存的key，所以得想办法通知集群所有节点，删除对应的本地缓存key。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7887887887887888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatwIA4gdmqlE6AiaXDXBLaWMBQdFGC7JibibOSicGRISXkMNicgF6jicFCcblw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以采用消息队列的方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;采用Redis本身的Pub/Sub机制，分布式集群的所有节点订阅删除本地缓存频道，删除Redis缓存的节点，同事发布删除本地缓存消息，订阅者们订阅到消息后，删除对应的本地key。但是Redis的发布订阅不是可靠的，不能保证一定删除成功。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入专业的消息队列，比如RocketMQ，保证消息的可靠性，但是增加了系统的复杂度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置适当的过期时间兜底，本地缓存可以设置相对短一些的过期时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.怎么处理热key？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是热Key？&lt;/strong&gt;所谓的热key，就是访问频率比较的key。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，热门新闻事件或商品，这类key通常有大流量的访问，对存储这类信息的 Redis来说，是不小的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如Redis集群部署，热key可能会造成整体流量的不均衡，个别节点出现OPS过大的情况，极端情况下热点key甚至会超过 Redis本身能够承受的OPS。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;怎么处理热key？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5923190546528804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatviapTWBpGDyRcZooWAyicciaQ1f7oXoZher5noREjZKHpNOVJ05vjjzsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;对热key的处理，最关键的是对热点key的监控，可以从这些端来监控热点key:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端
客户端其实是距离key“最近”的地方，因为Redis命令就是从客户端发出的，例如在客户端设置全局字典（key和调用次数），每次调用Redis命令时，使用这个字典进行记录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;代理端
像Twemproxy、Codis这些基于代理的Redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Redis服务端
使用monitor命令统计热点key是很多开发和运维人员首先想到，monitor命令可以监控到Redis执行的所有命令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要监控到了热key，对热key的处理就简单了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;把热key打散到不同的服务器，降低压⼒&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加⼊⼆级缓存，提前加载热key数据到内存中，如果redis宕机，⾛内存查询&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.缓存预热怎么做呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、直接写个缓存刷新页面或者接口，上线时手动操作&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、数据量不大，可以在项目启动的时候自动进行加载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、定时任务刷新缓存.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.热点key重建？问题？解决？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发的时候一般使用“缓存+过期时间”的策略，既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有两个问题如果同时出现，可能就会出现比较大的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;怎么处理呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决这个问题也不是很复杂，解决问题的要点在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;减少重建缓存的次数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据尽可能一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;较少的潜在危险。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以一般采用如下方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;互斥锁（mutex key）
这种方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;永远不过期
“永远不过期”包含两层意思：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.无底洞问题吗？如何解决？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是无底洞问题？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2010年，Facebook的Memcache节点已经达到了3000个，承载着TB级别的缓存数据。但开发和运维人员发现了一个问题，为了满足业务要求添加了大量新Memcache节点，但是发现性能不但没有好转反而下降了，当时将这 种现象称为缓存的“&lt;strong&gt;无底洞&lt;/strong&gt;”现象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么会产生这种现象呢?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来说添加节点使得Memcache集群 性能应该更强了，但事实并非如此。键值数据库由于通常采用哈希函数将 key映射到各个节点上，造成key的分布与业务无关，但是由于数据量和访问量的持续增长，造成需要添加大量节点做水平扩容，导致键值分布到更多的 节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;无底洞问题如何优化呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先分析一下无底洞问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;网络连接数变多，对节点的性能也有一定影响。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的优化思路如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;命令本身的优化，例如优化操作语句等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;减少网络通信次数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;降低接入成本，例如客户端使用长连/连接池、NIO等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Redis运维&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.Redis报内存不足怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 内存不足有这么几种处理方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可以通过命令set maxmemory动态设置内存上限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改内存淘汰策略，及时释放内存空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 Redis 集群模式，进行横向扩容。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;35.Redis的过期数据回收策略有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis主要有2种过期数据回收策略：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4332784184514003&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatYVobpiaR9w9d0zDvuUaibgXJpXz7YfdtMCbyiavDGP8X7GNvQicPTnICDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;惰性删除指的是当我们查询key的时候才对key进⾏检测，如果已经达到过期时间，则删除。显然，他有⼀个缺点就是如果这些过期的key没有被访问，那么他就⼀直⽆法被删除，⽽且⼀直占⽤内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;定期删除&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定期删除指的是Redis每隔⼀段时间对数据库做⼀次检查，删除⾥⾯的过期key。由于不可能对所有key去做轮询来删除，所以Redis会每次随机取⼀些key去做检查和删除。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;36.Redis有哪些内存溢出控制/内存淘汰策略？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略，Redis支持六种策略：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7047619047619048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iateNG0ibic9cicofOO1x5KHRYngvm3kKIGgUQyYrz3aU2m2jQhZ7YGEI1BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返 回客户端错误信息，此 时Redis只响应读操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直 到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性， 直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;allkeys-random：随机删除所有键，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-random：随机删除过期键，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果 没有，回退到noeviction策略。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;37.Redis阻塞？怎么解决？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis发生阻塞，可以从以下几个方面排查：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6198779424585876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iaty3nNrndQUQkj9mScHaGvvCUsFIS279FribibicKYCDuJlvX18KicRqialbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1147&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;API或数据结构使用不合理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常Redis执行命令速度非常快，但是不合理地使用命令，可能会导致执行速度很慢，导致阻塞，对于高并发的场景，应该尽量避免在大对象上执行算法复杂 度超过O（n）的命令。&lt;/p&gt;&lt;p&gt;对慢查询的处理分为两步：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发现慢查询：slowlog get{n}命令可以获取最近 的n条慢查询命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发现慢查询后，可以从两个方向去优化慢查询：1）修改为低算法复杂度的命令，如hgetall改为hmget等，禁用keys、sort等命 令
2）调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;CPU饱和的问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单线程的Redis处理命令时只能使用一个CPU。而CPU饱和是指Redis单核CPU使用率跑到接近100%。&lt;/p&gt;&lt;p&gt;针对这种情况，处理步骤一般如下：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前Redis并发量是否已经达到极限，可以使用统计命令redis-cli-h{ip}-p{port}--stat获取当前 Redis使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果Redis的请求几万+，那么大概就是Redis的OPS已经到了极限，应该做集群化水品扩展来分摊OPS压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果只有几百几千，那么就得排查命令和内存的使用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;持久化相关的阻塞&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于开启了持久化功能的Redis节点，需要排查是否是持久化导致的阻塞。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;fork阻塞
fork操作发生在RDB和AOF重写时，Redis主线程调用fork操作产生共享 内存的子进程，由子进程完成持久化文件重写工作。如果fork操作本身耗时过长，必然会导致主线程的阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF刷盘阻塞
当我们开启AOF持久化功能时，文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做fsync操作。当硬盘压力过大时，fsync操作需要等 待，直到写入完成。如果主线程发现距离上一次的fsync成功超过2秒，为了 数据安全性它会阻塞直到后台线程执行fsync操作完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HugePage写操作阻塞
对于开启Transparent HugePages的 操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;38.大key问题了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis使用过程中，有时候会出现大key的情况， 比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单个简单的key存储的value很大，size超过10KB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hash， set，zset，list 中存储过多的元素（以万为单位）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;大key会造成什么问题呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端耗时增加，甚至超时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对大key进行IO操作时，会严重占用带宽和CPU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;造成Redis集群中数据倾斜&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主动删除、被动删等，可能会导致阻塞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;如何找到大key?&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;bigkeys命令：使用bigkeys命令以遍历的方式分析Redis实例中的所有Key，并返回整体统计信息与每个数据类型中Top1的大Key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redis-rdb-tools：redis-rdb-tools是由Python写的用来分析Redis的rdb快照文件用的工具，它可以把rdb快照文件生成json文件或者生成报表用来分析Redis的使用详情。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;如何处理大key?&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6327913279132791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatBnjugvwtoQYFicNdF0pUzzsQxkMfgPFg62nIZHm533azQdV29YkKN7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;figcaption&gt;大key处理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;删除大key&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当Redis版本小于4.0时，避免使用阻塞式命令KEYS，而是建议通过SCAN命令执行增量迭代扫描key，然后判断进行删除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;压缩和拆分key&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当vaule是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当value是list/set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;39.Redis常见性能问题和解决方案？&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量避免在压力较大的主库上增加从库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关为：Master&amp;lt;–Slave1&amp;lt;–Slave2&amp;lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Redis应用&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;40.使用Redis 如何实现异步队列？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道redis支持很多种结构的数据，那么如何使用redis作为异步队列使用呢？一般有以下几种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;使用list作为队列，lpush生产消息，rpop消费消息&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式，消费者死循环rpop从队列中消费消息。但是这样，即使队列里没有消息，也会进行rpop，会导致Redis CPU的消耗。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31164901664145234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iataSNMfUgN3hVdMTYzZNehxNibNjRNt8tpvkw2eJ8rx15FoXHiaD258wqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;可以通过让消费者休眠的方式的方式来处理，但是这样又会又消息的延迟问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-&lt;strong&gt;使用list作为队列，lpush生产消息，brpop消费消息&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;brpop是rpop的阻塞版本，list为空的时候，它会一直阻塞，直到list中有值或者超时。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2765625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat4Qm5iaxQer0ic8khcI2Z4ZPicGp8atuE3iaiaTE6fhfraHklhDRNERluz4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式只能实现一对一的消息队列。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;使用Redis的pub/sub来进行消息的发布/订阅&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发布/订阅模式可以1：N的消息发布/订阅。发布者将消息发布到指定的频道频道（channel），订阅相应频道的客户端都能收到消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6124794745484401&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatG4UdPMChmGEgrTkgyKwTG6aS4mjPicWhy0JyaJutj76G8PRw3ic4fVKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;但是这种方式不是可靠的，它不保证订阅者一定能收到消息，也不进行消息的存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，一般的异步队列的实现还是交给专业的消息队列。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;41.Redis 如何实现延时队列?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用 zset这个结构，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 ....命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18957871396895787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatsYa7HIdh5yPtrSJjmd0k5A26ibPElMc5fwkGXiciafJ0ej7AMZ5Whwltg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;42.Redis 支持事务吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis提供了简单的事务，但它对事务ACID的支持并不完备。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; multi &lt;br/&gt;OK&lt;br/&gt;&lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; sadd user:a:follow user:b &lt;br/&gt;QUEUED &lt;br/&gt;&lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; sadd user:b:fans user:a &lt;br/&gt;QUEUED&lt;br/&gt;&lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; sismember user:a:follow user:b &lt;br/&gt;(integer) &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; exec &lt;span&gt;1&lt;/span&gt;) (integer) &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;) (integer) &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis事务的原理，是所有的指令在 exec 之前不执行，而是缓存在
服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5533980582524272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatLWiaU8ZJBaXB450OLvhricGRwPVEyHw2cib5VlEZeKWfH5TC7hBEsr8Gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;515&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为Redis执行命令是单线程的，所以这组命令顺序执行，而且不会被其它线程打断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis事务的注意点有哪些？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的点有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis 事务为什么不支持回滚？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的事务不支持回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以&lt;strong&gt;保持简单、快速的特性&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;43.Redis和Lua脚本的使用了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis的事务功能比较简单，平时的开发中，可以利用Lua脚本来增强Redis的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lua脚本能给开发人员带来这些好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这 些命令常驻在Redis内存中，实现复用的效果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Lua脚本可以将多条命令一次性打包，有效地减少网络开销。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如这一段很（烂）经（大）典（街）的秒杀系统利用lua扣减Redis库存的脚本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   -- 库存未预热&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt;) then&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;9&lt;/span&gt;;&lt;br/&gt;    end;&lt;br/&gt;    -- 秒杀商品库存存在&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt;) then&lt;br/&gt;        local stock = tonumber(redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]));&lt;br/&gt;        local num = tonumber(ARGV[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;        -- 剩余库存少于请求数量&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (stock &amp;lt; num) then&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;        end;&lt;br/&gt;        -- 扣减库存&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (stock &amp;gt;= num) then&lt;br/&gt;            redis.call(&lt;span&gt;&#x27;incrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt; - num);&lt;br/&gt;            -- 扣减成功&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        end;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    end;&lt;br/&gt;    -- 秒杀商品库存不存在&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;44.Redis的管道了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供三种将客户端多条命令打包发送给服务端执行的方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pipelining(管道) 、 Transactions(事务) 和 Lua Scripts(Lua 脚本) 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Pipelining&lt;/strong&gt;（管道）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 管道是三者之中最简单的，当客户端需要执行多条 redis 命令时，可以通过管道一次性将要执行的多条命令发送给服务端，其作用是为了降低 RTT(Round Trip Time) 对性能的影响，比如我们使用 nc 命令将两条指令发送给 redis 服务端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 服务端接收到管道发送过来的多条命令后，会一直执命令，并将命令的执行结果进行缓存，直到最后一条命令执行完成，再所有命令的执行结果一次性返回给客户端 。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6417525773195877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatHVHR3eMCJcapeDGWgcc9AVLicX6DYhdsicV8yzTTx7dxEibeYRXoLfZxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;776&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Pipelining的优势&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在性能方面， Pipelining 有下面两个优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;节省了RTT&lt;/strong&gt;：将多条命令打包一次性发送给服务端，减少了客户端与服务端之间的网络调用次数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;减少了上下文切换&lt;/strong&gt;：当客户端/服务端需要从网络中读写数据时，都会产生一次系统调用，系统调用是非常耗时的操作，其中设计到程序由用户态切换到内核态，再从内核态切换回用户态的过程。当我们执行 10 条 redis 命令的时候，就会发生 10 次用户态到内核态的上下文切换，但如果我们使用 Pipeining 将多条命令打包成一条一次性发送给服务端，就只会产生一次上下文切换。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;45.Redis实现分布式锁了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis是分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8442307692307692&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatJd1zU8fhgR0tYzX8jKCTLUHXFfibVXQLMcH7icPXSiaEyf2IAHMCMC5icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;520&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;gt; setnx lock:fighter &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;... &lt;span&gt;do&lt;/span&gt; something critical ...&lt;br/&gt;&amp;gt; del lock:fighter&lt;br/&gt;(integer) &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8694779116465864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatSGib0NvYsdo53k9rgaSctPxP32BAxGIP0cU8k9zCZzBRW8ZCaczg9XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;gt; setnx lock:fighter &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;&amp;gt; expire lock:fighter &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;... &lt;span&gt;do&lt;/span&gt; something critical ...&lt;br/&gt;&amp;gt; del lock:fighter&lt;br/&gt;(integer) &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题在Redis 2.8 版本中得到了解决，这个版本加入了 set 指令的扩展参数，使得 setnx 和expire 指令可以一起执行。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6744913928012519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat8rBRiaqASfciabUNQzSxTL0NgkhCibWpZYlE2l5LdtOC0CvJCbCM410hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set lock:fighter3 &lt;span&gt;true&lt;/span&gt; ex &lt;span&gt;5&lt;/span&gt; nx OK ... &lt;span&gt;do&lt;/span&gt; something critical ... &amp;gt; del lock:codehole&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个指令就是 setnx 和 expire 组合在一起的原子指令，这个就算是比较完善的分布式锁了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然实际的开发，没人会去自己写分布式锁的命令，因为有专业的轮子——&lt;strong&gt;Redisson&lt;/strong&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;底层结构&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一部分就比较深了，如果不是简历上写了精通Redis，应该不会怎么问。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;46.说说Redis底层数据结构？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis有&lt;strong&gt;动态字符串(sds)&lt;strong&gt;、&lt;/strong&gt;链表(list)&lt;strong&gt;、&lt;/strong&gt;字典(ht)&lt;strong&gt;、&lt;/strong&gt;跳跃表(skiplist)&lt;strong&gt;、&lt;/strong&gt;整数集合(intset)&lt;strong&gt;、&lt;/strong&gt;压缩列表(ziplist)&lt;/strong&gt; 等底层数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis并没有使用这些数据结构来直接实现键值对数据库，而是基于这些数据结构创建了一个对象系统，来表示所有的key-value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4891398783666377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iaty3Co6T9D2F9F8u3lvPK9awfficQY6QMJkCXdy5ynnLNicbic903JvaBSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1151&quot;/&gt;我们常用的数据类型和编码对应的映射关系：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6411428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatwtGpQUP0ibTpFcnK88Eib6MhnGibCG29zRveFHBV2rWNq4H3y0pTrbXEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;简单看一下底层数据结构，如果对数据结构掌握不错的话，理解这些结构应该不是特别难：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;字符串&lt;/strong&gt;：redis没有直接使⽤C语⾔传统的字符串表示，⽽是⾃⼰实现的叫做简单动态字符串SDS的抽象类型。&lt;/p&gt;&lt;p&gt;C语⾔的字符串不记录⾃身的⻓度信息，⽽SDS则保存了⻓度信息，这样将获取字符串⻓度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串⻓度时所需的内存重分配次数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6687022900763359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatia4JRrKexylvrmMmgBxtmfW9b8vudwCqofW0ZyCbDxHC0gIpAvhOZ5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;figcaption&gt;SDS&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;链表linkedlist&lt;/strong&gt;：redis链表是⼀个双向⽆环链表结构，很多发布订阅、慢查询、监视器功能都是使⽤到了链表来实现，每个链表的节点由⼀个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7344398340248963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatFHXiav6ic2hic3pEelBrjYQDFHm8rah8NcxicibgB4FZezvTEEKeJ2XIiaTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;figcaption&gt;链表linkedlist&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;字典dict&lt;/strong&gt;：⽤于保存键值对的抽象数据结构。Redis使⽤hash表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典里中的一个键值对。每个字典带有两个hash表，供平时使⽤和rehash时使⽤，hash表使⽤链地址法来解决键冲突，被分配到同⼀个索引位置的多个键值对会形成⼀个单向链表，在对hash表进⾏扩容或者缩容的时候，为了服务的可⽤性，rehash的过程不是⼀次性完成的，⽽是渐进式的。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7750730282375852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatISvoMgXfWPD0eCAKebj9cOYowEqUG7kbibBpKrqAcGOQFXfSPkMF8YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1027&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;跳跃表skiplist&lt;/strong&gt;：跳跃表是有序集合的底层实现之⼀，Redis中在实现有序集合键和集群节点的内部结构中都是⽤到了跳跃表。Redis跳跃表由zskiplist和zskiplistNode组成，zskiplist⽤于保存跳跃表信息（表头、表尾节点、⻓度等），zskiplistNode⽤于表示表跳跃节点，每个跳跃表节点的层⾼都是1-32的随机数，在同⼀个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯⼀的，节点按照分值⼤⼩排序，如果分值相同，则按照成员对象的⼤⼩排序。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5791701947502117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatBMcAYnSpKHV2FaAIK9mYozRj4458HowX7xBdDoficvSxmkS18TWvjhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1181&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;整数集合intset&lt;/strong&gt;：⽤于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3376110562685094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatqpbiajOw6VOF7hSGI0JdibWobhDlDDjDB72TFhiagDm4LfRcfia4jsaAYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1013&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;压缩列表ziplist&lt;/strong&gt;：压缩列表是为节约内存⽽开发的顺序性数据结构，它可以包含任意多个节点，每个节点可以保存⼀个字节数组或者整数值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13526119402985073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iataojicj9iaUPBUiaXv9YdGb82Hqdy9luQJRGHRp0ZVIcNgqB8vFESGiaD4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;figcaption&gt;压缩列表组成&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;47.Redis 的 SDS 和 C 中字符串相比有什么优势？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C 语言使用了一个长度为 &lt;code&gt;N+1&lt;/code&gt; 的字符数组来表示长度为 &lt;code&gt;N&lt;/code&gt; 的字符串，并且字符数组最后一个元素总是 &lt;code&gt;\0&lt;/code&gt;，这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3102362204724409&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatOpIgX29Q6yonUbHfaUEyOibzkO15NBzdEns78QZEXqZic7mcxic5Hrvaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;figcaption&gt;C语言的字符串&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;C语言的字符串可能有什么问题？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样简单的数据结构可能会造成以下一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;获取字符串长度复杂度高&lt;/strong&gt; ：因为 C 不保存数组的长度，每次都需要遍历一遍整个数组，时间复杂度为O(n)；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不能杜绝 &lt;strong&gt;缓冲区溢出/内存泄漏&lt;/strong&gt; 的问题 : C字符串不记录自身长度带来的另外一个问题是容易造成缓存区溢出（buffer overflow），例如在字符串拼接的时候，新的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C 字符串 &lt;strong&gt;只能保存文本数据&lt;/strong&gt; → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 &lt;code&gt;&#x27;\0&#x27;&lt;/code&gt; 可能会被判定为提前结束的字符串而识别不了；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Redis如何解决？优势？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35064935064935066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatywlcmpUGYkj5Ok4YG1slDmYiclH3icib4jAYV4YeEW1CXExb6u1WIkRIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;figcaption&gt;Redis sds&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说一下 Redis 如何解决的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多增加 len 表示当前字符串的长度&lt;/strong&gt;：这样就可以直接获取长度了，复杂度 O(1)；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自动扩展空间&lt;/strong&gt;：当 SDS 需要对字符串进行修改时，首先借助于 &lt;code&gt;len&lt;/code&gt; 和 &lt;code&gt;alloc&lt;/code&gt; 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的溢出情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;有效降低内存分配次数&lt;/strong&gt;：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 &lt;strong&gt;空间预分配&lt;/strong&gt; 和 &lt;strong&gt;惰性空间释放&lt;/strong&gt; 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;二进制安全&lt;/strong&gt;：C 语言字符串只能保存 &lt;code&gt;ascii&lt;/code&gt; 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;48.字典是如何实现的？Rehash 了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 &lt;strong&gt;hash&lt;/strong&gt; 结构的数据会用到字典外，整个 Redis 数据库的所有 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 也组成了一个 &lt;strong&gt;全局字典&lt;/strong&gt;，还有带过期时间的 &lt;code&gt;key&lt;/code&gt; 也是一个字典。*(存储在 RedisDb 数据结构中)*&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;字典结构是什么样的呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redis&lt;/strong&gt; 中的字典相当于 Java 中的 &lt;strong&gt;HashMap&lt;/strong&gt;，内部实现也差不多类似，采用哈希与运算计算下标位置；通过 &lt;strong&gt;&quot;数组 + 链表&quot; &lt;strong&gt;的&lt;/strong&gt;链地址法&lt;/strong&gt; 来解决哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49279050042408823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatzkdCKqvnlkGKWBx9TT0ac3ibPbscVcXQhpOpwiaxiaSWsRyicBFqMbxYnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1179&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;字典是怎么扩容的？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字典结构内部包含 &lt;strong&gt;两个 hashtable&lt;/strong&gt;，通常情况下只有一个哈希表 ht[0] 有值，在扩容的时候，把ht[0]里的值rehash到ht[1]，然后进行 &lt;strong&gt;渐进式rehash&lt;/strong&gt; ——所谓渐进式rehash，指的是这个rehash的动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待搬迁结束后，h[1]就取代h[0]存储字典的元素。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;49.跳跃表是如何实现的？原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:跳跃表是比较常问的一种结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40730837789661317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatPW2uUWSicojBwsGibNqmFCxlYZkick9fJzaS5dYLH4E2Cs2libia1Vic9Efg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么使用跳跃表?&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，因为 zset 要支持随机的插入和删除，所以它 &lt;strong&gt;不宜使用数组来实现&lt;/strong&gt;，关于排序问题，我们也很容易就想到 &lt;strong&gt;红黑树/ 平衡树&lt;/strong&gt; 这样的树形结构，为什么 Redis 不使用这样一些结构呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能考虑：&lt;/strong&gt; 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实现考虑：&lt;/strong&gt; 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上的一些考虑，Redis 基于 &lt;strong&gt;William Pugh&lt;/strong&gt; 的论文做出一些改进后采用了 &lt;strong&gt;跳跃表&lt;/strong&gt; 这样的结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质是解决查找问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;跳跃表是怎么实现的？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跳跃表的节点里有这些元素：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;层&lt;/strong&gt;跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量月多，访问其它节点的速度就越快。&lt;/p&gt;&lt;p&gt;每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;前进指针&lt;/strong&gt;每个层都有一个指向表尾的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。&lt;/p&gt;&lt;p&gt;我们看一下跳跃表从表头到表尾，遍历所有节点的路径：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4013961605584642&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat3Z2Px2GFaDGlKx02ntjveqKbFnzv9IvzP4QTIm3xEiaCHzmRIf45B1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1146&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;跨度&lt;/strong&gt;层的跨度用于记录两个节点之间的距离。跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。&lt;/p&gt;&lt;p&gt;例如查找，分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38864241348713396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatQM1HXaIAhcGwyxsjxBRamIT8JooKYrwj91oOZYJUKnVYG8n6yh0RGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1127&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;分值和成员&lt;/strong&gt;节点的分值（score属性）是一个double类型的浮点数，跳跃表中所有的节点都按分值从小到大来排序。&lt;/p&gt;&lt;p&gt;节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存这一个SDS值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;50.压缩列表了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;压缩列表是 Redis &lt;strong&gt;为了节约内存&lt;/strong&gt; 而使用的一种数据结构，是由一系列特殊编码的连续内存快组成的顺序型数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08933454876937101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iatsMx7rRMDIvLYJstYdia2Pyk1MDib0DT7nEW7rPU7RLzwQnEAa7EHHg4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1097&quot;/&gt;压缩列表由这么几部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;zlbyttes&lt;/strong&gt;:记录整个压缩列表占用的内存字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;zltail&lt;/strong&gt;:记录压缩列表表尾节点距离压缩列表的起始地址有多少字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;zllen&lt;/strong&gt;:记录压缩列表包含的节点数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;entryX&lt;/strong&gt;:列表节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;zlend&lt;/strong&gt;:用于标记压缩列表的末端&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18209876543209877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iat1s7ZPQUpuLuuibvdibPdNNZ5uel2cAR6F7ocYrKzWEWKicQmjiaEzyNHsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;figcaption&gt;压缩列表示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;51.快速列表 quicklist 了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但考虑到链表的附加空间相对较高，&lt;code&gt;prev&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 指针就要占去 &lt;code&gt;16&lt;/code&gt; 个字节（64 位操作系统占用 &lt;code&gt;8&lt;/code&gt; 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 &lt;code&gt;quicklist&lt;/code&gt; 代替了 &lt;code&gt;ziplist&lt;/code&gt; 和 &lt;code&gt;linkedlist&lt;/code&gt;，quicklist是综合考虑了时间效率与空间效率引入的新型数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;quicklist由list和ziplist结合而成，它是一个由ziplist充当节点的双向链表。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5865671641791045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWf5IyvQkjc4vibibgKwWma1iaticzSicZ6us2RWa52icIPTPicKDgbibXZvTD7cjvJpOCqXTtibP878hPem0Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1340&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他问题&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;52.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;keys&lt;/code&gt; 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 &lt;code&gt;scan&lt;/code&gt; 指令，&lt;code&gt;scan&lt;/code&gt; 指令可以无阻塞的提取出指定模式的 &lt;code&gt;key&lt;/code&gt; 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 &lt;code&gt;keys&lt;/code&gt; 指令长。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[1].《Redis开发与实战》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[2].《Redis设计与实现》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[3].《Redis深度历险》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[4]. 艾小仙《我要进大厂》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[5].田维常《后端面试小笔记》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[6]. [美团二面：Redis与MySQL双写一致性如何保证?](https://juejin.cn/post/6964531365643550751)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[7]. [妈妈再也不担心我面试被Redis问得脸都绿了 ](https://mp.weixin.qq.com/s/vXBFscXqDcXS_VaIERplMQ)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[8]. [面试官：缓存一致性问题怎么解决?](https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[9]. [高并发场景下，到底先更新缓存还是先更新数据库？](https://mp.weixin.qq.com/s/bewlUcHL2e6fw2vDrhEDCw)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[10] .[【Redis破障之路】三：Redis单线程架构](https://fighter3.blog.csdn.net/article/details/116166827)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[11]. Redis官网&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[12]. [解决了Redis大key问题，同事们都夸他牛皮](https://www.51cto.com/article/701990.html)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[13].[Redis 分布式锁原理看这篇就够了, 循循渐进 ](https://juejin.cn/post/6897414205071163400)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[14]. 《Redis5设计与源码分析》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>37898d0bf3d4077235df43a4031bfa5a</guid>
<title>[推荐] 3000帧动画图解MySQL为什么需要binlog、redo log和undo log</title>
<link>https://toutiao.io/k/b0g4460</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;blockquote&gt;&lt;p&gt;全文建立在MySQL的存储引擎为InnoDB的基础上&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;先看一条SQL如何入库的：&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6029106029106029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5vYBnrr3ECibGJgV4kDD13Owh9cakU4W7Y8icS44A3aPrDz1Zf2rExQyQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1443&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一条很简单的更新SQL，从MySQL服务端接收到SQL到落盘，先后经过了MySQL Server层和InnoDB存储引擎。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Server层就像一个产品经理，分析客户的需求，并给出实现需求的方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;InnoDB就像一个基层程序员，实现产品经理给出的具体方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在MySQL”分析需求，实现方案“的过程中，还夹杂着内存操作和磁盘操作，以及记录各种日志。&lt;/p&gt;&lt;p&gt;他们到底有什么用处？他们之间到底怎么配合的？MySQL又为什么要分层呢？InnoDB里面的那一块Buffer Pool又是什么？&lt;/p&gt;&lt;p&gt;我们慢慢分析。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;分层结构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;MySQL为什么要分为Server层和存储引擎两层呢？&lt;/p&gt;&lt;p&gt;这个问题官方也没有给出明确的答案，但是也不难猜，简单来说就是为了“解耦”。&lt;/p&gt;&lt;p&gt;Server层和存储引擎各司其职，分工明确，用户可以根据不同的需求去使用合适的存储引擎，多好的设计，对不对？&lt;/p&gt;&lt;p&gt;后来的发展也验证了“分层设计”的优越性：&lt;/p&gt;&lt;p&gt;MySQL最初搭载的存储引擎是自研的只支持简单查询的MyISAM的前身ISAM，后来与Sleepycat合作研发了Berkeley DB引擎，支持了事务。&lt;/p&gt;&lt;p&gt;江山代有才人出，技术后浪推前浪，MySQL在持续的升级着自己的存储引擎的过程中，遇到了横空出世的InnoDB，InnoDB的功能强大让MySQL倍感压力。&lt;/p&gt;&lt;p&gt;自己的存储引擎打不过InnoDB怎么办？&lt;/p&gt;&lt;p&gt;打不过就加入！&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5peOJnaG8YA8CDo2zXONz8lC5tWznDkgmO6faE29vSa7ZwBuGVPoKgA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;MySQL选择了和InnoDB合作。正是因为MySQL存储引擎的插件化设计，两个公司合作的非常顺利，MySQL也在合作后不久就发布了正式支持nnoDB的4.0版本以及经典的4.1版本。&lt;/p&gt;&lt;p&gt;MySQL兼并天下模式也成为MySQL走向繁荣的一个重要因素。这能让MySQL长久地保持着极强竞争力。&lt;/p&gt;&lt;p&gt;时至今日，MySQL依然占据着极高数据库市场份额，仅次于王牌数据库Oracle。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3684461391801716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5dPrXNGiaATYiaG9MdBHSHKHUIddI7nKQjonSj2ic2iacWOPV5eZC5eYjtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2098&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;Buffer Pool&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在InnoDB里，有一块非常重要的结构——Buffer Pool。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30505050505050507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5T84TEicntKYoZdaiavMT15VsV3vV9HVGNrfNERDib9XytRCstWD3HQ5Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Buffer Pool是个什么东西呢？&lt;/p&gt;&lt;p&gt;Buffer Pool就是一块用于缓存MySQL磁盘数据的内存空间。&lt;/p&gt;&lt;p&gt;为什么要缓存MySQL磁盘数据呢？&lt;/p&gt;&lt;p&gt;我们通过一个例子说明，我们先假设没有Buffer Pool，user表里面只有一条记录，记录的age = 1，假设需要执行三条SQL：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事务A：update user set age = 2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务B：update user set age = 3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务C：update user set age = 4&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果没有Buffer Pool，那执行就是这样的：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41952983725135623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5nzTZDvuxfVTnt20tv6pv6XmLgLZiaaHIX9OsiaGt5QLGjVTBGLP5IBHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1659&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从图上可以看出，每次更新都需要从磁盘拿数据（1次IO），修改完了需要刷到磁盘（1次IO），也就是每次更新都需要2次磁盘IO。三次更新需要6次磁盘IO。&lt;/p&gt;&lt;p&gt;而有了Buffer Pool，执行就成了这样：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41952983725135623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5qwznMkInqrsdynPSgYCLglIUBleUDCaGoc2ibYwhDJogudIWAOZCJ6Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1659&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从图上可以看出，只需要在第一次执行的时候将数据从磁盘拿到Buffer Pool（1次IO），第三次执行完将数据刷回磁盘（1次IO），整个过程只需要2次磁盘IO，比没有Buffer Pool节省了4次磁盘IO的时间。&lt;/p&gt;&lt;p&gt;当然，Buffer Pool真正的运转流程没有这么简单，具体实现细节和优化技巧还有很多，由于篇幅有限，本文不做详细描述。&lt;/p&gt;&lt;p&gt;我想表达的是：Buffer Pool就是将磁盘IO转换成了内存操作，节省了时间，提高了效率。&lt;/p&gt;&lt;p&gt;Buffer Pool是提高了效率没错，但是出现了一个问题，Buffer Pool是基于内存的，而只要一断电，内存里面的数据就会全部丢失。&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果断电的时候Buffer Pool的数据还没来得及刷到磁盘，那么这些数据不&lt;/span&gt;就&lt;span&gt;丢失了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;还是上面的那个例子，如果三个事务执行完毕，在age = 4还没有刷到磁盘的时候，突然断电，数据就全部丢掉了：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41952983725135623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5mJGnXS3KficmXdmTwfBqAhvUVLia7xpsiblEWl7vickNf1xxMdqkPYbwMA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1659&quot;/&gt;&lt;/figure&gt;&lt;p&gt;试想一下，如果这些丢失的数据是核心的用户交易数据，那用户能接受吗？&lt;/p&gt;&lt;p&gt;答案是否定的。&lt;/p&gt;&lt;p&gt;那InnoDB是如何做到数据不会丢失的呢？&lt;/p&gt;&lt;p&gt;今天的第一个日志——redo log登场了。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;恢复 - redo log&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;顾名思义，redo是重做的意思，redo log就是重做日志的意思。&lt;/p&gt;&lt;p&gt;redo log是如何保证数据不会丢失的呢？&lt;/p&gt;&lt;p&gt;就是在修改之后，先将修改后的值记录到磁盘上的redo log中，就算突然断电了，Buffer Pool中的数据全部丢失了，来电的时候也可以根据redo log恢复Buffer Pool，这样既利用到了Buffer Pool的内存高效性，也保证了数据不会丢失。&lt;/p&gt;&lt;p&gt;我们通过一个例子说明，我们先假设没有Buffer Pool，user表里面只有一条记录，记录的age = 1，假设需要执行一条SQL：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事务A：update user set age = 2&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;执行过程如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38396624472573837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5KslibP5KBnZYqoBY6CSyWSyRewzl77zcJuZ0GVSUhicOicSlfWrCqBEFA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1659&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图，有了redo log之后，将age修改成2之后，马上将age = 2写到redo log里面，如果这个时候突然断电内存数据丢失，在来电的时候，可以将redo log里面的数据读出来恢复数据，用这样的方式保证了数据不会丢失。&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能会问，redo log文件也在磁盘上，数据文件也在磁盘上，都是磁盘操作，何必多&lt;/span&gt;此&lt;span&gt;一举？&lt;/span&gt;&lt;span&gt;为什么不直接将修改的数据写到数据文件里面去呢？&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5pyBCEyFEmhK8jzx1YN0tZVa9IEXLIUjPPVHf0N74cR2KppBfOrXoAA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;傻瓜，因为redo log是磁盘顺序写，数据刷盘是磁盘随机写，磁盘的顺序写比随机写高效的多啊。&lt;/p&gt;&lt;p&gt;这种先预写日志后面再将数据刷盘的机制，有一个高大上的专业名词——WAL（Write-ahead logging），翻译成中文就是预写式日志。&lt;/p&gt;&lt;p&gt;虽然磁盘顺序写已经很高效了，但是和内存操作还是有一定的差距。&lt;/p&gt;&lt;p&gt;那么，有没有办法进一步优化一下呢？&lt;/p&gt;&lt;p&gt;答案是可以。那就是给redo log也加一个内存buffer，也就是redo log buffer，用这种套娃式的方法进一步提高效率。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5465587044534413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5WDqqxpEpfgTrbfYy7VKP6LQBb1wv4ZJqkZxRrKXAfaMRLcSm4WsZsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/figure&gt;&lt;p&gt;redo log buffer具体是怎么配合刷盘呢？&lt;/p&gt;&lt;p&gt;在&lt;span&gt;回答这个问题之前之前，我们先来捋一下MySQL服务端和操作系统的关系：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;MySQL服务端是一个进程，它运行于操作系统之上。也就是说，操作系统挂了MySQL一定挂了，但是MySQL挂了操作系统不一定挂。&lt;/p&gt;&lt;p&gt;所以MySQL挂了有两种情况：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MySQL挂了，操作系统也挂了，也就是常说的服务器宕机了。这种情况Buffer Pool里面的数据会全部丢失，操作系统的os cache里面的数据也会丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MySQL挂了，操作系统没有挂。这种情况Buffer Pool里面的数据会全部丢失，操作系统的os cache里面的数据不会丢失。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;OK，了解了MySQL服务端和操作系统的关系之后，再来看redo log的落盘机制。redo log的刷盘机制由参数innodb_flush_log_at_trx_commit控制，这个参数有3个值可以设置：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;innodb_flush_log_at_trx_commit = 1：实时写，实时刷&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;innodb_flush_log_at_trx_commit = 0：延迟写，延迟刷&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;innodb_flush_log_at_trx_commit = 2：实时写，延迟刷&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;写可以理解成写到操作系统的缓存（os cache），刷可以理解成把操作系统里面的缓存刷到磁盘。&lt;/p&gt;&lt;p&gt;这三种策略的区别，我们分开讨论：&lt;/p&gt;&lt;h3&gt;&lt;span&gt;innodb_flush_log_at_trx_commit = 1：实时写，实时刷&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这种策略会在每次事务提交之前，每次都会将数据从redo log刷到磁盘中去，理论上只要磁盘不出问题，数据就不会丢失。&lt;/p&gt;&lt;p&gt;总结来说，这种策略效率最低，但是丢数据风险也最低。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;234&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40538033395176254&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5n0EucPx61F7LGtsQFbO2yzUjKxZF3SNtOfaiasjlEZrmwQdGZjlIqYQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1078&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;innodb_flush_log_at_trx_commit = 0：延迟写，延迟刷&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这种策略在事务提交时，只会把数据写到redo log buffer中，然后让后台线程定时去将redo log buffer里面的数据刷到磁盘。&lt;/p&gt;&lt;p&gt;这种策略是最高效的，但是我们都知道，定时任务是有间隙的，但是如果事务提交后，后台线程没来得及将redo log刷到磁盘，这个时候不管是MySQL进程挂了还是操作系统挂了，这一部分数据都会丢失。&lt;/p&gt;&lt;p&gt;总结来说这种策略效率最高，丢数据的风险也最高。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40520896426408237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ59QvpbwvIf7WdEnWJx3zBiaeV0OJOSr9ucibf7JhiapxbBJLHq6Q9xCAhg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1651&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;innodb_flush_log_at_trx_commit = 2：实时写，延迟刷&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这种策略在事务提交之前会把redo log写到os cache中，但并不会实时地将redo log刷到磁盘，而是会每秒执行一次刷新磁盘操作。&lt;/p&gt;&lt;p&gt;这种情况下如果MySQL进程挂了，操作系统没挂的话，操作系统还是会将os cache刷到磁盘，数据不会丢失，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4043343653250774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ50MEiaYTeYH9S9WNyVrooZnYcyBQD5Zq87mjlRANKsAqZutf25Zp3Guw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1615&quot;/&gt;&lt;/figure&gt;&lt;p&gt;但如果MySQL所在的服务器挂掉了，也就是操作系统都挂了，那么os cache也会被清空，数据还是会丢失。如下图：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4094087730451367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5pam8k3dhEVCmz5mrcIQMiamkm4Zj5siagxcVtNLOS4ZSeBrP1xuIMHicA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1573&quot;/&gt;&lt;/figure&gt;&lt;p&gt;所以，这种redo log刷盘策略是上面两种策略的折中策略，效率比较高，丢失数据的风险比较低，绝大多情况下都推荐这种策略。&lt;/p&gt;&lt;p&gt;总结一下，redo log的作用是用于恢复数据，写redo log的过程是磁盘顺序写，有三种刷盘策略，有innodb_flush_log_at_trx_commit 参数控制，推荐设置成2。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;回滚 - undo log&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们都知道，InnoDB是支持事务的，而事务是可以回滚的。&lt;/p&gt;&lt;p&gt;假如一个事务将age=1修改成了age=2，在事务还没有提交的时候，后台线程已经将age=2刷入了磁盘。这个时候，不管是内存还是磁盘上，age都变成了2，如果事务要回滚，找不到修改之前的age=1，无法回滚了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4215328467153285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5qqicIWWjXR82P772LkA6zbTRx9s1lAEYoBmyicA32ibagvCU5icibNY6PDA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1644&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那怎么办呢？&lt;/p&gt;&lt;p&gt;很简单，把修改之前的age=1存起来，回滚的时候根据存起来的age=1回滚就行了。&lt;/p&gt;&lt;p&gt;MySQL确实是这么干的！这个记录修改之前的数据的过程，叫做记录undo log。undo翻译成中文是撤销、回滚的意思，undo log的主要作用也就是回滚数据。&lt;/p&gt;&lt;p&gt;如何回滚呢？看下面这个图：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43523002421307505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ5kSwP8QCpMtcjHxkGuiaelYNdWBlKmPsjc9sCAkLnwicILxEj2BcWJniaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1652&quot;/&gt;&lt;/figure&gt;&lt;p&gt;MySQL在将age = 1修改成age = 2之前，先将age = 1存到undo log里面去，这样需要回滚的时候，可以将undo log里面的age = 1读出来回滚。&lt;/p&gt;&lt;p&gt;需要注意的是，undo log默认存在全局表空间里面，你可以简单的理解成undo log也是记录在一个MySQL的表里面，插入一条undo log和插入一条普通数据是类似。也就是说，写undo log的过程中同样也是要写入redo log的。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;归档 - binlog&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;undo log记录的是修改之前的数据，提供回滚的能力。&lt;/p&gt;&lt;p&gt;redo log记录的是修改之后的数据，提供了崩溃恢复的能力。&lt;/p&gt;&lt;p&gt;那binlog是干什么的呢？&lt;/p&gt;&lt;p&gt;binlog记录的是修改之后的数据，用于归档。&lt;/p&gt;&lt;p&gt;和redo log日志类似，binlog也有着自己的刷盘策略，通过sync_binlog参数控制：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;sync_binlog = 0 ：每次提交事务前将binlog写入os cache，由操作系统控制什么时候刷到磁盘&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync_binlog =1 ：采用同步写磁盘的方式来写binlog，不使用os cache来写binlog&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync_binlog = N ：当每进行n次事务提交之后，调用一次fsync将os cache中的binlog强制刷到磁盘&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么问题来了，binlog和redo log都是记录的修改之后的值，这两者有什么区别呢？有redo log为什么还需要binlog呢？&lt;/p&gt;&lt;p&gt;首先看两者的一些区别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;binlog是逻辑日志，记录的是对哪一个表的哪一行做了什么修改；redo log是物理日志，记录的是对哪个数据页中的哪个记录做了什么修改，如果你还不了解数据页，你可以理解成对磁盘上的哪个数据做了修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;binlog是追加写；redo log是循环写，日志文件有固定大小，会覆盖之前的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;binlog是Server层的日志；redo log是InnoDB的日志。如果不使用InnoDB引擎，是没有redo log的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但说实话，我觉得这些区别并不是redo log不能取代binlog的原因，MySQL官方完全可以调整redo log让他兼并binlog的能力，但他没有这么做，为什么呢？&lt;/p&gt;&lt;p&gt;我认为不用redo log取代binlog最大的原因是“没必要”。&lt;/p&gt;&lt;p&gt;为什么这么说呢？&lt;/p&gt;&lt;p&gt;第一点，binlog的生态已经建立起来。MySQL高可用主要就是依赖binlog复制，还有很多公司的数据分析系统和数据处理系统，也都是依赖的binlog。取代binlog去改变一个生态费力了不讨好。&lt;/p&gt;&lt;p&gt;第二点，binlog并不是MySQL的瓶颈，花时间在没有瓶颈的地方没必要。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Buffer Pool是MySQL进程管理的一块内存空间，有减少磁盘IO次数的作用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redo log是InnoDB存储引擎的一种日志，主要作用是崩溃恢复，有三种刷盘策略，有innodb_flush_log_at_trx_commit 参数控制，推荐设置成2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;undo log是InnoDB存储引擎的一种日志，主要作用是回滚。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;binlog是MySQL Server层的一种日志，主要作用是归档。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MySQL挂了有两种情况：操作系统挂了MySQL进程跟着挂了；操作系统没挂，但是MySQL进程挂了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;最后，再用一张图总结一下全文的知识点：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5697841726618705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PVxtibbvVya2bEvr5pCsZk4zVuicqKCBZ56ib68QaiaFNXPOmiamJKekEtG1EK2DwJsVofQLVgSnZibAbIicGiaBZ5Belw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2780&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这篇文章写在一年之前，本来觉得是一篇水文没想要发，最近无聊修改了一下发了出来，希望能够用动图的形式帮助到MySQL基础不太好的朋友，大神忽略就好。&lt;/p&gt;&lt;p&gt;需要强调的一点是，由于作者水平有限，本文只是浅显的从无到有地阐述了MySQL几种日志的大致作用，过程中省略了很多细节，比如Buffer Pool的实现细节，比如undo log和MVCC的关系，比如binlog buffer、change buffer的存在，比如redo log的两阶段提交。&lt;/p&gt;&lt;p&gt;如果您有任何问题，我们可以探讨，如果您在文中发现错误，还望您指出，万分感谢！&lt;/p&gt;&lt;h2&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;《MySQL实战45讲》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《从根儿上理解MySQL》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《MySQL技术内幕—InnoDB存储引擎》第2版&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.08658008658008658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/TNUwKhV0JpTGQqtlGfEHkjibtshlaDwVKzjqq2pnpmYC14bKxDtSuhpWZWfVcicj5PFsoSMzuzicKIWZbsBpGXiaicg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;462&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2247499136_1&quot; data-recommend-article-time=&quot;1655523000&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/SHN22OeaUN82JdYKQ1ckc8nkc2icXUJShVr6gKMOXo5wicVLTcjibvHfFcA1KaS7MINgjffzwD2E3zEXSSicEsuwtQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Logback 配置文件这样优化，TPS提高 10 倍&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTcwMjk2OA==&amp;amp;mid=2247499136&amp;amp;idx=1&amp;amp;sn=e4547a54feff1756cc2ea20ee5409c18&amp;amp;chksm=e94835d7de3fbcc1e77ed37ff8cda59f58ba07fcd2668070c2b45e4970c8e1df7c0053b076c5#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTcwMjk2OA==&amp;amp;mid=2247499136&amp;amp;idx=1&amp;amp;sn=e4547a54feff1756cc2ea20ee5409c18&amp;amp;chksm=e94835d7de3fbcc1e77ed37ff8cda59f58ba07fcd2668070c2b45e4970c8e1df7c0053b076c5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;4&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SHN22OeaUN82JdYKQ1ckc8nkc2icXUJShVr6gKMOXo5wicVLTcjibvHfFcA1KaS7MINgjffzwD2E3zEXSSicEsuwtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;627&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;Logback 配置文件这样优化，TPS提高 10 倍&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2247499086_1&quot; data-recommend-article-time=&quot;1655350200&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/SHN22OeaUNibZmw7apXI7B0EZB44P4IRYib2jdCmTUMb0SezJsj4pWGadPjiat40Z4fsbjvnw7nibhSicnh6BlXicHQA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;看完这妹纸的日更作业，网友直呼：中国计算机界的神！&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTcwMjk2OA==&amp;amp;mid=2247499086&amp;amp;idx=1&amp;amp;sn=a604baa854c1496e02c88e59280788f1&amp;amp;chksm=e9483519de3fbc0f9db0a912c92a6424849b0818ea80c2b1d5a61cee0817a8a3cfa9f8d640ac#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTcwMjk2OA==&amp;amp;mid=2247499086&amp;amp;idx=1&amp;amp;sn=a604baa854c1496e02c88e59280788f1&amp;amp;chksm=e9483519de3fbc0f9db0a912c92a6424849b0818ea80c2b1d5a61cee0817a8a3cfa9f8d640ac&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;4&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SHN22OeaUNibZmw7apXI7B0EZB44P4IRYib2jdCmTUMb0SezJsj4pWGadPjiat40Z4fsbjvnw7nibhSicnh6BlXicHQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;481&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;看完这妹纸的日更作业，网友直呼：中国计算机界的神！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2247499030_1&quot; data-recommend-article-time=&quot;1655177400&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/SHN22OeaUN98R86Dfdrb58F04LJzaHL5SV9rurMmPZshC2ic92PKfwBtia1KuRvDDuhqXMibgvGybaA5JtgEL0rdQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;最新 955 不加班的公司名单&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTcwMjk2OA==&amp;amp;mid=2247499030&amp;amp;idx=1&amp;amp;sn=fdadbbb33c9e34726af338868314aa71&amp;amp;chksm=e9483541de3fbc57cb7953b3215892fea23c27d7138fe61a3e2f95be1779bf7578105e3320b4#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NTcwMjk2OA==&amp;amp;mid=2247499030&amp;amp;idx=1&amp;amp;sn=fdadbbb33c9e34726af338868314aa71&amp;amp;chksm=e9483541de3fbc57cb7953b3215892fea23c27d7138fe61a3e2f95be1779bf7578105e3320b4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;4&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.9987849331713244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SHN22OeaUN98R86Dfdrb58F04LJzaHL5SV9rurMmPZshC2ic92PKfwBtia1KuRvDDuhqXMibgvGybaA5JtgEL0rdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;823&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;最新 955 不加班的公司名单&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;END&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;添加下方面试现场小编微信&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;备注：面试交流 即可进群&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;316&quot; data-ratio=&quot;0.5703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SHN22OeaUN9fH6Ct6NMmF74YkHgbCPYCBmm94Oaccf1LxdibFVDg5j784RxugAHrCkIFS2f2thaSLgUA48PmT4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;↓喜欢「程序员面试现场」识别下方二维码↓&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;关注我们吧！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/c7KaH7odaU7ECIZmW23V9CNicM60zuH0nzRTibaqVuUlLCtibBFH6AHOeDVAtWsscQISjRIYficMe0cW80hhXUZIrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;「点赞」是认可★&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;「在看」是支持&lt;span&gt;★&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>