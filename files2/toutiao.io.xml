<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2d557bd0f6428b716e62c0fd62f07a4c</guid>
<title>突破 Web 应用研发效能的叹息之墙</title>
<link>https://toutiao.io/k/ymuky90</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;这篇文章可以看做是&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66474056&quot; class=&quot;internal&quot;&gt;《长夜未央——企业级研发提效的下一阶段》&lt;/a&gt;的后续。相比两年前只是架构思路和局部的技术积累，随着&lt;a href=&quot;https://zhuanlan.zhihu.com/p/264954202&quot; class=&quot;internal&quot;&gt;240 计划&lt;/a&gt; 的推进，我对架构中关键部分做了更详尽可执行的设计。并且以上线一个真实社区类产品为目标，完成了”最小化“的实现。&lt;/p&gt;&lt;p&gt;同时这一两年我还做了一些质量、项目管理相关的工作，这些经验给了我更全面的视角去看待”技术架构如何结合团队职能等方面的改进来进一步突破 web 研发中的效能瓶颈“这一问题。&lt;/p&gt;&lt;p&gt;这篇文章的内容分成两个部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对架构的关键部分的详细设计以及实现&lt;/li&gt;&lt;li&gt;架构对对工程质量、项目管理产生的意义&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;希望能为读者提供一些启发。&lt;/p&gt;&lt;h2&gt;第一部分 关键部分的详细设计以及实现&lt;/h2&gt;&lt;p&gt;先回顾《长夜未央》中最后设计的架构图作为讨论的基础：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a83657d97547156606c4eb369d46e32c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2859&quot; data-rawheight=&quot;1551&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-a83657d97547156606c4eb369d46e32c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2859&quot; data-rawheight=&quot;1551&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-a83657d97547156606c4eb369d46e32c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a83657d97547156606c4eb369d46e32c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在下面的内容中我们都将使用”功能描述“来代替”业务DSL“一词。这是考虑到狭义的 DSL 应该包含语法解析等要素，而我们的业务功能描述可以不只是 DSL，也可以是编程语言实现的一种数据结构，所以用功能描述会更准确。&lt;/p&gt;&lt;h3&gt;功能描述方式的设计&lt;/h3&gt;&lt;p&gt;正如文末的一条评论中所说。对“创造业务逻辑描述，与实现分离”的尝试几十年前就开始了，主要难点还是”如何创造出足够好的描述方式”。&lt;/p&gt;&lt;p&gt;240 计划中我的角色为这个问题创造了一个极好的思考切入点。从”功能描述“到”实现“，这是个不断具象的过程，创造好的描述方式就是在中间找到一个平衡点。在 240 中，一方面我既是 这种描述方式 的使用者，我希望它认知成本和使用成本足够低，能让我来快速创造或者长期迭代，能让我快速教会他人，能迅速看懂并复用他人的逻辑，实现大规模协作。另一方面我又是它的实现者，要考虑认知和使用成本的每一点降低可能都意味实施成本数量级级别的增高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7f09a07ad224c3a0470c75b7fd6d7d1b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1424&quot; data-rawheight=&quot;780&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-7f09a07ad224c3a0470c75b7fd6d7d1b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1424&quot; data-rawheight=&quot;780&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-7f09a07ad224c3a0470c75b7fd6d7d1b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-7f09a07ad224c3a0470c75b7fd6d7d1b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了保障创造出的功能描述方式认知复杂度足够低，我定了这样一个指标：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;应该能在 1 小时内教会没有任何产品设计经验，但能理解并使用互联网产品的用户来使用。&lt;/li&gt;&lt;li&gt;当需要描述更复杂的需求，他知道学习什么能让他描述好。&lt;/li&gt;&lt;li&gt;他知道他能描述的边界，知道在何时需要工程师介入。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;同时，不断具象的过程意味着不断引入概念。在执行过程中，始终保持着优先引入“符合产品设计直觉”的概念。最终我得到的方案如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 以产品设计认为的互联网产品能提供的“能力”来将功能分类，在每个分类下提供符合认知的原子操作。这是功能描述的基础单位。&lt;/li&gt;&lt;li&gt; 主要以“推演”的方式（描述过程的方式）来描述功能，引入推演必须的概念：事件、参与用户等，引入“分支”、“循环”、”并行“等基本的过程控制结构。&lt;/li&gt;&lt;li&gt; 如果有“规则”或者“规律”，那就用它（通常是声明式的描述）来描述功能。这很可能需要工程师帮助设计数据结构和提供可视化的编辑器。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更具体一点。&lt;/p&gt;&lt;p&gt;一、什么是设计师认为的互联网产品能提供的能力？可从三个大类来看：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;认为计算机能提供的能力：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;数据存取。例如保存文件、保存数据。&lt;/li&gt;&lt;li&gt;计算。例如“转换图片格式”。&lt;/li&gt;&lt;li&gt;自动化。例如自动抓取网页。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;认为网络提供的能力：&lt;/li&gt;&lt;li&gt;已经形成了的其他功能概念：&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;二、什么是以推演的方式描述功能？&lt;/p&gt;&lt;p&gt;互联网产品的功能绝大部分都可以描述成“事件”+“系统如何响应”的方式。结合上一中所提供的“原子能力”，一个“建立好友关系”的功能可描述成：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6327fd432e0da942e96aeb4d871738b0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1048&quot; data-rawheight=&quot;1206&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6327fd432e0da942e96aeb4d871738b0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1048&quot; data-rawheight=&quot;1206&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6327fd432e0da942e96aeb4d871738b0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6327fd432e0da942e96aeb4d871738b0_b.jpg&quot;/&gt;&lt;figcaption&gt;（圆角图形表示事件，矩形表示系统响应）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;三、什么是用“规则”或者“规律”描述功能？&lt;/p&gt;&lt;p&gt;当响应的过程已经是一种共识，并且功能的重点并不是响应过程时，规则或者规律就出来了。例如发布文章、发布评论的功能，我们发现系统的响应都是“增删改查”，于是可以通过只描述实体属性等要素，让系统自动生成相应的响应过程。&lt;/p&gt;&lt;p&gt;这个结论看似“平平无奇”，甚至不优雅：它不正交——例如”通信“的能力也可以用”数据存取“来实现；不”唯一“——有的功能既可以用推演也可以规律来表达；不“完美”——没有提出任何范式来保障完备。&lt;b&gt;但却是我认为这些年得到的最有价值的结论&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;得到这个结论的过程经过了不断切换角色的思考。其中既有工程师关于实现成本的研究，也有过去设计产品的经验，还有对实际用户测试反馈的参考。&lt;b&gt;它的目标不是，也不应该是完美，而应该是“还原需求本来的样子，符合产品设计的直觉”。&lt;/b&gt;接受这一点，才能真正看到它能带来的重大影响。&lt;/p&gt;&lt;p&gt;希望读者保持耐心，我会在第二部分详细说明。下面我们先来看最小化实现，产生更具体的印象之后再讨论影响会更容易一些。概览如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-827ca008e21eed4225687bdc2eb056af_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1926&quot; data-rawheight=&quot;1034&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-827ca008e21eed4225687bdc2eb056af_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1926&quot; data-rawheight=&quot;1034&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-827ca008e21eed4225687bdc2eb056af_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-827ca008e21eed4225687bdc2eb056af_b.jpg&quot;/&gt;&lt;figcaption&gt;(蓝色表示的是用户输入)&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;对整体的说明：没有创造新的 DSL 语言，而是对其中适合声明表达的地方设计了数据结构和编辑器。没有做前端的可视化搭建类的工作，而是创造了前端框架和组件库用来解决一些关键的领域问题。&lt;/p&gt;&lt;p&gt;对每一种功能描述设计的目标都是：同时从产品设计和工程师的角度出发，探寻产品设计中能表达的极限。产品设计能表达得越多，其能独立创造的价值越大。同时也意味着工程师做的”翻译工作“越好，整体效能提升越大。&lt;/p&gt;&lt;p&gt;在这一章节的最后会说明这个最小化实现如何渐进变成完整的架构，先看其中的重要部分的设计和实现：&lt;/p&gt;&lt;h3&gt;数据存取能力&lt;/h3&gt;&lt;p&gt;互联网产品的大部分功能都可以用数据存取来描述，其设计和实现都是整个架构中最重要的。为了探索产品设计师在描述存取功能时能表达的极限，我们要先搞清楚数据存取的需求是如何变复杂的。&lt;/p&gt;&lt;p&gt;把数据相关的应用逻辑看做是很多次存取操作的集合的话，有两个变复杂方向：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从局部看，数据之间逻辑关系越来越多。例如，人的“已婚属性”和他的”配偶“属性是有内部联系的，”已婚“甚至可以表达成&quot;有没有配偶&quot;。&lt;/li&gt;&lt;li&gt;从整体看，领域的动作会越来越复杂，一个动作可能有很多存取操作。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们注意到，越是模拟现实，也越复杂，因为需要引用现实中的逻辑关系和动作。而越是虚拟的应用，例如任务管理系统等，产品经理的对存取功能的描述几乎与实现别无二致。&lt;/p&gt;&lt;p&gt;那复杂到什么程度是极限，需要工程师介入呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;结论是多复杂都不需要！&lt;/b&gt;这个结论并不奇怪，领域的复杂逻辑本来就应该由产品设计者来负责，设计者都不能完全掌握领域逻辑，如何设计产品？并且实际上，处理复杂业务逻辑的一些常见工具，如决策树、驱动表都不需要具体的编程知识，复杂度也并不高，应该是产品设计基本素质中必须掌握的思维工具。&lt;/p&gt;&lt;p&gt;那是不是我们提供了足够的表达能力后，产品设计者就能完全自己来写数据存取相关的逻辑，自己实现“领域模型”了呢？我们应该再反过头来结合工程师的经验，看看还有哪些工作是需要工程师做的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 提供更多的存取能力和相应表达方式。例如“查询某人几度内的朋友”，需要用到图关系查询。&lt;/li&gt;&lt;li&gt; 因为性能要求，而不得不与具体实现强结合在一起的逻辑。例如现在流行的“热榜”功能，热度需要随时间下降，我们不可能做到读取时实时计算。因此需要用到缓存计算结果，需要综合性能和体验考虑何时触发计算。这时真实实现就与过程式的描述偏差得比较大了。&lt;/li&gt;&lt;li&gt; 互联网产品可能会用到一些互联网相关的领域知识，这时需要工程师作为领域专家参与。例如“需要查询某个 URL 相同子域下的所有页面”，关于子域、路径等信息就是需要工程师提供的领域知识，对存储的数据结构也有相应的要求。 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;综合以上的考虑，我得到的方案是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;以 ER 为主要抽象，辅助以表等其他简单抽象。对 ER 提供了可视化的编辑能力。产品设计中的 ER 区别于工程中的 ER，实体是指有明确生存周期，需要管理的概念，属性则不是。&lt;/li&gt;&lt;li&gt;对于复杂的数据间关系，提供了&lt;b&gt;计算属性&lt;/b&gt;作为一种逻辑载体，此外具有一定领域知识的属性可以请工程师介入提供。&lt;/li&gt;&lt;li&gt;提供“统称”的能力，可以理解成编程中的“泛型”。通常，有混合查询才需要“统称”。例如任务管理系统中的“需求”和“缺陷”都看作是“工作项”，如果有对“工作项”的统一查询，那么我们落地到关系型数据库时可能要将共同的字段要放到同一张表。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d708ec3fec7d9bc27236542d40d2f2f8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3854&quot; data-rawheight=&quot;2574&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d708ec3fec7d9bc27236542d40d2f2f8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3854&quot; data-rawheight=&quot;2574&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d708ec3fec7d9bc27236542d40d2f2f8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d708ec3fec7d9bc27236542d40d2f2f8_b.jpg&quot;/&gt;&lt;figcaption&gt;ER 图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在进行实现之前考察了大部分流行的 ORM 类型工具，没有找到符合要求的，存在的主要问题是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ER 能力不完整。Relation 上也是可能存在数据，很多工具没有支持。&lt;/li&gt;&lt;li&gt; 不支持自己扩展属性。&lt;/li&gt;&lt;li&gt; 表结构优化达不到要求。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;要保证产品能达到线上质量，这些问题都必须克服。最终我的实现方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;存储仍然落到了关系型数据库上。&lt;/li&gt;&lt;li&gt;将“复杂属性”模板化了，通过实现接口就能为产品设计提供新的属性，以及属性相关的方法。&lt;/li&gt;&lt;li&gt;自动根据 ER 等信息提供增删改查的接口，同时会汇聚复杂属性所提供出来的接口。例如前面例子中所说的“查询 URL 子路径的 xxx”。这样使用了 URL 作为属性类型的实体就都能被这样查询到。&lt;/li&gt;&lt;li&gt;数据库的优化策略写成了代码。根据 ER 数据中所提供的“消费信息”来自动决定是否应用。例如我们将一个字段标记为“lazy”，意味着它可能是大字段，可以延迟读，那么会自动被拆出来。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82362154d126c1e417887a1abe33c0d7_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2894&quot; data-rawheight=&quot;1012&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-82362154d126c1e417887a1abe33c0d7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2894&quot; data-rawheight=&quot;1012&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-82362154d126c1e417887a1abe33c0d7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-82362154d126c1e417887a1abe33c0d7_b.jpg&quot;/&gt;&lt;figcaption&gt;代码扩展复杂属性&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;目前表结构优化实现了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;1: 1 关系合表&lt;/li&gt;&lt;li&gt;字段上标记 unique：拆表出去，将属性用 id 替代值。&lt;/li&gt;&lt;li&gt;字段上标记 lazy：大字段、可延迟加载的字段拆出去。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在实现中，从 ER 到真实的建表过程中的每一步都产生了中间数据结构，利用这个中间数据可以快速实现中间件机制。也可以用来调试、查看。特别是在真实场景中，最终线上数据库变更都是需要管控的，有了这些中间数据结构，就可以方便地从 table 变更追溯优化策略甚至追溯到 ER 变更。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aeeda2e5baa8678e124381e19b0cf29c_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3854&quot; data-rawheight=&quot;2574&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-aeeda2e5baa8678e124381e19b0cf29c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3854&quot; data-rawheight=&quot;2574&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-aeeda2e5baa8678e124381e19b0cf29c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-aeeda2e5baa8678e124381e19b0cf29c_b.jpg&quot;/&gt;&lt;figcaption&gt;查看表生成的中间数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;推演描述设计（事件 &amp;amp; 响应）&lt;/h3&gt;&lt;p&gt;决定以推演来作为主要的功能描述的背后，是对”什么是最好的功能描述方式“这个问题的探索。注意，它并不是这个问题答案。为了回答这个问题我花了很多时间去回顾设计模式、编程范式、逻辑形式等等相关主题的历史和发展。&lt;/p&gt;&lt;p&gt;最后完整的结论是：&lt;/p&gt;&lt;p&gt;推演并不是”最好“的，而是最常见的，几乎没有认知成本的，因为人类的绝大部非思考都是基于推演。并且用它一定可以描述出想要的功能，因为我们对于功能是否满足需求的”第一判断“就是基于”我怎样输入，系统应该怎样输出”。这就是事件和响应。&lt;/p&gt;&lt;p&gt;那为什么不能说是”最好“的？因为也有的功能描述中响应过程不重要，重要的是规则和规律。例如做个做个公式计算器，输入输出过程极其简单，逻辑的主要部分是其中的公式。&lt;/p&gt;&lt;p&gt;另外，从对范式的深入中也可以看到，不同范式的意义其实在于”从哪个角度去管理逻辑最合适“。如何定义”合适“？即”&lt;b&gt;对逻辑中最复杂、最易变的部分是否形成了有效的管理&lt;/b&gt;”。例如 FBP 是从”数据会被谁处理，处理的顺序是怎样的“这个角度去管理所有逻辑的，所以对于资金账单类的业务逻辑极其合适，因为这类系统通常是有固定的流水处理过程。&lt;/p&gt;&lt;p&gt;再进一步，如何定性定量地去评判是否对逻辑的复杂部分有效管理了？管理，最终是人脑去管理，人觉得易读易写易修改，就是有效管理。继续探知人的认知会得到结论：&lt;b&gt;人善于线性思考，思考中切换上下文的成本极高，甚至上下文的“出入栈”成本也很高，此外思考中的上下文记忆容量很有限&lt;/b&gt;。因此当复杂的东西是非线性的时候，最好使用图等工具辅助推演。&lt;/p&gt;&lt;p&gt;根据这些结论，我们才得到了以 “推演” 和 “规律规则” 描述共同存在的结论。&lt;/p&gt;&lt;p&gt;再进一步看对于如何表达推演的设计。首先根据复杂度我们将描述可以分成三个等级：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;单次事件 &amp;amp; 响应的描述。例如用户触发存文章的事件，系统响应存入，功能描述就结束了。&lt;/li&gt;&lt;li&gt;跨事件的描述。通常可能有多用户参与，例如好友申请，需要审批的内容发布等。&lt;/li&gt;&lt;li&gt;将跨事件的描述看做一次会话，那么更复杂还有跨多次会话的描述，可以无限嵌套下去。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实际上除了最低等级的可以直接用线性的代码描述外，往上都适合用图等结构描述。以前面最简单的交友示例来看，复杂程度还远不止画出来这个样子，其中还有分支，例如用户取消了申请，用户ID被注销了等等。现在流行的 web 框架以 controller 作为调用的入口，基本都只适合处理等级一的逻辑，当要处理更复杂的情况的时候就会发现：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;流程的代码散落在各个 controller 方法里面。&lt;/li&gt;&lt;li&gt;片段代码往往要自己加载流程中的上下文，进行各种意外情况检测。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;再加上事件的触发往往来自于界面，要联系到用户的触发行为来理解整个流程会更加难。如果没有正确的文档指引，从代码角度来维护逻辑的难度会急遽上升。而关于文档的有效性和写文档的意愿，又回到了前面的问题。如果框架、工具能直接提供等级一以上的逻辑表达能力，那么研发效率和可维护性又能上一个新的台阶。&lt;/p&gt;&lt;p&gt;在最小化实现中作了一个流程图工具，参考了 UML 活动图，flow language 等。具备并串行、分支等能力。框架可以根据这个数据结构会自动为每个响应的代码片段注入上下文，进行各种边间情况检测。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-215ac74db93869ae8e4b89595d656b8d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1330&quot; data-rawheight=&quot;1019&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-215ac74db93869ae8e4b89595d656b8d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1330&quot; data-rawheight=&quot;1019&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-215ac74db93869ae8e4b89595d656b8d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-215ac74db93869ae8e4b89595d656b8d_b.jpg&quot;/&gt;&lt;figcaption&gt;流程编辑器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在响应逻辑中要提供“应用当前状态”、“历史事件栈”、用户等必备元素保障一定可以完备的描述出功能。&lt;/p&gt;&lt;p&gt;什么是“&lt;b&gt;应用当前状态&lt;/b&gt;”，实际上数据库等持久化存储里的所有数据就是整个应用的状态。&lt;/p&gt;&lt;p&gt;什么是“&lt;b&gt;历史事件栈&lt;/b&gt;”，为什么提供？整个应用里之前发生过的“事件”总和就是历史事件栈。举个需要用到历史事件栈的例子：在好友申请的功能中，我们可能会设置“对同一用户的申请，如果被拒绝过三次，那么就不能再申请”的规则。在这个描述里就需要查询“过去是否发生过被拒绝”的事件。在一般的实现中，我们可能会手动再创建一个“针对某用户被拒绝过的次数”的状态，然后在“好友申请”的事件回调里判断，如果拒绝了就手动“+1”。虽然这样写也可以实现功能，但语义又发生了一些偏离。同时使得工程可维护性又下降了一些。&lt;/p&gt;&lt;p&gt;在实际的质量工作经验中看到，当逻辑里有太多这样的“历史状态”时，我们需要在每个影响它的事件中都正确维护它。同时，一个事件可能会影响很多历史状态，这会使得一个事件响应的代码越来越臃肿，并且代码间的逻辑关联变得越来越小。而在消费这些状态的地方，我们得到的只有一个状态名字，当缺少正确的注释和文档时，想去通过“操作”这些状态的代码处去推断它的意思，就会变得极为困难。&lt;/p&gt;&lt;p&gt;如果框架本身就能提供对“历史事件栈”的查询，那么会极大地提升逻辑的清晰程度和和维护性。&lt;/p&gt;&lt;p&gt;但记录所有事件会有性能负担。在实现中我们可以通过简单的语义分析，去“自动决定”需要记录哪些事件，同时可以进一步提供一些常见操作（例如 COUNT）作为标记，来判断是否要进行“合并”等优化来提升性能。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 根据语义分析得到需要记录的事件为 event.refuse，需要记录的数据是 COUNT 后的总数，那么可优化为每次发生时 +1即可。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;refusedTimes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;defineState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;refuse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;sourceId&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;targetId&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]})&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;refusedTimes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sourceId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;targetId&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后关于推演描述还有两个有意思的设计：&lt;/p&gt;&lt;p&gt;一是我们可以将过程描述本身也当成一种可以使用的数据结构，这样做可以使逻辑复用发生巨大的变化。我们在复用时看到的将不再是一个简单的过程（函数）的名字，而是能看到具体流程（复杂的机构可以用图），甚至能够动态的去覆写、扩展而无需提供者手动支持。这对于不管是使用者还是提供者都能降低很多负担。但具体的实现就需要“基于非行列式字符编辑器的 IDE“的支持了，这也是在 240 中提到的原因。&lt;/p&gt;&lt;p&gt;第二个是应用中的”事件“不只是来自于界面上的用户行为，应该还包括”应用中的任何变化”。我们在描述逻辑时也常常会用到“当 XXX 数据更新时，就 YYY”这样的描述，本质上这是一种归纳逻辑。如果我们严格限制应用中的任何变化都需要使用封装好的 api，那么就可以把 api 的触发来当做事件使用。针对调用时传入的不同参数，也可以提供一定机制来将其命名成业务语义更强的事件。这使得不用再手动维护一个事件总线，也彻底解决了业务事件爆炸的问题。&lt;/p&gt;&lt;p&gt;目前的最小化实现中，我已经完成了基于 api 调用的事件机制。也完成了提供逻辑控制的编辑器，用来产出复杂程度 1 以上的逻辑数据结构。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-14668745e55ff9f4356721c645905930_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;685&quot; data-rawheight=&quot;453&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-14668745e55ff9f4356721c645905930_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;685&quot; data-rawheight=&quot;453&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-14668745e55ff9f4356721c645905930_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-14668745e55ff9f4356721c645905930_b.jpg&quot;/&gt;&lt;figcaption&gt;基于 api 的事件响应&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;视图层&lt;/h3&gt;&lt;p&gt;对视图层的设计和实现分成两部分：&lt;/p&gt;&lt;p&gt;一是写了个轻量的框架，直接将原子 api 和有动作语义的 api 暴露到前端。传统的 MVC 框架一般将 http 请求映射到 controller，再由controller去调用 model/service，前端通过 ajax 来发出调用请求。很多时候发现 controller 只是转发了调用到 model 而已，像权限验证之类的工作基本上也都是中间件了。再探索一下会发现 controller 实际上只在两类情况下有意义：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;因为安全需要不允许使用原子操作&lt;/li&gt;&lt;li&gt;一个过程中有多次原子调用，前后调用间有数据依赖，全部放到前端会出现中间大量中间数据进行网络传输，产生性能问题。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但这两类情况，我们都可以结合前端编译工具的能力将相应的调用从前端代码中剥离出来，生成服务端的 api，将前端调用重新替换为对生成的 api的调用即可。在我一个人同时负责前后逻辑的开发中，这个小小的设计极大地改善了开发体验。&lt;/p&gt;&lt;p&gt;二是写了个前端框架（Axii）、以及组件库等周边设施。主要是为了解决以下几个问题：&lt;/p&gt;&lt;p&gt;一、绝大部分应用中为了体验的一致性也好、为了减少研发工作也好，都需要复用。现有的框架对“复用”的实现支持得还不够。对组件的提供者来说，被复用的场景越多，组件可能越臃肿越难维护，即使是使用允许外部扩展的机制，也会慢慢发现几乎所有的地方都可能外部需要扩展或者覆写。对使用者来说，组件提供相应的功能和扩展机制就只能等着开发者更新。因为现在的前端即使同样的框架，不同的组件开发者往往也有不同的打包工具，要自己修改源码去得到想要的成本太高。&lt;/p&gt;&lt;p&gt;二、仍然存在大量的视觉还原等耗时工作。业界从视觉稿生成前端的工具远没达到好用的程度。&lt;/p&gt;&lt;p&gt;三、组件的状态和应用的状态需要由框架提供统一的解决方案。这样才有可能构建构建更好的调试、测试工具。&lt;/p&gt;&lt;p&gt;为了解决这些问题，和流行的框架相比，Axii 的主要特点如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;reactive data + jsx + function 的写法来开发组件。没有 template，但实现了精确更新来提供更好的性能。相比 template，function 更灵活、认知负担更小。&lt;/li&gt;&lt;li&gt;组件自动支持受控、非受控两种模式，自动支持回调、回调内阻止默认行为。不需要开发者单独处理这些逻辑。&lt;/li&gt;&lt;li&gt;可通过 feature based 的方式开发组件，可实现动态扩展或者覆写组件，使用成本低。对开发者来说通过框架就能获得极大的可扩展性，维护成本更低。&lt;/li&gt;&lt;li&gt;全新的样式系统。拆分 layout 和 非layout 样式，可快速得到页面骨架。将 design pattern 代码化，不必再逐个属性地还原视觉，可以通过 pattern 计算得到。样式逻辑可与代码交互逻辑分离。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了框架本身外，我也完善了周边设施：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//ariesate.github.io/axii-component-site/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;组件库&lt;/a&gt;。覆盖了常见的原子组件。&lt;/li&gt;&lt;li&gt;Axii-x6。x6 的 Axii 版本，前文中的 ER 图和流程图使用。&lt;/li&gt;&lt;li&gt;Axii-mdx。mdx 的 Axii 支持，Axii 官网使用。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多的能力不在此赘述，参见 Axii 官方网站: &lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=http%3A//axii.js.org/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot;LinkCard old LinkCard--noImage&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;Axii&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;axii.js.org&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;未来或许HUI有一篇文章单独讨论前端的领域问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe008c4e8d6a1fe6e14e8b6c286db48c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;1032&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe008c4e8d6a1fe6e14e8b6c286db48c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;1032&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fe008c4e8d6a1fe6e14e8b6c286db48c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fe008c4e8d6a1fe6e14e8b6c286db48c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;渐进推进的产物&lt;/h3&gt;&lt;p&gt;正如前面的 ER 图、流程图所示，我们并不需要一开始建立完整的功能描述，也不需要发明语言，而是可以先将一部分业务逻辑用数据结构表示，独立成文件，给与特定的后缀名。然后再为其提供合适的编辑器。&lt;/p&gt;&lt;p&gt;在制作编辑器的时候进一步想到，只要将编辑器在线化，通过 openapi 和仓库链接，一个非常简单的，可以让产品设计师直接参与进来的协作平台就出来！产品设计师编辑完直接又保存成相应的数据结构提交到仓库中。配合上 CI 工具设置可以实现产品设计师自己发布。推进过程中，我们只要逐步提供更多的数据结构和编辑器便逐步完善架构。&lt;/p&gt;&lt;p&gt;这个方案的实施成本极低，在我已上线的平台中，甚至允许业务开发者自己开发编辑器，自己定义数据结构。即使一开始不提供完整的数据结构，只是将“需求文档”也管理到代码仓库中，将其中的一些简单系统变量，例如列表每页应该有多少项、默认时间是什么时候等解析出来，直接由代码使用，也能极大地减轻工程师的低价值工作，让文档活起来，从而提高系统的可维护性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ca620d2751eba05b99fc5422474271c3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2460&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ca620d2751eba05b99fc5422474271c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2460&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ca620d2751eba05b99fc5422474271c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ca620d2751eba05b99fc5422474271c3_b.jpg&quot;/&gt;&lt;figcaption&gt;可用来编辑任何格式&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e8566aafdbeaea8905d5cabacbb8911a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2460&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e8566aafdbeaea8905d5cabacbb8911a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3500&quot; data-rawheight=&quot;2460&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e8566aafdbeaea8905d5cabacbb8911a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e8566aafdbeaea8905d5cabacbb8911a_b.jpg&quot;/&gt;&lt;figcaption&gt;可以编辑图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=http%3A//myeditor.cool&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; class=&quot;LinkCard old LinkCard--noImage&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;MyEditor Cool&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;myeditor.cool&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;p&gt;同时对于运行时的代码一开始也没有必要使用“生成”的形式，直接能运行更便于前期调试和稳定框架。但等研发力量成熟之后还是应该实现”生成“运行时代码。一是我们可以继续在生成的代码上覆写来满足极限的性能等要求，二是对于”覆写“代码多少的管理可以作为一种评价”描述抽象是否契合“的指标，但需要覆写的太多时，我们就知道该要重新设计抽象了。我们不可能找到完美的抽象，所以才要主动去管理起抽象变化的过程，不能纯粹寄希望与架构师考虑的深远程度。&lt;/p&gt;&lt;h2&gt;第二部分 对工程质量、项目管理产生的意义&lt;/h2&gt;&lt;p&gt;&lt;b&gt;提升效能的最大意义并不是降低工程师的工作量，而是释放创造产品的生产力&lt;/b&gt;。这个架构的关键之处在于，以可运行的功能描述作为中间交付物，更好地分离了产品设计师和工程师的职能：&lt;/p&gt;&lt;p&gt;一方面增强了产品设计师的表达能力，使其可能在无工程世界如的情况下创造可用的产品。&lt;/p&gt;&lt;p&gt;另一方面降低了工程师翻译逻辑等的低价值任务，使其有更多去抽象总结技术能提供的能力，进一步提升可供产品表达能力。&lt;/p&gt;&lt;p&gt;这两方面会互相促进，形成飞轮。除了直观的对研发的提深，接下来我们继续看看其对质量、项目管理的重要价值。&lt;/p&gt;&lt;h3&gt;对于软件质量的价值（可维护性）&lt;/h3&gt;&lt;p&gt;在质量相关的工作中，我看到的大公司这种流水线式生产的质量核心问题是”理&lt;b&gt;解原有逻辑的成本太高&lt;/b&gt;”。在对故障的统计分析结果中看到， 90% 以上的故障都是变更时理解出错产生的。从变更时的研发流程来看原因很简单，工程师：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先要需要理解原来原来业务逻辑。可能没有文档，可能原来的业务方换人了，可能理解有误。&lt;/li&gt;&lt;li&gt;再要理解原来的实现。可能代码可读性很差，可能其中有些性能之类的隐晦考虑。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a2f14c7bdb60c0587dd5365c58dd2284_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2f14c7bdb60c0587dd5365c58dd2284_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;497&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-a2f14c7bdb60c0587dd5365c58dd2284_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a2f14c7bdb60c0587dd5365c58dd2284_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这个链路中两次理解可能出错的几率太大了，特别是对于流水线式的、可能会经常换人的研发方式。&lt;/p&gt;&lt;p&gt;文档缺失或者腐化严重是造成业务理解错误的主要原因，深入到研发过程去看为什么产品设计不好好写文档：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;很多产品设计师觉得文档是一次性的，特别是互联网的业务初期可能只是尝试，可能很快又会下线，写文档太麻烦，不如直接口述给工程师。即使写了，慢慢也发现自然语言描述不易于长期迭代。不好写，写了很快没用，所以不想写。&lt;/li&gt;&lt;li&gt;同时对工程师来说，如果文档写得不好，阅读起来反而产生更多障碍，不如口头实时交流，有问题当面问效率更高。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;很多公司都把质量管控工作的重心放在了 code review、人工的流程管控上。这些工作应该做，但解决不了核心问题。首先对于 code review 来说，现在的 web 应用研发方式中有大量的“使用框架的翻译型工作”，严格去检查都相当于自己再写了，耗时并且价值极低。应该要做的是对其中”特异的“关键设计的 design review，这应该发生在写代码之前。其次，流水线上的流程管控形同虚设，就像 code review 一样，上线时的主管审批其实很难事无巨细去检查正确性。既然不能验证正确性，还怎么管控？&lt;/p&gt;&lt;p&gt;将”可运行起来的功能描述“作为产品和工程师的中间交接物可以解决核心问题。对产品设计来说必须保持其正确性才能运行起来，对工程师来说工作回归到有价值的能力研发上，让 code review 也变得有意义起来。&lt;/p&gt;&lt;p&gt;更深一层思考会发现，这样发展对保持和促进产品设计能力也有重要意义。如果仍然长期保持交接物模糊、人工传递逻辑的状态，产品设计的能力也会慢慢腐化掉：&lt;/p&gt;&lt;p&gt;我们构建的产品终究只是思维的产物，只是为了完成特定目的，并没有客观存在的“规律”，有的只是一时的总结。随着产品越来越复杂，任何之前总结的规律都可能被打破。可怕的是，我们常认为工程师“提前考虑到了，使得发生变化时开发顺畅“是个优点，但实际上对整个系统来说是个巨大的问题。&lt;/p&gt;&lt;p&gt;一是通常情况考虑得越多，抽象越复杂。发展过程中用到了是好事。如果没有用到呢？其维护成本如何计算？特别是如果业务的变化偏离了预计，提前考虑反而成了新的负担，这如何衡量？&lt;/p&gt;&lt;p&gt;二是很多时候业务所提出的所谓”特殊情况“其实是可能是因为业务逻辑上存在漏洞或者本来就有矛盾导致的。特殊情况越多，可能出问题的可能越大。工程师的”宽容“，反而掩盖了这种隐患，实际上得到的也是错误的抽象。&lt;/p&gt;&lt;p&gt;所以功能描述、包括对未来变化的预测必须回到产品设计师的职责之内，同时有”明确可衡量&quot;的交付物作为检验的指标，才有可能综合地让研发质量上一个台阶。&lt;/p&gt;&lt;h3&gt;对于项目管理的价值&lt;/h3&gt;&lt;p&gt;项目管理是效能评估管理的基础。我在项管工作中发现，效能问题远不只是从研发速度这个角度解这么简单，特别是公司越大流水线越长，问题越复杂。&lt;/p&gt;&lt;p&gt;我们从不同角色的不同需求来分析。角色可分为三种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;顶层管理者。资源投入者，项目最终受益者。&lt;/li&gt;&lt;li&gt;过程管理者。通常是产品经理，团队规模较小时，通常顶层管理者也是过程管理者。&lt;/li&gt;&lt;li&gt;实施者。团队的产品设计师，研发工程师等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在很多传统的项目管理工具中，顶层管理者的需求其实被忽略了。我们认为他关注进度，但其实他并不关注进度，他关注的是”进度风险“。&lt;b&gt;他站在的角度是”资本投入“的角度，他需要清晰看见的是”成本“、”收益“、”风险“&lt;/b&gt;。同时我还发现越来越多的管理者需要工具承载”预期“，以帮助其不断通过”预期“和”收益“来修正自己的认知，也同时作为工具来评判自己管理团队成员的认知正确程度。更进一步，顶层管理者是期待看到”成本“和”收益“细节的，期待能通过对细节的分析调节来降低成本提高收益。但现有的大部分基于”图文任务列表“的管理工具并不能满足其需求，一般只能看到项目级别投入了多少人，花了多少时间。至于项目中有多少人是做”基础设施“的，基础设施又支撑了多少场景，产生了多少收益，目前的工具难以回答。&lt;/p&gt;&lt;p&gt;对过程管理者来，他的需求是管理真正的进度，需要向上正确汇报。但软件越复杂，越难正确描述进度，可能任务列表看起来就只有一个任务了，但却是最难的一个花费了最长的时间。同时大部分管理软件也没有将软件中的依赖关系等内在逻辑表达出来，过程管理没有依据去提前预知风险等问题。在实际工作中发现很多过程管理者逐渐沦为了人肉沟通汇总的工具。&lt;/p&gt;&lt;p&gt;最后看实施者的需求。他们需要的其实“协同工具”。来看一个典型的流水线中的流程和需要协作的角色：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-47243fbc3ed5f14f0bac57554accd644_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1645&quot; data-rawheight=&quot;763&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-47243fbc3ed5f14f0bac57554accd644_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1645&quot; data-rawheight=&quot;763&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-47243fbc3ed5f14f0bac57554accd644_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-47243fbc3ed5f14f0bac57554accd644_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在大公司经常听到这样的问题：“看起来每个人都很忙，但是忙到什么事情中去了？为什么一线说白天开会，晚上才能写代码？”其罪魁祸首就是协作中的“非研发任务”负担：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 理解产品&lt;/li&gt;&lt;li&gt; 理解团队&lt;/li&gt;&lt;li&gt; 理解迭代上下文 &lt;/li&gt;&lt;ul&gt;&lt;li&gt;迭代中为什么有的功能没做，有的做了？&lt;/li&gt;&lt;li&gt;当时为什么是这样设计的？临时方案？&lt;/li&gt;&lt;li&gt; 新的迭代修改会不会改出 bug？ &lt;/li&gt;&lt;/ul&gt;&lt;li&gt; 理解研发任务&lt;/li&gt;&lt;ul&gt;&lt;li&gt;测试提的这个 bug 是哪个页面上的？&lt;/li&gt;&lt;li&gt;这个配置的数值为什么是这样？&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;如果工程师还要并行处理多个项目，那么上述过程就还要重复 N 次，怎么还有时间写代码？&lt;/p&gt;&lt;p&gt;虽然看待问题的角度不同，但问题背后的原因其实是同一个——“&lt;b&gt;产品与实施者之间的可定性衡量的协作交付物的缺失&lt;/b&gt;”。举个例子来说明，交互设计师和前端研发同为实施者需要协作，他们之间一般是以视觉稿作为明确交付物的。有了这个交付物，我们就可以从管理者角度回答“是不是设计师出视觉稿太晚了所以导致延期？”、“这个页面的 XXX 交互改善了转化率，是谁做的？花了多长时间做的？”。&lt;/p&gt;&lt;p&gt;如果我们能将产品功能描述作为产品与研发中间的必须交付物，并以此为中心建立管理体系，那么项目管理、效能将得到重大提升。&lt;/p&gt;&lt;p&gt;一是从实施中协作的角度，可以实现所有人工作就像在看一份图纸的效果，我们可以把“实施者”、“进度”、“缺陷”等等信息都全部关联到结构化的页面、功能描述上。&lt;/p&gt;&lt;p&gt;二是从进度管理的角度，可以清晰地看见关联、瓶颈，预知风险。&lt;/p&gt;&lt;p&gt;三是从顶层投资的角度，可以以产品功能描述为中心关联到产生的受益和投入的研发，真正展示出成本和收益的细节。&lt;/p&gt;&lt;p&gt;（出于工作的要求，我暂时不能展示更多的设计图来说明。或许未来会有一篇文章剔除公司的信息来进一步说明。）&lt;/p&gt;&lt;p&gt;当然，不一定是要以文中所述的“产品功能描述”作为中间交付物，只要达到“可定性衡量的交付物”即可。只不过我们架构中的“产品功能描述”可以用“是否能正确运行”作为“定性衡量的标准”，可以在研发上直接提升速度释放产品设计的生产力，这应该是最佳的选择。&lt;/p&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p&gt;这篇文章也可以看做是 240 计划研发部分的总结。回望这段经历，其中最有价值的有两个：&lt;/p&gt;&lt;p&gt;一、我即是设计者，也是实现者，既不想做低价值工作，又要考虑实现成本的这个视角。这个视角自然地就把职能不清晰、低效重复等问题放大了。其中既有需要具体技术支持解决的问题，也有需要改变研发模式的问题。有了这些实际的问题作为思考的线索，一切都清晰了起来。&lt;/p&gt;&lt;p&gt;二、从一个人研发，到思考怎么邀请他人协作、怎么管理，到结合之前带团队和做项管工作的实际经验，给了我更全面的视角去考虑最优解。&lt;b&gt;越来越多的时候感受到我们一点也不缺做好工具的能力，缺的永远是正确的方向&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;其中我也收获了很多同行者的观点，希望这篇文章能有所回赠。&lt;/p&gt;&lt;p&gt;路还长，但很有希望。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b6f62bdece816b442edc76a45c443d4f</guid>
<title>日订单量达到 100 万单后，我们做了订单中心重构</title>
<link>https://toutiao.io/k/0hjw87u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;strong&gt;&lt;span&gt;作者简介：曾任职于阿里巴巴，每日优鲜等互联网公司，任技术总监。&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近很多读者朋友留言，希望“二马”多写一些实际工作经历以及工作中遇到的问题和技术解决方案。应大家要求，本文介绍一次订单中心重构的经历。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;几年前我曾经服务过的一家电商公司，随着业务增长我们每天的订单量很快从30万单增长到了100万单，订单总量也突破了一亿。当时用的Mysql数据库。根据监控，我们的每秒最高订单量已经达到了2000笔（不包括秒杀，秒杀TPS已经上万了。秒杀我们有一套专门的解决方案，详见《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5MTIyODk1Mg==&amp;amp;mid=2247483999&amp;amp;idx=1&amp;amp;sn=8fc9b0a1f7b65b986f020c8c1807458b&amp;amp;chksm=fe337b28c944f23ea7b403875528a92a6a72a504a823cdb7b338e5dad11c5208feecfe03b010&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;秒杀系统设计～亿级用户&lt;/a&gt;》）。不过，直到此时，订单系统还是单库单表，幸好当时数据库服务器配置不错，我们的系统才能撑住这么大的压力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业务量还在快速增长，再不重构系统早晚出大事，我们花了一天时间快速制定了重构方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;重构？说这么高大上，不就是分库分表吗？的确，就是&lt;strong&gt;分库分表&lt;/strong&gt;。不过除了分库分表，还包括&lt;strong&gt;管理端的解决方案&lt;/strong&gt;，比如运营，客服和商务需要从多维度查询订单数据，分库分表后，怎么满足大家的需求？分库分表后，上线方案和&lt;strong&gt;数据&lt;/strong&gt;&lt;strong&gt;不停机迁移&lt;/strong&gt;方案都需要慎重考虑。为了保证系统稳定，还需要考虑相应的&lt;strong&gt;降级方案&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;为什么要分库分表？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数据库产生性能瓶颈：IO瓶颈或CPU瓶颈。两种瓶颈最终都会导致数据库的活跃连接数增加，进而达到数据库可承受的最大活跃连接数阈值。终会导致应用服务无连接可用，造成灾难性后果。可以先从代码&lt;span&gt;，&lt;/span&gt;sql&lt;span&gt;，&lt;/span&gt;索引几方面进行优化。如果这几方面已经没有太多优化的余地，就该考虑分库分表了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1、IO瓶颈&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;磁盘读IO瓶颈。由于热点数据太多，数据库缓存完全放不下，查询时会产生大量的磁盘IO，查询速度会比较慢，这样会导致产生大量活跃连接，最终可能会发展成无连接可用的后果。可以采用一主多从，读写分离的方案，用多个从库分摊查询流量。或者采用分库+水平分表（把一张表的数据拆成多张表来存放，比如订单表可以按user_id来拆分）的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种：磁盘写IO瓶颈。由于数据库写入频繁，会产生频繁的磁盘写入IO操作，频繁的磁盘IO操作导致产生大量活跃连接，最终同样会发展成无连接可用的后果。这时只能采用分库方案，用多个库来分摊写入压力。再加上水平分表的策略，分表后，单表存储的数据量会更小，插入数据时索引查找和更新的成本会更低，插入速度自然会更快。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2、CPU瓶颈&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分库分表方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分库分表主要有两种方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;利用MyCat，KingShard这种代理中间件分库分表。好处是和业务代码耦合度很低，只需做一些配置即可，接入成本低。缺点是这种代理中间件需要单独部署，所以从调用链路上又多了一层。而且分库分表逻辑完全由代理中间件管理，对于程序员完全是黑盒，一旦代理本身出问题（比如出错或宕机），会导致无法查询和存储相关业务数据，引发灾难性的后果。如果不熟悉代理中间件源码，排查问题会非常困难。曾经有公司使用MyCat，线上发生故障后，被迫修改方案，三天三夜才恢复系统。CTO也废了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;利用Sharding-Jdbc，TSharding等以Jar包形式呈现的轻量级组件分库分表。缺点是，会有一定的代码开发工作量，对业务有一些侵入性。好处是对程序员透明，程序员对分库分表逻辑的把控会更强，一旦发生故障，排查问题会比较容易。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;稳妥起见，我们选用了第二种方案，使用更轻量级的Sharding-Jdbc。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;做系统重构前，我们首先要确定重构的目标，其次要对未来业务的发展有一个预期，这个可以找相关业务负责人了解。根据目标和业务预期来确定重构方案。例如，我们希望经过本次重构，系统能支撑两年，两年内不再大改。业务方预期两年内日单量达到1000万。相当于两年后日订单量要翻10倍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据上面的数据，我们分成了16个数据库。按日订单量1000万来算，每个库平均的日订单量就是62.5万（1000万/16），每秒最高订单量理论上在1250左右（ 2000*（62.5/100） ）。这样数据库的压力基本上是可控的，而且基本不会浪费服务器资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个库分了16张表，即便按照每天1000万的订单量，两年总单量是73亿（73亿=1000万*365*2），每个库的数据量平均是4.56亿（4.56亿=73亿/16），每张表的数据量平均是2850万（2850万=4.56亿/16）。可以看到未来两到三年每张表的数据量也不算多，完全在可控范围。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分库分表主要是为了用户端下单和查询使用，按user_id的查询频率最高，其次是order_id。所以我们选择user_id做为sharding column，按user_id做hash，将相同用户的订单数据存储到同一个数据库的同一张表中。这样用户在网页或者App上查询订单时只需要路由到一张表就可以获取用户的所有订单了，这样就保证了查询性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外我们在订单ID（order_id）里掺杂了用户ID（user_id）信息。简单来说，order_id的设计思路就是，将order_id分为前后两部分，前面的部分是user_id，后面的部分是具体的订单编号，两部分组合在一起就构成了order_id。这样我们很容易从order_id解析出user_id。通过order_id查询订单时，先从order_id中解析出user_id，然后就可以根据user_id路由到具体的库表了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外，数据库分成16个，每个库分16张表还有一个好处。16是2的N次幂，所以hash值对16取模的结果与hash值和16按位“与运算”的结果是一样的。我们知道位运算基于二进制，跨过各种编译和转化直接到最底层的机器语言，效率自然远高于取模运算。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有读者可能会问，查询直接查数据库，会不会有性能问题？是的。所以我们在上层加了Redis，Redis做了分片集群，用于存储活跃用户最近50条订单。这样一来，只有少部分在Redis查不到订单的用户请求才会到数据库查询订单，这样就减小了数据库查询压力，而且每个分库还有两个从库，查询操作只走从库，进一步分摊了每个分库的压力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有读者可能会问，为什么没采用一致性hash方案？用户查询最近50条之前的订单怎么办？请继续往后看！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;管理端技术方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分库分表后，不同用户的订单数据散落在不同的库和表中，如果需要根据用户ID之外的其他条件查询订单。例如，运营同学想从后台查出某天iphone7的订单量，就需要从所有数据库的表中查出数据然后在聚合到一起。这样代码实现非常复杂，而且查询性能也会很差。所以我们需要一种更好的方案来解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们采用了ES（Elastic Search）+HBase组合的方案，将索引与数据存储隔离。可能参与条件检索的字段都会在ES中建一份索引，例如商家，商品名称，订单日期等。所有订单数据全量保存到HBase中。我们知道HBase支持海量存储，而且根据rowkey查询速度超快。而ES的多条件检索能力非常强大。可以说，这个方案把ES和HBase的优点发挥地淋漓尽致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看一下该方案的查询过程：先根据输入条件去ES相应的索引上查询符合条件的rowkey值，然后用rowkey值去HBase查询，后面这一步查询速度极快，查询时间几乎可以忽略不计。如下图： &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.789405684754522&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9iczwtGGt5GiaoZNxAqBKjqicAfjL337lVq1Cv36PY5DE7TC2OiamIV9bYr1IRdwwKE8ibMkMdnbyXIFEDw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案，解决了管理端通过各种字段条件查询订单的业务需求，同时也解决了商家端按商家ID和其他条件查询订单的需求。如果用户希望查询最近50条订单之前的历史订单，也同样可以用这个方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每天产生数百万的订单数据，如果管理后台想查到最新的订单数据，就需要频繁更新ES索引。在海量订单数据的场景下，索引频繁更新会不会对ES产生太大压力？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES索引有一个segment（片段）的概念。ES把每个索引分成若干个较小的 segment 片段。每一个 segement 都是一个完整的倒排索引，在搜索查询时会依次扫描相关索引的所有 segment。每次 refresh（刷新索引） 的时候，都会生成一个新的 segement，因此 segment 实际上记录了索引的一组变化值。由于每次索引刷新只涉及个别segement片段，更新索引的成本就很低了。所以，即便默认的索引刷新（refresh）间隔只有1秒钟，ES也能从容应对。不过，由于每个 segement 的存储和扫描都需要占用一定的内存和CPU等资源，因此ES后台进程需要不断的进行segement合并来减少 segement 的数量，从而提升扫描效率以及降低资源消耗。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Mysql中的订单数据需要实时同步到Hbase和ES中。同步方案是什么？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们利用Canal实时获取Mysql库表中的增量订单数据，然后把订单数据推到消息队列RocketMQ中，消费端获取消息后把数据写到Hbase，并在ES更新索引。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42857142857142855&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9iczibRT0Abae0FrKbPibIDicf8vt022PbtmAUNfds0vp0M49qh6IR7s1R8Yd1BEBBfxLbL8fSus4dJ4nQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;                                                &lt;span&gt;图片来源于网络&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面是Canal的原理图，&lt;/p&gt;&lt;p&gt;1，Canal模拟mysql slave的交互协议，把自己伪装成mysql的从库&lt;/p&gt;&lt;p&gt;2，向mysql master发送dump协议&lt;/p&gt;&lt;p&gt;3. mysql master收到dump协议，发送binary log给slave（Canal)&lt;/p&gt;&lt;p&gt;4. Canal解析binary log字节流对象，根据应用场景对binary log字节流做相应的处理&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了保证数据一致性，不丢失数据。我们使用了RocketMQ的事务型消息，保证消息一定能成功发送。另外，在Hbase和ES都操作成功后才做ack操作，保证消息正常消费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;不停机数据迁移&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在互联网行业，很多系统的访问量很高，即便在凌晨两三点也有一定的访问量。由于数据迁移导致服务暂停，是很难被业务方接受的！下面就聊一下在用户无感知的前提下，我们的不停机数据迁移方案！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据迁移过程我们要注意哪些关键点呢？第一，保证迁移后数据准确不丢失，即每条记录准确而且不丢失记录；第二，不影响用户体验，尤其是访问量高的C端业务需要不停机平滑迁移；第三，保证迁移后的系统性能和稳定性。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;常用的数据迁移方案主要包括：挂从库，双写以及利用数据同步工具三种方案。下面分别做一下介绍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;挂从库&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在主库上建一个从库。从库数据同步完成后，将从库升级成主库（新库），再将流量切到新库。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方式适合表结构不变，而且空闲时间段流量很低，允许停机迁移的场景。&lt;span&gt;一般发生在平台迁移的场景&lt;/span&gt;&lt;span&gt;，如从机房迁移到云平台，从一个云平台迁移到另一个云平台。&lt;/span&gt;&lt;span&gt;大&lt;/span&gt;&lt;span&gt;部分中小型互联网&lt;/span&gt;&lt;span&gt;系统，空闲时段访问量很低。&lt;/span&gt;&lt;span&gt;在空闲时段，几分钟的停机时间，对用户影响很小，业务方是可以接受的。&lt;/span&gt;&lt;span&gt;所以我们可以采用停机迁移的方案。&lt;/span&gt;&lt;span&gt;步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1，新建从库（新数据库），数据开始从主库向从库同步。&lt;/p&gt;&lt;p&gt;2，数据同步完成后，找一个空闲时间段。为了保证主从数据库数据一致，需要先停掉服务，然后再把从库升级为主库。如果访问数据库用的是域名，直接解析域名到新数据库（从库升级成的主库），如果访问数据库用的是IP，将IP改成新数据库IP。&lt;/p&gt;&lt;p&gt;3，最后启动服务，整个迁移过程完成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种迁移方案的优势是迁移成本低，迁移周期短。缺点是，切换数据库过程需要停止服务。&lt;strong&gt;我们的并发量比较高，而且又做了分库分表，表结构也变了，&lt;/strong&gt;&lt;strong&gt;所以不能采取这种方案！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;双写&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;老库和新库同时写入，然后将老数据批量迁移到新库，最后流量切换到新库并关闭老库读写。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方式适合数据结构发生变化，不允许停机迁移的场景。一般发生在系统重构时，表结构发生变化，如表结构改变或者分库分表等场景。有些大型互联网系统，平常并发量很高，即便是空闲时段也有相当的访问量。几分钟的停机时间，对用户也会有明显的影响，甚至导致一定的用户流失，这对业务方来说是无法接受的。所以我们需要考虑一种用户无感知的不停机迁移方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;聊一下我们的具体迁移方案，&lt;span&gt;步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码准备。&lt;/span&gt;&lt;span&gt;在服务层对订单&lt;span&gt;表进行增删改&lt;/span&gt;的地方，要同时操作新库（分库分表后的数据库表）和老库，需要修改相应的代码（同时写新库和老库）。&lt;/span&gt;&lt;span&gt;准备迁移程序脚本，用于做老数据迁移。&lt;/span&gt;&lt;span&gt;准备校验程序脚本，用于校验新库和老库的数据是否一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开启双写，老库和新库同时写入。&lt;/span&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;span&gt;任何对数据库的增删改都要双写；&lt;/span&gt;&lt;span&gt;对于更新操作，如果新库没有相关记录，需要先从老库查出记录，将更新后的记录写入新库；&lt;/span&gt;&lt;span&gt;为了保证写入性能，老库写完后，可以采用消息队列异步写入新库。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;利用脚本程序&lt;/span&gt;，将某一时间戳之前的老数据迁移到新库。注意：1，时间戳一定要选择开启双写后的时间点，比如开启双写后10分钟的时间点，避免部分老数据被漏掉；2，迁移过程遇到记录冲突直接忽略，因为第2步的更新操作，已经把记录拉到了新库；3，迁移过程一定要记录日志，尤其是错误日志，如果有双写失败的情况，我们可以通过日志恢复数据，以此来保证新老库的数据一致。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第3步完成后，我们还需要通过脚本程序检验数据，看新库数据是否准确以及有没有漏掉的数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据校验没问题后，开启双读，起初给新库放少部分流量，新库和老库同时读取。由于延时问题，新库和老库可能会有少量数据记录不一致的情况，所以新库读不到时需要再读一遍老库。然后再逐步将读流量切到新库，相当于灰度上线的过程。遇到问题可以及时把流量切回老库&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读流量全部切到新库后，关闭老库写入（可以在代码里加上热配置开关），只写新库&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;迁移完成，后续可以去掉双写双读相关无用代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.77109375&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I2EApibvt9iczibRT0Abae0FrKbPibIDicf8veFvraQhh7SdMVp553knVfxfYjvN2XB1LX3ehZ9EnGJcSS1q412Y0bA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;利用数据同步工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt; 我们可以看到上面双写的方案比较麻烦，很多数据库写入的地方都需要修改代码。有没有更好的方案呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;    我们还&lt;span&gt;可以利用&lt;/span&gt;&lt;span&gt;Canal，&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;Bus&lt;/span&gt;&lt;span&gt;等工具&lt;/span&gt;&lt;span&gt;做数据同步。&lt;/span&gt;&lt;span&gt;以阿里开源的Canal为例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;利用同步工具，就不需要开启双写了，&lt;span&gt;服务层&lt;/span&gt;也不需要编写双写的代码，直接用Canal做增量数据同步即可。相应的步骤就变成了：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码准备。准备Canal代码，解析binary log字节流对象，并把解析好的订单数据写入新库。&lt;/span&gt;&lt;span&gt;准备迁移程序脚本，用于做老数据迁移。&lt;/span&gt;&lt;span&gt;准备校验程序脚本，用于校验新库和老库的数据是否一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运行Canal代码，开始&lt;span&gt;增量&lt;/span&gt;数据（线上产生的新数据）从老库到新库的同步。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;利用脚本程序&lt;/span&gt;，将某一时间戳之前的老数据迁移到新库。注意：1，时间戳一定要选择开始&lt;span&gt;运行&lt;/span&gt;&lt;span&gt;Canal程序&lt;/span&gt;后的时间点（比如&lt;span&gt;运行&lt;/span&gt;&lt;span&gt;Canal代码&lt;/span&gt;后10分钟的时间点），避免部分老数据被漏掉；3，迁移过程一定要记录日志，尤其是错误日志，如果有些记录写入失败，我们可以通过日志恢复数据，以此来保证新老库的数据一致。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第3步完成后，我们还需要通过脚本程序检验数据，看新库数据是否准确以及有没有漏掉的数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据校验没问题后，开启双读，&lt;span&gt;起初给新库放少部分流量，新库和老库同时读取。&lt;/span&gt;&lt;span&gt;由于延时问题，新库和老库可能会有少量数据记录不一致的情况，所以新库读不到时需要再读一遍老库。&lt;/span&gt;&lt;span&gt;逐步将读流量切到新库，相当于灰度上线的过程。&lt;/span&gt;&lt;span&gt;遇到问题可以及时把流量切回老库&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读流量全部切到新库后，将写入流量切到新库（可以在代码里加上热配置开关。注：由于切换过程&lt;span&gt;Canal程序&lt;/span&gt;还在运行，仍然能够获取老库的数据变化并同步到新库，所以切换过程不会导致部分老库数据无法同步新库的情况）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关闭Canal程序&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;迁移完成。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;扩容缩容方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;需要对数据重新hash取模，再将原来多个库表的数据写入扩容后的库表中。整体扩容方案和上面的不停机迁移方案基本一致。采用双写或者Canal等数据同步方案都可以。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更好的分库分表方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过前面的描述，不难看出我们的分库分表方案有一些缺陷，比如采用hash取模的方式会产生数据分布不均匀的情况，扩容缩容也非常麻烦。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这些问题可以用一致性hash方案解决。基于虚拟节点设计原理的一致性hash可以让数据分布更均匀。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而且一致性hash采用环形设计思路，在增减节点时，使得数据迁移的成本会更低，只需要迁移临近节点的数据。不过需要扩容时基本上要成倍扩容，在hash环上每个节点间隙都增加新的节点，这样才能分摊所有原有节点的访问和存储压力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于篇幅原因，这里不详细介绍一致性hash了，网上有很多相关资料，大家有兴趣可以仔细研究一下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;降级方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在大促期间订单服务压力过大时，可以将同步调用改为异步消息队列方式，来减小订单服务压力并提高吞吐量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大促时某些时间点瞬间生成订单量很高。我们采取异步批量写数据库的方式，来减少数据库访问频次，进而降低数据库的写入压力。详细步骤：&lt;span&gt;后端服务接到下单请求，直接放进消息队列，订单服务取出消息后，先将订单信息写入Redis，每隔100ms或者积攒10条订单，批量写入数据库一次。前端页面下单后定时向后端拉取订单信息，获取到订单信息后跳转到支付页面。用这种异步&lt;span&gt;批量&lt;/span&gt;写入数据库的方式大幅减少了数据库写入频次，从而明显降低了订单数据库写入压力。不过，&lt;/span&gt;因为订单是异步写入数据库的，就会存在数据库订单和相应库存数据暂时不一致的情况，以及用户下单后不能及时查到订单的情况。因为毕竟是降级方案，可以适当降低用户体验，我们保证数据最终一致即可。根据系统压力情况，可以在大促开始时开启异步批量写的降级开关，大促结束后再关闭降级开关。流程如下图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6050119331742243&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9iczwtGGt5GiaoZNxAqBKjqicAfxPJiafBPnxkziczs7xfZ7wKIXYRdmwIeGFfVagEo0D4wtGrhsYRN44Qg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;原创不易，如果感觉本文对您有帮助，有劳“转发分享”或“在看”！让更多人收获知识和经验！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者简介：&lt;/span&gt;&lt;span&gt;曾任职于阿里巴巴，每日优鲜等互联网公司，任技术总监，15年电商互联网经历&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;点个在看少个 bug&lt;/span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;技术琐话 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。本号由坐馆老司机技术团队维护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;188&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;188&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWEup6pcFSoqDWX2CnKtr2ibick4zKc3GbnGwOU6OfRibTYDbP4ueZgYDVIQX96Wic9KibEX710j1jsqWicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1671625797b9eddc50beb741b57e0bc7</guid>
<title>滴滴出行平台业务架构演进</title>
<link>https://toutiao.io/k/a4op90o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBGbictVuOAcT4CPiaqY7Z3S4eKyhkndP7xMdx7l4JqNQjyGmsuSf0TUuE6G7aic8rUpiciaEEIqsoWsydg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-backw=&quot;562&quot; data-backh=&quot;90&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;562&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;562&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHwSF10sa1x9XEg93UCAt2dbJ5HS08qdSWBdXMRicjAoe9YuN4j3IEToxd0JUPE1JfZFVMFfUvkXow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot; data-style=&quot;padding: 10px; display: inline-block; width: 558px; border-width: 1px; border-style: solid; border-color: transparent; background-color: rgb(239, 239, 239); border-radius: 0px;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;p data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;桔妹导读：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;了满&lt;/span&gt;&lt;span&gt;足不&lt;/span&gt;&lt;span&gt;同用户&lt;/span&gt;&lt;span&gt;在价格&lt;/span&gt;&lt;span&gt;、体验&lt;/span&gt;&lt;span&gt;等方&lt;/span&gt;&lt;span&gt;面&lt;/span&gt;&lt;span&gt;的差异化诉求，滴滴提供了越来越丰富的品类，这些品类&lt;/span&gt;&lt;span&gt;大体流程是类&lt;/span&gt;&lt;span&gt;似&lt;/span&gt;&lt;span&gt;的，在一些细节体验上有差异，一套&lt;/span&gt;&lt;span&gt;架构如何兼顾隔离和复用，同时支持这些品类，且看滴滴&lt;/span&gt;&lt;span&gt;服务端技术的湾流平&lt;/span&gt;&lt;span&gt;台怎么&lt;/span&gt;&lt;span&gt;做。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在滴滴打车业务中，服务端API向上接收端上请求并组装返回，向下串接订单、计价、收银等业务中台的各个系统，完成整个打车流程，湾流平台项目期望在服务端API层打造一个「出行中台」。在已有业务中台的情况下，为什么还要在业务「前台」API层打造一个「出行中台」，这和出行业务的流量模式是分不开的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;1.1 &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;流量模式&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1.1.1 传统和业界常规的“锥状”流量分配模式&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;传统的典型中台架构是“大中台小前台”，造就这种架构的原因与流量分配模式相关。以电商领域为例，中台抽象了电商相关的业务实体如：订单、收银台、商品等，而不同业务线之间的流量入口是分开的，不同BU间能够以小前台的方式闭环实现。这种“大中台小前台”的架构，可以支持快速构建原型产品进行试错探索，中台提供电商标准的基础能力，前台各自闭合实现B2C、C2C等业务，而业务间互不影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;流量分配模式表现为：多业务（或品类）开放的&lt;/span&gt;&lt;strong&gt;前台流量接入&lt;/strong&gt;&lt;span&gt;，转化至统一有限的&lt;/span&gt;&lt;strong&gt;业务中台&lt;/strong&gt;&lt;span&gt;，最终落至&lt;/span&gt;&lt;strong&gt;基础平台。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.653125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32jw1CwOribumQwYX7H9G7N9bBvicdNENhDtVSibWjUzyPibIuuVScuVgkIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;1.1.2 网约车独特的“菱形”流量分配模式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;滴滴网约车业务核心是&lt;strong&gt;打车&lt;/strong&gt;，为了满足不同用户的需求（定价、应答率、体验等），通过品类区分提供差异化服务能力，从最初的出租车、专车、快车延展到了如今几十个品类。而入口始终围绕在司乘两端、开放平台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;流量分配模式表现为：多品类由&lt;strong&gt;统一的端&lt;/strong&gt;接入流量入口（&lt;strong&gt;API&lt;/strong&gt;）并完成各品类的主要业务逻辑处理，再交由&lt;strong&gt;统一的业务中台&lt;/strong&gt;，最终落至&lt;strong&gt;基础平台&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.70703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32vf2QibZjOnOI4wrp5YgoQ0FVWQGOPRcxSLwsibfb4oLicqm4e5U6YicMLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;网约车的「菱形」流量分配模式注定：服务端API一方面需要支持一些跨BU的平台级需求，如：春节服务费、疫情停开服等；另一方面也要支持不同BU间的差异化需求，如出租车使用打表计价不用线上计价等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着品类越来越丰富，这些差异逻辑也越来越多，导致系统越来越臃肿，复杂度越来越高，迭代效率下降。所以需要将服务端API通用的部分下沉，并且开放差异定制的机制，同时兼顾隔离和复用，湾流平台项目应运而生。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;1.2 服务端API职责定位&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在开始前，需要先明确服务端API的核心职责。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;核心职责&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32AtLicnXQQPj3bichXH4E7nLY9ue5pf6A0WHiat3EDYd2JAFGLM7ib7trHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;终极问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▍&lt;/span&gt;1.3 湾流平台演进&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在过去几年时间里，基于上述背景我们一直在不断探索，以下简单介绍下湾流平台项目前两个版本迭代的情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;1.3.1 湾流平台1.0（2017-2018）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;1.0阶段主要解决的是快速增加新品类和不同BU间代码隔离的问题，使用&lt;strong&gt;配置化&lt;/strong&gt;和&lt;strong&gt;插件化&lt;/strong&gt;解决。配置化主要是统一了上下游产品描述协议，形成产品描述N元组，并抽象一套通用的N元组到功能的映射规则；插件化利用插件包隔离不同BU间的代码，运行时插件选择器根据流量特征分发到对应插件包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32g0vzkSQwXNueIjMPYnl6GicmMUuYStVquMRXtnTzm7VPAbvIbYnWUrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;◎　&lt;/strong&gt;遗留问题&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置化依赖于功能抽象，需要一套统一的抽象方法&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;插件化依赖于稳固的流程，以及清晰的功能边界。按差异开放插件点会导致插件定义不明确、粒度无法把控、插入点不稳定等问题，长期维护困难。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;1.3.2 湾流平台2.0（2018）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;2.0一方面要解决1.0遗留的功能抽象、流程固化等问题，一方面还要面临复杂度越来越高的服务端api系统。为此我们借鉴了DDD的思路，开启了湾流平台2.0的改造。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.240625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32xwta8xjNt868oiazJfNOMfJkd4XIjdGzUH8ePWzOoFRtVF0wTaQaLibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;微观上，按&lt;strong&gt;流程&lt;/strong&gt;和&lt;strong&gt;功能&lt;/strong&gt;对领域服务进一步分析，进行功能聚合与抽象，即&lt;strong&gt;组件化&lt;/strong&gt;。提高&lt;strong&gt;复用性&lt;/strong&gt;，解决业务扩展性和开发效率的问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.68203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32mDgswE5KRJmDiaVZj0ycblQOkVV1HJybMX5RpO0N89PFT3EBibnnaSOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;◎　&lt;/span&gt;&lt;/strong&gt;遗留问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;未做系统性的框架约束，迭代容易破坏原有结构&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;侧重于分治和抽象，未同步考虑品类间隔离问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;em/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;/em&gt;&lt;em/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;湾流平台3.0详细方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;span&gt;▍&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;2.1 总体思路&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.58203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32Bf7ll6FZicYKbILmIqmKQs5sRlEicxicyISM6NvFP9iczcUjkWK9HVp3cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面也提到，湾流平台核心要解决隔离和复用的问题。3.0整体思路是把服务端API的业务逻辑分为两层，一层是用于串接状态流转的流程层，一层是用于完成各个垂类功能的能力组件层。流程层既包含从预估、发单到完单的宏观打车流程，也包含每个接口的执行流程。宏观的打车流程基本品类间是统一的&lt;/span&gt;&lt;span&gt;，与端的交互协议也是统一的；每个接口执行流程不同品类间由于业务形态差异，会有部分不一致。我们把接口的执行流程做环节抽象，形成一个个的step，沉淀一套接口标准通用的执行step，品类可以根据各自的差异，重载step。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;能力组件抽象聚合了一些垂直的功能，组件内部按照策略模式，根据不同的品类场景使用不同的策略完成组件行为。如播单组件，提供了延迟播单、实时播单、轮次播单等模式，专车预约采用延迟播单，这种是在播单组件中通过配置实现。如果一些有特别大的差异，比如出租车要实现一个全新的播单模式并且不具备通用性，也可以由出租车实现这个新的模式，通过插件的形式挂载进来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过这样改造之后，同时配套诞生了一些平台产品，辅助提高开发效率。如流程编排中心，可以根据不同的品类场景，对接口流程环节进行编排；特征管理平台，统一管控业务特征，保持业务描述统一；品类配置中心，从品类场景视角，配置不同能力的行为模式，快速上线新品类场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;2.2 &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;框架介绍&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了实现总体思路，我们开发了一套代码运行框架，命名为DuKang，何以解忧，唯有DuKang！依托DuKang框架，解决我们隔离和复用的难题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DuKang框架，针对每个接口，按照下图流程执行调度，涉及InputSource、Transport、TransportFactor、StepRuntime、Step、Ability等核心概念。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32jMzg6eGia0KA6ibLd5dCCGp5pDI1ovr1W3VaNqCncaT9BjSnueIKtj7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中核心的要点是，Transport作为流程承载器，提供了一个base的基础流程实现，不同品类可继承BaseTransport，然后可以针对差异的流程环节step进行重载，但整个流程是由流程驱动引擎调度，各品类保持一致。ability是能力组件，组件内部提供了一组通用的mode，不同品类场景通过配置化方式复用这些mode，同时也向业务开放了定制mode的机制，业务可以通过使用biz定制自己独有的mode，挂载到ability下，实现差异化功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务端API语言栈以php和golang为主，其中老的服务主要是用php写的，整体逐步在往golang上迁移，新服务都是直接采用的golang。Dukang框架同时支持了php和golang两个版本，下面以php版本，成单接口为例，展示dukang框架的运行过程：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//配置文件，管理流程环节，以及提供给不同品类注册各自transport&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ConfirmOrder,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;&lt;/span&gt;transports&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;&lt;/span&gt;default&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;\\DuKang\\Transport\\ConfirmOrderaseTransport&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;&lt;/span&gt;express&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;\\DuKang\\Express\\Transport\\ConfirmOrderExpressTransport&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;&lt;/span&gt;luxury&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;\\DuKang\\Luxury\\Transport\\ConfirmOrderLuxuryTransport&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;&lt;/span&gt;taxi&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;\\DuKang\\Taxi\\Transport\\ConfirmOrderTaxiTransport&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;&lt;/span&gt;steps&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: [&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;fetchInfoStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;获取基本信息&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;confirmTravelStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;确认行程信息&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;confirmBillStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;确认计价信息&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;checkStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;成单检查&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;fillOrderDetailStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;订单维度填充&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;sendOrderCommandStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;订单处理操作&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;sendDriverCommandStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;司机处理操作&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;sendSchedulingCommandStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;调度处理操作&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;buildResponseStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;构建响应&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;asyncOperationStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;异步操作&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;step_id&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;writeLogStep&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &quot;&lt;/span&gt;description&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;: &quot;&lt;/span&gt;日志处理&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// dukang框架核心执行过程&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 加载并解析接口配置，包括BizConfig、StepConfig&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__variable&quot;&gt;$oBizConf&lt;/span&gt; = BizConfig::load(&lt;span class=&quot;code-snippet__variable&quot;&gt;$sConfigStr&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 获取输入源数据，包括Request和基础数据获取&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__variable&quot;&gt;$oInputSource&lt;/span&gt; = new ConfirmOrdernputSource();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 构造StepRuntime&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__variable&quot;&gt;$oStepRuntime&lt;/span&gt; = new ConfirmOrdertepRuntime(&lt;span class=&quot;code-snippet__variable&quot;&gt;$oInputSource&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 将接口配置对象、StepRuntime放入流程调度器&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__variable&quot;&gt;$oFlowScheduler&lt;/span&gt; = new FlowScheduler(&lt;span class=&quot;code-snippet__variable&quot;&gt;$oBizConf&lt;/span&gt;, &lt;span class=&quot;code-snippet__variable&quot;&gt;$oStepRuntime&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 初始化传输器路由因子&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__variable&quot;&gt;$oTransportSelectFactor&lt;/span&gt; = new ConfirmOrderTransportSelectFactor(&lt;span class=&quot;code-snippet__variable&quot;&gt;$oInputSource&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if(&lt;span class=&quot;code-snippet__variable&quot;&gt;$oFlowScheduler&lt;/span&gt;-&amp;gt;selectTransport(&lt;span class=&quot;code-snippet__variable&quot;&gt;$oTransportSelectFactor&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 执行流程调度&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__variable&quot;&gt;$oFlowScheduler&lt;/span&gt;-&amp;gt;run();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 异常处理原则：接口外层只处理DuKangException和Exception，Step或者Ability处理异常则先处理逻辑再抛异常&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} catch (DuKangException &lt;span class=&quot;code-snippet__variable&quot;&gt;$e&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__variable&quot;&gt;$aResp&lt;/span&gt; = [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &#x27;errno&#x27;  =&amp;gt; &lt;span class=&quot;code-snippet__variable&quot;&gt;$e&lt;/span&gt;-&amp;gt;getCode(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &#x27;errmsg&#x27; =&amp;gt; &lt;span class=&quot;code-snippet__variable&quot;&gt;$e&lt;/span&gt;-&amp;gt;getMessage(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    echo json_encode(&lt;span class=&quot;code-snippet__variable&quot;&gt;$aResp&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} catch (\Exception &lt;span class=&quot;code-snippet__variable&quot;&gt;$e&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__variable&quot;&gt;$aResp&lt;/span&gt; = [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &#x27;errno&#x27;  =&amp;gt; &lt;span class=&quot;code-snippet__variable&quot;&gt;$e&lt;/span&gt;-&amp;gt;getCode(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &#x27;errmsg&#x27; =&amp;gt; &lt;span class=&quot;code-snippet__variable&quot;&gt;$e&lt;/span&gt;-&amp;gt;getMessage(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    echo json_encode(&lt;span class=&quot;code-snippet__variable&quot;&gt;$aResp&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来，再展开对dukang的一些核心概念进行讲解&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;2.2.1 Transport - 业务传输器/承载器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;约束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;2.2.2 Step - 流程环节&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;针对单接口内的业务进行抽象出来的环节载体&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单一Step是某一段业务环节或功能的具体实现&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;图例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务流程驱动型接口：以串联各个处理流程为主&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据驱动型接口：以构建业务特征数据为主&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.396875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32yJbE0h5LlAWRk9esr0Z9X8lpUAoMfpN0oICVx3ibLxGz929TKyCXS6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;2.2.3 StepRuntime - 运行时数据总线&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;约束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;图例&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.271186440677966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia322FPtc6IJaI7cicteRT3VxjGCvWuibsxXfxYTB5bc4ZDKMKUJWV8c43yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;2.2.4 InputSource - 输入源&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;约束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;图例&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32CGL2GuqoCTIxnKaLUXzVD2fGiaPm8R0QjUDWhzRgicuO383wwKyBOZBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;2.2.5 Transport Factor - 传输器因子&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;约束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;▎&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;2.2.6 Ability - 能力组件&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▏&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;2.2.6.1 概念描述&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;h4&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;◎　&lt;/span&gt;定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以特征数据为视角，对聚焦业务进行提炼和抽象，形成能力组件&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;◎　&lt;/span&gt;设计原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▏&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;2.2.6.2 业务特征&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;业务特征概念归纳&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32dLibzX84nFfCMBJKnUbVUCiciaEnNwTcRlPdkwxiaUStaGRCVWia6oicS7lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;业务特征解决的问题&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;规范业务属性或字段语义，避免歧义和未知语义&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;定义：业务 = 有序流程 * 控制(特征X, 特征Y, 特征Z, ...)， 控制 = 染色 ｜ 填充 ｜ 复写  |  合并  |  标记&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▏&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;2.2.6.3 能力组件抽取过程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;针对一组业务特征，将围绕这些业务特征的生产、修改操作聚合，形成能力组件。如围绕播单特征的播单组件、价格特征的计价组件等等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;Ability扩展性&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;支持以Addtional 的业务扩展Ability Mode，即前面提到的biz形式定制化mode，从而达到不同品类在Ability上的隔离。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;◎　&lt;/strong&gt;Ability+品类场景配置最终思路&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复用：基于品类+场景（N元组）配置化，mode selector灵活决策能力组件的执行模式&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;差异化：业务通过biz实现mode的定制，配置化动态加载&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32K6BBxjTW5SKic1b7EkEFmP3M7GvPeohqUzXAMju7rAibU8LiaiawNy6E7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;2.3 应用框架目录结构&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;php模块目录结构示例，golang模块整体类似&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;├── Dukang &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   ├── Ability &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   ├── Common &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   │   ├── DispatchOrder&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   │   │   └── DispatchOrderComponent.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   │   └── VirtualPhone&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   │       └── VirtualPhoneComponent.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   └── Express &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │       └── DispatchOrder&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │           └── DispatchOrderComponent.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   ├── Config &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   └── ConfirmOrder.json&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   ├── InputSource &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   └── ConfirmOrderInputSource.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   ├── StepRuntime &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   └── ConfirmOrderStepRuntime.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   ├── Model   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   ├── Dao&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   ├── Driver&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   │   └── DriverModel.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   └── Order&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │       └── OrderModel.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   ├── Service  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   └── Driver&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │       └── DriverService.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   ├── TransportFactor &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   │   └── ConfirmOrderTransportFactor.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│   └── Transport &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       ├── Base&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       │   └── ConfirmOrderBaseTransport.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│       └── Taxi&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│           └── ConfirmOrderTaxiTransport.php&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;└── vendor&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    └── dukang&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        └── framework&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ├── idl  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            └── src  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文作者&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;507&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;96&quot; data-ratio=&quot;0.18946188340807174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFZ1NRurs4gU8E9VtvsEia32KD4FibwSXYKrJp42d6y9iammA7DhYuEyVsxSjgUhADZ6neMubgyIic9nQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;团队招聘&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;滴滴&lt;/span&gt;&lt;span&gt;服&lt;/span&gt;&lt;span&gt;务端技术团队是滴滴网约车核心后台研发团队，负责网约车核心出行、品类技术、开放平台、业务架构与创新业务、业务中间件等公司级核心项目的研发，支持快车、专车、优步、优享、豪华车、拼车、出租车等出行业务。在这里，你将面对高并发、大流量、复杂业务的极限挑战；你将和顶级工程师一起打造分钟级接入新业务、新功能的技术实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;滴滴&lt;/span&gt;&lt;span&gt;服&lt;/span&gt;&lt;span&gt;务端技术团队长期招&lt;/span&gt;&lt;strong&gt;高级后端研发工程师&lt;/strong&gt;职位，欢迎有兴趣的小伙伴加入，可投递简历至 diditech@didiglobal.com，邮件请邮件主题请命名为「姓名-投递岗位-投递团队」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;135&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;135&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFBFcH3cDkw5qRpibVy97GUiaCUicPhRyTg6LpWp2CFHhKZSYuQnmhyZzBnnRxJ4EuWwvI3HTgqibQ7Mw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫码了解更多岗位&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247542399&amp;amp;idx=1&amp;amp;sn=452469435cc55f702ed54f1821d690d2&amp;amp;chksm=fc2948d8cb5ec1ce224ccd79d2c62d87aa0c6518e1338e0221eab78be96fa9be69e36c0997c1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;112&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBGlReEK0HYv7nsibtql6GAl061YJ0np6k3UcP67exCoHHVHad3NAtznxrhXJQrAQgD5VqcgD2fflWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247543250&amp;amp;idx=1&amp;amp;sn=bce0262b531cfb7bbf384ffd5aa6981c&amp;amp;chksm=fc294775cb5ece6376fae2f943ac888a4cab64ee690188be62c006b4763b93619808beee6734&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;112&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFC0gPjEK6eEUNya1YNwfapYYrehzfoUnPMVyMPnudCEto8ibHZdLVu9WV2qVAQPkdRHXohqicgppyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247544043&amp;amp;idx=1&amp;amp;sn=a4509a2290a0b33be68810c46c1216a5&amp;amp;chksm=fc29424ccb5ecb5ac45fe8cb335c61907b51baecbb69bf9c0c38f12efffcb519dd094687e822&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;112&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHwSF10sa1x9XEg93UCAt2dV6AtAiap7LRkqe3fiauhnN4wXpMEkDHGicMq97jzqsU9YDBUVObuVXxmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;内容编辑 | Hokka&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;联系我们 | DiDiTech@didiglobal.com&lt;/span&gt;&lt;/section&gt;&lt;pre ng-bind-html=&quot;message.MMActualContent&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;158&quot; data-backw=&quot;546&quot; data-ratio=&quot;0.28888888888888886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHCquJeOibVaFwqqC4iadSqFxSJRyP1G2V6ZB0tXzfDbHQmq5LXdiawGrVAfTs5INmjsvxOnH4dU8how/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>60b6d74a9becb493cbad28d4764ebaed</guid>
<title>方法调用：一看就懂，一问就懵？</title>
<link>https://toutiao.io/k/ewr4rul</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;181&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32344763670064874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOjRJj3rEmVIcZ4cxnPGXMbOToA3HQiafTrfmjfvOVQH0fLtCJwj3DkfC1GoPIRVmLY5oTemAhXibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法调用是不是很熟悉？那你真的了解它吗？今天就让我们来盘一下它。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.62&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpNK5NNz7Qg4DP701IxPOuxVXiazTNVPzPL7GyuKRJzhpM2ibibiaUHjZUWl9rBPIfiajlUCHrUJ1cPdMyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先大家要明确一个概念，此处的方法调用并不是方法中的代码被执行，而是要确定被调用方法的版本，即最终会调用哪一个方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5MDg2NjEzNA==&amp;amp;mid=2247484248&amp;amp;idx=1&amp;amp;sn=b15946ef29c25fb50f8b49e0d6f1f591&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt;中我们了解到，&lt;code&gt;class&lt;/code&gt;字节码文件中的方法的调用都只是符号引用，而不是直接引用（方法在实际运行时内存布局中的入口地址），要实现两者的转化，就不得不提到解析和分派了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们之前说过在类加载的解析阶段，会将一部分的符号引用转化为直接引用，该解析成立的前提是：方法在程序真正运行之前就已经有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。我们把这类方法的调用称为解析（&lt;code&gt;Resolution&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这个前提条件，有没有小伙伴联想到对象的多态性？&lt;img data-ratio=&quot;0.9395085066162571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNK5NNz7Qg4DP701IxPOuxVruaAnYPiaTjb4iacoyYMm9k7DJJbhVOZnAibfbPq9B2a3n0wAr98HBPMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;529&quot;/&gt;没错，就是这样，在&lt;code&gt;java&lt;/code&gt;中能满足不被重写的方法有静态方法、私有方法（不能被外部访问）、实例构造器和被&lt;code&gt;final&lt;/code&gt;修饰的方法，因此它们都适合在类加载阶段进行解析，另外通过&lt;code&gt;this&lt;/code&gt;或者&lt;code&gt;super&lt;/code&gt;调用的父类方法也是在类加载阶段进行解析的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;指令集&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用不同类型的方法，字节码指令集里设置了不同的指令，在&lt;code&gt;jvm&lt;/code&gt;里面提供了5条方法调用字节码指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;invokestatic&lt;/code&gt;：调用静态方法，解析阶段确定唯一方法版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;invokespecial&lt;/code&gt;：实例构造器&lt;code&gt;init&lt;/code&gt;方法、私有及父类方法，解析阶段确定唯一方法版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;invokevirtual&lt;/code&gt;：调用所有虚方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;invokeinterface&lt;/code&gt;：调用接口方法，在运行时再确定一个实现该接口的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;invokedynamic&lt;/code&gt;：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在&lt;code&gt;Java&lt;/code&gt;虚拟机内部的，而&lt;code&gt;invokedynamic&lt;/code&gt;指令的分派逻辑是由用户所设定的引导方法决定的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;invokedynamic&lt;/code&gt;指令是&lt;code&gt;Java7&lt;/code&gt;中增加的，是为实现动态类型的语言做的一种改进，但是在&lt;code&gt;java7&lt;/code&gt;中并没有直接提供生成该指令的方法，需要借助&lt;code&gt;ASM&lt;/code&gt;底层字节码工具来产生指令，直到&lt;code&gt;java8&lt;/code&gt;的&lt;code&gt;lambda&lt;/code&gt;表达式的出现，该指令才有了直接的生成方式。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「小知识点：静态类型语言与动态类型语言」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。即静态类型语言是判断变量自身的类型信息，动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「例」&lt;/strong&gt;&lt;code&gt;java&lt;/code&gt;类中定义的基本数据类型，在声明时就已经确定了他的具体类型了;而&lt;code&gt;JS&lt;/code&gt;中用&lt;code&gt;var&lt;/code&gt;来定义类型，值是什么类型就会在调用时使用什么类型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚方法与非虚方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节码指令集为&lt;code&gt;invokestatic&lt;/code&gt;、&lt;code&gt;invokespecial&lt;/code&gt;或者是用final修饰的&lt;code&gt;invokevirtual&lt;/code&gt;的方法的话，都可以在解析阶段中确定唯一的调用版本，符合这个条件的就是我们上边提到的五类方法。它们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为&lt;strong&gt;「非虚方法」&lt;/strong&gt;。与之相反，不是非虚方法的方法是&lt;strong&gt;「虚方法」&lt;/strong&gt;。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpNK5NNz7Qg4DP701IxPOuxV6vhReGtW0JpKHvia8YLqOFCx8aqonykkNm0CkL13VXmfMXNctRsZebA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;440&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分派&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在编译期间没有将方法的符号引用转化为直接引用，而是在运行期间根据方法的实际类型绑定相关的方法，我们把这种方法的调用称为分派。其中分派又分为静态分派和动态分派。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;静态分派&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你对重载了解多少？为了解释静态分派，我们先来个重载的小测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StaticDispatch&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Woman&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;(Human guy)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;hello,guy！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;(Man guy)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;hello,gentleman！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;(Woman guy)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;hello,lady！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Human man = &lt;span&gt;new&lt;/span&gt; Man();&lt;br/&gt;        Human woman = &lt;span&gt;new&lt;/span&gt; Woman();&lt;br/&gt;        StaticDispatch sr = &lt;span&gt;new&lt;/span&gt; StaticDispatch();&lt;br/&gt;        sr.sayHello(man);&lt;br/&gt;        sr.sayHello(woman);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请考虑一下输出结果，沉默两分钟。答案是&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hello,guy！&lt;br/&gt;hello,guy！&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你答对了嘛？首先我们来了解两个概念：静态类型和实际类型。拿&lt;code&gt;Human man = new Man();&lt;/code&gt;来说&lt;code&gt;Human&lt;/code&gt;称为变量的静态类型，而&lt;code&gt;Man&lt;/code&gt;我们称为变量的实际类型，区别如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;静态类型的变化仅仅在使用时才发生，变量本身的静态类型是不会被改变，并且最终静态类型在编译期是可知的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实际类型的变化是在运行期才知道，编译器在编译程序时并不知道一个对象的具体类型是什么。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处之所以执行的是&lt;code&gt;Human&lt;/code&gt;类型的方法，是因为编译器在重载时，会通过参数的&lt;strong&gt;「静态类型」&lt;/strong&gt;来作为判定执行方法的依据，而不是使用&lt;strong&gt;「实际类型」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，而是由编译器来完成。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;动态分派&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了重载之后再来了解下重写？案例走起：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DynamicDispatch&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;man say hello!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Woman&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;woman say hello!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        Human man = &lt;span&gt;new&lt;/span&gt; Man();&lt;br/&gt;        Human woman = &lt;span&gt;new&lt;/span&gt; Woman();&lt;br/&gt;        man.sayHello();&lt;br/&gt;        woman.sayHello();&lt;br/&gt;        man = &lt;span&gt;new&lt;/span&gt; Woman();&lt;br/&gt;        man.sayHello();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请考虑一下输出结果，继续沉默两分钟。答案是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;man say hello!&lt;br/&gt;woman say hello!&lt;br/&gt;woman say hello!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次相信大家的结果都对了吧？我们先来补充一个知识点：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;父类引用指向子类时，如果执行的父类方法在子类中未被重写，则调用自身的方法；如果被子类重写了，则调用子类的方法。如果要使用子类特有的属性和方法，需要向下转型。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这个结论我们反向推理一下：&lt;code&gt;man&lt;/code&gt;和&lt;code&gt;women&lt;/code&gt;是静态类型相同的变量，它们在调用相同的方法&lt;code&gt;sayHello()&lt;/code&gt;时返回了不同的结果，并且在变量&lt;code&gt;man&lt;/code&gt;的两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的&lt;strong&gt;「实际类型」&lt;/strong&gt;不同，&lt;code&gt;Java&lt;/code&gt;虚拟机是如何根据实际类型来分派方法执行版本的呢？我们看下字节码文件：&lt;img data-ratio=&quot;0.43853342918763477&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNK5NNz7Qg4DP701IxPOuxVecTAg92hwdnhryYTyUgulrmbyr8n8pSxLO43qdYZww6ovCMMIpQbjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1391&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;man.sayHello();&lt;br/&gt;woman.sayHello();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们关注的是以上两行代码，他们对应的分别是17和21行的字节码指令。单从字节码指令角度来看，它俩的指令&lt;code&gt;invokevirtual&lt;/code&gt;和常量&lt;code&gt;$Human.sayHello：（）V&lt;/code&gt;是完全一样的，但是执行的结果确是不同的，所以我们得研究下&lt;code&gt;invokevirtual&lt;/code&gt;指令了，操作流程如下：&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpNK5NNz7Qg4DP701IxPOuxVprmbMFCRahZ1GPhfVCiaMcIoaNxpvlpDzJqjEkLCHUS0QZ44Coicn1CQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;255&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回&lt;code&gt;java.lang.IllegalAccessError&lt;/code&gt;异常（假如不在一同一个jar包下就会报非法访问异常）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果始终没有找到合适的方法，则抛出&lt;code&gt;java.lang.AbstractMethodError&lt;/code&gt;异常。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;invokevirtual&lt;/code&gt;指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的&lt;code&gt;invokevirtual&lt;/code&gt;指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据接收者的实际类型来选择方法版本（案例中的实际类型为&lt;code&gt;Man&lt;/code&gt;和&lt;code&gt;Woman&lt;/code&gt;），这个过程就是&lt;code&gt;Java&lt;/code&gt;语言中方法重写的&lt;strong&gt;「本质」&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;单分派与多分派&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「举例说明」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dispatch&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;QQ&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; class_360{}&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; hardChoice（QQ arg）{&lt;br/&gt;            System.out.println（&lt;span&gt;&quot;father choose qq&quot;&lt;/span&gt;）；&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; hardChoice（_360 arg）{&lt;br/&gt;            System.out.println（&lt;span&gt;&quot;father choose 360&quot;&lt;/span&gt;）；&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; hardChoice（QQ arg）{&lt;br/&gt;            System.out.println（&lt;span&gt;&quot;son choose qq&quot;&lt;/span&gt;）；&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; hardChoice（_360 arg）{&lt;br/&gt;            System.out.println（&lt;span&gt;&quot;son choose 360&quot;&lt;/span&gt;）；&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main（String[]args）{&lt;br/&gt;        Father father=&lt;span&gt;new&lt;/span&gt; Father（）；&lt;br/&gt;        Father son=&lt;span&gt;new&lt;/span&gt; Son（）；&lt;br/&gt;        father.hardChoice（new_360（））；&lt;br/&gt;        son.hardChoice（&lt;span&gt;new&lt;/span&gt; QQ（））；&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请考虑一下输出结果，继续沉默两分钟。答案是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;father choose &lt;span&gt;360&lt;/span&gt;&lt;br/&gt;son choose qq&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：一是静态类型是&lt;code&gt;Father&lt;/code&gt;还是&lt;code&gt;Son&lt;/code&gt;，二是方法参数是&lt;code&gt;QQ&lt;/code&gt;还是&lt;code&gt;360&lt;/code&gt;。这次选择结果的最终产物是产生了两条&lt;code&gt;invokevirtual&lt;/code&gt;指令，两条指令的参数分别为常量池中指向&lt;code&gt;Father.hardChoice(360)&lt;/code&gt;及&lt;code&gt;Father.hardChoice(QQ)&lt;/code&gt;方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看看运行阶段虚拟机的选择，也就是动态分派的过程。在执行&lt;code&gt;“son.hardChoice(new QQ())”&lt;/code&gt;这句代码时，更准确地说，是在执行这句代码所对应的&lt;code&gt;invokevirtual&lt;/code&gt;指令时，由于编译期已经决定目标方法的签名必须为&lt;code&gt;hardChoice(QQ)&lt;/code&gt;，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是&lt;code&gt;Father&lt;/code&gt;还是&lt;code&gt;Son&lt;/code&gt;。因为只有一个宗量作为选择依据，所以&lt;code&gt;Java&lt;/code&gt;语言的动态分派属于单分派类型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;虚方法表&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就很可能影响到执行效率。因此，为了提高性能，&lt;code&gt;jvm&lt;/code&gt;采用在类的方法区建立一个虚方法表（&lt;code&gt;Vritual Method Table&lt;/code&gt;，也称为&lt;code&gt;vtable&lt;/code&gt;，与此对应的，在&lt;code&gt;invokeinterface&lt;/code&gt;执行时也会用到接口方法表——&lt;code&gt;Inteface Method Table&lt;/code&gt;，简称&lt;code&gt;itable&lt;/code&gt;）来实现，使用虚方法表索引来代替元数据查找以提高性能。&lt;img data-backh=&quot;499&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.895330112721417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNK5NNz7Qg4DP701IxPOuxVjY6IicXUAQGp0ntUfPZMDD1Jh3eL9m84j0d4WwsvWztIhRkcZBDt0SA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个类中都有一个虚方法表，表中存放着各种方法的实际入口:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Son&lt;/code&gt;重写了来自&lt;code&gt;Father&lt;/code&gt;的全部方法，因此&lt;code&gt;Son&lt;/code&gt;的方法表没有指向&lt;code&gt;Father&lt;/code&gt;类型数据的箭头。但是&lt;code&gt;Son&lt;/code&gt;和&lt;code&gt;Father&lt;/code&gt;都没有重写来自&lt;code&gt;Object&lt;/code&gt;的方法，所以它们的方法表中所有从&lt;code&gt;Object&lt;/code&gt;继承来的方法都指向了&lt;code&gt;Object&lt;/code&gt;的数据类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;绑定机制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。分派（&lt;code&gt;Dispatch&lt;/code&gt;）调用则可能是静态的也可能是动态的。因此我们把 &lt;strong&gt;「解析」&lt;/strong&gt; 和 &lt;strong&gt;「静态分派」&lt;/strong&gt; 这俩在编译期间就确定了被调用的方法，且在运行期间不变的调用称之为静态链接，而在运行期才确定下来调用方法的称之为动态链接。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;我们把在静态链接过程中的转换成为早期绑定，将动态链接过程中的转换称之为晚期绑定。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，方法的调用你搞懂了吗？如果你还有什么困惑的话，可以关注微信公众号“阿Q说代码”，也可以加阿Q好友qingqing-4132，阿Q期待你的到来！&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;内容推荐&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;觉得还不错？&lt;/span&gt;&lt;span&gt;记得一键四连呦👇&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f409d73191c06039c1480a9ef6d1f5aa</guid>
<title>消息队列如何确保消息的有序性？</title>
<link>https://toutiao.io/k/1b5jcg5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想实现消息有序，需要从 Producer 和 Consumer 两方面来考虑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Producer 生产消息的时候就必须要有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，Consumer 消费的时候，也要按顺序来，不能乱。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Producer 有序&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30861723446893785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92kj1oj7r0FqgF4nNvTotOBXkNDpntmWP5ibyP2mkR7G5xztgpz6TJCyxdluyyDFt5lEicUD2y3PxMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;998&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 RabbitMQ 这类普通的消息系统，队列结构简单，Producer 向队列中发送消息就完了，进入队列的消息肯定是有序的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92kj1oj7r0FqgF4nNvTotOBxaL6efibq00q2mFUOLjqbAzQzNj8bF7icac6ELpViaLRFg6rJHv9wYG6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 比较特殊，因为它的一个 Topic（就是队列的概念）实际上分为了多个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 发送消息的时候，是分散在不同 Partition 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 按顺序发消息，但进入 Kafka Topic 之后，这些消息就不一定进到哪个 Partition 了，所以顺序肯定是乱的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2950191570881226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92kj1oj7r0FqgF4nNvTotOBiagWTO1gd9QN03dQkC4Nfd5Farh3BJIvSqmGVXydlttGBQI42TyKYdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1044&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想 Topic 内的消息&lt;strong&gt;全局有序&lt;/strong&gt;，就只能设置一个 Partition 了，这就变成了 RabbitMQ 那种结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种结构不符合 Kafka 的设计理念，Topic 只有一个 Partition 就失去了扩展性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2647058823529412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92kj1oj7r0FqgF4nNvTotOBOo0tBYlfjLIqujjNxlCgLUaw3a4IYGDTGU7HJ97WliaXndwWMPVEUgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka 还支持一种&lt;strong&gt;局部有序&lt;/strong&gt;的方式，就是把某一类的消息都放入同一个 Partition，就保证了这组消息的顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发消息的时候指定 Partition Key，Kafka 对其进行 Hash 计算，根据计算结果决定放入哪个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Partition Key 一样的消息肯定是在一起的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如使用用户 ID 做 key，这样同一个用户的消息肯定是在一起的，就保证了这一组的消息的有序。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Consumer 有序&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MQ 内消息有序，那么 Consumer 自然也是按顺序接收的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果使用了多个 Consumer，就可能出现乱序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3074829931972789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92kj1oj7r0FqgF4nNvTotOBTlLru2Hdyzdugl540zqUNybjdKiapy4ic8Adm0zP6YsNcXtibg09292dA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 RabbitMQ 的一个 Queue 有 3个 Consumer，虽然会按顺序接收到消息，但是它们各自的处理速度是不同的，所以，出来的结果很可能是乱序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想严格按顺序来，就只能使用一个 Consumer。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果可以使用局部有序，那么就把之前的一个队列拆为多个队列，就像 Kafka 的 Partition Key 一样，把同组数据放入同一个队列。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30257186081694404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92kj1oj7r0FqgF4nNvTotOBrpTyOLv2cFVPRvjdibTRlEtmOibZOHNpib9yrhZbL8fWCyUkunRd2DnjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1322&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 中一个 Partition 只能对应一个 Consumer，但如果 Consumer 使用了多线程，就和多个 Consumer 一个效果了，还是会造成乱序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话就需要&lt;strong&gt;进一步细化&lt;/strong&gt;消息的分组。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35173501577287064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92kj1oj7r0FqgF4nNvTotOBaXsNRMgDBn5PxnXsnOXbuFCFyibyV858ovBXGgqHibpsSM5HNEP6J59Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1268&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为每个线程创建一个内存队列，Consumer 收到消息后，把同组的消息都放在同一个内存队列，由同一个线程处理即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;小结一下&lt;/strong&gt;，消息的有序需要 Producer 和 Consumer 都有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ 的队列结构简单，Producer 发送的消息是有序的。但 Kafka 特殊，一个 Topic 有多个 Partition，如果要求全局有序，就只能使用一个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果可以接受局部有序，就可以为消息设置 Partition Key，其 Hash 计算结果相同的消息都会在同一个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 消费时需要注意多 Consumer 的情况，例如多个消费线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在 Consumer 收到消息后再细化分组，同组的消息交给同一个消费线程处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;amp;mid=2652403576&amp;amp;idx=1&amp;amp;sn=00b6cc6110cbfc191d4efdcefd6432da&amp;amp;chksm=8bd8f19ebcaf7888b30a7491523de976154e0bcdd41df2167f10fd22c8526a392e9f7870cc75&amp;amp;token=456207156&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;OAuth2 图解&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;amp;mid=2652403396&amp;amp;idx=1&amp;amp;sn=53ac0376b271abab985de793a9a66bb0&amp;amp;chksm=8bd8f022bcaf7934051078105e66fa8f2986e4daaa067a0c6ea3668eb04b728762ba241547cc&amp;amp;token=456207156&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;轻松理解 Kubernetes 的核心概念&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;amp;mid=2652403407&amp;amp;idx=1&amp;amp;sn=69489b882cfafb77607a80e150d47b19&amp;amp;chksm=8bd8f029bcaf793fc8435b45f4bd2058200406e7a5f38665ef79acdb382feabacc8c5e5ac904&amp;amp;token=456207156&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;开发者必须要了解的架构技术趋势：Service Mesh&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>