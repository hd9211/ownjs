<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>75db89cae9b2cc3be304db50a37a854e</guid>
<title>在网页上调试手机上的APP</title>
<link>https://toutiao.io/k/b6l2ml9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;      我们工作中常用遇到这样的问题需要调试手机里的网页，而在手机里无法像chrome浏览器那样直接调试网页，特别是一些网关加了限制，都禁止抓包调试，之前常用的一种方式是需要翻墙的，不过后来翻墙也不好用了，方式如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用方式&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;p&gt;      扩展应用adb的作用是把手机上的APP页面用网页的形式在电脑上打开，开发人员便可根据自己的需求进行调试。下面介绍扩展应用adb的使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）打开谷歌浏览器的扩展应用窗口，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.687402799377916&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKK4z7PvYSTb2SNtic59ZMUJ4r9pnCpicxFueLu4ho4DJvy0xdEko8LMWgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6479250334672021&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKX3h5zSiacTKaWCHOSvVen0s4F0QbzcfVzJDoWs9qcVytZskRfXEbQEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.33705357142857145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKOibVWpDjGyDD4uibtLrwpibT980LmQ5eRiaopt6wt4WEargRrCTNvibMR0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为我已经添加了adb应用，所以这里不显示“添加至CHROME”，没有添加adb扩展应用的点击“+添加至CHROME”就可以了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）添加完后，回到扩展应用的窗口，就会出现下面的图标，表示添加成功：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24632768361581922&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKLQ2uzW3R3HUjHPJiaxzCdVQYZI99AWbVNQubjJyP8uIYwMnS14xdQsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;会在浏览器的页眉处出现这样的小图标：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2188782489740082&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKsRhSW744DQlM6qgtvnylsm01RwxSsXgo4dQU0tQmCjZA8zm5xNGhoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;731&quot;/&gt;&lt;/p&gt;&lt;p&gt;（3）点击小图标，进入检测手机的页面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6444007858546169&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKZiaB4vAo3yEjazZWRbQOET4mRqJDQDPNk0Gszp92Yf8kJkmYDS7Ib4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;509&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5595959595959596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKricyiaIkkZQwGyJf9FHGKF9abqkHyUge0icmwMEdD5wg86o6mMyv1SFfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（4）用usb连接手机，并且打开手机的usb调试选项。打开设置---更多设置----开发者选项----USB调试、USB安装、USB调试（安全设置）。如果找不到开发者选项，一般打开设置---关于手机----连续点击（Android版本或者MIUI版本等，具体方式请百度解决）----更多设置---开发开发者选项----USB调试、USB安装、USB调试（安全设置）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（5）USB连接手机后，打开要调试的app，就会在网页上显示要调试的链接，然后点击进入调试窗口inspect：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41412012644889357&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKQgzZibquialp6DicLlD6ic7iar5pdPn4ib5wSILA02NJmz1kTONBRMkbvLEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;949&quot;/&gt;&lt;/p&gt;&lt;p&gt;（6）有时候出来的inspect是空白页面（chrome://inspect/#devices）&lt;/p&gt;&lt;p&gt;说明您需要翻墙才能访问，您就需要搜一下怎么翻墙，或者直接购买vpn账号进行调试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不需要翻墙的方式&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;p&gt; 这种方式需要浏览器Edge,在浏览器输入edge://inspect/#devices即可。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.21296296296296297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKqJC41NLQ5ibt5IzFRuqd1Svqibmf549G58ySibjicjibjCEq9PGGMmLTEEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;324&quot;/&gt;&lt;/p&gt;&lt;p&gt;展示效果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7388949079089924&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKHGcD8dmMzzStQkyjWBfcbaHcSRn9HFsnicXsLAANDT1BE088u98aIVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;923&quot;/&gt;&lt;/p&gt;&lt;p&gt;点击inspect即可调试手机上的网页了，不过此方式需要在webview开启调试模式&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;webview&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.setWebContentsDebuggingEnabled&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7949790794979079&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yyLvy204xW87MNhqm4OxiaG8gFs1mMLKKqkslyZwLXct1Rmdic5jiaxljFEWaSVmSOS6j4icNfIayQS2cSJAFiaYOzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1195&quot;/&gt;&lt;/p&gt;&lt;p&gt;  &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果您这边还有什么方式可以推荐，欢迎留言交流。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注我获取更多知识或者投稿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3w57n09uKDowd4ZDjRIgSMUn9cqY6ia77Ys3VfZjG8LUviacGSr0DFIvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;0.20555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3gibpbVwAGtDUV15FZianjGs1whAZ2gg71IV6J7zQpQhtQRcSyHrGJbxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;180&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;多少不重要，你的头像会上榜&lt;/p&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ef2e73c1becc06d20bd4626e80f7ab9</guid>
<title>猎户座-爱奇艺在用户画像之上的策略引擎！</title>
<link>https://toutiao.io/k/i5ziw8j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;Flink&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;Apache_Flink&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;Apache Flink &amp;amp; Apache Hudi. 由Committer &amp;amp; PMC 维护。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c90b68742c6a5dd955a3886ac1853a0</guid>
<title>疫情下的失业程序员；参与开源项目很难吗？Go语言之父介绍泛型｜码农周刊VIP会员专属邮件周报 Vol.086</title>
<link>https://toutiao.io/k/07qzhk3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>baf50beec8b932221d678820be57e12d</guid>
<title>2022年MySQL最新面试题 -   MySQL数据库基础知识</title>
<link>https://toutiao.io/k/to1dvco</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-reco-content content__default&quot;&gt;&lt;h4 id=&quot;_0、概要&quot;&gt;&lt;a href=&quot;#_0、概要&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 0、概要&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;1、平时MySQL主要用哪个版本&lt;/li&gt; &lt;li&gt;2、数据库三大范式是什么&lt;/li&gt; &lt;li&gt;3、MySQL有关权限的表都有哪几个&lt;/li&gt; &lt;li&gt;4、MySQL的binlog有有几种录入格式？分别有什么区别？&lt;/li&gt; &lt;li&gt;5、平时用到哪些关系型数据库和非关系数据库, 可以谈谈你对它们的理解吗?&lt;/li&gt; &lt;li&gt;6、可以简单说说你对MySQL的逻辑架构了解吗？&lt;/li&gt; &lt;li&gt;7、了解MySQL中的MVCC是什么?&lt;/li&gt; &lt;li&gt;8、PostgreSQL相对于MySQL的优势&lt;/li&gt; &lt;li&gt;9、PostgreSQL和MySQL的一些区别&lt;/li&gt;&lt;/ul&gt; &lt;h4 id=&quot;_1、平时mysql主要用哪个版本&quot;&gt;&lt;a href=&quot;#_1、平时mysql主要用哪个版本&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 1、平时MySQL主要用哪个版本&lt;/h4&gt; &lt;p&gt;出现概率: ★★★★&lt;/p&gt; &lt;p&gt;可以说说自己用的MySQL版本, 比如我自己用的版本是5.7版本，然后可以也简单聊聊这个版本的一些特点:&lt;/p&gt; &lt;p&gt;1)、安全性&lt;/p&gt; &lt;p&gt;在MySQL 5.7中，有不少安全性相关的改进。包括：&lt;/p&gt; &lt;p&gt;MySQL数据库初始化完成以后，会产生一个 root@localhost 用户，从MySQL 5.7开始，root用户的密码不再是空，而是随机产生一个密码，这也导致了用户安装5.7时发现的与5.6版本比较大的一个不同点。&lt;/p&gt; &lt;p&gt;MySQL官方已经删除了test数据库，默认安装完后是没有test数据库的，就算用户创建了test库，也可以对test库进行权限控制了
MySQL 5.7版本提供了更为简单SSL安全访问配置，并且默认连接就采用SSL的加密方式。&lt;/p&gt; &lt;p&gt;可以为用户设置密码过期策略，一定时间以后，强制用户修改密码。&lt;/p&gt; &lt;p&gt;2)、灵活性&lt;/p&gt; &lt;p&gt;MySQL 5.7的两个全新的功能，即JSON和generate column&lt;/p&gt; &lt;div class=&quot;language- extra-class&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code&gt;CREATE TABLE t1 (jdoc JSON);
INSERT INTO t1 VALUES(&#x27;{&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}&#x27;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3)、可用性&lt;/p&gt; &lt;p&gt;在线设置复制的过滤规则，不再需要重启MySQL，只需要停止SQL thread，修改完成以后，启动SQL thread&lt;/p&gt; &lt;p&gt;这个主要大致谈谈你自己的理解， 也可以根据自己的理解多延展一些， 提高面试的加分。&lt;/p&gt; &lt;h4 id=&quot;_2、数据库三大范式是什么&quot;&gt;&lt;a href=&quot;#_2、数据库三大范式是什么&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 2、数据库三大范式是什么&lt;/h4&gt; &lt;p&gt;出现概率: ★★★&lt;/p&gt; &lt;p&gt;第一范式：每个列都不可以再拆分。&lt;/p&gt; &lt;p&gt;第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。&lt;/p&gt; &lt;p&gt;第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。&lt;/p&gt; &lt;p&gt;在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。&lt;/p&gt; &lt;h4 id=&quot;_3、mysql有关权限的表都有哪几个&quot;&gt;&lt;a href=&quot;#_3、mysql有关权限的表都有哪几个&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 3、MySQL有关权限的表都有哪几个&lt;/h4&gt; &lt;p&gt;出现概率: ★★★&lt;/p&gt; &lt;p&gt;MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别&lt;code&gt;user&lt;/code&gt;，&lt;code&gt;db&lt;/code&gt;，&lt;code&gt;table_priv&lt;/code&gt;，&lt;code&gt;columns_priv&lt;/code&gt;和&lt;code&gt;host&lt;/code&gt;。下面分别介绍一下这些表的结构和内容：&lt;/p&gt; &lt;p&gt;&lt;code&gt;user&lt;/code&gt;权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。&lt;br/&gt; &lt;code&gt;db&lt;/code&gt;权限表：记录各个帐号在各个数据库上的操作权限。&lt;br/&gt; &lt;code&gt;table_priv&lt;/code&gt;权限表：记录数据表级的操作权限。&lt;br/&gt; &lt;code&gt;columns_priv&lt;/code&gt;权限表：记录数据列级的操作权限。&lt;br/&gt; &lt;code&gt;host&lt;/code&gt;权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。&lt;/p&gt; &lt;h4 id=&quot;_4、mysql的binlog有有几种录入格式-分别有什么区别&quot;&gt;&lt;a href=&quot;#_4、mysql的binlog有有几种录入格式-分别有什么区别&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 4、MySQL的binlog有有几种录入格式？分别有什么区别？&lt;/h4&gt; &lt;p&gt;出现概率: ★★★&lt;/p&gt; &lt;p&gt;MySQL的binlog有三种格式: statement，row和mixed。&lt;/p&gt; &lt;p&gt;1)、statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。&lt;/p&gt; &lt;p&gt;2)、row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。&lt;/p&gt; &lt;p&gt;3)、mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。&lt;/p&gt; &lt;p&gt;此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。&lt;/p&gt; &lt;h4 id=&quot;平时用到哪些关系型数据库和非关系数据库-可以谈谈你对它们的理解吗&quot;&gt;&lt;a href=&quot;#平时用到哪些关系型数据库和非关系数据库-可以谈谈你对它们的理解吗&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 平时用到哪些关系型数据库和非关系数据库, 可以谈谈你对它们的理解吗?&lt;/h4&gt; &lt;p&gt;出现概率: ★★★★★&lt;/p&gt; &lt;p&gt;主要讲讲你用过的关系型数据库比如MySQL, 非关系数据库(NoSql数据库)比如Redis, MongoDB等等。&lt;/p&gt; &lt;p&gt;1)、事务方面&lt;/p&gt; &lt;p&gt;关系型数据库的最大特点就是事务的一致性, 所以对于订单模型 对一致性要求比较高的还是建议用MySQL。&lt;/p&gt; &lt;p&gt;2)、关系数据库的另一个特点就是其具有固定的表结构&lt;/p&gt; &lt;p&gt;其实在业务模型中, 表结构固定反而是一件好事, 没有约束的模型 更容易出问题。&lt;/p&gt; &lt;p&gt;3)、复杂SQL，特别是多表关联查询&lt;/p&gt; &lt;p&gt;NoSql是不支持JOIN 这种查询的。&lt;/p&gt; &lt;p&gt;4)、索引方式&lt;/p&gt; &lt;p&gt;关系型数据库：B树、哈希等&lt;br/&gt;
NoSql：键值索引&lt;/p&gt; &lt;p&gt;5)、并发支持&lt;/p&gt; &lt;p&gt;关系型数据库：通过事务和锁来支持并发，高并发情况下，执行效率较低。&lt;br/&gt;
NoSql：打破了传统关系型数据库范式的约束和事务一致性，因此并发性能高。&lt;/p&gt; &lt;p&gt;当然自己也可以多延伸看一下， 毕竟这个面试出现的概率还是蛮高的。&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/uploads/photo/2022/3ac41624-e9dc-4389-93c0-9c856857d035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; &lt;h4 id=&quot;_5、可以简单说说你对mysql的逻辑架构了解吗&quot;&gt;&lt;a href=&quot;#_5、可以简单说说你对mysql的逻辑架构了解吗&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 5、可以简单说说你对MySQL的逻辑架构了解吗？&lt;/h4&gt; &lt;p&gt;出现概率: ★★★&lt;/p&gt; &lt;p&gt;第一层是服务器层，主要提供连接处理、授权认证、安全等功能。&lt;/p&gt; &lt;p&gt;第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。&lt;/p&gt; &lt;p&gt;第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。&lt;/p&gt; &lt;h4 id=&quot;_6、了解mysql中的mvcc是什么&quot;&gt;&lt;a href=&quot;#_6、了解mysql中的mvcc是什么&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 6、了解MySQL中的MVCC是什么?&lt;/h4&gt; &lt;p&gt;出现概率: ★★★&lt;/p&gt; &lt;p&gt;MVCC 是多版本并发控制，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。&lt;/p&gt; &lt;p&gt;InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。&lt;/p&gt; &lt;p&gt;MVCC 只能在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 SERIALIZABLE 则会对所有读取的行都加锁。&lt;/p&gt; &lt;h4 id=&quot;_7、postgresql相对于mysql的优势&quot;&gt;&lt;a href=&quot;#_7、postgresql相对于mysql的优势&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 7、PostgreSQL相对于MySQL的优势&lt;/h4&gt; &lt;p&gt;出现概率: ★★★★&lt;/p&gt; &lt;ul&gt;&lt;li&gt;在SQL的标准实现上要比MySQL完善，而且功能实现比较严谨；&lt;/li&gt; &lt;li&gt;存储过程的功能支持要比MySQL好，具备本地缓存执行计划的能力；&lt;/li&gt; &lt;li&gt;对表连接支持较完整，优化器的功能较完整，支持的索引类型很多，复杂查询能力较强；&lt;/li&gt; &lt;li&gt;PG主表采用堆表存放，MySQL采用索引组织表，能够支持比MySQL更大的数据量。&lt;/li&gt; &lt;li&gt;PG的主备复制属于物理复制，相对于MySQL基于binlog的逻辑复制，数据的一致性更加可靠，复制性能更高，对主机性能的影响也更小。&lt;/li&gt;&lt;/ul&gt; &lt;h4 id=&quot;_8、postgresql和mysql的一些区别&quot;&gt;&lt;a href=&quot;#_8、postgresql和mysql的一些区别&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 8、PostgreSQL和MySQL的一些区别&lt;/h4&gt; &lt;p&gt;出现概率: ★★★★&lt;/p&gt; &lt;p&gt;这个其实出现的概率还比较高， 自己可以说几点就行了&lt;/p&gt; &lt;p&gt;MySQL不支持地理数据类型。&lt;/p&gt; &lt;p&gt;从9.2开始，PG支持json数据类型。相对于MySQL来说，PG对json的支持比较先进。他有一些json指定的操作符和函数，是的搜索json文本非常高效。9.4开始，可以以二进制的格式存储json数据，支持在该列上进行全文索引（GIN索引），从而在json文档中进行快速搜索。&lt;/p&gt; &lt;p&gt;从5.7开始，MySQL支持json数据类型，比PG晚。也可以在json列上建立索引。然而对json相关的函数的支持比较有限。不支持在json列上全文索引。由于MySQL对SQL支持的限制，在存储和处理json数据方面，MySQL不是一个很好的选择。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b498b488ef949944fb1d8a8ba72458f4</guid>
<title>Gin 优化那些事</title>
<link>https://toutiao.io/k/mb8ug6b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文介绍gin的一些知识点&lt;/span&gt;&lt;span&gt;,如自定义Response,中间件等。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gin&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Gin 是一个 go 写的 web 框架，具有高性能的优点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初级的使用方式不介绍了，具体请查阅官方文档。官方地址：&lt;code&gt;https://github.com/gin-gonic/gin&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下介绍基于gin开发项目的一些常用模块。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自定义Response&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个公司都会自定义接口的数据结构。故我们需要基于&lt;code&gt;Json()&lt;/code&gt;自定义一个更方便好用的response&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Response 数据结构体&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Response struct {&lt;br/&gt;    // StatusCode 业务状态码&lt;br/&gt; StatusCode int `json:&lt;span&gt;&quot;status_code&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Message 提示信息&lt;br/&gt; Message    string      `json:&lt;span&gt;&quot;message&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Data 数据，用interface{}的目的是可以用任意数据&lt;br/&gt; Data       interface{} `json:&lt;span&gt;&quot;data&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Meta 源数据,存储如请求ID,分页等信息&lt;br/&gt; Meta       Meta        `json:&lt;span&gt;&quot;meta&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;    // Errors 错误提示，如 xx字段不能为空等&lt;br/&gt; Errors     []ErrorItem `json:&lt;span&gt;&quot;errors&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Meta 元数据&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Meta struct {&lt;br/&gt; RequestId      string                 `json:&lt;span&gt;&quot;request_id&quot;&lt;/span&gt;`&lt;br/&gt; // 还可以集成分页信息等&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// ErrorItem 错误项&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ErrorItem struct {&lt;br/&gt; Key   string `json:&lt;span&gt;&quot;key&quot;&lt;/span&gt;`&lt;br/&gt; Value string `json:&lt;span&gt;&quot;error&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// New &lt;span&gt;return&lt;/span&gt; response instance&lt;br/&gt;func New() *Response {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Response{&lt;br/&gt;  StatusCode: 200,&lt;br/&gt;  Message:    &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;  Data:       nil,&lt;br/&gt;  Meta: Meta{&lt;br/&gt;   RequestId: uuid.NewV4().String(),&lt;br/&gt;  },&lt;br/&gt;  Errors: []ErrorItem{},&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装gin.Context以自定义一些方便的方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Wrapper include context&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Wrapper struct {&lt;br/&gt; ctx *gin.Context&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// WrapContext&lt;br/&gt;func WrapContext(ctx *gin.Context) *Wrapper {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Wrapper{ctx:ctx}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Json 输出json,支持自定义response结构体&lt;br/&gt;func (wrapper *Wrapper) Json(response *Response) {&lt;br/&gt; wrapper.ctx.JSON(200, response)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Success 成功的输出&lt;br/&gt;func (wrapper *Wrapper) Success( data interface{}) {&lt;br/&gt; response := New()&lt;br/&gt; response.Data = data&lt;br/&gt; wrapper.Json(response)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Error 错误输出&lt;br/&gt;func (wrapper *Wrapper) Error( statusCode int, message string) {&lt;br/&gt; response := New()&lt;br/&gt; response.StatusCode = statusCode&lt;br/&gt; response.Message = message&lt;br/&gt; wrapper.Json(response)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt; uuid &lt;span&gt;&quot;github.com/satori/go.uuid&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;()  {&lt;br/&gt; router := gin.Default()&lt;br/&gt; router.GET(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;  WrapContext(ctx).Success(&lt;span&gt;&quot;hello,world&quot;&lt;/span&gt;)&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; router.Run(&lt;span&gt;&quot;:8088&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;go run main.go&lt;/code&gt;运行后，浏览器访问&lt;code&gt;localhost:8088&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;中间件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍一些常用的中间件，如跨域、Jwt校验、请求日志等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;备注&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入中间件比如在注册路由之前,谨记!&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;跨域中间件&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package middleware&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;// CORS 跨域中间件&lt;br/&gt;func CORS(ctx *gin.Context) {&lt;br/&gt; method := ctx.Request.Method&lt;br/&gt;&lt;br/&gt; // &lt;span&gt;set&lt;/span&gt; response header&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Origin&quot;&lt;/span&gt;, ctx.Request.Header.Get(&lt;span&gt;&quot;Origin&quot;&lt;/span&gt;))&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Credentials&quot;&lt;/span&gt;, &lt;span&gt;&quot;true&quot;&lt;/span&gt;)&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Headers&quot;&lt;/span&gt;, &lt;span&gt;&quot;Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With&quot;&lt;/span&gt;)&lt;br/&gt; ctx.Header(&lt;span&gt;&quot;Access-Control-Allow-Methods&quot;&lt;/span&gt;, &lt;span&gt;&quot;GET,POST,PUT,PATCH,DELETE,OPTIONS&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    // 默认过滤这两个请求,使用204(No Content)这个特殊的http status code&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; method == &lt;span&gt;&quot;OPTIONS&quot;&lt;/span&gt; || method == &lt;span&gt;&quot;HEAD&quot;&lt;/span&gt; { &lt;br/&gt;  ctx.AbortWithStatus(204)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; ctx.Next()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    router := gin.Default()&lt;br/&gt;    router.Use(CORS)&lt;br/&gt;    router.GET(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;     WrapContext(ctx).Success(&lt;span&gt;&quot;hello,world&quot;&lt;/span&gt;)&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    router.Run(&lt;span&gt;&quot;:8088&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Jwt校验&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;errors&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/dgrijalva/jwt-go&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;var (&lt;br/&gt; TokenNotExist       = errors.New(&lt;span&gt;&quot;token not exist&quot;&lt;/span&gt;)&lt;br/&gt; TokenValidateFailed = errors.New(&lt;span&gt;&quot;token validate failed&quot;&lt;/span&gt;)&lt;br/&gt; ClaimsKey = &lt;span&gt;&quot;uniqueClaimsKey&quot;&lt;/span&gt;&lt;br/&gt; SignKey = &lt;span&gt;&quot;test&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;// JwtAuth jwt&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; JwtAuth struct {&lt;br/&gt; SignKey []byte&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// ParseToken parse token&lt;br/&gt;func (jwtAuth JwtAuth) ParseToken(token string) (jwt.Claims, error) {&lt;br/&gt; tokenClaims, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; jwtAuth.SignKey, nil&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; tokenClaims.Claims == nil || !tokenClaims.Valid {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil, TokenValidateFailed&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; tokenClaims.Claims, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// GenerateToken&lt;br/&gt;func (jwtAuth JwtAuth) GenerateToken(tokenExpireTime int64 /* 过期时间 */, iss string /* key*/) (string, error) {&lt;br/&gt; now := time.Now().Unix()&lt;br/&gt; exp := now + tokenExpireTime&lt;br/&gt; claim := jwt.MapClaims{&lt;br/&gt;  &lt;span&gt;&quot;iss&quot;&lt;/span&gt;: iss,&lt;br/&gt;  &lt;span&gt;&quot;iat&quot;&lt;/span&gt;: now,&lt;br/&gt;  &lt;span&gt;&quot;exp&quot;&lt;/span&gt;: exp,&lt;br/&gt; }&lt;br/&gt; token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)&lt;br/&gt; tokenStr, err := token.SignedString(jwtAuth.SignKey)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; tokenStr, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// JWT gin的jwt中间件&lt;br/&gt;func JWT(ctx *gin.Context) {&lt;br/&gt; // 解析token&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := validateToken(ctx); err != nil {&lt;br/&gt;  WrapContext(ctx).Error(401, err.Error())&lt;br/&gt;  ctx.Abort()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; ctx.Next()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// validateToken 验证token&lt;br/&gt;func validateToken(ctx *gin.Context) error {&lt;br/&gt; // 获取token&lt;br/&gt; tokenStr := ctx.GetHeader(&lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;)&lt;br/&gt; kv := strings.Split(tokenStr, &lt;span&gt;&quot; &quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; len(kv) != 2 || kv[0] != &lt;span&gt;&quot;Bearer&quot;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; TokenNotExist&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; jwtAuth := &amp;amp;JwtAuth{SignKey: []byte(SignKey)}&lt;br/&gt; claims, err := jwtAuth.ParseToken(kv[1])&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // token存入context&lt;br/&gt; ctx.Set(ClaimsKey, claims)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;()  {&lt;br/&gt; router := gin.Default()&lt;br/&gt; router.GET(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;  WrapContext(ctx).Success(&lt;span&gt;&quot;hello,world&quot;&lt;/span&gt;)&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt;    // 指定user这组路由都需要校验jwt&lt;br/&gt; user := router.Group(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;).Use(JWT)&lt;br/&gt; {&lt;br/&gt;  user.GET(&lt;span&gt;&quot;/info&quot;&lt;/span&gt;, func(ctx *gin.Context) {&lt;br/&gt;   claims, exist := ctx.Get(ClaimsKey)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; !exist {&lt;br/&gt;    WrapContext(ctx).Error(1001, &lt;span&gt;&quot;获取用户信息失败&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   WrapContext(ctx).Success(claims)&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; router.Run(&lt;span&gt;&quot;:8088&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl  &lt;span&gt;&quot;localhost:8088/user/info&quot;&lt;/span&gt;&lt;br/&gt;// 输出:&lt;br/&gt;// {&lt;span&gt;&quot;status_code&quot;&lt;/span&gt;:401,&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;token not exist&quot;&lt;/span&gt;,&lt;span&gt;&quot;data&quot;&lt;/span&gt;:null,&lt;span&gt;&quot;meta&quot;&lt;/span&gt;:{&lt;span&gt;&quot;request_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;e69361cf-1fd4-42e4-8af8-d18fac1e70fb&quot;&lt;/span&gt;},&lt;span&gt;&quot;errors&quot;&lt;/span&gt;:[]}&lt;br/&gt;&lt;br/&gt;// 通过GenerateToken()生成一个token&lt;br/&gt;curl -H &lt;span&gt;&quot;Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODU4MjQ2NzgsImlhdCI6MTU4NTgyMTA3OCwiaXNzIjoiYWEifQ.Eyo8KptVUgGfnRG8zsjDilAJOBmaXMtjqJxw__a32HY&quot;&lt;/span&gt;  localhost:8088/user/info&lt;br/&gt;// 输出：&lt;br/&gt;{&lt;span&gt;&quot;status_code&quot;&lt;/span&gt;:200,&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;span&gt;&quot;data&quot;&lt;/span&gt;:{&lt;span&gt;&quot;exp&quot;&lt;/span&gt;:1585824678,&lt;span&gt;&quot;iat&quot;&lt;/span&gt;:1585821078,&lt;span&gt;&quot;iss&quot;&lt;/span&gt;:&lt;span&gt;&quot;aa&quot;&lt;/span&gt;},&lt;span&gt;&quot;meta&quot;&lt;/span&gt;:{&lt;span&gt;&quot;request_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;464743de-1033-4656-96f8-36c1529f13e0&quot;&lt;/span&gt;},&lt;span&gt;&quot;errors&quot;&lt;/span&gt;:[]}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;请求日志&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录每个请求的重要信息&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import (&lt;br/&gt; &lt;span&gt;&quot;bytes&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;io/ioutil&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;// bodyLogWriter 定义一个存储响应内容的结构体&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; bodyLogWriter struct {&lt;br/&gt; gin.ResponseWriter&lt;br/&gt; body *bytes.Buffer&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Write 读取响应数据&lt;br/&gt;func (w bodyLogWriter) Write(b []byte) (int, error) {&lt;br/&gt; w.body.Write(b)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; w.ResponseWriter.Write(b)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// RequestLog gin的请求日志中间件&lt;br/&gt;func RequestLog(c *gin.Context) {&lt;br/&gt; // 记录请求开始时间&lt;br/&gt; t := time.Now()&lt;br/&gt; blw := &amp;amp;bodyLogWriter{body: bytes.NewBufferString(&lt;span&gt;&quot;&quot;&lt;/span&gt;), ResponseWriter: c.Writer}&lt;br/&gt; // 必须!&lt;br/&gt; c.Writer = blw&lt;br/&gt;&lt;br/&gt; // 获取请求信息&lt;br/&gt; requestBody := getRequestBody(c)&lt;br/&gt;&lt;br/&gt; c.Next()&lt;br/&gt;&lt;br/&gt; // 记录请求所用时间&lt;br/&gt; latency := time.Since(t)&lt;br/&gt;&lt;br/&gt; // 获取响应内容&lt;br/&gt; responseBody := blw.body.String()&lt;br/&gt;&lt;br/&gt; logContext := make(map[string]interface{})&lt;br/&gt; // 日志格式&lt;br/&gt; logContext[&lt;span&gt;&quot;request_uri&quot;&lt;/span&gt;] = c.Request.RequestURI&lt;br/&gt; logContext[&lt;span&gt;&quot;request_method&quot;&lt;/span&gt;] = c.Request.Method&lt;br/&gt; logContext[&lt;span&gt;&quot;refer_service_name&quot;&lt;/span&gt;] = c.Request.Referer()&lt;br/&gt; logContext[&lt;span&gt;&quot;refer_request_host&quot;&lt;/span&gt;] = c.ClientIP()&lt;br/&gt; logContext[&lt;span&gt;&quot;request_body&quot;&lt;/span&gt;] = requestBody&lt;br/&gt; logContext[&lt;span&gt;&quot;request_time&quot;&lt;/span&gt;] = t.String()&lt;br/&gt; logContext[&lt;span&gt;&quot;response_body&quot;&lt;/span&gt;] = responseBody&lt;br/&gt; logContext[&lt;span&gt;&quot;time_used&quot;&lt;/span&gt;] = fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, latency)&lt;br/&gt; logContext[&lt;span&gt;&quot;header&quot;&lt;/span&gt;] = c.Request.Header&lt;br/&gt;&lt;br/&gt; log.Println(logContext)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// getRequestBody 获取请求参数&lt;br/&gt;func getRequestBody(c *gin.Context) interface{} {&lt;br/&gt; switch c.Request.Method {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodGet:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.Request.URL.Query()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodPost:&lt;br/&gt;  fallthrough&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodPut:&lt;br/&gt;  fallthrough&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; http.MethodPatch:&lt;br/&gt;  var bodyBytes []byte // 我们需要的body内容&lt;br/&gt;        // 可以用buffer代替ioutil.ReadAll提高性能&lt;br/&gt;  bodyBytes, err := ioutil.ReadAll(c.Request.Body)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;        }&lt;br/&gt;        // 将数据还回去&lt;br/&gt;  c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; string(bodyBytes)&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;router.Use(ReqeustLog)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就到这儿吧，还有一些比如全局ID中间件，后面来写。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>