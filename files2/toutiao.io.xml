<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3ef105562296968c1b917a3e0f0b0b36</guid>
<title>建木持续集成平台 v1.0.0 发布</title>
<link>https://toutiao.io/k/5q2gy9v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;建木持续集成平台是基于建木自动化平台提供的国产开源CI/CD产品，致力于为国内开发者提供简单易用、方便快捷的开发体验，推广DevOps的最佳实践，填补国内开源软件供应链中缺失的一环。&lt;/p&gt;

&lt;p&gt;建木持续集成平台v1.0.0现已发布&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要功能：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事件桥接器：提供外部系统触发流程执行的事件桥接转换机制，当前只支持Webhook方式调用。&lt;/li&gt;
&lt;li&gt;配置即代码：提供两种不同的DSL语法来描述配置CI/CD流程。同时支持本地创建和远程Git导入两种方式来创建项目，可以支持GitOps的最佳实践。&lt;/li&gt;
&lt;li&gt;流程可视化：提供CI/CD流程的可视化展示，流程节点编排依赖与执行情况一目了然&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://ci.jianmu.dev&quot;&gt;详见官方项目示例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.jianmu.dev/guide/quick-start.html&quot;&gt;快速开始&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jianmu.dev&quot;&gt;官网首页&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3837321b75fc204900015fb80dd2ecc5</guid>
<title>ElasticSearch 基础之分布式查询的执行</title>
<link>https://toutiao.io/k/quxpiua</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;我们在之前的《&lt;a href=&quot;https://donggeitnote.com/2021/08/25/elasticsearch-distribute-storage/&quot;&gt;ElasticSearch基础之分布式存储&lt;/a&gt;》中详细介绍了ElasticSearch是如何进行分布式的读写（CRUD）。那我们在发送查找请求之后，ElasticSearch是如何进行分布式执行的呢？它其实要比我们前面提到的CRUD操作复杂一些，本文就来详细介绍一下这一方面的知识。&lt;/p&gt;



&lt;p&gt;前面的CRUD操作其实只是针对某一个shard的，也就是说我们其实是知道我们的操作最终会指向哪一个shard的， 而search相对来说复杂的地方就在于我们根本不知道要查找的内容是存储在哪一个shard上，这就必然导致我们需要去访问每一个shard，或者说至少是我们感兴趣的shard。然后访问不同（所有）shard得到的数据其实只完成了一部分的工作，你还需要把各个shard返回的内容进行整合，排序或者筛选出最终返回给用户的那一部分数据并把它们从各个shard提取出来。因此我们可以简单认为search其实包含了两个部分的操作，一个是查询一个是提取。&lt;/p&gt;



&lt;h1&gt;查询&lt;/h1&gt;



&lt;p&gt;查询过程其实说白了也很简单，它在开始的时候会把你的query发送到index上所有的shard（有可能是primary也可能是replica的shard），然后在各个shard上执行查询，并根据相匹配的文档生成一个priority queue。具体可以参见下面的流程图：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-20.png&quot; alt=&quot;&quot; class=&quot;wp-image-943&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-20.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-20-300x141.png 300w, https://donggeitnote.com/wp-content/uploads/2021/09/image-20-520x245.png 520w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;首先假设client端会把search的request发送到node3，这里首先会create一个空的priority queue，大小就是from+size。这里from就是页码，比如说我们每页返回10条记录，我想看第三页的，那么from这里就设为20，size就是10。&lt;/li&gt;&lt;li&gt;Node3会把这个request转发给cluster中所有的相关shard，可能是primary也可能是replica，每个shard会在本地执行相关的request，并把它们的结果加入到本地的priority queue中，每个priority queue的大小也是from+size。&lt;/li&gt;&lt;li&gt;每个shard都会把它们的结果返回给node3，node3这里会进行merge的操作，同样取最前面的from+size放到全局的priority queue中。&lt;/li&gt;&lt;/ol&gt;



&lt;p&gt;整个流程还是蛮清晰的，node3负责接收request和返回response，它也负责分发request到各个shard，并merge最终得到的结果。这里假如你仔细观察会发现其实from这个值对我们需要查询的内容有很大的影响，同样是查询10条数据，假如from==0，也就是第一页，你就只要查询10条，但是假如from是9，也就是第10页，它就需要查询100条数据，这在分散到各个shard上，查询的数据就更大了。这也是为什么有些查询不支持太多的页，一方面是因为排序在后面的内容其实意义也不是很大，另一方面也是考虑这个查询的效率问题。&lt;/p&gt;



&lt;h1&gt;提取&lt;/h1&gt;



&lt;p&gt;上面查询就是确定哪些文本是符合最终的需求的，在有了这些信息之后，下一步要做的就是把这些文本提取出来，这就是提取这一步要做的事情，大体的流程见下图：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-21.png&quot; alt=&quot;&quot; class=&quot;wp-image-944&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-21.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-21-300x137.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;Node3从查询阶段得到了符合要求的文本列表，它会根据这个列表发送Get请求到各个shard来获取相关的文本内容。&lt;/li&gt;&lt;li&gt;每一个shard都加载相关的文本，并有可能附加一些额外的信息（metadata或者高亮文本之类的），然后返回给node3.&lt;/li&gt;&lt;li&gt;Node3接收到所有的文本内容，返回给client端。&lt;/li&gt;&lt;/ol&gt;



&lt;p&gt;Node3在第一步会计算一下哪些文本真正的需要提取，比如说像我们上面提到的例子，from是9，那么其实前面的90条记录是不需要去进行提取的，只需要提取91到100这一范围的文本就可以了。&lt;/p&gt;



&lt;h1&gt;查询的选项&lt;/h1&gt;



&lt;p&gt;上面提到的整个流程其实是一个通用情况的流程，其实有很多查询参数也会影响这个流程：&lt;/p&gt;



&lt;h2&gt;Preference&lt;/h2&gt;



&lt;p&gt;假如你仔细阅读上面的流程，你会发现我们在查询的时候并不一定是要去访问所有的shard，这里其实是可以控制的，甚至哪些node需要访问都是可以通过preference来设置的。&lt;/p&gt;



&lt;p&gt;你可以设置这个参数为_primary, _primary_first, _local, _only_node:xyz,_prefer_node:xyz或者_shards:2,3等等，不需要我详细介绍各个设置的意义应该还是蛮明显的。&lt;/p&gt;



&lt;h2&gt;Timeout&lt;/h2&gt;



&lt;p&gt;这个也比较好理解，我们毕竟要访问很多不同的shard，这个过程中什么都有可能发生，不可能无限制的等待下去，所以会有一个超时的机制，当超过了这段时间我们就不再等待相应shard的返回了，这个结果会显示在最终的返回结果中，如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-22.png&quot; alt=&quot;&quot; class=&quot;wp-image-945&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-22.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-22-300x102.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这里就是有超时发生，总共有5个shard，其中有一个没有在规定时间内返回结果。我们也可以通过这个域来判断是不是所有的shard都出现了问题。&lt;/p&gt;



&lt;h2&gt;Routing&lt;/h2&gt;



&lt;p&gt;我们在index的时候可以根据routing来把相关的文档都放在同样的shard中，那么显然在查询的时候我们也可以通过设置这个参数来控制查询所涉及的shard。比如说下面这个request就只touch user1和user2所在的shard。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-23.png&quot; alt=&quot;&quot; class=&quot;wp-image-946&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-23.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-23-300x24.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;h2&gt;Search_type&lt;/h2&gt;



&lt;p&gt;其实我们上面提到的查询-提取只是一个默认的操作，我们是可以通过search_type来控制的，它可以设置为下面这些值：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;Count：这个就只有查询的步骤，不会去进行提取。一般用在我们不需要知道具体文档的情况下，比如有多少个查询结果之类的。&lt;/li&gt;&lt;li&gt;Query_and_fetch：这个就是我们上面提到的查询和提取。&lt;/li&gt;&lt;li&gt;Dfs_query_then_fetch/dfs_quey_and_fetchg：这个设置中有一个预查询的步骤，他们会从所有相关的shard中获取term的frequency来决定一个global的term frequency。这个主要是用来防止relevance计算出问题。我们在《&lt;a href=&quot;https://donggeitnote.com/2021/09/19/elasticsearch-tfidf/&quot;&gt;Elasticsearch基础之相关性介绍&lt;/a&gt;》中详细介绍了relevance的计算，这里有一个概念，就是相关性其实和term出现的频率有关系，假如term在某一个shard中出现的频率太高或者太低，那么就会影响它在那个shard中分数的计算，从而在我们合并多个shard进行比较的时候不公平，所以这里我们会通过这个设置来得到一个全局的频率从而减小这个误差。当然在数据量很大的系统中，没有必要这么做，这个在一些比较小数据量的测试系统中会常常遇到。&lt;/li&gt;&lt;li&gt;Scan：这个主要是和scroll来配合的，主要是用来高效查询大数据量的结果，它不会进行各个shard之间的排序。主要是用来快速返回大量数据的情况下。&lt;/li&gt;&lt;/ul&gt;



&lt;h1&gt;总结&lt;/h1&gt;



&lt;p&gt;至此本文就详细介绍了ElasticSearch是如何进行分布式查询的，并介绍了几个常见的参数。&lt;/p&gt;
                                                    &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb19d95e0277309a87eacb680bdf11d5</guid>
<title>Minerva：Airbnb 的大规模数据指标系统（三）</title>
<link>https://toutiao.io/k/jsdma77</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;这是Airbnb Minerva系列文章的第三篇，主要介绍Minerva如何为不同用户量身定制多功能的数据消费体验。原文：How Airbnb Enables Consistent Data Consumption at Scale&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247483890&amp;amp;idx=1&amp;amp;sn=b91ffef8a8c32fe24439afa367b0205a&amp;amp;chksm=fc73bc29cb04353f2de39edcd82c90e5300d1374b3a0806603bf8cb6b894d54043eb04ae0366&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Minerva -- Airbnb的大规模数据指标系统 Part 1&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Minerva -- Airbnb的大规模数据指标系统 Part 1&lt;br/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247483909&amp;amp;idx=1&amp;amp;sn=03c33e563c9edf8c92778e8f155d2557&amp;amp;chksm=fc73bfdecb0436c80078f63579f783a19df434b64ee79fcbc520e9c546df3ac940f0fd61638b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Minerva -- Airbnb的大规模数据指标系统 Part 2&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Minerva -- Airbnb的大规模数据指标系统 Part 2&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwfQEsAtYD8KP1NGlcA6QwFbYZrS8qOFeEDgNsPl60l0OqPHzGBDgOmg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;h3/&gt;&lt;h3&gt;简介&lt;/h3&gt;&lt;p&gt;在本系列的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247483890&amp;amp;idx=1&amp;amp;sn=b91ffef8a8c32fe24439afa367b0205a&amp;amp;chksm=fc73bc29cb04353f2de39edcd82c90e5300d1374b3a0806603bf8cb6b894d54043eb04ae0366&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第一篇文章&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第一篇文章&lt;/a&gt;中，我们介绍了Minerva在改善Airbnb数据分析工作方面所起的作用。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247483909&amp;amp;idx=1&amp;amp;sn=03c33e563c9edf8c92778e8f155d2557&amp;amp;chksm=fc73bfdecb0436c80078f63579f783a19df434b64ee79fcbc520e9c546df3ac940f0fd61638b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第二篇文章&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第二篇文章&lt;/a&gt;中，我们深入探讨了Minerva的核心计算基础设施，并介绍了我们如何保证数据集和团队数据的一致性。在第三篇也是最后一篇文章中，我们将重点讲述Minerva如何极大的简化和改善用户的数据消费体验。具体来说，我们将展示统一指标层（我们称之为Minerva API）如何帮助我们构建为具有广泛背景和不同级别数据专业知识的用户量身定制的多功能数据消费体验。&lt;/p&gt;&lt;h3&gt;以指标为中心的方法（A Metric-Centric Approach）&lt;/h3&gt;&lt;p&gt;当用户采用数据来探索业务问题时，通常会考虑不同的指标和维度。例如，业务负责人可能想知道长期住宿（维度）占预订（指标）的百分比是多少。要回答这个问题，首先要找到正确的表单（where），通过必要的联合（joins）或过滤（filters）（how），最终聚合数据（how）以得到正确的答案。&lt;/p&gt;&lt;p&gt;虽然许多传统BI工具试图代表用户把这些工作抽象出来，但大多数数据服务逻辑仍然严重依赖用户来确定“where”和“how”。在Airbnb，我们希望提供更好的用户体验——用户只要简单的请求获取指标和维度，就可以直接得到答案，而不必担心“where”或“how”的问题。我们将这一愿景称之为“以指标为中心的方法”，最终发现这是一个艰巨的工程挑战。&lt;/p&gt;&lt;h3&gt;挑战一：“Where”&lt;/h3&gt;&lt;p&gt;在大多数传统数据仓库中，数据以表的形式组织。这意味着要响应某个查询，BI工具需要将相关的指标和维度与包含相关答案的物理表关联起来。然而，对于给定的指标和维度的组合，也许有许多数据集包含有相关答案。这些表通常具有不同程度的数据质量和正确性保证，因此选择正确的表来服务数据并非易事。&lt;/p&gt;&lt;h3&gt;挑战二：“How”&lt;/h3&gt;&lt;p&gt;除了“where”之外，负责“how”的数据服务逻辑也有许多细微差别。首先，有不同的指标类型：由单个物理事件（例如：预定量）组成的&lt;em&gt;简单指标（simple metrics）&lt;/em&gt;；基于维度过滤产生的一组简单指标组成的&lt;em&gt;过滤指标（filtered metrics）&lt;/em&gt;（例如：中国的预订量）；由一个或多个非派生指标组成的&lt;em&gt;派生指标（derived metrics）&lt;/em&gt;（例如：图书搜索匹配率)。此外，虽然有许多指标是递增的（例如：预订量），但也有许多指标不是：计数差、百分比和基于时间的快照等，不能简单的通过汇总单个事件来计算。始终如一的在所有场景中正确的计算这些不同类型的指标是一个巨大的挑战。&lt;/p&gt;&lt;h3&gt;挑战三：与下游应用程序集成&lt;/h3&gt;&lt;p&gt;最后，只有在各种上下文环境、应用程序和工具中使用数据，才能做出基于数据的决策。指标越通用、越重要，就越有可能被广泛应用于各种场合。例如，总预订价值（Gross Booking Value，GBV）、预订夜数（nights booked）和收入（revenue）是Airbnb最常用的指标，被广泛应用于跟踪业务表现、作为随机控制实验的基准比较指标，并用于比较机器学习模型。在不同用例中基于这些指标提供服务，同时为用户提供上下文信息从而可以以正确的方式使用它们，是我们面临的另一个核心挑战。&lt;/p&gt;&lt;h3&gt;解决方案&lt;/h3&gt;&lt;p&gt;我们通过构建Minerva API来解决这些挑战，这是一个指标服务层（metric-serving layer），充当上游数据模型和下游应用程序之间的接口。有了Minerva API，任何下游应用程序都能够以一致和正确的方式消费数据，而不用知道数据存储在哪里，也不用知道应该如何计算指标。本质上，Minerva API通过连接“what”和“where”来充当“how”。&lt;/p&gt;&lt;h1&gt;Minerva API&lt;/h1&gt;&lt;p&gt;Minerva API由API web服务、元数据获取应用以及客户端（与Apache Superset&lt;span&gt;[2]&lt;/span&gt;、Tableau&lt;span&gt;[3]&lt;/span&gt;、Python&lt;span&gt;[4]&lt;/span&gt;和R&lt;span&gt;[5]&lt;/span&gt;集成）组成。这些组件为下游应用程序提供本地NoSQL和SQL指标查询。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5238095238095238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwFnHQFmtZKaC7oHCA6NOKX3Vp3MiajTG0ySWZ5VJ1vzV0qhMs8Dcybww/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Minerva API充当消费者和底层数据集之间的接口&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;元数据获取器：抽象“Where”&lt;/h3&gt;&lt;p&gt;我们前面提到过，用户只需要向Minerva提供指标和规格参数，而不需要指定“where”。当发出数据请求时，Minerva会花费大量精力来确定应该使用哪个数据集来响应该请求。&lt;/p&gt;&lt;p&gt;Minerva在幕后选择最佳数据源之前需要综合考虑多个因素，其中最重要的因素之一是数据完整性。这意味着选择用于查询的任何数据源都应该包含给定用户查询请求所需的所有列，并且必须涵盖查询请求所需的时间范围。&lt;/p&gt;&lt;p&gt;为此，我们构建了一个名为元数据获取器（Metadata Fetcher）的服务，该服务每15分钟定期从数据源获取元数据，并将其缓存到MySQL数据库中。具体来说，我们定期从S3获取Minerva配置的最新副本（存储在Thrift二进制文件中），从而获取Druid中每个有效Minerva数据源的列表。对于每个数据源，我们查询Druid代理以读取它的名称以及相关的指标和维度列表。此外，我们还可以从代理获取最小日期、最大日期以及日期计数，以确定是否有任何丢失的数据。每次获取新信息时，我们都会更新MySQL数据库，以维护真实数据源。通过元数据获取器，我们能够在任何给定的时间使用最好的数据源来服务数据请求。&lt;/p&gt;&lt;h3&gt;数据API：抽象“How”&lt;/h3&gt;&lt;p&gt;假设用户希望了解2021年8月的4周时间内，除私人房间外，各目的地地区的日均价格（average daily price，ADR）下降趋势。示例查询的完整规格定义如下所示：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;metric&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘price_per_night’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;groupby_dimension&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘destination_region’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;global_filter&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘dim_room_type!=”private-room”’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;aggregation_granularity&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘W-SAT’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;start_date&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘2021–08–01’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;end_date&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘2021–09–01’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;truncate_incomplete_leading_data&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘true’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;truncate_incomplete_trailing_data&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ‘true’&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当Minerva接收到这样的请求时，它不仅需要确定从哪里获取数据，还需要知道如何过滤、组合以及聚合数据以获得最终的结果。它采用了一种策略，通过Split-Apply-Combine范式&lt;span&gt;[6]&lt;/span&gt;来实现，该范式通常用于数据分析。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3523809523809524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAw1Zicqsy7RhczicIutgpMdBuqVjZscuCd4O2bHQhmRh4oJGicuIG1KpDPQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对&#x27;price_per_night&#x27;指标应用Split-Apply-Combine范式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;步骤一：将请求拆分为原子指标请求&lt;/h3&gt;&lt;p&gt;当Minerva API接收到如上所述的查询请求时，它所做的第一件事就是通过创建一组相关的子查询，将任何派生指标分解为我们称为Minerva“原子”指标。如果一个用户查询只指定一个原子的Minerva指标，那么第一步基本上是一个空操作。&lt;/p&gt;&lt;p&gt;在上面的例子中，给定‘price_per_night’指标是一个比率指标（派生指标的一种特例），它包含一个分子(‘gross_booking_value_stays’)和一个分母(‘nights_booking’)，Minerva API将这个请求分解为两个子请求。&lt;/p&gt;&lt;h3&gt;步骤二：采用并执行每个子查询&lt;/h3&gt;&lt;p&gt;对于第1步中确定的原子指标，Minerva利用S3中存储的指标配置来推断相关的指标表达式和元数据，从而生成子查询。我们继续讨论这个例子：Minerva数据API查找“gross_booking_value_stays”的指标定义，发现它是一个SUM聚合，类似的，“nights_booking”指标也是如此。在这两个请求中，通过全局过滤器&#x27; dim_room_type != &quot; private-room&quot; &#x27;用于确保私人房间不在计算范围内。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5552380952380952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwibKicEMp9z5e5TC7KWCAicJia5Y2Tfc3icJ8cufzPYWU6e1cm1KQib3Ky57A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对ADR指标应用Split-Apply-Combine范式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一旦为每个原子指标都生成了关联的子查询，Minerva API最终将查询发送给Druid或Presto。它将查询分割成几个跨越更小时间范围的“片”，然后在达到资源限制时将结果合并到单个数据帧中。在基于聚合粒度拼接数据帧之前，API还会丢弃任何不完整的前置或后置数据。&lt;/p&gt;&lt;h3&gt;步骤三：将原子指标结果合并到单个数据帧中&lt;/h3&gt;&lt;p&gt;一旦Minerva获取到每个原子指标的数据帧，它会通过连接时间戳列上的数据帧将它们组合成一个单独的数据帧。作为最后一步，Minerva API在以序列化JSON格式将最终结果返回给客户端之前将执行任何必要的聚合后计算、排序和限制操作。&lt;/p&gt;&lt;p&gt;总之，通过Minerva的数据源API和数据API，我们可以抽象出确定从哪里获取数据以及如何返回数据的过程。这个API作为Minerva的单一抽象层，可以满足来自下游应用程序的任何请求。然而，我们的故事并没有就此结束：我们的许多工程挑战都涉及到如何将不同的应用程序与这个API集成，我们将在下一节探讨这些挑战。&lt;/p&gt;&lt;h1&gt;数据消费经验&lt;/h1&gt;&lt;p&gt;考虑到Airbnb内部数据消费者的多样性，我们开始构建针对不同角色和用例的工具。通过Minerva API，我们构建了广泛的用户界面，这些用户界面提供了一致的数据消费体验。正如我们在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247483890&amp;amp;idx=1&amp;amp;sn=b91ffef8a8c32fe24439afa367b0205a&amp;amp;chksm=fc73bc29cb04353f2de39edcd82c90e5300d1374b3a0806603bf8cb6b894d54043eb04ae0366&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第一篇文章&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第一篇文章&lt;/a&gt;中简要提到的，有四个主要的集成点，每个点支持一组不同的工具和用户：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据分析（Data Analysis）：&lt;/span&gt;与Python和R集成，主要用于高级数据分析&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据探索（Data Exploration）：&lt;/span&gt;与BI工具（如Superset、Metric Explorer&lt;span&gt;[7]&lt;/span&gt;和Tableau)的集成，为精通数据的分析师量身定制，以帮助商业洞察&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;报告（Reporting）：&lt;/span&gt;与XRF（eXecutive Reporting Framework，执行报告框架）&lt;span&gt;[8]&lt;/span&gt;集成，为希望了解当前业务状态的管理层量身定制&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实验（Experimentation）：&lt;/span&gt;与ERF（Experimentation Reporting Framework，实验报告框架）集成，专为在Airbnb进行A/B测试的数据科学家、工程师或产品经理量身定制&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当我们构建这些特性时，我们总是在一致性、灵活性和可访问性之间进行权衡。例如，Metric Explorer主要是为非数据专家的非技术用户构建的，这意味需要为它优化一致性和可访问性，而不是灵活性。Metric Explorer有严格的执行保护，防止用户做错误的事情，并且几乎没有机会偏离确定的道路。&lt;/p&gt;&lt;p&gt;作为另一个极端，通常受数据科学家青睐的R和Python客户端要灵活得多。用户可以完全控制如何利用客户端API来执行定制分析或可视化。在接下来的几节中，我们将介绍这些消费体验是如何被创建的。&lt;/p&gt;&lt;h3&gt;与Metric Explorer集成&lt;/h3&gt;&lt;p&gt;Metric Explorer由Airbnb创建，任何人（无论他们的数据专业水平如何）都可以利用数据做出明智的决策。由于其面向广泛的目标用户，Metric Explorer优化了可访问性和数据一致性，而不是灵活性。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5419047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwGS9kOuAn3ibPThAicVIdHv1dM98ic3jd6MGd4E071UEMjABLW8FuJ05GA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Metric Explorer对于想要回答高级业务问题的非技术用户来说非常适合&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;所有Metric Explorer的指标、维度和相关元数据都来自Minerva的指标存储库，并被注入到Elasticsearch&lt;span&gt;[9]&lt;/span&gt;中。在用户对数据执行任何操作之前，这些元数据作为上下文方便的显示在右侧栏上。&lt;/p&gt;&lt;p&gt;当用户选择执行Group By和Filter之类的数据操作时，Metrics Explorer按等级顺序显示维度，这样只有很少或没有业务上下文的用户可以轻松的挖掘信息，而不需要提前知道维度值（如上所示）。&lt;/p&gt;&lt;p&gt;当用户对数据进行切片时，Minerva API会自动确定哪个组合是有效的，并且只会对有效的数据组合进行切割。在这种体验中，用户不需要知道任何有关所涉及指标来源的底层物理表的信息。&lt;/p&gt;&lt;h3&gt;与Apache Superset集成&lt;/h3&gt;&lt;p&gt;虽然Metrics Explorer提供了有关参数的高级信息，但更有探索精神的用户可以在Superset中进行更多操作。Apache Superset&lt;span&gt;[10]&lt;/span&gt;是Airbnb自助BI解决方案的核心工具。考虑到Superset在公司内的广泛应用，我们知道需要提供类SQL的功能，从而与Superset进行集成，以便Minerva能够被广泛采用。&lt;/p&gt;&lt;p&gt;用于Apache Superset和Tableau等BI工具的客户端接口要复杂得多，很多应用可以选择直接通过RESTful接口调用Minerva API。这些BI工具通常使用SQL（通过客户端），而不是HTTP请求进行访问。这意味着Minerva API需要支持类SQL接口，该接口需要遵循OLAP&lt;span&gt;[11]&lt;/span&gt;查询结构。为了构建这样一个接口，我们利用sqlparse&lt;span&gt;[12]&lt;/span&gt;在Minerva API中添加了一个SQL解析器，用于将SQL语句解析为AST，然后对其进行验证并将其转换为本地HTTP请求。&lt;/p&gt;&lt;p&gt;遵循DRY原则，我们复用Apache Calcite Avatica&lt;span&gt;[13]&lt;/span&gt;定义了客户机和服务器之间的通用数据库连接API。Minerva API充当Avatica HTTP服务器，客户端要么是基于SQLAlchemy&lt;span&gt;[14]&lt;/span&gt;定制的Python Database API&lt;span&gt;[15]&lt;/span&gt;数据库驱动程序，要么是Avatica提供的JDBC连接器（Tableau）。&lt;/p&gt;&lt;p&gt;传统BI工具在工具内部实现自定义业务逻辑，而Minerva通过类SQL的AGG指标表达式来整合这些逻辑。下表中，我们比较了在传统BI工具和Superset工具中运行的查询：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.38285714285714284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwnNolUUBgwMomibfzWB1vUM6MyD9rkIGPK2EbYJ9wFhA1WhAbwDYDvog/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;在左边的查询中，用户不需要指定指标应该从哪里计算，也不需要指定正确的聚合函数——这些细节都被Minerva抽象了。&lt;/p&gt;&lt;p&gt;最后，假设Minerva中有12,000个指标和5,000个维度，但并不是所有的指标-维度组合都是有效的。例如，活动列表可以通过主机所在的位置来切割，但不能通过客人的出发位置来切割（也就是说，每个预订的客人属性可能不同）。我们在图表控件中添加了事件监听器，以确保左侧视窗中只显示符合条件的指标和维度的组合。这种设计有助于减少认知负载，简化数据挖掘过程。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.54&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwNmrYIOS4mZ48mwOgP2MjahacMqiaJjYBva3AfeMtVicZHCe5Y12oQsMw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Superset是以指标为中心的，用户可以从单个虚拟源查询所有指标和维度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;与XRF（eXecutive Reporting Framework）集成&lt;/h3&gt;&lt;p&gt;如&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247483890&amp;amp;idx=1&amp;amp;sn=b91ffef8a8c32fe24439afa367b0205a&amp;amp;chksm=fc73bc29cb04353f2de39edcd82c90e5300d1374b3a0806603bf8cb6b894d54043eb04ae0366&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第一篇&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;第一篇&lt;/a&gt;所述，XRF是一个框架，用于生成由执行人员和领导团队使用的简洁、高保真的业务关键报告。这个框架是通过Minerva的配置来配置的，并且完全由Minerva API提供支持。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.37142857142857144&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwHnIyFUVZ9RiapG07O5Lu1jU5hJPtd4AJg7n6mdJKuWVhQ6D1iasmW1Xg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;XRF自动化了大量重复的手工工作，并允许我们标准化高保真的业务关键报告&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;要管理XRF报告，用户首先需要定义报告配置，并指定所需的业务指标、维度切片以及需要应用的全局筛选器。此外，用户还可以配置其他控制行为，比如某个指标是否需要执行聚合（如MTD、QTD或YTD）操作，以及为基于时间的比较增长率（如YoY、MoM或WoW）指定合适的单位。一旦指定了这些设置，Minerva API就会执行必要的聚合操作以及生成最终的报告。&lt;/p&gt;&lt;p&gt;XRF输出的数据可以通过自定义GoogleSheetHook渲染在Google表格中，也可以通过Presto连接到Tableau中。通过利用Minerva及其聚合逻辑中的指标定义，我们在用户选择的表示层中强制执行一致性保障。&lt;/p&gt;&lt;h3&gt;与ERF（Experimentation Reporting Framework）集成&lt;/h3&gt;&lt;p&gt;与分析或报告用例不同，实验用例比较特殊，用于报告的指标只是一个起点。为了做出正确的因果推论，在将指标转换为可用于有效统计比较的汇总统计数据之前，必须将指标与实验分配的数据结合起来。&lt;/p&gt;&lt;p&gt;通常，Minerva向ERF提供“原始事件”。根据随机单元和分析单元，我们使用不同的主题键将Minerva数据加入到分配日志中，以便每个事件都有相关的主题，以及与之相关的实验组。最后计算并汇总统计信息（如平均值、百分比变化和p值）并显示在ERF记分卡中。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.22857142857142856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwuEZiaJJXzg1Rla8FSAcRluhjyBMNh0scr6gR44Sndh5ETjgViaRKUQvQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显示实验统计摘要的ERF记分卡&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;实验UI还会直接显示相关的Minerva元数据，用户还可以查看Minerva事件的描述和所有权信息。一个带有ETA信息的谱系视图允许用户跟踪ERF指标进展&lt;span&gt;[16]&lt;/span&gt;，并帮助他们在出现延迟的情况下联系相关的Minerva指标所有者。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.35619047619047617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VVcUKEa0ClxT4hXADLJuAwldLsps0RoaiaQUl0icOHbqF9Kj4XpQDIIWz2ia2SXyAx0v8W6ZvPc8XfA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ERF显示指标元数据，链接到SLA Tracker[17]从而可视化数据谱系和时间线&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;总之，Minerva及其多种集成工具帮助用户能够在他们的计划报告中轻松跟踪指标，测量实验产生的变化，并探索意外的变化——所有这些都让用户相信数据是正确和一致的，这种信心极大的减少了获取洞察所花费的时间，增加了对数据的信任，并有助于支持数据驱动的决策。&lt;/p&gt;&lt;h1&gt;尾声&lt;/h1&gt;&lt;p&gt;Minerva引入了一种思考数据的新方法，不仅意味着以业务和指标为中心的用户接口，还需要我们调整传统BI工具（主要使用SQL）来适应Minerva API的接口。在某种意义上，这类似于将一个新的方钉（Minerva）插入一个现有的圆孔（BI Tools）中。&lt;/p&gt;&lt;p&gt;随着越来越多的组织接受类似Minerva的指标层的理念，我们相信将会有一系列新的挑战等着我们。也就是说，一些开创性的工作肯定会把分析带到新的水平，我们为能够为这一领域做出创新工作而感到自豪，我们也希望会有更多公司跟我们一样在这一领域做出贡献。&lt;/p&gt;&lt;h1&gt;感谢&lt;/h1&gt;&lt;p&gt;感谢每一个为这篇博文所介绍的工作和成果做出贡献的人&lt;span&gt;[18]&lt;/span&gt;。除了之前的致谢，我们还想感谢那些与我们合作，在工作中采用Minerva的人。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;所有商标都是各自所有者的财产，相关资料的使用仅用于身份识别的目的，并不意味着赞助或背书。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Reference:&lt;/span&gt;&lt;br/&gt;[1] https://medium.com/airbnb-engineering/how-airbnb-enables-consistent-data-consumption-at-scale-1c0b6a8b9206&lt;br/&gt;[2] https://superset.apache.org/&lt;br/&gt;[3] https://www.tableau.com/&lt;br/&gt;[4] https://www.python.org/&lt;br/&gt;[5] https://www.r-project.org/&lt;br/&gt;[6] https://www.jstatsoft.org/article/view/v040i01&lt;br/&gt;[7] https://medium.com/airbnb-engineering/supercharging-apache-superset-b1a2393278bd#c576&lt;br/&gt;[8] https://medium.com/airbnb-engineering/how-airbnb-achieved-metric-consistency-at-scale-f23cc53dea70#efb9&lt;br/&gt;[9] https://www.elastic.co/elasticsearch/&lt;br/&gt;[10] https://medium.com/airbnb-engineering/supercharging-apache-superset-b1a2393278bd&lt;br/&gt;[11] https://en.wikipedia.org/wiki/Online_analytical_processing&lt;br/&gt;[12] https://pypi.org/project/sqlparse/v&lt;br/&gt;[13] https://calcite.apache.org/avatica/&lt;br/&gt;[14] https://www.sqlalchemy.org/&lt;br/&gt;[15] https://www.python.org/dev/peps/pep-0249/&lt;br/&gt;[16] https://medium.com/airbnb-engineering/visualizing-data-timeliness-at-airbnb-ee638fdf4710&lt;br/&gt;[17] https://medium.com/airbnb-engineering/visualizing-data-timeliness-at-airbnb-ee638fdf4710&lt;br/&gt;[18] https://medium.com/airbnb-engineering/how-airbnb-achieved-metric-consistency-at-scale-f23cc53dea70#8a0a&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>89c6c3bbc14bec68c0f30453039035ff</guid>
<title>深入理解 Java 泛型与类型擦除</title>
<link>https://toutiao.io/k/cltui92</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0OTYwNTQ4Ng==&amp;amp;action=getalbum&amp;amp;album_id=2079436762237419520#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2079436762237419520&quot; data-tag_source=&quot;1&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#Java&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;1个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nKovjAe6Lrp9wQ11qlueRuuicrmq5DmFqIhXavbHjVPhpRvYyCzziciaHzNKVICicE5et9fzZlh9mV8AfEosGgxQ9A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;1. 什么是泛型&lt;/h2&gt;&lt;p&gt;Java 1.5 发行版本中增加了泛型(Generic)。在没有泛型之前，从集合中读取到的每一个对象都必须进行装换。如果有人不小心插入了类型错误的对象，在运行时的装换处理器就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动为你的插入进行转化，并在编译器告知是否插入了类型错误对象。&lt;/p&gt;&lt;p&gt;那什么是泛型呢？声明中具有一个或者多个类型参数的类或者接口就是泛型类或者接口。例如，从 Java 1.5 发行版本开始，List 接口就只有单个类型参数 E，表示列表的元素类型。从技术的角度看，这个接口的名称应该是指现在的 &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;，但是人们经常把它简称为 List。泛型类和接口都统称为泛型。每种泛型定义一组参数化的类型，构成格式为：先是类和接口的名称，接着用尖括号(‘&amp;lt;&amp;gt;’)把对应于泛型形式类型参数的实际类型参数列表括起来。例如，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 是一个参数化的类型，表示元素类型为 String 的列表。String 是与形式类型参数 E 相对应的实际类型参数。&lt;/p&gt;&lt;p&gt;泛型都定义一个原生态类型，即不带任何实际类型参数的泛型名称。例如，与 &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; 相对应的原生态类型是 List。原生态类型就像从类型声明中删除了所有泛型信息一样。实际上，原生态类型 List 与 Java 没有泛型之前的接口类型 List 完全一样。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;术语&lt;/th&gt;&lt;th&gt;示例&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;泛型&lt;/td&gt;&lt;td&gt;&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;形式类型参数&lt;/td&gt;&lt;td&gt;E&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;参数化的类型&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实际类型参数&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;原生态类型&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;有限制类型参数&lt;/td&gt;&lt;td&gt;&lt;code&gt;&amp;lt;E extends NUmber&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;2. 为什么使用泛型&lt;/h2&gt;&lt;p&gt;使用泛型的代码比非泛型代码有很多好处。&lt;/p&gt;&lt;h3&gt;2.1 类型安全&lt;/h3&gt;&lt;p&gt;Java 编译器对泛型代码应用强类型检查，如果代码违反类型安全就会发出错误。修复编译时错误比修复运行时错误更容易，因为运行时错误很难排查。&lt;/p&gt;&lt;p&gt;假设在 Java 1.5 发行版本之前，我们使用 List 定义了一个只保存正方形对象的列表 squareList。如果不小心将一个长方形对象放进了列表中，这一错误插入照样编译和运行并且不会出现任何错误，直到我们从列表中获取正方形对象的时候才会受到错误提示：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;// 目标是定义一个只保存正方形的列表&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;List squareList = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;squareList.add(&lt;span&gt;new&lt;/span&gt; Square(&lt;span&gt;4&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;squareList.add(&lt;span&gt;new&lt;/span&gt; Square(&lt;span&gt;2&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 误添加一个长方形&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;squareList.add(&lt;span&gt;new&lt;/span&gt; Rectangle(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; (Object square : squareList) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    Square s = (Square) square; &lt;span&gt;// throw ClassCastException&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    System.out.println(s.getArea());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;到了运行阶段发现错误再排查就难得多了，出错之后应该尽快发现，最好是在编译阶段就被发现。有了泛型，我们就可以利用改进后的类型声明来告诉编译器我们要的是一个正方形对象的列表：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;List&amp;lt;Square&amp;gt; squareList = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;通过这条声明，编译器知道 squareList 应该只包含 Square 实例，并会给予保证，准确的告诉我们哪里出错了：&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;204&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.35247524752475246&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrp9wQ11qlueRuuicrmq5DmFqzbyricibEs78BurtfDDDK8yaAUaW8rHqxLIzj3SPj5mIgL2oTGdbmeQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;505&quot;/&gt;&lt;/section&gt;&lt;h3&gt;2.2 无需强制类型转换&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;下面没有泛型的代码片段需要强制类型转换:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;List list = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;list.add(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;String s = (String) list.get(&lt;span&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当重写为使用泛型时，代码不需要强制类型转换:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;list.add(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;String s = list.get(&lt;span&gt;0&lt;/span&gt;);   &lt;span&gt;// no cast&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3&gt;2.3 其他&lt;/h3&gt;&lt;p&gt;此外，还可以提升可读性，从编码阶段就知道泛型类、泛型方法等处理的对象类型是什么；还可以提高代码的复用，泛型合并了同类型的处理代码，使代码的重用度提高。&lt;/p&gt;&lt;h2&gt;3. 泛型的实现方法：类型擦除&lt;/h2&gt;&lt;p&gt;类型擦除可以理解为泛型只是在编译时强制执行类型约束，并在运行时丢弃（或者擦除）元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用。类型擦除可以发生在类（或变量）以及方法级别。&lt;/p&gt;&lt;h3&gt;3.1 泛型类的类型擦除&lt;/h3&gt;&lt;p&gt;在类型擦除过程中，Java 编译器擦除所有类型参数，如果类型参数是有限制的，则使用其第一个限制参数替换每个类型参数，如果类型参数不受限制，则用 Object 替换。考虑以下表示单向链表节点的泛型类：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; T data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; Node&amp;lt;T&amp;gt; next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(T data, Node&amp;lt;T&amp;gt; next)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;getData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;由于类型参数 T 不受限制，因此 Java 编译器将其替换为 Object：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; Object data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; Node next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(Object data, Node next)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在下面的例子中，泛型 Node 类使用了一个有限制的类型参数：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; T data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; Node&amp;lt;T&amp;gt; next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(T data, Node&amp;lt;T&amp;gt; next)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;getData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;Java 编译器将有限制的类型参数 T 替换为第一受限类 Comparable:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; Comparable data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; Node next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(Comparable data, Node next)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Comparable &lt;span&gt;getData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3&gt;3.2 泛型方法的类型擦除&lt;/h3&gt;&lt;p&gt;Java 编译器还会擦除泛型方法参数中的类型参数。考虑以下泛型方法：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;// 计算元素 elem 在数组中出现的次数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;&lt;span&gt;(T[] anArray, T elem)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;for&lt;/span&gt; (T e : anArray)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;if&lt;/span&gt; (e.equals(elem))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            ++cnt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;return&lt;/span&gt; cnt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;因为 T 是非限制类型参数，Java 编译器将它替换为 Object:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;&lt;span&gt;(Object[] anArray, Object elem)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;for&lt;/span&gt; (Object e : anArray)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;if&lt;/span&gt; (e.equals(elem))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            ++cnt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;return&lt;/span&gt; cnt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;假设定义了以下类:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Shape&lt;/span&gt; { &lt;span&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Circle&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Shape&lt;/span&gt; { &lt;span&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Rectangle&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Shape&lt;/span&gt; { &lt;span&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们可以编写一个泛型方法来绘制不同的形状:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T extends Shape&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;draw&lt;/span&gt;&lt;span&gt;(T shape)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;Java 编译器会用 Shape 替换 T:&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;draw&lt;/span&gt;&lt;span&gt;(Shape shape)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3&gt;3.3 类型擦除与桥方法&lt;/h3&gt;&lt;p&gt;现在有这样一个泛型类：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;public&lt;/span&gt; T data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(T data)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.data = data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setData&lt;/span&gt;&lt;span&gt;(T data)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(&lt;span&gt;&quot;Node.setData&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后我们想要一个子类继承它：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyNode&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;MyNode&lt;/span&gt;&lt;span&gt;(Integer data)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;super&lt;/span&gt;(data); }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setData&lt;/span&gt;&lt;span&gt;(Integer data)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(&lt;span&gt;&quot;MyNode.setData&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;super&lt;/span&gt;.setData(data);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在这个子类中，我们设定父类的参数化的类型为 Node&lt;integer&gt;，在子类中我们覆盖了父类的方法，我们的本意是：将父类的泛型类型限定为 Integer，那么父类里面方法的参数为 Integer 类型：&lt;br/&gt;&lt;/integer&gt;&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;public&lt;/span&gt; Integer data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(Integer data)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.data = data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setData&lt;/span&gt;&lt;span&gt;(String data)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(&lt;span&gt;&quot;Node.setData&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;所以，我们在子类中重写这个方法一点问题也没有，另外从 &lt;code&gt;@Override&lt;/code&gt; 标签中也可以看到没什么问题，实际上是这样的吗？实际上，类型擦除后，父类的的泛型实际类型参数全部变为了 Object，所以父类编译之后会变成下面的样子：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;public&lt;/span&gt; Object data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.data = data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setData&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(&lt;span&gt;&quot;Node.setData&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们来分析一下 setData 方法，父类的类型是 Object，而子类的类型是 Integer，参数类型不一样，如果是在普通的继承关系中，根本就不会是重写，而是重载。我们在一个 main 方法测试一下：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException &lt;/span&gt;{  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;  MyNode myNode = &lt;span&gt;new&lt;/span&gt; MyNode();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  myNode.setData(&lt;span&gt;123&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  myNode.setData(&lt;span&gt;new&lt;/span&gt; Object()); &lt;span&gt;//编译错误&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果是重载，那么子类中 setData 方法应该有两个，一个是参数 Object 类型，一个是 Integer 类型，可是我们发现，根本就没有这样的一个子类继承自父类的 Object 类型参数的方法。所以说，确实是重写了，而不是重载了。为什么会这样呢？原因是我们传入父类的泛型实际类型参数是 Integer，我们的本意是将泛型类变为如下：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;public&lt;/span&gt; Integer data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(Integer data)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.data = data; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setData&lt;/span&gt;&lt;span&gt;(String data)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(&lt;span&gt;&quot;Node.setData&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后在子类中重写参数类型为 Integer 的方法，实现继承中的多态。可是由于种种原因，虚拟机并不能将泛型实际类型参数变为 Integer，只能将类型擦除掉，变为 Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM 知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的 Integer 类型参数的方法呢。于是 JVM 采用了一个特殊的方法，来完成这项功能，那就是桥方法：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyNode&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;MyNode&lt;/span&gt;&lt;span&gt;(Integer data)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;super&lt;/span&gt;(data); }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// 编译器生成的桥方法&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setData&lt;/span&gt;&lt;span&gt;(Object data)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        setData((Integer) data);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setData&lt;/span&gt;&lt;span&gt;(Integer data)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(&lt;span&gt;&quot;MyNode.setData&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;super&lt;/span&gt;.setData(data);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到桥方法的参数类型都是 Object，也就是说，子类中真正覆盖父类方法的就是这个我们看不到的桥方法。而打在我们自己定义的 setData 方法上面的 &lt;code&gt;@Overide&lt;/code&gt; 只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。&lt;/p&gt;&lt;h2&gt;4. 泛型类型擦除证明&lt;/h2&gt;&lt;p&gt;我们通过两个例子来证明泛型的类型擦除。第一个例子中，我们定义了两个 List 数组：第一个是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 泛型类型的字符串列表，只能存储字符串，另一个是 &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; 泛型类型的数值型列表，只能存储整数。最后，我们通过 strList 对象和 intList 对象的 getClass() 方法获取他们的类的信息，最后发现结果为 true。说明 String 和 Integer 实际类型参数都被擦除掉了，只剩下原始类型：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;// 字符串列表&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ArrayList&amp;lt;String&amp;gt; strList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;strList.add(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 数值型列表&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ArrayList&amp;lt;Integer&amp;gt; intList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;intList.add(&lt;span&gt;123&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// strList: class java.util.ArrayList&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;System.out.println(&lt;span&gt;&quot;strList: &quot;&lt;/span&gt; + strList.getClass());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// intList: class java.util.ArrayList&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;System.out.println(&lt;span&gt;&quot;intList: &quot;&lt;/span&gt; + intList.getClass());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;System.out.println(strList.getClass() == intList.getClass());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在第二个例子中，我们定义了一个 &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; 泛型类型的数值型列表。如果直接调用 add() 方法，那么只能存储整数数据，如果我们利用反射调用 add() 方法的时候，却可以存储字符串，这说明了 Integer 实际类型参数在编译之后被擦除掉了，只保留了原始类型 List：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 直接调用 add 方法只能存储整形，因为泛型实际类型为 Integer&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 反射方式调用 add 方法可以存储字符串&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;list.getClass().getMethod(&lt;span&gt;&quot;add&quot;&lt;/span&gt;, Object.class).invoke(list, &lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    System.out.println(list.get(i));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2&gt;5. 类型擦除带来的限制&lt;/h2&gt;&lt;p&gt;因为种种原因，Java 不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN 对这些问题做出了种种限制，避免我们发生各种错误。&lt;/p&gt;&lt;h3&gt;5.1 自动类型转换&lt;/h3&gt;&lt;p&gt;因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？看下ArrayList.get()方法：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    rangeCheck(index);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; elementData(index);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;E &lt;span&gt;elementData&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; (E) elementData[index];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到，在 return 之前，会根据泛型变量进行强制类型转换。假设泛型实际类型参数为 String，虽然泛型类型参数会被擦除，但是会将(E) elementData[index]，编译为 (String)elementData[index]。所以我们不用自己进行强制类型转换。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这一条严格来说不是限制，只是一种说明&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;5.2 无法创建形式类型参数的实例&lt;/h3&gt;&lt;p&gt;我们无法创建形式类型参数的实例。例如，如下代码会导致编译时错误：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(List&amp;lt;E&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    E elem = &lt;span&gt;new&lt;/span&gt; E();  &lt;span&gt;// compile-time error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    list.add(elem);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;作为解决方法，我们可以通过反射创建类型参数的对象：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(List&amp;lt;E&amp;gt; list, Class&amp;lt;E&amp;gt; cls)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    E elem = cls.newInstance();   &lt;span&gt;// OK&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    list.add(elem);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们可以按如下方式调用 append 方法：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;List&amp;lt;String&amp;gt; ls = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;append(ls, String.class);&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3&gt;5.3 泛型实际类型参数不能是基本数据类型&lt;/h3&gt;&lt;p&gt;泛型实际类型参数不能是基本数据类型，我们可以通过使用基本包装类型来避开这个限制。考虑以下参数化类型：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pair&lt;/span&gt;&amp;lt;&lt;span&gt;K&lt;/span&gt;, &lt;span&gt;V&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; K key;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; V value;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Pair&lt;/span&gt;&lt;span&gt;(K key, V value)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;this&lt;/span&gt;.value = value;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;创建 Pair 对象时，不能用原始类型替换类型参数 K 或 V：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;Pair&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;char&lt;/span&gt;&amp;gt; p = &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;);  &lt;span&gt;// compile-time error&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们可以使用基本包装类型替换类型参数 K 和 V：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;Pair&amp;lt;Integer, Character&amp;gt; p = &lt;span&gt;new&lt;/span&gt; Pair&amp;lt;&amp;gt;(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3&gt;5.4 不能对参数化的类型使用 Casts 或 instanceof&lt;/h3&gt;&lt;p&gt;因为 Java 编译器会擦除泛型代码中的所有类型参数，所以运行时我们无法验证泛型类型正在使用的是哪个参数化的类型：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;rtti&lt;/span&gt;&lt;span&gt;(List&amp;lt;E&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;if&lt;/span&gt; (list &lt;span&gt;instanceof&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;) {  &lt;span&gt;// compile-time error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;运行时不跟踪类型参数，因此无法区分 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;&lt;/code&gt; 和   &lt;code&gt;ArrayList&amp;lt;String&amp;gt;&lt;/code&gt; 之间的区别。我们最多可以使用无界通配符来验证 List 是否为 ArrayList：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rtti&lt;/span&gt;&lt;span&gt;(List&amp;lt;?&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;if&lt;/span&gt; (list &lt;span&gt;instanceof&lt;/span&gt; ArrayList&amp;lt;?&amp;gt;) {  &lt;span&gt;// OK; instanceof requires a reifiable type&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3&gt;5.5 不能声明类型为类型参数的静态字段&lt;/h3&gt;&lt;p&gt;类的静态字段是类的所有非静态对象共享的类级变量。因此，不允许使用类型参数的静态字段。考虑以下类：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MobileDevice&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T os;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果允许类型参数的静态字段，那么下面的代码会被混淆：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;MobileDevice&amp;lt;Smartphone&amp;gt; phone = &lt;span&gt;new&lt;/span&gt; MobileDevice&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MobileDevice&amp;lt;Pager&amp;gt; pager = &lt;span&gt;new&lt;/span&gt; MobileDevice&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MobileDevice&amp;lt;TabletPC&amp;gt; pc = &lt;span&gt;new&lt;/span&gt; MobileDevice&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;因为静态字段 os 是 phone、pager、pc 共享的，那么 os 的实际类型是什么？不能同时是 Smartphone、Pager 和 TabletPC。因此，我们不能创建类型参数的静态字段。&lt;/p&gt;&lt;h3&gt;5.6 无法创建参数化类型的数组&lt;/h3&gt;&lt;p&gt;我们不能创建参数化类型的数组。例如，如下代码无法编译：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;List&amp;lt;Integer&amp;gt;[] arrayOfLists = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Integer&amp;gt;[&lt;span&gt;2&lt;/span&gt;];  &lt;span&gt;// compile-time error&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如下代码说明了将不同类型插入数组时会发生什么：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;Object[] strings = &lt;span&gt;new&lt;/span&gt; String[&lt;span&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;strings[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;&quot;hi&quot;&lt;/span&gt;;   &lt;span&gt;// OK&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;strings[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;100&lt;/span&gt;;    &lt;span&gt;// An ArrayStoreException is thrown.&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果你用泛型 List 尝试同样的事情，就会出现问题：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;Object[] stringLists = &lt;span&gt;new&lt;/span&gt; List&amp;lt;String&amp;gt;[&lt;span&gt;2&lt;/span&gt;];  &lt;span&gt;// compiler error, but pretend it&#x27;s allowed&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;stringLists[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();   &lt;span&gt;// OK&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;stringLists[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();  &lt;span&gt;// An ArrayStoreException should be thrown,&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                                            &lt;span&gt;// but the runtime can&#x27;t detect it.&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果允许参数化 List 的数组，则上面的代码无法抛出所需的 ArrayStoreException。&lt;/p&gt;&lt;h3&gt;5.7 无法创建、捕获或抛出参数化类型的对象&lt;/h3&gt;&lt;p&gt;泛型类不能直接或间接扩展 Throwable 类。例如，如下类将无法编译：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;// Extends Throwable indirectly&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MathException&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt; { &lt;span&gt;/* ... */&lt;/span&gt; }    &lt;span&gt;// compile-time error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// Extends Throwable directly&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;QueueFullException&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Throwable&lt;/span&gt; { &lt;span&gt;/* ... */&lt;/span&gt; &lt;span&gt;// compile-time error&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;方法无法捕获类型参数的实例：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T extends Exception, J&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(List&amp;lt;J&amp;gt; jobs)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;for&lt;/span&gt; (J job : jobs)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    } &lt;span&gt;catch&lt;/span&gt; (T e) {   &lt;span&gt;// compile-time error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;但是，我们可以在 throws 子句中使用类型参数：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parser&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(File file)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; T &lt;/span&gt;{     &lt;span&gt;// OK&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;欢迎关注我的公众号和博客：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nKovjAe6LrqPP36RWGmwXAHAUPcg48ibQzRb82UubkaEj0K8CANwdefia4cJZK3B0jiavicU35I08Z8lbgeFzibJofw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ddf916061ce9d99f3f0eed30b17a6577</guid>
<title>开源｜一款本地优先的个人知识管理系统</title>
<link>https://toutiao.io/k/mksehc8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;一款本地优先的个人知识管理系统，支持细粒度块级引用和 Markdown 所见即所得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.6133333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ40yO6oWpG0FibQH7RwiaE55zn5RjbSzxsAyzX8xFJO9IWdTQETrgdLE0V1MtuiazoaVXb0ibic6Wk1npg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;以上内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>