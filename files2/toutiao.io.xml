<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4263927c7ac1557996ddd2c6f313f968</guid>
<title>Spring Boot 2 集成测试组件，七种测试手段对比</title>
<link>https://toutiao.io/k/3db8n15</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、背景描述&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在版本开发中，时间段大致的划分为：需求，开发，测试；&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需求阶段：理解需求做好接口设计；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发阶段：完成功能开发和对接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试上线：自测，提测，修复，上线；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实际上开发阶段两个核心的工作，开发和流程自测，自测的根本目的是为自己提前解决可能出现的问题；如果缺少自测和提测两个关键步骤，那么问题就会被传递给更多的用户，产生更多的资源消耗；&lt;/p&gt;&lt;p&gt;自测是于开发而言，提测是对专业的测试人员而言，如果尽可能在自测阶段就发现问题，并解决问题，那么一个问题就不会影响到团队协作上的更多人员，&lt;span&gt;&lt;strong&gt;如果一个简单的问题上升到团队协作层面，很可能会导致问题本身被放大&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;工欲善其事必先利其器，开发如果要做好自测流程，学会使用工具提高效率是十分关键的，自测的关键在于发现问题和解决问题，所以选择好用和高效的工具可以极大的降低自测的时间消耗。&lt;/p&gt;&lt;p&gt;下面围绕几个自己开发过程中常用的测试工具和手段，做简单的总结，&lt;span&gt;&lt;strong&gt;不在于对比方式的好坏，存在即合理，在不同场景中对合理手段的选择，快速解决问题才是根本目的&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、PostMan工具&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;PostMan很常用的接口测试工具，开发过程中快速测试接口，功能强大并且简单方便，不但可以单个接口测试，也可以对接口分块管理批量运行：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCibyeRmHarPoYfo6rCBBxJqBLeHXUZmvpGTYNn7foxOqrqHUGYm6Xnq2CpyqSYibtr2SACyPVVXZuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;整体来说工具比较好用，适应于开发阶段的接口快速测试，或者在解决问题的过程中单个接口的测试，同时对测试参数有存储和记忆能力，这也是受欢迎的一大原因。&lt;/p&gt;&lt;p&gt;但是该工具不适应于复杂的流程化测试，例如需要根据上次接口的响应报文做分别处理，或者下次请求需要填充某个接口响应的数据。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、Swagger文档&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;Swagger管理接口文档，是当下服务中很常用的组件，通过对接口和对象的简单注释，快速生成接口描述信息，并且可以对接口发送请求，协助调试，该文档在前后端联调中极大的提高效率。&lt;/p&gt;&lt;p&gt;接口文档的管理本身是一件麻烦事，接口通常会根据业务不断的调整，如果单独维护一份接口文档，需要付出很多时间成本，并且容易出问题，利用swagger就可以避免这个问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;借助swagger注解标记对象&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@TableName&lt;/span&gt;(&lt;span&gt;&quot;jt_activity&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@ApiModel&lt;/span&gt;(value=&lt;span&gt;&quot;活动PO对象&quot;&lt;/span&gt;, description=&lt;span&gt;&quot;活动信息表【jt_activity】&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Activity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiModelProperty&lt;/span&gt;(value = &lt;span&gt;&quot;主键ID&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@TableId&lt;/span&gt;(type = IdType.AUTO)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiModelProperty&lt;/span&gt;(value = &lt;span&gt;&quot;活动主题&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String activityTitle;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiModelProperty&lt;/span&gt;(value = &lt;span&gt;&quot;联系号码&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String contactPhone;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiModelProperty&lt;/span&gt;(value = &lt;span&gt;&quot;1线上、2线下&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer isOnline;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiModelProperty&lt;/span&gt;(value = &lt;span&gt;&quot;举办地址&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String address;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiModelProperty&lt;/span&gt;(value = &lt;span&gt;&quot;主办单位&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String organizer;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiModelProperty&lt;/span&gt;(value = &lt;span&gt;&quot;创建时间&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Date createTime;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;借助swagger注解标记接口&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Api&lt;/span&gt;(tags = &lt;span&gt;&quot;活动主体接口&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityWeb&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ActivityService activityService ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiOperation&lt;/span&gt;(&lt;span&gt;&quot;新增活动&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/activity&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;save&lt;/span&gt; &lt;span&gt;(@RequestBody Activity activity)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        activityService.save(activity) ;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; activity.getId() ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiOperation&lt;/span&gt;(&lt;span&gt;&quot;主键查询&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/activity/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Activity &lt;span&gt;getById&lt;/span&gt; &lt;span&gt;(@PathVariable(&lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; Integer id)&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; activityService.getById(id) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ApiOperation&lt;/span&gt;(&lt;span&gt;&quot;修改活动&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@PutMapping&lt;/span&gt;(&lt;span&gt;&quot;/activity&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Boolean &lt;span&gt;updateById&lt;/span&gt; &lt;span&gt;(@RequestBody Activity activity)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; activityService.updateById(activity) ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.346875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCibyeRmHarPoYfo6rCBBxJqOm2XMic7kjwthpiaqvRhDicUIu8SjVwhicQ8x5cJmGPzuzrWmKBEsAuy7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通常来说，基于swagger注解标记接口类和方法上的入参和关键返参对象即可，这样可以避免再单独维护接口文档。&lt;/p&gt;&lt;p&gt;Swagger接口文档在开发的过程中更多是扮演文档的角色，真正使用swagger去调试的接口也常是一些增删改查的简单接口，这个工具也同样不适应于复杂流程的测试。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、TestRestTemplate类&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;SpringBoot测试包中集成的测试API，需要依赖测试包，可以访问控制层接口，非常方便的完成交互过程：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Jar包依赖&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;使用案例&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;SpringBootTest&lt;/span&gt;(&lt;span&gt;webEnvironment&lt;/span&gt; &lt;/span&gt;= SpringBootTest.WebEnvironment.RANDOM_PORT)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityTest01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(ActivityTest01&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestRestTemplate restTemplate;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Activity activity = &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;    &lt;span&gt;@Before&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;before&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        activity = restTemplate.getForObject(&lt;span&gt;&quot;/activity/{id}&quot;&lt;/span&gt;, Activity&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,1)&lt;/span&gt;;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;+JSONUtil.toJsonPrettyStr(activity));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateById&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (activity != &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;            activity.setCreateTime(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;            activity.setOrganizer(&lt;span&gt;&quot;One商家&quot;&lt;/span&gt;);&lt;br/&gt;            restTemplate.put(&lt;span&gt;&quot;/activity&quot;&lt;/span&gt;,activity);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@After&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;after&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        activity = restTemplate.getForObject(&lt;span&gt;&quot;/activity/{id}&quot;&lt;/span&gt;, Activity&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,1)&lt;/span&gt;;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;\n&quot;&lt;/span&gt;+JSONUtil.toJsonPrettyStr(activity));&lt;br/&gt;        activity = &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在TestRestTemplate源码中可以发现，基于RestTemplate做封装，很多功能的实现都是调用RestTemplate方法。&lt;/p&gt;&lt;p&gt;用写代码的方式去实现接口测试，灵活度非常高，可以根据流程做定制开发，很适应于中等复杂的场景测试，这里为什么这样描述，下面对比Http请求再细说。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、Http请求模式&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;通过模拟接口的Http请求实现的方式，目前来说个人感觉灵活的最高的方式，先看简单的案例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;SpringBootTest&lt;/span&gt;(&lt;span&gt;webEnvironment&lt;/span&gt; &lt;/span&gt;= SpringBootTest.WebEnvironment.DEFINED_PORT)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityTest03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(ActivityTest03&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String REQ_URL = &lt;span&gt;&quot;服务地址+端口&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testHttp&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 查询&lt;/span&gt;&lt;br/&gt;        String getRes = HttpUtil.get(REQ_URL+&lt;span&gt;&quot;activity/1&quot;&lt;/span&gt;);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;\n {} &quot;&lt;/span&gt;,JSONUtil.toJsonPrettyStr(getRes));&lt;br/&gt;        Activity activity = JSONUtil.toBean(getRes, Activity&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 新增&lt;/span&gt;&lt;br/&gt;        activity.setId(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        activity.setOrganizer(&lt;span&gt;&quot;Http商家&quot;&lt;/span&gt;);&lt;br/&gt;        String saveRes = HttpUtil.post(REQ_URL+&lt;span&gt;&quot;/activity&quot;&lt;/span&gt;,JSONUtil.toJsonStr(activity));&lt;br/&gt;        logger.info(&lt;span&gt;&quot;\n {} &quot;&lt;/span&gt;,saveRes);&lt;br/&gt;        &lt;span&gt;// 更新&lt;/span&gt;&lt;br/&gt;        activity.setId(Integer.parseInt(saveRes));&lt;br/&gt;        activity.setOrganizer(&lt;span&gt;&quot;Put商家&quot;&lt;/span&gt;);&lt;br/&gt;        String putRes = HttpRequest.put(REQ_URL+&lt;span&gt;&quot;/activity&quot;&lt;/span&gt;)&lt;br/&gt;                .body(JSONUtil.toJsonStr(activity)).execute().body();&lt;br/&gt;        logger.info(&lt;span&gt;&quot;\n {} &quot;&lt;/span&gt;,putRes);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式对于复杂的业务流程来说非常好用，当然这里不排除个人习惯，在测试复杂流程的时候，一个简单方案：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户信息：模拟http中token数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务流程：通过数据获取包装参数模型；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立服务管理，模拟并发场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据执行过程生成分析数据结果；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于复杂业务流程的测试，每个节点的模拟都具有一定的难度，通常在完整的流程中涉及到的服务和库表都是多个，并且请求链路复杂，基于一个灵活的自动化流程，去测试完整的链路，可以对效率有极大的提升。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;六、Service层测试&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;针对服务层的测试手段，其本意在于业务实现的逻辑测试：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;SpringBootTest&lt;/span&gt;(&lt;span&gt;classes&lt;/span&gt; &lt;/span&gt;= Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityTest04&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(ActivityTest04&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ActivityService activityService ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testService&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 查询&lt;/span&gt;&lt;br/&gt;        Activity activity = activityService.getById(&lt;span&gt;1&lt;/span&gt;) ;&lt;br/&gt;        &lt;span&gt;// 新增&lt;/span&gt;&lt;br/&gt;        activity.setId(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        activityService.save(activity) ;&lt;br/&gt;        &lt;span&gt;// 修改&lt;/span&gt;&lt;br/&gt;        activity.setOrganizer(&lt;span&gt;&quot;Ser商家&quot;&lt;/span&gt;);&lt;br/&gt;        activityService.updateById(activity) ;&lt;br/&gt;        &lt;span&gt;// 删除&lt;/span&gt;&lt;br/&gt;        activityService.removeById(activity.getId()) ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试在实际的开发过程也并不常用，偶尔在于某个业务方法实现难度很大，用来针对性测试。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;七、MockMvc方式&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;MockMvc同样是SpringBoot集成测试包提供的测试方式，通过对象的模拟，验证接口是否符合预期：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@AutoConfigureMockMvc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;SpringBootTest&lt;/span&gt;(&lt;span&gt;webEnvironment&lt;/span&gt; &lt;/span&gt;= SpringBootTest.WebEnvironment.MOCK)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityTest02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(ActivityTest02&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; MockMvc mockMvc ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Activity activity = &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Before&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;before&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        ResultActions resultAction = mockMvc.perform(MockMvcRequestBuilders.get(&lt;span&gt;&quot;/activity/{id}&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)) ;&lt;br/&gt;        MvcResult mvcResult = resultAction.andReturn() ;&lt;br/&gt;        String result = mvcResult.getResponse().getContentAsString();&lt;br/&gt;        activity = JSONUtil.toBean(result,Activity&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateById&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        activity.setId(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        activity.setCreateTime(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;        activity.setOrganizer(&lt;span&gt;&quot;One商家&quot;&lt;/span&gt;);&lt;br/&gt;        ResultActions resultAction = mockMvc.perform(MockMvcRequestBuilders.post(&lt;span&gt;&quot;/activity&quot;&lt;/span&gt;)&lt;br/&gt;                                            .contentType(MediaType.APPLICATION_JSON)&lt;br/&gt;                                            .content(JSONUtil.toJsonStr(activity))) ;&lt;br/&gt;        MvcResult mvcResult = resultAction.andReturn() ;&lt;br/&gt;        String result = mvcResult.getResponse().getContentAsString();&lt;br/&gt;        activity.setId(Integer.parseInt(result));&lt;br/&gt;        logger.info(&lt;span&gt;&quot;result : {} &quot;&lt;/span&gt;,result);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@After&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;after&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        activity.setCreateTime(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;        activity.setOrganizer(&lt;span&gt;&quot;Update商家&quot;&lt;/span&gt;);&lt;br/&gt;        ResultActions resultAction = mockMvc.perform(MockMvcRequestBuilders.put(&lt;span&gt;&quot;/activity&quot;&lt;/span&gt;)&lt;br/&gt;                .contentType(MediaType.APPLICATION_JSON)&lt;br/&gt;                .content(JSONUtil.toJsonStr(activity))) ;&lt;br/&gt;        MvcResult mvcResult = resultAction.andReturn() ;&lt;br/&gt;        String result = mvcResult.getResponse().getContentAsString();&lt;br/&gt;        logger.info(&lt;span&gt;&quot;result : {} &quot;&lt;/span&gt;,result);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这种Mock类型的测试，非常专业，通常个人使用极少，暂时没有Get到其精髓思想。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;八、Mockito测试&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;Mock属于非常专业和标准的测试手段，需要依赖powermock包：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.powermock&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;powermock-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.powermock&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;powermock-api-mockito2&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.powermock&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;powermock-module-junit4&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单使用案例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RunWith&lt;/span&gt;(PowerMockRunner&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;SpringBootTest&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActivityTest05&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testMock&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        Set mockSet = PowerMockito.mock(Set&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        PowerMockito.when(mockSet.size()).thenReturn(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; actual = mockSet.size();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; expected = &lt;span&gt;15&lt;/span&gt; ;&lt;br/&gt;        Assert.assertEquals(&lt;span&gt;&quot;返回值不符合预期&quot;&lt;/span&gt;,expected, actual);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testTitle&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        String expectTitle = &lt;span&gt;&quot;Mock主题&quot;&lt;/span&gt; ;&lt;br/&gt;        Activity activity = PowerMockito.mock(Activity&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        PowerMockito.when(activity.getMockTitle()).thenReturn(expectTitle);&lt;br/&gt;        String actualTitle = activity.getMockTitle();&lt;br/&gt;        Assert.assertNotEquals(&lt;span&gt;&quot;主题相符&quot;&lt;/span&gt;, expectTitle, actualTitle);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过Mock方式，快速模拟出复杂的对象结构，以便构建测试方法，由于使用很少，同样个人暂时没Get到点。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;九、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https://github.com/cicadasmile/middle-ware-parent&lt;br/&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile/middle-ware-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7d3190adb42a365001bd8c03757f53b</guid>
<title>搞 Go 要了解的 2 个 Header，你知道吗？</title>
<link>https://toutiao.io/k/u5hnz1y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中总是有一些看上去奇奇怪怪的东西，咋一眼一看感觉很熟悉，但又不理解其在 Go 代码中的实际意义，面试官却爱问...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天要给大家介绍的是 SliceHeader 和 StringHeader 结构体，了解清楚他到底是什么，又有什么用，并且会在最后给大家介绍 0 拷贝转换的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一起愉快地开始吸鱼之路。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SliceHeader&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SliceHeader 如其名，Slice + Header，看上去很直观，实际上是 Go Slice（切片）的运行时表现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SliceHeader 的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; SliceHeader &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Data &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; Len  &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; Cap  &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Data：指向具体的底层数组。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Len：代表切片的长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cap：代表切片的容量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然知道了切片的运行时表现，那是不是就意味着我们可以自己造一个？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常程序中，可以利用标准库 &lt;code&gt;reflect&lt;/code&gt; 提供的 &lt;code&gt;SliceHeader&lt;/code&gt; 结构体造一个：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 初始化底层数组&lt;/span&gt;&lt;br/&gt; s := [&lt;span&gt;4&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;脑子&quot;&lt;/span&gt;, &lt;span&gt;&quot;进&quot;&lt;/span&gt;, &lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;, &lt;span&gt;&quot;了&quot;&lt;/span&gt;}&lt;br/&gt; s1 := s[&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt; s2 := s[:]&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 构造 SliceHeader&lt;/span&gt;&lt;br/&gt; sh1 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s1))&lt;br/&gt; sh2 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s2))&lt;br/&gt; fmt.Println(sh1.Len, sh1.Cap, sh1.Data)&lt;br/&gt; fmt.Println(sh2.Len, sh2.Cap, sh2.Data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你认为输出结果是什么，这两个新切片会指向同一个底层数组的内存地址吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1 4 824634330936&lt;br/&gt;4 4 824634330936&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个切片的 Data 属性所指向的底层数组是一致的，Len 属性的值不一样，sh1 和 sh2 分别是两个切片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;疑问&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么两个新切片所指向的 Data 是同一个地址的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实是 Go 语言本身为了减少内存占用，提高整体的性能才这么设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将切片复制到任意函数的时候，对底层数组大小都不会影响。复制时只会复制切片本身（值传递），不会涉及底层数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是在函数间传递切片，其只拷贝 24 个字节（指针字段 8 个字节，长度和容量分别需要 8 个字节），效率很高。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;坑&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种设计也引出了新的问题，在平时通过 &lt;code&gt;s[i:j]&lt;/code&gt; 所生成的新切片，两个切片底层指向的是同一个底层数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设&lt;strong&gt;在没有超过容量（cap）的情况下，对第二个切片操作会影响第一个切片&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是很多 Go 开发常会碰到的一个大 “坑”，不清楚的排查了很久的都不得而终。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;StringHeader&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 SliceHeader 外，Go 语言中还有一个典型代表，那就是字符串（string）的运行时表现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringHeader 的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; StringHeader &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;   Data &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;   Len  &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Data：存放指针，其指向具体的存储数据的内存区域。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Len：字符串的长度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可得知 “Hello” 字符串的底层数据如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; data = [...]&lt;span&gt;byte&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&#x27;h&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;e&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;l&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;l&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;o&#x27;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;底层的存储示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.571969696969697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4jfibxyw4OREA3aLy9COicDcKcqoxcxmPjL5lI5jD0PBrMWicPeAyQwUHUSB09dEM8QiaqoqxJmGibbGzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;264&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真实演示例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;&lt;br/&gt; s1 := &lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;&lt;br/&gt; s2 := &lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;[&lt;span&gt;7&lt;/span&gt;:]&lt;br/&gt;&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%d \n&quot;&lt;/span&gt;, (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s)).Data)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%d \n&quot;&lt;/span&gt;, (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s1)).Data)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;%d \n&quot;&lt;/span&gt;, (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s2)).Data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你认为输出结果是什么，变量 s 和 s1、s2 会指向同一个底层内存空间吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;17608227 &lt;br/&gt;17608227 &lt;br/&gt;17608234 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从输出结果来看，变量 s 和 s1 指向同一个内存地址。变量 s2 虽稍有偏差，但本质上也是指向同一块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为其是字符串的切片操作，是从第 7 位索引开始，因此正好的 17608234-17608227 = 7。也就是三个变量都是指向同一块内存空间，这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为在 Go 语言中，&lt;strong&gt;字符串都是只读的，为了节省内存，相同字面量的字符串通常对应于同一字符串常量，因此指向同一个底层数组&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0 拷贝转换&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会有人关注到 SliceHeader、StringHeader 这类运行时细节呢，一大部分原因是业内会有开发者，&lt;strong&gt;希望利用其实现零拷贝的 string 到 bytes 的转换&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见转换代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;string2bytes&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))&lt;br/&gt;&lt;br/&gt; bh := reflect.SliceHeader{&lt;br/&gt;  Data: stringHeader.Data,&lt;br/&gt;  Len:  stringHeader.Len,&lt;br/&gt;  Cap:  stringHeader.Len,&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; *(*[]&lt;span&gt;byte&lt;/span&gt;)(unsafe.Pointer(&amp;amp;bh))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这其实是错误的，官方明确表示：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SliceHeader、StringHeader 的 Data 字段是一个 &lt;code&gt;uintptr&lt;/code&gt; 类型。由于 Go 语言只有值传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在上述代码中会出现将 &lt;code&gt;Data&lt;/code&gt; 作为值拷贝的情况，这就会导致&lt;strong&gt;无法保证它所引用的数据不会被垃圾回收（GC）&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该使用如下转换方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;&lt;br/&gt; v := string2bytes1(s)&lt;br/&gt; fmt.Println(v)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;string2bytes1&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;s))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; b []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; pbytes := (*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;b))&lt;br/&gt; pbytes.Data = stringHeader.Data&lt;br/&gt; pbytes.Len = stringHeader.Len&lt;br/&gt; pbytes.Cap = stringHeader.Len&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; b&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在程序必须保留一个单独的、正确类型的指向底层数据的指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在性能方面，若只是期望单纯的转换，对容量（cap）等字段值不敏感，也可以使用以下方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;string2bytes2&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; *(*[]&lt;span&gt;byte&lt;/span&gt;)(unsafe.Pointer(&amp;amp;s))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能对比：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;string2bytes1-1000-4   3.746 ns/op  0 allocs/op&lt;br/&gt;string2bytes1-1000-4   3.713 ns/op  0 allocs/op&lt;br/&gt;string2bytes1-1000-4   3.969 ns/op  0 allocs/op&lt;br/&gt;&lt;br/&gt;string2bytes2-1000-4   2.445 ns/op  0 allocs/op&lt;br/&gt;string2bytes2-1000-4   2.451 ns/op  0 allocs/op&lt;br/&gt;string2bytes2-1000-4   2.455 ns/op  0 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会相当标准的转换性能会稍快一些，这种强转也会导致一个小问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;脑子进煎鱼了&quot;&lt;/span&gt;&lt;br/&gt; v := string2bytes2(s)&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;len&lt;/span&gt;(v), &lt;span&gt;cap&lt;/span&gt;(v))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;string2bytes2&lt;/span&gt;&lt;span&gt;(s &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; *(*[]&lt;span&gt;byte&lt;/span&gt;)(unsafe.Pointer(&amp;amp;s))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;18 824633927632&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种强转其会导致 byte 的切片容量非常大，需要特别注意。一般还是推荐使用标准的 SliceHeader、StringHeader 方式就好了，也便于后来的维护者理解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这篇文章中，我们介绍了字符串（string）和切片（slice）的两个运行时表现，分别是 StringHeader 和 SliceHeader。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时了解到其运行时表现后，我们还针对其两者的地址指向，常见坑进行了说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们进一步深入，面向 0 拷贝转换的场景进行了介绍和性能分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你平时有没有遇到过这块的疑惑或问题呢，欢迎大家一起讨论！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Go语言slice的本质-SliceHeader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组、字符串和切片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;零拷贝实现string 和bytes的转换疑问&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d11ec56578fafb70366349774d511e6</guid>
<title>JavaScript 中如何实现大文件并发上传？</title>
<link>https://toutiao.io/k/pp7infh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2MjcxNTQ0Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V0dLQzNJW15CVaCoNjposvTpccciaj05o5nPiaqfLRRfTQiaYFYPN41Etrrqt8jPOWukPmJWt3lYxwuA/0?wx_fmt=png&quot; data-nickname=&quot;全栈修仙之路&quot; data-alias=&quot;FerRoad&quot; data-signature=&quot;专注分享 TS、Vue3、前端架构和源码解析等技术干货。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247490704&amp;amp;idx=1&amp;amp;sn=18976b9c9fe2456172c394f1d9cae88b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;JavaScript 中如何实现并发控制？&lt;/a&gt; 这篇文章中，阿宝哥详细分析了 async-pool 这个库如何利用 &lt;code&gt;Promise.all&lt;/code&gt; 和 &lt;code&gt;Promise.race&lt;/code&gt; 函数实现异步任务的并发控制。之后，阿宝哥通过 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247490849&amp;amp;idx=1&amp;amp;sn=9d062c04baeb629d9b69a9fb4e7c3599&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;JavaScript 中如何实现大文件并行下载？&lt;/a&gt; 这篇文章介绍了 async-pool 这个库的实际应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将介绍如何利用 async-pool 这个库提供的 &lt;code&gt;asyncPool&lt;/code&gt; 函数来实现大文件的并发上传。相信有些小伙伴已经了解大文件上传的解决方案，在上传大文件时，为了提高上传的效率，我们一般会使用 Blob.slice 方法对大文件按照指定的大小进行切割，然后通过多线程进行分块上传，等所有分块都成功上传后，再通知服务端进行分块合并。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V15OhibWCicHeQ2ha7jaIibQVxD8OC6uZMYAD0QhvqsBcbiciamNiahkHo7KzQVTUMg9vniaibpS8Nk2ntVRQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.562962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完上图相信你对大文件上传的方案，已经有了一定的了解。接下来，我们先来介绍 Blob 和 File 对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;一、Blob 和 File 对象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Blob 对象&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。&lt;strong&gt;在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。&lt;/strong&gt; 为了更直观的感受 Blob 对象，我们先来使用 Blob 构造函数，创建一个 myBlob 对象，具体如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V15OhibWCicHeQ2ha7jaIibQVxAZoOzUibKsylfibSNBC22diab7FEUjO3d5BG5gvDJNkIQVT6wLtn2jwPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.19427402862985685&quot; data-w=&quot;978&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如你所见，myBlob 对象含有两个属性：size 和 type。其中 &lt;code&gt;size&lt;/code&gt; 属性用于表示数据的大小（以字节为单位），&lt;code&gt;type&lt;/code&gt; 是 MIME 类型的字符串。&lt;code&gt;Blob&lt;/code&gt; 由一个可选的字符串 &lt;code&gt;type&lt;/code&gt;（通常是 MIME 类型）和 &lt;code&gt;blobParts&lt;/code&gt; 组成：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V15OhibWCicHeQ2ha7jaIibQVxe5bia734tgDlw8L2OsicZ7cnsqibhicR32WXpd4REUiaQVaib1ePaBr9GvBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.26944444444444443&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Blob 表示的不一定是 JavaScript 原生格式的数据。比如 File 接口基于 Blob，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 File 对象&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下， File 对象是来自用户在一个 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素上选择文件后返回的 FileList 对象，也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。比如说 FileReader、URL.createObjectURL() 及 XMLHttpRequest.send() 都能处理 Blob 和 File。在大文件上传的场景中，我们将使用 Blob.slice 方法对大文件按照指定的大小进行切割，然后对分块进行并行上传。接下来，我们来看一下具体如何实现大文件上传。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;二、如何实现大文件上传&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让大家能够更好地理解后面的内容，我们先来看一下整体的流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V15OhibWCicHeQ2ha7jaIibQVxeRgWfNLH2g7EFPibsPcTkpd48eSp8H7lr9GsOxeD3l8C1y23dkSRf2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.8074074074074075&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完大文件上传的流程之后，我们先来定义上述流程中涉及的一些辅助函数。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 定义辅助函数&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1 定义 calcFileMD5 函数&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义 &lt;code&gt;calcFileMD5&lt;/code&gt; 函数，用于计算文件的 MD5 值（数字指纹）。在该函数中，我们使用 FileReader API 分块读取文件的内容，然后通过 &lt;code&gt;spark-md5&lt;/code&gt; 这个库提供的方法来计算文件的 MD5 值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;calcFileMD5&lt;/span&gt;(&lt;span&gt;file&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; chunkSize = &lt;span&gt;2097152&lt;/span&gt;, &lt;span&gt;// 2M&lt;/span&gt;&lt;br/&gt;      chunks = &lt;span&gt;Math&lt;/span&gt;.ceil(file.size / chunkSize),&lt;br/&gt;      currentChunk = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;      spark = &lt;span&gt;new&lt;/span&gt; SparkMD5.ArrayBuffer(),&lt;br/&gt;      fileReader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;      fileReader.onload = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        spark.append(e.target.result);&lt;br/&gt;        currentChunk++;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (currentChunk &amp;lt; chunks) {&lt;br/&gt;          loadNext();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          resolve(spark.end());&lt;br/&gt;        }&lt;br/&gt;      };&lt;br/&gt;&lt;br/&gt;      fileReader.onerror = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        reject(fileReader.error);&lt;br/&gt;        reader.abort();&lt;br/&gt;      };&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loadNext&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; start = currentChunk * chunkSize,&lt;br/&gt;          end = start + chunkSize &amp;gt;= file.size ? file.size : start + chunkSize;&lt;br/&gt;        fileReader.readAsArrayBuffer(file.slice(start, end));&lt;br/&gt;      }&lt;br/&gt;      loadNext();&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2 定义 asyncPool 函数&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247490704&amp;amp;idx=1&amp;amp;sn=18976b9c9fe2456172c394f1d9cae88b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;JavaScript 中如何实现并发控制？&lt;/a&gt; 这篇文章中，我们介绍了 &lt;code&gt;asyncPool&lt;/code&gt; 函数，它用于实现异步任务的并发控制。该函数接收 3 个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;poolLimit&lt;/code&gt;（数字类型）：表示限制的并发数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;array&lt;/code&gt;（数组类型）：表示任务数组；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;iteratorFn&lt;/code&gt;（函数类型）：表示迭代函数，用于实现对每个任务项进行处理，该函数会返回一个 Promise 对象或异步函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;asyncPool&lt;/span&gt;(&lt;span&gt;poolLimit, array, iteratorFn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ret = []; &lt;span&gt;// 存储所有的异步任务&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; executing = []; &lt;span&gt;// 存储正在执行的异步任务&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; item &lt;span&gt;of&lt;/span&gt; array) {&lt;br/&gt;    &lt;span&gt;// 调用iteratorFn函数创建异步任务&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;Promise&lt;/span&gt;.resolve().then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; iteratorFn(item, array));&lt;br/&gt;    ret.push(p); &lt;span&gt;// 保存新的异步任务&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 当poolLimit值小于或等于总任务个数时，进行并发控制&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (poolLimit &amp;lt;= array.length) {&lt;br/&gt;      &lt;span&gt;// 当任务完成后，从正在执行的任务数组中移除已完成的任务&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; e = p.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; executing.splice(executing.indexOf(e), &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;      executing.push(e); &lt;span&gt;// 保存正在执行的异步任务&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (executing.length &amp;gt;= poolLimit) {&lt;br/&gt;        &lt;span&gt;await&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.race(executing); &lt;span&gt;// 等待较快的任务执行完成&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.all(ret);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.3 定义 checkFileExist 函数&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;checkFileExist&lt;/code&gt; 函数用于检测文件是否已经上传过了，如果已存在则秒传，否则返回已上传的分块 ID 列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkFileExist&lt;/span&gt;(&lt;span&gt;url, name, md5&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; request.get(url, {&lt;br/&gt;    &lt;span&gt;params&lt;/span&gt;: {&lt;br/&gt;      name,&lt;br/&gt;      md5,&lt;br/&gt;    },&lt;br/&gt;  }).then(&lt;span&gt;(&lt;span&gt;response&lt;/span&gt;) =&amp;gt;&lt;/span&gt; response.data);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;checkFileExist&lt;/code&gt; 函数中使用到的 &lt;code&gt;request&lt;/code&gt; 对象是 &lt;code&gt;Axios&lt;/code&gt; 实例，通过 &lt;code&gt;axios.create&lt;/code&gt; 方法来创建：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; request = axios.create({&lt;br/&gt;  &lt;span&gt;baseURL&lt;/span&gt;: &lt;span&gt;&quot;http://localhost:3000/upload&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;timeout&lt;/span&gt;: &lt;span&gt;10000&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 &lt;code&gt;request&lt;/code&gt; 对象之后，我们就可以轻易地发送 HTTP 请求。在 &lt;code&gt;checkFileExist&lt;/code&gt; 函数内部，我们会发起一个 GET 请求，同时携带的查询参数是文件名（name）和文件的 MD5 值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.4 定义 upload 函数&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当调用 &lt;code&gt;checkFileExist&lt;/code&gt; 函数之后，如果发现文件尚未上传或者只上传完部分分块的话，就会继续调用 &lt;code&gt;upload&lt;/code&gt; 函数来执行上传任务。在 &lt;code&gt;upload&lt;/code&gt; 函数内，我们使用了前面介绍的 &lt;code&gt;asyncPool&lt;/code&gt; 函数来实现异步任务的并发控制，具体如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;upload&lt;/span&gt;(&lt;span&gt;{ &lt;br/&gt;  url, file, fileMd5, &lt;br/&gt;  fileSize, chunkSize, chunkIds,&lt;br/&gt;  poolLimit = &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;}&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; chunks = &lt;span&gt;typeof&lt;/span&gt; chunkSize === &lt;span&gt;&quot;number&quot;&lt;/span&gt; ? &lt;span&gt;Math&lt;/span&gt;.ceil(fileSize / chunkSize) : &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; asyncPool(poolLimit, [...new &lt;span&gt;Array&lt;/span&gt;(chunks).keys()], (i) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (chunkIds.indexOf(i + &lt;span&gt;&quot;&quot;&lt;/span&gt;) !== &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// 已上传的分块直接跳过&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; start = i * chunkSize;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; end = i + &lt;span&gt;1&lt;/span&gt; == chunks ? fileSize : (i + &lt;span&gt;1&lt;/span&gt;) * chunkSize;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; chunk = file.slice(start, end); &lt;span&gt;// 对文件进行切割&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; uploadChunk({&lt;br/&gt;      url,&lt;br/&gt;      chunk,&lt;br/&gt;      &lt;span&gt;chunkIndex&lt;/span&gt;: i,&lt;br/&gt;      fileMd5,&lt;br/&gt;      &lt;span&gt;fileName&lt;/span&gt;: file.name,&lt;br/&gt;    });&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于切割完的文件块，会通过 &lt;code&gt;uploadChunk&lt;/code&gt; 函数，来执行实际的上传操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;uploadChunk&lt;/span&gt;(&lt;span&gt;{ url, chunk, chunkIndex, fileMd5, fileName }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; formData = &lt;span&gt;new&lt;/span&gt; FormData();&lt;br/&gt;  formData.set(&lt;span&gt;&quot;file&quot;&lt;/span&gt;, chunk, fileMd5 + &lt;span&gt;&quot;-&quot;&lt;/span&gt; + chunkIndex);&lt;br/&gt;  formData.set(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, fileName);&lt;br/&gt;  formData.set(&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;, &lt;span&gt;Date&lt;/span&gt;.now());&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; request.post(url, formData);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.5 定义 concatFiles 函数&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有分块都上传完成之后，我们需要通知服务端执行分块合并操作，这里我们定义了 &lt;code&gt;concatFiles&lt;/code&gt; 函数来实现该功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;concatFiles&lt;/span&gt;(&lt;span&gt;url, name, md5&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; request.get(url, {&lt;br/&gt;    &lt;span&gt;params&lt;/span&gt;: {&lt;br/&gt;      name,&lt;br/&gt;      md5,&lt;br/&gt;    },&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.6 定义 uploadFile 函数&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面已定义辅助函数的基础上，我们就可以根据大文件上传的整体流程图来实现一个 &lt;code&gt;uploadFile&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;uploadFile&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!uploadFileEle.files.length) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; file = uploadFileEle.files[&lt;span&gt;0&lt;/span&gt;]; &lt;span&gt;// 获取待上传的文件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; fileMd5 = &lt;span&gt;await&lt;/span&gt; calcFileMD5(file); &lt;span&gt;// 计算文件的MD5&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; fileStatus = &lt;span&gt;await&lt;/span&gt; checkFileExist(  &lt;span&gt;// 判断文件是否已存在&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;/exists&quot;&lt;/span&gt;, &lt;br/&gt;    file.name, fileMd5&lt;br/&gt;  );&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (fileStatus.data &amp;amp;&amp;amp; fileStatus.data.isExists) {&lt;br/&gt;    alert(&lt;span&gt;&quot;文件已上传[秒传]&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; upload({&lt;br/&gt;      &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&quot;/single&quot;&lt;/span&gt;,&lt;br/&gt;      file, &lt;span&gt;// 文件对象&lt;/span&gt;&lt;br/&gt;      fileMd5, &lt;span&gt;// 文件MD5值&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;fileSize&lt;/span&gt;: file.size, &lt;span&gt;// 文件大小&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;chunkSize&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;, &lt;span&gt;// 分块大小&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;chunkIds&lt;/span&gt;: fileStatus.data.chunkIds, &lt;span&gt;// 已上传的分块列表&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;poolLimit&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;// 限制的并发数&lt;/span&gt;&lt;br/&gt;     });&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; concatFiles(&lt;span&gt;&quot;/concatFiles&quot;&lt;/span&gt;, file.name, fileMd5);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 大文件并发上传示例&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义完 &lt;code&gt;uploadFile&lt;/code&gt; 函数，要实现大文件并发上传的功能就很简单了，具体代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!DOCTYPE &lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;html&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;=&lt;span&gt;&quot;zh-CN&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;charset&lt;/span&gt;=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;meta&lt;/span&gt; &lt;span&gt;http-equiv&lt;/span&gt;=&lt;span&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;ie=edge&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;大文件并发上传示例（阿宝哥）&lt;span&gt;&amp;lt;/&lt;span&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.bootcdn.net/ajax/libs/spark-md5/3.0.0/spark-md5.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;uploadFile&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;submit&quot;&lt;/span&gt; &lt;span&gt;onclick&lt;/span&gt;=&lt;span&gt;&quot;uploadFile()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;上传文件&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; uploadFileEle = &lt;span&gt;document&lt;/span&gt;.querySelector(&lt;span&gt;&quot;#uploadFile&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; request = axios.create({&lt;br/&gt;        &lt;span&gt;baseURL&lt;/span&gt;: &lt;span&gt;&quot;http://localhost:3000/upload&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;timeout&lt;/span&gt;: &lt;span&gt;10000&lt;/span&gt;,&lt;br/&gt;      });&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;uploadFile&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!uploadFileEle.files.length) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; file = uploadFileEle.files[&lt;span&gt;0&lt;/span&gt;]; &lt;span&gt;// 获取待上传的文件&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; fileMd5 = &lt;span&gt;await&lt;/span&gt; calcFileMD5(file); &lt;span&gt;// 计算文件的MD5&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 省略其他函数&lt;/span&gt;&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于完整的示例代码内容比较多，阿宝哥就不放具体的代码了。感兴趣的小伙伴，可以访问以下地址浏览客户端和服务器端代码。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;完整的示例代码（代码仅供参考，可根据实际情况进行调整）：&lt;/p&gt;&lt;p&gt;https://gist.github.com/semlinker/b211c0b148ac9be0ac286b387757e692&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们来看一下大文件并发上传示例的运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V15OhibWCicHeQ2ha7jaIibQVxbXwlCl3Kaic7mQraJg4k5zrQ7EXiaB8PTQRXajibJMb6T8bGxXeF9CV5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.42962962962962964&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了在 JavaScript 中如何利用 async-pool 这个库提供的 &lt;code&gt;asyncPool&lt;/code&gt; 函数，来实现大文件的并发上传。此外，文中我们也使用了 spark-md5 这个库来计算文件的数字指纹，如果你数字指纹感兴趣的话，可以阅读 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247489195&amp;amp;idx=1&amp;amp;sn=06e21ce0a261b43335260f79c526d6bc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;数字指纹有什么用？赶紧来了解一下&lt;/a&gt; 这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅有限，阿宝哥并未介绍服务端的具体代码。其实在做文件分块合并时，阿宝哥是以流的形式进行合并，感兴趣的小伙伴可以自行阅读一下相关代码。如果有遇到不清楚的地方，欢迎随时跟阿宝哥交流哟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;四、参考资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>281f0bda46fb2f32a4dee5c965078a53</guid>
<title>JVM 进阶之路（十四）：类加载器和类加载机制</title>
<link>https://toutiao.io/k/84pqgj8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一章里，我们已经学习了类加载的过程，我们知道在加载阶段需要”通过一个类的全限定名来获取描述该类的二进制字节流“，而来完成这个工作的就是类加载器（Class Loader）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1、类与类加载器&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器只用于实现类的加载动作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每 一个类加载器，都拥有一个独立的类名称空间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4880636604774536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMjsqjVJe3XQmHibFatUwBmhPbAOQsYGHIEGYJic2MXsmwzQVCkqvQiazXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;377&quot;/&gt;&lt;figcaption&gt;类加载器和类确定类是否相等&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则,即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下演示了不同的类加载器对instanceof关键字运算的结果的影响。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ClassLoaderTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//自定义一个简单的类加载器&lt;/span&gt;&lt;br/&gt;        ClassLoader myLoader = &lt;span&gt;new&lt;/span&gt; ClassLoader() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//加载类方法&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name) &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;//获取文件名&lt;/span&gt;&lt;br/&gt;                    String fileName = name.substring(name.lastIndexOf(&lt;span&gt;&quot;.&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;&quot;.class&quot;&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//加载输入流&lt;/span&gt;&lt;br/&gt;                    InputStream is = getClass().getResourceAsStream(fileName);&lt;br/&gt;                    &lt;span&gt;//使用父类加载&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (is == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.loadClass(name);&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[is.available()];&lt;br/&gt;                    is.read(b);&lt;br/&gt;                    &lt;span&gt;//从流中转化类的实例&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; defineClass(name, b, &lt;span&gt;0&lt;/span&gt;, b.length);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassNotFoundException(name);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        &lt;span&gt;//使用自己实现的类加载器加载&lt;/span&gt;&lt;br/&gt;        Object obj = myLoader.loadClass(&lt;span&gt;&quot;cn.fighter3.loader.ClassLoaderTest&quot;&lt;/span&gt;).newInstance();&lt;br/&gt;        System.out.println(obj.getClass());&lt;br/&gt;        &lt;span&gt;//实例判断&lt;/span&gt;&lt;br/&gt;        System.out.println(obj &lt;span&gt;instanceof&lt;/span&gt; cn.fighter3.loader.ClassLoaderTest);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16707021791767554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMxicP6OZrIsbTuSe0nN3cCu0hpK4QpPKTgxDCyibBia4dyBzs8gs3ICsRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;413&quot;/&gt;&lt;figcaption&gt;运行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码里定义了一个简单的类加载器，使用这个类加载器去加载&lt;code&gt;cn.fighter3.loader.ClassLoaderTest&lt;/code&gt;类并创建实例，去做类型检查的时候，发现结果是false。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;2、双亲委派模型&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7906602254428341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMLicib4voEciceY3xGFsibe7aWbZRA4Aa6t4q6xvnSXKLtnP9bcnev9SPuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot;/&gt;&lt;figcaption&gt;双亲委派模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型如上图：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;启动类加载器（Bootstrap Class Loader）：负责加载存放在 &amp;lt;JAVA_HOME&amp;gt;\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，能被Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展类加载器（Extension Class Loader）：负责加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序类加载器（Application Class Loader）：负责加载用户类路径 （ClassPath）上所有的类库，如果没有自定义类加载器，一般情况下这个加载器就是程序中默认的类加载器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户还可以加入自定义的类加载器器来进行扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;双亲委派模型的工作过程&lt;/strong&gt;：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。&lt;/p&gt;&lt;img data-ratio=&quot;1.1443514644351465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKM6nibtLgvOy803PFUE7JKVjh15BjFMCcsc9u6SDTF1EMHGDDABJmibhOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么要用双亲委派机制呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是为了保证应用程序的稳定有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如类java.lang.Object，它存放在rt.jar之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证Object的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的代码实现非常简单，在&lt;code&gt;java.lang.ClassLoader.java&lt;/code&gt;中有一个 &lt;code&gt;loadClass&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name, &lt;span&gt;boolean&lt;/span&gt; resolve)&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (getClassLoadingLock(name)) {&lt;br/&gt;            &lt;span&gt;// 首先，判断类是否被加载过&lt;/span&gt;&lt;br/&gt;            Class&amp;lt;?&amp;gt; c = findLoadedClass(name);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; t0 = System.nanoTime();&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        c = parent.loadClass(name, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        c = findBootstrapClassOrNull(name);&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;                    &lt;span&gt;// 如果父类加载器抛出ClassNotFoundException &lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;// 说明父类加载器无法完成加载请求&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// 在父类加载器无法加载时 &lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;// 再调用本身的findClass方法来进行类加载&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;long&lt;/span&gt; t1 = System.nanoTime();&lt;br/&gt;                    c = findClass(name);&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;// this is the defining class loader; record the stats&lt;/span&gt;&lt;br/&gt;                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);&lt;br/&gt;                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&lt;br/&gt;                    sun.misc.PerfCounter.getFindClasses().increment();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (resolve) {&lt;br/&gt;                resolveClass(c);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3、破坏双亲委派模型&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制在历史上主要有三次破坏：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第一次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader则在Java的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的 protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5477707006369427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMYUYkKxYLhJweRYuJfK23O4dJKtUxvzMrn6eVv3g4h8qNuym1yUoWYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;figcaption&gt;重写loadClass破坏双亲委派&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第二次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们比较熟悉的JDBC:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各个厂商各有不同的JDBC的实现，Java在核心包&lt;code&gt;\lib&lt;/code&gt;里定义了对应的SPI，那么这个就毫无疑问由&lt;code&gt;启动类加载器&lt;/code&gt;加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是各个厂商的实现，是没办法放在核心包里的，只能放在&lt;code&gt;classpath&lt;/code&gt;里，只能被&lt;code&gt;应用类加载器&lt;/code&gt;加载。那么，问题来了，启动类加载器它就加载不到厂商提供的SPI服务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个我呢提，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5078809106830122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc1j2WuicLaUrTTt27JD1QKMy2IW5HtULHnLWIiaaqU34NQBic5efB9sE51InlQ9WXjkRZCDhEiaRkbzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;figcaption&gt;加载第三方spi第二次破坏&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第三次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;简单的事情重复做，重复的事情认真做，认真的事情有创造性地做！&quot;——&lt;/p&gt;&lt;p&gt;我是三分恶，可以叫我老三/三分/三哥/三子，一个能文能武的全栈开发，咱们下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;【1】：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） 》&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;【4】：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247489698&amp;amp;idx=1&amp;amp;sn=b2e1275688b6e2866de4edc5c8b48a61&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;读者美团五面：Java历史上有三次破坏双亲委派模型，是哪三次？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>388a9def3ee1fcefb60e6d5ffe16a207</guid>
<title>《面试官：谈谈你对索引的认知》系列之 B+ 树</title>
<link>https://toutiao.io/k/sx601m9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h3 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33184855233853006&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRgzIV2YTLYP1C9K6m6ZesXIGMic8cBk5es1ZicMDfULrExGEw49a51icWhlYkA1pXmib62xNNUDrMgXA/640?wx_fmt=png&quot;/&gt;&lt;/h3&gt;&lt;h3 data-pm-slice=&quot;1 1 []&quot;&gt;&lt;strong&gt;&lt;span&gt;写在前面&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前面一讲我们介绍了B-树的特性，以及与平衡二叉树的对比得出B-树这类数据结构的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDg5MDkzOA==&amp;amp;mid=2448765348&amp;amp;idx=1&amp;amp;sn=688b58a857f9d83a86d7a2a59a295e07&amp;amp;chksm=8b347571bc43fc670ed2fb66ee9c69751da0f913ba2006535fd8cfabb6f532df97471d11c9a6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《面试官：谈谈你对索引的认知》系列之B-树&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《面试官：谈谈你对索引的认知》系列之B-树&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那B+树作为B树的一个升级版，那它又有哪些优势呢？本讲继续为大家揭开B+树的神秘面纱，让它不再成为你前进的羁绊！&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;B+树 简介&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;B+树是B-树的一个升级版，也是一种多路搜索树，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQfEJjeU6ceaTRxtHuuwlpBJsPsWdAPHRtCeIPnibPzkVAqibRNj1USKpcP9dPBRjnTgcDWic2ODsS0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图B-树的简化图，我们可以发现几个显著特点：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;B+树 VS B-树&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1、数据实现结构不同，查询复杂度不同&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如我们分别查询B-树/B+树节点 key 为 50 的 data。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44749596122778673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQfEJjeU6ceaTRxtHuuwlpBJFn1xa3ic3LYKS1IF0UHMezd5Ty7wKgIrnc36wYzSEoDeNocjYNU1Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;key 为 50 的节点恰好就在第一层，B-树只需要一次磁盘 IO 即可完成查找。所以说B-树的查询最好时间复杂度是 O(1)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4684014869888476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQfEJjeU6ceaTRxtHuuwlpBhvqD51lgH5nL3Zo0CxKsJHcc1gQOorHcxbeSMVFwZwCvXFc3j3X2ibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于B+树所有的 data 域都在根节点，所以查询 key 为 50的节点必须从根节点索引到叶节点，时间复杂度固定为 O(log n)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;B树的由于每个节点都有key和data，所以查询的时候可能不需要O(logn)的复杂度，甚至最好的情况是O(1)就可以找到数据，而B+树由于只有叶子节点保存了data，所以必须经历O(logn)复杂度才能找到数据。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2、B+树可以更好的利用局部性原理&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.48148148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQfEJjeU6ceaTRxtHuuwlpBvNcCtboNhTIsELE2YzkXSExW09CTU9o9YVraIzHcMQT0nvPjfKT2cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若我们访问节点 key为 50，则 key 为 55、60、62 的节点将来也可能被访问，我们可以利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。当然B+树也能够很好的完成范围查询。比如查询 key 值在 50-70 之间的节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;由于B+树的叶子节点的数据都是使用链表连接起来的，而且他们在磁盘里是顺序存储的，所以当读到某个值的时候，磁盘预读原理就会提前把这些数据都读进内存，使得范围查询和排序都很快。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、B+树每个节点能索引的范围更大更精确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为它内节点不存储data，这样一个节点就可以存储更多的key。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于B-树节点内部每个 key 都带着 data 域，而B+树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。前面说过磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着B+树单次磁盘 IO 的信息量大于B-树，从这点来看B+树相对B-树磁盘 IO 次数少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQfEJjeU6ceaTRxtHuuwlpBcE1f4CpWEKkl0mwSKOaCwibPvPP4objEHevHfRiaS6BDBQafcESO6blg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可以看出相同大小的区域，B-树仅有 2 个 key，而B+树有 3 个 key。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;由于B树的节点都存了key和data，而B+树只有叶子节点存data，非叶子节点都只是索引值，没有实际的数据，这就时B+树在一次IO里面，能读出的索引值更多。从而减少查询时候需要的IO次数！&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;B-树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是B+树的优势更加明显：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;·················· &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; ··················&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注公众号，免费领取程序员成长大礼包&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;十年研发路，大厂架构师，&lt;/span&gt;&lt;span&gt;CSDN博客专家&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;专注架构技术学习及分享，职业与认知升级&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;坚持分享接地气儿的干货，&lt;span&gt;期待与你一起成长&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536564239870558210#wechat_redirect&quot; textvalue=&quot;消息中间件&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;消息中间件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536567322449117185#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;架构应用汇总&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536569434063077381#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; data-linktype=&quot;2&quot;&gt;认知升级迭代&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536561900824657922#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MySQL实用探秘&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgTqLjdQBs7fV8zqHRaQhA2ibia13fFn6ibS5qr5PpmZoxd8nlhAyJu7d1CjLicAruicOEb7uxibEGM476xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「架构精进之路」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97708&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;点“赞”和“在看”哦&lt;/span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.5925925925925926&quot; data-type=&quot;gif&quot; data-w=&quot;135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/noz2jw2hPlWiaCrGuJxBicU5mcib3QapDLyo6eKnNVm9dPTV4Z1SicHLtrCCwOG9gblMBFlKf7p9cvwL6wIkZJvamg/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>