<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>52700d0932c1be83fc86d3a0335cfff4</guid>
<title>浅谈 Java 中的 AutoCloseable 接口</title>
<link>https://toutiao.io/k/znohjci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Closes this resource, relinquishing any underlying resources. This method is invoked automatically on objects managed by the try-with-resources statement.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;While this interface method is declared to throw Exception, implementers are strongly encouraged to declare concrete implementations of the close method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Cases where the close operation may fail require careful attention by implementers. It is strongly advised to relinquish the underlying resources and to internally mark the resource as closed, prior to throwing the exception. The close method is unlikely to be invoked more than once and so this ensures that the resources are released in a timely manner. Furthermore it reduces problems that could arise when the resource wraps, or is wrapped, by another resource.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Implementers of this interface are also strongly advised to not have the close method throw InterruptedException.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;This exception interacts with a thread&#x27;s interrupted status, and runtime misbehavior is likely to occur if an InterruptedException is suppressed.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;More generally, if it would cause problems for an exception to be suppressed, the AutoCloseable.close method should not throw it.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Note that unlike the java.io.Closeable#close close method of java.io.Closeable, this close method is not required to be idempotent. In other words, calling this close method more than once may have some visible side effect, unlike Closeable.close which is required to have no effect if called more than once.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;However, implementers of this interface are strongly encouraged to make their close methods idempotent.&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a13fc38fcf5d9f04e0e4337893d09f5e</guid>
<title>[推荐] [译] 何时使用 Rust 和何时使用 Golang？</title>
<link>https://toutiao.io/k/z6p6anw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6671232876712329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXzWUb2qTiaX8WcYsNsx4F7qza5oHcHhXsgQhIp1ht8Ih1ldzkgaKuUeTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发性，内存管理和整体开发人员体验。我们还将概述这些元素，以帮助您一目了然地为项目选择正确的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您刚开始使用 Rust，那么在继续阅读之前，最好先阅读一下&lt;span&gt;初学者指南&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您全都都准备好了，那就让我们开始吧！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 最初是由 Google 的工程师设计的，于 2009 年向公众推出。它的创建是为 C++提供替代方案，该替代方案易于学习和编码，并且经过优化可在多核 CPU 上运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从那时起，Golang 对于希望利用该语言提供的并发性的开发人员来说非常有用。该语言提供了 goroutine，使您可以将函数作为 goroutine 运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 的一大优势是您可以轻松使用 goroutines。只需将&lt;code&gt;go&lt;/code&gt;添加到函数前即可使其作为 goroutine 运行。Golang 的并发模型允许您跨多个 CPU 内核部署工作负载，从而使其成为一种非常有效的语言。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(from &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;        fmt.Println(from, &lt;span&gt;&quot;:&quot;&lt;/span&gt;, i)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    f(&lt;span&gt;&quot;direct&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; f(&lt;span&gt;&quot;goroutine&quot;&lt;/span&gt;)&lt;br/&gt;    time.Sleep(time.Second)&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;done&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管有多核 CPU 支持，Rust 仍然跑赢 Golang。Rust 在执行算法和资源密集型操作方面效率更高。该&lt;span&gt;基准测试游戏&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;比较了 rust 和 golang 的不同算法，如二叉树。对于所有经过测试的算法，Rust 至少快 30％；在二叉树计算的情况下，最高可达 1,000％。&lt;span&gt;Bitbucket 的&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;一项研究表明，Rust 与 C++的性能相似。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6680555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXz3Z8x7jFeiaHleFQBURFps0bFfArzvohAtf5AmK6uibNxyfK3tLhHl5Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;（来源：&lt;span&gt;基准测试游戏&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;）&lt;/em&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所述，Golang 支持并发。例如，假设您正在运行一个处理 API 请求的 Web 服务器。您可以使用 Golang 的 goroutine 程序将每个请求作为 goroutine 运行，通过将任务分发到所有可用的 CPU 内核来最大程度地提高效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goroutines 是 Golang 内置功能的一部分，而 Rust 仅支持本地 async/await 语法来支持并发。因此，在并发方面，Golang 的开发人员有经验优势。但是，Rust 在保证内存安全方面要好得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 Rust 的简化线程的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;use&lt;/span&gt; std::thread;&lt;br/&gt;&lt;span&gt;use&lt;/span&gt; std::time::Duration;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   &lt;span&gt;// 1. create a new thread&lt;/span&gt;&lt;br/&gt;   thread::spawn(|| {&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;..&lt;span&gt;10&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;thread: number {}!&quot;&lt;/span&gt;, i);&lt;br/&gt;         thread::sleep(Duration::from_millis(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;      }&lt;br/&gt;   });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;hi from the main thread!&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发一直是开发人员的棘手问题。在不影响开发人员体验的情况下保证内存安全的并发性并不是一项容易的任务。但是，这种极端的安全重点导致创建了&lt;span&gt;可证明正确的并发&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。Rust 尝试使用所有权概念来防止未经请求的资源访问，以防止出现内存安全错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 提供了四种不同的并发范例，以帮助您避免常见的内存安全陷阱。我们将仔细研究两个常见的范例：channel 和锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channel&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;channel&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 有助于从一个线程传送消息到另一个。虽然 Golang 也存在此概念，但 Rust 允许您将&lt;span&gt;指针&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;从一个线程转移到另一个线程，以避免争用资源。通过传递指针，Rust 可以对 channel 强制执行线程隔离。同样，Rust 在并发模型方面表现出对内存安全的痴迷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅当持有&lt;span&gt;锁&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;时才能访问数据。Rust 依赖于锁定数据而不是 cod 的原理，而 cod 经常在诸如 Java 之类的编程语言中找到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关所有权和所有并发范例的更多详细信息，请查看“&lt;span&gt;使用 Rust 进行无所畏惧的并发&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存安全&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;较早的所有权概念是 Rust 的主要卖点之一。Rust 将&lt;span&gt;类型安全&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;提升到了新的水平，这对于实现内存安全的并发性也很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;Bitbucket 博客&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;，“ Rust 非常严格和繁琐的编译器会检查您使用的每个变量以及您引用的每个内存地址。它避免了可能发生的数据争用情况，并通知您未定义的行为。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着由于 Rust 对内存安全性的极度痴迷，您最终不会出现缓冲区溢出或争用情况。但是，这也有其缺点。例如，您在编写代码时必须非常了解内存分配原则。始终保持您的内存安全防护并不容易。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发人员体验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，让我们看一下每种语言的学习曲线。Golang 在设计时考虑了简单性。开发人员经常将其称为“无聊”语言，也就是说，其有限的内置功能集使 Golang 易于学习、使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Golang 提供了比 C++更简单的替代方案，隐藏了诸如内存安全性和内存分配等方面的内容。Rust 采用了另一种方法，迫使您考虑诸如内存安全性的概念。所有权的概念和传递指针的能力使 Rust 失去了学习的吸引力。当您不断考虑内存安全性时，您的工作效率就会降低，并且您的代码注定会变得更加复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 Golang 相比，Rust 的学习曲线非常陡峭。值得一提的是，与 Python 和 JavaScript 等动态语言相比，Golang 的学习曲线较为陡峭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;何时使用 Golang&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 在各种用例中都能很好地工作，使其成为创建 Web API 的 Node.js 的绝佳替代品。正如&lt;span&gt;Loris Cro&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;指出的那样，“ Go 的并发模型非常适合必须处理多个独立请求的服务器端应用程序”。这正是 Golang 提供 goroutines 的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Golang 内置了对 HTTP Web 协议的支持。您可以使用内置的 HTTP 支持快速设计一个小型 API，并将其作为微服务运行。因此，Golang 非常适合微服务架构并满足 API 开发人员的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，如果您重视开发速度并且更喜欢语法简单而不是性能，那么 Golang 是一个很好的选择。最重要的是，Golang 提供了更好的代码可读性，这对于大型开发团队而言是一个重要标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下情况下选择 Golang：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;您关心简单性和可读性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您需要一种简单的语法来快速编写代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您想使用支持 Web 开发的更灵活的语言&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;何时使用 Rust&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当性能很重要时，例如在处理大量数据时，Rust 是一个不错的选择。此外，Rust 为您提供了对线程行为以及线程之间资源共享方式的细粒度控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，Rust 具有陡峭的学习曲线，并且由于内存安全性的额外复杂性而减慢了开发速度。这并不一定是不利的。Rust 还保证当编译器检查每个数据指针时，您不会遇到内存安全性错误。对于复杂的系统，此保证会派上用场。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以下情况下选择 Rust：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;您关心性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您想要对线程进行细粒度的控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;您重视内存安全而不是简单性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go vs. Rust：我的大实话&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们从突出相似之处开始。Go 和 Rust 都是开源的，旨在支持微服务架构和并行计算环境。两者都通过并发优化了可用 CPU 内核的利用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但归根结底，哪种语言是最好的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有很多方法可以解决这个问题。我建议考虑要构建哪种类型的应用程序。Golang 可很好地用于创建 Web 应用程序和 API，这些应用程序和 API 利用其内置的并发功能，同时支持微服务体系结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您还可以使用 Rust 来开发 Web API，但并不是在设计时考虑到此用例。Rust 对内存安全性的关注增加了复杂性和开发时间，尤其是对于相当简单的 Web API。但是，对代码的大量控制使您可以编写更优化，内存效率更高且性能更高的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，Golang 与 Rust 的争论实际上是一个简单与安全的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关更多观点，请查看“&lt;span&gt;在 Go 和 Rust 之间选择&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LogRocket：全面了解线上 Rust 应用程序&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间感兴趣，请&lt;span&gt;尝试 LogRocket&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5641666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UWba2ryLMqm2lSGu3l8woJasfoSWefXzicMmuvXWfZBD6vwrFFqvVWQBhs8NY0G1DCqbicVkYrrBWviaY3uFMnx9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LogRocket&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;就像 Web 应用程序的 DVR，实际上记录了 Rust 应用程序中发生的所有事情。您可以汇总并报告问题发生时应用程序所处的状态，而不用猜测为什么会发生问题。LogRocket 还监视您的应用程序的性能，报告诸如客户端 CPU 负载，客户端内存使用情况等指标。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://blog.logrocket.com/when-to-use-rust-and-when-to-use-golang/&lt;/p&gt;&lt;p&gt;原文作者：Michiel Mulders&lt;/p&gt;&lt;p&gt;译者：polarisxu&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;初学者指南: &lt;em&gt;https://blog.logrocket.com/getting-up-to-speed-with-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;基准测试游戏: &lt;em&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Bitbucket 的: &lt;em&gt;https://bitbucket.org/blog/why-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;基准测试游戏: &lt;em&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;可证明正确的并发: &lt;em&gt;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;channel: &lt;em&gt;https://doc.rust-lang.org/stable/rust-by-example/std_misc/channels.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;指针: &lt;em&gt;https://doc.rust-lang.org/std/primitive.pointer.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;锁: &lt;em&gt;https://doc.rust-lang.org/std/sync/struct.Mutex.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;使用 Rust 进行无所畏惧的并发: &lt;em&gt;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;类型安全: &lt;em&gt;https://en.wikipedia.org/wiki/Type_safety&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Bitbucket 博客: &lt;em&gt;https://bitbucket.org/blog/why-rust&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Loris Cro: &lt;em&gt;https://kristoff.it/blog/why-go-and-not-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;在 Go 和 Rust 之间选择: &lt;em&gt;https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;尝试 LogRocket: &lt;em&gt;https://logrocket.com/signup&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;LogRocket: &lt;em&gt;https://logrocket.com/signup&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7207b9ab5a64afbda98591815971f720</guid>
<title>[推荐] 图解常见的九种设计模式</title>
<link>https://toutiao.io/k/pjsjgsi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。根据模式的目的来划分的话，GoF（Gang of Four）设计模式可以分为以下 3 种类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYORsOE5icFY5emqIg38W1BFcLLHCtQy8reE1enw9uibroWMVxZlQUqw9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.33055555555555555&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、创建型模式：用来描述 “如何创建对象”，它的主要特点是 “将对象的创建和使用分离”。包括单例、原型、工厂方法、抽象工厂和建造者 5 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、结构型模式：用来描述如何将类或对象按照某种布局组成更大的结构。包括代理、适配器、桥接、装饰、外观、享元和组合 7 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、行为型模式：用来识别对象之间的常用交流模式以及如何分配职责。包括模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录和解释器 11 种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来阿宝哥将结合一些生活中的场景并通过精美的配图，来向大家介绍 9 种常用的设计模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、建造者模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建造者模式（Builder Pattern）将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一辆小汽车 🚗 通常由 &lt;strong&gt;发动机、底盘、车身和电气设备&lt;/strong&gt; 四大部分组成。汽车电气设备的内部构造很复杂，简单起见，我们只考虑三个部分：引擎、底盘和车身。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYYVUo8Masic9yq0JzwWjiaUtXcd8csBBBK3ysEJXLVH6qoVZbnlElSC6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.24814814814814815&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现实生活中，小汽车也是由不同的零部件组装而成，比如上图中我们把小汽车分成引擎、底盘和车身三大部分。下面我们来看一下如何使用建造者模式来造车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Car {&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; engine: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; chassis: &lt;span&gt;string&lt;/span&gt;, &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; body: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  &lt;/span&gt;) {}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CarBuilder {&lt;br/&gt;  engine!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 引擎&lt;/span&gt;&lt;br/&gt;  chassis!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 底盘&lt;/span&gt;&lt;br/&gt;  body!: &lt;span&gt;string&lt;/span&gt;; &lt;span&gt;// 车身&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  addChassis(chassis: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.chassis = chassis;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  addEngine(engine: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.engine = engine;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  addBody(body: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.body = body;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  build() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Car(&lt;span&gt;this&lt;/span&gt;.engine, &lt;span&gt;this&lt;/span&gt;.chassis, &lt;span&gt;this&lt;/span&gt;.body);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们定义一个 &lt;code&gt;CarBuilder&lt;/code&gt; 类，并提供了 &lt;code&gt;addChassis&lt;/code&gt;、&lt;code&gt;addEngine&lt;/code&gt; 和 &lt;code&gt;addBody&lt;/code&gt; 3 个方法用于组装车子的不同部位，当车子的 3 个部分都组装完成后，调用 &lt;code&gt;build&lt;/code&gt; 方法就可以开始造车。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; car = &lt;span&gt;new&lt;/span&gt; CarBuilder()&lt;br/&gt;  .addEngine(&lt;span&gt;&#x27;v12&#x27;&lt;/span&gt;)&lt;br/&gt;  .addBody(&lt;span&gt;&#x27;镁合金&#x27;&lt;/span&gt;)&lt;br/&gt;  .addChassis(&lt;span&gt;&#x27;复合材料&#x27;&lt;/span&gt;)&lt;br/&gt;  .build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要生成的产品对象的属性相互依赖，需要指定其生成顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - node-sql-query：https://github.com/dresende/node-sql-query&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、工厂模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在现实生活中，工厂是负责生产产品的，比如牛奶、面包或礼物等，这些产品满足了我们日常的生理需求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYYozbev3whOjKiciaF6TnbB1nHA5U8oT5pmPebv7XtWas0V0s8kXWQibcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.35648148148148145&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在众多设计模式当中，有一种被称为工厂模式的设计模式，它提供了创建对象的最佳方式。工厂模式可以分为：&lt;strong&gt;简单工厂模式、工厂方法模式和抽象工厂模式&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 简单工厂&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单工厂模式又叫 &lt;strong&gt;静态方法模式&lt;/strong&gt;，因为工厂类中定义了一个静态方法用于创建对象。简单工厂让使用者不用知道具体的参数就可以创建出所需的 ”产品“ 类，即使用者可以直接消费产品而不需要知道产品的具体生产细节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYUWltia1zbFdvpxcrGHC0CEjTT0iacxdXxW3AVicYb2J4TYCsTNsicR7SEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4861111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 工厂订购了 BMW730 和 BMW840 型号的车型，接着工厂会先判断用户选择的车型，然后按照对应的模型进行生产并在生产完成后交付给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用简单工厂来描述 BMW 工厂生产指定型号车子的过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMW {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; run(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW730 &lt;span&gt;extends&lt;/span&gt; BMW {&lt;br/&gt;  run(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;BMW730 发动咯&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW840 &lt;span&gt;extends&lt;/span&gt; BMW {&lt;br/&gt;  run(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;BMW840 发动咯&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; produceBMW(model: &lt;span&gt;&quot;730&quot;&lt;/span&gt; | &lt;span&gt;&quot;840&quot;&lt;/span&gt;): BMW {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (model === &lt;span&gt;&quot;730&quot;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们定义一个 &lt;code&gt;BMWFactory&lt;/code&gt; 类，该类提供了一个静态的 &lt;code&gt;produceBMW()&lt;/code&gt; 方法，用于根据不同的模型参数来创建不同型号的车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = BMWFactory.produceBMW(&lt;span&gt;&quot;730&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = BMWFactory.produceBMW(&lt;span&gt;&quot;840&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;工厂类负责创建的对象比较少：由于创建的对象比较少，不会造成工厂方法中业务逻辑过于复杂。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端只需知道传入工厂类静态方法的参数，而不需要关心创建对象的细节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 工厂方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫多态工厂（Polymorphic Factory）模式，它属于类创建型模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象， &lt;strong&gt;这样做的目的是将产品类的实例化操作延迟到工厂子类中完成&lt;/strong&gt;，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYKUYSgZ69oEMWbx3nEAUw2Weg0iacMyKMfyiaCjiciaFyU18qskQvchSicUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4824074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王和小秦分别向 BMW 730 和 BMW 840 工厂订购了 BMW730 和 BMW840 型号的车子，接着工厂按照对应的模型进行生产并在生产完成后交付给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，我们来看一下如何使用工厂方法来描述 BMW 工厂生产指定型号车子的过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produceBMW(): BMW;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW730Factory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produceBMW(): BMW {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; BMW840Factory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produceBMW(): BMW {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们分别创建了 &lt;code&gt;BMW730Factory&lt;/code&gt; 和 &lt;code&gt;BMW840Factory&lt;/code&gt; 两个工厂类，然后使用这两个类的实例来生产不同型号的车子。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmw730Factory = &lt;span&gt;new&lt;/span&gt; BMW730Factory();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840Factory = &lt;span&gt;new&lt;/span&gt; BMW840Factory();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = bmw730Factory.produceBMW();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = bmw840Factory.produceBMW();&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 抽象工厂&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。&lt;strong&gt;但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYH3bye09dUCBvakibGmEJd8XJKG22mqwlFGibnAtW3OzsN9YWGiaIGQiaew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4898148148148148&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了用户购车的流程，小王向 BMW 工厂订购了 BMW730，工厂按照 730 对应的模型进行生产并在生产完成后交付给小王。而小秦向同一个 BMW 工厂订购了 BMW840，工厂按照 840 对应的模型进行生产并在生产完成后交付给小秦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用抽象工厂来描述上述的购车过程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory {&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produce730BMW(): BMW730;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; produce840BMW(): BMW840;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; ConcreteBMWFactory &lt;span&gt;extends&lt;/span&gt; BMWFactory {&lt;br/&gt;  produce730BMW(): BMW730 {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW730();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  produce840BMW(): BMW840 {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BMW840();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bmwFactory = &lt;span&gt;new&lt;/span&gt; ConcreteBMWFactory();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw730 = bmwFactory.produce730BMW();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bmw840 = bmwFactory.produce840BMW();&lt;br/&gt;&lt;br/&gt;bmw730.run();&lt;br/&gt;bmw840.run();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统中有多于一个的产品族，而每次只使用其中某一产品族。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、单例模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式（Singleton Pattern）是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器中的 window 对象等。单例模式用于保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYCwmXHgibyIcuia9UpgZTBEUL1HBdHfdfNayicOJRwbqRZYMOIMH8fK7TQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.39537037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥模拟了借车的流程，小王临时有急事找阿宝哥借车子，阿宝哥家的车子刚好没用，就借给小王了。当天，小秦也需要用车子，也找阿宝哥借车，因为阿宝哥家里只有一辆车子，所以就没有车可借了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于车子来说，它虽然给生活带来了很大的便利，但养车也需要一笔不小的费用（车位费、油费和保养费等），所以阿宝哥家里只有一辆车子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发软件系统时，如果遇到创建对象时耗时过多或耗资源过多，但又经常用到的对象，我们就可以考虑使用单例模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现单例模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Singleton {&lt;br/&gt;  &lt;span&gt;// 定义私有的静态属性，来保存对象实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; singleton: Singleton;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {}&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 提供一个静态的方法来获取对象实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; getInstance(): Singleton {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!Singleton.singleton) {&lt;br/&gt;      Singleton.singleton = &lt;span&gt;new&lt;/span&gt; Singleton();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Singleton.singleton;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; instance1 = Singleton.getInstance();&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; instance2 = Singleton.getInstance();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(instance1 === instance2); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要频繁实例化然后销毁的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建对象时耗时过多或耗资源过多，但又经常用到的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、适配器模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际生活中，也存在适配器的使用场景，比如：港式插头转换器、电源适配器和 USB 转接口。&lt;strong&gt;而在软件工程中，适配器模式的作用是解决两个软件实体间的接口不兼容的问题&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体就可以一起工作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicY87zR7joPTDTaflpOc37uVYctCgwjzVyPry3AVUW2ubVNUdp0X7ib0Ug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4527777777777778&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Logger {&lt;br/&gt;  info(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; CloudLogger {&lt;br/&gt;  sendToServer(message: &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; AliLogger &lt;span&gt;implements&lt;/span&gt; CloudLogger {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; sendToServer(message: &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.info(message);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.info(&lt;span&gt;&#x27;This Message was saved with AliLogger&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CloudLoggerAdapter &lt;span&gt;implements&lt;/span&gt; Logger {&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; cloudLogger: CloudLogger;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt; (&lt;span&gt;cloudLogger: CloudLogger&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.cloudLogger = cloudLogger;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; info(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.cloudLogger.sendToServer(message, &lt;span&gt;&#x27;info&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; NotificationService {&lt;br/&gt;  &lt;span&gt;protected&lt;/span&gt; logger: Logger;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt; (&lt;span&gt;logger: Logger&lt;/span&gt;) {    &lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.logger = logger;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; send(message: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.logger.info(&lt;span&gt;`Notification sended: &lt;span&gt;${message}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，因为 &lt;code&gt;Logger&lt;/code&gt; 和 &lt;code&gt;CloudLogger&lt;/code&gt; 这两个接口不匹配，所以我们引入了 &lt;code&gt;CloudLoggerAdapter&lt;/code&gt; 适配器来解决兼容性问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(&lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; aliLogger = &lt;span&gt;new&lt;/span&gt; AliLogger();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cloudLoggerAdapter = &lt;span&gt;new&lt;/span&gt; CloudLoggerAdapter(aliLogger);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; notificationService = &lt;span&gt;new&lt;/span&gt; NotificationService(cloudLoggerAdapter);&lt;br/&gt;  &lt;span&gt;await&lt;/span&gt; notificationService.send(&lt;span&gt;&#x27;Hello semlinker, To Cloud&#x27;&lt;/span&gt;);&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - axios-mock-adapter：https://github.com/ctimmerm/axios-mock-adapter&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、观察者模式 &amp;amp; 发布订阅模式&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 观察者模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察者模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在观察者模式中有两个主要角色：Subject（主题）和 Observer（观察者）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYicKmbjTUWZYRg7bzOP6ZPlhC8dAhEwia3pqtReHMnCZF6R3TTeWnJOkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.531062124248497&quot; data-w=&quot;998&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，Subject（主题）就是阿宝哥的 TS 专题文章，而观察者就是小秦和小王。由于观察者模式支持简单的广播通信，当消息更新时，会自动通知所有的观察者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现观察者模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Observer {&lt;br/&gt;  notify: &lt;span&gt;Function&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; ConcreteObserver &lt;span&gt;implements&lt;/span&gt; Observer{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;&lt;span&gt;private&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {}&lt;br/&gt;&lt;br/&gt;  notify() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt; has been notified.`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Subject { &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; observers: Observer[] = [];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; addObserver(observer: Observer): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(observer, &lt;span&gt;&quot;is pushed!&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observers.push(observer);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; deleteObserver(observer: Observer): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;remove&quot;&lt;/span&gt;, observer);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; n: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.observers.indexOf(observer);&lt;br/&gt;    n != &lt;span&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.observers.splice(n, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; notifyObservers(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;notify all the observers&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.observers);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observers.forEach(&lt;span&gt;&lt;span&gt;observer&lt;/span&gt; =&amp;gt;&lt;/span&gt; observer.notify());&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; subject: Subject = &lt;span&gt;new&lt;/span&gt; Subject();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoQin = &lt;span&gt;new&lt;/span&gt; ConcreteObserver(&lt;span&gt;&quot;小秦&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoWang = &lt;span&gt;new&lt;/span&gt; ConcreteObserver(&lt;span&gt;&quot;小王&quot;&lt;/span&gt;);&lt;br/&gt;subject.addObserver(xiaoQin);&lt;br/&gt;subject.addObserver(xiaoWang);&lt;br/&gt;subject.notifyObservers();&lt;br/&gt;&lt;br/&gt;subject.deleteObserver(xiaoQin);&lt;br/&gt;subject.notifyObservers();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个对象的行为依赖于另一个对象的状态。或者换一种说法，当被观察对象（目标对象）的状态发生改变时 ，会直接影响到观察对象的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RxJS Subject：https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RxJS Subject 文档：https://rxjs.dev/guide/subject&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 发布订阅模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件架构中，发布/订阅是一种消息范式，&lt;strong&gt;消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，然后分别发送给不同的订阅者。&lt;/strong&gt; 同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发布订阅模式中有三个主要角色：Publisher（发布者）、 Channels（通道）和 Subscriber（订阅者）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYsZibrw2DBibCXudiabAmSCg3nNZectclZZCib795MH2z8lt14YMKsKtuFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.40185185185185185&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，Publisher（发布者）是阿宝哥，Channels（通道）中 Topic A 和 Topic B 分别对应于 TS 专题和 Deno 专题，而 Subscriber（订阅者）就是小秦、小王和小池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用 TypeScript 来实现发布订阅模式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; EventHandler = &lt;span&gt;(&lt;span&gt;...args: &lt;span&gt;any&lt;/span&gt;[]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; EventEmitter {&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;&lt;span&gt;string&lt;/span&gt;, EventHandler[]&amp;gt;();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 订阅指定的主题&lt;/span&gt;&lt;br/&gt;  subscribe(topic: &lt;span&gt;string&lt;/span&gt;, ...handlers: EventHandler[]) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.c.set(topic, topics = []);&lt;br/&gt;    }&lt;br/&gt;    topics.push(...handlers);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 取消订阅指定的主题&lt;/span&gt;&lt;br/&gt;  unsubscribe(topic: &lt;span&gt;string&lt;/span&gt;, handler?: EventHandler): &lt;span&gt;boolean&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!handler) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.c.delete(topic);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; index = topics.indexOf(handler);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (index &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    topics.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (topics.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.c.delete(topic);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 为指定的主题发布消息&lt;/span&gt;&lt;br/&gt;  publish(topic: &lt;span&gt;string&lt;/span&gt;, ...args: &lt;span&gt;any&lt;/span&gt;[]): &lt;span&gt;any&lt;/span&gt;[] | &lt;span&gt;null&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; topics = &lt;span&gt;this&lt;/span&gt;.c.get(topic);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!topics) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; topics.map(&lt;span&gt;&lt;span&gt;handler&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; handler(...args);&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.error(e);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; eventEmitter = &lt;span&gt;new&lt;/span&gt; EventEmitter();&lt;br/&gt;eventEmitter.subscribe(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;(&lt;span&gt;msg&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`收到订阅的消息：&lt;span&gt;${msg}&lt;/span&gt;`&lt;/span&gt;) );&lt;br/&gt;&lt;br/&gt;eventEmitter.publish(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;&quot;TypeScript发布订阅模式&quot;&lt;/span&gt;);&lt;br/&gt;eventEmitter.unsubscribe(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;);&lt;br/&gt;eventEmitter.publish(&lt;span&gt;&quot;ts&quot;&lt;/span&gt;, &lt;span&gt;&quot;TypeScript发布订阅模式&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为事件总线，来实现不同组件间或模块间的通信。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BetterScroll - EventEmitter：https://github.com/ustbhuangyi/better-scroll/blob/dev/packages/shared-utils/src/events.ts&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247486413&amp;amp;idx=1&amp;amp;sn=f9a2d3a0f7f89817ce0f5abb4a2698ed&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;EventEmitter 在插件化架构的应用&lt;/a&gt;：https://mp.weixin.qq.com/s/N4iw3bi0bxJ57J8EAp5ctQ&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、策略模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式（Strategy Pattern）定义了一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活、可维护、可扩展。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYJbJ6yQpSoG7PMzibnyoAia1NvIeWVVIauojkxNu9o2Qa7GN0T2nmliaHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.512962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前在一些主流的 Web 站点中，都提供了多种不同的登录方式。比如账号密码登录、手机验证码登录和第三方登录。为了方便维护不同的登录方式，我们可以把不同的登录方式封装成不同的登录策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用策略模式来封装不同的登录方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYl5SX5hwrg3Tj5LPGQwh4eVsNKuEcXo8MX1mbgUPcAq5C8PNIxm3KMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.38981481481481484&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(...args: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Authenticator {&lt;br/&gt;  strategy: &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.strategy = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  setStrategy(strategy: &lt;span&gt;any&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.strategy = strategy;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  authenticate(...args: &lt;span&gt;any&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.strategy) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;尚未设置认证策略&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.strategy.authenticate(...args);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; WechatStrategy &lt;span&gt;implements&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(wechatToken: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (wechatToken !== &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;无效的微信用户&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;微信认证成功&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; LocalStrategy &lt;span&gt;implements&lt;/span&gt; Strategy {&lt;br/&gt;  authenticate(username: &lt;span&gt;string&lt;/span&gt;, password: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (username !== &lt;span&gt;&#x27;abao&#x27;&lt;/span&gt; &amp;amp;&amp;amp; password !== &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;账号或密码错误&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;账号和密码认证成功&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; auth = &lt;span&gt;new&lt;/span&gt; Authenticator();&lt;br/&gt;&lt;br/&gt;auth.setStrategy(&lt;span&gt;new&lt;/span&gt; WechatStrategy());&lt;br/&gt;auth.authenticate(&lt;span&gt;&#x27;123456&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;auth.setStrategy(&lt;span&gt;new&lt;/span&gt; LocalStrategy());&lt;br/&gt;auth.authenticate(&lt;span&gt;&#x27;abao&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 应用场景及案例&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - passport-local：https://github.com/jaredhanson/passport-local&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - passport-oauth2：https://github.com/jaredhanson/passport-oauth2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - zod：https://github.com/vriad/zod/blob/master/src/types/string.ts&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、职责链模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;职责链模式是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYK5Ro2JicfYmoq4dRHeibldSgicBR1tfHmmjf1GFX43B3Ijn8jHv855dWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4305555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在公司中不同的岗位拥有不同的职责与权限。以上述的请假流程为例，当阿宝哥请 1 天假时，只要组长审批就可以了，不需要流转到主管和总监。如果职责链上的某个环节无法处理当前的请求，若含有下个环节，则会把请求转交给下个环节来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常的软件开发过程中，对于职责链来说，一种常见的应用场景是中间件，下面我们来看一下如何利用职责链来处理请求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYz2cnpExp89LOgLVLq0HgyDqUSFqVXgiaAKs5VX0vicYnd1CC4Sq51ulg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5805555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; IHandler {&lt;br/&gt;  addMiddleware(h: IHandler): IHandler;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractHandler &lt;span&gt;implements&lt;/span&gt; IHandler {&lt;br/&gt;  next!: IHandler;&lt;br/&gt;  addMiddleware(h: IHandler) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.next = h;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.next;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.next) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.next.get(url, callback);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义Auth中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Auth &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  isAuthenticated: &lt;span&gt;boolean&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;username: &lt;span&gt;string&lt;/span&gt;, password: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.isAuthenticated = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (username === &lt;span&gt;&#x27;abao&#x27;&lt;/span&gt; &amp;amp;&amp;amp; password === &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.isAuthenticated = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isAuthenticated) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Not Authorized&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义Logger中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Logger &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;/GET Request to: &#x27;&lt;/span&gt;, url);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; Route &lt;span&gt;extends&lt;/span&gt; AbstractHandler {&lt;br/&gt;  URLMaps: {[key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span/&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.URLMaps = {&lt;br/&gt;      &lt;span&gt;&#x27;/api/todos&#x27;&lt;/span&gt;: [{ title: &lt;span&gt;&#x27;learn ts&#x27;&lt;/span&gt; }, { title: &lt;span&gt;&#x27;learn react&#x27;&lt;/span&gt; }],&lt;br/&gt;      &lt;span&gt;&#x27;/api/random&#x27;&lt;/span&gt;: &lt;span&gt;Math&lt;/span&gt;.random(),&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(url: &lt;span&gt;string&lt;/span&gt;, callback: &lt;span&gt;(&lt;span&gt;data: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;.get(url, callback);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.URLMaps.hasOwnProperty(url)) {&lt;br/&gt;      callback(&lt;span&gt;this&lt;/span&gt;.URLMaps[url]);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; route = &lt;span&gt;new&lt;/span&gt; Route();&lt;br/&gt;route.addMiddleware(&lt;span&gt;new&lt;/span&gt; Auth(&lt;span&gt;&#x27;abao&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;)).addMiddleware(&lt;span&gt;new&lt;/span&gt; Logger());&lt;br/&gt;&lt;br/&gt;route.get(&lt;span&gt;&#x27;/api/todos&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;JSON&lt;/span&gt;.stringify({ data }, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;route.get(&lt;span&gt;&#x27;/api/random&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(data);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可处理一个请求的对象集合应被动态指定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定，客户端只需要把请求提交到链上即可。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;八、模板方法模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模板方法模式由两部分结构组成：抽象父类和具体的实现子类。&lt;strong&gt;通常在抽象父类中封装了子类的算法框架，也包括实现一些公共方法以及封装子类中所有方法的执行顺序&lt;/strong&gt;。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYNOdjfUEPciaNfMYZpJCCXRHjOoPAAC7wc8qLibIKIyWzcbUshQyW6QuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.34629629629629627&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，阿宝哥通过使用不同的解析器来分别解析 CSV 和 Markup 文件。虽然解析的是不同的类型的文件，但文件的处理流程是一样的。这里主要包含读取文件、解析文件和打印数据三个步骤。针对这个场景，我们就可以引入模板方法来封装以上三个步骤的处理顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下如何使用模板方法来实现上述的解析流程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 实现代码&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好地理解以下代码，我们先来看一下对应的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V252cp6PKgZhEk1W7DNYOicYLXjUAXclQXQ508iabWJhUgAfSR8aD4icKD2JbRjSK0klfVXnowCP1UsA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.524&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; fs &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;fs&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DataParser {&lt;br/&gt;  data: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  out: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 这就是所谓的模板方法&lt;/span&gt;&lt;br/&gt;  parse(pathUrl: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.readFile(pathUrl);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.doParsing();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.printData();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  readFile(pathUrl: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.data = fs.readFileSync(pathUrl, &lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;abstract&lt;/span&gt; doParsing(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  printData() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.out);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; CSVParser &lt;span&gt;extends&lt;/span&gt; DataParser {&lt;br/&gt;  doParsing() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.out = &lt;span&gt;this&lt;/span&gt;.data.split(&lt;span&gt;&#x27;,&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; MarkupParser &lt;span&gt;extends&lt;/span&gt; DataParser {&lt;br/&gt;  doParsing() {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.out = &lt;span&gt;this&lt;/span&gt;.data.match(&lt;span&gt;/&amp;lt;\w+&amp;gt;.*&amp;lt;\/\w+&amp;gt;/gim&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 使用示例&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; csvPath = &lt;span&gt;&#x27;./data.csv&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; mdPath = &lt;span&gt;&#x27;./design-pattern.md&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; CSVParser().parse(csvPath);&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; MarkupParser().parse(mdPath);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 应用场景&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;九、参考资源&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;维基百科 - 设计模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java设计模式：23种设计模式全面解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Design Patterns Everyday&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d5a87b0043a2faec24f11385810b6d6d</guid>
<title>[推荐] 技术选型：为什么批处理我们却选择了 Flink</title>
<link>https://toutiao.io/k/0n78gha</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;最近接手了一个改造多平台日志服务的需求，经过梳理，我认为之前服务在设计上存在缺陷。经过一段时间的技术方案调研，最终我们决定选择使用 Flink 重构该服务。&lt;/p&gt;&lt;p&gt;目前重构后的服务已成功经受了国庆节流量洪峰的考验，今日特来总结回顾，和大家分享一下经验。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;业务需求及背景&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在了解改造服务的需求前，我们首先要明确，要解决什么问题以及目前的服务是如何解决的。&lt;/p&gt;&lt;p&gt;当前的业务逻辑还是比较清晰的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;采集同一时段不同数据源的日志；&lt;/li&gt;&lt;li&gt;对采集的数据进行处理；&lt;/li&gt;&lt;li&gt;将处理后的数据上传到指定位置，供客户下载。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们面临的痛点和难点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;日志的数据量比较大：每小时未压缩的日志数据量有 50 多个 G，节假日等特殊时间节点，日志量会翻倍。&lt;/li&gt;&lt;li&gt;目前服务使用单机进行处理，速度比较慢，扩容不方便。&lt;/li&gt;&lt;li&gt;目前服务处理数据时需要清洗字段，按时间排序，统计某字段的频率等步骤。这些步骤都属于 ETL 中的常规操作，但是目前是以代码的形式实现的，我们想以配置形式减少重复编码，尽量更加简单、通用。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;方案1：我们需要一个数据库吗?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;针对以上业务需求，有同学提出：“我们可以把所有原始数据放到数据库中，后续的 ETL 可以通过 SQL 实现。”&lt;/p&gt;&lt;p&gt;如果你一听到&quot;数据库&quot;想到的就是 Pg、Mysql、Oracle 等，觉得这个方案不具有可行性，那你就错了。数据库的类型和维度是非常丰富的，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;811&quot; data-rawheight=&quot;618&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;811&quot; data-rawheight=&quot;618&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2046f993e1c0a87adb39d2d697e87749_b.jpg&quot;/&gt;&lt;figcaption&gt;△数据库行业全景图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;按业务负载特征，关系型数据库可分为 OLTP 数据库（交易型）和 OLAP 数据库（分析型) ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OLTP，Online Transaction Processing。OLTP 数据库最大的特点是支持事务，增删查改等功能强大，适合需要被频繁修改的&quot;热数据&quot;。我们耳熟能详的 Mysql、Pg 等都属于这一类。缺点就是由于支持事务，插入时比较慢。拿来实现我们的需求显然是不合适的。&lt;/li&gt;&lt;li&gt;OLAP，Online Analytical Processing，数据分析为主。不支持事务，或者说是对事务的支持有限。OLAP 的场景是：大多数是读请求，数据总是以相当大的批(&amp;gt; 1000 rows)进行写入，不修改已添加的数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;方案 1 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;OLAP 的使用场景符合我们的需求，为此我们还专门去调研了一下 ClickHouse。但是有一个因素让我们最终放弃了使用 OLAP。请注意，数据库存储的数据都是二维的，有行和列两个维度。但是日志只有行一个维度。如果说为了把日志存入数据库把每行日志都切分，那统计字段的需求也就顺手实现了，又何必存到数据呢?&lt;/p&gt;&lt;p&gt;所以，OLAP 使用场景隐含的一个特点是：存入的数据需要被多维度反复分析的。这样才有把数据存入数据库的动力，像我们当前的需求对日志进行简单的变形后仍旧以文本日志的形式输出，使用 OLAP 是不合适的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案2：Hive 为什么不行?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;看到这，熟悉大数据的同学可能会觉得我们水平很 Low，因为业务需求归根到底就是三个字：批处理。 &lt;/p&gt;&lt;p&gt;那我们为什么第一时间没有考虑上大数据呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;417&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;417&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b2359f08971047d09d069c415a66dab9_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 大数据处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;大数据确实如雷贯耳，但现在我们的日志处理这块大部分都是用 Golang 实现的，团队内的其他业务用了 Python、Lua、C，就是没有用过到 Java。而目前大数据都是基于 JVM 开发的。Golang 调用这些服务没有一个好用的客户端。&lt;/p&gt;&lt;p&gt;所以基于团队目前的技术储备，大数据才没有成为我们的首选。但是从目前的状况来看大数据是最优解了。那么我们该选用大数据的什么组件实现需求呢?&lt;/p&gt;&lt;p&gt;放弃使用数据库直接使用 HDFS 存储日志文件，应该是毋庸置疑的。&lt;/p&gt;&lt;p&gt;我们需求是离线批处理数据，对时效性没有要求，MapReduce 和 Hive 都能满足需求。但是 MapReduce 与 Hive 相比，Hive 在 MapReduce 上做了一层封装并且支持 SQL。看起来 Hive 是非常合适的。&lt;/p&gt;&lt;p&gt;那为什么最终放弃了 Hive 呢?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;机器资源问题。公司其他团队已经有一套 HDFS 的设施，只用来做存储，Hadoop 的 MapReduce 这个组件根本没跑起来。那套 HDFS 部署的机器资源比较紧张，他们担心我们使用 MapReduce 和 Hive 跑计算，会影响现在 HDFS 的性能; 我们想审批一批新的机器，重新使用 Ambari 搭建一套 Hadoop，却被告知没那么多闲置的机器资源。而且我们即便申请下来了机器，只跑目前服务也跑不满，机器资源大部分也会被闲置，也有浪费资源的嫌疑。&lt;/li&gt;&lt;li&gt;存储分离是趋势。在调研中我们发现，像 Hadoop 这样把存储和计算放到一起的已经比较&quot;落伍&quot;了。Hadoop 存储分离，需要修改源码，目前没有开源实现，只是云厂商和各个大数据公司有相关商业产品。从这个角度讲，即便我们自己搞定了机器资源搭一套 Hadoop，也只不过是拾人牙慧罢了。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;504&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4a36a4acf61b6fb5522c4202e55e7735_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 大数据生态图，图片来源于小枣君&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;方案 2 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;再合适的技术方案不能落地也是空谈。但是技术方案想要落地时，已经不是一个单纯的技术问题了，资源限制，团队限制等都需要考虑在内。&lt;/p&gt;&lt;p&gt;一个优秀的技术方案立足于解决当下的问题，并且能放眼未来勾画蓝图，这样大家觉得 &quot;有利可图&quot;，才愿意跟你一起折腾。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案3：为什么我们放弃了 Spark?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;通用的计算引擎&lt;/b&gt;&lt;/p&gt;&lt;p&gt;虽然使用 HDFS 的团队不赞成在他们的机器上跑 Hive，但是我们把日志数据存到他们的 HDFS 上还是没问题的。在已知 &quot;存储和分离是趋势&quot; 是前提的基础下，&quot;我们到底需要什么&quot; 这个问题已经有答案了。&lt;/p&gt;&lt;p&gt;我们需要的是一个通用的计算引擎。存储已经剥离给 HDFS 了，所以我们只需要找一个工具，帮我们处理 ETL 就可以了。Spark 和 Flink 正是这样的场景。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Spark 与 Flink 初次交锋&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Spark 和 Flink 之间，我们毫不犹豫地选择了 Spark。原因非常简单：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Spark 适合批处理。Spark 当初的设计目标就是用来替换 MapReduce。而 Spark 流处理的能力是后来加上去的。所以用 Spark 进行批处理，可谓得心应手。&lt;/li&gt;&lt;li&gt;Spark 成熟度高。Spark 目前已经发布到 3.0，而 Flink 尚在 Flink 1.x 阶段。Flink 向来以流处理闻名，虽然被国内某云收购后开始鼓吹 &quot;流批一体&quot;，但是线上效果还是有待检验的。&lt;/li&gt;&lt;li&gt;Scala 的加持。Spark 大部分是用 Scala 实现的。Scala 是一门多范式的编程语言，并且与 Haskell 有很深的渊源。Haskell 是一门大名鼎鼎的函数式编程语言。对于函数式编程语言，想必大多数程序猿都有一种 &quot;虽不能至，然心向往之&quot; 的情结。现在使用 Spark 能捎带着耍一耍函数式编程语言 Scala，岂不妙哉？&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;753&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;753&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-cab5f3da76c389c723b5cdfbcfc32b77_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Scala&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;挥泪斩 Spark&lt;/b&gt;&lt;/p&gt;&lt;p&gt;前文已经交代过了，我们否决掉 Hive 的一个重要因素是没有足够的机器资源。所以我们把 Spark 直接部署到云平台上。&lt;/p&gt;&lt;p&gt;对于我司的云平台要补充一些细节。&lt;/p&gt;&lt;p&gt;我们的云平台是基于 K8S 二次开发的，目前还在迭代当中，因此&quot;Spark on K8S&quot; 的运行模式我们暂时用不了。在这样的情况下，我们采用了 &quot;Spark Standalone&quot; 的模式。Standalone 模式，也就是Master Slaver 模式，类似于 Nginx 那样的架构，Master 节点负责接收分发任务，Slaver 节点负责&quot;干活&quot;。&lt;/p&gt;&lt;p&gt;等到我们在云平台上以 &quot;Spark Standalone&quot; 模式部署好了，跑了几个测试 Case 发现了新问题。我们的云平台与办公网络是隔离的，如果办公网络想访问云平台的某个 Docker 容器，需要配置域名。而 Spark 的管理页面上很多 URL 的 domain 是所在机器的 IP，容器的 IP 是虚拟 IP，容器重启后IP 就会改变。具体如图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;301&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;301&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-814f1110cacc77ebd8cff4ebee4be9fd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 部署在云平台的 spark&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Spark 的管理平台非常重要，因为能从这上面看到当前各个节点运行情况，任务的异常信息等，现在很多链接不能访问，不利于我们对 Spark 任务进行问题排查和调优。基于这个原因，我们最终放弃了 Spark。&lt;/p&gt;&lt;p&gt;&lt;b&gt;方案 3 小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Spark 你真的很优秀，擅长批处理，如此成熟，还有函数式的基因 。。。这些优点早让我倾心不已。&lt;/p&gt;&lt;p&gt;Spark 你真的是个好人，如果不是云平台的限制，我一定选择你。&lt;/p&gt;&lt;p&gt;Spark，对不起。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;方案4：Flink，真香！&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;给 Spark 发完好人卡后，我们看一看新欢 Flink。不客气的说，Flink 初期时很多实现都是抄的 Spark，所以二者的很多概念相似。所以 Flink 同样有 Standalone 模式，我们在部署阶段没遇到任何问题。&lt;/p&gt;&lt;p&gt;在跑了几个 Flink 测试 Case 后，我们由衷的感叹 Flink 真香。&lt;/p&gt;&lt;p&gt;放弃 Spark 时我们的痛点在于 &quot;部署在云平台上的 Spark 服务的管理界面很多功能无法使用&quot;，而 Flink 的管理平台完全没有这个问题。除此之外，Flink 管理平台的 &quot;颜值&quot; 和功能都是 Spark 无法比拟的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;管理平台颜值对比&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;155&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-81f492437b2251f815d5ecc50871e4c5_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Spark管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;487&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;487&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5c6ba1581fc95f0f3415440f80d516d0_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Flink管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;对比之下，Spark 的页面完全是个&quot;黄脸婆&quot;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Flink 管理平台功能&lt;/b&gt;&lt;/p&gt;&lt;p&gt;由于 Spark 的功能很多不能使用，所以就不重点和 Flink 做比较了。这里只说 Flink 几个让人眼前一亮的功能。&lt;/p&gt;&lt;p&gt;部署了 Flink 或 Spark 服务后，该如何下发计算任务呢? 一般是通过 bin 目录下的一个名称中包含 submit 的可执行程序。那如果想把 Flink 或 Spark 做成微服务，通过 http 接口去下发任务呢?&lt;/p&gt;&lt;p&gt;Spark1.0 的时候支持 http，2.0时这个功能基本上废掉了，很多参数不支持了，把 http 这个功能交由 jobService 一个第三方开源组件去实现。这个 jobService 的开源组件对云平台的支持也非常不友好。所以在我们看来，Spark 通过 Http 下发任务的路子基本被堵死了。&lt;/p&gt;&lt;p&gt;反观 Flink，管理平台的接口是 Restful 的，不仅支持 Http 下发计算任务，还可以通过相关接口查看任务状态和获取异常或返回值。&lt;/p&gt;&lt;p&gt;Flink 的任务分为几个不同的阶段，每个不同的阶段有不同的颜色。这样仅从颜色就可以判断出当前 Flink 任务执行的大致情况。如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;232&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;232&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4b93584c342c4241557a8a73b9236757_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Flink管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在任务详情页面，会有任务分解图和任务执行耗时表格，这两个结合起来能够知道当然 Flink 任务是如何分解的，是否出现数据倾斜的情况，哪个步骤耗时最多，是否有优化的空间。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;390&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;390&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5fbdbc218db74ca27303a7c0de607018_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;510&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-82e9fa77f69d496a517d722ebba0de46_b.jpg&quot;/&gt;&lt;figcaption&gt; △ 管理平台页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这就是做批处理技术选型时候的心路历程，随笔记了下来，希望对大家有所帮助。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/583/%25E5%25A6%2582%25E4%25BD%2595%25E9%2580%2589%25E6%258B%25A9%25E9%2580%2582%25E5%2590%2588%25E8%2587%25AA%25E5%25B7%25B1%25E7%25BD%2591%25E7%25AB%2599%25E7%259A%2584%25E9%2598%25B2%25E7%259B%2597%25E9%2593%25BE.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-56c5b7b098e6252cc7acb7a601428c09_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;640&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;如何选择适合自己网站的防盗链&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic2.zhimg.com/v2-56c5b7b098e6252cc7acb7a601428c09_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/577/HTTP%252F3%2520%25E6%259D%25A5%25E4%25BA%2586%25EF%25BC%258C%25E4%25BD%25A0%25E4%25BA%2586%25E8%25A7%25A3%25E5%25AE%2583%25E4%25B9%2588%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-cddf6e4c200fe6cc94c4b8edfdae7521_180x120.jpg&quot; data-image-width=&quot;1080&quot; data-image-height=&quot;523&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;HTTP/3 来了，你了解它么？&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic2.zhimg.com/v2-cddf6e4c200fe6cc94c4b8edfdae7521_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d073a2764d4084b6a06c7240b0a44f59</guid>
<title>[推荐] 《我想进大厂》之 JVM 夺命连环 10 问</title>
<link>https://toutiao.io/k/swi8lo6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者： 科技缪缪（本文来自作者投稿）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 说说 JVM 的内存布局？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlaX1kzmfeFkqNiaDiar0WVkM9WqfBbh6BW3EmEgTCVCW4XbhYQGBzhSXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 虚拟机主要包含几个区域：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;堆&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：堆是 Java 虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为 Young&lt;/span&gt;&lt;span&gt; 区年轻代和 Old 区老年代，其中年轻代又分为 Eden、S0、S1 3个部分，他们默认的比例是 8:1:1 的大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，它的参数会被传递至从0开始的连续的局部变量表中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态连接用于将符号引用表示的方法转换为实际方法的直接引用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;元数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在 Java1.7 之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;class 文件就是类和接口的定义信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时常量池就是类和接口的常量池运行时的表现形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;本地方法栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要用于执行本地 native 方法的区域。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;程序计数器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 知道 new 一个对象的过程吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.40390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlOvda0KYHkCicWv9Libm8FpZgRKScK30oQxYPNIOsfMgjEvMmq8Isb6Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当虚拟机遇见 &lt;strong&gt;new &lt;/strong&gt;关键字时候，实现判断当前类是否已经加载。如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先&lt;strong&gt;校验当前类是否被加载&lt;/strong&gt;，如果没有加载，执行类加载机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加载&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：就是从字节码加载成二进制流的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;验证&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当然加载完成之后，当然需要校验 class 文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为静态变量、常量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：执行 static 代码块 (cinit) 进行初始化，如果存在父类，先对父类进行初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：静态代码块是绝对线程安全的，只能隐式被 Java 虚拟机在类加载过程中初始化调用！(此处该有问题：&lt;strong&gt;static 代码块线程安全吗？&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先为对象分配合适大小的内存空间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着为实例变量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置对象的头信息，对象 hashcode、GC 分代年龄、元数据信息等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行构造函数 (init) 初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 知道双亲委派模型吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类加载器自顶向下分为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bootstrap ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（启动类加载器）：默认会去加载 JAVA_HOME/lib 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Extention ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（扩展类加载器）：默认去加载 JAVA_HOME/lib/ext 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Application ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（应用程序类加载器）：比如我们的 Web 应用，会加载 Web 程序中 ClassPath 下的类；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;User ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（用户自定义类加载器）：由用户自己定义。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们在加载类的时候，首先都会向上询问自己的父加载器是否已经加载。如果没有则依次向上询问；如果没有加载，则从上到下依次尝试是否能加载当前类，直到加载成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlZKccYiccqpOGYdIUwltUNPmmyib6Gz2W6IWH6FCIIxojeQpyjXpw6T5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 说说有哪些垃圾回收算法？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-清除&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统一标记出需要回收的对象，标记完成之后统一回收所有被标记的对象。而由于标记的过程需要遍历所有的 GC ROOT，清除的过程也要遍历堆中所有的对象，所以标记-清除算法的效率低下，同时也带来了内存碎片的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;复制算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决性能的问题，复制算法应运而生。它将内存分为大小相等的两块区域，每次使用其中的一块。当一块内存使用完之后，将还存活的对象拷贝到另外一块内存区域中，然后把当前内存清空。这样性能和内存碎片的问题得以解决。但是同时带来了另外一个问题，可使用的内存空间缩小了一半！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，诞生了我们现在的常见的&lt;strong&gt;年轻代+老年代&lt;/strong&gt;的内存结构：Eden+S0+S1 组成。因为根据 IBM 的研究显示，98%的对象都是朝生夕死，所以实际上存活的对象并不是很多，完全不需要用到一半内存浪费，所以默认的比例是 8:1:1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，在使用的时候只使用 Eden 区和 S0、S1 中的一个，每次都把存活的对象拷贝另外一个未使用的 Survivor 区，同时清空 Eden 和使用的 Survivor，这样下来内存的浪费就只有10%了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果最后未使用的 Survivor 放不下存活的对象，这些对象就进入 Old 老年代了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所以有一些初级点的问题会问你，为什么要分为 Eden 区和2个 Survior 区？有什么作用？就是为了节省内存和解决内存碎片的问题。这些算法都是为了解决问题而产生的，如果理解原因你就不需要死记硬背了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-整理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对老年代再用复制算法显然不合适，因为进入老年代的对象都存活率比较高了，这时候再频繁的复制对性能影响就比较大，而且也不会再有另外的空间进行兜底。所以针对老年代的特点，通过&lt;strong&gt;标记-整理&lt;/strong&gt;算法，标记出所有的存活对象，让所有存活的对象都向一端移动，然后清理掉边界以外的内存空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 什么是 GC ROOT？有哪些 GC ROOT？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面提到的标记的算法，怎么标记一个对象是否存活？简单的通过引用计数法，给对象设置一个引用计数器，每当有一个地方引用他，就给计数器+1，反之则计数器-1，但是这个简单的算法&lt;strong&gt;无法解决循环引用的问题&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 通过可达性分析算法来达到标记存活对象的目的，定义一系列的 GC ROOT 为起点。从起点开始向下开始搜索，搜索走过的路径称为引用链。当一个对象到 GC ROOT没有任何引用链相连的话，则对象可以判定是可以被回收的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而可以作为 GC ROOT 的对象包括：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态变量、常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本地方法栈 native 方法引用的对象。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 垃圾回收器了解吗？年轻代和老年代都有哪些垃圾回收器？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlS2swjribk4EibNmDPwGf1o5gqeRbkSdEKic67pibPqMEDGPf857pP2G1YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;年轻代的垃圾收集器包含有 Serial、ParNew、Parallell。老年代则包括 Serial Old 老年代版本、CMS、Parallel Old 老年代版本和 JDK11 中全新的 G1 收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单线程版本收集器，进行垃圾回收的时候会 STW（Stop The World），也就是进行垃圾回收的时候其他的工作线程都必须暂停。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;ParNew&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的多线程版本，用于和 CMS 配合使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Scavenge&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以并行收集的多线程垃圾收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的老年代版本，也是单线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Parallel Scavenge 的老年代版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;CMS（Concurrent Mark Sweep）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：CMS 收集器是以获取最短停顿时间为目标的收集器。相对于其他的收集器 STW 的时间更短暂，可以并行收集是它的特点，同时它基于&lt;strong&gt;标记-清除&lt;/strong&gt;算法。整个 GC 过程分为4步：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，不需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;重新标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发清除&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：清理删除掉标记阶段判断的已经死亡的对象，不需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程。而初始标记和重新标记的耗时较短，但是需要停止用户线程。总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;G1（Garbage First）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：G1 收集器是 JDK9 的默认垃圾收集器，不再区分年轻代和老年代进行回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. G1的原理了解吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlclwUSgRl1TKmdLvuBoicahRpa48GWyMADXRrVQhAiaryF7LPkLCC1TeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 作为 JDK9 之后的服务端默认收集器，不再区分年轻代和老年代进行垃圾回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把内存划分为多个 Region，每个 Region 的大小可以通过 &lt;strong&gt;-XX：G1HeapRegionSize&lt;/strong&gt; 设置，大小为1~32M。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于大对象的存储则衍生出 &lt;strong&gt;Humongous &lt;/strong&gt;的概念。超过 Region 大小一半的对象会被认为是大对象，而超过整个 Region 大小的对象被认为是超级大对象，将会被存储在连续的 N 个 Humongous Region 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 在进行回收的时候会在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先回收收益最大的 Region。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 的回收过程分为以下四个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最终标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：短暂暂停用户线程，再处理一次，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;筛选回收&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：更新 Region 的统计数据，对每个 Region 的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的 Region 中存活对象复制到空的 Region，同时清理旧的 Region。需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说除了并发标记之外，其他几个过程也还是需要短暂的 STW。G1 的目标是在停顿和延迟可控的情况下尽可能提高吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 什么时候会触发 YGC 和 FGC？对象什么时候会进入老年代？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个新的对象来申请内存空间的时候，如果 Eden 区无法满足内存分配需求，则触发 YGC。使用中的 Survivor 区和 Eden 区存活对象送到未使用的 Survivor 区。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 YGC 之后还是没有足够空间，则直接进入老年代分配。如果老年代也无法分配空间，触发 FGC，FGC 之后还是放不下则报出 OOM 异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.03125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlDlicFGn9Z2ic9ABVnrxWE9qzl4p4QOrbWyeZ1nEYqxGibianVicET1BqnLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;YGC 之后，存活的对象将会被复制到未使用的 Survivor 区。如果 S 区放不下，则直接晋升至老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而对于那些一直在 Survivor 区来回复制的对象，通过 &lt;strong&gt;-XX：MaxTenuringThreshold&lt;/strong&gt; 配置交换阈值，默认15次。如果超过次数同样进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，还有一种动态年龄的判断机制，不需要等到 MaxTenuringThreshold 就能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. 频繁 FullGC 怎么排查？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种问题最好的办法就是结合有具体的例子举例分析，如果没有就说一般的分析步骤。发生 FGC 有可能是内存分配不合理，比如 Eden 区太小，导致对象频繁进入老年代，这时候通过启动参数配置就能看出来，另外有可能就是存在内存泄露，可以通过以下的步骤进行排查：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. &lt;strong&gt;jstat -gcutil&lt;/strong&gt; 或者查看 gc.log 日志，查看内存回收情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlNzhFQZlnLpOEIWkoPIgE4pPQYFcZ8OVdAu4ibOBtawqVJOaLficd7icXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;S0、S1 分别代表两个 Survivor 区占比；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;E 代表 Eden 区占比，图中可以看到使用了78%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;O 代表老年代，M 代表元空间，YGC 发生54次，YGCT 代表 YGC 累计耗时，GCT 代表 GC 累计耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.196875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSllkLHHPvwzafVdDDsvk6lPxdJPUQ5M2uV0Cch5HD8LfnjWrjBGPJj0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[GC&lt;/span&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;span&gt;[FGC&lt;/span&gt;&lt;span&gt; 开头代表垃圾回收的类型；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PSYoungGen: 6130K-&amp;gt;6130K(9216K)] 12274K-&amp;gt;14330K(19456K), 0.0034895 secs&lt;/span&gt;&lt;span&gt; 代表 YGC 前后内存使用情况；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Times: user=0.02 sys=0.00, real=0.00 secs&lt;/span&gt;&lt;span&gt;：user 表示用户态消耗的 CPU 时间，sys 表示内核态消耗的 CPU 时间，real 表示各种墙时钟的等待时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这两张图只是举例并没有关联关系。比如你从图里面看能到是否进行 FGC、FGC 的时间花费多长；GC 后老年代，年轻代内存是否有减少；得到一些初步的情况来做出判断。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. dump 出内存文件在具体分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如通过 jmap 命令 &lt;strong&gt;jmap -dump:format=b,file=dumpfile pid&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;导出之后再&lt;/span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;span&gt;Eclipse Memory Analyze&lt;/span&gt;&lt;span&gt;r &lt;/span&gt;&lt;span&gt;等工具进行分析，定位到代码、&lt;/span&gt;&lt;span&gt;修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里还会可能存在一个提问的点，比如 &lt;strong&gt;CPU 飙高，同时 FGC 怎么办&lt;/strong&gt;？办法比较类似：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到当前进程的 pid，&lt;strong&gt;top -p pid -H&lt;/strong&gt; 查看资源占用，找到问题线程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;printf “%x\n” pid&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，把线程 pid 转为16进制，比如 0x32d；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;jstack pid|grep -A 10 0x32d &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;查看线程的堆栈日志，还找不到问题继续下一步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dump 出内存文件用 MAT 等工具进行分析，定位到代码、修复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. JVM调优有什么经验吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要明白一点，所有的调优的目的都是为了用更小的硬件成本达到更高的吞吐，JVM 的调优也是一样。通过对垃圾收集器和内存分配的调优达到性能的最佳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;简单的参数含义&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，需要知道几个主要的参数含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlLWMnkcBxCTMcdsOu97iaiaSbOv87f3heq6PbIWTnZOtQIaEy96HZxj8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-Xms&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置初始堆的大小，&lt;strong&gt;-Xmx &lt;/strong&gt;设置最大堆的大小；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewSize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代大小，&lt;strong&gt;-XX:MaxNewSize&lt;/strong&gt; 年轻代最大值，&lt;strong&gt;-Xmn&lt;/strong&gt; 则是相当于同时配置 -XX:NewSize 和 -XX:MaxNewSize 为一样的值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置年轻代和年老代的比值。如果为3，表示年轻代与老年代比值为 1:3，默认值为2；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:SurvivorRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代和两个 Survivor 的比值。默认值为8，代表比值为 8:1:1；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:PretenureSizeThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当创建的对象超过指定大小时，直接把对象分配在老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设定对象在 Survivor 复制的最大年龄阈值，超过阈值转移到老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxDirectMemorySize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当 Direct ByteBuffer 分配的堆外内存到达指定大小后，即触发 Full GC。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;调优&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了打印日志方便排查问题最好开启GC日志。开启GC日志对性能影响微乎其微，但是能帮助我们快速排查定位问题。&lt;strong&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一般设置 &lt;strong&gt;-Xms=-Xmx&lt;/strong&gt;。这样可以获得固定大小的堆内存，减少 GC 次数和耗时，可以使得堆相对稳定；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 让 JVM 在发生内存溢出的时候自动生成内存快照，方便排查问题；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;-Xmn&lt;/strong&gt; 设置新生代的大小。太小会增加 YGC，太大会减小老年代大小，一般设置为&lt;strong&gt;整个堆的1/4到1/3&lt;/strong&gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置 &lt;strong&gt;-XX:+DisableExplicitGC &lt;/strong&gt;禁止系统 System.gc()。防止手动误触发 FGC 造成问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651482823&amp;amp;idx=1&amp;amp;sn=cd623fbfa900f1217b34d34f980b2e82&amp;amp;chksm=bd2506b88a528faea643840bb2613ae67252085c24faaba2359006cc37335dc4fe042f1ca66d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;关于 JVM 内存的 N 个问题&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651488039&amp;amp;idx=1&amp;amp;sn=b812f2bd8b3e0e7edfdb2bb6c050894e&amp;amp;chksm=bd2513588a529a4e02c41f59fa78adc2c064b48b112a5120d53687b8ee84aff87524acecb479&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JVM 史上最最最完整深入解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486318&amp;amp;idx=1&amp;amp;sn=a0bf7b6896cc30cff1581243193200fc&amp;amp;chksm=bd2514118a529d0769979c50eaac2c8b5fef25cb8fdf550d9e24534d211700d0bd6befae2b64&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Boot项目优化和JVM调优&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好文章，我&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>