<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>337802376e8ca46ba8246e5f3c990458</guid>
<title>大话后端开发的奇淫技巧（二）</title>
<link>https://toutiao.io/k/7eacn7b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article itemscope=&quot;&quot; itemtype=&quot;http://schema.org/BlogPosting&quot;&gt;
            &lt;p&gt;从事服务端工作，已经有大几年了，从懵懂的小菜鸡，成长为可以自由飞翔的秃鹰，那些逝去青春和的头发见证了自己的成长&lt;/p&gt;

&lt;p&gt;或许，这就是高手的应该有样子吧&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.thankbabe.com/imgs/tule2.jpg&quot; alt=&quot;头秃图&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里将会把类似的问题/业务场景的解决方案中，提炼出相对通用的部分，作为经验进行梳理罗列出来，共勉&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;幂等&quot;&gt;幂等&lt;/h3&gt;

&lt;h4 id=&quot;业务场景&quot;&gt;业务场景：&lt;/h4&gt;

&lt;p&gt;用户多次点击按钮，或者因为设备的性能问题，连接的网络问题，点击按钮没反应，用户就会继续尝试点击，导致触发多次请求提交&lt;/p&gt;

&lt;h4 id=&quot;解决方案&quot;&gt;解决方案：&lt;/h4&gt;

&lt;p&gt;客户端防重点击：&lt;br/&gt;
防重点击，只允许点击一次，通过记录按钮的状态值，控制按钮不可点击，等响应结果回来才能再次被点击&lt;/p&gt;

&lt;p&gt;服务端:&lt;/p&gt;

&lt;p&gt;1.表约束&lt;/p&gt;

&lt;p&gt;表设计字段的唯一约束，比如：签到记录表，用户 ID+签到日期这两个字段组合建立唯一索引 UNIQUE，使用事物操作，先 INSERT 签到记录，成功后再去 UPDATE 积分
并行执行的时候，必然只能有一个 INSERT 成功，其他都失败，最终只会累加一次积分&lt;/p&gt;

&lt;p&gt;2.分布式锁&lt;/p&gt;

&lt;p&gt;分布式锁约束，可以利用 redis incr 原子操作的特性来实现&lt;/p&gt;

&lt;p&gt;在操作业务前，先获取用户 ID 的 incr，获取到值=1，代表获取到锁成功，进行原子操作，然后执行业务逻辑，执行成功后删除掉 key&lt;/p&gt;

&lt;p&gt;如果获取到值&amp;gt;1 获取执行锁失败，代表执行没结束，锁没有释放，无法继续执行，直接返回失败&lt;/p&gt;

&lt;p&gt;这里需要注意避免网络抖动或者业务执行报错导致最终 key 删除没成功，所以再执行 incr 获取锁成功后，同时获取下 ttl 值，如果 ttl 没设置，这个时候需要对 key 设置下 ttl，超出时间后让 key 自动过期，以免锁没释放，导致死锁&lt;/p&gt;

&lt;p&gt;3.token 机制&lt;/p&gt;

&lt;p&gt;在操作前先获取令牌 token，token 只能被使用一次，执行业务逻辑前，需要去 update token 使用状态，update 成功，才能执行后续业务逻辑，update 失败，代表 token 已经被使用，返回失败&lt;/p&gt;

&lt;p&gt;可以使用 mysql token 表+redis list，list 作为令牌桶，需要的业务从队列中 pop 获取令牌，使用的时候状态 update token 表&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;主从延迟&quot;&gt;主从延迟&lt;/h3&gt;

&lt;h4 id=&quot;业务场景-1&quot;&gt;业务场景：&lt;/h4&gt;
&lt;p&gt;用户反馈说看不到刚提交的数据或者没更新成功，或者触发了非正常流程能理解的逻辑，排查后发现数据正常&lt;/p&gt;

&lt;h4 id=&quot;解决方案-1&quot;&gt;解决方案：&lt;/h4&gt;

&lt;p&gt;说到主从延迟，大家应该就不陌生了，只要数据库（mysql，redis）部署是主从分离的，多多少少都会遇到过这种问题&lt;/p&gt;

&lt;p&gt;低概率场景，就是数据写入/更新到主库，从库因为网络抖动等原因，没有及时同步到，然后查询的时候走的是从库，导致查到的是脏数据，这种情况就只能竟可能保障服务器环境稳定&lt;/p&gt;

&lt;p&gt;其实出现这种问题比较多的情况是，insert/update 到主库成功后，马上就查询数据，这个时候可能数据还没同步到从库，虽然主从同步会比较快，但是还是有一定的延迟性&lt;/p&gt;

&lt;p&gt;这种情况就需要将查询指定到主库上进行操作，就可以避免主从延迟，查询不到最新数据的问题&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;并发&quot;&gt;并发&lt;/h3&gt;

&lt;h4 id=&quot;业务场景-2&quot;&gt;业务场景：&lt;/h4&gt;

&lt;p&gt;用户快速点击按钮，或者通过压测工具，写脚本发起并发请求分发到多台服务器，多台同时接收到请求，多次/并发请求有机率会并行执行，导致超出正常逻辑范围的问题&lt;/p&gt;

&lt;p&gt;往往在这种情况下，会出现很多异常的数据，比如：同一天多条的签到记录，并且多次累加积分奖励&lt;/p&gt;

&lt;p&gt;职业羊毛党使用工具或者写脚本恶意发起并发请求接口，翻倍获利后提现，从漏洞中谋取利益&lt;/p&gt;

&lt;h4 id=&quot;解决方案-2&quot;&gt;解决方案：&lt;/h4&gt;

&lt;p&gt;表约束&lt;br/&gt;
同 ↑ 幂等的解决方案&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;安全隐私&quot;&gt;安全隐私&lt;/h3&gt;

&lt;h4 id=&quot;业务场景-3&quot;&gt;业务场景：&lt;/h4&gt;

&lt;p&gt;在涉及用户隐私数据或者一些商业性敏感数据业务，接口下发数据的时候没有做脱敏，把用户的隐私的数据赤裸裸的暴露出来，如：将用户的手机号，身份证号码，等重要信息直接明文及接口输出&lt;/p&gt;

&lt;p&gt;将用户 ID 作为图片命名，可以轻松遍历用户上传的图片，身份证照片等，用于非法用途&lt;/p&gt;

&lt;h4 id=&quot;解决方案-3&quot;&gt;解决方案：&lt;/h4&gt;

&lt;p&gt;数据脱敏：&lt;/p&gt;

&lt;p&gt;在不违反系统规则条件下，对真实数据进行改造，进行数据脱敏&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据规则改造敏感数据输出
    
  &lt;/li&gt;
  &lt;li&gt;敏感数据传递，加密处理
    &lt;ul&gt;
      &lt;li&gt;aes 加密&lt;/li&gt;
      &lt;li&gt;hashids 足够短，不可预测且唯一的数字 ID&lt;/li&gt;
      &lt;li&gt;…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CND 媒体地址安全：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;大部分 cdn 平台都支持&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;URL 鉴权
    
  &lt;/li&gt;
  &lt;li&gt;防盗链
    
  &lt;/li&gt;
  &lt;li&gt;限制访问
    &lt;ul&gt;
      &lt;li&gt;Referer 防盗链&lt;/li&gt;
      &lt;li&gt;UserAgent 黑白名单&lt;/li&gt;
      &lt;li&gt;IP 黑白名单&lt;/li&gt;
      &lt;li&gt;等（具体看第三支持）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;mq-业务解耦神器&quot;&gt;MQ 业务解耦神器&lt;/h3&gt;

&lt;h4 id=&quot;异步业务解耦&quot;&gt;异步业务解耦&lt;/h4&gt;

&lt;p&gt;业务场景：&lt;/p&gt;

&lt;p&gt;比如，订单下单结算成功后，发送推送通知、发放优惠券奖励，操作业务异步任务，通知用户领取，等&lt;/p&gt;

&lt;p&gt;类似这种非业务主流程里内容，主流程执行完成后可以立即返回响应给用户，其他一些成功后的附加操作通过入列到 MQ，进行异步的处理&lt;/p&gt;

&lt;p&gt;MQ也可以用于实现跨进程，跨语言消息通讯&lt;/p&gt;

&lt;p&gt;通多订阅方便业务拓展，ack 机制保障执行的完成，死信队列，进行容错处理&lt;/p&gt;

&lt;p&gt;不同的MQ中间件的支持略有差异，各有各的特性，大同小异，不同MQ优势也不一样，可以根据自己的需求场景选择合适的中间件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;rabbitmq&lt;/li&gt;
  &lt;li&gt;kafka&lt;/li&gt;
  &lt;li&gt;rocketmq&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;img src=&quot;http://blog.thankbabe.com/imgs/mq.jpg&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;

&lt;h3 id=&quot;缓存大法&quot;&gt;缓存大法&lt;/h3&gt;

&lt;p&gt;在高并发场景下，通过缓存热数据，减轻 DB 压力，提高响应速度&lt;/p&gt;

&lt;p&gt;缓存可以分为服务端缓存和客户端缓存&lt;/p&gt;

&lt;p&gt;服务端缓存：&lt;/p&gt;

&lt;p&gt;当前使用比较多的分布式内存缓存数据库就是 redis，结合支持的数据类型和特性，再加上开发的创造力，可以满足大部分需求&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;但是在使用的过程中也会遇到一些使用不当的问题，这里罗列下常见的问题：&lt;/p&gt;

&lt;p&gt;1.缓存更新&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;对于一些用户私有数据&lt;/code&gt;，一般会在数据更新的时候，del cache，然后后续获取的数据的时候，先从 cache 中获取，如果不存在，再从 db-&amp;gt;cache，最后输出给用户&lt;/p&gt;

&lt;p&gt;但是由于网络抖动等，有可能会低概率的导致 del cache 没成功，所以，一般我们会在设置 cache 的时候加过期时间，让脏数据可以在短时间内失效，这样也可以对于一些不常查询的数据进行过期清理&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;对于一些公用的热数据&lt;/code&gt;，如：商品列表等，运营人员通过后台配置商品，配置完成后，最后操作缓存更新，这个时候需要对缓存进行平滑的过度更新，不能先删除 key，再写入缓存，这种操作会导致有用户在缓存更新进去前，短暂时间区间内获取不到商品&lt;/p&gt;

&lt;p&gt;之前做过类似的需求，解决方案就是，会在创建的缓存 key 设计版本号规则，然后缓存创建成功后，在替换可以展示的版本号，把旧的版本号的数据设置过期时间&lt;/p&gt;

&lt;p&gt;旧版本数据不能马上删除，设置合理过期时间，是因为旧版本数据还会在短时间内被使用，比如：用户已经使用旧版本数据查询，并且继续后面的分页查询，设置过期时间可以合理时间内再过去清理掉旧不使用的数据&lt;/p&gt;

&lt;p&gt;数据获取就先获取当前要展示的版本号，然后获取本号对应的数据&lt;/p&gt;

&lt;p&gt;早前有写过一个类似的，场景会更佳复杂的缓存更新的方案，&lt;a href=&quot;http://blog.thankbabe.com/2017/05/21/api-design/&quot;&gt;高并发业务接口开发思路&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.穿透&lt;/p&gt;

&lt;p&gt;cache 和 db 中都没有数据，读完 cache 没有，再读 db 还是没有，每次都请求到 cache 和 db&lt;/p&gt;

&lt;p&gt;一般情况就是 null 数据问题导致，解决方案就是，可以将null也缓存起来，避免穿透到 DB
如果有较多 null 数据，可以使用 bitmaps 布隆过滤器，来标识存储 null 的数据，节约存储空间&lt;/p&gt;

&lt;p&gt;3.击穿，雪崩&lt;/p&gt;

&lt;p&gt;出现大量 cache 数据同时过期，导致大量请求同时请到 db&lt;/p&gt;

&lt;p&gt;对于高并发业务的热数据的缓存，就不能删除/设置过期时间，只能通过平滑的过度进行更新，类似上面缓存更新中提到的方案&lt;/p&gt;

&lt;p&gt;4.压缩数据，数据过期&lt;/p&gt;

&lt;p&gt;redis缓存使用的是内存空间，所以比较稀缺，即使财大气粗分布式再多的机器，也经不起不起随意的霍霍&lt;/p&gt;

&lt;p&gt;对于不使用的字段，或者数据，都不要存储到缓存，有时候就是为了方便，直接json序列化整个对象，就直接缓存起来了&lt;/p&gt;

&lt;p&gt;对于用户私有的缓存，或者热度不高的缓存，需要设置缓存过期时间，避免长期不查询的垃圾数据堆积，占用空间，后面遇到的瓶颈，再来清理就麻烦了&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;客户端缓存:&lt;/p&gt;

&lt;p&gt;1.缓存版本数据&lt;/p&gt;

&lt;p&gt;客户端缓存数据+数据版本号，每次获取数据的时候上传数据版本号参数，服务端校验是否最新数据，如果是最新就不下发数据，客户端可以继续使用本地数据&lt;/p&gt;

&lt;p&gt;2.增量拉取更新&lt;/p&gt;

&lt;p&gt;服务端接口返回数据的时候，返回当前时间戳，客户端对数据和拉取时间戳进行缓存，后续客户端请求带上时间戳，服务端匹配更新时间&amp;gt;时间戳时间的数据，进行下发，实现客户端数据的增量/修改更新&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;redis 巧用&lt;/p&gt;



&lt;hr/&gt;

&lt;h3 id=&quot;日志监控&quot;&gt;日志/监控&lt;/h3&gt;

&lt;p&gt;关于日志：&lt;/p&gt;

&lt;p&gt;当线上用户反馈问题的时候，我们需要去排查问题，就靠用户的几段描述和APP的截图，有时候很难排查出根本问题&lt;/p&gt;

&lt;p&gt;这个时候如果能提供用户的请求日志轨迹就可以很好帮助到排查&lt;/p&gt;

&lt;p&gt;我们目前对于日志这块的支持有两块，一个是nginx请求日志，通过elk搭建日志系统，进行日志的收集和展示&lt;/p&gt;

&lt;p&gt;同时在数加也会备份可一份长时间的请求日志，对于历史过长的请求日志，可以到数加进行表查询&lt;/p&gt;

&lt;p&gt;一般的错误日志也可以上报到elk中，独立出一个err group方便查询&lt;/p&gt;



&lt;hr/&gt;

&lt;p&gt;关于监控：&lt;/p&gt;

&lt;p&gt;监控可以分为，服务器的监控，业务功能的监控&lt;/p&gt;

&lt;p&gt;线上服务器稳定性，决定了业务功能的稳定一个重要因素，这部分主要是运维这边去保障&lt;/p&gt;

&lt;p&gt;业务功能的监控，除了偶尔翻下错误日志，修复异常情况以外，还需要对于一些业务进行功能的监控，比如：一些定时的服务，定时的推送，每天整点需要对没有记录的用户进行提醒推送，需要保障圈定用户的效率和推送的速度，保障在规定时间内容推送出去&lt;/p&gt;

&lt;p&gt;随着业务增长，数据不断的增加，原本一个小时搞定的执行，可能会一直的延长，最后可能一整天都执行不完，对应这种业务，就需要在用户反馈之前，优先的get到问题，然后进行优化改善&lt;/p&gt;

&lt;p&gt;这个时候就需要有一个监控功能，对业务功能进行监控，超出预警进行预警通知，尽快的改善问题&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;在服务端开发的这几年，参与过公司里的好几个项目，有电商相关，工具类相关，等，因为项目本身技术背景和技术改进需要，在开发语言上也涉猎了好几门，有 .net（项目），java（项目），nodejs（项目），python（采集，爬虫），php（转岗项目），golang（微服务），谈不上每个语言都有多么的熟练，一般的业务开发是没有多大问题&lt;/p&gt;

&lt;p&gt;其实语言就是一个实现业务需求的工具，就像锄头和镐子，镰刀和柴刀，菜刀和小刀，基础使用方式差不多，就是在不同的需求场景下优势不一样，适合的场景使用适合的工具&lt;/p&gt;

&lt;p&gt;参与这么多个项目和涉猎这么多的语言，会发现服务端的经验是通用的，与语言和项目无关，就是解决一些问题和业务场景的解决思路和方案&lt;/p&gt;

&lt;p&gt;竟可能在一段时间里对参与过的业务/问题的解决方案进行梳理总结，这样才能很好的把共同场景的解决方案，提炼成自己的经验，不然时间一长很多做过的内容都忘记了&lt;/p&gt;

            &lt;hr/&gt;
            
            &lt;hr/&gt;
            &lt;blockquote&gt;
                &lt;p&gt;
                    
                    有任何想说的请留言哦
                    &lt;br/&gt;
                    转载请申明原文地址，谢谢合作
                &lt;/p&gt;
            &lt;/blockquote&gt;
            
            &lt;div&gt;
                &lt;p&gt;老铁们关注我的《大话WEB开发》微信公众号，跟踪我的原创博文&lt;/p&gt;
                &lt;p&gt;并不定时推荐WEB开发相关技术博文，共勉与学习交流！二维码↓&lt;/p&gt;
                &lt;img src=&quot;http://blog.thankbabe.com/imgs/gzh.jpg&quot; alt=&quot;我的公众号&quot;/&gt;
            &lt;/div&gt;
            
            
        &lt;/article&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f120f9c08a6cdc5e3d68b8f183d21b47</guid>
<title>要写系统设计文档了，但是不知道写什么，该怎么办?</title>
<link>https://toutiao.io/k/mrazqtw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;Ralph Jonhson 有一句绝对正确，但是毫无用处的名言：&lt;/p&gt;&lt;blockquote&gt;architecture is “the design decisions that need to be made early in a project”, but Ralph complained about this too, saying that it was more like the decisions you wish you could get right early in a project.&lt;br/&gt;His conclusion was that&lt;b&gt;“Architecture is about the important stuff. Whatever that is”&lt;/b&gt;.&lt;br/&gt;引用自：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//martinfowler.com/architecture/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;martinfowler.com/archit&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ecture/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;经常遇到的问题是，要开始一个新项目了，得像模像样的写系统设计文档了，但是写啥呢?&lt;/p&gt;&lt;p&gt;如果没有提前做好设计，以下两个症状是最常见的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;所有人似乎都在修改同一个文件，例如 order.php。所有需求似乎都堆积在少数几个人的身上。所有团队似乎都等着同一个模块的上线，但是一天只有24小时，没有足够的时间去在生产环境验证新部署的可靠性。&lt;/li&gt;&lt;li&gt;很多地方都在写非常类似的代码，比如每个 RPC 调用之后，都要手工再写一行日志。所有的列表页面，都要重复实现一次分页，排序等非常类似的功能。当出现性能问题，稳定性问题的时候，似乎需要修改一亿个地方才能改完。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;需要提前设计的东西，就是为了避免这两个项目到晚期会出现的症状。这两个症状的共同特点就是修复成本特别高，高到了“我们不如重写一遍”的地步。如何避免每次都走入同样的陷阱?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;良好的分工：啥叫良好，啥叫分工? 谁来天天盯着新代码被写到正确的git仓库，正确的目录，正确的文件里呢? 谁有这么无穷的精力来盯着每个人来写代码? 架构师么? 架构师不是第一天写好白板，剩下的实施工作都不管的甩手掌柜么? 需求变了，架构师管不管?&lt;/li&gt;&lt;li&gt;复用模块：啥叫复用，啥叫模块? 谁来写这些可复用的东西? 可复用的东西只满足我 80% 的需求怎么办? 我不知道有这个可复用的模块啊，我重复实现一遍又不是故意的。谁来盯着重复代码不会被反复地写出来呢? 我们团队分布在北京，杭州，成都，大家都不知道对方在干啥，咋复用?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有没有什么办法不去指望有一个万能的“独裁者”去天天盯着架构不被腐化，而是让架构朝着正确的方向自然而然的生长出来呢? 或者至少让这个“独裁者”能够不那么痛苦。一生二，二生三，三生万物。要做什么神奇的初始设计才能比较省力地达到理想的彼岸?&lt;/p&gt;&lt;h2&gt;如何做好分工&lt;/h2&gt;&lt;p&gt;我在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/taowen/modularization-examples&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;taowen/modularization-examples&lt;/a&gt; 里已经写了比较多的具体的例子了。需要看具体例子的同学，去读读里面的具体业务场景的例子。结论就是，最初始的设计就是要设计好分多少个模块，以及这些模块的依赖关系。如果你写的是 javascript，这里就是说需要分多少个 npm package，以及每个 npm package 中 package.json 的 dependencies 填什么。&lt;/p&gt;&lt;p&gt;要达成的目的是写限时折扣的人，不用去管团购业务是怎么做的。每块功能都可以最大程度地独立开发。传统的做法是需要有一个人一直盯着所有人写代码的时候把代码写到了正确的地方，这个做法对于 code review 的人压力很大，而且也容易造成返工。避免人来盯着的办法就是让“编译器”来盯着。也就是代码写错了地方，编译就无法通过。怎么做到这一点呢?&lt;/p&gt;&lt;p&gt;其秘诀就是让模块之间不产生直接的依赖关系。假设我们有 xszk-promotion, group-purchase 分别放了限时折扣的表，以及团购的表。这两个项目之间是没有直接的 dependency 关系的。这样如果在不正确的地方写了代码，这代码编译就无法通过。那我如果有地方需要集成两块业务怎么办? 解决办法就是“依赖倒置”，我们在最底层设置一个 motherboard 模块，它被 xszk-promotion 和 group-purchase 等业务模块所依赖。在 motherboard 中提供 SPI，也就是扩展点。每个业务模块往 motherboard 上注册。这个注册可以是编译期的扩展点，也可以是运行时的扩展点。&lt;/p&gt;&lt;p&gt;在这样的依赖关系下，我们只需要做一个初始的模块切分，以及依赖关系。然后日常的工作就是在新需求来的时候，决定是新建一个模块，还是写到已有的模块里。这个决策非常低频，日常的文件和目录级别的调整都是不用去关心的实现细节。另外一个日常工作就是盯着 motherboard 的改动，要严格控制被下沉的公共代码，确保98%的代码写在具体的独立的业务模块里，只有必要的业务集成变成 SPI 下沉到 motherboard 模块内。&lt;/p&gt;&lt;p&gt;值得注意的是，即便拆分微服务未必就控制了依赖关系。只要两个微服务之间可以直接 RPC 通信，那么这样的依赖关系并不会比函数直接调用更弱。只是从编译期的链接，改成了动态链接，从依赖关系的本质上没有变化。&lt;/p&gt;&lt;h2&gt;如何避免重复&lt;/h2&gt;&lt;p&gt;重复最难的是如何发现重复，其实是如何让其他人心甘情愿地复用你的东西。&lt;/p&gt;&lt;p&gt;一开始设计好所有可复用的东西并不是那么靠谱。虽然做过一两个项目之后，你会得出一些经验。例如一定要有一个日志库，一定要把 RPC 都封装到一个公共的地方。但是这些经验一般都局限于“非功能性需求”领域。这也是为啥架构师最后都沦为运维的命运，因为他们一般也就负责解决性能和稳定性问题。这些问题的特点就是通用，不管啥业务，都有“非功能性需求”。&lt;/p&gt;&lt;p&gt;对于具体业务里可能出现的重复，例如每个列表页都长得差不多，为啥要重复实现。这样的问题是没法提前预见的。依靠所有一线干活的人去判断是不是要抽个啥公共模块也是不靠谱的。因为具体到每一个人，他做的每一个业务对他来说都是第一次做。而且大家都是社恐，非常抗拒与同僚沟通，去让他们改已经写好的代码。&lt;/p&gt;&lt;p&gt;这个问题的正确的解决办法是“需求评审委员会”。所有的业务需求，都要由那么固定的几个人来准入。委员会的构成是资深的研发和产品经理。他们负责是&lt;/p&gt;&lt;p&gt;因为所有的需求都要经过有限的几个人来准入，所以他们可以很容易发现业务中的重复。如果应该重复而没有重复的地方，可以用“UI一致性”的大帽子扣上去，让产品经理去修改。&lt;/p&gt;&lt;p&gt;在发现了重复之后，总是需要某一部分人来做轮子给其他人复用的。要让别人愿意用你的轮子首先是政治问题（利益分配）。在解决了政治问题之后，就是你这个轮子是不是真的好用了。评价轮子易用性的唯一标准就是看复用这个轮子所需要传递的参数个数和复杂度。如果参数不明确，参数很诡异，参数几十个，谁都不愿意你用的轮子的。代码生成，运行时反射，动态链接库，谁也不一定比谁高级。都是要回答参数个数的问题，为什么要搞反射，要搞基于元数据的代码生成，其实都是在减少复用的人需要传递的参数个数。&lt;/p&gt;&lt;h2&gt;初始设计&lt;/h2&gt;&lt;p&gt;项目一开始应该做的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;预估出几个初始的模块，以及倒置的依赖关系&lt;/li&gt;&lt;li&gt;非功能性需求等可预见的复用代码&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;日常需要做的&lt;/p&gt;&lt;ul&gt;&lt;li&gt;严守 motherboard 模块的修改，避免倒置的依赖关系被破坏&lt;/li&gt;&lt;li&gt;合理判断新需求是否需要新增模块&lt;/li&gt;&lt;li&gt;需求评审委员会&lt;/li&gt;&lt;li&gt;不断减少参数个数&lt;/li&gt;&lt;/ul&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31b7c2bad8f06a8e09fa82bbd603183f</guid>
<title>程序员为什么转型管理？</title>
<link>https://toutiao.io/k/cxuwyue</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;
&lt;p&gt;一个享受编程的程序员为什么会有转管理的念头？更何况技术精进的好，不愁找工作，不愁加薪，还受领导重用，同事尊重，名利双收。我想通过亲身经历，说说转型管理的心路历程。&lt;/p&gt;
&lt;p&gt;转型管理，这个念头来自一次失败的创业经历。从那以后，意识到了，再好的技术，如果解决不了用户的痛点，投入再多的心血，也都是无用功。这是走向管理最重要的契机。除此之外，还有好奇心的驱动，做了七年多的开发，技术仍可以进步，但吸了水海绵，越吸越难，在管理这个新领域，很多知识都是新的，一碰就能吸进去。第三个原因，是想体验帮助人的快乐，程序员死磕代码，带来的是自我的成就感，做管理，能让光和热，温暖到更多的人。&lt;/p&gt;
&lt;p&gt;转管理更能创造价值。相对于程序员来讲，经理有更多的牌可以打，让程序员敲出的代码，能解决真正的问题，好钢用在刀刃上。这里所说的牌，是对项目更大的把控。首先，作为技术经理可以和产品经理及其他业务人员，围绕产品进行更深远的规划，因为技术经理可以从日常的事物中抽出身来，把花在机器上的编码调试时间省出来，抬头远眺，评估和管理产品可能遇到的风险。其次，可以利用所掌控的资源，为项目的进展保驾护航，特别是当项目遇到困难的时候，有权利调配研发力量，对产品进行迭代。最后，随着经历不断丰富，对产品，项目管理，技术实现等各个方面洞察力会不断增强，能从产品研发的全方位确保价值的产生。&lt;/p&gt;
&lt;p&gt;转管理更能博闻强识。程序员满足自身的求知欲，断然不是问题，这得益于技术更新换代的高速度。然而，程序员要做的优秀，最保险的是在技术领域深耕细作，这也往往限制了程序员对其他领域的探索和发现，失去了达到新高度的机会。做技术经理，除了对技术积累的要求外，有机会也有必要触及更多的领域。培养情商，有利于沟通；知晓心理学，有利于增强领导力；储备金融知识，有利于判断企业的发展潜力；学习决策组织管理，有利于在不同的机构不同的环境中游刃有余。自从转了管理以后，我发现了另外一片知识的海洋，享受着学习的快乐。&lt;/p&gt;
&lt;p&gt;转管理更能发现意义。写代码也好，做产品也好，达到职业巅峰也好。日出日落之后，是什么让你觉得你做的事情有意义。人作为一个社会动物，我觉得通过人与人之间的相处更容易找到意义。转了管理，考虑的不仅仅是自己，开始懂得照顾他人，关心团队的业绩，队员的成长。在对团队坚持不懈的支持下，团队取得的卓越绩效，队员的稳步成长，比独自撸代码战胜难题，更能带来满足感。&lt;/p&gt;
&lt;p&gt;上面说了我从程序员转型管理最重要的动机。然而我并不想盲目鼓励所有的程序员都去着急的转管理。这里有两个很重要的原因，首先，程序员和技术经理，不是黑与白的对立。管理特别是在技术领域下，需要程序员时期技术的沉淀，这样一来能更加深入的理解程序员这个群体的需求，二来帮助你得到程序员们新的信任，三是有助于敏锐的发现项目中暗藏的技术风险。&lt;/p&gt;
&lt;p&gt;除了需要技术积累，选择管理并不是对所有的人都适合。如果你喜欢专注起来做一件事，喜欢钻研事物的本质而成为某个领域的专家，比如某个数据库，或者某个编程语言。做程序员最大的幸事，就是你既可以做自己喜欢的，也可以衣食无忧。&lt;/p&gt;
&lt;p&gt;为什么要转型？如果你还没有答案，也不要过于纠结，大不了试一试，喜欢了就接着做，不喜欢可以继续做回工程师。这其实不但可行，反而会有意外的收获，因为管理，可以使你成为更好的工程师。因为从事管理，可以锻炼你更加全面长远的看待问题。也可以让你接触到更多的问题及解决办法，进而增加处理问题的经验。凡是没有绝对的黑和白，不同的岗位有不同的优缺点，如何找到合适你的，这是一个值得整个职业生涯都去考虑的事。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c843de582c692c50edef5ad79876df1</guid>
<title>Python 源码混淆与加密</title>
<link>https://toutiao.io/k/wvvxrwp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt; △点击上方&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;Python猫&lt;/span&gt;&lt;span&gt;”关注 ，回复“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”领取电子书&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6410788381742739&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTP3yyKQ9hktdb308Njp3pw44ic7IAJEWWz01qr61iaW95GiaPpVJD7Mf3CXFY4XnTBwytYZbkgPqichog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;482&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;作者：Collapsar&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源：360BugCloud&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Python 是一种解释型语言，没有编译过程，发布程序的同时就相当于公开了源码，这也是其作为开源语言的一个特性。但在某些场景下，我们的源码是不想被别人看到的，例如开发商业软件、编写 0day 漏洞 POC/EXP、免杀 shellcode 等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以免杀为例，如果打包的源码没做任何处理，安全研究人员在捕获到样本后连分析的过程都省掉了，直接通过源码锁定特征，很快免杀就会失效，这显然不是我们想看到的。因此对源码做相应的保护还是有必要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：本文代码只为介绍源码保护方法，不涉及免杀姿势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目前保护 Python 代码主要有以下几种方式：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n6&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对代码进行混淆以降低源码可读性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将 py 文件编译为二进制 pyc 文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 Pyinstaller 打包源码为二进制可执行文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 PyArmor 加密脚本&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将 py/pyc 文件使用 AES 加密为 pye 文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将 py 文件转为 c 文件后编译为动态链接库文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代码混淆&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码混淆是指在不改变代码逻辑的情况下，对代码结构进行变换，通过一些带有混淆性质的命名、注释等，使代码变得晦涩难懂，从而达到保护代码的作用。这里提供两种代码混淆的方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代码混淆库 pyobfuscate&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;pyobfuscate 会对代码中用户定义的类、函数、变量等进行重命名、更改代码缩进(默认1)、移除注释、添加不影响逻辑的代码语句，最终起到混淆的作用。不过 pyobfuscate 使用 Python2 编写，无法解析 Python3 中的 f-string 等特殊语法，因此使用前需要将源码进行一定程度的修改，当然也可以直接修改 pyobfuscate 库，增加对 Python3 版本的支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;样例 (对 malicious.py 文件进行混淆)：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n26&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;python2 pyobfuscate.py malicious.py &amp;gt; malicious_obfuscated.py&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4118457300275482&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joIia2IicuUgVwpxD2XREYOIU6kC6JfOxz7AoQawibGpI7FYvcBKU7yg7MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;效果如下图所示，左侧为一段从云端获取 shellcode 加载进内存执行的代码，右图为其混淆后的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4759581881533101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joJdoicMn6Hm0OIRbpDvnao4eiaNTTrECRaibhicIeCQD3iaX7L6Fjialqna0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1435&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出代码虽然进行了一定程度的变换，但代码结构基本还是原来的样子，并不能很有效的增加破解难度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;利用 AST 混淆源码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AST，即抽象语法树，它可以将源代码以树状结构表示。Python 内置了 ast 模块，该模块通过内置函数 compile() 和 parse() 将  Python 源代码解析为 AST，之后可以利用 ast 模块内的方法对 ast 节点进行相应的操作，混淆处理后使用 codegen 库将 AST 重新生成为 Python 源码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;样例：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n35&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;python2 astobf.py malicious.py &amp;gt; malicious_astobfed.py&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3852040816326531&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jo4wlTIiaRT76hYXhZibYZ8UHBfBoZS4Iv2kLtyQTAGT8T6JsBOwVjnAjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;效果如下图所示，AST 混淆后的代码略有修改，以保证 Python3 下脚本可正常执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4944769330734243&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jo1yDXSXrvz5pjicUyPDBm9ichLdVZ6vxicX8Gf3TWJjcD2XrqTVEZDLA0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1539&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;混淆后的代码使用 __import__ 动态导入模块、使用 getattr 调用类方法，这样就可以以字符串方式传入模块名和方法名，借由字符串翻转拼接、数字计算等方式达到混淆目的，相比之下，AST 方式的混淆效果明显要优于 pyobfuscate 库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;编译为 pyc 文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;pyc 文件是 Python 的字节码文件，其存在的意义在于每次调用模块时，不用重新对该模块进行解释，从而提高效率，减少性能损耗。但是在运行一个单独的脚本时，该脚本是不会被编译为 pyc 文件的，这是由于 Python 的解释器认为只有导入的包才会被不断复用，才有编译的价值。不过 Python 提供了 py_compile 库和 compileall 程序用于手动编译 py 文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;py_compile&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;python&quot; cid=&quot;n42&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot;&gt;import py_compile&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;py_compile.compile(file=&quot;malicious.py&quot;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;compileall&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n44&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;python -m compileall ./&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.25196850393700787&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joq9m9F1vQVF0H2gq0PzLtheqQtH0F5NUvSTGxPuBAAzsCAnMvfK7ictg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1143&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译为字节码文件后，确实没办法直接读取源码了，但是 Python 有 uncompyle6 这么一个跨版本反编译器，可以将 Python 字节码转换回等效的 Python 源代码。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n47&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot;&gt;python -m pip install uncompyle6&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;uncompyle6 malicious.cpython-37.pyc &amp;gt; malicious_Decompiled.py&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3840104849279161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jovEK7cETNQH2AYKqOySoBopQags76x2N78GeymyAu1mJw4pTCk0nAIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4966722129783694&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jokHFlJdlgx4Ryvw8UW3ic2qOPvgJmr8biawSHvic8VtR06icFMklaP7VibEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且 pyc 还有一个弊端，就是它依赖于 Python 解释器的版本，使用某版本解释器编译的 pyc 文件必须使用相同版本解释器运行才能正常工作， 所以实际上将 py 文件编译为 pyc 文件的实用性并不是很大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;打包为独立可执行程序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过将 Python 文件打包为独立可执行程序也是一种保护源码的方式。Windows 平台下 ，有 Pyinstaller 、 py2exe 和 cx_Freeze 等多种打包程序可以使用，以 Pyinstaller 为例，打包 malicious.py 命令如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n53&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot;&gt;python -m pip install pyinstaller&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;pyinstaller -Fw -i myicon.ico malicious.py&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-F 表示生成单文件，-w 表示隐藏控制台窗口，-i 表示为生成的 exe 文件添加图标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4313326551373347&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joqUFTbpewQJnOSsy6aYvuwniaiaIaI4M4dDBm4D05Zoibz9gWv2IuNjxicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Python 打包的 exe 程序并不是将文件编译为真正的机器码，而是将脚本编译为 pyc 后连同依赖文件、当前的 Python 解释器一同打包起来，根据命令参数生成文件夹或打包成单独的可执行文件。之后运行 exe 时，实际运行的是一个引导加载程序，引导加载程序会创建一个临时的 Python 环境，通过解释器副本来执行 pyc 文件。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于这种运行方式的特殊性，Pyinstaller 打包的 exe 文件也是可以被还原出源码的。使用 pyinstxtractor 解包 exe：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n58&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;python pyinstxtractor.py malicious.exe&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41230551626591233&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joqVlrnQ0h0ia9f2C5xUOIJBGzxHibF1aztjJnByribvR0icMJxYJdyv0TiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1414&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解包后的文件夹内包含了 malicious.pyc 文件，之后使用 uncompyle6 反编译该文件就可以拿到源码。所以将 Python 打包为 exe 只相当于在编译为 pyc 的基础上添加了一步打包操作，同样不能很有效的对源码进行保护。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用 PyArmor 加密代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n62&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p&gt;&lt;span&gt;PyArmor 是一个用于加密和保护 Python 脚本的工具。它能够在运行时刻保护 Python 脚本的二进制代码不被泄露，设置加密后 Python 源代码的有效期限，绑定加密后的 Python 源代码到硬盘、网卡等硬件设备。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的保障机制主要包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n65&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;加密编译后的代码块，保护模块中的字符串和常量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在脚本运行时候动态加密和解密每一个函数（代码块）的二进制代码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;代码块执行完成之后清空堆栈局部变量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过授权文件限制加密后脚本的有效期和设备环境&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PyArmor 的工作原理相对复杂，有兴趣的朋友可以参考官方的说明文档：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://pyarmor.readthedocs.io/。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 PyArmor 默认加密方式加密 malicious.py：&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n77&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;pyarmor obfuscate malicious.py&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5500878734622144&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jo7csSqg4bicTWSDL3ZPXvZl8ZszuoobkujwxU3bDqiblHtNAtqUg0cs0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.155467720685112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joBE3WUg7nUSy7RNLczCQ4R1ybalDgw93SwIUb6SHKh4iboQfyRwLEp3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加密后的文件前两行代码是引导代码，用于加载 pytransform 动态链接库和添加三个内置函数到 builtins 模块，之后调用 __pyarmor__ 导入加密模块执行加密代码。加密后的文件目录还有一个名叫 pytransform 的运行辅助包，它是解密文件所必须的，因此打包加密文件时需要同时将运行辅助包打包进去。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n81&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;pyinstaller -Fw --add-data &quot;pytransform;pytransform&quot; malicious.py&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.44569288389513106&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5josN61LRXTLyJsqViaokicId9mzXhBrxFoIcXM0a25smFQZwv45FdGHmSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1335&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PyArmor 使用分片式技术来保护 Python 脚本。所谓分片保护，就是单独加密每一个函数，在运行脚本的时候，只有当前调用的函数被解密，其他函数都没有解密。而一旦函数执行完成，就又会重新加密。这种方式相对于混淆来说，效果明显要好的多。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加密为 pye 文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;pyconcrete 是另一个 python 的文件加密库，安装它需要提供一个密钥，用于之后对源码文件进行加密，同时由于过程中涉及 .c 文件的编译，因此 Windows 下需要安装 VC++ build tools，Linux 下需要安装 GCC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解压出 pyconcrete 库源码后，使用 setup 进行安装。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n87&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;python setup.py install&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6798457087753134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joZHzylkhIecXnwOdppYd1tMcqYW917EZBJDL6EQObriafqk3uEqvho8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安装成功后复制 pyconcrete-admin.py 文件到项目文件夹就可以使用了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;pyconcrete 可以将源码文件夹下所有 py/pyc 文件通过 AES128 加密为 pye 文件，该文件无法被正常的 Pyhon 解释器解释，需要使用 pyconcrete 程序加载运行。当然也可以将函数定义部分提出来作为库文件单独加密，函数调用部分独立出来作为一个入口，如下，将 malicious.py 文件拆分为 malicious_func.py 和 malicious_enter.py。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5199686765857479&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joAu97n8umW9fHNmOrgnZXgpcwDQVtLzrY1y0B6Xwpo7Dq4eKbahT7vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1277&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对 malicious_func.py 文件单独加密。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n93&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;python pyconcrete-admin.py compile --source=malicious_func.py --pye&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joCjGibkDmV0MgjkZWSln1VSv0nojQg5NauKu33VZJVic9NO9zErfsMyicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1186&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加密后在只有 malicious_enter.py 和 malicious_func.pye 两个文件的情况下运行 malicious_enter.py 文件，脚本是可以在本地正常运行的，因为解释器在导入 pye 文件时会自动调用环境变量中的 pyconcrete 进行解密。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1962233169129721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joGmNLkGko8QyYMnyxic8omUwtLT1LLBKTGkZ8Mgw2WDZ18OII0QvH0Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果想将其打包为 exe 在其他机器上运行，还需要进行一些修改：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n98&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;修改 malicious_enter.py 文件，在首部导入 pyconcrete，以及加密脚本中需要用到的库，这是为了在调用 Pyinstaller 时，将 pyconcrete 解密程序和脚本依赖的库同时打包进 exe。pyconcrete 库需要在其他库之前导入，它会自动和其他模块挂钩，在其目录寻找 pye 文件，然后通过 _pyconcrete.pyd 对 pye 文件进行解密。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pyinstaller 不会将 pye 文件主动打包进 exe，需要在打包时通过 --add-data 添加。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5247813411078717&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jo2bcuXpkGpsULUSlyicKGWgcNXZIxYzicOSRLyDm621EHnO7WuQicazMkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样打包出的 exe 就可以执行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4096244131455399&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jobmg8DzUdTibUP6JDR9NHPEevFsUhe1nwO9ib0bbOadUVfQr0QvopHzsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 pyconcrete 加密的源码在运行时会调用 _pyconcrete.pyd 文件进行解密，该文件内存储了用于解密源码的密钥。由于其密钥隐藏在二进制数据中，无法通过十六进制编辑器直接看到，因此想要解密源码，就必须对 _pyconcrete.pyd 文件进行逆向分析，提取密钥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;编译为 pyd 文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面提到的 pyd 文件是 Python 的动态链接库，类似 Windows 下的 DLL 和 Linux 下的 SO，它是 Cython 结合 C 的编译器编译而来，涉及 C 的编译， 因此同样需要 VC++ build tools 或 GCC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上，Cython 是一门单独的语言，专门用来写 Python 的 C 扩展。原本是为了解决 Python 语言的效率问题，但由于其有专门的转换器可以将 .py 文件转换为 .c 文件 (自动加入大量 C-Python API ) 后编译为 pyd，因此也可以利用这个特点来保护 Python 源码，下面为编译方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;pyd 的文件为库文件，所以也需要一个 py 文件进行调用，这里还是使用 malicious_enter.py 和 malicious_func.py 作为示例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创建一个 py 文件，用于将 malicious_func.py 编译为 pyd。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;python&quot; cid=&quot;n112&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;from distutils.core import setup&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;from Cython.Build import cythonize&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;setup(&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    ext_modules = cythonize([&#x27;malicious_func.py&#x27;,]),&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    )&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cythonize 方法会将 malicious_func.py 的 Python 代码转换为 Cython 代码，之后调用 setup 将 .c 文件编译为 pyd。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;shell&quot; cid=&quot;n114&quot; mdtype=&quot;fences&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;python build_pyd.py build_ext --inpla&lt;/span&gt;&lt;span role=&quot;presentation&quot;&gt;ce&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6796714579055442&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joDgUcibduNZNOBTos0gokSZhAn0kBdooLqYMiab2THnVIFKciaibLsibgUUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以直接运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.20134228187919462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5joQxogL4K5ib596eLdjtwWsCUhciafvnXQVBSOFxJ1ZGtOCPcsLZiamibq3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以打包为 exe，Pyinstaller 会自动将 pyd 文件作为依赖导入。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.17105263157894737&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pajG4l5Gnt7KKiblia7tEibDwwjwicoly5jomNPJdPJ16O3U50QaL9aLjc8NkWlo423SyzrcCNNvFXiaiaS2YxFbK1Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1292&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译为 pyd 后，想要了解源码的逻辑就必须通过逆向来分析，相较于从 _pyconcrete.pyd 中提取密钥解密 pye，这种直接将完整逻辑代码编译为二进制文件的方式更不容易被逆向出来，逻辑写的越复杂，逆向分析的代价就越高。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;最后，&lt;/span&gt;&lt;span&gt;上面说的这些 Python 源码保护方法其实正常情况下很少会用得到，既然使用了 Python，一般也不会有人刻意去隐藏自己的代码。不过对于安全领域，这些方法还是有一定价值的。拿免杀来说，复杂的加解密流程，配合上面某些方法，说不定就能很好的隐藏自己的特征，养出一匹低调的马儿。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.45454545454545453&quot; data-w=&quot;22&quot; title=&quot;音符&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPiaJQXWGyC9wrUzIicibgXayrgibTYarT3A1yzttbtaO0JlV21wMqroGYT3QtPq2C7HMYsvicSB2p7dTBg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Python猫技术交流群开放啦！&lt;/span&gt;&lt;/strong&gt;群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请在公号内回复『&lt;strong&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;/strong&gt;』，获取猫哥的微信&lt;span&gt;（谢绝广告党，非诚勿扰！）&lt;/span&gt;~&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;近期热门文章推荐：&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247488178&amp;amp;idx=1&amp;amp;sn=afa599220900f2cba569fe25cd3c9826&amp;amp;chksm=fa585537cd2fdc21dc89ff9e9beca0f0fb9a4d77b71e350259bf53f77e65298ebd48c2bfd958&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python最会变魔术的魔术方法，我觉得是它！&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485372&amp;amp;idx=1&amp;amp;sn=9b5c5b75156b68a7a59f9228bf457196&amp;amp;chksm=fa584039cd2fc92f53f661e99c277ad85080421da3440fc7730d3171c0d34eac9ef80405a88c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;饿了么交易系统 5 年演化史&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485052&amp;amp;idx=1&amp;amp;sn=08fbfa7106e3dcc3939ccc3ef969607b&amp;amp;chksm=fa5841f9cd2fc8ef5ac6c8054542ef6b5579d738ccc44cd4e2371edd44179b51883a03f8ebbd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 任务自动化工具 tox 教程&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486028&amp;amp;idx=1&amp;amp;sn=ca225d5e85c47698db8bc1ff47849ece&amp;amp;chksm=fa584dc9cd2fc4dfa076da6f90b7d53a9ebd6b344512612612b5f241db18143fdc13404990a9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 为什么会有个奇怪的“...”对象？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.2336283185840708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTMJhESpVSgO3VPnQ9RrstXztuOsKekkV5W3jFZDGFsTqNwHaWkWzwNjYdEoc52ZpQQYE3Dz463gwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;565&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;91842&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;91842&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;感谢创作者的好文&lt;img data-ratio=&quot;0.8936170212765957&quot; data-type=&quot;png&quot; data-w=&quot;47&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e025946b1ff7de3e029391045a88a88b</guid>
<title>从面试角度分析 ArrayList 源码</title>
<link>https://toutiao.io/k/bgpyn76</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：本系列文章中用到的jdk版本均为&lt;code&gt;java8&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;类图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5584594222833562&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgiaG5BicLkVdL73ibGvmicTmuU0Fe2U9aQXMsfZRm5HkRNK2pZtT4Bs73gJIRdVTrSl36cC4Vaac5reue4zWEwb5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;的底层是由数组实现的，数组的特点是&lt;code&gt;固定&lt;/code&gt;大小，而&lt;code&gt;ArrayList&lt;/code&gt;实现了&lt;code&gt;动态扩容&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;部分变量如下，在下面的分析中会用到这些变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 默认容量&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 空的对象数组&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] EMPTY_ELEMENTDATA = {};&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 无参构造器创建的空数组&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 存放数据的数组的缓存变量&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;transient&lt;/span&gt; Object[] elementData;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 元素数量&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;一 初始化ArrayList&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化&lt;code&gt;ArrayList&lt;/code&gt;一般会使用以下两个构造器&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 无参构造器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化&lt;code&gt;ArrayList&lt;/code&gt;的时候如果不指定大小，则会创建一个空数组。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 指定数组大小的构造器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个&lt;strong&gt;预估&lt;/strong&gt;大小的数组，指定大小后只是指定了数组初始值的大小，不影响后面扩容，指定的好处就是可以节省内存及时间上的开销。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; initialCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.elementData = &lt;span&gt;new&lt;/span&gt; Object[initialCapacity];&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (initialCapacity == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.elementData = EMPTY_ELEMENTDATA;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;Illegal Capacity: &quot;&lt;/span&gt;+initialCapacity);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;二 添加元素、动态扩容&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayList.add(E e)源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ensureCapacityInternal(size + &lt;span&gt;1&lt;/span&gt;);  &lt;span&gt;// Increments modCount!!&lt;/span&gt;&lt;br/&gt;    elementData[size++] = e;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;add()&lt;/code&gt;中&lt;code&gt;elementData[size++] = e&lt;/code&gt;很好理解，就是将元素插入第&lt;code&gt;size&lt;/code&gt;个位置，然后将&lt;code&gt;size++&lt;/code&gt;，我们重点来看看&lt;code&gt;ensureCapacityInternal(size + 1)&lt;/code&gt;方法；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureCapacityInternal&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; minCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {&lt;br/&gt;        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&lt;br/&gt;    }&lt;br/&gt;    ensureExplicitCapacity(minCapacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ensureCapacityInternal()&lt;/code&gt;方法中判断缓存变量&lt;code&gt;elementData&lt;/code&gt;是否为空，也就是判断是否是第一次添加元素，如果是第一次添加元素，则设置初始化大小为默认容量&lt;code&gt;10&lt;/code&gt;，否则为传入的参数。这个方法的目的就是&lt;strong&gt;获取初始化数组容量&lt;/strong&gt;。获取到初始化容量后调用&lt;code&gt;ensureExplicitCapacity(minCapacity)&lt;/code&gt;方法；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureExplicitCapacity&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; minCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    modCount++;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// overflow-conscious code&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (minCapacity - elementData.length &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        grow(minCapacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ensureExplicitCapacity(minCapacity)&lt;/code&gt;方法用来判断是否需要扩容，假如第一次添加元素，&lt;code&gt;minCapacity&lt;/code&gt;为&lt;code&gt;10&lt;/code&gt;，&lt;code&gt;elementData&lt;/code&gt;容量为&lt;code&gt;0&lt;/code&gt;，那么就需要去扩容。调用&lt;code&gt;grow(minCapacity)&lt;/code&gt;方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 数组的最大容量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_ARRAY_SIZE = Integer.MAX_VALUE - &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;grow&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; minCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// overflow-conscious code&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; oldCapacity = elementData.length;&lt;br/&gt;    &lt;span&gt;// 扩容大小为原来数组长度的1.5倍&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 扩容容量比需要扩容的长度小，则使用需要扩容的容量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        newCapacity = minCapacity;&lt;br/&gt;    &lt;span&gt;// 扩容容量比最大数组长度大，则使用最大整数长度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        newCapacity = hugeCapacity(minCapacity);&lt;br/&gt;    &lt;span&gt;// minCapacity is usually close to size, so this is a win:&lt;/span&gt;&lt;br/&gt;    elementData = Arrays.copyOf(elementData, newCapacity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;grow(minCapacity)&lt;/code&gt;方法对数组进行扩容，扩容大小为原数组的&lt;code&gt;1.5&lt;/code&gt;倍，如果计算出的扩容容量比需要的容量小，则扩容大小为需要的容量，如果扩容容量比数组最大容量大，则调用&lt;code&gt;hugeCapacity(minCapacity)&lt;/code&gt;方法，将数组扩容为整数的最大长度，然后将&lt;code&gt;elemetData&lt;/code&gt;数组指向新扩容的内存空间并将元素复制到新空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当需要的集合容量特别大时，扩容&lt;code&gt;1.5&lt;/code&gt;倍就会非常消耗空间，因此建议初始化时预估一个容量大小。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三 删除元素&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;提供两种删除元素的方法，可以通过&lt;code&gt;索引&lt;/code&gt;和&lt;code&gt;元素&lt;/code&gt;进行删除。两种删除大同小异，删除元素后，将后面的元素一次向前移动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayList.remove(int index)源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    rangeCheck(index);&lt;br/&gt;&lt;br/&gt;    modCount++;&lt;br/&gt;    E oldValue = elementData(index);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; numMoved = size - index - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        System.arraycopy(elementData, index+&lt;span&gt;1&lt;/span&gt;, elementData, index,&lt;br/&gt;                         numMoved);&lt;br/&gt;    elementData[--size] = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// clear to let GC do its work&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; oldValue;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除元素时，首先会判断索引是否大于&lt;code&gt;ArrayList&lt;/code&gt;的大小，如果索引范围正确，则将索引位置的下一个元素赋值到索引位置，将&lt;code&gt;ArrayList&lt;/code&gt;的大小&lt;code&gt;-1&lt;/code&gt;，最后返回移除的元素。操作图如下，假如我要移除索引为&lt;code&gt;1&lt;/code&gt;的元素：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5144628099173554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgiaG5BicLkVdL73ibGvmicTmuU0Fe2U9aQXFQAicJj7EWT9iaU5vaZaWyVx66kbURDHDWVse9qal5r3cQBTCPib3LnGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;四 总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;底层是数组实现的，可以进行动态扩容，扩容大小为原来的1.5倍，虽然可以通过动态扩容，但是数组非常大时会特别浪费空间，因此建议初始化时预估数组大小。&lt;code&gt;ArrayList&lt;/code&gt;允许插入重复值和空值。&lt;code&gt;ArrayList&lt;/code&gt;实现了&lt;code&gt;RandomAccess&lt;/code&gt;接口，支持快速随机访问，就是可以通过索引快速查到某个元素，因此遍历时使用for循环的方式效率更高。&lt;code&gt;ArrayList&lt;/code&gt;是线程不安全的，可以通过&lt;code&gt;Collections.synchronizedList&lt;/code&gt;将其转变为线程安全的集合，不过一般不会使用，&lt;code&gt;Vector&lt;/code&gt;和&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;是线程安全的，&lt;code&gt;Vector&lt;/code&gt;性能一般，逐渐被&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;取代了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>