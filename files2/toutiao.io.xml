<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f3edf1b859ee8ff280db3074224f9fba</guid>
<title>从维护性工作到软件开发革命，运维 15 年间的大逆转</title>
<link>https://toutiao.io/k/xr13s7n</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
&lt;p id=&quot;app&quot;/&gt;
&lt;img src=&quot;https://static001.infoq.cn/static/infoq/img/logo-121-75.yuij86g.png&quot; alt=&quot;从维护性工作到软件开发革命，运维15年间的大逆转_DevOps_Tina_InfoQ精选文章&quot;/&gt;





    

&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>60b906bc208db3d6569275c07c574c47</guid>
<title>如何学习架构，一个系列帮助你构筑架构知识体系</title>
<link>https://toutiao.io/k/i9clyuy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-default-content content__default&quot;&gt;&lt;h1 id=&quot;♥架构---知识体系详解♥&quot;&gt;&lt;a href=&quot;#♥架构---知识体系详解♥&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; ♥架构 - 知识体系详解♥&lt;/h1&gt; &lt;div class=&quot;custom-block tip&quot;&gt;&lt;p class=&quot;custom-block-title&quot;&gt;TIP&lt;/p&gt; &lt;p&gt;本系列将带你梳理下架构相关的知识体系。@pdai&lt;/p&gt;&lt;/div&gt;  &lt;h2 id=&quot;如何学习架构&quot;&gt;&lt;a href=&quot;#如何学习架构&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 如何学习架构&lt;/h2&gt;  &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/arch/arch-x-overview-learn2.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;h3 id=&quot;基础到方法论&quot;&gt;&lt;a href=&quot;#基础到方法论&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 基础到方法论&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;包括架构的概述，特点，目标，本质以及方法论等&lt;/p&gt;&lt;/blockquote&gt;  &lt;h3 id=&quot;如何理解架构&quot;&gt;&lt;a href=&quot;#如何理解架构&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 如何理解架构&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;理解架构，包括架构的视角，架构的演进，服务化演进，架构的核心要素&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-view.html&quot;&gt;架构 - 理解构架的视角&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在学习架构时，我认为首先要理清楚架构的视角，&lt;strong&gt;因为你所认知的架构和别人所说的架构可能是两码事&lt;/strong&gt;。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-evolution.html&quot;&gt;架构 - 理解架构的演进&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在学习架构时，&lt;strong&gt;第一步不要去学习框架，而是要学习架构的演进&lt;/strong&gt;。强烈推荐李智慧老师的《大型网站技术架构》，这本书翻起来很快，对构筑你自己的体系很有帮助，本文的内容来源于它，在此基础上拓展了下。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-service.html&quot;&gt;架构 - 理解架构的服务演化&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Kubernetes、Service Mesh 和 Serverless应该是最近比较火的了，而上文主要从&lt;strong&gt;逻辑架构角度&lt;/strong&gt;分析了架构演进，本文将从&lt;strong&gt;服务演化&lt;/strong&gt;和&lt;strong&gt;容器编排化&lt;/strong&gt;的角度帮你增强对架构演进的认识。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-pattern.html&quot;&gt;架构 - 理解架构的模式1&lt;/a&gt; &lt;ul&gt;&lt;li&gt;架构演进中有很多知识点，总体上可以归结为以下模式，&lt;strong&gt;这里说的模式本质是架构中技术点的抽象&lt;/strong&gt;。强烈推荐李智慧老师的《大型网站技术架构》，本文的内容也是来源于它，在此基础上拓展了下。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-pattern-2.html&quot;&gt;架构 - 理解架构的模式2&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-core-metrics.html&quot;&gt;架构 - 理解架构的核心要素&lt;/a&gt; &lt;ul&gt;&lt;li&gt;一般来说软件架构需要关注&lt;strong&gt;性能、可用性、伸缩性、扩展性和安全性这5个架构要素&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;h3 id=&quot;架构高并发和高可用&quot;&gt;&lt;a href=&quot;#架构高并发和高可用&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 架构高并发和高可用&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;架构高并发和高可用技术点主要包含如下方面。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-cache.html&quot;&gt;架构之高并发：缓存&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;高并发实现的三板斧：缓存，限流和降级&lt;/strong&gt;。缓存在高并发系统中有者极其广阔的应用，需要重点掌握，本文重点介绍下缓存及其实现。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-ratelimit.html&quot;&gt;架构之高并发：限流&lt;/a&gt; &lt;ul&gt;&lt;li&gt;每个系统都有服务的上线，所以当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。限流其实就是：当高并发或者瞬时高并发时，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价或者延迟处理请求为代价，保证系统整体服务可用。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-reduce.html&quot;&gt;架构之高并发：降级和熔断&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在高并发环境下，&lt;strong&gt;服务之间的依赖关系导致调用失败，解决的方式通常是: 限流-&amp;gt;熔断-&amp;gt;隔离-&amp;gt;降级, 其目的是防止雪崩效应&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-loadbalance.html&quot;&gt;架构之高可用：负载均衡&lt;/a&gt; &lt;ul&gt;&lt;li&gt;负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-backup.html&quot;&gt;架构之高可用：容灾备份,故障转移&lt;/a&gt; &lt;ul&gt;&lt;li&gt;容灾技术是系统的高可用性技术的一个组成部分，容灾系统更加强调处理外界环境对系统的影响，特别是灾难性事件对整个IT节点的影响，提供节点级别的系统恢复功能。故障转移（failover），即当活动的服务或应用意外终止时，快速启用&lt;strong&gt;冗余&lt;/strong&gt;或备用的服务器、系统、硬件或者网络接替它们工作。故障恢复是在计划内或计划外中断解决后&lt;strong&gt;切换回主站点&lt;/strong&gt;的过程。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;此外还需要关注下架构的安全。&lt;/p&gt;  &lt;h3 id=&quot;分层下看架构技术点&quot;&gt;&lt;a href=&quot;#分层下看架构技术点&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 分层下看架构技术点&lt;/h3&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/arch/arch-x-overview-layer2.jpg&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;p&gt;以上采用七层逻辑架构，第一层客户层，第二层前端优化层，第三层应用层，第四层服务层，第五层数据存储层，第六层大数据存储层，第七层大数据处理层。&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;客户层&lt;/strong&gt;：减少Http请求数，浏览器缓存，启用压缩，Js异步，减少Cookie传输；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;前端层&lt;/strong&gt;：DNS负载均衡，CDN本地加速，反向代理服务；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;：业务拆分；负载均衡，分级管理，应用缓存，服务集群，快速失败，异步调用，服务降级，消息队列，幂等设计等。&lt;/li&gt; &lt;li&gt;&lt;strong&gt;服务层&lt;/strong&gt;：提供公用服务，比如用户服务，订单服务，支付服务等；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;数据层&lt;/strong&gt;：分布式, 数据库集群，读写分离，NOSQL集群，文件系统集群；分布式缓存；冗余备份（冷，热备[同步，异步]，温备），失效转移（确认，转移，恢复）。CAP理论，一致性算法。&lt;/li&gt; &lt;li&gt;&lt;strong&gt;大数据存储层&lt;/strong&gt;：支持应用层和服务层的日志数据收集，关系数据库和NOSQL数据库的结构化和半结构化数据收集；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;大数据处理层&lt;/strong&gt;：通过Mapreduce进行离线数据分析或Storm实时数据分析，并将处理后的数据存入关系型数据库。（实际使用中，离线数据和实时数据会按照业务要求进行分类处理，并存入不同的数据库中，供应用层或服务层使用）。&lt;/li&gt;&lt;/ul&gt; &lt;h3 id=&quot;架构案例分析&quot;&gt;&lt;a href=&quot;#架构案例分析&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 架构案例分析&lt;/h3&gt;  &lt;p&gt;&lt;strong&gt;更多待整合的文章&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;如何从 0 到 1 设计、构建移动分析架构
https://blog.csdn.net/weixin_44326589/article/details/93463878&lt;/p&gt; &lt;p&gt;蚂蚁金服面对亿级并发场景的组件体系设计
https://juejin.im/post/5cda3131e51d4514df42076f&lt;/p&gt; &lt;p&gt;高德服务单元化方案和架构实践
https://yq.aliyun.com/articles/728021&lt;/p&gt; &lt;p&gt;从 0 到 100——知乎架构变迁史
https://www.infoq.cn/article/2014/12/zhihu-architecture-evolution/
https://www.jianshu.com/p/2639b7bb0d74&lt;/p&gt; &lt;p&gt;蚂蚁金服 11.11：支付宝和蚂蚁花呗的技术架构及实践
https://www.infoq.cn/article/technical-architecture-of-alipay-and-ant-check-later/&lt;/p&gt; &lt;p&gt;新浪微博王传鹏：微博推荐架构的演进
http://www.uml.org.cn/zjjs/2015092801.asp&lt;/p&gt; &lt;p&gt;互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构
https://github.com/davideuler/architecture.of.internet-product&lt;/p&gt;&lt;/div&gt; &lt;footer class=&quot;page-edit&quot;&gt; &lt;p class=&quot;last-updated&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;上次更新: &lt;/span&gt; &lt;span class=&quot;time&quot;&gt;2022/5/17 下午10:43:17&lt;/span&gt;&lt;/p&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ddbdb065bf9499af70fdb18f8f106621</guid>
<title>从HTTP.TRANSPORT看连接池的设计</title>
<link>https://toutiao.io/k/sl5a7p7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;&amp;#13;
            &lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文基于Golang 1.17.6&lt;/p&gt;
&lt;h2&gt;1.前言&lt;/h2&gt;
&lt;p&gt;之前萌叔曾在文章&lt;br/&gt;
&lt;a href=&quot;https://vearne.cc/archives/448&quot;&gt;imroc/req 连接池使用须知&lt;/a&gt; 提及过Golang标准库net/http提供的连接池http.Transport，但是是浅尝辄止。&lt;br/&gt;
本文萌叔想从http.Transport出发来谈谈一个连接池设计应该考虑哪些问题？&lt;/p&gt;
&lt;h2&gt;2.连接池的功能特征&lt;/h2&gt;
&lt;p&gt;下图是针对Grpc和Thrift压测结果(见参考资料1)。我么可以看出，长连接相比与短连接相比，QPS大概提升了1倍多。这是因为长连接减少连接建立的所需的3次握手。&lt;br/&gt;
&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220620/607da666-f04a-11ec-8e33-5626e1cdcfe1.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
要对长连接进行管理，特别是对闲置的长连接进行管理，就不可避免的引入连接池。&lt;/p&gt;
&lt;h2&gt;特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;需要一个连接时，并不一定真的创建新连接，而是优先尝试从连接池选出空闲连接;如果连接池对应的连接为空，才创建新连接。&lt;/li&gt;
&lt;li&gt;销毁并不是真的销毁，而是将使用完毕的连接放回连接池中（逻辑关闭）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里引出了几个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q1:获取连接阶段，我们有没有办法知道从连接池中取出的空闲连接(复用)是有效的，还是无效的？&lt;/li&gt;
&lt;li&gt;Q2:把使用完毕的连接放回连接池的阶段，空闲连接数量是否要做上限的约束。如果空闲连接数量有上限约束且空闲连接的数量已经达到上限。那么把连接放回连接池的过程，必然需要将之前的某个空闲连接进行关闭，那么按照什么规则选择这个需要关闭的连接。&lt;/li&gt;
&lt;li&gt;Q3:放置在连接池中的连接，随着时间的流逝，它可能会变成无效连接(stale)。比如由于Server端定时清理空闲连接。那么为了确保连接池中连接的有效性，是否需要引入定时的检查逻辑？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.net/http中连接池的实现&lt;/h2&gt;
&lt;p&gt;net/http中连接池的实现代码在&lt;br/&gt;
&lt;a href=&quot;https://github.com/golang/go/blob/go1.17.6/src/net/http/transport.go#L95&quot;&gt;net/http/transport.go&lt;/a&gt; 中&lt;/p&gt;
&lt;h3&gt;获取连接&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;Transport.RoundTrip() -&amp;gt; Transport.getConn()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;放回连接(逻辑关闭)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;Response.Body.Close() -&amp;gt; bodyEOFSignal.Close() -&amp;gt; Transport.tryPutIdleConn()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220620/a7f64d94-f05a-11ec-9d25-5626e1cdcfe1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了约束空闲连接的数量，连接池引入了几个变量:&lt;br/&gt;
&lt;code&gt;MaxIdleConns&lt;/code&gt; MaxIdleConns controls the maximum number of idle (keep-alive) connections across all hosts.&lt;br/&gt;
所有host总的最大空闲连接数量，默认值是100&lt;br/&gt;
&lt;code&gt;MaxIdleConnsPerHost&lt;/code&gt;if non-zero, controls the maximum idle&lt;br/&gt;
(keep-alive) connections to keep per-host。&lt;br/&gt;
针对每个Host能够保持的最大空闲连接数量。默认值是2&lt;br/&gt;
这个是一个比较有意思的变量，因为默认情况，所有的HTTP请求都使用同一个连接池，由于&lt;code&gt;MaxIdleConns&lt;/code&gt;存在，如果针对某个Host的 连接占用了大量空间，那么针对其它Host的连接可能就没有存储空间了。&lt;br/&gt;
&lt;code&gt;MaxConnsPerHost&lt;/code&gt; MaxConnsPerHost optionally limits the total number of connections per host, including connections in the dialing, active, and idle states.&lt;br/&gt;
默认值是0，表示不限制。&lt;/p&gt;
&lt;h3&gt;有意思的点&lt;/h3&gt;
&lt;p&gt;transport中的连接是按照key存储，key可以对应到下面的结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;type connectMethod struct {
    _            incomparable
    proxyURL     *url.URL // nil for no proxy, else full proxy URL
    targetScheme string   // &quot;http&quot; or &quot;https&quot;
    // If proxyURL specifies an http or https proxy, and targetScheme is http (not https),
    // then targetAddr is not included in the connect method key, because the socket can
    // be reused for different targetAddr values.
    targetAddr string
    onlyH1     bool // whether to disable HTTP/2 and force HTTP/1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;connectMethod.key().String()&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;|http|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|https|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|https,h1|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server w/o HTTP/2, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;http to proxy, then CONNECT to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http://proxy.com|http&lt;/td&gt;
&lt;td&gt;http to proxy, http to anywhere after that&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;socks5://proxy.com|http|foo.com&lt;/td&gt;
&lt;td&gt;socks5 to proxy, then http to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;socks5://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;socks5 to proxy, then https to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;https://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;https to proxy, then CONNECT to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;https://proxy.com|http&lt;/td&gt;
&lt;td&gt;https to proxy, http to anywhere after that&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 目标地址如果是同一个域名则算作同一个Host&lt;/p&gt;
&lt;h3&gt;Q2：把连接放回连接池的过程，必然需要将之前的某个空闲连接进行关闭，那么按照什么规则选择这个需要关闭的连接。&lt;/h3&gt;
&lt;h3&gt;A2：&lt;/h3&gt;
&lt;p&gt;如果连接池已经满了（MaxIdleConns），那么放回空闲连接的同时，还需要从连接池中选出一个旧连接进行关闭。这个选择的规则依据LRU进行筛选。net/http使用的双向链表。&lt;/p&gt;
&lt;h3&gt;Q3: 为了确保连接池中连接的有效性，是否需要引入定时的检查逻辑？&lt;/h3&gt;
&lt;h3&gt;A3:&lt;/h3&gt;
&lt;p&gt;net/http没有引入定期检查逻辑，但是额外的增加了一个变量&lt;br/&gt;
&lt;code&gt;IdleConnTimeout&lt;/code&gt;: IdleConnTimeout is the maximum amount of time an idle (keep-alive) connection will remain idle before closing itself.&lt;br/&gt;
超过&lt;code&gt;IdleConnTimeout&lt;/code&gt;的空闲连接将强制关闭。默认设置是90秒。&lt;/p&gt;
&lt;p&gt;这个逻辑可能是：”过长时间的空闲连接都是不可信赖的”&lt;/p&gt;
&lt;p&gt;一个从连接池中获得的连接只有在真正使用时，才能确定它是否有效。&lt;br/&gt;
如果连接在使用时报错，需要执行shouldRetryRequest()以确定是否需要获取新连接来执行失败的HTTP请求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool {
        ...
    if err == errServerClosedIdle {
        // The server replied with io.EOF while we were trying to
        // read the response. Probably an unfortunately keep-alive
        // timeout, just as the client was writing a request.
        return true
    }
    return false // conservatively
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如如果是&lt;code&gt;errServerClosedIdle&lt;/code&gt;，服务端关闭了空闲连接导致请求失败，那么显然应该重新获取一个新连接，再发起一次请求。&lt;/p&gt;
&lt;h2&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;看net/http的连接池，萌叔发现它与数据库的连接池、甚至与进程内的本地缓存在设计要点有很多相似之处。比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接池大小的限制  缓存大小的限制&lt;/li&gt;
&lt;li&gt;stale空闲连接的检查  过期key的清理&lt;/li&gt;
&lt;li&gt;达到空闲连接上限后，连接的换入换出  缓存满了之后，数据的换入换出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. 参考资料&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://blog.csdn.net/Com_ma/article/details/97134775&quot;&gt;grpc和thrift性能对比&lt;/a&gt;&lt;br/&gt;
2.&lt;a href=&quot;https://juejin.cn/post/6844903853872119822&quot;&gt;如何设计并实现一个db连接池？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;请我喝瓶饮料&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220421/e824ac06-c136-11ec-8e0e-5626e1cdcfe2.jpg&quot; alt=&quot;微信支付码&quot;/&gt;&lt;/p&gt;


            &lt;p class=&quot;clear&quot;/&gt;&amp;#13;
        &lt;/div&gt;&amp;#13;
        
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>352eb263dd2770c89f70f6ba4cb9c644</guid>
<title>字节跳动基于 Iceberg 的海量特征存储实践</title>
<link>https://toutiao.io/k/kekzyb3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;火山引擎开发者社区&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;VolcanoEngineToD&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;火山引擎开发者社区是火山引擎的 TOD 社区，致力于链接火山引擎和开发者，为大家提供前沿技术内容和丰富的技术活动，打造更好的开发者文化和氛围，共建开源生态。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d8ca21315f4d527e15cbca64f1554714</guid>
<title>后端思维篇:如何抽一个观察者模板</title>
<link>https://toutiao.io/k/bl9mj5i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;strong&gt;捡田螺的小男孩&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是&lt;strong&gt;后端思维专栏的第五篇&lt;/strong&gt;哈，我的整个后端思维专栏都是跟日常工作相关的哈。今天跟大家聊聊什么是观察者模式，如何应用到工作实践中，以及如何抽取一个观察者模板。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;观察者模式定义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观察者模式的应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何实现一个简单的观察者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工作中，如何使用观察者模式的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring观察者模式原理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于spring观察者模式，抽取一个通用模板&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唠叨几句，总结一下&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 观察者模式定义&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察者模式，也可以称之为&lt;strong&gt;发布订阅模式&lt;/strong&gt;，它在GoF 的《设计模式》中，是这么定义的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译过来就是：&lt;strong&gt;观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被完成业务的更新&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察者模式属于&lt;strong&gt;行为模式&lt;/strong&gt;，一个对象（&lt;strong&gt;被观察者&lt;/strong&gt;）的状态发生改变，所有的依赖对象（&lt;strong&gt;观察者对象&lt;/strong&gt;）都将得到通知，进行广播通知。它的主要成员就是&lt;strong&gt;观察者和被观察者&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;被观察者（Observerable）：目标对象，状态发生变化时，将通知所有的观察者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观察者（observer）：接受被观察者的状态变化通知，执行预先定义的业务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 观察者模式的应用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪些场景我们可以考虑使用观察者模式呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;我们日常生活中&lt;/strong&gt;，其实就有观察者模式类似的例子。比如，我们订阅了报社一年的报纸。每天报社印刷好报纸，就送到我们手中。我们就是观察者，报社就是被观察者。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而日常开发中，观察者模式的使用场景主要表现在：完成一件事情后，通知处理某个逻辑。如，&lt;strong&gt;登陆成功发个IM消息&lt;/strong&gt;，&lt;strong&gt;支付成功发个邮件消息或者发个抽奖消息&lt;/strong&gt;，&lt;strong&gt;用户评论成功给他发个积分&lt;/strong&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个详细点的例子吧，&lt;strong&gt;登陆注册&lt;/strong&gt;应该是最常见的业务场景了，我们就拿注册来说事，大家经常会遇到类似的场景，就是用户注册成功后，我们给用户发一条&lt;code&gt;IM&lt;/code&gt;消息，又或者发个邮件等等，因此经常有如下的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void register(User user){&lt;br/&gt;  insertRegisterUser（user）;&lt;br/&gt;  sendIMMessage();&lt;br/&gt;  sendEmail()；&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块代码会有什么问题呢？如果产品又加需求：现在注册成功的用户，再给用户发一条短信通知。于是你又得改&lt;code&gt;register&lt;/code&gt;方法的代码了。。。这是不是违反了&lt;strong&gt;开闭原则&lt;/strong&gt;啦。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void register(User user){&lt;br/&gt;  insertRegisterUser（user）;&lt;br/&gt;  sendIMMessage();&lt;br/&gt;  sendMobileMessage（）;&lt;br/&gt;  sendEmail()；&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，如果调发短信的接口失败了，是不是又影响到用户注册了？！这时候，是不是得加个&lt;strong&gt;异步方法&lt;/strong&gt;，异步发通知消息才好？？其实这种场景，我们可以使用&lt;strong&gt;异步非阻塞的观察者模式&lt;/strong&gt;优化的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 如何实现一个简单的观察者模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看下，简单的观察者模式如何实现。可以这么定义&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个主题接口&lt;code&gt;Subject&lt;/code&gt;（声明添加、删除、通知观察者方法）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个&lt;code&gt;Observer&lt;/code&gt;观察者接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个创建主题的类&lt;code&gt;ObserverableImpl&lt;/code&gt;（即被观察者），实现了&lt;code&gt;Subject&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;各个观察者的差异化实现&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了通俗易懂，可以这样理解观察者模式：就是被观察者（&lt;code&gt;ObserverableImpl&lt;/code&gt;）做了一件事情，或者说发布了一个主题（&lt;code&gt;Subject&lt;/code&gt;），然后这件事情通知到各个相关的不同的人（不同的观察者，&lt;code&gt;Observer&lt;/code&gt;的差异化实现者）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4513742071881607&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxDuptDKEdibIeWf74yhpHrUH3Ipnvp1jOXq2s8XcicqnArsm3hG7WCC8yskr6eaSFuLnDXnygEZmtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个主题接口&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface Subject {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 添加观察者&lt;br/&gt;     * @param observer&lt;br/&gt;     */&lt;br/&gt;    void addServer(Observer observer);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 移除观察者&lt;br/&gt;     * @param observer&lt;br/&gt;     */&lt;br/&gt;    void removeServer(Observer observer);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 通知观察者&lt;br/&gt;     * @param msg&lt;br/&gt;     */&lt;br/&gt;    void notifyAllObservers(String msg);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个&lt;code&gt;Observer&lt;/code&gt;接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 观察者&lt;br/&gt; *&lt;br/&gt; */&lt;br/&gt;public interface Observer {&lt;br/&gt;    /**&lt;br/&gt;     * 更新消息&lt;br/&gt;     * @param msg&lt;br/&gt;     */&lt;br/&gt;    void update(String msg);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个创建主题的类&lt;code&gt;ObserverableImpl&lt;/code&gt;（即被观察者），同时有观察者列表的属性（其实就是说观察者要事先注册到被观察者）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class ObserverableImpl implements Subject {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 存储被观察者&lt;br/&gt;     */&lt;br/&gt;    private List&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;Observer&amp;gt;();&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void addServer(Observer observer) {&lt;br/&gt;        observers.add(observer);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void removeServer(Observer observer) {&lt;br/&gt;        observers.remove(observer);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void notifyAllObservers(String msg) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Observer observer : observers) {&lt;br/&gt;            observer.update(msg);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;观察者的差异化&lt;/strong&gt;实现，以及使用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class ObserverOneImpl implements Observer {&lt;br/&gt;    @Override&lt;br/&gt;    public void update(String msg) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;ObserverOne is notified,&quot;&lt;/span&gt;+msg);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class ObserverTwoImpl implements Observer {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void update(String msg) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;ObserverTwo is notified,&quot;&lt;/span&gt;+msg);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class ObserverDemoTest {&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        Subject subject = new ObserverableImpl();&lt;br/&gt;        //添加观察者&lt;br/&gt;        subject.addObserver(new ObserverOneImpl());&lt;br/&gt;        subject.addObserver(new ObserverTwoImpl());&lt;br/&gt;        //通知&lt;br/&gt;        subject.notifyAllObservers(&lt;span&gt;&quot;关注公众号:捡田螺的小男孩&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;//输出&lt;br/&gt;ObserverOne is notified,关注公众号:捡田螺的小男孩&lt;br/&gt;ObserverTwo is notified,关注公众号:捡田螺的小男孩&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样，我们实现了观察者模式啦，是不是很简单？不过上面的代码，只能算是观察者模式的&lt;strong&gt;模板代码&lt;/strong&gt;，只能反映大体的设计思路。接下来，我们看下在工作中，是如何使用观察者模式的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 工作中，如何使用观察者模式的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察者模式的实现有两种方式，同步阻塞方式和异步非阻塞方式。第3小节就是一个&lt;strong&gt;同步阻塞方式&lt;/strong&gt;的观察者模式。我们来看下，日常工作的例子：&lt;strong&gt;用户注册成功发消息的例子，如何实现&lt;/strong&gt;。本小节分同步阻塞、异步阻塞、spring观察者模式三个方向探讨。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;同步阻塞方式的观察模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步非阻塞方式的观察者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spring观察者模式应用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 同步阻塞方式的观察模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以把&lt;strong&gt;用户注册&lt;/strong&gt;，当做&lt;strong&gt;被观察者&lt;/strong&gt;实现的逻辑，然后&lt;strong&gt;发消息&lt;/strong&gt;就是&lt;strong&gt;观察者的实现逻辑&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个观察者，分  别是发QQ消息和手机消息，于是有以下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface RegisterObserver {&lt;br/&gt;    void sendMsg(String msg);&lt;br/&gt;}&lt;br/&gt;@Service&lt;br/&gt;public class ObserverMobileImpl implements RegisterObserver {&lt;br/&gt;    @Override&lt;br/&gt;    public void sendMsg(String msg) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;发送手机短信消息&quot;&lt;/span&gt;+msg);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;@Service&lt;br/&gt;public class ObserverQQImpl implements RegisterObserver {&lt;br/&gt;    @Override&lt;br/&gt;    public void sendMsg(String msg) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;发送QQ消息&quot;&lt;/span&gt;+msg);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接可以通过&lt;code&gt;spring&lt;/code&gt;的&lt;code&gt;ApplicationContextAware&lt;/code&gt;，初始化观察者列表，然后用户注册成功，通知观察者即可。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RestController&lt;br/&gt;public class UserController implements ApplicationContextAware{&lt;br/&gt;&lt;br/&gt;     @Autowired&lt;br/&gt;     private UserService userService;&lt;br/&gt;&lt;br/&gt;     //观察者列表&lt;br/&gt;     private Collection&amp;lt;RegisterObserver&amp;gt; regObservers;&lt;br/&gt;&lt;br/&gt;     @RequestMapping(&lt;span&gt;&quot;register&quot;&lt;/span&gt;)&lt;br/&gt;     public String register(UserParam userParam) {&lt;br/&gt;          //注册成功过（类似于被观察者，做了某件事）&lt;br/&gt;          userService.addUser(userParam);&lt;br/&gt;          //然后就开始通知各个观察者。&lt;br/&gt;          &lt;span&gt;for&lt;/span&gt;(RegisterObserver temp:regObservers){&lt;br/&gt;               temp.sendMsg(&lt;span&gt;&quot;注冊成功&quot;&lt;/span&gt;);&lt;br/&gt;          }&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;;&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;     //利用spring的ApplicationContextAware，初始化所有观察者&lt;br/&gt;     @Override&lt;br/&gt;     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {&lt;br/&gt;          regObservers = new ArrayList&amp;lt;&amp;gt;(applicationContext.getBeansOfType(RegisterObserver.class).values());&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，观察者模式，就是将不同的行为代码解耦，也就是说&lt;strong&gt;将观察者和被观察者代码解耦&lt;/strong&gt;。但是这里大家会发现，这是&lt;strong&gt;同步阻塞式的观察者模式&lt;/strong&gt;，是有缺点的，比如发QQ消息异常，就会影响用户注册，或者发消息因为某些原因耗时，就影响了用户注册，所以可以考虑&lt;strong&gt;异步非阻塞&lt;/strong&gt;的观察者模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 异步非阻塞方式的观察者模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何实现异步非阻塞，最简单就是另开个线程嘛，即&lt;strong&gt;新开个线程或者线程池异步跑观察者通知&lt;/strong&gt;。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RestController&lt;br/&gt;public class UserController implements ApplicationContextAware{&lt;br/&gt;&lt;br/&gt;     @Autowired&lt;br/&gt;     private UserService userService;&lt;br/&gt;&lt;br/&gt;     private Collection&amp;lt;RegisterObserver&amp;gt; regObservers;&lt;br/&gt;&lt;br/&gt;     private Executor executor = Executors.newFixedThreadPool(10);&lt;br/&gt;&lt;br/&gt;     @RequestMapping(&lt;span&gt;&quot;register&quot;&lt;/span&gt;)&lt;br/&gt;     public String register(UserParam userParam) {&lt;br/&gt;          userService.addUser(userParam);&lt;br/&gt;          //异步通知每个观察者&lt;br/&gt;          &lt;span&gt;for&lt;/span&gt; (RegisterObserver temp : regObservers) {&lt;br/&gt;               executor.execute(() -&amp;gt; {&lt;br/&gt;                    temp.sendMsg(&lt;span&gt;&quot;注冊成功&quot;&lt;/span&gt;);&lt;br/&gt;               });&lt;br/&gt;          }&lt;br/&gt;&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;;&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;     @Override&lt;br/&gt;     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {&lt;br/&gt;          regObservers = new ArrayList&amp;lt;&amp;gt;(applicationContext.getBeansOfType(RegisterObserver.class).values());&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池实现的异步非阻塞方式，还是可以的，但是异步执行逻辑都耦合在了&lt;code&gt;register()函数&lt;/code&gt;中，不是很优雅，也增加了这部分业务代码的维护成本。一般日常工作中，我们会用&lt;code&gt;spring&lt;/code&gt;那一套观察者模式等&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 spring观察者模式应用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring的观察者模式使用也是比较简单的，就是先定义个事件，继承于&lt;code&gt;ApplicationEvent&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class MessageEvent extends ApplicationEvent {&lt;br/&gt;&lt;br/&gt;    public MessageEvent(Object &lt;span&gt;source&lt;/span&gt;) {&lt;br/&gt;        super(&lt;span&gt;source&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后定义一个事件监听器&lt;code&gt;MessageListener&lt;/code&gt;，类似于&lt;strong&gt;观察者&lt;/strong&gt;，它实现&lt;code&gt;ApplicationListener&lt;/code&gt;接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Component&lt;br/&gt;public class MessageListener implements ApplicationListener&amp;lt;MessageEvent&amp;gt; {&lt;br/&gt;    @Override&lt;br/&gt;    public void onApplicationEvent(MessageEvent messageEvent) {&lt;br/&gt;       System.out.println(&lt;span&gt;&quot;用户注册成功，执行监听事件&quot;&lt;/span&gt;+messageEvent.getSource());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户注册成功后，&lt;code&gt;applicationEventPublisher&lt;/code&gt;（&lt;strong&gt;类似于被观察者&lt;/strong&gt;）发布事件即可，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RestController&lt;br/&gt;public class UserController implements ApplicationContextAware{&lt;br/&gt;&lt;br/&gt;     @Autowired&lt;br/&gt;     private UserService userService;&lt;br/&gt;     &lt;br/&gt;     @Autowired&lt;br/&gt;     private ApplicationEventPublisher applicationEventPublisher;&lt;br/&gt;&lt;br/&gt;    @RequestMapping(&lt;span&gt;&quot;springListenRegister&quot;&lt;/span&gt;)&lt;br/&gt;    public String springListenRegister(UserParam userParam) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;开始注册&quot;&lt;/span&gt;);&lt;br/&gt;        userService.addUser(userParam);&lt;br/&gt;        //用户注册成功，发布事件&lt;br/&gt;        applicationEventPublisher.publishEvent(new MessageEvent(&lt;span&gt;&quot;666&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;开始注册&lt;br/&gt;用户注册成功，执行监听事件666&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也是&lt;strong&gt;同步阻塞&lt;/strong&gt;的方式实现的，等下下个小节先介绍完&lt;code&gt;spring&lt;/code&gt;观察者模式的原理，田螺哥再来教大家如何抽取一个通用的异步非阻塞观察者模式哈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. Spring观察者模式原理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 中实现的观察者模式包含三部分：分别是&lt;code&gt;Event&lt;/code&gt;事件（相当于消息）、&lt;code&gt;Listener&lt;/code&gt;监听者（相当于观察者）、&lt;code&gt;Publisher&lt;/code&gt;发送者（相当于被观察者）。用个图表示就是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30844793713163066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxDuptDKEdibIeWf74yhpHrU80nCraZrsSBVLysvJsEVNvroKURcFGSmjzcIYyPr0bpfyPDTKkDicNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1018&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个&lt;code&gt;ApplicationEvent&lt;/code&gt;是放到哪里的，监听者&lt;code&gt;AppliactionListener&lt;/code&gt;是如何监听到的。接下来，我们来看下spring框架的观察者原理是怎样哈~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看下&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;源代码（&lt;strong&gt;被观察者/发布者&lt;/strong&gt;）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@FunctionalInterface&lt;br/&gt;public interface ApplicationEventPublisher {&lt;br/&gt;&lt;br/&gt; default void publishEvent(ApplicationEvent event) {&lt;br/&gt;  publishEvent((Object) event);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; void publishEvent(Object event);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;它只是一个函数式接口，我们再看下它接口方法的实现。它的具体实现类是&lt;code&gt;AbstractApplicationContext&lt;/code&gt;，这个类代码有点多，我把关键部分代码贴出来了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;public abstract class AbstractApplicationContext extends ... {&lt;br/&gt;  //监听者（观察者列表）&lt;br/&gt;  private final Set&amp;lt;ApplicationListener&amp;lt;?&amp;gt;&amp;gt; applicationListeners;&lt;br/&gt;  &lt;br/&gt;  //构造器，初始化观察者列表&lt;br/&gt;  public &lt;span&gt;&lt;span&gt;AbstractApplicationContext&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    this.applicationListeners = new LinkedHashSet();&lt;br/&gt;    //...&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  //发布事件&lt;br/&gt;  public void publishEvent(ApplicationEvent event) {&lt;br/&gt;    this.publishEvent(event, (ResolvableType)null);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  public void publishEvent(Object event) {&lt;br/&gt;    this.publishEvent(event, (ResolvableType)null);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  //发布事件接口实现&lt;br/&gt;  protected void publishEvent(Object event, ResolvableType eventType) {&lt;br/&gt;    //...&lt;br/&gt;    Object applicationEvent;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (event instanceof ApplicationEvent) {&lt;br/&gt;      //如果event是ApplicationEvent对象,或者是它的子类&lt;br/&gt;      applicationEvent = (ApplicationEvent)event;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      // 如果不是ApplicationEvent对象或者它的子类，则将其包装成PayloadApplicationEvent事件，并获取对应的事件类型&lt;br/&gt;      applicationEvent = new PayloadApplicationEvent(this, event);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (eventType == null) {&lt;br/&gt;        eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (this.earlyApplicationEvents != null) {&lt;br/&gt;      this.earlyApplicationEvents.add(applicationEvent);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      //真正的消息发送，是通过它。获取ApplicationEventMulticaster，调用multicastEvent方法广播事件&lt;br/&gt;      this.getApplicationEventMulticaster().multicastEvent(&lt;br/&gt;            (ApplicationEvent)applicationEvent, eventType);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    //如果当前命名空间还有父亲节点，也需要给父亲推送该消息&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (this.parent != null) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (this.parent instanceof AbstractApplicationContext) {&lt;br/&gt;        ((AbstractApplicationContext)this.parent).publishEvent(event, eventType);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        this.parent.publishEvent(event);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  //添加观察者（监听者）&lt;br/&gt;  public void addApplicationListener(ApplicationListener&amp;lt;?&amp;gt; listener) {&lt;br/&gt;    Assert.notNull(listener, &lt;span&gt;&quot;ApplicationListener must not be null&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (this.applicationEventMulticaster != null) {&lt;br/&gt;    this.applicationEventMulticaster.addApplicationListener(listener);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      this.applicationListeners.add(listener);&lt;br/&gt;    }  &lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  //观察者列表&lt;br/&gt;  public Collection&amp;lt;ApplicationListener&amp;lt;?&amp;gt;&amp;gt; &lt;span&gt;&lt;span&gt;getApplicationListeners&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; this.applicationListeners;&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  // 注册监听器&lt;br/&gt;  protected void &lt;span&gt;&lt;span&gt;registerListeners&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  //把提前存储好的监听器添加到监听器容器中到ApplicationEventMulticaster&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (ApplicationListener&amp;lt;?&amp;gt; listener : getApplicationListeners()) {&lt;br/&gt;   getApplicationEventMulticaster().addApplicationListener(listener);&lt;br/&gt;  }&lt;br/&gt;     //获取类型是ApplicationListener的beanName集合，此处不会去实例化bean&lt;br/&gt;  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (String listenerBeanName : listenerBeanNames) {&lt;br/&gt;   getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  Set&amp;lt;ApplicationEvent&amp;gt; earlyEventsToProcess = this.earlyApplicationEvents;&lt;br/&gt;  this.earlyApplicationEvents = null;&lt;br/&gt;    //如果存在earlyEventsToProcess，提前处理这些事件&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!CollectionUtils.isEmpty(earlyEventsToProcess)) {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (ApplicationEvent earlyEvent : earlyEventsToProcess) {&lt;br/&gt;    getApplicationEventMulticaster().multicastEvent(earlyEvent);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上代码，我们可以发现，真正的消息发送，实际上是通过事件广播器&lt;code&gt;ApplicationEventMulticaster &lt;/code&gt;这个接口来完成的。&lt;code&gt;multicastEvent&lt;/code&gt;是主要方法，这个方法的实现在类&lt;code&gt;SimpleApplicationEventMulticaster&lt;/code&gt;中，我们一起来看下源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {&lt;br/&gt;  ...&lt;br/&gt;  &lt;br/&gt;  //线程池&lt;br/&gt;  @Nullable&lt;br/&gt; protected Executor &lt;span&gt;&lt;span&gt;getTaskExecutor&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; this.taskExecutor;&lt;br/&gt; }&lt;br/&gt;  &lt;br/&gt;  public void setTaskExecutor(@Nullable Executor taskExecutor) {&lt;br/&gt;  this.taskExecutor = taskExecutor;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;  &lt;br/&gt; @Override&lt;br/&gt; public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {&lt;br/&gt;  ResolvableType &lt;span&gt;type&lt;/span&gt; = (eventType != null ? eventType : resolveDefaultEventType(event));&lt;br/&gt;    // 根据event类型获取适合的监听器&lt;br/&gt;  Executor executor = getTaskExecutor();&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (ApplicationListener&amp;lt;?&amp;gt; listener : getApplicationListeners(event, &lt;span&gt;type&lt;/span&gt;)) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (executor != null) {&lt;br/&gt;        //如果executor不为空，异步调用执行监听器中的方法&lt;br/&gt;    executor.execute(() -&amp;gt; invokeListener(listener, event));&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        //调用监听器的方法&lt;br/&gt;    invokeListener(listener, event);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;  &lt;br/&gt; protected void invokeListener(ApplicationListener&amp;lt;?&amp;gt; listener, ApplicationEvent event) {&lt;br/&gt;  ErrorHandler errorHandler = getErrorHandler();&lt;br/&gt;    //如果存在ErrorHandler，调用监听器方法(会用try...catch包一下)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (errorHandler != null) {&lt;br/&gt;   try {&lt;br/&gt;    doInvokeListener(listener, event);&lt;br/&gt;   }&lt;br/&gt;   catch (Throwable err) {&lt;br/&gt;        //如果抛出异常则调用ErrorHandler来处理异常。&lt;br/&gt;    errorHandler.handleError(err);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      否则直接调用监听器方法&lt;br/&gt;   doInvokeListener(listener, event);&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;  ...&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，&lt;strong&gt;默认情况下，spring实现的观察者模式，同步阻塞的&lt;/strong&gt;。如果想异步执行事件，可以自定义&lt;code&gt;SimpleApplicationEventMulticaster&lt;/code&gt;，然后构造一下&lt;code&gt;executor&lt;/code&gt;线程池就好啦。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 公众号：捡田螺的小男孩&lt;br/&gt; */&lt;br/&gt;@Component&lt;br/&gt;public class ListenerConfig {&lt;br/&gt;&lt;br/&gt;    //把线程池赋值进去&lt;br/&gt;    @Bean&lt;br/&gt;    public SimpleApplicationEventMulticaster &lt;span&gt;&lt;span&gt;applicationEventMulticaster&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = new SimpleApplicationEventMulticaster();&lt;br/&gt;        simpleApplicationEventMulticaster.setTaskExecutor(simpleAsyncTaskExecutor());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; simpleApplicationEventMulticaster;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    public SimpleAsyncTaskExecutor &lt;span&gt;&lt;span&gt;simpleAsyncTaskExecutor&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; new SimpleAsyncTaskExecutor();&lt;br/&gt;    } &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;demo跑一下，运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;注册开始&lt;br/&gt;当前线程名称http-nio-8080-exec-1&lt;br/&gt;注册结束&lt;br/&gt;用户注册成功2，执行监听事件666Sat Jun 18 11:44:07 GMT+08:00 2022&lt;br/&gt;当前线程名称:SimpleAsyncTaskExecutor-20&lt;br/&gt;当前线程名称:SimpleAsyncTaskExecutor-19&lt;br/&gt;用户注册成功，执行监听事件666Sat Jun 18 11:44:12 GMT+08:00 2022&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果手动新建&lt;code&gt;SimpleApplicationEventMulticaster&lt;/code&gt;，并设置&lt;code&gt;taskExecutor&lt;/code&gt;的话，所有的监听响应事件，都是&lt;strong&gt;异步执行&lt;/strong&gt;的哦。而有些有些场景我们希望同步执行的，这时候这种实现方式就不好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;spring&lt;/code&gt;提供了&lt;code&gt;@Async&lt;/code&gt;注解，可以用来实现&lt;strong&gt;异步&lt;/strong&gt;。具体怎么实现呢？其实很简单，只需要在&lt;strong&gt;配置类&lt;/strong&gt;加上&lt;code&gt;@EnableAsync&lt;/code&gt;，接着在需要异步执行的监听实现方法。加上&lt;code&gt;@Async&lt;/code&gt;即可。代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：捡田螺的小男孩&lt;br/&gt; * 更多实战干货&lt;br/&gt; */&lt;br/&gt;@Component&lt;br/&gt;@EnableAsync //配置类加上```@EnableAsync```&lt;br/&gt;public class ListenerConfig2 {&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    public SimpleApplicationEventMulticaster &lt;span&gt;&lt;span&gt;applicationEventMulticaster&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = new SimpleApplicationEventMulticaster();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; simpleApplicationEventMulticaster;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@Component&lt;br/&gt;public class MessageAsyncListener3 implements ApplicationListener&amp;lt;MessageEvent&amp;gt; {&lt;br/&gt;&lt;br/&gt;    @Async //方法异步注解&lt;br/&gt;    @Override&lt;br/&gt;    public void onApplicationEvent(MessageEvent messageEvent) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;用户注册成功3，执行监听事件&quot;&lt;/span&gt; + messageEvent.getSource() + new Date());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;当前线程名称:&quot;&lt;/span&gt;+Thread.currentThread().getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，异步执行也可以自己手动通过线程池来开启啦。回到我们本文的&lt;strong&gt;后端思维&lt;/strong&gt;主题，如果每个开发，都自己定义观察者模式的实现，这种代码会很混乱，&lt;strong&gt;所以最好是实现一个可扩展，通用的观察者模板&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 基于spring观察者模式，抽取一个模板&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的最后小节，跟大家一起基于spring的观察者模式，一步一步实现并抽取个模板哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要基于spring实现观察者模式的话，就包括这三步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义&lt;code&gt;Event&lt;/code&gt;事件（相当于消息），一般定义一个&lt;code&gt;Event&lt;/code&gt;对象，继承&lt;code&gt;ApplicationEvent&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定义&lt;code&gt;Listener&lt;/code&gt;监听者（相当于观察者），实现接口&lt;code&gt;ApplicationListener&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Publisher&lt;/code&gt;发送者（相当于被观察者），通过&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;发布。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 定义&lt;code&gt;Event&lt;/code&gt;事件对象&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们要抽取观察者模板，那肯定不是每个人自己写自己的&lt;code&gt;Event&lt;/code&gt;，然后都去继承&lt;code&gt;ApplicationEvent&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以自己定义一个&lt;strong&gt;项目相关的，通用&lt;/strong&gt;的&lt;code&gt;BaseEvent&lt;/code&gt;类，然后一些相关通用的信息属性可以放进去，比如&lt;code&gt;eventId&lt;/code&gt;或者流水号&lt;code&gt;bizSeq&lt;/code&gt;什么的，都可以，看你们项目需要哈。以下代码，我定义一个空空如也的&lt;code&gt;BaseEvent&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：捡田螺的小男孩&lt;br/&gt; * 更多实战干货&lt;br/&gt; * @desc : 事件基础对象&lt;br/&gt; */&lt;br/&gt;public class BaseEvent extends ApplicationEvent {&lt;br/&gt;&lt;br/&gt;    public BaseEvent(Object &lt;span&gt;source&lt;/span&gt;) {&lt;br/&gt;        super(&lt;span&gt;source&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public &lt;span&gt;&lt;span&gt;BaseEvent&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        this(&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的观察者模式，是注册成功之后，发个消息的，你就可以声明一个消息类事件对象&lt;code&gt;RegisterMessageEvent&lt;/code&gt;，继承通用的&lt;code&gt;BaseEvent&lt;/code&gt;即可。然后属性可以自定义就好，比如&lt;code&gt;messageId&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class RegisterMessageEvent  extends BaseEvent{&lt;br/&gt;&lt;br/&gt;    private String msgId;&lt;br/&gt;&lt;br/&gt;    public RegisterMessageEvent(String msgId) {&lt;br/&gt;        super();&lt;br/&gt;        this.msgId = msgId;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getMsgId&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; msgId;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setMsgId(String msgId) {&lt;br/&gt;        this.msgId = msgId;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，如果你想定义一个用户送礼物成功，然后发个广播，可以定义一个&lt;code&gt;GiftSendEvent&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class GiftSendEvent extends BaseEvent {&lt;br/&gt;&lt;br/&gt;    private String giftId;&lt;br/&gt;&lt;br/&gt;    public GiftSendEvent(String giftId) {&lt;br/&gt;        this.giftId = giftId;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getGiftId&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; giftId;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setGiftId(String giftId) {&lt;br/&gt;        this.giftId = giftId;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他业务场景类似，只要想接入你的观察者模板，只需要自己定义事件对象，继承于你的&lt;code&gt;BaseEvent&lt;/code&gt;即可，是不是&lt;strong&gt;成就感满满&lt;/strong&gt;啦。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2  定义&lt;code&gt;Listener&lt;/code&gt;监听者（观察者啦）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义完&lt;code&gt;Event&lt;/code&gt;事件，我们就可以开始定义监听者了。我们定义的监听者，只需要实现接口&lt;code&gt;ApplicationListener&lt;/code&gt;接口即可。如果每个人也是各写各的，这些就很乱，毫无&lt;strong&gt;模板规范&lt;/strong&gt;可言了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以封装一下嘛，如何封装呢？很简单，可以先声明一个&lt;code&gt;IEventListener&lt;/code&gt;，让它继承&lt;code&gt;ApplicationListener&lt;/code&gt;接口，我们都知道，接口也是可以继承的哈。如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface IEventListener extends ApplicationListener {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监听者的实现，关键在于实现&lt;code&gt;ApplicationListener&lt;/code&gt;的&lt;code&gt;onApplicationEvent&lt;/code&gt;的接口方法即可。又因为未来别的业务场景接入观察者模式，都是按你的模板来，所以各个&lt;code&gt;Event&lt;/code&gt;事件对象，都是继承于你的&lt;code&gt;BaseEvent&lt;/code&gt;的，所以我们可以把&lt;code&gt;&amp;lt;T extends BaseEvent&amp;gt;&lt;/code&gt;的泛型加进去，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：捡田螺的小男孩&lt;br/&gt; * @desc : 更多干货&lt;br/&gt; */&lt;br/&gt;public interface IEventListener&amp;lt;T extends BaseEvent&amp;gt; extends ApplicationListener &amp;lt;T&amp;gt;{&lt;br/&gt;    void onApplicationEvent(T event);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些时候，可能会有这种场景，就是执行&lt;strong&gt;监听逻辑&lt;/strong&gt;，&lt;strong&gt;只对部分数据（或者说部分特殊用户才执行）&lt;/strong&gt;。既然我们是抽取监听模板，考虑到可扩展性，我们可以优化下&lt;code&gt;IEventListener&lt;/code&gt;的代码。我们可以声明一个support的方法，默认是执行的,子类可以覆盖重写（让子类去控制是否执行这个监听逻辑），如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface IEventListener&amp;lt;T extends BaseEvent&amp;gt; extends ApplicationListener &amp;lt;T&amp;gt; {&lt;br/&gt;&lt;br/&gt;    void onApplicationEvent(T event);&lt;br/&gt;&lt;br/&gt;    //接口里面，加了default，就可以写方法实现&lt;br/&gt;    default boolean support(T event) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后呢，只有&lt;code&gt;support&lt;/code&gt;方法返回&lt;code&gt;true&lt;/code&gt;，才执行&lt;strong&gt;监听的逻辑&lt;/strong&gt;，我们还可以定义一个&lt;code&gt;handler&lt;/code&gt;方法，给子类去实现自己的业务逻辑，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：捡田螺的小男孩&lt;br/&gt; * @desc : 更多干货&lt;br/&gt; */&lt;br/&gt;public interface IEventListener&amp;lt;T extends BaseEvent&amp;gt; extends ApplicationListener &amp;lt;T&amp;gt; {&lt;br/&gt;&lt;br/&gt;    default void onApplicationEvent(T event){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (support(event)) {&lt;br/&gt;            handler(event);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    default boolean support(T event) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    //真正实现业务逻辑的接口，给子类去实现。&lt;br/&gt;    void handler(T event);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对着以上的代码模板，小伙伴们是否还有一些优化的想法呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果方法产生了异常，我们是不是可以注意一下异常处理呢？以上小节，SimpleApplicationEventMulticaster源码分析的时候，不知道大家有没有细看，其实它就用了一个很巧妙的异常处理，我们可以借鉴一下，哈哈哈，这就是看源码的一个小小的好处了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以给&lt;code&gt;onApplicationEvent&lt;/code&gt;的实现&lt;code&gt;try...catch...&lt;/code&gt;一下，如果&lt;code&gt;catch&lt;/code&gt;住异常的话，可以定义一个&lt;code&gt;handlerException&lt;/code&gt;异常处理方法，给子类自定义去实现，当然，异常可以默认不处理嘛，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：捡田螺的小男孩&lt;br/&gt; * @desc : 更多干货&lt;br/&gt; */&lt;br/&gt;public interface IEventListener&amp;lt;T extends BaseEvent&amp;gt; extends ApplicationListener &amp;lt;T&amp;gt; {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 观察者的业务逻辑处理&lt;br/&gt;     * @param event&lt;br/&gt;     */&lt;br/&gt;    default void onApplicationEvent(T event){&lt;br/&gt;        try {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (support(event)) {&lt;br/&gt;                handler(event);&lt;br/&gt;            }&lt;br/&gt;        } catch (Throwable e) {&lt;br/&gt;            /**&lt;br/&gt;             * &lt;br/&gt;             */&lt;br/&gt;            handleException(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 默认执行观察者的逻辑的&lt;br/&gt;     * @param event&lt;br/&gt;     * @&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    default boolean support(T event) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     *  观察者的逻辑，交给不同子类自定义实现&lt;br/&gt;     * @param event&lt;br/&gt;     */&lt;br/&gt;    void handler(T event);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 异常默认不处理&lt;br/&gt;     * @param exception&lt;br/&gt;     */&lt;br/&gt;    default void handleException(Throwable exception) {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后呢，不同业务不同的监听者（观察者），直接实现你的&lt;code&gt;IEventListener&lt;/code&gt;就好啦，比如注册成功那个，我们声明一个&lt;code&gt;RegisterMessageListenerImpl&lt;/code&gt;类，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Service&lt;br/&gt;public class RegisterMessageListenerImpl implements IEventListener&amp;lt;RegisterMessageEvent&amp;gt; {&lt;br/&gt;    &lt;br/&gt;    @Override&lt;br/&gt;    public void handler(RegisterMessageEvent event) {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;用户注册成功register，执行监听事件&quot;&lt;/span&gt; + event.getSource() + new Date());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 定义&lt;code&gt;Publisher&lt;/code&gt;发送者模板&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的观察者模板，最后一步就是&lt;strong&gt;定义发送者模板&lt;/strong&gt;。最简单的发送，就是利用&lt;code&gt;ApplicationContext&lt;/code&gt;直接发送就好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Component&lt;br/&gt;public class EventPublish {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private ApplicationContext applicationContext;&lt;br/&gt;&lt;br/&gt;    void publish(BaseEvent event) {&lt;br/&gt;        applicationContext.publishEvent(event);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为什么可以直接使用applicationContext来发送，文章开始介绍，我们不是用ApplicationEventPublisher来发送嘛？其实是因为applicationContext继承了ApplicationEventPublisher接口&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个只是同步阻塞方式的观察者模式，一般来说，一个&lt;strong&gt;通用的观察者模板&lt;/strong&gt;。也需要提供异步非阻塞方式的观察者模板。本文第5小节，我们知道了，在配置类加上&lt;code&gt;@EnableAsync&lt;/code&gt;，在需要异步执行的监听加上&lt;code&gt;@Async&lt;/code&gt;，即可实现异步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便管理，和API语义更明确，我们可以手动设置线程池，给我们的模板发布类，提供异步发送的接口。我们先自定义一个线程池，一般&lt;strong&gt;不建议&lt;/strong&gt;直接使用JDK的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何自定义线程池呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在&lt;code&gt;application.properties&lt;/code&gt;配置文件，定义线程池一些属性（核心线程数、最大线程数等等）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;executor.corePoolSize=50&lt;br/&gt;executor.maxPoolSize=100&lt;br/&gt;executor.queueCapacity=200&lt;br/&gt;executor.keepAliveSeconds=120&lt;br/&gt;executor.threadNamePrefix=threadPoolExecutor&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后声明一个线程配置类&lt;code&gt;TianLuoExecutorsConfig&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：捡田螺的小男孩&lt;br/&gt; * 更多实战干货&lt;br/&gt; */&lt;br/&gt;&lt;br/&gt;@Configuration&lt;br/&gt;@ConfigurationProperties(&lt;span&gt;&quot;executor&quot;&lt;/span&gt;)//读取配置文件的线程池属性&lt;br/&gt;public class TianLuoExecutorsConfig {&lt;br/&gt;&lt;br/&gt;    private int corePoolSize;&lt;br/&gt;&lt;br/&gt;    private int maxPoolSize;&lt;br/&gt;&lt;br/&gt;    private int queueCapacity;&lt;br/&gt;&lt;br/&gt;    private int keepAliveSeconds;&lt;br/&gt;&lt;br/&gt;    private String threadNamePrefix;&lt;br/&gt;    &lt;br/&gt;    //省略get和&lt;span&gt;set&lt;/span&gt;的方法&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过线程配置类&lt;code&gt;TianLuoExecutorsConfig&lt;/code&gt;，初始化线程池&lt;code&gt;TianLuoExecutorPool&lt;/code&gt;，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：捡田螺的小男孩&lt;br/&gt; * 更多实战干货&lt;br/&gt; */&lt;br/&gt;@Configuration&lt;br/&gt;public class TianLuoExecutorPool {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private TianLuoExecutorsConfig tianLuoExecutorsConfig;&lt;br/&gt;&lt;br/&gt;    @Bean&lt;br/&gt;    public ThreadPoolTaskExecutor &lt;span&gt;&lt;span&gt;eventExecutor&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();&lt;br/&gt;        executor.setCorePoolSize(tianLuoExecutorsConfig.getCorePoolSize());&lt;br/&gt;        executor.setMaxPoolSize(tianLuoExecutorsConfig.getMaxPoolSize());&lt;br/&gt;        executor.setKeepAliveSeconds(tianLuoExecutorsConfig.getKeepAliveSeconds());&lt;br/&gt;        executor.setQueueCapacity(tianLuoExecutorsConfig.getQueueCapacity());&lt;br/&gt;        executor.setThreadNamePrefix(tianLuoExecutorsConfig.getThreadNamePrefix());&lt;br/&gt;        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;        executor.initialize();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; executor;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后回到&lt;code&gt;EventPublish&lt;/code&gt;，把异步发布的接口加上，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 观察者模式，事件发布通用接口&lt;br/&gt; **/&lt;br/&gt;@Component&lt;br/&gt;public class EventPublish {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private ApplicationContext applicationContext;&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private TianLuoExecutorPool tianLuoExecutorPool;&lt;br/&gt; &lt;br/&gt;    //同步阻塞&lt;br/&gt;    public void publish(BaseEvent event) {&lt;br/&gt;        applicationContext.publishEvent(event);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    //异步发布（异步非阻塞）&lt;br/&gt;    public void asyncPublish(BaseEvent event) {&lt;br/&gt;        tianLuoExecutorPool.eventExecutor().execute(()-&amp;gt;{&lt;br/&gt;            publish(event);&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 唠叨几句&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文大家学到了哪些知识呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;观察者模式定义，观察者模式的使用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何实现一个简单的观察者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring观察者模式的原理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同步阻塞、异步非阻塞、spring观察者模式的实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端思维：如何抽取一个观察者模板`&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进阶篇？有些小伙伴说，实现观察者模式，可以使用guava的&lt;code&gt;eventBus&lt;/code&gt;，大家可以去看看哈，其实原理类似的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后的话，本文的源代码，如果小伙伴需要的话，可以关注公众号：程序员田螺，回复：&lt;strong&gt;观察者模式&lt;/strong&gt;。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>