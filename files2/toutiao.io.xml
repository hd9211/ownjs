<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>72806cfa33253887239c761c7d38f57d</guid>
<title>这几款 JVM 故障诊断处理工具你还不会？</title>
<link>https://toutiao.io/k/dux0ogl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天中午正在和同事最近聊股市较好，这几天每天都可以喝点肉汤，心里还是挺高兴的；正在这个时候收到了线上告警邮件和运维同学的消息，“你们有服务挂了！”，心里一紧，立马打开电脑看来下线上cat监控大盘，发现很多服务都在报错，根据cat上的监控日志很快发现了其中一个服务内存溢出导致其他调用服务也有问题，竟然已经定位到了出问题的服务，那就简单了，没有是重启解决不了的问题，重启之后很快服务都恢复正常了。几分钟之后又报错了，同样也是这个服务内存溢出，经过排查后发现该服务的堆内存被改小了，好家伙，运维同学不讲武德，搞偷袭，趁我没反应过来调了内存，内存调整回去之后服务就恢复了正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后把线上的快照文件拖了下来分析，发现本身这个项目的代码也有些问题，本文就整理了一下JVM常用的分析工具。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命令行工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在安装完JDK之后在JAVA_HOME/bin目录下JDK已经提供了很多命令行的工具&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.06375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3L6TRz9Y0UdvzxE2DGJosqxbc4qu9pJCWZejq6WtqCssK83AEK3UMrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能我们最常用的就是&lt;code&gt;java&lt;/code&gt;、&lt;code&gt;javac&lt;/code&gt;这两个命令，除了这两个命令之外还有提供很多其他的实用工具，本文主要来一起学习对JVM监控诊断工具&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机进程状况工具（jps）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该工具的功能比较单一，与linux中的ps功能类似，用来列出正在运行的虚拟机进程，并显示出运行的主类和进程号&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jps [option] [hostid]&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果需要查看远程机器的jvm进程需要填写&lt;code&gt;hostid&lt;/code&gt;，并且需要使用RMI，比如：&lt;code&gt;rmi://192.168.2.128:12345&lt;/code&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-q&lt;/code&gt; : 只显示出虚拟机的进程id（lvmid），省略主类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt; : 输出启动时传递给主类的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt; : 显示出主类的全名，包括jar包路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-v&lt;/code&gt; : 输出虚拟机进程启动时的JVM参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23290203327171904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3zIQRpQAtZibR8uPLX3MU1OoibCvIQQZLFLia31ermSkeW8icYvYdPLLPnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机统计信息监控工具（jstat）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于监控虚拟机运行状态信息的命令行工具，可以提供内存，垃圾收集等运行时的数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstat [option vmid] [interval [s|ms] [count]]&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;interval表示间隔多久时间查询一次，count表示查询多少次，比如：每个两秒查询一次进程52412的垃圾收集情况，共查询5次&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstat -gc 52412 2s 5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3OObJnsw4ho5Gam75mB4vIA1kMeuFBLmdoHYajmf15ibYh1iaPz1GkZxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-class&lt;/code&gt;: 监控类装载，卸载次数和总空间以及加载类的耗时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gc&lt;/code&gt;: 监控java堆的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcutil&lt;/code&gt;: 主要输出各个空间使用的百分比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcnew&lt;/code&gt;: 主要是监控新生代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcold&lt;/code&gt;: 监控老年代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-compiler&lt;/code&gt;: 输出JIT编译器编译过的方法和耗时信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看堆空间的使用百分比: &lt;code&gt;jstat -gcutil 52412 2s 5&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16973684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN39ticu2fcOAGShUKaqFQzmIfZtLAgGceHoruTjg6AOZibahyoIT9bwPJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;java配置信息工具（jinfo）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;jinfo&lt;/code&gt;实时的查看和调整虚拟机的各项参数；可以通过&lt;code&gt;jps -v&lt;/code&gt;查看虚拟机启动时候指定的参数信息，如果需要查看未显示指定的参数默认值也可以通过&lt;code&gt;jinfo -flag&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flag CMSInitiatingOccupancyFraction 52412&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3HcQOFibOt6HbrdaIeRvEVMhicicPAfgichnqbgRCQSAjQes4J6ZtURl3Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jinfo除了可以查看参数以外，还可以在运行时修改一些允许被修改的参数&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Java内存映像工具（jmap）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap用于生成JVM堆的快照文件，除了使用jmap工具，我们通常也会在配置JVM的启动参数 &lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt; 让JVM在发送内存溢出之后自动生成dump文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jmap [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如生成java堆的快照文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jmap -dump:live,format=b,file=/Users/huaan9527/Desktop/heap.hprof 59950&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当虚拟机对-dump选项没有响应时可用选择使用这个参数强制生成快照&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-histo&lt;/code&gt;: 显示出堆中对象统计信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;堆栈跟踪工具（jstack）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于生成JVM当前线程的快照信息。通常用于查询什么原因导致线程长时间的停顿，比如：线程死循环，死锁，等待网络/IO&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstack [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当请求不被响应时强制输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt;: 除了显示堆栈外，还需要显示锁的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt;: 如果调用到本地方法，显示出C/C++的堆栈&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VisualVM 可视化工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM是目前JDK自带的功能最强的运行监视和故障处理程序，在VisualVM之前，JDK也提供了一款可视化工具JConsole，由于JConsole的所有功能在VisualVM都有，所以可视化工具大家几乎都选择使用VisualVM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM本身是基于Netbean开发的，所以具备了插件扩展功能，安装插件之后上面介绍的所有命令行的工具的功能都可以在VisualVM中使用。可以在在JAVA_HOME/bin目录下执行&lt;code&gt;jvisualvm&lt;/code&gt;启动。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;插件安装
默认情况VisualVM提供的功能很少，需要我们在菜单栏-&amp;gt;工具-&amp;gt;插件里面安装插件，我这是全部插件都安装了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.59875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3QGVcxoRL0D1EaoyiaI5tEqpBEGL0yXhmHe2NfcKJtyvic20C2RRhJP1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;功能演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46981627296587924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3UEXOHP6iauXffDAODBG85QP4PqKosiajOGz9GVXUib8x6c9HDJed2DxVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显示出当前本机所有的JVM进程，这里显示的内容和前面说的命令行&lt;code&gt;jps&lt;/code&gt;显示的内容一样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3ZZs5Y4qialznXKtKIj1MibSTrqWycDS8UYoiaadvzqXOn2IR9DOiaWc0Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前虚拟机启动信息的展示，比如：JVM启动参数、系统参数&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.66&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3IuCCtJENo62LdUe0eVNAlVESYFVCQGKQjJib0TPxwcpWVLIuuCj6ia8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个页面相当于命令jstat的功能，显示出了CPU, 内存，线程，类装载当前处于什么情况&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成dump文件可以在应用程序窗口右键菜单中选择，也可以在这个页面点击右上角的&lt;code&gt;堆dump&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Visual GC
此页主要展示了GC相关的信息，这是在性能调优时常用的页面之一&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3uMn8Ciaga5rTDzRsjfjMa36O6GGgez4Cuj1EozA2VjwHnEiczK8EfxjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以写个程序来观看下这个截图各个内存区域的变化情况，为了让图的效果明显需要修改JVM的启动参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xmx100m -Xms100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/huaan9527/Desktop&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) {&lt;br/&gt;    List&amp;lt;DataTest&amp;gt; datas = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    IntStream.range(0, 10000).forEach(index -&amp;gt; {&lt;br/&gt;        datas.add(new DataTest());&lt;br/&gt;&lt;br/&gt;        try {&lt;br/&gt;            Thread.sleep(50);&lt;br/&gt;        } catch (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    System.gc();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;static class DataTest {&lt;br/&gt;    byte[] bytes = new byte[1024];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TJRzV0hnQgqJyXvS7icdAw8Rdh0wDAeaY3evvibsq9kEloJF3VNYLxOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程
本页的功能相当于命令行工具&lt;code&gt;jstack&lt;/code&gt;，主要是用于检查什么原因导致线程长时间等待，我们写程序来演示下等待外部资源、锁等待、死循环这几种请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「等待外部资源」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException {&lt;br/&gt;    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));&lt;br/&gt;    System.out.println(reader.readLine());&lt;br/&gt;    try {&lt;br/&gt;        Thread.sleep(1000000);&lt;br/&gt;    } catch (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选中main线程，右侧会看到当前线程运行到了readBytes，等待键盘输入&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN30YP4cEJicbw4ibpa7HpHV68d8qiaExhstP9l0eMdQmrltjZJrwS7Is9JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在控制台输入之后再次查看main线程的状态，此时进入了TIME_WAIT状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3vF9IMG5fFrYAq5GkB0ta3yLZlHrm7ccRfCqU7VDHEz9hRVQJLsZKMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁等待」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    Thread thread = createLockThread(new Object());&lt;br/&gt;    thread.join();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public static Thread createLockThread(final Object lock) {&lt;br/&gt;    Thread lockThread = new Thread(() -&amp;gt; {&lt;br/&gt;        synchronized (lock) {&lt;br/&gt;            try {&lt;br/&gt;                lock.wait();&lt;br/&gt;            } catch (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }, &lt;span&gt;&quot;lockThread&quot;&lt;/span&gt;);&lt;br/&gt;    lockThread.start();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; lockThread;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TktpB0w3QcrBiadrLic8Jz2wErvo24dZRtXCCNc9os2CQJJrESuofvfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lockThread线程在等待lock对象的notify方法被调用，此时处于WAITING状态，在被唤醒之前是不会再分配执行时间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「死循环」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3LDibRDrJ6XM9pYXlHdpupiauyXORbYfdsDOsDzuACnEia4uURESibn4aWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程一直处于运行状态，从堆栈追踪里可以看出代码一直停留在了191行，在空循环上用尽分配的执行时间&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇介绍了命令行工具和可视化工具，下篇实战演示下如何通过这些工具对&lt;strong&gt;「Idea运行速度调优」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写到最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家给我留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;strong&gt;「白嫖不好，创作不易」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20ee1157d866bed603d03131c7cca4e6</guid>
<title>面试官问：“在项目中用过多线程吗？” 你就把这个案例讲给他听</title>
<link>https://toutiao.io/k/tgp1ua8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面试当中，有时候会问到&lt;strong&gt;你在项目中用过多线程么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于普通的应届生或者工作时间不长的初级开发  ？？？—— crud仔流下了没有技术的眼泪。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJjUTFMSmfLCYF8L6PlhgCQYp5sGBCIzm5HAVwv8sllu19YibQa32zfMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博主这里整理了项目中用到了多线程的一个简单的实例，希望能对你有所启发。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多线程开发实例&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用的背景非常简单，博主做的项目是一个审核类的项目，审核的数据需要推送给第三方监管系统，这只是一个很简单的对接，但是存在一个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要推送的数据大概三十万条，但是第三方监管提供的接口只支持单条推送（别问为什么不支持批量，问就是没&lt;span&gt;讨&lt;/span&gt;撕&lt;span&gt;论&lt;/span&gt;比&lt;span&gt;好&lt;/span&gt;过）。可以估算一下，三十万条数据，一条数据按3秒算，大概需要250（为什么恰好会是这个数）个小时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以就考虑到引入多线程来进行并发操作，降低数据推送的时间，提高数据推送的实时性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2850595783684693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJoeKuibMZJrNYKWXOCuhKl5cib1GVQWTfibHN2qAozc2jkSM9X0OriaicicwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;业务示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计要点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;防止重复&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们推送给第三方的数据肯定是不能重复推送的，必须要有一个机制保证各个线程推送数据的隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个思路：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将所有数据取到集合（内存）中，然后进行切割，每个线程推送不同段的数据&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;利用 数据库分页的方式，每个线程取 [start,limit] 区间的数据推送，我们需要保证start的一致性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里采用了第二种方式，因为考虑到可能数据量后续会继续增加，把所有数据都加载到内存中，可能会有比较大的内存占用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;失败机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还得考虑到线程推送数据失败的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是自己的系统，我们可以把多线程调用的方法抽出来加一个事务，一个线程异常，整体回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是是和第三方的对接，我们都没法做事务的，所以，我们采用了直接在数据库记录失败状态的方法，可以在后面用其它方式处理失败的数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;线程池选择&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际使用中，我们肯定是要用到线程池来管理线程，关于线程池，我们常用 ThreadPoolExecutor提供的线程池服务，SpringBoot中同样也提供了线程池异步的方式，虽然SprignBoot异步可能更方便一点，但是使用ThreadPoolExecutor更加直观地控制线程池，所以我们直接使用ThreadPoolExecutor构造方法创建线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概的技术设计示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4625322997416021&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ5Ndqibz0WmpUMk6xZmaO0wo6pO34Sode5OnXrQ0m7O6R1QbAjs1NhaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;设计示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心代码&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面叭叭了一堆，到了show you code的环节了。我将项目里的代码抽取出来，简化出了一个示例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt; 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2021/3/5&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushProcessServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;PushProcessService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PushUtil pushUtil;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PushProcessMapper pushProcessMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//每个线程每次查询的条数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer LIMIT = &lt;span&gt;5000&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//起的线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer THREAD_NUM = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//创建线程池&lt;/span&gt;&lt;br/&gt;    ThreadPoolExecutor pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(THREAD_NUM, THREAD_NUM * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pushData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ExecutionException, InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//计数器，需要保证线程安全&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//未推送数据总数&lt;/span&gt;&lt;br/&gt;        Integer total = pushProcessMapper.countPushRecordsByState(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;未推送数据条数：{}&quot;&lt;/span&gt;, total);&lt;br/&gt;        &lt;span&gt;//计算需要多少轮&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; num = total / (LIMIT * THREAD_NUM) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;要经过的轮数:{}&quot;&lt;/span&gt;, num);&lt;br/&gt;        &lt;span&gt;//统计总共推送成功的数据条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; totalSuccessCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++) {&lt;br/&gt;            &lt;span&gt;//接收线程返回结果&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futureList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//起THREAD_NUM个线程并行查询更新库，加锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; THREAD_NUM; j++) {&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;int&lt;/span&gt; start = count * LIMIT;&lt;br/&gt;                    count++;&lt;br/&gt;                    &lt;span&gt;//提交线程，用数据起始位置标识线程&lt;/span&gt;&lt;br/&gt;                    Future&amp;lt;Integer&amp;gt; future = pool.submit(&lt;span&gt;new&lt;/span&gt; PushDataTask(start, LIMIT, start));&lt;br/&gt;                    &lt;span&gt;//先不取值，防止阻塞,放进集合&lt;/span&gt;&lt;br/&gt;                    futureList.add(future);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//统计本轮推送成功数据&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Future f : futureList) {&lt;br/&gt;                totalSuccessCount = totalSuccessCount + (&lt;span&gt;int&lt;/span&gt;) f.get();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//更新推送标志&lt;/span&gt;&lt;br/&gt;        pushProcessMapper.updateAllState(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;推送数据完成，需推送数据:{},推送成功：{}&quot;&lt;/span&gt;, total, totalSuccessCount);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 推送数据线程类&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushDataTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; start;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; limit;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; threadNo;   &lt;span&gt;//线程编号&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        PushDataTask(&lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; limit, &lt;span&gt;int&lt;/span&gt; threadNo) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.start = start;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.limit = limit;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.threadNo = threadNo;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//推送的数据&lt;/span&gt;&lt;br/&gt;            List&amp;lt;PushProcess&amp;gt; pushProcessList = pushProcessMapper.findPushRecordsByStateLimit(&lt;span&gt;0&lt;/span&gt;, start, limit);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(pushProcessList)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;            }&lt;br/&gt;            logger.info(&lt;span&gt;&quot;线程{}开始推送数据&quot;&lt;/span&gt;, threadNo);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (PushProcess process : pushProcessList) {&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; isSuccess = pushUtil.sendRecord(process);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (isSuccess) {   &lt;span&gt;//推送成功&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//更新推送标识&lt;/span&gt;&lt;br/&gt;                    pushProcessMapper.updateFlagById(process.getId(), &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    count++;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {  &lt;span&gt;//推送失败&lt;/span&gt;&lt;br/&gt;                    pushProcessMapper.updateFlagById(process.getId(), &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            logger.info(&lt;span&gt;&quot;线程{}推送成功{}条&quot;&lt;/span&gt;, threadNo, count);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码很长，我们简单说一下关键的地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程创建：线程内部类选择了实现Callable接口，这样方便获取线程任务执行的结果，在示例里用于统计线程推送成功的数量&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushDataTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 ThreadPoolExecutor 创建线程池，&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;//创建线程池&lt;/span&gt;&lt;br/&gt;      ThreadPoolExecutor pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(THREAD_NUM, THREAD_NUM * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要构造参数如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-  corePoolSize：线程核心参数选择了5&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- maximumPoolSize：最大线程数选择了核心线程数2倍数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- keepAliveTime：非核心闲置线程存活时间直接置为0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- workQueue：线程池等待队列，使用 容量初始为100的 LinkedBlockingQueue阻塞队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有没写出来的线程池拒绝策略，采用了默认AbortPolicy：直接丢弃任务，抛出异常。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 synchronized 来保证线程安全，保证计数器的增加是有序的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futureList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，主要的代码和简单的解析就到这里了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这个简单的demo，这里只是简单地做推送数据处理。考虑一下，这个实例是不是可以用在你项目的某些地方。例如监管系统的数据校验、审计系统的数据统计、电商系统的数据分析等等，只要是有大量数据处理的地方，都可以把这个例子结合到你的项目里，这样你就有了多线程开发的经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;完整代码仓库地址在文章底部👇👇&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对线面试官&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面试官：小伙子，不错，你这个整挺好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：那是自然。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试官：呦，小伙子，挺自信，那我得好好考考你。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：放马过来，但考无妨。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;0.9817813765182186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJplnicOJE2fe1ibB8MLlpJxFQJhx3CBhqdeXd2OIuicJTPuVwkST3VkeLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;494&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：先从最简单的开始，说说什么是线程吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说线程，必先说进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说Java里怎么创建线程吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java里创建线程主要有三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;继承 Thread类：Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现 Runnable接口：如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现 Callable接口：实现Callable接口，重写call()方法，可以返回一个 Future类型的返回值。我在上面的例子里就是用到了这种方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说线程的生命周期和状态&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，线程共有六种状态：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;NEW&lt;/td&gt;&lt;td&gt;初始状态：线程被创建，但还没有调用start()方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RUNNABLE&lt;/td&gt;&lt;td&gt;运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLOCKED&lt;/td&gt;&lt;td&gt;阻塞状态：表示线程阻塞于锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WAITING&lt;/td&gt;&lt;td&gt;等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME_WAITING&lt;/td&gt;&lt;td&gt;超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TERMINATED&lt;/td&gt;&lt;td&gt;终止状态：表示当前线程已经执行完毕&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6393688955672426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJwMXbeLwuiar3nicJXFSHGzgnzpP9d2NNGKUYbcS8fibkFeOTmNpzEQ5dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Java线程状态变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：我看你提到了线程阻塞，那你再说说线程死锁吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对⽅的资源，所以这两个线程就会互相等待⽽进⼊死锁状态。&lt;/p&gt;&lt;img data-ratio=&quot;0.6206896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJvsVBVbkFS5uejiao5Q2nbCe7vygjTchP3PviaNSMDPJjZYfjXvBiarD5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产生死锁必须满足四个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：怎么避免死锁呢？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我上⾯说了产⽣死锁的四个必要条件，为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个就可以了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏请求与保持条件 ：⼀次性申请所有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：我看你的例子里用到了synchronized，说说 synchronized的用法吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「synchronized」&lt;/strong&gt; 关键字最主要的三种使⽤⽅式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「1.&lt;strong&gt;「修饰实例⽅法」&lt;/strong&gt;:」&lt;/strong&gt; 作⽤于当前对象实例加锁，进⼊同步代码前要获得 当前对象实例的锁&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「2.&lt;strong&gt;「修饰静态⽅法」&lt;/strong&gt;:」&lt;/strong&gt; 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ &lt;em&gt;static&lt;/em&gt; 表明这是该类的⼀个静态资源，不管 &lt;em&gt;new&lt;/em&gt; 了多少个对象，只有⼀份）。所以，如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 &lt;strong&gt;「synchronized」&lt;/strong&gt; ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 &lt;strong&gt;「synchronized」&lt;/strong&gt; ⽅法占⽤的锁是当前实例对象锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; staic &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**3.**修饰代码块 ：指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的例子里使用synchronized修饰代码块，给PushProcessServiceImpl类加锁，进⼊同步代码前要获得 当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁，防止PushProcessServiceImpl类的对象在控制层调用推送数据的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：除了使用synchronized，还有什么办法来加锁吗？详细说一下&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用juc包提供的锁。Lock接口主要相关的类和接口如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3722044728434505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJG4J44V9sDaKDh0FFLj48icG9E2fHqaJ4zST9FIbqC0Tl4hqvqrE8gMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306162316895&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lock中的主要方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;lock：用来获取锁，如果锁被其他线程获取，进入等待状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lockInterruptibly：通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock：tryLock方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock（long，TimeUnit）：与tryLock类似，只不过是有等待时间，在等待时间内获取到锁返回true，超时返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unlock：释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其它接口和类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReetrantLock（可重入锁）：实现了Lock接口，可重入锁，内部定义了公平锁与非公平锁。可以完成synchronized 所能完成的所有工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReadWriteLock（读写锁）：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ReadWriteLock&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;Lock &lt;span&gt;readLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;       &lt;span&gt;//获取读锁  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Lock &lt;span&gt;writeLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;      &lt;span&gt;//获取写锁  &lt;/span&gt;&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReetrantReadWriteLock（可重入读写锁）：ReetrantReadWriteLock同样支持公平性选择，支持重进入，锁降级。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说synchronized和Lock的区别&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类别&lt;/th&gt;&lt;th&gt;synchronized&lt;/th&gt;&lt;th&gt;Lock&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;存在层次&lt;/td&gt;&lt;td&gt;Java的关键字，在jvm层面上&lt;/td&gt;&lt;td&gt;是一个接口，api级别&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁的释放&lt;/td&gt;&lt;td&gt;1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁&lt;/td&gt;&lt;td&gt;在finally中必须释放锁，不然容易造成线程死锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁的获取&lt;/td&gt;&lt;td&gt;假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待&lt;/td&gt;&lt;td&gt;分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁状态&lt;/td&gt;&lt;td&gt;无法判断&lt;/td&gt;&lt;td&gt;可以判断&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁类型&lt;/td&gt;&lt;td&gt;可重入 不可中断 非公平&lt;/td&gt;&lt;td&gt;可重入 可判断 可公平（两者皆可）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能&lt;/td&gt;&lt;td&gt;少量同步&lt;/td&gt;&lt;td&gt;大量同步&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：你提到了synchronized基于jvm层面，对这个有了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized是利用java提供的原⼦性内置锁（&lt;strong&gt;「monitor」&lt;/strong&gt; 对象），每个对象中都内置了⼀个 ObjectMonitor 对象。这种内置的并且使⽤者看不到的锁也被称为监视器锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;big&gt;同步语句块&lt;/big&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「synchronized」&lt;/strong&gt; 同步语句块的实现使⽤的是 &lt;strong&gt;「monitorenter」&lt;/strong&gt; 和 &lt;strong&gt;「monitorexit」&lt;/strong&gt; 指令，其中&lt;strong&gt;「monitorenter」&lt;/strong&gt; 指令指向同步代码块的开始位置&lt;strong&gt;「monitorexit」&lt;/strong&gt; 指令则指明同步代码块的结束位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执⾏monitorenter指令时会尝试获取内置锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进⼊等待队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执⾏monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt; &lt;strong&gt;「synchronized 修饰⽅法」&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法。JVM 通过该ACC_SYNCHRONIZED 访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，二者细节略有不同，但本质上都是获取原子性内置锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再深入一点，synchronized实际上有两个队列waitSet和entryList。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当多个线程进⼊同步代码块时，⾸先进⼊entryList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有⼀个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程调⽤wait⽅法，将释放锁，当前线程置为null，计数器-1，同时进⼊waitSet等待被唤醒，调⽤notify或者notifyAll之后⼜会进⼊entryList竞争锁&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程执⾏完毕，同样释放锁，计数器-1，当前线程置为null&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;0.3701171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJCQqkRia6AlWJCCkCiac1TAlGzgu2ShHRVnQmfG4c7q50pe9fEqa7Cuwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;synchronized的优化能说一说吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是⼀个很重量级的锁。优化机制包括⾃适应锁、⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁的状态从低到⾼依次为⽆锁**-&amp;gt;&lt;strong&gt;「偏向锁」&lt;/strong&gt;-&amp;gt;&lt;strong&gt;「轻量级锁」&lt;/strong&gt;-&amp;gt;**重量级锁，升级的过程就是从低到⾼。&lt;/p&gt;&lt;img data-ratio=&quot;0.08827785817655572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJPvVAdbIhia0cc5ddicbLAWRLP9h8UzSw9w4iaa1zkellSYGwU1WPOrTAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「自旋锁」&lt;/strong&gt;：由于⼤部分时候，锁被占⽤的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，⽤户态和内核态的来回上下⽂切换严重影响性能。⾃旋的概念就是让线程执⾏⼀个忙循环，可以理解为就是啥也不⼲，防⽌从⽤户态转⼊内核态，⾃旋锁可以通过设置-XX:+UseSpining来开启，⾃旋的默认次数是10次，可以使⽤-XX:PreBlockSpin设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「自适应锁」&lt;/strong&gt;：自适应锁就是自适应的自旋锁，自旋锁的时间不是固定时间，而是由前⼀次在同⼀个锁上的⾃旋时间和锁的持有者状态来决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁消除」&lt;/strong&gt;：锁消除指的是JVM检测到⼀些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进⾏锁消除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁粗化」&lt;/strong&gt;：锁粗化指的是有很多操作都是对同⼀个对象进⾏加锁，就会把锁的同步范围扩展到整个操作序列之外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「偏向锁」&lt;/strong&gt;：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录⾥存储偏向锁的线程ID，之后这个线程再次进⼊同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第⼀个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进⾏同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以⽤过设置-XX:+UseBiasedLocking开启偏向锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「轻量级锁」&lt;/strong&gt;：JVM的对象的对象头中包含有⼀些锁的标志位，代码进⼊同步块的时候，JVM将会使⽤CAS⽅式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试⾃旋来获得锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁升级的过程非常复杂，简单点说，偏向锁就是通过对象头的偏向线程ID来对⽐，甚⾄都不需要CAS了，⽽轻量级锁主要就是通过CAS修改对象头锁记录和⾃旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6295566502463055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJiaFD7Ewdg0khfoiceO25NMrR1XWVmxiaapjd2BE5iaDCRGWO2caUliaUiaDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1015&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306142412015&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下CAS&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS是一种乐观锁，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的 (AtomicInteger,AtomicBoolean,AtomicLong)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：CAS会导致什么问题？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ABA 问题：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;循环时间长开销大：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;section&gt;只能保证一个共享变量的原子操作：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下说下ReentrantLock原理吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 是基于 Lock 实现的可重入锁，所有的 Lock 都是基于 AQS 实现的，AQS 和 Condition 各自维护不同的对象，在使用 Lock 和 Condition 时，其实就是两个队列的互相移动。它所提供的共享锁、互斥锁都是基于对 state 的操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下AQS吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueuedSynchronizer，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock/Semaphore/CountDownLatch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「AQS」&lt;/strong&gt; 核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 &lt;strong&gt;「AQS」&lt;/strong&gt; 是⽤ &lt;strong&gt;「CLH」&lt;/strong&gt; 队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个 AQS原理图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4160777385159011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJmGic1XKMoG5Z3fN861cmupUyv3Z0cSb1nwicuSKj745fTUdTlvu5hn6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306144734263&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 使⽤⼀个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队⼯作。AQS 使⽤ CAS 对该同步状态进⾏原⼦操作实现对其值的修改。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;&lt;span&gt;//共享变量，使⽤volatile修饰保证线程可⻅性&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态信息通过 protected 类型的 getState，setState，compareAndSetState 进⾏操作&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//返回同步状态的当前值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getState&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; state; }&lt;br/&gt;&lt;span&gt;// 设置同步状态的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setState&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; newState)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; state = newState; }&lt;br/&gt;&lt;span&gt;//原⼦地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;compareAndSetState&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt; update)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, expect, update);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试加锁的时候通过CAS(CompareAndSwap)修改值，如果成功设置为1，并且把当前线程ID赋值，则代表加锁成功，⼀旦获取到锁，其他的线程将会被阻塞进⼊阻塞队列⾃旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把state重新置为0，同时当前线程ID置为空。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.436308926780341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJeSTAsNxmibRjUoOdxmKgItEMhuxaQGPvrgRuzox1eSOS69YJOIt0zWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306145019137&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下Semaphore/CountDownLatch/CyclicBarrier吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Semaphore(信号量)&lt;/strong&gt;-允许多个线程同时访问：synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CountDownLatch(倒计时器)&lt;/strong&gt;：CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CyclicBarrier(循环栅栏)&lt;/strong&gt;：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;volatile原理知道吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相⽐synchronized的加锁⽅式来解决共享变量的内存可⻅性问题，volatile就是更轻量的选择，他没有上下⽂切换的额外开销成本。使⽤volatile声明的变量，可以确保值被更新的时候对其他线程⽴刻可⻅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile使⽤&lt;strong&gt;内存屏障&lt;/strong&gt;来保证不会发⽣指令重排，解决了内存可⻅性的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，线程都是从主内存中读取共享变量到⼯作内存来操作，完成之后再把结果写会主内存，但是这样就会带来可⻅性问题。举个例⼦，假设现在我们是两级缓存的双核CPU架构，包含L1、L2两级缓存。&lt;/p&gt;&lt;img data-ratio=&quot;0.8811524609843937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJp6C8HJnZuXTJhuyHtqPJ5plQKskBqhibvrR5Ukpib0HQj34ibc9ialicuibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果X变量⽤volatile修饰的话，当线程A再次读取变量X的话，CPU就会根据缓存⼀致性协议强制线程A重新从主内存加载最新的值到⾃⼰的⼯作内存，⽽不是直接⽤缓存中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来说&lt;strong&gt;内存屏障&lt;/strong&gt;的问题，volatile修饰之后会加⼊不同的内存屏障来保证可⻅性的问题能正确执⾏。这⾥写的屏障基于书中提供的内容，但是实际上由于CPU架构不同，重排序的策略不同，提供的内存屏障也不⼀样，⽐如x86平台上，只有StoreLoad⼀种内存屏障。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;StoreStore屏障，保证上⾯的普通写不和volatile写发⽣重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;StoreLoad屏障，保证volatile写与后⾯可能的volatile读写不发⽣重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LoadLoad屏障，禁⽌volatile读与后⾯的普通读重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LoadStore屏障，禁⽌volatile读和后⾯的普通写重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;1.159322033898305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJXJHlLMQzpAEEw4TAosJ9ccLDurob0zCLQpFMLjqeFtzwQTjICzicib6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说你对Java内存模型（JMM）的理解，为什么要用JMM&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本身随着CPU和内存的发展速度差异的问题，导致CPU的速度远快于内存，所以现在的CPU加⼊了⾼速缓存，⾼速缓存⼀般可以分为L1、L2、L3三级缓存。基于上⾯的例⼦我们知道了这导致了缓存⼀致性的问题，所以加⼊了缓存⼀致性协议，同时导致了内存可⻅性的问题，⽽编译器和CPU的重排序导致了原⼦性和有序性的问题，JMM内存模型正是对多线程操作下的⼀系列规范约束，通过JMM我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了Java程序在不同的平台下达到⼀致的内存访问效果，同时也是保证在⾼效并发的时候程序能够正确执⾏。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7018121911037891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ00th6hBgy6hxkpJBuIzIRDMJSxHrOADPx9XRC986581P9mY8QMDqlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306150619637&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：看你用到了线程池，能说说为什么吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提高线程的利用率，降低资源的消耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高响应速度，线程的创建时间为T1，执行时间T2，销毁时间T3，用线程池可以免去T1和T3的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;便于统一管理线程对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可控制最大并发数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下线程池的核心参数吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一ThreadPoolExecutor的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize,&lt;br/&gt;                         &lt;span&gt;int&lt;/span&gt; maximumPoolSize,&lt;br/&gt;                         &lt;span&gt;long&lt;/span&gt; keepAliveTime,&lt;br/&gt;                         TimeUnit unit,&lt;br/&gt;                        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;br/&gt;                        ThreadFactory threadFactory,&lt;br/&gt;                        RejectedExecutionHandler handler)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;核⼼线程数corePoolSize  :此值是用来初始化线程池中核心线程数，当线程池中线程池数&amp;lt; &lt;code&gt;corePoolSize&lt;/code&gt;时，系统默认是添加一个任务才创建一个线程池。可以通过调用&lt;code&gt;prestartAllCoreThreads&lt;/code&gt;方法一次性的启动&lt;code&gt;corePoolSize&lt;/code&gt;个数的线程。当线程数 = corePoolSize时，新任务会追加到workQueue中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;允许的最大线程数maximumPoolSize:&lt;code&gt;maximumPoolSize&lt;/code&gt;表示允许的最大线程数 = (非核心线程数+核心线程数)，当&lt;code&gt;BlockingQueue&lt;/code&gt;也满了，但线程池中总线程数 &amp;lt; &lt;code&gt;maximumPoolSize&lt;/code&gt;时候就会再次创建新的线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;活跃时间keepAliveTime：非核心线程 =(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;保持存活时间unit：线程池中非核心线程保持存活的时间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;等待队列workQueue：线程池 等待队列，维护着等待执行的&lt;code&gt;Runnable&lt;/code&gt;对象。当运行当线程数= corePoolSize时，新的任务会被添加到&lt;code&gt;workQueue&lt;/code&gt;中，如果&lt;code&gt;workQueue&lt;/code&gt;也满了则尝试用非核心线程执行任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程工厂 threadFactory：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;拒绝策略RejectedExecutionHandler：&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;都不可用的时候执行的 饱和策略。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：完整说一下线程池的工作流程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当调用 execute() 方法添加一个任务时，线程池会做如下判断：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;0.5403788634097707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJiabKkQuSUuAtzSXDvoGSaaYvVTbzPLyVvc3ibLpnIbknKcdHwEOAlCQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：拒绝策略有哪些&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有4种拒绝策略：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AbortPolicy：直接丢弃任务，抛出异常，这是默认策略&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CallerRunsPolicy：只⽤调⽤者所在的线程来处理任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执⾏当前任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DiscardPolicy：直接丢弃任务，也不抛出异常&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下你的核心线程数是怎么选的&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在&lt;strong&gt;「页缺失」&lt;/strong&gt;(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;IO密集型：线程数适当大一点，机器的Cpu核心数*2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合型：如果密集型站大头则拆分的必要性不大，如果IO型占据不少有必要，Mark 下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下有哪些常见阻塞队列&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DelayQueue：使用优先级队列实现的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue：不存储元素的阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedTransferQueue：由链表结构组成的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedBlockingDeque：由链表结构组成的双向阻塞队列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下有哪几种常见的线程池吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们直接用到了ThreadPoolExecutor的构造方法创建线程池，还有另一种方式，通过Executors 创建线程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;需要注意的是，阿里巴巴Java开发手册强制禁止使用Executors创建线程&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2937608318890815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ6Sf9ictaJYLZLV5nyqVTj2TlD5qhgic9FGOwsBRNyDmvZDsnibxM5ohicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306153832125&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较典型常见的四种线程池包括：&lt;code&gt;newFixedThreadPool&lt;/code&gt;、 &lt;code&gt;newSingleThreadExecutor&lt;/code&gt; 、 &lt;code&gt;newCachedThreadPool&lt;/code&gt;、&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;FixedThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用的&lt;strong&gt;「无界」&lt;/strong&gt;的等待队列是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;。使用时候有堵满等待队列的风险。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17851500789889416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJj8iaqmShUicGYeYhblGRG5NAfqTicVTkyKvGXicVrVrxmVrxTM6nhLdtZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161851855&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SingleThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有一条线程来执行任务，适用于有顺序的任务的应用场景，也是用的&lt;strong&gt;「无」&lt;/strong&gt;界等待队列&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2006079027355623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJCjQtia7UaYsRicWAZiaCjxKvXk4DciaS2yG8xicYdWnAZ4w6eoda9ceKj6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161915934&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt; CachedThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。任务队列用的是SynchronousQueue如果生产多快消费慢，则会导致创建很多线程需注意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1841704718417047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJRt6IRxgXUn7u7Ov5eRVDY18lI2yuCd0DhPF5c51rKVibEUUJ5WpxumA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161950237&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt; ScheduledThreadPoolExecutor&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「周期性」&lt;/strong&gt;执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看构造函数：调用的还是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;构造函数，区别不同点在于任务队列是用的DelayedWorkQueue。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1598173515981735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJWjOgicNxoqp79nVPJxq6UzYbSJWfmNHr8nhRGXCjNhcm3LnLIJJb8Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306162020463&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面试官：这些题都能回答出来，很好，小伙子，很有精神！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：谢谢。那面试官老师，你看这一轮面试……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试官：虽然你答的很好，但你的项目数据量只有十万级，不符合我们的要求。所以，面试不能让你过。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老三上去就是一个左刺拳，再接一个右正蹬……&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;代码地址：https://gitee.com/fighter3/thread-demo.git&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;好了，通过本文，相信你对多线程的应用和原理都有了一定的了解。文章开头提到的crud仔就是博主本人了，技术水平有限，难免错漏，欢迎指出，谢谢！&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：[使用多线程查询百万条用户数据将汉字转化成拼音](https://juejin.cn/post/6844903665564647437)&lt;br/&gt;&lt;br/&gt;【2】：[讲真 这次绝对让你轻松学习线程池](https://mp.weixin.qq.com/s/dTMH1TdxiCKy5yotQ7u7cA)&lt;br/&gt;&lt;br/&gt;【3】：[SpringBoot学习笔记（十七：异步调用）](https://blog.csdn.net/sinat_40770656/article/details/107351205?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161495963016780274184752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;amp;request_id=161495963016780274184752&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-107351205.pc_v2_rank_blog_default&amp;amp;utm_term=%E5%BC%82%E6%AD%A5)&lt;br/&gt;&lt;br/&gt;【4】：JavaGuide编著《JavaGuide面试突击版》&lt;br/&gt;&lt;br/&gt;【5】：艾小仙编著 《我想进大厂面试总结》&lt;br/&gt;&lt;br/&gt;【6】：佚名编著 《Java核心知识点整理》&lt;br/&gt;&lt;br/&gt;【7】：[Java并发基础知识，我用思维导图整理好了](https://blog.csdn.net/sinat_40770656/article/details/113612422)&lt;br/&gt;&lt;br/&gt;【8】：[并发编程的锁机制：synchronized和lock ](https://juejin.cn/post/6844903542440869896#heading-11)&lt;br/&gt;&lt;br/&gt;【9】：[详解synchronized与Lock的区别与使用](https://blog.csdn.net/u012403290/article/details/64910926)&lt;br/&gt;&lt;br/&gt;【10】：bugstack小傅哥编著《Java面经手册》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;往期精选:&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247484838&amp;amp;idx=1&amp;amp;sn=01306c236ab7dc1bd744f07c2eb3ef69&amp;amp;chksm=c0cced03f7bb6415d36b294d7d3db382fad79e04be56c9424645547c16756f63c82f31a3d270&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这些不可不知的JVM知识，我都用思维导图整理好了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485058&amp;amp;idx=1&amp;amp;sn=7e4273c31e97f2be4ec25c2c16577488&amp;amp;chksm=c0ccee27f7bb6731a9b749c2a8658541461b1054dafe057f5d1eec06f2738eeb963ec8abbea1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL索引从基础到原理，看这一篇就够了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247484269&amp;amp;idx=1&amp;amp;sn=4ed9f127f859fc6c06c4d6a28b68fbf2&amp;amp;chksm=c0ccebc8f7bb62deff86a8a13d32e31760aa86da15b94a3bb6d0f2946af4c32425dc34dfb56d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这些并发基础知识，我都用思维导图整理好了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5daed062f927e6435ab95bf182f02b29</guid>
<title>从技术专家到技术管理，我对管理的思考</title>
<link>https://toutiao.io/k/r5kgujp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-lake-id=&quot;c59d3ce6d8f3de38bc41f0ddf54f9231&quot;&gt;前言&lt;/h2&gt;&lt;p data-lake-id=&quot;af3634f9a47f9d77c40232118fb35431&quot;&gt;工作第七个年头，我从技术专家，变成了一名技术管理者。最近一直在忙碌中思考如何成为一名优秀的技术管理者。这篇文章，主要会从两个观点和维度，来谈谈自己的一些认知和思考总结。&lt;span data-mce-style=&quot;font-size: 10px&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8f2d278849f8aaa34c20d8cf8062c66a&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;40b9e41847e55b8d4e1b3b023302ce0e&quot;&gt;观点&lt;/h2&gt;&lt;p data-lake-id=&quot;5b8334f08a8247b7564621261e23f7ab&quot;&gt;首先，从工程师到技术管理的转变，有两个观点要明确：&lt;/p&gt;&lt;p data-lake-id=&quot;e2d8767d6bcdfda62e182f65392ffc66&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;1）技术Leader是团队最好的工程师之一；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f2da4fbfc10ea20dd0e497a3fdc9f56e&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;2）技术Leader是为团队服务，解决团队的问题；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;dda379e68872bf2ec7b133d94eefafc7&quot;&gt;&lt;span&gt;工程师只需要对自己负责，而管理者需要对团队负责。&lt;/span&gt;&lt;span&gt;这两个身份所立足的核心点是一样的，首先要有符合要求的专业性，专业性越强越能够给他人带来信任感；其次是良好的沟通能力。但是这两件事在管理者和工程师身上的要求和方向却有很大的差异。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;daf8d4ab8a1fd2ab2c5a66b8e7710085&quot;&gt;&lt;span&gt;专业性&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;8c38524d3ed4bb5c6f0b7fa0ed3739b6&quot;&gt;&lt;span&gt;     对于工程师来说，所谓的专业性单纯的指技术领域的专业性，因为工程师的核心产出主要依赖于其技术领域的造诣，主要的要求是对自己的产出负责，所以需要不停的钻研自己需要依赖的技术，打磨自己使用的工具，不断提升自己能做的事情的边界，不断的提升自己的深度；&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9641e0e95cae78d8bc10b47dfae46f64&quot;&gt;&lt;span&gt;对于管理者来说，所谓的专业性则更加偏向于如何提升团队产出，所以核心的要求会和工程师有所变化，我个人认为可以拆解到以下几方面：&lt;/span&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;44f581f6d7cbfb60d5cf135d9733c193&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;团队建设&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：核心包括招聘和团队层次搭建，团队和个人最直接的区别就是人数，团队是一个组织，对于管理者来说，首先需要的就是把这个组织建立起来，一个人的组织很难比10个人的组织产出高；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;设定目标&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当团队已经搭建起来之后，最重要的事情就是要做什么了，如果团队的目标是错误的，那很可能导致整个团队负向产出，所以目标一定要对。在这一点上是最体现管理者的“专业性”的，方向走对了，整个团队事半功倍，整个团队都会信服管理者，反之，则全是管理者一个人的责任。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;提升效率&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：一般我们直观能想到的就是招更好的人提升效率，但站在管理者的角度还要考虑是否能在工具或流程上改造，是否能靠提升团队分工情况来改善效率等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;树立榜样&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;管理者是团队的模仿对象，是团队的行为标杆，将自身的能力、行为分享和传达给团队，建立积极的竞争氛围。竞争能够高效激发员工的潜力，要让团队中员工处理良性竞争状态，给团队创造“危机意识”。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-lake-id=&quot;582e6e65ed96c968061f42c62070c0a4&quot;&gt;&lt;span&gt;职业性&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;7269550dd666ace24d32984db19d4b62&quot;&gt;&lt;span&gt;对于工程师来说，核心的沟通方一般是团队内部和产品，沟通的要求主要是能和产品沟通清楚需求，能讲明白自己的技术方案即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;584bd55824a5a682718e668958c37a2c&quot;&gt;&lt;span&gt;对于团队管理来说，核心的沟通方都是其他团队，管理者需要帮团队解决的一个大问题就是外部资源依赖问题，所以对沟通的要求要高很多，如何能说服其他团队提供资源解决自己的问题是管理者需要解决的核心工作之一。&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;你推进的不再是一个简单的、自闭环的事。你需要对上沟通，跨团队沟通，以及对下沟通，开始需要学习各种技能，更多的掌握业务，站在用户角度，然后再来思考如何通过系统来满足需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;584bd55824a5a682718e668958c37a2c&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e9d443b7a027bc82214a2f69ea675b43&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;27d9eb02e9f9e9841111ab839d8e611c&quot;&gt;维度&lt;/h2&gt;&lt;h3 data-lake-id=&quot;a7f02a83be67ff42355179341ee11d2d&quot;&gt;团队维度&lt;/h3&gt;&lt;p data-lake-id=&quot;c54fbdcd3de056a1e2b620331c09527f&quot;&gt;&lt;span/&gt;从团队维度来讲，从一名工程师到技术管理的转变，我总结了四个方面：&lt;/p&gt;&lt;h4 data-lake-id=&quot;77ed77b111085a02c8009a414f1c5b0d&quot;&gt;1、躬身入局&lt;/h4&gt;&lt;p data-lake-id=&quot;f0ef8e2f712a1c0a3964465a1f8f153d&quot;&gt;如果只是以工程师的角度去工作，可能只会关注项目里面的某些点，容易陷入思维定势，不太容易去思考全局。因此在最开始应该学会“躬身入局”，了解团队工作中的重要节点，而不是高高在上。工程师和技术管理只是职责上不同，而非职级或者“阶级”上的区分。&lt;/p&gt;&lt;h4 data-lake-id=&quot;0b7e2ddf968b095371ea0186a0f46bad&quot;&gt;2、抓大放小&lt;/h4&gt;&lt;p data-lake-id=&quot;69e4d6d96d977350f4d77f8ec2cde27e&quot;&gt;团队要做的事情，从复杂程度以及数量多寡来说，肯定远远超过个人。因此要学会分辨那些是重要紧急的事项，从全局角度考虑，可以适当的做“局部牺牲”来保证整体拿到更好的结果。&lt;/p&gt;&lt;h4 data-lake-id=&quot;d03f7208c6c181b5424a74ca99693490&quot;&gt;3、向下赋能&lt;/h4&gt;&lt;p data-lake-id=&quot;43e6bc147cdf3682113f453e68aaec1a&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;个人的时间和精力都是有限的，&lt;/span&gt;从工程师到技术管理，&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;很多时候时间不再是自己的。尝试去&lt;/span&gt;相信团队里面的每个同学，给他们机会去做一些超过之前职责和能力的事情，当然过程中要及时给予指导和过程把控，相信他们能拿到更好的结果。&lt;/p&gt;&lt;h4 data-lake-id=&quot;7a8015eb4583869ba3e5fd2c3c27e1f7&quot;&gt;4、持续学习&lt;br/&gt;&lt;/h4&gt;&lt;p data-lake-id=&quot;fe9939db6c761d62fe14a468984da890&quot;&gt;作为技术出身的管理者，要时刻保持对新技术的学习，并在可能的范围之内承担一定的开发&amp;amp;测试工作或者说要对团队内技术项目足够深入，在成员遇到问题时要能给出解决方案或者思路。&lt;/p&gt;&lt;p data-lake-id=&quot;17b9fc245d6e67143a08abb074ac1c4e&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;保持耐性，有服务和指导以及培养团队的的意识，提升整个团队的实力。技术管理者要能规划和提出团队的目标，明确团队前进的方向，并确保大家能够不偏离轨道，不断纠正，直到达到目标。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;17b9fc245d6e67143a08abb074ac1c4e&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;a5b1d117be8845df5ae97a882966bd21&quot;&gt;个人维度&lt;/h3&gt;&lt;h4 data-lake-id=&quot;5b1caf8796e87a80d15ebe35677c3f78&quot;&gt;1、持续学习&lt;/h4&gt;&lt;p data-lake-id=&quot;46705897c7ea0c922b7dc80dba878926&quot;&gt;技术Leader必须是团队最好的工程师之一，要能够基于自己的技术能力&amp;amp;业务认知做决策。要确保技术成长的速度，&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;通过现象看出背后的原因或原理，要能成为问题终结者。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;10ccd978a8ee82305faffc5a020edc87&quot;&gt;2、目标明确&lt;/h4&gt;&lt;p data-lake-id=&quot;dd1e107dc12d7571c28c4a74373d6a65&quot;&gt;工程师更多是面向技术，是一个很小的圆；成为技术管理者后，需要调整自己的认知边界，成为更大的圆，及时补齐不同方面的能力缺失。&lt;/p&gt;&lt;ul data-lake-id=&quot;19f80dc8ef98a32f19cf5daba461a606&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;业务&lt;/strong&gt;：从单一功能模块设计、单一系统设计到思考业务发展趋势、结合现阶段公司情况能比较清晰认识到现阶段、中短期、中长期、长期业务的形态和该做的事情。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;团队&lt;/strong&gt;：首先要有能力打造团队(招聘、教化、引导)，然后思考团队目标是什么、团队面临的职责或使命是什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;规划&lt;/strong&gt;：认清做好规划是为了落地去实现它而不是为了PPT，需要具备一定的规划能力，这其中包含了对上对下的目标明确、资源协调争取、对外沟通合作等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;对上对下&lt;/strong&gt;：对上，明确公司业务战略方向，及时对齐目标，及时同步进展；对下，及时沟通了解个性了解述求、协调资源给与帮助。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-lake-id=&quot;ca70dd28aeeae59523efbce9e02a8031&quot;&gt;3、保持思考&lt;/h4&gt;&lt;p data-lake-id=&quot;57f883033b72f711af1c175971975c90&quot;&gt;当你作为一个技术管理者，需要保证一定的思考时间，转换埋头执行的工作方式。需要从单点模式的思考，快速过度到一个项目甚至更高维度的业务层级。这是一个“点-线-面”的过程，需要保持耐心。&lt;/p&gt;&lt;h4 data-lake-id=&quot;1915e6f9e47ae550be573d8689f9c329&quot;&gt;4、适当放手&lt;/h4&gt;&lt;p data-lake-id=&quot;7580b3010625bc238954b901fee38d35&quot;&gt;学会抓大放小，结果导向。精力有限很难面面俱到，学会放手让有能力的人去具体落地，自己做好跟进识别业务核心、把控方案设计、codereview等工作。&lt;/p&gt;&lt;p data-lake-id=&quot;c31547fc9ec678828e3e191fa91e3b95&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5fbb517257a28e30ea61bc289260d500&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c1dc4845b178637eddcd355d6fd336a</guid>
<title>下一代微服务 Service Mesh 原理及实践</title>
<link>https://toutiao.io/k/hxrinvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构痛点&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业务关注服务之间通信&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;会导致业务迭代速度变慢&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务架构1.0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.643&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmiajLDjc9MPXicibQiaAOrKpKhktXkwo2z5AvyvtbGM2G3zPx7EM1rAZHIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;网关层1个、业务逻辑层多个、数据访问层多个、DB/Cache多个，注册中心、配置中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务2.0架构-服务网格&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3867735470941884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm04yhHth8b2E02ib2USEvHaksgazdibxTMQGWicTTrqD0cJOpTt1nDl4JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础设施升级困难&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;影响基础设施团队的交付能力和交付速度&lt;br/&gt;因为应用程序通过jar包方式引入通信组件&lt;br/&gt;通信组件升级需要应用程序配合jar包版本升级&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35850956696878145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmuVcXnTB12CTiaZVfCDZD4XLTEMxuT7JD9dsQsD6yJdN6kH40neXsRpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1986&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多编程语言之间&#x27;通信&#x27;问题&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;业务每种语言一套基础设施 成本大&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5065065065065065&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0nkAfvnwft5wCfvspwQt3ia7UKuvn1duiatSHBlazZEfeb7yV48BwNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1998&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构演进&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6202404809619239&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm82tn8Emsn1QQJ8Gd8oVkUOgNrjGbk5Qo8eibwrgticTdSEsUjF7XP53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格定义&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1494949494949495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmdp8dbUuibwWlMgXtcKZMYHfjoGxouD6aP5llbqrpE6d5Ph50Vo4MOrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格架构&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3587939698492462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm7ldtRY15MtRTHt4CFvCK0B7hlXA1NwmU6rsPIDRLmw4y7AxXl6av9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;带来的问题-链路会变长&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;性能里面的RT 平均响应延迟会变高&lt;br/&gt;但本机之间即应用程序放到本机的sidecar损耗不会超过1毫秒&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开源框架&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最早版本linkerd&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5393145161290323&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmhqnkic7NVOkx4vic78f0T6Bb5sQCA0OdszPgw7ohciaEuHbPrjke1Q6bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;应用程序和sidecar之间通讯用tcp或http1.1以上都可以；两者需要保持长连接&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;istio&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5272177419354839&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmV5BVAcx02mtLnoX8k72PeIgfZ2fy57ybnMcrh18FCtchUETXwkNPqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;控制中心&lt;br/&gt;1、控制proxy之间通讯&lt;br/&gt;2、负载均衡&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;数据收集服务：&lt;br/&gt;&lt;br/&gt;proxy之间通讯完之后 要上报一些mertics信息 （耗时、请求次数）&lt;br/&gt;全部同步上报&lt;br/&gt;集中式 不靠谱&lt;br/&gt;它的性能影响proxy本身的性能&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;做鉴权安全相关的&lt;br/&gt;proxy之间权限鉴权比如TLS、SSL&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sofa mesh&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;蚂蚁金服开源&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;架构&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5371485943775101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmjb27vgyKDnVKosFmXPicLTPtNPaV3PeVibd8PCFnj6VRrdQOlTQhib0uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1992&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、将istio中的proxy重写&lt;br/&gt;isotio proxy是用c++写的&lt;br/&gt;sofa用go重写&lt;br/&gt;2、istio数据收集节点是集中式的 sofa是分布式的即每个proxy中都有一个mixer&lt;br/&gt;3、目前还没有公司大规模在用 社区不活跃 建议使用istio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;新浪weibo mesh&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5542046605876393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2AcJ10hv8sSMFHW5pnNv802fibw4icNZfxAkIlpdK3h0lh5IxypAqxGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1974&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格做什么&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5557809330628803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmfqEgE9Iyuic9SDnQGfJF5lU2C32bibIZTfuB65QWzXxFAicbSdPL9xbmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何选型&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0440456769983686&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmoCLMeFcSWr3p7LHdyDm1sZbb56h6HF5y3u4oLH6RZeIrfVwCLWbmGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、业务升级代价太高 要让业务的升级成本降低到0 要兼容所有rpc用法 所以自研&lt;br/&gt;2、期望的是业务方只需要将rpc jar包换成这个rpc mesh jar包就行了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自研思路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6939655172413793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmbQfriaJyu4Rc3C2ibSQicXoEww4Ple3YtpZ12M5c4MIQtQDc3akNFH2mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、要兼容传统(物理机、虚拟机)和云&lt;br/&gt;2、控制中心包括服务管理平台和数据收集中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构设计&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.624750499001996&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm6YibfraG2mpo9wpNsAs4fQVaxH903whNVe2ssxQUYIAbkiaamplfmqBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2004&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、数据收集中心：&lt;br/&gt;a、Metric:收集耗时、响应情况&lt;br/&gt;b、Trace:分布式请求跟踪系统APM&lt;br/&gt;c、Alarm：报警功能&lt;br/&gt;2、Protocol&lt;br/&gt;a、RPC:兼容老的RPC协议&lt;br/&gt;b、mesh包括通讯协议(http1.1和2.0)和数据协议(protobuff)&lt;br/&gt;&lt;br/&gt;（注：http1.0不支持 因为是短连接;http1.1和http2.0支持keep alive长连接;tpc是长连接;连接还在 server短可以直接推送消息给client）&lt;br/&gt;&lt;br/&gt;2、sidecar之间的健康检查没有通过注册中心而是本身&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总体流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5563380281690141&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmrSJdXxcYt152vciaR2Ob4vQiagxHDFXu7AK2qTtD6qbiadr6oXczw4Y3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;用户发起一个熔断服务B的指令&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6687179487179488&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2TJRQWtdicfY7JJaRtb3QRUad370WicLSQK8RDpLUWLb53ialyPKNqRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、服务管理平台、控制中心、数据收集中心都是现成的服务（之前文章介绍过）那么自研Service Mesh只需要实现proxy就可以了&lt;br/&gt;2、之前Service和Proxy是一个进程&lt;br/&gt;现在需要修改成2个独立的进程即可&lt;br/&gt;3、将二者放到同一个pod中&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;如果sidecar挂了对整体是否有影响?&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;没有影响。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4915514592933948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmha1K9PrBecoN7mhbfYdUAa1bledkmlrEMYdwwf9lWovsiaYndOL5I9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sidecar挂掉 pod如何处理？&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;如果sidecar挂掉了 就会被监控到 直接把当前pod杀死就行了 k8s会自动重启一个pod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2个应用程序放在同一个物理机上架构怎样？&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5741758241758241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmVVtyS2E1ZDIlJRdTiceHsjug11thSR3uOZQtjtbuzwg9uPqM5wn3ldw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;漂移&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、日志漂移&lt;br/&gt;&lt;br/&gt;服务器1上有服务1生成日志1&lt;br/&gt;如果服务器1上面的服务1挂了&lt;br/&gt;在服务器2上启动服务2生成日志2 &lt;br/&gt;如果日志1和日志2有强依赖关系 &lt;br/&gt;那么必须得在服务器1上启动服务1继续在日志1的基础上生成日志&lt;br/&gt;&lt;br/&gt;2、重试漂移&lt;br/&gt;pod如果挂了 再次重启 那么ip就会改变&lt;br/&gt;重试漂移到云上任何节点都没有关系&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;完整流程图&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;这个完整的流程图涵盖了&lt;br/&gt;DNS、CDN、Nginx、FastDFS（或Ceph）、&lt;br/&gt;LVS、ServiceMash、数据收集中心、&lt;br/&gt;注册中心、控制中心、网关、业务逻辑层、&lt;br/&gt;数据访问层、存储层等数据交互过程&lt;br/&gt;&lt;br/&gt;价值不菲 想要的话 &lt;br/&gt;可以添加我微信15900411193&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用链路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3782696177062374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmgLOSWZMwhkiaN5VeySCQn6QUbjIibuHr4MOWQGibSzNlhfuqibGBpyUHCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、做协议解析的目的是兼容老的协议&lt;br/&gt;客户端发出请求后 在客户端service和服务方service要做协议解析&lt;br/&gt;如果都是mesh协议 是不需要协议解析的、协议封装也不需要&lt;br/&gt;2、客户端一定要做序列化、反序列化 这和通讯没啥关系 就是一个数据包&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用方时序图&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1094017094017095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmo2ZqydDFr5mLALib7TFtOxoFyrW4put3x8MzSwP5TpsW6bgLplp3umw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方时序图&lt;br/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4110671936758894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmA6dmticzO1uAO4jXEy5NC7T1wPfmuNmr99yWrOibPd2ic5iaXDKwB1E8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;缓存管理 多个Map:&lt;br/&gt;服务方提供哪些函数调用 通过扫描jar包 反射机制 获取服务提供的类名和方法名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;协议设计&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、Protocol Buffer&lt;br/&gt;2、分割符、版本号、Mesh消息构成&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.19497487437185929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmk1YhLJzQ3xd5E9GbDmX1anKKgIqD6tuiaNG4EQIV52TrWIHF4yXApEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、一次传输协议中有版本号 &lt;br/&gt;比如 版本号1表示rpc协议 &lt;br/&gt;版本号2表示mesh协议&lt;br/&gt;通过版本号可以区分兼容老协议还是新协议&lt;br/&gt;2、多个数据包之间通过头和尾分割符分开&lt;br/&gt;3、分割符占5个字节&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Mesh通讯协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、TCP长连接&lt;br/&gt;2、Http1.1或2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;混合云部署&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、调用方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;2、服务方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;访问流程&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3229689067201605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm20ht2oGM3KHs0CDYics7JXYjRJrPIEYplfbpOYS7zhQ9tgAIXzD1kFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、在服务启动的时候 mesh服务或普通的RPC服务都会去注册中心注册 此时就知道了该节点的服务类型&lt;br/&gt;2、调用方下拉服务信息 也就知道了提供方服务类型 然后选择不同的协议去调用&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小细节&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、熔断放在mesh里面做 不需要业务方参与&lt;br/&gt;2、下游重试次数是一样的 是服务粒度 非接口粒度&lt;br/&gt;3、proxy(mesh)之间做健康检测 是分布式的 一旦发现自己的上游或下游出现了问题 就更新本地的路由表&lt;br/&gt;4、负载均衡算法:Random、RR、Hash(主要用一致性&lt;span&gt;hash&lt;/span&gt;来做)&lt;br/&gt;（RR：(循环负载)&lt;br/&gt;第一次请求路由到第一个节点，&lt;br/&gt;第二次请求路由到第二个节点，&lt;br/&gt;第三次请求路由到第三个节点，&lt;br/&gt;第四次请求路由到第一个节点&lt;br/&gt;....）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构未来&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2平台1中心1趋势&lt;br/&gt;&lt;br/&gt;service mesh平台与业务解耦&lt;br/&gt;容器云弹性平台&lt;br/&gt;服务治理平台(控制中心、注册中心、数据收集中心)&lt;br/&gt;人工智能(AI)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务管理平台的调用关系-数据收集存储方法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方-调用方角度&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4020100502512563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmnp3gibme5rHX7cQxzrJojyic7S72CvWH0Vr24WpDC8RGicKCuQYm2ogaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;服务方:1分钟500万条记录&lt;br/&gt;调用方:50万&lt;br/&gt;共550万&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5426278836509528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0a7lakm422lTyImtA59Vo4GP3nsFjib63vAQQq6uuheS5AhqicIbW6rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案二&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;重复数据提取出来作为元数据&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46598984771573604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm1ficWMZOiaX1GReepHV0qKPibWuE9zpYfhicnJ1a3EhXurnibZ7iaG6jRwWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1970&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案三&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;实际调用流量仅为方案1的1/10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.295959595959596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmMekAzNGwEOiarZTiakpzeibcXlV36Cen0DhAcna6ictLUKddPVBeE4iaVfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;、&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9af65d40078c18311fdf2ec0dc1fc07</guid>
<title>MySQL 读写分离，写完读不到问题如何解决</title>
<link>https://toutiao.io/k/ga340bq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;点击上方&quot;&lt;span&gt;程序员历小冰&lt;/span&gt;&quot;，选择“置顶或者星标”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   你的关注意义重大!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;大家好，我是历小冰。&lt;/p&gt;&lt;p&gt;今天我们来详细了解一下主从同步延迟时读写分离发生写后读不到的问题，依次讲解问题出现的原因，解决策略以及 Sharding-jdbc、MyCat 和 MaxScale 等开源数据库中间件具体的实现方案。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;写后读不到问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;MySQL 经典的一主两从三节点架构是大多数创业公司初期使用的主流数据存储方案之一，主节点处理写操作，两个从节点处理读操作，分摊了主库的压力。&lt;/p&gt;&lt;p&gt;但是，有时候可能会遇到执行完写操作后，立刻去读发现读不到或者读到旧状态的尴尬场景。这是由于主从同步可能存在延迟，在主节点执行完写操作，再去从节点执行读操作，读取了之前旧的状态。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;212&quot; data-backw=&quot;315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2meEfiaicLjLO2lJ4wxqbXVrYWSbsVNKbtVGD7sWEWSpmWovic8PO6SHGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;null&quot; data-ratio=&quot;0.6726677577741408&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图展示了此类问题出现的操作顺序示意图：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;客户端首先通过代理向主节点 Master 进行了写入操作&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;紧接着第二步去从节点 Slave A 执行读操作，此时 Master 和 Slave A 之间的同步还未完成，所以第二步的读操作读取到了旧状态&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;当第五步再次进行读操作时，此时同步已经完成，所以可以从 Slave B 中读取到正确的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面，我们就来看一下为什么会出现此类问题。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;MySQL 主从同步&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;理解问题背后发生的原因，才能更好的解决问题。MySQL 主从复制的过程大致如下图所示，本篇文章只讲解同步过程中的流程，建立同步连接和失联重传不是重点，暂不讲解，感兴趣的同学可以自行了解。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;192&quot; data-backw=&quot;315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2RZaNfJyhe1ic0lHSkrm2xJibd5hImLZnR6Mb8RhtXuZT3RX1qquich41g/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;null&quot; data-ratio=&quot;0.6110019646365422&quot; data-w=&quot;1018&quot;/&gt;&lt;/p&gt;&lt;p&gt;MySQL 主从复制，涉及主从两个节点，一共四个四个线程参与其中：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;主节点的 Client Thread&lt;/em&gt;&lt;span&gt;，处理客户端请求的线程，执行如图所示的1~5步骤，2，3，4步骤是为了保证数据的一致性和尽量减少丢失，第三步骤时会通知 Dump Thread；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;主节点的 Dump Thread&lt;/em&gt;&lt;span&gt;，接收到 Client Thread 通知后，负责读取本地的 binlog 的数据，将 binlog 数据，binlog 文件名 以及当前发送 binlog 的位置信息发送给从节点；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;从节点的 IO Thread&lt;/em&gt;&lt;span&gt; 负责接收 Dump Thread 发送的 binlog 数据和相关位置信息，将其追加到本地的 relay log 等文件中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;从节点的 SQL Thread &lt;/em&gt;&lt;span&gt;检测到 relay log 追加了新数据，则解析其内容(其实就是解析 binlog 文件的内容)为可以执行的 SQL 语句，然后在本地数据执行，并记录下当前执行的 relay log 位置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述是默认的&lt;strong&gt;异步同步模式&lt;/strong&gt;，我们发现，从主节点提交成功到从节点同步完成，中间间隔了6，7，8，9，10多个步骤，涉及到一次网络传输，多次文件读取和写入的磁盘 IO 操作，以及最后的 SQL 执行的 CPU 操作。&lt;/p&gt;&lt;p&gt;所以，当主从节点间网络传输出现问题，或者从节点性能较低时，主从节点间的同步就会出现延迟，导致文章一开始提及的写后读不到的问题。在高并发场景，从节点一般要过几十毫秒，甚至几百毫秒才能读到最新的状态。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;常见的解决策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;一般来讲，大致有如下方案解决写后读不出问题：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;强制走主库&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;判断主备无延迟&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;等主库位点或 GTID 方案&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;强制走主库&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;强制走主库方案最容易理解和实现，它也是最常用的方案。顾名思义，它就是强制让部分必须要读到最新状态的读操作去主节点执行，这样就不会出现写后读不出问题。这种方案问题在于将一部分读压力给了主节点，部分破化了读写分离的目的，&lt;strong&gt;降低了整个系统的扩展性&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;一般主流的数据库中间件都提供了强制走主库的机制，比如，在 sharding-jdbc 中，可以使用 &lt;code&gt;Hint&lt;/code&gt; 来强制路由主库。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2689075630252101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2oiagOfDJ49bloGPlTPTjtVdYRJlhRDyyxVmfBGKswTYU72ToS3BLz1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/p&gt;&lt;p&gt;它的原理就是在 SQL 语句前添加 Hint，然后数据库中间件会识别出 Hint，将其路由到主节点。&lt;/p&gt;&lt;p&gt;下面，我们就来看一下如果要去从库查询，并且要避免过期读的方案，并分析各个方案的优缺点。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;判断主备无延迟&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;第二种方案是使用 show slave status 语句结果中的部分值来判断主从同步的延迟时间：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; show slave status&lt;/span&gt;&lt;br/&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;** 1. row **&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Master_Log_File&lt;/span&gt;: &lt;span&gt;mysql-bin&lt;/span&gt;&lt;span&gt;.001822&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Read_Master_Log_Pos&lt;/span&gt;: 290072815&lt;br/&gt;&lt;span&gt;Seconds_Behind_Master&lt;/span&gt;: 2923&lt;br/&gt;&lt;span&gt;Relay_Master_Log_File&lt;/span&gt;: &lt;span&gt;mysql-bin&lt;/span&gt;&lt;span&gt;.001821&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Exec_Master_Log_Pos&lt;/span&gt;: 256529431&lt;br/&gt;&lt;span&gt;Auto_Position&lt;/span&gt;: 0&lt;br/&gt;&lt;span&gt;Retrieved_Gtid_Set&lt;/span&gt;: &lt;br/&gt;&lt;span&gt;Executed_Gtid_Set&lt;/span&gt;: &lt;br/&gt;.....&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;em&gt;seconds_behind_master&lt;/em&gt;，表示落后主节点秒数，如果此值为0，则表示主从无延迟&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;em&gt;Master_Log_File 和 Read_Master_Log_Pos&lt;/em&gt;，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。如果这两组值相等，则表示主从无延迟&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;em&gt;Auto_Position=1 &lt;/em&gt;，表示使用了 GTID 协议，并且备库收到的所有日志的 GTID 集合 Retrieved_Gtid_Set 和 执行完成的 GTID 集合 Executed_Gtid_Set 相等，则表示主从无延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在进行读操作前，先根据上述方式来判断主从是否有延迟，如果有延迟，则一直等待到无延迟后执行。但是这类方案在判断是否有延迟时存在着假阳和假阴的问题：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;em&gt;判断无延迟，其他延迟了&lt;/em&gt;。因为上述判断是基于从节点的状态，当主节点的 Dump Thread 尚未将最新状态发送给从节点的 IO SQL 时，从节点可能会错误的判断自己和主节点无延迟。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;em&gt;判断有延迟，但是读操作读取的最新状态已经同步&lt;/em&gt;。因为 MySQL 主从复制是一直在进行的，写后直接读的同时可能还有其他无关写操作，虽然主从有延迟，但是对于第一次写操作的同步已经完成，所以读操作已经可以读到最新的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对于第一个问题，需要使用主从复制的 &lt;strong&gt;semi-sync 模式&lt;/strong&gt;，上文中讲解介绍的是默认的异步模式，semi-sync 模式的流程如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;192&quot; data-backw=&quot;315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2ibIBKUVI4VaiaicXkz4gyKT4wjq1aNgKH33tz7vNJicQyBNxb2xqMsFvLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;null&quot; data-ratio=&quot;0.6100196463654224&quot; data-w=&quot;1018&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;当主节点事务提交的时候，Dump Thread 把 binlog 发给从节点；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;从节点的 IO Thread 收到 binlog 以后，发回给主节点一个 ack，表示收到了；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主节点的 Dump Thread &lt;strong&gt;收到这个 ack 以后，再通知 Client Thread &lt;/strong&gt;，此时才能给客户端返回执行成功的响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这样，写操作执行后，就确保从节点已经读取到主节点发送的 binglog 数据，即 Master_Log_File、 Read_Master_Log_Pos 或 Retrieved_Gtid_Set 是最新的，这样才能与执行的相关数据进行对比，判断是否有延迟。&lt;/p&gt;&lt;p&gt;可惜的是，上述 semi-sync 模式只需要等待&lt;strong&gt;一个从节点的&lt;/strong&gt;ACK，所以一主多从的模式该方案将会无效。&lt;/p&gt;&lt;p&gt;虽然该方案有种种问题，但是对于一致性要求不那么高的场景也能适用，比如 MyCat 就是用 seconds_behind_master 是否落后主节点过多，如果超过一定阈值，就将其从有效从节点列表中删除，不再将读请求路由到它身上。&lt;/p&gt;&lt;p&gt;在 MyCAT 的用于监听从节点状态，发送心跳的 MySQLDetector 类中，它会读取从节点的 seconds_behind_master，如果其值大于配置的 slaveThreshold，则将打印日志，并将延迟时间设置到心跳信息中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30851063829787234&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2bCpaHaF4nGq8oGoIwXK43Kibo43PKZhjZesPiaGFZWb4jib9ibN3dvbjxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面，我们就介绍能够解决第二个问题的方案，即判断有延迟，但是读操作读取的特定最新状态已经同步。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;等GTID 方案&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;首先介绍一下 GTID，也就是&lt;strong&gt;全局事务 ID&lt;/strong&gt;，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由MySQL 实例的uuid和一个整数组成，该整数由该实例维护，初始值是 1，每次该实例提交事务后都会加一。&lt;/p&gt;&lt;p&gt;MySQL 提供了一条基于 GTID 的命令，用于在从节点上执行，等待从库同步到了对应的 GTID（binlog文件中会包含 GTID），或者超时返回。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.18969072164948453&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2Kogy4cUU5E98ymJoUdWJW82ib5MuB09dfibKiaXMs2tpWDknYZMmSHGmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;485&quot;/&gt;&lt;/p&gt;&lt;p&gt;MySQL 在执行完事务后，会将该事务的 GTID 会给客户端，然后客户端可以使用该命令去要执行读操作的从库中执行，&lt;strong&gt;等待该 GTID，等待成功后，再执行读操作&lt;/strong&gt;；如果等待超时，则去主库执行读操作，或者再换一个从库执行上述流程。&lt;/p&gt;&lt;p&gt;MariaDB 的 MaxScale 就是使用该方案，MaxScale 是 MariaDB 开发的一个数据库智能代理服务(也支持 MySQL)，允许根据数据库 SQL 语句将请求转向目标一个到多个服务器，可设定各种复杂程度的转向规则。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;169&quot; data-backw=&quot;315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2l2Nyqwc7xFEBTy9d27m03FS82riahRWReAOiaRQlZLyrNGsdq0iaic0TTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;null&quot; data-ratio=&quot;0.535183349851338&quot; data-w=&quot;1009&quot;/&gt;&lt;/p&gt;&lt;p&gt;MaxScale 在其 readwritesplit.hh 头文件和 rwsplit_causal_reads.cc 文件中的 add_prefix_wait_gtid 函数中使用了上述方案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2VwS9ibDT0kiaY4ScQibVhEeKmiagmPIo7p7l0JRyun6vTnFSuq9dkUOmpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.25865580448065173&quot; data-w=&quot;982&quot;/&gt;&lt;/p&gt;&lt;p&gt;举个例子，原来要执行读操作的 SQL 和添加了前缀的 SQL 如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.142578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtfNvZwND62DC6voCNHuomK2gichLKSjWDic8AMibrEZh4D4PgnrF2L1OQFmHVUZMWm0YwjyNHIMibyl3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;当 WAIT_FOR_EXECUTED_GTID_SET 执行失败后，原 SQL 就不会再执行，而是将该 SQL 去主节点执行。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;感觉大家一直读到文末，后续小冰会继续为大家奉上高质量的文章，也希望大家继续关注。&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注我&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5075921908893709&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtehL5KdOC0Uib7CdHkxwGibQdibjs4kC3FpEO9ehCCjHwFa1ZSS8QoEgb9AtomP8cDZmz8jC1gR8qvzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247484555&amp;amp;idx=1&amp;amp;sn=40fb1ea6d3589d1c1ace0dc493488fea&amp;amp;chksm=ce4fc218f9384b0e894a7724ec7daa8acbd4be34977644850635376cf960477f7b0ad9faec90&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一万字详解 Redis Cluster Gossip 协议&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247484616&amp;amp;idx=1&amp;amp;sn=e1b30eff9aee62bc232ef2800534a3dd&amp;amp;chksm=ce4fc25bf9384b4d7b2c63821d441a3b6ef74513c6bb143c1461e23c4c8c7283270d449b8869&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么 ElasticSearch 比 MySQL 更适合复杂条件搜索&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247484468&amp;amp;idx=1&amp;amp;sn=b17568cb7f127543ba752c63577013ce&amp;amp;chksm=ce4fc2a7f9384bb1f072198b01fdea1986e35377cba3481cde874e6367bf0d40996293c0ab68&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL 的 join 功能弱爆了？&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;参考&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt; https://time.geekbang.org/column/article/77636&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;https://www.cnblogs.com/rickiyang/p/13856388.html&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;https://www.cnblogs.com/paul8339/p/7615310.html&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;https://github.com/mariadb-corporation/MaxScale&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n259&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>