<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0d9ae6a3be783c208a9b70b2a093a046</guid>
<title>[译] 新老手必备的 34 种 JavaScript 简写优化技术</title>
<link>https://toutiao.io/k/jdslwhk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://javascript.plainenglish.io/34-javascript-optimization-techniques-to-know-in-2021-d561afdf73c3&lt;br/&gt;作者：Atit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者的生活总是在学习新的东西，跟上变化不应该比现在更难，我的动机是介绍所有JavaScript的最佳实践，比如简写功能，作为一个前端开发者，我们必须知道，让我们的生活在2021年变得更轻松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能做了很长时间的JavaScript开发，但有时你可能没有更新最新的特性，这些特性可以解决你的问题，而不需要做或编写一些额外的代码。这些技术可以帮助您编写干净和优化的JavaScript代码。此外，这些主题可以帮助你为2021年的JavaScript面试做准备。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.如果有多个条件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在数组中存储多个值，并且可以使用数组 &lt;code&gt;include&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x === &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;def&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt; || x ===&lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; ([&lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;def&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;].includes(x)) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.如果为真…否则简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于我们有 &lt;code&gt;if-else&lt;/code&gt; 条件，里面不包含更大的逻辑时，是一个较大的捷径。我们可以简单的使用三元运算符来实现这个简写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test: boolean;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) {&lt;br/&gt;  test = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = (x &amp;gt; &lt;span&gt;10&lt;/span&gt;) ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//or we can use directly&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = x &amp;gt; &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们有嵌套条件时，我们可以采用这种方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;test2 = (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) ? &lt;span&gt;&#x27;greater 100&#x27;&lt;/span&gt; : (x &amp;lt; &lt;span&gt;50&lt;/span&gt;) ? &lt;span&gt;&#x27;less 50&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;between 50 and 100&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// &quot;greater than 100&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.声明变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们要声明两个具有共同值或共同类型的变量时，可以使用此简写形式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Null, Undefined，空检查&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们创建新的变量时，有时我们想检查我们引用的变量的值是否为空或undefined。JavaScript确实有一个非常好的简写工具来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt; || test1 !== &lt;span&gt;undefined&lt;/span&gt; || test1 !== &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; test2 = test1;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.null值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;null check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.undefined值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;undefined check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常值检查&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// output: &#x27;test&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.将值分配给多个变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们处理多个变量并希望将不同的值分配给不同的变量时，此简写技术非常有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2, test3;&lt;br/&gt;test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;test3 = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; [test1, test2, test3] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.赋值运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在编程中处理很多算术运算符，这是将运算符分配给JavaScript变量的有用技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;test1 = test1 + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = test2 - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test3 = test3 * &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;test1++;&lt;br/&gt;test2--;&lt;br/&gt;test3 *= &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.如果存在简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们大家都在使用的常用简写之一，但仍然值得一提。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;true&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;&quot;&quot;&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand //it will check empty string,null and undefined too&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：如果test1有任何值，它将在if循环后进入逻辑，该运算符主要用于 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的检查。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.多个条件的AND（&amp;amp;&amp;amp;）运算符&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果仅在变量为 &lt;code&gt;true&lt;/code&gt; 的情况下才调用函数，则可以使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1) {&lt;br/&gt; callMethod(); &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;test1 &amp;amp;&amp;amp; callMethod();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.foreach循环简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是迭代的常用简写技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; testData.length; i++)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; testData) or  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;of&lt;/span&gt; testData)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个变量的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;testData&lt;/span&gt;(&lt;span&gt;element, index, array&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test[&#x27;&lt;/span&gt; + index + &lt;span&gt;&#x27;] = &#x27;&lt;/span&gt; + element);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;].forEach(testData);&lt;br/&gt;&lt;span&gt;// logs: test[0] = 11, test[1] = 24, test[2] = 32&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.return中比较&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在return语句中使用比较。它将避免我们的5行代码，并将它们减少到1行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!(test === &lt;span&gt;undefined&lt;/span&gt;)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = checkReturn();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data); &lt;span&gt;//output test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;val&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(val);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test || callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.箭头函数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; a + b; &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;}&lt;br/&gt;callMe = &lt;span&gt;&lt;span&gt;name&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.短函数调用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用三元运算符来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; test3 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test3 == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;(test3 === &lt;span&gt;1&lt;/span&gt;? test1:test2)();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. Switch简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将条件保存在键值对象中，并可以根据条件使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;switch&lt;/span&gt; (data) {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;    test1();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;    test2();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;br/&gt;    test();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// And so on...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = {&lt;br/&gt;  &lt;span&gt;1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;3&lt;/span&gt;: test&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;data[something] &amp;amp;&amp;amp; data[something]();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.隐式返回简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用箭头函数，我们可以直接返回值，而不必编写return语句。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;calculate&lt;/span&gt;(&lt;span&gt;diameter&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.PI * diameter&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;calculate = &lt;span&gt;&lt;span&gt;diameter&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;Math&lt;/span&gt;.PI * diameter;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.小数基数指数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) { ... }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1e4&lt;/span&gt;; i++) {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.默认参数值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;test1, test2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test2 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; test1 + test2;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;add = &lt;span&gt;(&lt;span&gt;test1 = &lt;span&gt;1&lt;/span&gt;, test2 = &lt;span&gt;2&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (test1 + test2);&lt;br/&gt;add() &lt;span&gt;//output: 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.扩展运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays using concat&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;].concat(data);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;, ...data];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test); &lt;span&gt;// [ 4, 5, 6, 1, 2, 3]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于克隆，我们也可以使用扩展运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = test1.slice()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = [...test1];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.模板文字&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您厌倦了在单个字符串中使用 &lt;code&gt;+&lt;/code&gt; 来连接多个变量，那么这种简写可以消除您的头痛。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;&#x27;Hi &#x27;&lt;/span&gt; + test1 + &lt;span&gt;&#x27; &#x27;&lt;/span&gt; + test2 + &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;`Hi &lt;span&gt;${test1}&lt;/span&gt; &lt;span&gt;${test2}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.多行字符串简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在代码中处理多行字符串时，可以使用以下功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;&#x27;abc abc abc abc abc abc\n\t&#x27;&lt;/span&gt;&lt;br/&gt;    + &lt;span&gt;&#x27;test test,test test test test\n\t&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;`abc abc abc abc abc abc&lt;br/&gt;         test test,test test test test`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.对象属性分配&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {&lt;span&gt;test1&lt;/span&gt;: test1, &lt;span&gt;test2&lt;/span&gt;: test2}; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {test1, test2};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.将字符串转换成数字&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;parseInt&lt;/span&gt;(&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;parseFloat&lt;/span&gt;(&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = +&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = +&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.用解构简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = &lt;span&gt;this&lt;/span&gt;.data.test1;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test2;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test3;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { test1, test2, test3 } = &lt;span&gt;this&lt;/span&gt;.data;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.用Array.find简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们确实有一个对象数组并且我们想要根据对象属性查找特定对象时，find方法确实很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;]&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;findtest1&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.length; ++i) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (data[i].type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data[i].name === name) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; data[i];&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;filteredData = data.find(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; data.type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data.name === &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(filteredData); &lt;span&gt;// { type: &#x27;test1&#x27;, name: &#x27;fgh&#x27; }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.查找条件简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们有代码来检查类型，根据类型需要调用不同的方法，我们可以选择使用多个else ifs或者switch，但是如果我们有比这更好的简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;) {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test3&#x27;&lt;/span&gt;) {&lt;br/&gt;  test3();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test4&#x27;&lt;/span&gt;) {&lt;br/&gt;  test4();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; types = {&lt;br/&gt;  &lt;span&gt;test1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;test2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;test3&lt;/span&gt;: test3,&lt;br/&gt;  &lt;span&gt;test4&lt;/span&gt;: test4&lt;br/&gt;};&lt;br/&gt; &lt;br/&gt;&lt;span&gt;var&lt;/span&gt; func = types[type];&lt;br/&gt;(!func) &amp;amp;&amp;amp; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type); func();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.按位索引简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们遍历数组以查找特定值时，我们确实使用 &lt;code&gt;indexOf()&lt;/code&gt; 方法，如果找到更好的方法该怎么办？让我们看看这个例子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) &amp;gt; &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item found &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) === &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(~arr.indexOf(item)) { &lt;span&gt;// item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!~arr.indexOf(item)) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按位（&lt;code&gt;〜&lt;/code&gt;）运算符将返回除-1以外的任何值的真实值。否定它就像做 &lt;code&gt;~~&lt;/code&gt; 一样简单。另外，我们也可以使用 &lt;code&gt;include()&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (arr.includes(item)) { &lt;br/&gt;&lt;span&gt;// true if the item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.Object.entries()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此函数有助于将对象转换为对象数组。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;, &lt;span&gt;test3&lt;/span&gt;: &lt;span&gt;&#x27;efg&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.entries(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ [ &#x27;test1&#x27;, &#x27;abc&#x27; ],&lt;br/&gt;  [ &#x27;test2&#x27;, &#x27;cde&#x27; ],&lt;br/&gt;  [ &#x27;test3&#x27;, &#x27;efg&#x27; ]&lt;br/&gt;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.Object.values()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是ES8中引入的一项新功能，该功能执行与 &lt;code&gt;Object.entries()&lt;/code&gt; 类似的功能，但没有关键部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.values(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ &#x27;abc&#x27;, &#x27;cde&#x27;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.双按位简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重NOT按位运算符方法仅适用于32位整数）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;1.9&lt;/span&gt;) === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;~~&lt;span&gt;1.9&lt;/span&gt; === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.重复一个字符串多次&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要一次又一次地重复相同的字符，我们可以使用for循环并将它们添加到同一循环中，但是如果我们有一个简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i ++) { &lt;br/&gt;  test += &lt;span&gt;&#x27;test &#x27;&lt;/span&gt;; &lt;br/&gt;} &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(str); &lt;span&gt;// test test test test test &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&#x27;test &#x27;&lt;/span&gt;.repeat(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.在数组中查找最大值和最小值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]; &lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.max(…arr); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.min(…arr); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.从字符串中获取字符&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str = &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;str.charAt(&lt;span&gt;2&lt;/span&gt;); &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;Note: If we know the index &lt;span&gt;of&lt;/span&gt; the array then we can directly use index insted &lt;span&gt;of&lt;/span&gt; character.If we are not sure about index it can &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;str[&lt;span&gt;2&lt;/span&gt;]; &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.数学指数幂函数的简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.pow(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;); &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;**&lt;span&gt;3&lt;/span&gt; &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c03d3839044e1943bb937ed4509e556</guid>
<title>浅谈数仓、数仓模型分层</title>
<link>https://toutiao.io/k/151twp1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content post-body&quot;&gt;&lt;p&gt;数据分层是数仓模型设计中十分重要的环节，优秀的分层设计能够让整个数据体系更易理解和使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studytime.xin/article/20210312000046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数仓分层意义&quot;&gt;&lt;a href=&quot;#数仓分层意义&quot; class=&quot;headerlink&quot; title=&quot;数仓分层意义&quot;/&gt;数仓分层意义&lt;/h3&gt;&lt;p&gt;  数仓分层目的是使用空间换时间，通过大量预处理，提升用户数据加工效率等，故而存在大量数据冗余。如果不分层，源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大。&lt;/p&gt;
&lt;p&gt;  通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。&lt;/p&gt;
&lt;p&gt;综上所述数据分层将可以给我们带来如下的好处：&lt;br/&gt;1、清晰数据结构：每一个数据分层都有它的作用域和职责，在使用表的时候能更方便地定位和理解&lt;br/&gt;2、减少重复开发：规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算&lt;br/&gt;3、统一数据口径：通过数据分层，提供统一的数据出口，统一对外输出的数据口径&lt;br/&gt;4、复杂问题简单化：将一个复杂的任务分解成多个步骤来完成，每一层解决特定的问题&lt;/p&gt;
&lt;h3 id=&quot;通用可行的数仓分层设计方案&quot;&gt;&lt;a href=&quot;#通用可行的数仓分层设计方案&quot; class=&quot;headerlink&quot; title=&quot;通用可行的数仓分层设计方案&quot;/&gt;通用可行的数仓分层设计方案&lt;/h3&gt;&lt;p&gt;为了满足前面提到数据分层带来的好处，建议将数据模型分为三层：基础数据层（ ODS、STG ）、公共维度模型层（CDM或EDW）和数据应用层（ADS）。如下图所示。简单来讲，我们可以理解为：基础数据层存放的是接入的原始数据，DW层是存放我们要重点设计的数据仓库中间层数据，数据应用层是面向业务定制的应用数据。&lt;/p&gt;
&lt;h3 id=&quot;基础数据层&quot;&gt;&lt;a href=&quot;#基础数据层&quot; class=&quot;headerlink&quot; title=&quot;基础数据层&quot;/&gt;基础数据层&lt;/h3&gt;&lt;p&gt;包含 STG（数据缓冲层）与 ODS（原始数据层）两层，这两层数据结构与业务数据几乎一致。&lt;/p&gt;
&lt;h4 id=&quot;STG-数据准备区或数据缓冲区&quot;&gt;&lt;a href=&quot;#STG-数据准备区或数据缓冲区&quot; class=&quot;headerlink&quot; title=&quot;STG 数据准备区或数据缓冲区&quot;/&gt;STG 数据准备区或数据缓冲区&lt;/h4&gt;&lt;p&gt;定位是缓存来自 DB 抽取、消息、日志解析落地的临时数据，结构与业务系统保持一致；负责对垃圾数据、不规范数据进行清洗转换；该层除为ODS 层服务外，不提供服务，也就是不能被其他更上层次调用。&lt;/p&gt;
&lt;h4 id=&quot;ODS原始数据层或操作数据层&quot;&gt;&lt;a href=&quot;#ODS原始数据层或操作数据层&quot; class=&quot;headerlink&quot; title=&quot;ODS原始数据层或操作数据层&quot;/&gt;ODS原始数据层或操作数据层&lt;/h4&gt;&lt;p&gt;操作数据层定位于业务明细数据保留区，负责保留数据接入时点后历史变更数据，数据原则上全量保留。可以在此层对增量数据或者拉链表数据进行合并。&lt;/p&gt;
&lt;h3 id=&quot;公共维度模型层CDM（Common-Data-Model）或者-企业级数据仓库EDW-（Enterprise-Data-Warehouse）&quot;&gt;&lt;a href=&quot;#公共维度模型层CDM（Common-Data-Model）或者-企业级数据仓库EDW-（Enterprise-Data-Warehouse）&quot; class=&quot;headerlink&quot; title=&quot;公共维度模型层CDM（Common Data Model）或者 企业级数据仓库EDW （Enterprise Data Warehouse）&quot;/&gt;公共维度模型层CDM（Common Data Model）或者 企业级数据仓库EDW （Enterprise Data Warehouse）&lt;/h3&gt;&lt;p&gt;公共维度模型层主要用于存放明细事实数据、维表数据及公共指标汇总数据，其中明细事实数据、维表数据一般根据ODS层数据加工生成；公共指标汇总数据一般根据维表数据和明细事实数据加工生成。本层采用维度模型作为建模方法的理论基础，更多的是通过采用一些维度退化手段，将维度退化至事实表中，减少维表和事实表的关联，提高数据易用性。&lt;/p&gt;
&lt;h4 id=&quot;明细数据层：DWD（Data-Warehouse-Detail）&quot;&gt;&lt;a href=&quot;#明细数据层：DWD（Data-Warehouse-Detail）&quot; class=&quot;headerlink&quot; title=&quot;明细数据层：DWD（Data Warehouse Detail）&quot;/&gt;明细数据层：DWD（Data Warehouse Detail）&lt;/h4&gt;&lt;p&gt;该层一般保持和ODS层一样的数据粒度，并且提供一定的数据质量保证。同时，为了提高数据明细层的易用性，该层会采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联。同时在此层会采用明细宽表，复用关联计算，极少数据扫描。举例：订单主表以及订单明细表，可以以订单明细表作为最小粒度，连表整合订单表数据，生成dwd层订单事实表。&lt;/p&gt;
&lt;h4 id=&quot;数据汇总层：DWS（Data-WareHouse-Summary）&quot;&gt;&lt;a href=&quot;#数据汇总层：DWS（Data-WareHouse-Summary）&quot; class=&quot;headerlink&quot; title=&quot;数据汇总层：DWS（Data WareHouse Summary）&quot;/&gt;数据汇总层：DWS（Data WareHouse Summary）&lt;/h4&gt;&lt;p&gt;该层会在DWD层的数据基础上，对数据做轻度的聚合操作，生成一系列的中间表，提升公共指标的复用性，减少重复加工。直观来讲，就是对通用的核心维度进行聚合操作，算出相应的统计指标。&lt;/p&gt;
&lt;h3 id=&quot;公共维度模型层CDM主要作用&quot;&gt;&lt;a href=&quot;#公共维度模型层CDM主要作用&quot; class=&quot;headerlink&quot; title=&quot;公共维度模型层CDM主要作用&quot;/&gt;公共维度模型层CDM主要作用&lt;/h3&gt;&lt;p&gt;1、组合相关和相识数据，采用明细宽表，复用关联计算，减少数据扫描&lt;br/&gt;2、公共指标统一加工，为上层数据产品应用，服务提供公共指标，建立逻辑汇总宽表&lt;br/&gt;3、建立一致性维度，一致性的数据分析维度，降低数据计算口径，解决算法不同意的风险&lt;/p&gt;
&lt;h3 id=&quot;应⽤层-ADS（Application-Data-Mart-应⽤数据集市）&quot;&gt;&lt;a href=&quot;#应⽤层-ADS（Application-Data-Mart-应⽤数据集市）&quot; class=&quot;headerlink&quot; title=&quot;应⽤层 ADS（Application Data Mart-应⽤数据集市）&quot;/&gt;应⽤层 ADS（Application Data Mart-应⽤数据集市）&lt;/h3&gt;&lt;p&gt;数据应用层，也叫DM(数据集市)或APP层等，面试实际的数据需求，可以直接给业务人员使用，以DWD或者DWS层的数据为基础，组成各种统计报表。除此之外还有一些直接的表现形式，例如主题大宽度表集市，以及横表转纵表等。&lt;/p&gt;
&lt;h4 id=&quot;宽表&quot;&gt;&lt;a href=&quot;#宽表&quot; class=&quot;headerlink&quot; title=&quot;宽表&quot;/&gt;宽表&lt;/h4&gt;&lt;p&gt;宽表这块我的理解是，基于维度模型的扩展，采用退化维度的方式，将不同维度的度量放入数据表的不同列中，同时将于主分析维度相关的指标进行整合，更利于理解，以及较好的查询性能。&lt;/p&gt;
&lt;p&gt;宽表物理设计结构：&lt;br/&gt;1、基本属性&lt;br/&gt;2、日行为汇总指标&lt;br/&gt;3、周期行为汇总指标&lt;br/&gt;4、历史累计属性和指标&lt;/p&gt;
&lt;h3 id=&quot;思考和总结一下&quot;&gt;&lt;a href=&quot;#思考和总结一下&quot; class=&quot;headerlink&quot; title=&quot;思考和总结一下&quot;/&gt;思考和总结一下&lt;/h3&gt;&lt;p&gt;从数据应用理解上来讲，目的是希望越上层次，对使用者约友好。比如ADS层，基本是完全为应用来设计的，很易懂，DWS层的话，相对来讲就会有一点点理解成本，然后DWD层就比较难理解了，因为它的维度可能会比较多，而且一个需求可能要多张表经过很复杂的计算才能完成。&lt;/p&gt;
&lt;p&gt;从能力范围来讲，我们希望80%需求由20%的表来支持。直接点讲，就是大部分（80%以上）的需求，都用DWS的表来支持就行，DWS支持不了的，就用DWD的表来支持，这些都支持不了的极少一部分数据需要从原始日志中后去。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e9c6e5993f13c953bc9d741fed3c08ec</guid>
<title>史上超强拷贝仓：GitHub 热点速览 v.21.11</title>
<link>https://toutiao.io/k/8ku8lte</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRw88W5VXbJr8T0DQFVjRGaEa1YClm5qKkkYz68aGSTva9VZuCw6zugQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Clone-Wars 是真的强，能细数 70+ 知名应用网站的源码，即便你不看代码，也可以了解下各大网站的所用技术栈。同样很强的是用 OpenCV 实现的图片转 csv 文件的 image2csv。而作为开源的认证和授权服务器的 authelia 也很强，和反向代理们搭档，拦截不可靠的 Query 查询，保证数据安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CR1qO6BrLhwogFmy9Aia31TtJVRIKMdTKauzpK4zKOHFX6NIwicurVAfOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4124087591240876&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始本周的特推之前，如果你有什么想要的 GitHub 项目，记得留言呀~你的留言超重要 (≧▽≦)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 图片转 csv 文件：image2csv&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;New&lt;/code&gt; image2csv 是一个提取图片中的数据信息生成 csv 文件的小工具。它用 OpenCV 做图片处理，Tesseract 识别图片中数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/artperrin/image2csv&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRWP3ku0s3IYvkABkKqibicUV6C8HP0IYstHic9OfPrRFXLspEcOFMEzWnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 史上最强拷贝仓：Clone-Wars&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：3,300+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;New&lt;/code&gt; Clone-Wars 收录了 70+ 国内外知名网站的 Clone 版，诸如 Airbnb、Amazon、Instagram、Netflix、Tiktok、Spotify 等等，并注明了各个网站使用了什么技术栈，可以说是一个十分优秀的技术学习项目了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/GorvGoyl/Clone-Wars&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CROODEkVxp1iaWevic1N4NfcDWtl34K75O4LRRghm3zaCT3syBIHbxIZqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.525&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 单点登录守卫：authelia&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,850+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Authelia 是一个开源的认证和授权服务器，通过 Web Portal 为应用程序提供双重认证和单点登录（SSO）。作为反向代理 (如 Nginx、Traefik 或 HAProxy) 的好搭档，Authelia 让它反向代理们知道 Query 是否应该通过，而未经身份验证的用户将被重定向到 Authelia 登录界面。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/authelia/authelia&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRtLkvpBntEzMQsSVJgNR6BeK41ojNqqRx2lYE4aLxNFztUL5ZGZicHTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.46131805157593125&quot; data-w=&quot;698&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Flutter 聊天应用：Chat-Messaging-App-Light-and-Dark-Theme&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;New&lt;/code&gt; Chat-Messaging-App-Light-and-Dark-Theme 是一个用 Flutter 开发的聊天应用，支持 Dark 和 Light 模式的无缝切换。通过这个项目，你可以学到如何制作一个支持文字、语音、视频的聊天应用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/abuanwar072/Chat-Messaging-App-Light-and-Dark-Theme&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CR457EdMHVscecjxYp3sId3W2jchusnNSXmZPBLdJCAYfEIBicUk5mGjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5625&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 敏感信息扫描工具：apkleaks&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;apkleaks 是个 APK 文件敏感信息扫描工具，它会扫描 APK 来获取 URI、端点和 secret。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/dwisiswant0/apkleaks&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CRS6TECPFUg4e8zdlIEHF9DN6hqLBFxr4e2vPrPnKqVKuZjw1GwnNylw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5861111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 新型 shell：nushell&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：950+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nushell 是一个新型的 shell，由 Rust 编写而成。相比传统 shell，它提供了更全面的信息，且它内置了一组命令。如果一个命令是未知的，该命令将退出 shell 并执行它 (在 Windows 上使用 cmd，或在 Linux 和 macOS 上使用 bash)，正确地传递 &lt;code&gt;stdin&lt;/code&gt;、&lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt;，以便 git 工作流 / vim 可以正常运行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/nushell/nushell&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNNoMXlqibETY6839Etw3X7CR6WEg6bTDddrSGC27m2CrXDeUlX3WuOx1OXlzw7nw1noeoOenBYB8Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1610&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 深度学习资料：d2l-zh&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,250+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;d2l-zh 是《动手学深度学习》教程，读者可从中了解概念、背景知识和代码，而项目作者也在资料中阐述剖析问题所需的批判性思维、解决问题所需的数学知识，以及实现解决方案所需的工程技能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/d2l-ai/d2l-zh&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNNoMXlqibETY6839Etw3X7CROTzsvXFETmNrxGevB0zM7YpDCpch84vUWeSdAWSTQAlpkwA64qgryg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.7666666666666667&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：量化交易，AI 换头等等。👀 和之前的送书活动类似，留言点赞 Top5 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上为 2021 年第 11 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆「点击关注」&lt;/span&gt;&lt;/strong&gt;更多惊喜等待你！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb9173e91ccb4fc2a699159b40e7dba1</guid>
<title>2021 技术展望 | 弱网下的极限实时视频通信</title>
<link>https://toutiao.io/k/rmj15hr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-id=&quot;97593&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.2173913043478262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhVhBh7lXTUQjb9RB9yUXdaI7w6QTR2qEapYicGVn4elicdQI3yB1ricQhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;23&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;线上会议、在线教育、电商直播等多个场景的兴起，也使得实时互动技术从幕后走到台前，得到了更多人的关注。编解码、网络传输、计算机视觉等 RTE 相关的一系列技术也正焕发出更强的生命力。2021 年，在深度学习、5G 等技术的加持下，RTE 会进一步催生哪些可能？&lt;br/&gt;&lt;br/&gt;声网Agora 开发者社区联合 InfoQ 共同策划，邀请了声网Agora 开发者社区中的多位技术专家，从视频传输、计算机视觉、编解码标准发展、WebRTC、机器学习、音频技术等角度，共同撰写「2021 实时互动技术展望系列」，一窥技术新趋势。&lt;strong&gt;&lt;span&gt;本文作者，南京大学陈浩、马展、刘浩杰。本系列内容由声网 Agora 开发者社区 与 InfoQ 联合策划，并由 InfoQ 审校，&lt;strong&gt;&lt;span&gt;首发于 InfoQ&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;实时视频通信已然成为当前互联网应用的亮点。特别在这疫情期间，全球都在“被隔离”，无法开展线下活动，更加迫切的需要以实时视频通信为技术支撑的各种虚拟线上交流。在可见的数年内，稳定高质量的互联网实时视频通信是各行各业的迫切需求，协同复工复产，帮助经济恢复；当用户习惯逐渐养成，实时视频通信又将成为生产生活的基本配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;从应用的角度看，用户对服务的需求和网络基础设施永远是一对不可调和的矛盾。以实时视频通信为例，我们永远无法保证网络的全时稳定，弱网环境长期存在，特别在很多关乎到生活、生产乃至生命的关键时刻，通信网络往往受到极大的物理条件限制，如海事作业、应急救灾、高并发场景等。因此我们更加需要探索新理论新方法来有效的分析、精准的建模、准确的预判，以期实现弱网极限环境下（如极低带宽 &amp;lt;50kbps, 极不稳定网络抖动，极大时延等）的高质量实时视频通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;过去的 5 年，我们南京大学电子学院团队在实时视频通信下做了一系列的探索工作，搭建了以互联网云游戏/云 VR 为应用的实时视频通信平台（&lt;/span&gt;&lt;span&gt;https://www.anygame.info/&lt;/span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;），嵌入人工智能（AI）方法驱动自适应网络带宽调节和端到端用户体验优化。目前，该平台依然每天支持数百上千名用户实时操作，也帮助我们持续优化和更新，覆盖更多的应用场景。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;近期乃至未来，我们认为实时视频通信的核心问题还未得到解决，特别是弱网下的高质量保证，而这些 corner case 往往是服务水平的直观体现。面对弱网的各种限制，我们提出极限实时视频通信：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;第一次尝试实现全链路 AI 控制（包括编码和传输）&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;从 AlphaGo 开始，强化学习在任务决策方面展现了非凡的能力；三年前，我们提出基于强化学习的网络流控，自适应侦测调节带宽反馈给发送方优化视频压缩；这样的过程虽然带来了可见的效果，但是并没有真的解决网络流控和视频压缩流控的核心矛盾；网络流控的难点在于异构性，视频压缩的流控难点是内容多样性。近期，我们将强化学习的决策机制同时涵盖编码和传输，全链路 AI 控制（状态采集，决策预判），实现更加精准的带宽控制；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;基于 IP 的分组交换网络在视频传输网络中占据主导地位，使得端到端网络的吞吐量、延迟等状态具有很高的时变性，并且在不同的用户之间由于网络资源竞争使得这些网络状态随时间动态波动。另一方面，由于实时视频通信要求的苛刻时延和视频内容复杂度差异，难以实现良好的码率控制。这使得难以通过对网路和内容建模生成统一、固定规则的码率自适应算法。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;受人类行为决策思想启发，我们引入强化学习理论和工具，综合考虑视频编码与网络传输端到端流程，提出了基于强化学习的全链路网络流控，其系统框图如图 1 所示。智能体首先观察以往实时视频通信会话的经验，即从视频编码器和接收端收集的编码状态、网络和播放状态，使用神经网络挖掘编码和传输过程中视频内容和网络的潜在特征，并做出编码参数设置的决策。视频应用程序的发送端基于该决策编码和传输视频，在接收端进行解码播放后，产生新的状态，同时向智能体反馈当前决策的奖励。基于此奖励信号，智能体以最大化累积奖励为目标不断更新神经网络参数。最终，我们仅通过观察和学习编码、网络和播放的原始状态，对视频编码参数进行自适应调整，有效对抗网络波动的同时，有效提升用户体验质量（Quality of Experience, QoE）。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5206270627062707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPP3z7TwDYR1d02C5TjOdL9OLRfdc5rOc8hEfAsORcicokwdwvVOcp3TpA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1212&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 1 基于强化学习的全链路网络流控示意图&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为评估基于强化学习的全链路网络流控的性能，我们选取当前先进的谷歌拥塞控制（Google Congestion Control，GCC）和瓶颈带宽与往返时延（Bottleneck Bandwidth and Round-trip time，BBR）算法进行了对比实验，结果如图 2 所示。可以看出，相对于 GCC 和 BBR 算法，我们可以提升分别 3.6%和 27.9%的归一化平均 QoE 分数。其中，我们以所有测试样本取得 QoE 的最小值与最大值进行归一化处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.631578947368421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPPtoMJDmR8uD6pz3VUa0TJTWBJZudFdHITDy3plZ3SZ3ZsWss7Vx4fVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;456&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 2 基于强化学习的全链路网络流控性能评估&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;引入网络多模态感知进行在线建模和推理&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;用户很难预判网络的好坏。网络的异构性让这个问题变得极为艰难。从医疗大样本数据分析推理得到启发，我们引入网络多模态感知，梳理网络的不同规则，应用在线建模逐步完善，覆盖各种网络情况。针对不同的网络情况应用对应的网络模型实现大幅性能提升；&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;对于实时视频通信场景，用于承载视频流的接入网络除了时变特性以外，还往往具备高度的异构性，如蜂窝链路（3G/4G/5G）、WiFi 无线链路、光纤链路等形态，这些接入网络具有不同的带宽、延迟和缓冲容量。此外，用户使用网络的环境也复杂多样，包括静止、步行、乘汽车、乘高铁等使用环境，使得带宽、延迟等网络特性动态改变，网络波动频繁。单一学习模型的性能往往难以覆盖如此复杂、异构的网络环境。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为此，我们引入了网络多模态感知进行在线建模和推理，其系统框图如图 3 所示。发送端经过视频获取、视频编码和视频流化等处理后将视频流发送到网络上，接收端接收视频数据进行解码和播放等操作，并收集网络状况和视频播放情况相关数据。为减小码率决策时延，我们将网路模态感知、码率自适应和在线建模与推理模块部署在接收端。首先，通过分析和挖掘历史网络状态特征，识别当前网络模态，初步感知整体网络质量情况。之后，使用基于强化学习理论的多模态码率自适应，依据网络模态动态切换码率自适应模型，从而针对不同网络状况精细化生成不同的码率自适应决策算法。在实际新网络环境下，基于多模态码率自适应模型应用在线建模和推理，进一步面向当前环境更新和优化模型和算法，解决新环境下模型性能退化问题。一次码率决策完成后，接收到通知和指导发送端的视频编码和视频流化模块对编码码率和发送码率进行调整，以抵抗动态网络波动。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3649407361197754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPPvKoibibzzXeicwXibk9W0I3Cl7jD7uw8e3wjtkotRaf6Lb7J3QDGniaKzaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1603&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 3 网络多模态感知进行在线建模和推理系统框图&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;鉴于图 2 中 BBR 性能差于 GCC，我们选取 GCC 算法作为评估网络多模态感知进行在线建模和推理性能的对比对象，结果如图 4 所示。对比于 GCC 算法，多模态码率自适应模型可以提升 9.1%归一化平均 QoE。其中，我们以测试样本取得 QoE 的最小值与最大值进行归一化处理。在线建模与推理方法相对于 GCC 算法，能够提升约 15.1%归一化平均 QoE，并且在训练时也达到相对稳定和可接受的码率自适应性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6541019955654102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPP3qouFuXJcH0jIFMRycoVJTGzXxPH5j7VPicSr5GV7cwHjiajDhPmqhjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;451&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 4 网络多模态感知进行在线建模和推理性能评估&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;强化网络主动决策&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;在网络状态变差的时候，视频传输总会丢包；目前策略是 FEC 或者重传。无论哪一种方式都让网络更拥塞。从另外一个角度看，视频内容具备很强时空一致性（Spatiotemporal Coherency)；因此，与其进行保护，不如直接有选择的丢弃，后期利用时空一致性进行补偿。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;为此，我们引入了智能时空预测补偿模块，通过联合多帧视频时空相关一致性来在解码端直接重建丢弃的视频帧，其系统框图如图 5 所示。接收端经过视频解码得到一系列时空相关的视频解码帧，这些视频帧在编码端编码过程中已通过有选择的丢弃，来确保已存在的视频解码帧有很强的时空一致性来对丢弃帧进行恢复。智能时空预测补偿模型能根据输入的解码视频帧构造一个非线性的二阶预测模型，该模型利用了物理概念对运动进行二阶建模，结合非线性的神经网络模型更好地预测丢失视频帧。模型可基于接收到的视频解码帧，有选择地采用直接法和引导法，对不同运动特性和场景的视频进行分区域多重运动补偿，重建丢失的视频帧。此外，为了获得极高的视觉流畅度，我们在重建过程中引入了时空一致性的约束，使得重建的视频序列得到极高的视频时空流畅度，基本上在视觉感知不变的情况下，通过主动丢包可以大幅降低网络压力，保证流畅服务。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.33605600933488916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBH5JImU3vtHm7ZwzplH6qPPFynVVpibNtgueYAQicZof1wXQQGgW6UyfvyPWbVDQibFiaBQhzabRdhTUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-align-center=&quot;&quot; data-type=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;图 5 智能时空预测补偿模块&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;通过上述三个方面的创新，我们实现了 50kbps 下的高质量视频实时通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;作者介绍：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;马展，教授，南京大学, &lt;/span&gt;&lt;span&gt;mazhan@nju.edu.cn&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;刘浩杰，博士生，南京大学, &lt;/span&gt;&lt;span&gt;haojie@smail.nju.edu.cn&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span data-name=&quot;user&quot; data-type=&quot;color&quot;&gt;陈浩，副研究员，南京大学, &lt;/span&gt;&lt;span&gt;chenhao1210@nju.edu.cn&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87704&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-bcless=&quot;darken&quot; data-bclessp=&quot;20%&quot; data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span data-brushtype=&quot;text&quot;&gt;本系列相关阅读&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span hm_fix=&quot;313:362&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNzA1OTA2OQ==&amp;amp;mid=2657215253&amp;amp;idx=1&amp;amp;sn=9ec7f2da59954dfd040e97c8264c8248&amp;amp;chksm=8c8d6207bbfaeb110ff8a12cdf4ffc3be6be22cf9bb6c622803263326094ba4e2e0057a4f581&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2021 技术展望 | 走向未来的实时生成技术&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2021 技术展望 | 走向未来的实时生成技术&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3037037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBEHqOZjJmEPvV8JHfEDRRkq4aQIgGKpLLGE7KUcBVJVMhkRibEKbYLzKkOYzMbia7B90GEslXrkCYUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5528bb7cfea6f08f64de6fa8a7569b3</guid>
<title>Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</title>
<link>https://toutiao.io/k/vsxwjpf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;Redis是目前广为人知的一个内存数据库，在各个场景中都有着非常丰富的应用，前段时间Redis推出了6.0的版本，在新版本中采用了多线程模型。&lt;/p&gt;
&lt;p&gt;因为我们公司使用的内存数据库是自研的，按理说我对Redis的关注其实并不算多，但是因为Redis用的比较广泛，所以我需要了解一下这样方便我进行面试。&lt;/p&gt;
&lt;p&gt;总不能候选人用过Redis，但是我非要问人家阿里的Tair是怎么回事吧。&lt;/p&gt;
&lt;p&gt;所以，在Redis 6.0 推出之后，我想去了解下为什么采用多线程，现在采用的多线程和以前版本有什么区别？为什么这么晚才使用多线程？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis不是已经采用了多路复用技术吗？不是号称很高的性能了吗？为啥还要采用多线程模型呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文就来分析下这些问题以及背后的思考。&lt;/p&gt;
&lt;h3&gt;Redis为什么最开始被设计成单线程的？&lt;/h3&gt;
&lt;p&gt;Redis作为一个成熟的分布式缓存框架，它由很多个模块组成，如网络请求模块、索引模块、存储模块、高可用集群支撑模块、数据操作模块等。&lt;/p&gt;
&lt;p&gt;很多人说Redis是单线程的，就认为Redis中所有模块的操作都是单线程的，其实这是不对的。&lt;/p&gt;
&lt;p&gt;我们所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，&lt;strong&gt;Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以说，Redis中并不是没有多线程模型的，早在Redis 4.0的时候就已经针对部分命令做了多线程化。&lt;/p&gt;
&lt;p&gt;那么，为什么网络操作模块和数据存储模块最初并没有使用多线程呢？&lt;/p&gt;
&lt;p&gt;这个问题的答案比较简单！因为：”没必要！”&lt;/p&gt;
&lt;p&gt;为什么没必要呢？我们先来说一下，什么情况下要使用多线程？&lt;/p&gt;
&lt;h4&gt;多线程适用场景&lt;/h4&gt;
&lt;p&gt;一个计算机程序在执行的过程中，主要需要进行两种操作分别是读写操作和计算操作。&lt;/p&gt;
&lt;p&gt;其中读写操作主要是涉及到的就是I/O操作，其中包括网络I/O和磁盘I/O。计算操作主要涉及到CPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而多线程的目的，就是通过并发的方式来提升I/O的利用率和CPU的利用率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，Redis需不需要通过多线程的方式来提升提升I/O的利用率和CPU的利用率呢？&lt;/p&gt;
&lt;p&gt;首先，我们可以肯定的说，Redis不需要提升CPU利用率，因为&lt;strong&gt;Redis的操作基本都是基于内存的，CPU资源根本就不是Redis的性能瓶颈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，通过多线程技术来提升Redis的CPU利用率这一点是完全没必要的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，使用多线程技术来提升Redis的I/O利用率呢？是不是有必要呢？&lt;/p&gt;
&lt;p&gt;Redis确实是一个I/O操作密集的框架，他的数据操作过程中，会有大量的网络I/O和磁盘I/O的发生。要想提升Redis的性能，是一定要提升Redis的I/O利用率的，这一点毋庸置疑。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;提升I/O利用率，并不是只有采用多线程技术这一条路可以走！&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;多线程的弊端&lt;/h4&gt;
&lt;p&gt;我们在很多文章中介绍过一些Java中的多线程技术，如内存模型、锁、CAS等，这些都是Java中提供的一些在多线程情况下保证线程安全的技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程安全：是编程中的术语，指某个函数、函数库在并发环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和Java类似，所有支持多线程的编程语言或者框架，都不得不面对的一个问题，那就是如何解决多线程编程模式带来的共享资源的并发控制问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然，采用多线程可以帮助我们提升CPU和I/O的利用率，但是多线程带来的并发问题也给这些语言和框架带来了更多的复杂性。而且，多线程模型中，多个线程的互相切换也会带来一定的性能开销。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在提升I/O利用率这个方面上，Redis并没有采用多线程技术，而是选择了&lt;strong&gt;多路复用 I/O&lt;/strong&gt;技术。&lt;/p&gt;
&lt;h4&gt;小结&lt;/h4&gt;
&lt;p&gt;Redis并没有在网络请求模块和数据操作模块中使用多线程模型，主要是基于以下四个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、Redis 操作基于内存，绝大多数操作的性能瓶颈不在 CPU&lt;/li&gt;
&lt;li&gt;2、使用单线程模型，可维护性更高，开发，调试和维护的成本更低&lt;/li&gt;
&lt;li&gt;3、单线程模型，避免了线程间切换带来的性能开销&lt;/li&gt;
&lt;li&gt;4、在单线程中使用多路复用 I/O技术也能提升Redis的I/O利用率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还是要记住：Redis并不是完全单线程的，只是有关键的网络IO和键值对读写是由一个线程完成的。&lt;/p&gt;
&lt;h3&gt;Redis的多路复用&lt;/h3&gt;
&lt;p&gt;多路复用这个词，相信很多人都不陌生。我之前的很多文章中也够提到过这个词。&lt;/p&gt;
&lt;p&gt;其中在介绍Linux IO模型的时候我们提到过它、在介绍HTTP/2的原理的时候，我们也提到过他。&lt;/p&gt;
&lt;p&gt;那么，Redis的多路复用技术和我们之前介绍的又有什么区别呢？&lt;/p&gt;
&lt;p&gt;这里先讲讲&lt;strong&gt;Linux多路复用技术，就是多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157036192280.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;多看一遍上面这张图和上面那句话，后面可能还会用得到。&lt;/p&gt;
&lt;p&gt;也就是说，通过一个线程来处理多个IO流。&lt;/p&gt;
&lt;p&gt;IO多路复用在Linux下包括了三种，select、poll、epoll，抽象来看，他们功能是类似的，但具体细节各有不同。&lt;/p&gt;
&lt;p&gt;其实，Redis的IO多路复用程序的所有功能都是通过包装操作系统的IO多路复用函数库来实现的。每个IO多路复用函数库在Redis源码中都有对应的一个单独的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157004365080.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;在Redis 中，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157003905528.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。&lt;/p&gt;
&lt;p&gt;所以，Redis选择使用多路复用IO技术来提升I/O利用率。&lt;/p&gt;
&lt;p&gt;而之所以Redis能够有这么高的性能，不仅仅和采用多路复用技术和单线程有关，此外还有以下几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、数据结构简单，对数据操作也简单，如哈希表、跳表都有很高的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、使用多路I/O复用模型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;为什么Redis 6.0 引入多线程&lt;/h3&gt;
&lt;p&gt;2020年5月份，Redis正式推出了6.0版本，这个版本中有很多重要的新特性，其中多线程特性引起了广泛关注。&lt;/p&gt;
&lt;p&gt;但是，需要提醒大家的是，&lt;strong&gt;Redis 6.0中的多线程，也只是针对处理网络请求过程采用了多线程，而数据的读写命令，仍然是单线程处理的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，不知道会不会有人有这样的疑问：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis不是号称单线程也有很高的性能么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是说多路复用技术已经大大的提升了IO利用率了么，为啥还需要多线程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是因为我们对Redis有着更高的要求。&lt;/p&gt;
&lt;p&gt;根据测算，Redis 将所有数据放在内存中，内存的响应时长大约为 100 纳秒，对于小数据包，Redis 服务器可以处理 80,000 到 100,000 QPS，这么高的对于 80% 的公司来说，单线程的 Redis 已经足够使用了。&lt;/p&gt;
&lt;p&gt;但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的 QPS。&lt;/p&gt;
&lt;p&gt;为了提升QPS，很多公司的做法是部署Redis集群，并且尽可能提升Redis机器数。但是这种做法的资源消耗是巨大的。&lt;/p&gt;
&lt;p&gt;而经过分析，限制Redis的性能的主要瓶颈出现在网络IO的处理上，虽然之前采用了多路复用技术。但是我们前面也提到过，&lt;strong&gt;多路复用的IO模型本质上仍然是同步阻塞型IO模型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面是多路复用IO中select函数的处理过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157047007332.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;从上图我们可以看到，&lt;strong&gt;在多路复用的IO模型中，在处理网络请求时，调用 select （其他函数同理）的过程是阻塞的，也就是说这个过程会阻塞线程，如果并发量很高，此处可能会成为瓶颈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然现在很多服务器都是多个CPU核的，但是对于Redis来说，因为使用了单线程，在一次数据操作的过程中，有大量的CPU时间片是耗费在了网络IO的同步处理上的，并没有充分的发挥出多核的优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果能采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，Redis 6.0采用多个IO线程来处理网络请求，网络请求的解析可以由其他线程完成，然后把解析后的请求交由主线程进行实际的内存读写。提升网络请求处理的并行度，进而提升整体性能。&lt;/p&gt;
&lt;p&gt;但是，Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，在引入多线程之后，如何解决并发带来的线程安全问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是为什么我们前面多次提到的”Redis 6.0的多线程只用来处理网络请求，而数据的读写还是单线程”的原因。&lt;/p&gt;
&lt;p&gt;Redis 6.0 只有在网络请求的接收和解析，以及请求后的数据通过网络返回给时，使用了多线程。而数据读写操作还是由单线程来完成的，所以，这样就不会出现并发问题了。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/Zzbj/p/13531622.html https://xie.infoq.cn/article/b3816e9fe3ac77684b4f29348 https://jishuin.proginn.com/p/763bfbd2a1c2 《极客时间：Redis核心技术与实战》&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>