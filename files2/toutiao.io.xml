<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>492648e91b5b0f73105be2abc7dbcc42</guid>
<title>2022 年升职加薪就靠它了！抓紧时间！</title>
<link>https://toutiao.io/k/fitvcz1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc30ec71cff02337f98b8aaaa1011dc0</guid>
<title>深度分页，我都是这么玩的</title>
<link>https://toutiao.io/k/p61u81q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d265d35077231d4586b6820fd4ef7611</guid>
<title>2022 年要考虑的 7 种 Docker 替代方案</title>
<link>https://toutiao.io/k/ywk73n5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YriaiaJPb26VN5koUu22VNrAnuXDfGLRs8w4tRT63wErRVia5ic9J4ZyzWLDwcKT1Ldrzibn8lWIAnCQmkMCAVEtuIg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section&gt;作者 | Sudip Sengupta&lt;/section&gt;&lt;section&gt;
译者 | 辛晓亮&lt;/section&gt;&lt;p&gt;许多企业都采用容器来进行开发和管理稳定的应用程序，Docker 是该领域功能最丰富且使用最广泛的工具之一，已有数百万应用程序在使用它。Docker 本身有着强大的独立生态系统，并提供了一个广泛的工具包来管理容器化过程，但 Docker 还有其他替代品，它们提供了独特的用例和功能。本文深入探讨了 Docker 七个替代品，其中包括一系列综合平台，如 Docker 以及可以作为 Docker 生态系统组件替代品的工具等。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Podman&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2852852852852853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPdOhe0afO6YmFOckTwrr17v7vcib7WiaCFZA3GyyNEGfb7vuNsDSIqF2GeqZKovvBRsCDRibyomDqQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1332&quot;/&gt;&lt;/p&gt;&lt;p&gt;Podman 是 RedHat 开发的一个无守护程序的开源 Linux 原生容器引擎，用于构建、运行和管理 Linux OCI 容器与容器镜像。尽管 Podman 提供了一个类似于 Docker 的命令行界面，但它的操作方式并不相同。&lt;/p&gt;&lt;p&gt;Docker 和 Podman 之间的一个显著区别是，Docker 运行一个持久的、自给自足的运行时来管理其对象或称为 dockerd 的守护进程；而 Podman 并不依赖守护进程来工作，相反，Podman 将容器作为子进程启动，它还直接与注册表和使用运行时进程的 Linux 内核进行交互，也正因如此，Podman 被称为无守护进程的容器技术。&lt;/p&gt;&lt;p&gt;没有守护进程提高了 Podman 作为容器引擎的灵活性，消除了对单个进程的依赖。Podman 与 Docker 的另一大不同就是它不需要 root 权限。这一特点提供了一个额外的安全缓冲区，限制了某些可能操纵关键系统设置并使容器和包含的应用程序易受攻击的潜在危险进程。&lt;/p&gt;&lt;p&gt;此外，Podman 可以运行 pod-- 包含一个或多个容器的集合，作为一个单一实体管理，并利用共享的资源池。通过这项能力，Podman 用户可以将他们的工作负载转移到 Kubernetes。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;L  X  D&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34294385432473445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPdOhe0afO6YmFOckTwrr17ygsk3jCfFca9MTzgDHXTCIU5dGx6KwPNz0GwGEzm4wFF5uALsjxIrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/p&gt;&lt;p&gt;LXD 一个专为 LXC Linux 容器设计的开源容器引擎。LXC 使用户能够在隔离的容器或类似于虚拟机的虚拟环境中运行应用程序，而无需承担管理单个内核的技术负担。LXD 提供了一个用于连接 LXC 软件库的接口，同时创建了一个守护进程，负责处理网络、数据存储和管理多个 LXC 容器。尽管 LXC 可以作为独立工具运行，但它拥有有限的功能子集。LXD 提供了这些附加功能，因此依赖于 LXC 工作。&lt;/p&gt;&lt;p&gt;LXD 与 Docker 的主要区别如下。与 Docker 建议每个容器只有单个进程的设计模式不同，LXC/LXD 中的容器可以运行多个进程。此外，Docker 容器可移植性更强，为与 LXD 相比，Docker 有效地抽象了资源。最后，Docker 支持在 Windows 和 macOS 环境上运行，但 LXD 只支持 Linux。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;containerd&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3249444855662472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPdOhe0afO6YmFOckTwrr17TiaFWSIfjhzEYEW6Pk4M4etCCh8I9B3sEcL0mLo8x5AniayEAMtVmbOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1351&quot;/&gt;&lt;/p&gt;&lt;p&gt;containerd 是一个高级容器运行时，它通过在底层运行 runc 以提供操作系统和容器引擎之间的接口。runc 是一个支持 Windows 和 Linux 的守护进程，它抽象了特定于操作系统的功能，使运行和监督容器以及管理图像传输和存储变得更加容易。&lt;/p&gt;&lt;p&gt;containerd 提供的这种抽象级别功能消除了进行若干低级系统调用的复杂性，使得容器的可移植性得以实现。然而，与 Docker 不同，containerd 不处理镜像的构建或卷的创建。有趣的是，containerd 是 Docker 的默认运行时，现在它是一个独立的工具，就像 runc 一样。这也使得 containerd 像 Kubernetes 一样成为一个方便的编排工具，containerd 也是最受欢迎的 Docker 替代品之一。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Buildah&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2906875543951262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPdOhe0afO6YmFOckTwrr17ZcY4FuiauOUibQicmxfyEy78iaeJq9rHIefza085fsHJy4I3eaZp5XYBpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1149&quot;/&gt;&lt;/p&gt;&lt;p&gt;Buildah 是红帽基金会为容器化系统开发的一个 OCI 镜像构建工具。它是一个提供类似于在 Docker 中运行 &lt;code&gt;docker build&lt;/code&gt; 的功能的工具。Buildah 经常与 Podman 一起使用，互作补充，例如，Podman 在后台使用 Buildah 功能的子集来实现其构建过程。&lt;/p&gt;&lt;p&gt;它可以从 Dockerfile 或 Containerfile 中构建镜像，并生成与使用 Docker 创建的镜像相同的镜像，因为这些镜像是符合 OCI 的。此外，它还提供了对镜像层的细粒度控制，允许在一个单一层中进行多次修改提交。它还提供了从头开始构建镜像的能力，即不包含任何内容的镜像，这让用户可以自由地只添加运行应用程序所需的软件包。最后，与 Docker 不同的是，在 Buildah 中，用户只能看到他们构建的镜像。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;BuildKit&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2831230283911672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPdOhe0afO6YmFOckTwrr17cyEvAcrCF9Uu7qQxbcicbBxRgu3mf5tO0hFK7qjV4246pJG24Uk6PicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;BuildKit 是第二代构建镜像的 Moby 项目，在较新的 Docker 版本中作为实验性功能提供。&lt;span&gt;与 Do&lt;/span&gt;&lt;span&gt;cker 一样，它使用守护程序&lt;/span&gt;运行。不过，标准 Docker 构建和 BuildKit 之间的主要区别之一是，前者是逐层构建，后者提供并行构建处理。这个功能提高了性能，使构建速度更快。BuildKit 还允许跳过未使用的阶段，改善增量构建，并允许无根构建。此外，BuildKit 使用一个缓存来减少重建图像每一层的需要。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Kaniko&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3467297084318361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPdOhe0afO6YmFOckTwrr17oDFlibicibMlDxGwy9MnM3QVwZiaBcuhKdrMNFNzAK4fdUc0N5m7ZTXjKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot;/&gt;&lt;/p&gt;&lt;p&gt;Kaniko 是一个谷歌镜像构建工具，它可以从 Dockerfile 构建镜像。它和 Buildah 一样是无守护进程的，但更侧重于在 Kubernetes 中构建镜像。Kaniko 对于本地开发实例来说不是很方便，因为它通常作为镜像与 Kubernetes 等容器编排器一起运行。对于 Kubernetes 集群中的持续集成和交付管道，Kaniko 可以成为一个实用的工具。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;RunC&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3230437903804738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VPdOhe0afO6YmFOckTwrr17FAXBYfic6Y7wwhYfHTAMrY5HE72EoggsRuXmnrmGQz1AOP3TZiajOOmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1393&quot;/&gt;&lt;/p&gt;&lt;p&gt;RunC 以前是嵌入到 Docker 架构中的一个模块，在 2015 年作为独立工具发布。此后，它成为一个广泛使用的、标准化的、可互操作的容器运行时。DevOps 团队可以将其作为 Docker 或其他定制容器引擎的一部分。RunC 属于容器化生态系统中的容器运行时部分。容器运行时是处理容器运行的容器引擎中使用的较低级别的组件。&lt;/p&gt;&lt;p&gt;尽管 Docker 为组织在容器化过程中所需的各个方面提供了一个全面的工具包，但某些 DevOps 功能可能需要探索其他替代方案。但是，在选择任何此类选项时也需牢记此类替代方案所运行的主机操作系统及其使用情况。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.containiq.com/post/docker-alternatives&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;点击底部&lt;/span&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;span&gt;访问 InfoQ 官网，获取更多精彩内容！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span photoshow-hd-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YriaiaJPb26VNPrPHVrV124MK6fhrWJSGLwiapMkaCSpJichgaCz6JzXr413C6xfEjiasT96KgRdhjRP3CHnaEHQe7A/&quot;&gt;今日好文推荐&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651106089&amp;amp;idx=1&amp;amp;sn=4eb1903a395a9544767d5383bd4cfbff&amp;amp;chksm=bdb9537a8aceda6c96a107d348b5e954fb2107f89870b67a6c50f557c7969029f21b4240aa2d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;75%新项目都可以“无脑”选择单体架构&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;75%新项目都可以“无脑”选择单体架构&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651105854&amp;amp;idx=1&amp;amp;sn=346fc790136616fc3e088acc8bf0f950&amp;amp;chksm=bdb9526d8acedb7bff88e236e17002102f92918bb3245796020239927cfa21ce5bd341caad6a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;InfoQ 最新 Java 发展趋势报告&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;InfoQ 最新 Java 发展趋势报告&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651105779&amp;amp;idx=1&amp;amp;sn=9d06a049aa0429b3eb56c6af73305bb0&amp;amp;chksm=bdb951a08aced8b68c97d4d0ed16bdeee3128bd0e081b173b2c35e955c7c09e737af191c2694&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;AlphaCode编程比赛击败一半程序员；微信超1亿人视频号看春晚，6.6亿人抢红包；Flutter 2.10发布 ｜ Q资讯&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;AlphaCode编程比赛击败一半程序员；微信超1亿人视频号看春晚，6.6亿人抢红包；Flutter 2.10发布 ｜ Q资讯&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651105739&amp;amp;idx=1&amp;amp;sn=0c9a1d1a5b45c7a5a5c6779cb3f2a232&amp;amp;chksm=bdb951988aced88e599f05b2cb023a267e074a033cfb395d5742b5dbd7c5fd08ae924bd5df32&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;这十个事件，让“永不宕机”变成了一个笑话&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;这十个事件，让“永不宕机”变成了一个笑话&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YriaiaJPb26VNBX66P2F9dF2yuYfbcibGMuaBYgvK62MGPE9HhgU2vptFAUZdaO2cGKCsP4h1DnibIGywKSkFv9b6g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点个在看少个 bug&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff9faba0786646f10ee2bc7a294c11e8</guid>
<title>使用 Cilium 增强 Kubernetes 网络安全</title>
<link>https://toutiao.io/k/37vv9md</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TL;DR&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本篇，我们分别使用了 Kubernetes 原生的网络策略和 Cilium 的网络策略实现了 Pod 网络层面的隔离。不同的是，前者只提供了基于 L3/4 的网络策略；后者支持 L3/4、L7 的网络策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过网络策略来提升网络安全，可以极大降低了实现和维护的成本，同时对系统几乎没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是基于 eBPF 技术的 Cilium，解决了内核扩展性不足的问题，从内核层面为工作负载提供安全可靠、可观测的网络连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么说 Kubernetes 网络存在安全隐患？集群中的 Pod 默认是未隔离的，也就是 Pod 之间的网络是互通的，可以互相通信的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就会有问题，比如由于数据敏感服务 B 只允许特定的服务 A 才能访问，而服务 C 无法访问 B。要禁止服务 C 对服务 B 的访问，可以有几种方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 SDK 中提供通用的解决方案，实现白名单的功能。首先请求要带有来源的标识，然后服务端可以接收规则设置放行特定标识的请求，拒绝其他的请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;云原生的解决方案，使用服务网格的 RBAC、mTLS 功能。RBAC 实现原理与应用层的 SDK 方案类似，但是属于基础设施层的抽象通用方案；mTLS 则会更加复杂一些，在连接握手阶段进行身份验证，涉及证书的签发、验证等操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上两种方案各有利弊：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SDK 的方案实现简单，但是规模较大的系统会面临升级推广困难、多语言支持成本高等问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务网格的方案是基础设施层的通用方案，天生支持多语言。但是对于未落地网格的用户来说，架构变化大，成本高。如果单纯为了解决安全问题，使用网格方案性价比又很低，且不说现有网格实现等落地难度大及后期的使用维护成本高。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续向基础设施下层找方案，从网络层入手。Kubernetes 提供了的&lt;span&gt;网络策略 *NetworkPolicy*&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，则可以实现“网络层面的隔离”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;示例应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进一步演示 &lt;span&gt;NetworkPolicy&lt;/span&gt; 的方案之前，先介绍用于演示的示例应用。我们使用 Cilium 在互动教程 &lt;span&gt;Cilium getting started&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 中使用的“星球大战”场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有三个应用，星战迷估计不会陌生：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;死星 &lt;span&gt;deathstar&lt;/span&gt;：在 &lt;code&gt;80&lt;/code&gt; 端口提供 web 服务，有 2 个 副本，通过 Kubernetes Service 的负载均衡为&lt;strong&gt;帝国战机&lt;/strong&gt;对外提供”登陆“服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;钛战机 &lt;span&gt;tiefighter&lt;/span&gt;：执行登陆请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;X翼战机 &lt;span&gt;xwing&lt;/span&gt;：执行登陆请求。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8492520138089759&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxec2EkzdFcUSgwicz701f6VwrdfgPyCkOhzewcaKVHRnc5Dt6P1uDb5C63kgFcEQsXC8kjbmYDFpsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如图所示，我们使用了 &lt;span&gt;Label&lt;/span&gt; 对三个应用进行了标识：&lt;code&gt;org&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt;。在执行网络策略时，我们会使用这两个标签识别负载。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# app.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app.kubernetes.io/name:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;ClusterIP&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app.kubernetes.io/name:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app.kubernetes.io/name:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;docker.io/cilium/starwars&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Pod&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;tiefighter&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;tiefighter&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app.kubernetes.io/name:&lt;/span&gt; &lt;span&gt;tiefighter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;spaceship&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;docker.io/tgraf/netperf&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Pod&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;xwing&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app.kubernetes.io/name:&lt;/span&gt; &lt;span&gt;xwing&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;alliance&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;xwing&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;spaceship&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;docker.io/tgraf/netperf&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 网络策略&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;span&gt;官方文档&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;获取更多详细信息，这里我们直接放出配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# native/networkpolicy.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;networking.k8s.io/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;NetworkPolicy&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;policy&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;podSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;policyTypes:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Ingress&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ingress:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;from:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;podSelector:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;podSelector&lt;/code&gt; ：表示要应用网络策略的工作负载均衡，通过 &lt;span&gt;label&lt;/span&gt; 选择到了 &lt;span&gt;deathstar&lt;/span&gt; 的 2 个 Pod。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;policyTypes&lt;/code&gt; ：表示流量的类型，可以是 &lt;code&gt;Ingress&lt;/code&gt; 或 &lt;code&gt;Egress&lt;/code&gt; 或两者兼具。这里使用 &lt;code&gt;Ingress&lt;/code&gt;，表示对选择的 &lt;span&gt;deathstar&lt;/span&gt; Pod 的入站流量执行规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ingress.from&lt;/code&gt;：表示流量的来源工作负载，也是使用 &lt;code&gt;podSelector&lt;/code&gt; 和 &lt;span&gt;Label&lt;/span&gt; 进行选择，这里选中了 &lt;code&gt;org=empire&lt;/code&gt; 也就是所有“帝国的战机”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ingress.ports&lt;/code&gt;：表示流量的进入端口，这里列出了 &lt;span&gt;deathstar&lt;/span&gt; 的服务端口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们测试下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;测试&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先准备环境，我们使用 &lt;span&gt;K3s&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 作为 Kubernetes 环境。但由于 K3s 默认的 CNI 插件 Flannel 不支持网络策略，我们需要换个插件，这里选择 &lt;span&gt;Calico&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;，即 K3s + Calico 的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先创建一个单节点的集群：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE=&quot;644&quot; INSTALL_K3S_EXEC=&quot;--flannel-backend=none --cluster-cidr=10.42.0.0/16 --disable-network-policy --disable=traefik&quot; sh -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，所有的 Pod 都处于 &lt;code&gt;Pending&lt;/code&gt; 状态，因为还需要安装 Calico：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f https://projectcalico.docs.tigera.io/manifests/calico.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待 Calico 成功运行后，所有的 Pod 也会成功运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是部署应用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f app.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行策略前&lt;/strong&gt;，执行下面的命令看看“战机能否登陆死星”：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl exec tiefighter -- curl -s -XPOST deathstar.default.svc.cluster.local/v1/request-landing&lt;br/&gt;Ship landed&lt;br/&gt;&lt;br/&gt;kubectl exec xwing -- curl -s -XPOST deathstar.default.svc.cluster.local/v1/request-landing&lt;br/&gt;Ship landed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果来看，两种 ”战机“（Pod 负载）都可以访问 &lt;span&gt;deathstar&lt;/span&gt; 服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8471264367816091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxec2EkzdFcUSgwicz701f6VwqzJotZtZoiaFoXD2okXDQNjxT4nyMxbDPC10k1LjFf46Hk37mIxZojA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时执行网络策略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f native/networkpolicy.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次尝试”登陆“，&lt;span&gt;xwing&lt;/span&gt; 的登陆请求会停在那（需要使用 &lt;span&gt;ctrl+c&lt;/span&gt; 退出，或者请求时加上 &lt;code&gt;--connect-timeout 2&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8471264367816091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxec2EkzdFcUSgwicz701f6VwgX2zaJQdclCx58FbCtDrHlicbeksxpTUz8ay5Rib653BTmUSOziaDrdmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;思考&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Kubernetes 网络策略实现了我们想要的，从网络层面为服务增加了白名单的功能，这种方案没有改造成本，对系统也几乎无影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cilium 还没出场就结束了？我们继续看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时我们的服务会对外暴露一些管理端点，由系统调用执行一些管理上的操作，比如热更新、重启等。这些端点是不允许普通服务来调用，否则会造成严重的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如示例中，&lt;span&gt;tiefighter&lt;/span&gt; 访问了 &lt;span&gt;deathstar&lt;/span&gt; 的管理端点 &lt;code&gt;/exhaust-port&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl exec tiefighter -- curl -s -XPUT deathstar.default.svc.cluster.local/v1/exhaust-port&lt;br/&gt;Panic: deathstar exploded&lt;br/&gt;&lt;br/&gt;goroutine 1 [running]:&lt;br/&gt;main.HandleGarbage(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)&lt;br/&gt;        /code/src/github.com/empire/deathstar/&lt;br/&gt;        temp/main.go:9 +0x64&lt;br/&gt;main.main()&lt;br/&gt;        /code/src/github.com/empire/deathstar/&lt;br/&gt;        temp/main.go:5 +0x85&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现了 &lt;span&gt;Panic&lt;/span&gt; 错误，检查 Pod 你会发现 &lt;span&gt;dealthstar&lt;/span&gt; 挂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kubernetes 的网络策略仅能工作在 L3/4 层，对 L7 层就无能为力了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是要请出 Cilium。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cilium 网络策略&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;由于 Cilium 涉及了 Linux 内核、网络等众多知识点，要讲清实现原理篇幅极大。故这里仅摘取了官网的介绍，后期希望有时间再写一篇关于实现的。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Cilium 简介&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;Cilium&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 是一个开源软件，用于提供、保护和观察容器工作负载（云原生）之间的网络连接，由革命性的内核技术 &lt;span&gt;eBPF&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt; 推动。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;eBPF 是什么？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Linux 内核一直是实现监控/可观测性、网络和安全功能的理想地方。不过很多情况下这并非易事，因为这些工作需要修改内核源码或加载内核模块， 最终实现形式是在已有的层层抽象之上叠加新的抽象。eBPF 是一项革命性技术，它能在内核中运行沙箱程序（sandbox programs）， 而无需修改内核源码或者加载内核模块。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;将 Linux 内核变成可编程之后，就能基于现有的（而非增加新的）抽象层来打造更加智能、 功能更加丰富的基础设施软件，而不会增加系统的复杂度，也不会牺牲执行效率和安全性。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5268214571657326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tMghG0NOfxec2EkzdFcUSgwicz701f6VwwicXHKudjS0cAQPc1HUdqITaAicZ1HIfPHZBnPZh7Ya0FrEfGe92YbxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1249&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下 Cilium 的网络策略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# cilium/networkpolicy-L4.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;&quot;cilium.io/v2&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;CiliumNetworkPolicy&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;rule1&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;description:&lt;/span&gt; &lt;span&gt;&quot;L7 policy to restrict access to specific HTTP call&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;endpointSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ingress:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;fromEndpoints:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;toPorts:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;&quot;80&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 Kubernetes 的原生网络策略差异不大，参考前面的介绍也都看懂，我们直接进入测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;测试&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Cilium 本身就实现了 CNI，所以之前的集群就不能用了，先卸载集群：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;k3s-uninstall.sh&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ！！！切记要清理之前的 cni 插件&lt;/span&gt;&lt;br/&gt;sudo rm -rf /etc/cni/net.d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是使用同样的命令创建单节点的集群：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE=&quot;644&quot; INSTALL_K3S_EXEC=&quot;--flannel-backend=none --cluster-cidr=10.42.0.0/16 --disable-network-policy --disable=traefik&quot; sh -&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; cilium 会使用该变量&lt;/span&gt;&lt;br/&gt;export KUBECONFIG=/etc/rancher/k3s/k3s.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来安装 Cilium CLI：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -L --remote-name-all https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz{,.sha256sum}&lt;br/&gt;sha256sum --check cilium-linux-amd64.tar.gz.sha256sum&lt;br/&gt;sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin&lt;br/&gt;rm cilium-linux-amd64.tar.gz{,.sha256sum}&lt;br/&gt;&lt;br/&gt;cilium version&lt;br/&gt;cilium-cli: v0.10.2 compiled with go1.17.6 on linux/amd64&lt;br/&gt;cilium image (default): v1.11.1&lt;br/&gt;cilium image (stable): v1.11.1&lt;br/&gt;cilium image (running): unknown. Unable to obtain cilium version, no cilium pods found in namespace &quot;kube-system&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装 Cilium 到集群：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cilium install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待 Cilium 成功运行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cilium status&lt;br/&gt;    /¯¯\&lt;br/&gt; /¯¯\__/¯¯\    Cilium:         OK&lt;br/&gt; \__/¯¯\__/    Operator:       OK&lt;br/&gt; /¯¯\__/¯¯\    Hubble:         disabled&lt;br/&gt; \__/¯¯\__/    ClusterMesh:    disabled&lt;br/&gt;    \__/&lt;br/&gt;&lt;br/&gt;Deployment        cilium-operator    Desired: 1, Ready: 1/1, Available: 1/1&lt;br/&gt;DaemonSet         cilium             Desired: 1, Ready: 1/1, Available: 1/1&lt;br/&gt;Containers:       cilium             Running: 1&lt;br/&gt;                  cilium-operator    Running: 1&lt;br/&gt;Cluster Pods:     3/3 managed by Cilium&lt;br/&gt;Image versions    cilium-operator    quay.io/cilium/operator-generic:v1.11.1@sha256:977240a4783c7be821e215ead515da3093a10f4a7baea9f803511a2c2b44a235: 1&lt;br/&gt;                  cilium             quay.io/cilium/cilium:v1.11.1@sha256:251ff274acf22fd2067b29a31e9fda94253d2961c061577203621583d7e85bd2: 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署应用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f app.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待应用启动后测试服务调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl exec tiefighter -- curl -s -XPOST deathstar.default.svc.cluster.local/v1/request-landing&lt;br/&gt;Ship landed&lt;br/&gt;kubectl exec xwing -- curl -s -XPOST deathstar.default.svc.cluster.local/v1/request-landing&lt;br/&gt;Ship landed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 L4 网络策略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f cilium/networkpolicy-L4.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次尝试“登陆”死星，&lt;span&gt;xwing&lt;/span&gt; 战机同样无法登陆，说明 L4 层的规则生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再尝试 L7 层的规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# cilium/networkpolicy-L7.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;&quot;cilium.io/v2&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;CiliumNetworkPolicy&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;rule1&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;description:&lt;/span&gt; &lt;span&gt;&quot;L7 policy to restrict access to specific HTTP call&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;endpointSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;class:&lt;/span&gt; &lt;span&gt;deathstar&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ingress:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;fromEndpoints:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;org:&lt;/span&gt; &lt;span&gt;empire&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;toPorts:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;&quot;80&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;rules:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;http:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;method:&lt;/span&gt; &lt;span&gt;&quot;POST&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;path:&lt;/span&gt; &lt;span&gt;&quot;/v1/request-landing&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f cilium/networkpolicy-L7.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这回，使用 &lt;span&gt;tiefighter&lt;/span&gt; 调用死星的管理接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl exec tiefighter -- curl -s -XPUT deathstar.default.svc.cluster.local/v1/exhaust-port&lt;br/&gt;Access denied&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登陆接口工作正常&lt;/span&gt;&lt;br/&gt;kubectl exec tiefighter -- curl -s -XPOST deathstar.default.svc.cluster.local/v1/request-landing&lt;br/&gt;Ship landed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这回返回了 &lt;span&gt;Access denied&lt;/span&gt;，说明 L7 层的规则生效了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.841324200913242&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxec2EkzdFcUSgwicz701f6Vwy7ZqS9rAAZq5YMFlIHl2FTzcnbicXqa0B4dlIf8AfGjuQNp5JKGNonw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;网络策略 &lt;span&gt;NetworkPolicy&lt;/span&gt;: &lt;span&gt;https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;Cilium getting started: &lt;span&gt;https://play.instruqt.com/isovalent/tracks/cilium-getting-started&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;官方文档: &lt;span&gt;https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;K3s: &lt;span&gt;https://k3s.io&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;p&gt;Calico: &lt;span&gt;https://www.tigera.io/project-calico/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;p&gt;Cilium: &lt;span&gt;https://cilium.io&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;p&gt;eBPF: &lt;span&gt;https://ebpf.io&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>70a71e80623d556d153bc42fd415d4bc</guid>
<title>500行代码了解缓存客户端驱动原理</title>
<link>https://toutiao.io/k/ac0zoxq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创不易，求分享、求一键三连&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存一般是用来加速数据访问的效率，在获取数据耗时高的场景下使用缓存可以有效的提高数据获取的效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，先从memcached中获取数据，如果没有则查询mysql中的数据得到结果写入到memcached中然后返回，下次请求就能够从memcached中获取数据直接返回。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1181102362204725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBicwZP34Pk8kpgiaaAicEh9yPy4ntGyw8l8icNKISicZicxic8NJAOGwR4h7EIFsxV9ehapjlohnBStYj7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在行业中使用比较多的缓存数据库有Redis和Memcached。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天用go实现Memcached的驱动程序，深入了解Memcached和咱们平时所写的业务代码如何进行数据交互的协议和原理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是memcached&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Memcached是LiveJournal旗下Danga Interactive公司的Brad Fitzpatric为首开发的一款自由开源、高性能的key-value缓存数据库软件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Mecached协议&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mecached服务和应用程序是不同机器不同的进程，双方进行数据交互通讯涉及到tcp和通讯协议，在memcache中协议有两种类型一种是文本行方式，另一种是非结构化数据方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们挑选文本行协议来实现，大多数Mecached的客户端也是采用文本行协议来开发的因为比较简单，特定格式文本字符串来约定数据交互，如下以客户端发送命令举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;command&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;key&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;flags&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;exptime&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;bytes&lt;/span&gt;&amp;gt;&lt;/span&gt;\r\n&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;data&lt;/span&gt; &lt;span&gt;block&lt;/span&gt;&amp;gt;&lt;/span&gt;\r\n&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;command name&amp;gt;&lt;/code&gt; 是协议的命令，大致分为三类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;存储命令：set、 add、replace、append、prepend、cas。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取命令：get、gets。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他命令：version、stats&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要求存储数据的关键字；由于memached底层实现的限制，key的长度限制在250个字符内，并且key中不能包含控制字符或空格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;flags&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是一个16位无符号整数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;exptime&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是存储超时时间。如果值为0表示该数据项永不超时；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过期时间实现限制，过期时间要么是Unix时间（从1970-1-1开始计算的秒数），要么是从当前时间开始计算的秒数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该值不能超过30天，否则服务器将该参数当做真正的Unix时间而不是当前时间的一个偏移值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是随后数据的字节数，不包括终结符\r\n。&lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt;有可能是0，它后面将是一个空的数据块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;data block&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储数据流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端以字符串的方式向服务端发送文本行的内容服务器端会返回对应的执行结果数据，也有返回错误的情况，memcache也对错误的数据格式定义三种不同错误类型的三种格式让错误的返回简单：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ERROR\r\n&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明客户端发送了一个不存在命令&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CLIENT_ERROR&lt;error&gt;\r\n&lt;/error&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明在输入行中存在某种类型的客户端错误，例如输入的信息没有遵循memcached的协议&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SERVER_ERROR&lt;error&gt;\r\n&lt;/error&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明服务端存在某种类型的错误导致致命命令无法执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;error&amp;gt;&lt;/code&gt;是具有可读性的错误字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当服务端错误发生后，将会导致服务器将不会再提供服务，服务器在发送该错误信息行后将关闭链接。只有在此场景下，服务器才会关闭与客户端链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下就具体罗列memcached常用包含客户端发送和响应的命令格式列表：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1415241057542769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBicwZP34Pk8kpgiaaAicEh9yPbCLZkaWncxYJ1FPxN283giccMbXnKTzscQicfj67XgnBvWW4YSnJgeUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5429447852760736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBicwZP34Pk8kpgiaaAicEh9yPGibxy9LvsxNcbP9I8pibYvymeyHcOTuGJoGFOjhdHuYRTuu2U27icmn2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是command是区分大小写的，客户端使用tcp连接服务端发送客户端文本行命令，发送成功后等待服务器返回数据，根据格式解析获取需要的返回值这就是一个简单的协议命令执行流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Golang实现客户端驱动&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对memache协议的了解现在来实现通讯就比较简单，首先需要定义Client结构体，保存客户端一些基本配置信息及链接信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Client &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;   Timeout      time.Duration&lt;br/&gt;   MaxIdleConns &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;   lock         sync.Mutex&lt;br/&gt;   addr         net.Addr&lt;br/&gt;   conns        []*conn&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Timeout tcp链接读写超时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;conns 是memcache链接池存放的数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MaxIdleConns 是Idle链接的数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lock 是操作conns时加锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;addr则是链接的memcache的地址&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;memcached的单独一个conn连接结构体定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; conn &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;   nc   net.Conn&lt;br/&gt;   rw   *bufio.ReadWriter&lt;br/&gt;   addr net.Addr&lt;br/&gt;   c    *Client&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;nc 是建立好的tcp网络链接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rw 为了方便数据发送和读取设置bufio的ReadWriter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;addr 存储memcached地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;c 存储客户端的引用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是看如何获取链接和使用完之后如何将链接放回到链接池中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//获取memcached的链接&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;getFreeConn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(cn *conn, ok &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   c.lock.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; c.lock.Unlock()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; c.conns == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   freelist := c.conns&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(freelist) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   cn = freelist[&lt;span&gt;len&lt;/span&gt;(freelist)&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;   c.conns = freelist[:&lt;span&gt;len&lt;/span&gt;(freelist)&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; cn, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//将使用完的链接放回到conns中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;putFreeConn&lt;/span&gt;&lt;span&gt;(cn *conn)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   c.lock.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; c.lock.Unlock()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; c.conns == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      c.conns = &lt;span&gt;make&lt;/span&gt;([]*conn, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   freelist := c.conns&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(freelist) &amp;gt;= c.maxIdleConns() {&lt;br/&gt;      cn.nc.Close()&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   c.conns = &lt;span&gt;append&lt;/span&gt;(freelist, cn)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来以GET命令为例，来详细看如何进行网络传输和协议解析的实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(item *Item, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;//check key len 验证key是否长于250字符&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; !legalKey(key) {&lt;br/&gt;      err = ErrMalformedKey&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   keys := []&lt;span&gt;string&lt;/span&gt;{key}&lt;br/&gt;   cn, err := c.getConn() &lt;span&gt;//获取memcached链接&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err) &lt;span&gt;// 方法执行完之后将链接release，返回到链接池中&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   rw := cn.rw&lt;br/&gt;   &lt;span&gt;//将gets 命令用文本行协议写入到rw中&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; _, err = fmt.Fprintf(rw, &lt;span&gt;&quot;gets %s\r\n&quot;&lt;/span&gt;, strings.Join(keys, &lt;span&gt;&quot; &quot;&lt;/span&gt;)); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err = rw.Flush(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;//获取GET命令发送之后等待和获取返回的响应数据&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err = parseGetResponse(rw.Reader, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(it *Item)&lt;/span&gt;&lt;/span&gt; { item = it }); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; item == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      err = ErrCacheMiss&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;parseGetResponse&lt;/span&gt;&lt;span&gt;(r *bufio.Reader, cb &lt;span&gt;func&lt;/span&gt;(*Item)&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  line, err := r.ReadSlice(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; bytes.Equal(line, resultEnd) { &lt;span&gt;//如果获取是 END\r\n 则数据返回完，则返回&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  it := &lt;span&gt;new&lt;/span&gt;(Item)&lt;br/&gt;  size, err := scanGetResponseLine(line, it)&lt;span&gt;//先根据格式获取第一行数据和&amp;lt;data&amp;gt; 部分的大小&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;    &lt;span&gt;//根据bytes获取数据&lt;/span&gt;&lt;br/&gt;  it.Value = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, size+&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;  _, err = io.ReadFull(r, it.Value)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   it.Value = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !bytes.HasSuffix(it.Value, crlf) {&lt;br/&gt;   it.Value = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;memcache: corrupt get result read&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  it.Value = it.Value[:size]&lt;br/&gt;  cb(it)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//根据返回数据格式获取返回值设置到Item结构中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;scanGetResponseLine&lt;/span&gt;&lt;span&gt;(line []&lt;span&gt;byte&lt;/span&gt;, it *Item)&lt;/span&gt; &lt;span&gt;(size &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 返回的数据格式 VALUE &amp;lt;key&amp;gt; &amp;lt;falgs&amp;gt; &amp;lt;bytes&amp;gt; &amp;lt;casid&amp;gt;&lt;/span&gt;&lt;br/&gt;  pattern := &lt;span&gt;&quot;VALUE %s %d %d %d\r\n&quot;&lt;/span&gt;&lt;br/&gt; dest := []&lt;span&gt;interface&lt;/span&gt;{}{&amp;amp;it.Key, &amp;amp;it.Flags, &amp;amp;size, &amp;amp;it.casid}&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; bytes.Count(line, space) == &lt;span&gt;3&lt;/span&gt; {&lt;br/&gt;  pattern = &lt;span&gt;&quot;VALUE %s %d %d\r\n&quot;&lt;/span&gt;&lt;br/&gt;  dest = dest[:&lt;span&gt;3&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; n, err := fmt.Sscanf(&lt;span&gt;string&lt;/span&gt;(line), pattern, dest...)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; || n != &lt;span&gt;len&lt;/span&gt;(dest) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;, fmt.Errorf(&lt;span&gt;&quot;memcache: unexpected line in get response: %q&quot;&lt;/span&gt;, line)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; size, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//判断key是否符合要求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;legalKey&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(key) &amp;gt; &lt;span&gt;250&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(key); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; key[i] &amp;lt;= &lt;span&gt;&#x27; &#x27;&lt;/span&gt; || key[i] == &lt;span&gt;0x7f&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其它命令不在详细描述，完整代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; memcache&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;bytes&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;errors&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strconv&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//memcached -m 1024  -u root -l 127.0.0.1 -p 12001 -c 55535&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//# memcached -d -m 10  -u root -l 127.0.0.1 -p 12001 -c 256 -P /tmp/memcached.pid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-d选项是启动一个守护进程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-m是分配给Memcache使用的内存数量，单位是MB，我这里是10MB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-u是运行Memcache的用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-l是监听的服务器IP地址，如果有多个地址的话，我这里指定了服务器的IP地址127.0.0.1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-p是设置 Memcache监听的端口，我这里设置了12001，最好是1024以上的端口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-c选项是最大运行的并发连接数，默认是1024，我这里设置了 256，按照你服务器的负载量来设定&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-P是设置保存Memcache的pid文件，我这里是保存在 /tmp/memcached.pid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//停止进程：# kill `cat /tmp/memcached.pid`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; (&lt;br/&gt; DefaultTimeout      = &lt;span&gt;100&lt;/span&gt; * time.Millisecond&lt;br/&gt; DefaultMaxIdleConns = &lt;span&gt;40&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; resultClientErrorPrefix = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;CLIENT_ERROR&quot;&lt;/span&gt;)&lt;br/&gt; resultErrPrefix         = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;ERROR&quot;&lt;/span&gt;)&lt;br/&gt; resultServerErrPrefix   = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;SERVER_ERROR&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; crlf            = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;)&lt;br/&gt; space           = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot; &quot;&lt;/span&gt;)&lt;br/&gt; resultOK        = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;OK\r\n&quot;&lt;/span&gt;)&lt;br/&gt; resultStored    = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;STORED\r\n&quot;&lt;/span&gt;)&lt;br/&gt; resultNotStored = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;NOT_STORED\r\n&quot;&lt;/span&gt;)&lt;br/&gt; resultExists    = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;EXISTS\r\n&quot;&lt;/span&gt;)&lt;br/&gt; resultNotFound  = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;NOT_FOUND\r\n&quot;&lt;/span&gt;)&lt;br/&gt; resultDeleted   = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;DELETED\r\n&quot;&lt;/span&gt;)&lt;br/&gt; resultEnd       = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;END\r\n&quot;&lt;/span&gt;)&lt;br/&gt; resultTouched   = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;TOUCHED\r\n&quot;&lt;/span&gt;)&lt;br/&gt; versionPrefix   = []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;VERSION&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; ErrMalformedKey = errors.New(&lt;span&gt;&quot;malformed: key is too long or contains invalid characters&quot;&lt;/span&gt;)&lt;br/&gt; ErrCacheMiss    = errors.New(&lt;span&gt;&quot;memcache: cache miss&quot;&lt;/span&gt;)&lt;br/&gt; ErrCASConflict  = errors.New(&lt;span&gt;&quot;memcache: compare-and-swap conflict&quot;&lt;/span&gt;)&lt;br/&gt; ErrNotStored    = errors.New(&lt;span&gt;&quot;memcache: item not stored&quot;&lt;/span&gt;)&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Client &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Timeout      time.Duration&lt;br/&gt; MaxIdleConns &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; lock         sync.Mutex&lt;br/&gt; addr         net.Addr&lt;br/&gt; conns        []*conn&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewClient&lt;/span&gt;&lt;span&gt;(timeout time.Duration, maxIdleConns &lt;span&gt;int&lt;/span&gt;, addr net.Addr)&lt;/span&gt; *&lt;span&gt;Client&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Client{&lt;br/&gt;  Timeout:      timeout,&lt;br/&gt;  MaxIdleConns: maxIdleConns,&lt;br/&gt;  lock:         sync.Mutex{},&lt;br/&gt;  addr:         addr,&lt;br/&gt;  conns:        &lt;span&gt;nil&lt;/span&gt;,&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Item &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Key is the Item&#x27;s key (250 bytes maximum).&lt;/span&gt;&lt;br/&gt; Key &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Value is the Item&#x27;s value.&lt;/span&gt;&lt;br/&gt; Value []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Flags are server-opaque flags whose semantics are entirely&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// up to the app.&lt;/span&gt;&lt;br/&gt; Flags &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Expiration is the cache expiration time, in seconds: either a relative&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// time from now (up to 1 month), or an absolute Unix epoch time.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Zero means the Item has no expiration time.&lt;/span&gt;&lt;br/&gt; Expiration &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Compare and swap ID.&lt;/span&gt;&lt;br/&gt; casid &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;maxIdleConns&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.MaxIdleConns &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.MaxIdleConns&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; DefaultMaxIdleConns&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;netTimeout&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Duration&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.Timeout != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.Timeout&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; DefaultTimeout&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; conn &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; nc   net.Conn&lt;br/&gt; rw   *bufio.ReadWriter&lt;br/&gt; addr net.Addr&lt;br/&gt; c    *Client&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 设置超时时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(cn *conn)&lt;/span&gt; &lt;span&gt;extendDeadline&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cn.nc.SetDeadline(time.Now().Add(cn.c.netTimeout()))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Release 如果是正常的err 则放回到conns中，如果不是这直接close掉conn&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(cn *conn)&lt;/span&gt; &lt;span&gt;condRelease&lt;/span&gt;&lt;span&gt;(err *error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; *err == &lt;span&gt;nil&lt;/span&gt; || resumableError(*err) {&lt;br/&gt;  cn.release()&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;xxx&quot;&lt;/span&gt;, fmt.Sprintf(&lt;span&gt;&quot;%s&quot;&lt;/span&gt;, (*err).Error()))&lt;br/&gt;  cn.nc.Close()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// release returns this connection back to the client&#x27;s free pool&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(cn *conn)&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cn.c.putFreeConn(cn)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;putFreeConn&lt;/span&gt;&lt;span&gt;(cn *conn)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.lock.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; c.lock.Unlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.conns == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  c.conns = &lt;span&gt;make&lt;/span&gt;([]*conn, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; freelist := c.conns&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(freelist) &amp;gt;= c.maxIdleConns() {&lt;br/&gt;  cn.nc.Close()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; c.conns = &lt;span&gt;append&lt;/span&gt;(freelist, cn)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;getFreeConn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(cn *conn, ok &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.lock.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; c.lock.Unlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.conns == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; freelist := c.conns&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(freelist) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; cn = freelist[&lt;span&gt;len&lt;/span&gt;(freelist)&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt; c.conns = freelist[:&lt;span&gt;len&lt;/span&gt;(freelist)&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; cn, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ConnectTimeoutError &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Addr net.Addr&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(cte *ConnectTimeoutError)&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;memcache: connect timeout to &quot;&lt;/span&gt; + cte.Addr.String()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取memcached连接&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;getConn&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(*conn, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cn, ok := c.getFreeConn()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok {&lt;br/&gt;  cn.extendDeadline()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; cn, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; nc, err := c.dial(c.addr)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; cn = &amp;amp;conn{&lt;br/&gt;  nc:   nc,&lt;br/&gt;  addr: c.addr,&lt;br/&gt;  rw:   bufio.NewReadWriter(bufio.NewReader(nc), bufio.NewWriter(nc)),&lt;br/&gt;  c:    c,&lt;br/&gt; }&lt;br/&gt; cn.extendDeadline()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; cn, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;dial&lt;/span&gt;&lt;span&gt;(addr net.Addr)&lt;/span&gt; &lt;span&gt;(net.Conn, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; nc, err := net.DialTimeout(addr.Network(), addr.String(), c.netTimeout())&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nc, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ne, ok := err.(net.Error); ok &amp;amp;&amp;amp; ne.Timeout() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, &amp;amp;ConnectTimeoutError{Addr: addr}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(item *Item, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;//check key len&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !legalKey(key) {&lt;br/&gt;  err = ErrMalformedKey&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; keys := []&lt;span&gt;string&lt;/span&gt;{key}&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; rw := cn.rw&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, err = fmt.Fprintf(rw, &lt;span&gt;&quot;gets %s\r\n&quot;&lt;/span&gt;, strings.Join(keys, &lt;span&gt;&quot; &quot;&lt;/span&gt;)); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = rw.Flush(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = parseGetResponse(rw.Reader, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(it *Item)&lt;/span&gt;&lt;/span&gt; { item = it }); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; item == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  err = ErrCacheMiss&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;GetMulti&lt;/span&gt;&lt;span&gt;(keys []&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]*Item, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; lk sync.Mutex&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]*Item)&lt;br/&gt; addItemToMap := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(it *Item)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  lk.Lock()&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; lk.Unlock()&lt;br/&gt;  m[it.Key] = it&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, key := &lt;span&gt;range&lt;/span&gt; keys {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !legalKey(key) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, ErrMalformedKey&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, err = fmt.Fprintf(cn.rw, &lt;span&gt;&quot;gets %s\r\n&quot;&lt;/span&gt;, strings.Join(keys, &lt;span&gt;&quot; &quot;&lt;/span&gt;)); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = cn.rw.Flush(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = parseGetResponse(cn.rw.Reader, addItemToMap); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m, err&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Touch&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, seconds &lt;span&gt;int32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, err = fmt.Fprintf(cn.rw, &lt;span&gt;&quot;touch %s %d\r\n&quot;&lt;/span&gt;, key, seconds); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = cn.rw.Flush(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; line, err := cn.rw.ReadSlice(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultTouched):&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultNotFound):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrCacheMiss&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;memcache: unexpected response line from touch: %q&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;(line))&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.onItem(item, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(client *Client, rw *bufio.ReadWriter, item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; client.populateOne(rw, &lt;span&gt;&quot;add&quot;&lt;/span&gt;, item)&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.onItem(item, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(client *Client, rw *bufio.ReadWriter, item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; client.populateOne(rw, &lt;span&gt;&quot;set&quot;&lt;/span&gt;, item)&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;CompareAndSwap&lt;/span&gt;&lt;span&gt;(item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.onItem(item, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(client *Client, rw *bufio.ReadWriter, item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; client.populateOne(rw, &lt;span&gt;&quot;cas&quot;&lt;/span&gt;, item)&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Replace&lt;/span&gt;&lt;span&gt;(item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.onItem(item, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(client *Client, rw *bufio.ReadWriter, item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; client.populateOne(rw, &lt;span&gt;&quot;replace&quot;&lt;/span&gt;, item)&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !legalKey(key) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrMalformedKey&lt;br/&gt; }&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; writeExpectf(cn.rw, resultDeleted, &lt;span&gt;&quot;delete %s\r\n&quot;&lt;/span&gt;, key)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;FlushAll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; writeExpectf(cn.rw, resultDeleted, &lt;span&gt;&quot;flush_all\r\n&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(rw *bufio.ReadWriter)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, e := fmt.Fprintf(rw, &lt;span&gt;&quot;version\r\n&quot;&lt;/span&gt;); e != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; e := rw.Flush(); e != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; e&lt;br/&gt;  }&lt;br/&gt;  line, e := rw.ReadSlice(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; e != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; e&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;switch&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; bytes.HasPrefix(line, versionPrefix):&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;memcache: unexpected response line from ping: %q&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;(line))&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }(cn.rw)&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Increment&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, delta &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(newValue &lt;span&gt;uint64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.incrDecr(&lt;span&gt;&quot;incr&quot;&lt;/span&gt;, key, delta)&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;Decrement&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, delta &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(newValue &lt;span&gt;uint64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.incrDecr(&lt;span&gt;&quot;decr&quot;&lt;/span&gt;, key, delta)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;onItem&lt;/span&gt;&lt;span&gt;(item *Item, fn &lt;span&gt;func&lt;/span&gt;(*Client, *bufio.ReadWriter, *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = fn(c, cn.rw, item); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;parseGetResponse&lt;/span&gt;&lt;span&gt;(r *bufio.Reader, cb &lt;span&gt;func&lt;/span&gt;(*Item)&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  line, err := r.ReadSlice(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; bytes.Equal(line, resultEnd) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  it := &lt;span&gt;new&lt;/span&gt;(Item)&lt;br/&gt;  size, err := scanGetResponseLine(line, it)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  it.Value = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, size+&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;  _, err = io.ReadFull(r, it.Value)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   it.Value = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !bytes.HasSuffix(it.Value, crlf) {&lt;br/&gt;   it.Value = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;memcache: corrupt get result read&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  it.Value = it.Value[:size]&lt;br/&gt;  cb(it)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;scanGetResponseLine&lt;/span&gt;&lt;span&gt;(line []&lt;span&gt;byte&lt;/span&gt;, it *Item)&lt;/span&gt; &lt;span&gt;(size &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; pattern := &lt;span&gt;&quot;VALUE %s %d %d %d\r\n&quot;&lt;/span&gt;&lt;br/&gt; dest := []&lt;span&gt;interface&lt;/span&gt;{}{&amp;amp;it.Key, &amp;amp;it.Flags, &amp;amp;size, &amp;amp;it.casid}&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; bytes.Count(line, space) == &lt;span&gt;3&lt;/span&gt; {&lt;br/&gt;  pattern = &lt;span&gt;&quot;VALUE %s %d %d\r\n&quot;&lt;/span&gt;&lt;br/&gt;  dest = dest[:&lt;span&gt;3&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; n, err := fmt.Sscanf(&lt;span&gt;string&lt;/span&gt;(line), pattern, dest...)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; || n != &lt;span&gt;len&lt;/span&gt;(dest) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;, fmt.Errorf(&lt;span&gt;&quot;memcache: unexpected line in get response: %q&quot;&lt;/span&gt;, line)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; size, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;legalKey&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(key) &amp;gt; &lt;span&gt;250&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(key); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; key[i] &amp;lt;= &lt;span&gt;&#x27; &#x27;&lt;/span&gt; || key[i] == &lt;span&gt;0x7f&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;resumableError&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; err {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; ErrCacheMiss, ErrCASConflict, ErrNotStored, ErrMalformedKey:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;populateOne&lt;/span&gt;&lt;span&gt;(rw *bufio.ReadWriter, verb &lt;span&gt;string&lt;/span&gt;, item *Item)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !legalKey(item.Key) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrMalformedKey&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; verb == &lt;span&gt;&quot;cas&quot;&lt;/span&gt; {&lt;br/&gt;  _, err = fmt.Fprintf(rw, &lt;span&gt;&quot;%s %s %d %d %d %d\r\n&quot;&lt;/span&gt;,&lt;br/&gt;   verb, item.Key, item.Flags, item.Expiration, &lt;span&gt;len&lt;/span&gt;(item.Value), item.casid)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  _, err = fmt.Fprintf(rw, &lt;span&gt;&quot;%s %s %d %d %d\r\n&quot;&lt;/span&gt;,&lt;br/&gt;   verb, item.Key, item.Flags, item.Expiration, &lt;span&gt;len&lt;/span&gt;(item.Value))&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, err = rw.Write(item.Value); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, err = rw.Write(crlf); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = rw.Flush(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; line, err := rw.ReadSlice(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultStored):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultNotStored):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrNotStored&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultExists):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrCASConflict&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultNotFound):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrCacheMiss&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;memcache: unexpected response line from %q: %q&quot;&lt;/span&gt;, verb, &lt;span&gt;string&lt;/span&gt;(line))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;writeExpectf&lt;/span&gt;&lt;span&gt;(rw *bufio.ReadWriter, expect []&lt;span&gt;byte&lt;/span&gt;, format &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; line, err := writeReadLine(rw, format, args...)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultOK):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, expect):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultNotStored):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrNotStored&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultExists):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrCASConflict&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultNotFound):&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ErrCacheMiss&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;memcache: unexpected response line: %q&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;(line))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;writeReadLine&lt;/span&gt;&lt;span&gt;(rw *bufio.ReadWriter, format &lt;span&gt;string&lt;/span&gt;, args ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; _, err := fmt.Fprintf(rw, format, args...)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; e := rw.Flush(); e != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, e&lt;br/&gt; }&lt;br/&gt; line, err := rw.ReadSlice(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; line, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Client)&lt;/span&gt; &lt;span&gt;incrDecr&lt;/span&gt;&lt;span&gt;(verb, key &lt;span&gt;string&lt;/span&gt;, delta &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;uint64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; val &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt; cn, err := c.getConn()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cn.condRelease(&amp;amp;err)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(rw *bufio.ReadWriter)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  line, e := writeReadLine(rw, &lt;span&gt;&quot;%s %s %d\r\n&quot;&lt;/span&gt;, verb, key, delta)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; e != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; e&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;switch&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; bytes.Equal(line, resultNotFound):&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; ErrCacheMiss&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; bytes.HasPrefix(line, resultClientErrorPrefix):&lt;br/&gt;   errMsg := line[&lt;span&gt;len&lt;/span&gt;(resultClientErrorPrefix) : &lt;span&gt;len&lt;/span&gt;(line)&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.New(&lt;span&gt;&quot;memcache: client error: &quot;&lt;/span&gt; + &lt;span&gt;string&lt;/span&gt;(errMsg))&lt;br/&gt;  }&lt;br/&gt;  val, e = strconv.ParseUint(&lt;span&gt;string&lt;/span&gt;(line[:&lt;span&gt;len&lt;/span&gt;(line)&lt;span&gt;-2&lt;/span&gt;]), &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; e != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; e&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }(cn.rw)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; val, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码，启动一个http服务器先设置到memcached中，通过/hello 接口从memcached中获取对应的值&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;memcache_go/memcache&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; client *memcache.Client&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;IndexHandler&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ret, err := client.Get(&lt;span&gt;&quot;tcp_key&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Fprintln(w, &lt;span&gt;&quot;err &quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; str := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ret != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  str = &lt;span&gt;string&lt;/span&gt;(ret.Value)&lt;br/&gt;  fmt.Fprintln(w, &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;, str)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  fmt.Fprintln(w, &lt;span&gt;&quot;nil&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;touchHandler&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; err := client.Touch(&lt;span&gt;&quot;tcp_key&quot;&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Fprintln(w, &lt;span&gt;&quot;err &quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; fmt.Fprintln(w, &lt;span&gt;&quot;succ&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; addr, err := net.ResolveTCPAddr(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;127.0.0.1:12001&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(fmt.Sprintf(&lt;span&gt;&quot;get err %v&quot;&lt;/span&gt;, err))&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; client = memcache.NewClient(&lt;span&gt;30&lt;/span&gt;*time.Second, &lt;span&gt;30&lt;/span&gt;, addr)&lt;br/&gt;&lt;br/&gt; err = client.Add(&amp;amp;memcache.Item{&lt;br/&gt;  Key:        &lt;span&gt;&quot;tcp_key&quot;&lt;/span&gt;,&lt;br/&gt;  Value:      []&lt;span&gt;byte&lt;/span&gt;(fmt.Sprintf(&lt;span&gt;&quot;tcp_key_value_%d&quot;&lt;/span&gt;, time.Now().UnixNano())),&lt;br/&gt;  Flags:      &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;  Expiration: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;执行失败&quot;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;//return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;, IndexHandler)&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/touch&quot;&lt;/span&gt;, touchHandler)&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;127.0.0.1:8000&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;//fmt.Println(&quot;memcache_test...&quot;)&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  time.Sleep(&lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;30&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动memcached服务进行测试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;memcached -m &lt;span&gt;1024&lt;/span&gt;  -u root -l &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt; -p &lt;span&gt;12001&lt;/span&gt; -c &lt;span&gt;55535&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-d选项是启动一个守护进程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-m是分配给Memcache使用的内存数量，单位是MB，我这里是10MB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-u是运行Memcache的用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-l是监听的服务器IP地址，如果有多个地址的话，我这里指定了服务器的IP地址127.0.0.1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-p是设置 Memcache监听的端口，我这里设置了12001，最好是1024以上的端口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-c选项是最大运行的并发连接数，默认是1024，我这里设置了 256，按照你服务器的负载量来设定&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//-P是设置保存Memcache的pid文件，我这里是保存在 /tmp/memcached.pid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//停止进程：# kill `cat /tmp/memcached.pid`  &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们大概用了几百行代码实现了一个简单的memcached链接驱动的子集，对应用程序和memcached如何通讯有了大致了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的分享就到这，希望对各位有用。&lt;strong&gt;「原创不易，多多分享」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要更多交流可以加群：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2585227272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBicwZP34Pk8kpgiaaAicEh9yPjqfTJLBOMia0aPBJZRLvHIjMH27pnxsmgdTQicaY4aOXdtAEBVJkCSiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以加入知识星球免费提问：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2923076923076924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBicwZP34Pk8kpgiaaAicEh9yPptIEtuXVeuVzxPhziaiaCHeHy5IckpPZUm9vog1xgia5X2ZSqIHLeHUEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>