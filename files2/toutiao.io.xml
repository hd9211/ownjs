<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>512f8fe57ee76acf380058763a8808df</guid>
<title>[推荐] 终于有人把数据中台讲明白了</title>
<link>https://toutiao.io/k/t3ybr20</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42519af03b9c645f1be24a41f87218a9</guid>
<title>[推荐] MySQL 的 join 功能弱爆了？</title>
<link>https://toutiao.io/k/031qbdy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;点击上方&quot;&lt;span&gt;程序员历小冰&lt;/span&gt;&quot;，选择“置顶或者星标”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   你的关注意义重大!&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n868&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大家好，我是历小冰，今天我们来学习和吐槽一下 MySQL 的 Join 功能。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n870&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于MySQL 的 join，大家一定了解过很多它的“轶事趣闻”，比如两表 join 要小表驱动大表，阿里开发者规范禁止三张表以上的 join 操作，MySQL 的 join 功能弱爆了等等。这些规范或者言论亦真亦假，时对时错，需要大家自己对 join 有深入的了解后才能清楚地理解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n871&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们就来全面的了解一下 MySQL 的 join 操作。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n873&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n875&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在日常数据库查询时，我们经常要对多表进行连表操作来一次性获得多个表合并后的数据，这是就要使用到数据库的 join 语法。join 是在数据领域中十分常见的将两个数据集进行合并的操作，如果大家了解的多的话，会发现 MySQL，Oracle，PostgreSQL 和 Spark 都支持该操作。本篇文章的主角是 MySQL，下文没有特别说明的话，就是以 MySQL 的 join 为主语。而 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Oracle ，PostgreSQL 和 Spark 则可以算做将其吊打的大boss，其对 join 的算法优化和实现方式都要优于 MySQL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n876&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n877&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MySQL 的 join 有诸多规则，可能稍有不慎，可能一个不好的 join 语句不仅会导致对某一张表的全表查询，还有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;可能会影响数据库的缓存，导致大部分热点数据都被替换出去，拖累整个数据库性能。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n878&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n879&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;所以，业界针对 MySQL 的 join 总结了很多规范或者原则，比如说小表驱动大表和禁止三张表以上的 join 操作。下面我们会依次介绍 MySQL join 的算法，和 Oracle 和 Spark 的 join 实现对比，并在其中穿插解答为什么会形成上述的规范或者原则。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n880&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n881&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;对于 join 操作的实现，大概有 Nested Loop Join (循环嵌套连接)，Hash Join(散列连接) 和 Sort Merge Join(排序归并连接) 三种较为常见的算法&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;，它们各有优缺点和适用条件，接下来我们会依次来介绍。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n886&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;MySQL 中的 Nested Loop Join 实现&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n887&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Nested Loop Join 是扫描驱动表，每读出一条记录，就根据 join 的关联字段上的索引去被驱动表中查询对应数据。它适用于被连接的数据子集较小的场景，它也是 MySQL join 的唯一算法实现，关于它的细节我们接下来会详细讲解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n888&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MySQL 中有两个 Nested Loop Join 算法的变种，分别是 Index Nested-Loop Join 和 Block Nested-Loop Join。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n889&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Index Nested-Loop Join 算法&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n890&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们先来初始化一下相关的表结构和数据&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n892&quot; mdtype=&quot;fences&quot;&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;CREATE TABLE `t1` (&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `id` int(11) NOT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `a` int(11) DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `b` int(11) DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  KEY `a` (`a`)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;) ENGINE=InnoDB;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;delimiter ;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 定义存储过程来初始化t1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;create procedure init_data()&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;begin&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  declare i int;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  set i=1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  while(i&amp;lt;=10000)do&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    insert into t1 values(i, i, i);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    set i=i+1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  end while;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;end;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;delimiter ;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 调用存储过来来初始化t1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;call init_data();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 创建并初始化t2&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;create table t2 like t1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;insert into t2 (select * from t1 where id&amp;lt;=500)&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n893&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;有上述命令可知，这两个表都有一个主键索引 id 和一个索引 a，字段 b 上无索引。存储过程 init_data 往表 t1 里插入了 10000 行数据，在表 t2 里插入的是 500 行数据。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1079&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n894&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;为了避免 MySQL 优化器会自行选择表作为驱动表，影响分析 SQL 语句的执行过程，我们直接使用 straight_join 来让 MySQL 使用固定的连接表顺序进行查询，如下语句中，t1是驱动表，t2是被驱动表。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n895&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select * from t2 straight_join t1 on (t2.a=t1.a);&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用我们之前&lt;a spellcheck=&quot;false&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247484242&amp;amp;idx=1&amp;amp;sn=119c2972357d57b6575fb790f8a25a4d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;文章&lt;/span&gt;&lt;/a&gt;介绍的 explain 命令查看一下该语句的执行计划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNMUcEv1V6eIjpqaW4icDC63FvAiabuGyzgO8337XeTs3Sa65QuGK9uzHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n898&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;从上图可以看到，t1 表上的 a 字段是由索引的，join 过程中使用了该索引，因此该 SQL 语句的执行流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这个流程我们就称之为 Index Nested-Loop Join，简称 NLJ，它对应的流程图如下所示。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n909&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.remcarpediem.net/2020-11-10-145533.png&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNb59c86YWzMkWQVz1TlE7MJnolPNGicibyRKuf1bT1yWKZFlmtVMxSgOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6940418679549114&quot; data-w=&quot;621&quot;/&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n910&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要注意的是，在第二步中，根据 a 字段去表t1中查询时，使用了索引，所以每次扫描只会扫描一行(从explain结果得出，根据不同的案例场景而变化)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n911&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n912&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;假设驱动表的行数是N，被驱动表的行数是 M。因为在这个 join 语句执行过程中，驱动表是走全表扫描，而被驱动表则使用了索引，并且驱动表中的每一行数据都要去被驱动表中进行索引查询，所以整个 join 过程的近似复杂度是 N&lt;em&gt;2&lt;/em&gt;log2M。显然，N 对扫描行数的影响更大，因此这种情况下应该让小表来做驱动表。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n913&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n914&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然，这一切的前提是 join 的关联字段是 a，并且 t1 表的 a 字段上有索引。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n915&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果没有索引时，再用上图的执行流程时，每次到 t1 去匹配的时候，就要做一次全表扫描。这也导致整个过程的时间复杂度编程了 N * M，这是不可接受的。所以，当没有索引时，MySQL 使用 Block Nested-Loop Join 算法。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n917&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Block Nested-Loop Join&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n919&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Block Nested-Loop Join的算法，简称 BNL，它是 MySQL 在被驱动表上无可用索引时使用的 join 算法，其具体流程如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n926&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;比如下面这条 SQL&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n927&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select * from t2 straight_join t1 on (t2.b=t1.b);&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n928&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这条语句的 explain 结果如下所示。可以看出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNMlI7EH23UYB3ACyuR4UOmHfvfMkC9cmxf59qlR238Hp6L9Ql9mmzAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n929&quot; mdtype=&quot;paragraph&quot;&gt;可以看出，这次 join 过程对 t1 和 t2 都做了一次全表扫描，并且将表 t2 中的 500 条数据全部放入内存 join_buffer 中，并且对于表 t1 中的每一行数据，都要去 join_buffer 中遍历一遍，都要做 500 次对比，所以一共要进行 500 * 10000 次内存对比操作，具体流程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8668885191347754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNe5TjXlIrqNqubPg6jU2rbKuIUZUibf3LHgH77JFbmzMATlJQAia6x7TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n933&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;主要注意的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;第一步中，并不是将表 t2 中的所有数据都放入 join_buffer，而是根据具体的 SQL 语句，而放入不同行的数据和不同的字段&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;比如下面这条 join 语句则只会将表 t2 中符合 b &amp;gt;= 100 的数据的 b 字段存入 join_buffer。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n934&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select t2.b,t1.b from t2 straight_join t1 on (t2.b=t1.b) where t2.b &amp;gt;= 100;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n935&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;join_buffer 并不是无限大的，由 join_buffer_size 控制，默认值为 256K。当要存入的数据过大时，就只有分段存储了，整个执行过程就变成了：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n936&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n938&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;扫描表 t2，将符合条件的数据行存入 join_buffer，因为其大小有限，存到100行时满了，则执行第二步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n940&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;扫描表 t1，每取出一行数据，就跟 join_buffer 中的数据进行对比，满足 join 条件的，则放入结果集；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n942&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;清空 join_buffer；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n944&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;再次执行第一步，直到全部数据被扫描完，由于 t2 表中有 500行数据，所以一共重复了 5次&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n945&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这个流程体现了该算法名称中 Block 的由来，分块去执行 join 操作。因为表 t2 的数据被分成了 5 次存入 join_buffer，导致表 t1 要被全表扫描 5次。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n946&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n947&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n949&quot; mdtype=&quot;table_cell&quot;&gt;全部存入&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n950&quot; mdtype=&quot;table_cell&quot;&gt;分5次存入&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n951&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n952&quot; mdtype=&quot;table_cell&quot;&gt;内存操作&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n953&quot; mdtype=&quot;table_cell&quot;&gt;10000 * 500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n954&quot; mdtype=&quot;table_cell&quot;&gt;10000 * (100 * 5)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n955&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n956&quot; mdtype=&quot;table_cell&quot;&gt;扫描行数&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n957&quot; mdtype=&quot;table_cell&quot;&gt;10000 + 500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n958&quot; mdtype=&quot;table_cell&quot;&gt;10000 *  5 + 500&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n963&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如上所示，和表数据可以全部存入 join_buffer 相比，内存判断的次数没有变化，都是两张表行数的乘积，也就是 10000 * 500，但是被驱动表会被多次扫描，每多存入一次，被驱动表就要扫描一遍，影响了最终的执行效率。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n964&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n965&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于上述两种算法，我们可以得出下面的结论，这也是网上大多数对 MySQL join 语句的规范。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n971&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n972&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;因为上述两个 join 算法的时间复杂度&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;至少&lt;/span&gt;&lt;/strong&gt;也和涉及表的行数成一阶关系，并且要花费大量的内存空间，所以阿里开发者规范所说的严格禁止三张表以上的 join 操作也是可以理解的了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n973&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但是上述这两个算法只是 join 的算法之一，还有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;更加高效的 join 算法，比如 Hash Join 和 Sorted Merged join。可惜这两个算法 MySQL 的主流版本中目前都不提供，而 Oracle ，PostgreSQL 和 Spark 则都支持，这也是网上吐槽 MySQL 弱爆了的原因&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;(MySQL 8.0 版本支持了 Hash join，但是8.0目前还不是主流版本)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n974&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;其实阿里开发者规范也是在从 Oracle 迁移到 MySQL 时，因为 MySQL 的 join 操作性能太差而定下的禁止三张表以上的 join 操作规定的 。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n975&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Hash Join 算法&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n976&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Hash Join 是扫描驱动表，利用 join 的关联字段在内存中建立散列表，然后扫描被驱动表，每读出一行数据，并从散列表中找到与之对应数据。它是大数据集连接操时的常用方式，适用于驱动表的数据量较小，可以放入内存的场景，它对于&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;没有索引的大表&lt;/span&gt;&lt;/strong&gt;和并行查询的场景下能够提供最好的性能。可惜它只适用于等值连接的场景，比如 on a.id = where b.a_id。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1083&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;还是上述两张表 join 的语句，其执行过程如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8668885191347754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNicswJwpEaHDncHQsERVxIrXFHb6CQtkY6IDIudygG9oAWy5ibRoZU4sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n977&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以看出，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;该算法和 Block Nested-Loop Join 有类似之处，只不过是将无序的 Join Buffer 改为了散列表 hash table，从而让数据匹配不再需要将 join buffer 中的数据全部遍历一遍，而是直接通过 hash，以接近 O(1) 的时间复杂度获得匹配的行&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，这极大地提高了两张表的 join 速度。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不过由于 hash 的特性，该算法只能适用于等值连接的场景，其他的连接场景均无法使用该算法。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n978&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Sorted Merge Join 算法&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n979&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Sort Merge Join 则是先根据 join 的关联字段将两张表排序(如果已经排序好了，比如字段上有索引则不需要再排序)，然后在对两张表进行一次归并操作。如果两表已经被排过序，在执行排序合并连接时不需要再排序了，这时Merge Join的性能会优于Hash Join。Merge Join可适于于非等值Join（&amp;gt;，&amp;lt;，&amp;gt;=，&amp;lt;=，但是不包含!=，也即&amp;lt;&amp;gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要注意的是，如果连接的字段已经有索引，也就说已经排好序的话，可以直接进行归并操作，但是如果连接的字段没有索引的话，则它的执行过程如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5522388059701493&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNuUTmPgYY5IRfnuNEBesMVktGMzHwHvNEjJm35FB3K41zlF1LGqgdtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n1119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Sorted Merge Join 算法的主要时间消耗在于对两个表的排序操作，所以如果两个表已经按照连接字段排序过了，该算法甚至比 Hash Join 算法还要快。在一边情况下，该算法是比 Nested Loop Join 算法要快的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n980&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们来总结一下上述三种算法的区别和优缺点。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n982&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n983&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n985&quot; mdtype=&quot;table_cell&quot;&gt;Nested Loop Join&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n986&quot; mdtype=&quot;table_cell&quot;&gt;Hash Join&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n987&quot; mdtype=&quot;table_cell&quot;&gt;Sorted Merge Join&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n988&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n989&quot; mdtype=&quot;table_cell&quot;&gt;连接条件&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n990&quot; mdtype=&quot;table_cell&quot;&gt;适用于任何条件&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n991&quot; mdtype=&quot;table_cell&quot;&gt;只适用于等值连接（=）&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n992&quot; mdtype=&quot;table_cell&quot;&gt;等值或非等值连接(&amp;gt;，&amp;lt;，=，&amp;gt;=，&amp;lt;=)，‘&amp;lt;&amp;gt;’除外&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n993&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n994&quot; mdtype=&quot;table_cell&quot;&gt;主要消耗资源&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n995&quot; mdtype=&quot;table_cell&quot;&gt;CPU、磁盘I/O&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n996&quot; mdtype=&quot;table_cell&quot;&gt;内存、临时空间&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n997&quot; mdtype=&quot;table_cell&quot;&gt;内存、临时空间&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n998&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n999&quot; mdtype=&quot;table_cell&quot;&gt;特点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1000&quot; mdtype=&quot;table_cell&quot;&gt;当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1001&quot; mdtype=&quot;table_cell&quot;&gt;当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。通常比 Merge Join 快。在数据仓库环境下，如果表的纪录数多，效率高&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1002&quot; mdtype=&quot;table_cell&quot;&gt;当缺乏索引或者索引条件模糊时，Sort Merge Join 比 Nested Loop 有效。当连接字段有索引或者提前排好序时，比 hash join 快，并且支持更多的连接条件&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1003&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1004&quot; mdtype=&quot;table_cell&quot;&gt;缺点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1005&quot; mdtype=&quot;table_cell&quot;&gt;无索引或者表记录多时效率低&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1006&quot; mdtype=&quot;table_cell&quot;&gt;建立哈希表需要大量内存，第一次的结果返回较慢&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1007&quot; mdtype=&quot;table_cell&quot;&gt;所有的表都需要排序。它为最优化的吞吐量而设计，并且在结果没有全部找到前不返回数据&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1008&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1009&quot; mdtype=&quot;table_cell&quot;&gt;需要索引&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1010&quot; mdtype=&quot;table_cell&quot;&gt;是(没有索引效率太差)&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1011&quot; mdtype=&quot;table_cell&quot;&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1012&quot; mdtype=&quot;table_cell&quot;&gt;否&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 cid=&quot;n1020&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;对于 Join 操作的理解&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n1022&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;讲完了 Join 相关的算法，我们这里也聊一聊对于 join 操作的业务理解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1023&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在业务不复杂的情况下，大多数join并不是无可替代。比如订单记录里一般只有订单用户的 user_id，返回信息时需要取得用户姓名，可能的实现方案有如下几种：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1024&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1026&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一次数据库操作，使用  join 操作，订单表和用户表进行 join，连同用户名一起返回；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1028&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;两次数据库操作，分两次查询，第一次获得订单信息和 user_id，第二次根据 user_id 取姓名，使用代码程序进行信息合并；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1030&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用冗余用户名称或者从 ES 等非关系数据库中读取。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1036&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上述方案都能解决数据聚合的问题，而且基于程序代码来处理，比数据库 join 更容易调试和优化，比如取用户姓名不从数据库中取，而是先从缓存中查找。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1043&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1045&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然， join 操作也不是一无是处，所以技术都有其使用场景，&lt;/span&gt;&lt;span&gt;上边这些方案或者规则都是互联网开发团队总结出来的，适用于高并发、轻写重读、分布式、业务逻辑简单的情况，这些场景一般对数据的一致性要求都不高，甚至允许脏读&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1046&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但是，&lt;/span&gt;&lt;span&gt;在金融银行或者财务等企业应用场景，join 操作则是不可或缺的&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，这些应用一般都是低并发、频繁复杂数据写入、CPU密集而非IO密集，主要业务逻辑通过数据库处理甚至包含大量存储过程、对一致性与完整性要求很高的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注我&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5075921908893709&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtehL5KdOC0Uib7CdHkxwGibQdibjs4kC3FpEO9ehCCjHwFa1ZSS8QoEgb9AtomP8cDZmz8jC1gR8qvzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>67e1209d3291219d76675a9c7bbc0be5</guid>
<title>[推荐] 技术人员该如何接手一个复杂的系统？吐血推荐这几招</title>
<link>https://toutiao.io/k/yyjv3sj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;23&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;阅读本文大概需要 5 分钟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为程序员，无论是小菜还是老鸟，都会因为离职交接或者岗位异动等各种原因，而避免不了要如羚羊奔跑版的速度接手一个复杂业务系统。&lt;/span&gt;&lt;span&gt;因为只有尽快熟悉系统，方能够快速支持业务需求的研发。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，问题就来了？面对一个一无所知的复杂的系统，我们该如何入手呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文将结合菜菜同学多年来的沉（经）淀（验），再融合&lt;/span&gt;&lt;span&gt;老中医望闻问切的招式，吐血整理成一副图和一剂&lt;span&gt;锦囊妙药，送给大家&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《一剂良药》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;菊花&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;」看文档，记疑惑。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;薄荷&lt;/span&gt;&lt;/span&gt;」串文档，理脉络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;莲&lt;span&gt;心&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;」讲系统，要知彼。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「&lt;span&gt;&lt;span&gt;荷叶&lt;/span&gt;&lt;/span&gt;」捋代码，了梗概。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;玄参&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」盘经验，&lt;/span&gt;&lt;span&gt;理大坑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;芦根&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」亲操刀，细解剖&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《一幅脑图》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;369&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.6787003610108303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOPZShy6w0VLYA9q4QG54aXkVo8OJ9MTP1IQmgia6C8Cia3VD4XlTLgAJc2icPNZADZOcngrGI5Bznsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1662&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第一招：&lt;span&gt;看文档，知脉略。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：望。望诊，是对病人的神、色、形、态、舌象等进行有目的的观察，以测知内脏病变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「望诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式一：&lt;/span&gt;&lt;span&gt;看&lt;/span&gt;&lt;span&gt;文档，知脉略&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个复杂的系统要交接到你手上时，理想中各种文档样样全，要啥有啥，而现实啪啪打脸。&lt;/span&gt;&lt;span&gt;多数情况下都没有文档，如果有一些文档可看，无论质量如何，都是一件值得庆幸的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果项目组比较规范，沉淀了一些入门文档、产品介绍文档、业务架构设计文档、数据库设计文档，那就更值得庆幸啦，静下来仔细去看，&lt;span&gt;通过文档多少会了解一些系统的前世今生，对系统有一个初步的认识。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，&lt;/span&gt;&lt;span&gt;当接手一个系统时，一定要看看文档在哪里？&lt;/span&gt;&lt;span&gt;是在 Wiki 上，还是在 SVN、Git 上，如若有文档的情况下，尽快找到它，并粗略的看一遍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看了这么多文档，肯定有太多的疑惑，先拿小本本记下来，制造机会请老鸟给你答疑解惑。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第二招：听细节&lt;/span&gt;&lt;span&gt;，聊全局。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：闻。闻诊，主要是听患者语言气息的高低、强弱、清浊、缓急……等变化，以分辨病情的虚实寒热。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「闻诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式二：&lt;/span&gt;&lt;span&gt;听细节，聊全局。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拿着你事先记录好满满疑惑的小本本，组个会议，喊上老鸟好好给你指点迷津。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，请老鸟串一串文档。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概理一理，然后把你之前小本本上的问题，一股脑抛出来当面请教。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后，请老鸟讲一讲系统。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概要了解一下系统的使用方是谁？&lt;/span&gt;&lt;span&gt;系统依赖的系统有哪些？系统&lt;/span&gt;&lt;span&gt;主要干&lt;/span&gt;&lt;span&gt;系&lt;/span&gt;&lt;span&gt;人有哪些？系统研发的需求来自于哪里？&lt;/span&gt;&lt;span&gt;最重要的是要请老鸟演示一下如何把系统跑起来？&lt;/span&gt;&lt;span&gt;跑起来后功能该怎么用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;最后，请老鸟捋一捋代码。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;大概捋一捋代码的设计，了解一下&lt;span&gt;主要分为几&lt;/span&gt;&lt;span&gt;大&lt;/span&gt;&lt;span&gt;块？&lt;/span&gt;程序入口在哪里？技术栈是啥样子？... ...&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第三招：&lt;/span&gt;&lt;span&gt;问疑难，解杂症。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：问。问诊，通过了解既往病史与家族病史、起病原因、发病经过及治疗过程，主要痛苦所在，自觉症状，饮食喜恶等情况，结合望、切、闻三诊，综合分析，作出判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「问诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式三：问疑难&lt;/span&gt;&lt;span&gt;，解杂症。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，问老鸟：要接手的系统，历史事故都发生过哪些？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为了&lt;/span&gt;&lt;span&gt;不贰过，要&lt;/span&gt;了解一下要接手的系统，历史的事故是代码问题，还是人祸导致的？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，问老鸟：要接手的系统，坑在哪里？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概了解一下老鸟以往趟过的那些坑，前车之鉴必是后车之师。&lt;/span&gt;&lt;span&gt;重点了解系统有哪块会有潜在的问题，当接手之后一定要细心着重对待，防患于未然。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第四招：亲操刀&lt;/span&gt;&lt;span&gt;，细解剖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老中医：切。切脉又称诊脉，是医者用手指按其腕后桡动脉搏动处，借以体察脉象变化，辨别脏腑功能盛衰，气血津精虚滞的一种方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;菜菜同学结合「切诊」而独创快速接手一个复杂系统之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;招式四：&lt;/span&gt;&lt;span&gt;亲操刀，细解剖。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过前面三种招式相结合，我们文档也看了，系统功能也了解了，历史事故也知道了，接下来要进入程序员最擅长区域——解剖代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先，加注释，加&lt;/span&gt;&lt;span&gt;关键日志。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找到程序入口，根据自己的理解，一步一步去加注释，&lt;span&gt;要&lt;/span&gt;&lt;span&gt;敢于&lt;/span&gt;&lt;span&gt;动手去&lt;/span&gt;&lt;span&gt;加，确定不了的，有疑问&lt;/span&gt;的用注释标记好，或者记个大大的问号，把你的想法理解都用注释记录一下，相信对代码的理解，一遍比一遍更透彻。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，除了加注释的一种方式，还推荐加关键日志，因为加入关键日志，不过日志最好有一些特色，例如都还有「haha：」，这样能够在子模块调用比较复杂的情形下，在项目启动后，根据加入日志文件，直接关注「haha：」就能把相关子系统的调用流程串在一起，屡试不爽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后，跑应用，Debug。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了加注释，加关键日志能够理解代码逻辑外，Debug 也是推荐的一种方式，从程序入口开始逐步进行调试，也会对代码有一个质的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仁者见仁智者见智，依据个人习惯，还是更推荐加日志，或许是因为 Debug 有些时候遇到反射或者库调用，跟着跟着就乱掉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里，建议一定要把应用跑起来，只有跑起来，才能根据之前加入的日志，梳理梳理系统调用关系，模块调用关系，再好好体验体验功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，画画图，善分享。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加日志、加注释、Debug 的事儿&lt;span/&gt;&lt;span&gt;多数铁子&lt;/span&gt;都干过，但是能把自己对代码的理解真心画下来的估计会很少，这块真心推荐大家没事的时候静下来画一画，是对代码理解质的一次提升，画出来才能理解的更透彻，更清晰，如果闲暇之余把上手系统的经过写成手册，相信对于后面接手的同事而言是一大笔“财富”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然了，除了画图、写手册还是不够的，重要的是能够拉几个同事进行分享一下，这样才能更快变成自己的知识，在这里忍不住要抛一张图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;383&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.7043918918918919&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOPZShy6w0VLYA9q4QG54aXcqRygDUGZ7A2oNeg0VBT6rLfvn7woyU2HqufDeia1Tv3Dp6KGz5JKnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，接手系统解剖代码这块放到最后一部分去谈，原因这块确实考验个人的技术能力，而且是一个长久的过程，需要慢慢去磨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;5&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;真心寄语&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次主要谈谈如何快速接手一个系统？&lt;/span&gt;&lt;span&gt;吐血推荐的一幅图和一剂药，如果有接手系统的困惑，而且没有更好的方法时，那不妨拿去实践，&lt;/span&gt;&lt;span&gt;屡试不爽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前路漫长，&lt;/span&gt;&lt;span&gt;人生实苦，每个人方法都不一样，条条大路通罗马，选择适合自己的。奔跑是追梦人的气质，用奋斗定义人生价值，在奔跑中抵达远方，铁子们加油💪。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好了，分享就到这里，希望对你有帮助。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;会持续输出原创精彩分享，敬请期待！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;198&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1710&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOwkpyEoA1IiakYviaHIX4GnoUHGE4kNCqHqAM54WmxryEd76E7Uf1xibO18pftGiafQqI8ibxqMHG34xA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247485536&amp;amp;idx=1&amp;amp;sn=4347aea8740973fea3346fb48e7efd97&amp;amp;chksm=fc00436dcb77ca7ba2c0fcc105c8adbf1c31f61fc6ed143b936fea806c973fdf37e169aeba61&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|技术人员该如何站好最后一班岗？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247485423&amp;amp;idx=1&amp;amp;sn=e74b30d0c5482e2b6f488901229698b5&amp;amp;chksm=fc004ce2cb77c5f419dabb40e9a237d892a3cf489741f4c5f87fc0d9f61d296c763f58cd4726&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|为什么要做有灵魂的程序员？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d96baa3f70e2b26025c911ff82d482e</guid>
<title>[推荐] 基于时间线的 Feed 流后台系统设计</title>
<link>https://toutiao.io/k/yy8cawz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;| 导语  &lt;/span&gt;&lt;span&gt;本文将总结一下常用的基于时间线Feed流的后台存储设计方案。结合具体的业务场景，讲述一下根据实际需求，在基本设计思路上做一些灵活运用。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;01&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Feed流产品在我们手机APP中几乎无处不在，常见的Feed流比如微信朋友圈、新浪微博、今日头条等。对Feed流的定义，可以简单理解为只要大拇指不停地往下划手机屏幕，就有一条条的信息不断涌现出来。就像给牲畜喂饲料一样，只要它吃光了就要不断再往里加，故此得名Feed（饲养）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大多数Feed流产品都包含两种Feed流，一种是基于算法推荐，另一种是基于关注（好友关系）。例如下图中的微博和知乎，顶栏的页卡都包含“关注”和“推荐”这两种。两种Feed流背后用到的技术差别会比较大。本文将重点探索一下“关注”页卡的后台实现方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.456&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAIicibFam6WcZxfibgMqWtSCHETM6ojOtmJjuWIEXLcYicicWPEsvFCZA9gOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来源:新浪微博&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5106666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAIjBgRzGj09712g4icG1kNeOXgvJnfhflF6UJlLfUbk3LFHwD3VBQ5qpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来源:知乎&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于“推荐”页卡那种千人前面算法推荐的方式，通常“关注”页卡所展示的内容先后顺序都有固定的规则，最常见的规则是基于时间线来排序，也就是展示“我关注的人所发的帖子，&lt;/span&gt;&lt;span&gt;根据发帖时间从晚到早依次排列&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;02&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;Feed流实现方案介绍&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方案1——读扩散&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读扩散也称为拉模式，这应该是最符合我们直觉的一种实现方式。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6164167324388319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIL5cG4Jib8ga3JFY696FHgX1qqd0icUjdAmqwVyLYbbmNUGvFJehZJicibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个内容发布者都有一个自己的发件箱（“我发布的内容”），每当我们发出一个新帖子，都存入自己的发件箱中。当我们的粉丝来阅读时，系统首先需要拿到粉丝关注的所有人，然后遍历所有发布者的发件箱，取出他们所发布的帖子，然后依据发布时间排序，展示给阅读者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种设计，阅读者&lt;/span&gt;&lt;span&gt;读一次&lt;/span&gt;&lt;span&gt;Feed流，后台&lt;/span&gt;&lt;span&gt;会扩散为N次读操作&lt;/span&gt;&lt;span&gt;（N等于关注的人数）以及一次聚合操作，因此称为读扩散。每次读Feed流相当于去关注者的收件箱主动拉取帖子，因此也得名拉模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种模式的好处是底层存储简单，没有空间浪费。坏处是每次读操作会非常重，操作非常多。设想一下如果我关注的人数非常多，遍历一遍我所关注的所有人，并且再聚合一下，这个系统开销会非常大，时延上可能达到无法忍受的地步。因此读扩散主要适用系统中阅读者关注的人没那么多，并且刷Feed流并不频繁的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拉模式还有一个比较大的缺点就是分页不方便，我们刷微博或朋友圈，肯定是随着大拇指在屏幕不断划动，内容一页一页的从后台拉取。如果不做其他优化，只采用实时聚合的方式，下滑到比较靠后的页码时会非常麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方案2——写扩散&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据统计，大多数Feed流产品的读写比大概在100:1，也就是说大部分情况都是刷Feed流看别人发的朋友圈和微博，只有很少情况是自己亲自发一条朋友圈或微博给别人看。因此，读扩散那种很重的读逻辑并不适合大多数场景。我们宁愿让发帖的过程复杂一些，也不愿影响用户读Feed流的体验，因此稍微改造一下前面方案就有了写扩散。写扩散也称为推模式，这种模式会对拉模式的一些缺点做改进。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6187845303867403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAI8h0GN9j2NxibTXRh7QNRWERy44BNJdt33ynsjvaIYTt8u2mcVSCibdrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统中每个用户除了有发件箱，也会有自己的收件箱。当发布者发表一篇帖子的时候，除了往自己发件箱记录一下之外，还会遍历发布者的所有粉丝，往这些粉丝的收件箱也投放一份相同内容。这样阅读者来读Feed流时，直接从自己的收件箱读取即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种设计，&lt;/span&gt;&lt;span&gt;每次发表帖子，都会扩散为M次写操作&lt;/span&gt;&lt;span&gt;（M等于自己的粉丝数），因此成为写扩散。每篇帖子都会主动推送到所有粉丝的收件箱，因此也得名推模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种模式可想而知，发一篇帖子，背后会涉及到很多次的写操作。通常为了发帖人的用户体验，当发布的帖子写到自己发件箱时，就可以返回发布成功。后台另外起一个异步任务，不慌不忙地往粉丝收件箱投递帖子即可。写扩散的好处在于通过数据冗余（一篇帖子会被存储M份副本），提升了阅读者的用户体验。通常适当的数据冗余不是什么问题，但是到了微博明星这里，完全行不通。比如目前微博粉丝量Top2的谢娜与何炅，两个人微博粉丝过亿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.40175219023779724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIoUYdzOIUVULHVicSdNk4iaXleaaZ9q4qpaicNvicPpBFB08NYnuciaVhwaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1598&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来源：&lt;/span&gt;&lt;span&gt;新浪&lt;/span&gt;&lt;span&gt;微博&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设想一下，如果单纯采用推模式，那每次谢娜何炅发一条微博，微博后台都要地震一次。一篇微博导致后台上亿次写操作，这显然是不可行的。另外由于写扩散是异步操作，写的太慢会导致帖子发出去半天，有些粉丝依然没能看见，这种体验也不太好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常写扩散适用于好友量不大的情况，据悉微信朋友圈正是写扩散模式。每一名微信用户的好友上限为5000人，也就是说你发一条朋友圈最多也就扩散到5000次写操作，如果异步任务性能好一些，完全没有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方案3——读写混合模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写混合也可以称作推拉结合。这种方式可以兼具读扩散和写扩散的优点。我们首先来总结一下读扩散和写扩散的优缺点：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读扩散&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;节约存储空间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发帖操作简单&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读帖操作复杂&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注人数多时是灾难&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;用户不活跃，很少读帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有大V粉丝量多，但每个粉丝关注的人少&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写扩散&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读帖操作简单&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;发帖操作复杂，浪费存储空间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大V粉丝量多时是灾难&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;用户非常活跃，经常刷帖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无大V，用户粉丝量都比较少&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仔细比较一下读扩散与写扩散的优缺点，不难发现两者的适用场景是互补的。因此在设计后台存储的时候，我们如果能够区分一下场景，在不同场景下选择最适合的方案，并且动态调整策略，就实现了读写混合模式。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5511811023622047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIRmT9V432l0mAtDhycHicnM3ia1HFo8I00jqt17Xodz292xr7cOXh8FTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当何炅这种粉丝量超大的人发帖时，将帖子写入何炅的发件箱，另外提取出来何炅粉丝当中比较活跃的那一批（这已经可以筛掉大部分了），将何炅的帖子写入他们的收件箱。当一个粉丝量很小的路人甲发帖时，采用写扩散方式，遍历他的所有粉丝并将帖子写入粉丝收件箱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于那些活跃用户登录刷Feed流时，他直接从自己的收件箱读取帖子即可，保证了活跃用户的体验。当一个非活跃的用户突然登录刷Feed流时，我们一方面需要读他的收件箱，另一方面需要遍历他所关注的大V用户的发件箱提取帖子，并且做一下聚合展示。在展示完后，系统还需要有个任务来判断是否有必要将该用户升级为活跃用户。因为有读扩散的场景存在，因此即使是混合模式，每个阅读者所能关注的人数也要设置上限，例如新浪微博限制每个账号最多可以关注2000人。如果不设上限，设想一下有一位用户把微博所有账号全部关注了，那他打开关注列表会读取到微博全站所有帖子，一旦出现读扩散，系统必然崩溃；即使是写扩散，他的收件箱也无法容纳这么多的微博。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写混合模式下，系统需要做两个判断。一个是哪些用户属于大V，我们可以将粉丝量作为一个判断指标。另一个是哪些用户属于活跃粉丝，这个判断标准可以是最近一次登录时间等。这两处判断标准就需要在系统发展过程中动态地识别和调整，没有固定公式了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出读写结合模式综合了两种模式的优点，属于最佳方案。然而他的缺点是系统机制非常复杂，给程序员带来无数烦恼。通常在项目初期，只有一两个开发人员，用户规模也很小的时候，一步到位地采用这种混合模式还是要慎重，容易出bug。当项目规模逐渐发展到新浪微博的水平，有一个大团队专门来做Feed流时，读写混合模式才是必须的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Feed流中的分页问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;前文已经叙述了基于时间线的Feed流常见设计方案，但实操起来会比理论要麻烦许多。接下来专门讨论一个困难点——Feed流的分页。不管是读扩散还是写扩散，Feed流本质上是一个动态列表，列表内容会随着时间不断变化。传统的前端分页参数使用page_size和page_num，分表表示每页几条，以及当前是第几页。对于一个动态列表会有如下问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.37381703470031546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIwX6v94mT3bOJmd8GBM0Lms3pul0ZcmfrcRGNtFkNVeePoicNy9CY6sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在T1时刻读取了第一页，T2时刻有人新发表了“内容11”，在T3时刻如果来拉取第二页，会导致错位出现，“内容6”在第一页和第二页都被返回了。事实上，但凡两页之间出现内容的添加或删除，都会导致错位问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决这一问题，通常Feed流的分页入参不会使用page_size和page_num，而是使用last_id来记录上一页最后一条内容的id。前端读取下一页的时候，必须将last_id作为入参，后台直接找到last_id对应数据，再往后偏移page_size条数据，返回给前端，这样就避免了错位问题。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.37381703470031546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIroJl1axDODe9VbQboNEah3iaACDkDEVFrjHtZYWnMQH7xDQicQqBDsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用last_id的方案有一个重要条件，就是last_id本身这条数据不可以被硬删除。设想一下上图中T1时刻返回5条数据，last_id为内容6；T2时刻内容6被发布者删除；那么T3时刻再来请求第二页，我们根本找不到last_id对应的数据了，也就无法确认分页偏移量。通常碰到删除的场景，我们采用软删除方式，只是在内容上置一个标志位，表示内容已删除。由于已经删除的内容不应该再返回给前端，因此软删除模式下，找到last_id并往后偏移page_size条，如果其中有被删除的数据会导致获得足够的数据条数给前端。这里一个解决方案是找不够继续再往下找，另一种方案是与前端协商，允许返回条数少于page_size条，page_size只是个建议值。甚至大家约定好了以后，可以不要page_size参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;03&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;实际业务应用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务需求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章最后结合我们自身业务，介绍一下实际业务场景中碰到的一个非常特殊的Feed流设计方案。直享直播是一款直播带货工具，主播可以创建一场未来时刻的直播，到时间后开播卖货，直播结束后，主播的粉丝可以查看直播回放。这样，每个直播场次就有三种状态——预告中（创建一场直播但还未开播）、直播中、回放。作为观众，我可以关注多位主播，这样从粉丝视角来看，也会有个直播场次的Feed流页面。这个Feed流最特殊的地方在于它的Feed流排序规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.8639652677279306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIUzQUWrk9GTu9iblPtjCrUicqfSJuoDss4HXPTkjJXWkBZhBXsUiczgiawg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Feed流排序规则：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.我关注的所有主播，正在直播中的场次排在最前；预告中的场次排中间；回放场次排最后&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.多场次都在直播中的，按开播时间从晚到早排序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.多场次都在预告中的，按预计开播时间从早到晚排序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.多场次都在回放的，按直播结束时间从晚到早排序&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;04&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;问题分析&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本需求最复杂的点在于Feed流内容融入的“状态”因素，状态的转变会直接导致Feed流顺序不同。为了更清晰解释一下对排序的影响，我们可以用下图详细说明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.53836784409257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAIorRoCC7yjzlcKOvSz6ia4NOxOXRCiaGEwLGIjHqHrNcDmvNqKMStncyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图中展示了4个主播的5个直播场次，作为观众，当我在T1时刻打开页面，看到的顺序是场次3在最上方，其余场次均在预告状态，按照预计开播时间从早到晚展示。当我在T2时刻打开页面，场次5在最上方，其余有三场在预告状态排在中间，场次3已经结束了所以排在最后。以此类推，直到所有直播都结束，所有场次最终的状态都会变为回放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里需要注意一点，如果我在T1时刻打开第一页，然后盯着页面不动，一直盯到T4时刻再下划到第二页，这时上一页的last_id，即分页偏移量很有可能因为直播状态变化而不知道飞到了什么位置，这会导致严重的&lt;/span&gt;&lt;span&gt;错位问题&lt;/span&gt;&lt;span&gt;，以及直播&lt;/span&gt;&lt;span&gt;状态展示不统一&lt;/span&gt;&lt;span&gt;的问题（第一页展示的是T1时刻的直播状态，第二页展示的是T4时刻的直播状态）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;05&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直播系统是个单向关系链，和微博有些类似，&lt;/span&gt;&lt;span&gt;每个观众会关注少量主播，每个主播会可能有非常多的关注者&lt;/span&gt;&lt;span&gt;。由于有状态变化的存在，写扩散几乎无法实现。因为如果采用写扩散的方式，每次主播创建直播、直播开播、直播结束这三个事件发生时导致的场次状态变化，会扩散为非常多次的写操作，不仅操作复杂，时延上也无法接受。微博之所以可以写扩散，就是因为一篇帖子发出后，这篇帖子就不会再有任何影响排序的状态转变。在我们场景中，“预告中”与“直播中”是两个中间态，而“回放”状态才是所有直播的最终归宿，一旦进入回放，这场直播也就不会再有状态转变。因此“&lt;/span&gt;&lt;span&gt;直播中&lt;/span&gt;&lt;span&gt;”与“&lt;/span&gt;&lt;span&gt;预告中&lt;/span&gt;&lt;span&gt;”状态可以采用&lt;/span&gt;&lt;span&gt;读扩散&lt;/span&gt;&lt;span&gt;方式，“&lt;/span&gt;&lt;span&gt;回放&lt;/span&gt;&lt;span&gt;”状态采取写扩散方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终的方案如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.793538219070134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwia2nukSP19wlR1UA1MexAItHotS8G6SI3I7r4QKksicQyIG3hUJuwib6wk6mha132v0FI1NK1uRAmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会影响直播状态的三种事件（创建直播、开播、结束直播）全部采用监听队列异步处理。我们为每一位主播维护一个直播中+预告中状态的优先级队列。每当监听到有主播创建直播时，将直播场次加入队列中，得分为开播的时间戳的相反数（负数）。每当监听到有主播开播时，把这场直播在队列中的得分修改为开播时间（正数）。每当监听到有主播结束直播，则异步地将播放信息投递到每个观众的回放队列中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有一个小技巧，前文提到，直播中状态按照开播时间从大到小排序，而预告中状态则按照开播时间从小到大排序，因此如果将预告中状态的得分全部取开播时间相反数，那排序同样就成为了从大到小。这样的转化可以保证直播中与预告中同处于一个队列排序。&lt;/span&gt;&lt;span&gt;预告中得分全都为负数，直播中得分全都为正数&lt;/span&gt;&lt;span&gt;，最后聚合时可以保证所有直播中全都自然排在预告中前面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外前文还提到的另一个问题是T1时刻拉取第一页，T4时刻拉取第二页，导致第一页和第二页直播间状态不统一。解决这个问题的办法是通过快照方式。当观众来拉取第一页Feed流时，我们依据当前时间，将全部直播中和预告中状态的场次建立一份快照，使用一个session_id标识，每次前端分页拉取时，我们直接从快照中读取即可。如果快照中读取完毕，证明该观众的直播中和预告中场次全部读完，剩下的则使用回放队列进行补充。照此一来，我们的Feed流系统，前端分页拉取的参数一共有4个：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;值来源&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读第一页时参数值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;session_id&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;快照队列ID，从该快照中读取直播中和预告中场次&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页返回值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;空字符串&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;last_id&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页读取到哪一场直播&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页返回值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;空字符串&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;state&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;枚举值0或1，表示last_id处于快照队列还是回放队列&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;上一页返回值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;page_size&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;每页建议读几条&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;前后端约定&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;10&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每当碰到session_id和last_id为空，则证明用户想要读取第一页，需要重新构建快照。这里还有一个衍生问题，session_id的如何取值？如果不考虑同一个观众在多端登录的情况，其实每一位观众维护一个快照id即可，也就是直接将系统用户id设为session_id；如果考虑多端登录的情况，则session_id中必须包含每个端的信息，以避免多端快照相互影响；如果不心疼内存，也可以每次随机一个字符串作为session_id，并设置一个足够长的过期时间，让快照自然过期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上设计，其实系统计算量最大的时刻就是拉取第一页，构建快照的开销。目前的线上数据，对于只关注不到10个主播的观众（这也是大多数场景），拉取第一页的QPS可以达到1.5万。如果将第二页以后的请求也算进来，Feed流的综合QPS可以达到更高水平，支撑目前的用户规模已经绰绰有余。如果我们拉取第一页时只获取到前10条即可直接返回，将构建快照操作改为异步，也许QPS可以更高一些，这可能是后续的优化点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;06&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读扩散、写扩散、读写混合，几乎所有基于时间线和关注关系的Feed流都逃不开这三种基本设计模式。具体到实际业务中，可能会有更复杂的场景，比如本文所说的状态流转影响排序，微博朋友圈场景中也会有广告接入、特别关注、热点话题等可能影响到Feed流排序的因素。这些场景就只能根据业务需求，做相对应的变通了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-id=&quot;92805&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;▼&lt;/strong&gt;&lt;strong&gt;近期热文&lt;/strong&gt;&lt;strong&gt;▼&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot; data-width=&quot;96%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECzSiakZVZkZxlxohbG68ZFCdgNxc2bfc9oVunDD0Cjt7pUTq3KLernrgXM4Tnxiaibx301wyMsAyqicOQ/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;11.35135135135135&quot; data-cropy2=&quot;347.027027027027&quot; data-ratio=&quot;0.37333333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAImuO8icLYWczZtjAJ5tQQW1eRfobWnRmlic6zMqkoUooFgu30Tnibtadbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户访谈（一）：如何做好访谈前的准备工作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwFiaxZanicXILIU67ZkN6Pftibibw8RappAvsfEfYvL3jMAnqY7nplPYJ1T7SR6qSBU2APWG4TqLU0rA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;29.584775086505182&quot; data-cropy2=&quot;348.78892733564004&quot; data-ratio=&quot;0.35444444444444445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECwia2nukSP19wlR1UA1MexAI54vROEMyGibgt1ibcqIwI3lcmU86WsOaJoicETZxglOIorLGXgbsaLsCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot; data-width=&quot;96%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;用户访谈（二）：如何进行一场有效的访谈？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MTEwNTM0ODI0MQ==&amp;amp;mid=2653449418&amp;amp;idx=1&amp;amp;sn=ad1ea98489213b88560d9c382174bcde&amp;amp;chksm=72017d344576f422956ea79c32c6d1486d2a156dcdce625fa5c8f67914aa68ca4dedb42ad3d0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jiboYA4jZECwiazRb3mtLO3KVYmGzmGwVsiblicTCHDEyuaZT14iaWmnz8wMA3xliaQTQFBxbf7UeEAf4zT6E067ZDYQ/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;17.837837837837835&quot; data-cropy2=&quot;353.5135135135135&quot; data-ratio=&quot;0.37333333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jiboYA4jZECzSiakZVZkZxlxohbG68ZFCdf0Kp77J5tGRmJIoHcYk7qecIOboTQRm8H9C8te6x4U51J3dHjicpJ3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MTEwNTM0ODI0MQ==&amp;amp;mid=2653449418&amp;amp;idx=1&amp;amp;sn=ad1ea98489213b88560d9c382174bcde&amp;amp;chksm=72017d344576f422956ea79c32c6d1486d2a156dcdce625fa5c8f67914aa68ca4dedb42ad3d0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;渠道质量评估模型&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;渠道质量评估模型&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94901&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.65625&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot; data-backw=&quot;677&quot; data-backh=&quot;444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jiboYA4jZECyg5asa7YvWj9MVdwpMRfiaugTX0ZODtYicibgG6lAqia17L773UTuFHTTlz8rsec5Qhp3OzYffibD2YUg/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;喜欢本文？快点“在看”支持一下&lt;/span&gt;&lt;img data-ratio=&quot;0.43902439024390244&quot; data-type=&quot;gif&quot; data-w=&quot;41&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jiboYA4jZECzfiag8ibXkV6v69AiaeWjmU9ic1nKbfLjPibRx0CSMt87FJz2ibeFibOuhS7Fe3QKa46qulB8HYbjOtfaBA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>96745a693e4f07817eb94d89cda83ee7</guid>
<title>[推荐] 自定义注解！绝对是程序员装逼的利器</title>
<link>https://toutiao.io/k/gnbzbuw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;相信很多人对Java中的注解都很熟悉，比如我们经常会用到的一些如@Override、@Autowired、@Service等，这些都是JDK或者诸如Spring这类框架给我们提供的。&lt;/p&gt;
&lt;p&gt;在以往的面试过程中，我发现，关于注解的知识很多程序员都仅仅停留在使用的层面上，很少有人知道注解是如何实现的，更别提使用自定义注解来解决实际问题了。&lt;/p&gt;
&lt;p&gt;但是其实，我觉得一个好的程序员的标准就是懂得如何优化自己的代码，那在代码优化上面，如何精简代码，去掉重复代码就是一个至关重要的话题，在这个话题领域，自定义注解绝对可以算得上是一个大大的功臣。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;在我看来，会使用自定义注解 ≈ 好的程序员。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，本文，就来介绍几个，作者在开发中实际用到的几个例子，向你介绍下如何使用注解来提升你代码的逼格。&lt;/p&gt;
&lt;h3&gt;基本知识&lt;/h3&gt;
&lt;p&gt;在Java中，注解分为两种，元注解和自定义注解。&lt;/p&gt;
&lt;p&gt;很多人误以为自定义注解就是开发者自己定义的，而其它框架提供的不算，但是其实上面我们提到的那几个注解其实都是自定义注解。&lt;/p&gt;
&lt;p&gt;关于”元”这个描述，在编程世界里面有都很多，比如”元注解”、”元数据”、”元类”、”元表”等等，这里的”元”其实都是从meta翻译过来的。&lt;/p&gt;
&lt;p&gt;一般我们把&lt;strong&gt;元注解理解为描述注解的注解&lt;/strong&gt;，&lt;strong&gt;元数据理解为描述数据的数据&lt;/strong&gt;，&lt;strong&gt;元类理解为描述类的类&lt;/strong&gt;…&lt;/p&gt;
&lt;p&gt;所以，在Java中，除了有限的几个固定的”描述注解的注解”以外，所有的注解都是自定义注解。&lt;/p&gt;
&lt;p&gt;在JDK中提供了4个标准的用来对注解类型进行注解的注解类（元注解），他们分别是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target
@Retention
@Documented
@Inherited
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了以上这四个，所有的其他注解全部都是自定义注解。&lt;/p&gt;
&lt;p&gt;这里不准备深入介绍以上四个元注解的作用，大家可以自行学习。&lt;/p&gt;
&lt;p&gt;本文即将提到的几个例子，都是作者在日常工作中真实使用到的场景，这例子有一个共同点，那就是都用到了Spring的AOP技术。&lt;/p&gt;
&lt;p&gt;什么是AOP以及他的用法相信很多人都知道，这里也就不展开介绍了。&lt;/p&gt;
&lt;h3&gt;使用自定义注解做日志记录&lt;/h3&gt;
&lt;p&gt;不知道大家有没有遇到过类似的诉求，就是希望在一个方法的入口处或者出口处做统一的日志处理，比如记录一下入参、出参、记录下方法执行的时间等。&lt;/p&gt;
&lt;p&gt;如果在每一个方法中自己写这样的代码的话，一方面会有很多代码重复，另外也容易被遗漏。&lt;/p&gt;
&lt;p&gt;这种场景，就可以使用自定义注解+切面实现这个功能。&lt;/p&gt;
&lt;p&gt;假设我们想要在一些web请求的方法上，记录下本次操作具体做了什么事情，比如新增了一条记录或者删除了一条记录等。&lt;/p&gt;
&lt;p&gt;首先我们自定义一个注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Operate Log 的自定义注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface OpLog {

    /**
     * 业务类型，如新增、删除、修改
     *
     * @return
     */
    public OpType opType();

    /**
     * 业务对象名称，如订单、库存、价格
     *
     * @return
     */
    public String opItem();

    /**
     * 业务对象编号表达式，描述了如何获取订单号的表达式
     *
     * @return
     */
    public String opItemIdExpression();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们不仅要在日志中记录本次操作了什么，还需要知道被操作的对象的具体的唯一性标识，如订单号信息。&lt;/p&gt;
&lt;p&gt;但是每一个接口方法的参数类型肯定是不一样的，很难有一个统一的标准，那么我们就可以借助Spel表达式，即在表达式中指明如何获取对应的对象的唯一性标识。&lt;/p&gt;
&lt;p&gt;有了上面的注解，接下来就可以写切面了。主要代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * OpLog的切面处理类，用于通过注解获取日志信息，进行日志记录
 *
 * @author Hollis
 */
@Aspect
@Component
public class OpLogAspect {

    private static final Logger LOGGER = LoggerFactory.getLogger(OpLogAspect.class);

    @Autowired
    HttpServletRequest request;

    @Around(&quot;@annotation(com.hollis.annotation.OpLog)&quot;)
    public Object log(ProceedingJoinPoint pjp) throws Exception {

        Method method = ((MethodSignature)pjp.getSignature()).getMethod();
        OpLog opLog = method.getAnnotation(OpLog.class);

        Object response = null;

        try {
            // 目标方法执行
            response = pjp.proceed();
        } catch (Throwable throwable) {
            throw new Exception(throwable);
        } 

        if (StringUtils.isNotEmpty(opLog.opItemIdExpression())) {
            SpelExpressionParser parser = new SpelExpressionParser();
            Expression expression = parser.parseExpression(opLog.opItemIdExpression());

            EvaluationContext context = new StandardEvaluationContext();
            // 获取参数值
            Object[] args = pjp.getArgs();

            // 获取运行时参数的名称
            LocalVariableTableParameterNameDiscoverer discoverer
                = new LocalVariableTableParameterNameDiscoverer();
            String[] parameterNames = discoverer.getParameterNames(method);

            // 将参数绑定到context中
            if (parameterNames != null) {
                for (int i = 0; i &amp;lt; parameterNames.length; i++) {
                    context.setVariable(parameterNames[i], args[i]);
                }
            }

            // 将方法的resp当做变量放到context中，变量名称为该类名转化为小写字母开头的驼峰形式
            if (response != null) {
                context.setVariable(
                    CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, response.getClass().getSimpleName()),
                    response);
            }

            // 解析表达式，获取结果
            String itemId = String.valueOf(expression.getValue(context));

            // 执行日志记录
            handle(opLog.opType(), opLog.opItem(), itemId);
        }

        return response;
    }


    private void handle(OpType opType,  String opItem, String opItemId) {
      // 通过日志打印输出
      LOGGER.info(&quot;opType = &quot; + opType.name() +&quot;,opItem = &quot; +opItem + &quot;,opItemId = &quot; +opItemId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上切面中，有几个点需要大家注意的：&lt;/p&gt;
&lt;p&gt;1、使用@Around注解来指定对标注了OpLog的方法设置切面。 2、使用Spel的相关方法，通过指定的表示，从对应的参数中获取到目标对象的唯一性标识。 3、再方法执行成功后，输出日志。&lt;/p&gt;
&lt;p&gt;有了以上的切面及注解后，我们只需要在对应的方法上增加注解标注即可，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#id&quot;)
public @ResponseBody
HashMap view(@RequestParam(name = &quot;id&quot;) String id)
    throws Exception {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这种是入参的参数列表中已经有了被操作的对象的唯一性标识，直接使用&lt;code&gt;#id&lt;/code&gt;指定即可。&lt;/p&gt;
&lt;p&gt;如果被操作的对象的唯一性标识不在入参列表中，那么可能是入参的对象中的某一个属性，用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#orderVo.id&quot;)
public @ResponseBody
HashMap update(OrderVO orderVo)
    throws Exception {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，即可从入参的OrderVO对象的id属性的值获取。&lt;/p&gt;
&lt;p&gt;如果我们要记录的唯一性标识，在入参中没有的话，应该怎么办呢？最典型的就是插入方法，插入成功之前，根本不知道主键ID是什么，这种怎么办呢？&lt;/p&gt;
&lt;p&gt;我们上面的切面中，做了一件事情，就是我们把方法的返回值也会使用表达式进行一次解析，如果可以解析得到具体的值，可以是可以。如以下写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#insertResult.id&quot;)
public @ResponseBody
InsertResult insert(OrderVO orderVo)
    throws Exception {

    return orderDao.insert(orderVo);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是一个简单的使用自定义注解+切面进行日志记录的场景。下面我们再来看一个如何使用注解做方法参数的校验。&lt;/p&gt;
&lt;h3&gt;使用自定义注解做前置检查&lt;/h3&gt;
&lt;p&gt;当我们对外部提供接口的时候，会对其中的部分参数有一定的要求，比如某些参数值不能为空等。大多数情况下我们都需要自己主动进行校验，判断对方传入的值是否合理。&lt;/p&gt;
&lt;p&gt;这里推荐一个使用HibernateValidator + 自定义注解 + AOP实现参数校验的方式。&lt;/p&gt;
&lt;p&gt;首先我们会有一个具体的入参类，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private String idempotentNo;
    @NotNull(
        message = &quot;userName can&#x27;t be null&quot;
    )
    private String userName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，对userName参数注明不能为null。&lt;/p&gt;
&lt;p&gt;然后再使用hibernate validator定义一个工具类，用于做参数校验。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 参数校验工具
 *
 * @author Hollis
 */
public class BeanValidator {

    private static Validator validator = Validation.byProvider(HibernateValidator.class).configure().failFast(true)
        .buildValidatorFactory().getValidator();

    /**
     * @param object object
     * @param groups groups
     */
    public static void validateObject(Object object, Class&amp;lt;?&amp;gt;... groups) throws ValidationException {
        Set&amp;lt;ConstraintViolation&amp;lt;Object&amp;gt;&amp;gt; constraintViolations = validator.validate(object, groups);
        if (constraintViolations.stream().findFirst().isPresent()) {
            throw new ValidationException(constraintViolations.stream().findFirst().get().getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码，会对一个bean进行校验，一旦失败，就会抛出ValidationException。&lt;/p&gt;
&lt;p&gt;接下来定义一个注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * facade接口注解， 用于统一对facade进行参数校验及异常捕获
 * &amp;lt;pre&amp;gt;
 *      注意，使用该注解需要注意，该方法的返回值必须是BaseResponse的子类
 * &amp;lt;/pre&amp;gt;
 */

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Facade {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个注解里面没有任何参数，只用于标注那些方法要进行参数校验。&lt;/p&gt;
&lt;p&gt;接下来定义切面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Facade的切面处理类，统一统计进行参数校验及异常捕获
 *
 * @author Hollis
 */
@Aspect
@Component
public class FacadeAspect {

    private static final Logger LOGGER = LoggerFactory.getLogger(FacadeAspect.class);

    @Autowired
    HttpServletRequest request;

    @Around(&quot;@annotation(com.hollis.annotation.Facade)&quot;)
    public Object facade(ProceedingJoinPoint pjp) throws Exception {

        Method method = ((MethodSignature)pjp.getSignature()).getMethod();
        Object[] args = pjp.getArgs();

        Class returnType = ((MethodSignature)pjp.getSignature()).getMethod().getReturnType();

        //循环遍历所有参数，进行参数校验
        for (Object parameter : args) {
            try {
                BeanValidator.validateObject(parameter);
            } catch (ValidationException e) {
                return getFailedResponse(returnType, e);
            }
        }

        try {
            // 目标方法执行
            Object response = pjp.proceed();
            return response;
        } catch (Throwable throwable) {
            return getFailedResponse(returnType, throwable);
        }
    }

    /**
     * 定义并返回一个通用的失败响应
     */
    private Object getFailedResponse(Class returnType, Throwable throwable)
        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {

        //如果返回值的类型为BaseResponse 的子类，则创建一个通用的失败响应
        if (returnType.getDeclaredConstructor().newInstance() instanceof BaseResponse) {
            BaseResponse response = (BaseResponse)returnType.getDeclaredConstructor().newInstance();
            response.setSuccess(false);
            response.setResponseMessage(throwable.toString());
            response.setResponseCode(GlobalConstant.BIZ_ERROR);
            return response;
        }

        LOGGER.error(
            &quot;failed to getFailedResponse , returnType (&quot; + returnType + &quot;) is not instanceof BaseResponse&quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码，和前面的切面有点类似，主要是定义了一个切面，会对所有标注@Facade的方法进行统一处理，即在开始方法调用前进行参数校验，一旦校验失败，则返回一个固定的失败的Response，特别需要注意的是，这里之所以可以返回一个固定的BaseResponse，是因为我们会要求我们的所有对外提供的接口的response必须继承BaseResponse类，这个类里面会定义一些默认的参数，如错误码等。&lt;/p&gt;
&lt;p&gt;之后，只需要对需要参数校验的方法增加对应注解即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Facade
public TestResponse query(User user) {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，有了以上注解和切面，我们就可以对所有的对外方法做统一的控制了。&lt;/p&gt;
&lt;p&gt;其实，以上这个facadeAspect我省略了很多东西，我们真正使用的那个切面，不仅仅做了参数检查，还可以做很多其他事情。比如异常的统一处理、错误码的统一转换、记录方法执行时长、记录方法的入参出参等等。&lt;/p&gt;
&lt;p&gt;总之，使用切面+自定义注解，我们可以统一做很多事情。除了以上的这几个场景，我们还有很多相似的用法，比如：&lt;/p&gt;
&lt;p&gt;统一的缓存处理。如某些操作需要在操作前查缓存、操作后更新缓存。这种就可以通过自定义注解+切面的方式统一处理。&lt;/p&gt;
&lt;p&gt;代码其实都差不多，思路也比较简单，就是通过自定义注解来标注需要被切面处理的累或者方法，然后在切面中对方法的执行过程进行干预，比如在执行前或者执行后做一些特殊的操作。&lt;/p&gt;
&lt;p&gt;使用这种方式可以大大减少重复代码，大大提升代码的优雅性，方便我们使用。&lt;/p&gt;
&lt;p&gt;但是同时也不能过度使用，因为注解看似简单，但是其实内部有很多逻辑是容易被忽略的。就像我之前写过一篇《&lt;a href=&quot;https://www.hollischuang.com/archives/5608&quot;&gt;Spring官方都推荐使用的@Transactional事务，为啥我不建议使用！&lt;/a&gt;》中提到的观点一样，无脑的使用切面和注解，可能会引入一些不必要的问题。&lt;/p&gt;
&lt;p&gt;不管怎么说，自定义注解却是是一个很好的发明，可以减少很多重复代码。快快在你的项目中用起来吧。&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>