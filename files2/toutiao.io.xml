<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0dc2c45e110519e79d939790e47a1d42</guid>
<title>后端开发实践系列之一：Spring Boot项目模板</title>
<link>https://toutiao.io/k/99knvya</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;p&gt;在我的工作中，我从零开始搭建了不少软件项目，其中包含了基础代码框架和持续集成基础设施等，这些内容在敏捷开发中通常被称为“第0个迭代”要做的事情。但是，当项目运行了一段时间之后再来反观，我总会发现一些不足的地方，要么测试分类没有分好，要么基本的编码架子没有考虑周全。&lt;/p&gt;
&lt;p&gt;另外，我在工作中也会接触到很多既有项目，公司内部和外部的都有，多数项目的编码实践我都是不满意的。比如，我曾经新加入一个项目的时候，前前后后请教了3位同事才把该项目在本地运行起来；又比如在另一项目中，我发现前端请求对应的Java类命名规范不统一，有被后缀为Request的，也有被后缀为Command的。&lt;/p&gt;
&lt;p&gt;再者，工作了这么多年之后，我越来越发现基础知识以及系统性学习的重要性。诚然，技术框架的发展使得我们可以快速地实现业务功能，但是当软件出了问题之后有时却需要将各方面的知识融会贯通并在大脑里综合反应才能找到解决思路。&lt;/p&gt;
&lt;p&gt;基于以上，我希望整理出一套公共性的项目模板出来，旨在尽量多地包含日常开发之所需，减少开发者的重复性工作以及提供一些最佳实践。对于后端开发而言，我选择了当前被行业大量使用的Spring Boot，基于此整理出了一套公共的、基础性的实践方式，在结合了自己的经验以及其他项目的优秀实践之后，总结出本文以飨开发者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5262621-df88ddc72486345f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文以一个简单的电商订单系统为例，源代码请访问：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/e-commerce-sample/order-backend&lt;/code&gt;&lt;br/&gt;
&lt;code&gt;git checkout a443dace&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所使用的技术栈主要包括：Spring Boot、Gradle、MySQL、Junit 5、Rest Assured、Docker等。&lt;/p&gt;
&lt;h1 id=&quot;第一步从写好readme开始&quot;&gt;第一步：从写好README开始&lt;/h1&gt;
&lt;p&gt;一份好的README可以给人以项目全景概览，可以使新人快速上手项目，可以降低沟通成本。同时，README应该简明扼要，条理清晰，建议包含以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目简介：用一两句话简单描述该项目所实现的业务功能；&lt;/li&gt;
&lt;li&gt;技术选型：列出项目的技术栈，包括语言、框架和中间件等；&lt;/li&gt;
&lt;li&gt;本地构建：列出本地开发过程中所用到的工具命令；&lt;/li&gt;
&lt;li&gt;领域模型：核心的领域概念，比如对于示例电商系统来说有Order、Product等；&lt;/li&gt;
&lt;li&gt;测试策略：自动化测试如何分类，哪些必须写测试，哪些没有必要写测试；&lt;/li&gt;
&lt;li&gt;技术架构：技术架构图；&lt;/li&gt;
&lt;li&gt;部署架构：部署架构图；&lt;/li&gt;
&lt;li&gt;外部依赖：项目运行时所依赖的外部集成方，比如订单系统会依赖于会员系统；&lt;/li&gt;
&lt;li&gt;环境信息：各个环境的访问方式，数据库连接等；&lt;/li&gt;
&lt;li&gt;编码实践：统一的编码实践，比如异常处理原则、分页封装等；&lt;/li&gt;
&lt;li&gt;FAQ：开发过程中常见问题的解答。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，README中的信息可能随着项目的演进而改变（比如引入了新的技术栈或者加入了新的领域模型），因此也是需要持续更新的。虽然我们知道，软件文档的一个痛点便是无法与项目实际进展保持同步，但是就README这点信息来讲，还是建议开发者们不要吝啬那一点点敲键盘的时间。&lt;/p&gt;
&lt;p&gt;此外，除了保持README的持续更新，一些重要的架构决定可以通过示例代码的形式记录在代码库中，新开发者可以通过直接阅读这些示例代码快速了解项目的通用实践方式以及架构选择，请参考ThoughtWorks的&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/lightweight-architecture-decision-records&quot; target=&quot;_blank&quot;&gt;技术雷达&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;一键式本地构建&quot;&gt;一键式本地构建&lt;/h1&gt;
&lt;p&gt;为了避免诸如前文中所提到的“请教了3位同事才本地构建成功”的尴尬，为了减少“懒惰”的程序员们的手动操作，也为了为所有开发者提供一种一致的开发体验，我们希望用一个命令就可以完成所有的事情。这里，对于不同的场景我总结出了以下命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成IDE工程：&lt;code&gt;idea.sh&lt;/code&gt;，生成IntelliJ工程文件并自动打开IntelliJ&lt;/li&gt;
&lt;li&gt;本地运行：&lt;code&gt;run.sh&lt;/code&gt;，本地启动项目，自动启动本地数据库，监听调试端口5005&lt;/li&gt;
&lt;li&gt;本地构建：&lt;code&gt;local-build.sh&lt;/code&gt;，只有本地构建成功才能提交代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上3个命令基本上可以完成日常开发之所需，此时，对于新人的开发流程大致为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拉取代码；&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;idea.sh&lt;/code&gt;，自动打开IntelliJ；&lt;/li&gt;
&lt;li&gt;编写代码，包含业务代码和自动化测试；&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;run.sh&lt;/code&gt;，进行本地调试或必要的手动测试(本步骤不是必需)；&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;local-build.sh&lt;/code&gt;，完成本地构建；&lt;/li&gt;
&lt;li&gt;再次拉取代码，保证&lt;code&gt;local-build.sh&lt;/code&gt;成功，提交代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事实上，这些命令脚本的内容非常简单，比如&lt;code&gt;run.sh&lt;/code&gt;文件内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash
./gradlew clean bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，这种显式化的命令却可以减少新人的恐惧感，因为他们只需要知道运行这3个命令就可以搞开发了。另外，一个小小的细节：本地构建的&lt;code&gt;local-build.sh&lt;/code&gt;命令本来可以重命名为更简单的&lt;code&gt;build.sh&lt;/code&gt;，但是当我们在命令行中使用Tab键自动补全的时候，会发现自动补全到了&lt;code&gt;build&lt;/code&gt;目录，而不是&lt;code&gt;build.sh&lt;/code&gt;命令，并不方便，因此命名为了&lt;code&gt;local-build.sh&lt;/code&gt;。细节虽小，但是却体现了一个宗旨，即我们希望给开发者一种极简的开发体验，我把这些看似微不足道的东西称作是对程序员的“人文关怀”。&lt;/p&gt;
&lt;h1 id=&quot;目录结构&quot;&gt;目录结构&lt;/h1&gt;
&lt;p&gt;Maven所提倡的&lt;a href=&quot;https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html&quot; target=&quot;_blank&quot;&gt;目录结构&lt;/a&gt;当前已经成为事实上的行业标准，Gradle在默认情况下也采用了Maven的目录结构，这对于多数项目来说已经足够了。此外，除了Java代码，项目中还存在其他类型的文件，比如Gradle插件的配置、工具脚本和部署配置等。无论如何，项目目录结构的原则是简单而有条理，不要随意地增加多余的文件夹，并且也需要及时重构。&lt;/p&gt;
&lt;p&gt;在示例项目中，顶层只有2个文件夹，一个是用于放置Java源代码和项目配置的&lt;code&gt;src&lt;/code&gt;文件夹，另一个是用于放置所有Gradle配置的&lt;code&gt;gradle&lt;/code&gt;文件夹，此外，为了方便开发人员使用，将上文提到的3个常用脚本直接放到根目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└── order-backend
    ├── gradle // 文件夹，用于放置所有Gradle配置
    ├── src // 文件夹，Java源代码
    ├── idea.sh //生成IntelliJ工程
    ├── local-build.sh // 提交之前的本地构建
    └── run.sh // 本地运行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;gradle&lt;/code&gt;而言，我们刻意地将Gradle插件脚本与插件配置放到了一起，比如Checkstyle：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── gradle
│   ├── checkstyle
│   │   ├── checkstyle.gradle
│   │   └── checkstyle.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实上，在默认情况下Checkstyle插件会从项目根目录下的&lt;code&gt;config&lt;/code&gt;目录查找&lt;code&gt;checkstyle.xml&lt;/code&gt;配置文件，但是这一方面增加了多余的文件夹，另一方面与该插件相关的设施分散在了不同的地方，违背了广义上的内聚原则。&lt;/p&gt;
&lt;h1 id=&quot;基于业务分包&quot;&gt;基于业务分包&lt;/h1&gt;
&lt;p&gt;早年的Java分包方式通常是基于技术的，比如与domain包平级的有controller包、service包和infrastructure包等。这种方式当前并不被行业所推崇，而是应该首先基于业务分包。比如，在订单示例项目中，有两个重要的领域对象&lt;code&gt;Order&lt;/code&gt;和&lt;code&gt;Product&lt;/code&gt;（在&lt;a target=&quot;_blank&quot;&gt;DDD&lt;/a&gt;中称为&lt;a target=&quot;_blank&quot;&gt;聚合根&lt;/a&gt;），所有的业务都围绕它们展开，因此分别创建order包和product包，再分别在包下创建与之相关的各个子包。此时的order包如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── order
│   ├── OrderApplicationService.java
│   ├── OrderController.java
│   ├── OrderNotFoundException.java
│   ├── OrderRepository.java
│   ├── OrderService.java
│   └── model
│       ├── Order.java
│       ├── OrderFactory.java
│       ├── OrderId.java
│       ├── OrderItem.java
│       └── OrderStatus.java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，在order包下我们直接放置了&lt;code&gt;OrderController&lt;/code&gt;和&lt;code&gt;OrderRepository&lt;/code&gt;等类，而没有必要再为这些类划分单独的子包。而对于领域模型Order来讲，由于包含了多个对象，因此基于内聚性原则将它们归到model包中。但是这并不是一个必须，如果业务足够简单，我们甚至可以将所有类直接放到业务包下，product包便是如此：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└── product
    ├── Product.java
    ├── ProductApplicationService.java
    ├── ProductController.java
    ├── ProductId.java
    └── ProductRepository.java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编码实践中，我们总是基于一个业务用例来实现代码，在技术分包场景下，我们需要在分散的各包中来回切换，增加了代码导航的成本；另外，代码提交的变更内容也是散落的，在查看代码提交历史时，无法直观的看出该次提交是关于什么业务功能的。在业务分包下，我们只需要在单个统一的包下修改代码，减少了代码导航成本；另外一个好处是，如果哪天我们需要将某个业务迁移到另外的项目（比如识别出了独立的微服务），那么直接整体移动业务包即可。&lt;/p&gt;
&lt;p&gt;当然，基于业务分包并不意味着所有的代码都必须囿于业务包下，这里的逻辑是：优先进行业务分包，然后对于一些不隶属于任何业务的代码可以单独分包，比如一些util类、公共配置等。比如我们依然可以创建一个common包，下面放置了Spring公共配置、异常处理框架和日志等子包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;└── common
    ├── configuration
    ├── exception
    ├── loggin
    └── utils
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;自动化测试分类&quot;&gt;自动化测试分类&lt;/h1&gt;
&lt;p&gt;在当前的微服务和前后端分离的开发模式下，后端项目仅提供纯粹的业务API，而不包含UI逻辑，因此后端项目不会再包含诸如WebDriver的重量级端到端测试。同时，后端项目作为向外提供业务功能的独立运行单元，在API级别也应该有相应的测试。&lt;/p&gt;
&lt;p&gt;此外，程序中有些框架性代码，要么是诸如Controller之类的技术性框架代码，要么是基于某种架构风格的代码（比如DDD实践中的&lt;a target=&quot;_blank&quot;&gt;ApplicationService&lt;/a&gt;），这些代码一方面并不包含业务逻辑，一方面是很薄的一个抽象层（即实现相对简单），用单元测试来覆盖显得没有必要，因此笔者的观点是可以不为此编写单独的单元测试。再者，程序中有些重要的组件性代码，比如访问数据库的Repository或者分布式锁，使用单元测试实际上“测不到点上”，而使用API测试又显得在分类逻辑上不合理，为此我们可以专门创建一种测试类型谓之组件测试。&lt;/p&gt;
&lt;p&gt;基于以上，我们可以对自动化测试做个分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单元测试：核心的领域模型，包括领域对象(比如Order类)，Factory类，领域服务类等；&lt;/li&gt;
&lt;li&gt;组件测试：不适合写单元测试但是又必须测试的类，比如Repository类，在有些项目中，这种类型测试也被称为集成测试；&lt;/li&gt;
&lt;li&gt;API测试：模拟客户端测试各个API接口，需要启动程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gradle在默认情况下只提供&lt;code&gt;src/test/java&lt;/code&gt;目录用于测试，对于以上3种类型的测试，我们需要将它们分开以便于管理（也是职责分离的体现）。为此，可以通过Gradle提供的SourceSets对测试代码进行分类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sourceSets {
    componentTest {
        compileClasspath += sourceSets.main.output + sourceSets.test.output
        runtimeClasspath += sourceSets.main.output + sourceSets.test.output
    }

    apiTest {
        compileClasspath += sourceSets.main.output + sourceSets.test.output
        runtimeClasspath += sourceSets.main.output + sourceSets.test.output
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此，3种类型的测试可以分别编写在以下目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单元测试：&lt;code&gt;src/test/java&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组件测试：&lt;code&gt;src/componentTest/java&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;API测试：&lt;code&gt;src/apiTest/java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，这里的API测试更多强调的是对业务功能的测试，有些项目中可能还会存在契约测试和安全测试等，虽然从技术上讲都是对API的访问，但是这些测试都是单独的关注点，因此建议分开对待。&lt;/p&gt;
&lt;p&gt;值得一提的是，由于组件测试和API测试需要启动程序，也即需要准备好本地数据库，我们采用了Gradle的&lt;a href=&quot;https://plugins.gradle.org/plugin/com.avast.gradle.docker-compose&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;docker-compose&lt;/code&gt;&lt;/a&gt;插件(或者&lt;a href=&quot;https://github.com/GoogleContainerTools/jib&quot; target=&quot;_blank&quot;&gt;jib插件&lt;/a&gt;)，该插件会在运行测试之前自动运行Docker容器（比如MySQL）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apply plugin: &#x27;docker-compose&#x27;


dockerCompose {
    useComposeFiles = [&#x27;docker/mysql/docker-compose.yml&#x27;]
}

bootRun.dependsOn composeUp
componentTest.dependsOn composeUp
apiTest.dependsOn composeUp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多的测试分类配置细节，比如&lt;a href=&quot;https://docs.gradle.org/current/userguide/jacoco_plugin.html&quot; target=&quot;_blank&quot;&gt;JaCoCo&lt;/a&gt;测试覆盖率配置等，请参考本文的示例项目代码。对Gradle不熟悉的读者可以参考笔者的&lt;a href=&quot;https://www.cnblogs.com/CloudTeng/p/3417762.html&quot; target=&quot;_blank&quot;&gt;Gradle学习系列&lt;/a&gt;文章。&lt;/p&gt;
&lt;h1 id=&quot;日志处理&quot;&gt;日志处理&lt;/h1&gt;
&lt;p&gt;在日志处理中，除了完成基本配置外，还有2个需要考虑的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在日志中加入请求标识，便于链路追踪。在处理一个请求的过程中有时会输出多条日志，如果每条日志都共享统一的请求ID，那么在日志追踪时会更加方便。此时，可以使用Logback原生提供的MDC(Mapped Diagnostic Context)功能，创建一个RequestIdMdcFilter：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        //request id in header may come from Gateway, eg. Nginx
        String headerRequestId = request.getHeader(HEADER_X_REQUEST_ID);
        MDC.put(REQUEST_ID, isNullOrEmpty(headerRequestId) ? newUuid() : headerRequestId);
        try {
            filterChain.doFilter(request, response);
        } finally {
            clearMdc();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;集中式日志管理，在多节点部署的场景下，各个节点的日志是分散的，为此可以引入诸如ELK之类的工具将日志统一输出到ElasticSearch中。本文的示例项目使用了RedisAppender将日志输出到Logstash：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;appender name=&quot;REDIS&quot; class=&quot;com.cwbase.logback.RedisAppender&quot;&amp;gt;
    &amp;lt;tags&amp;gt;ecommerce-order-backend-${ACTIVE_PROFILE}&amp;lt;/tags&amp;gt;
    &amp;lt;host&amp;gt;elk.yourdomain.com&amp;lt;/host&amp;gt;
    &amp;lt;port&amp;gt;6379&amp;lt;/port&amp;gt;
    &amp;lt;password&amp;gt;whatever&amp;lt;/password&amp;gt;
    &amp;lt;key&amp;gt;ecommerce-ordder-log&amp;lt;/key&amp;gt;
    &amp;lt;mdc&amp;gt;true&amp;lt;/mdc&amp;gt;
    &amp;lt;type&amp;gt;redis&amp;lt;/type&amp;gt;
&amp;lt;/appender&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，统一日志的方案还有很多，比如Splunk和Graylog等。&lt;/p&gt;
&lt;h1 id=&quot;异常处理&quot;&gt;异常处理&lt;/h1&gt;
&lt;p&gt;在设计异常处理的框架时，需要考虑以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向客户端提供格式统一的异常返回&lt;/li&gt;
&lt;li&gt;异常信息中应该包含足够多的上下文信息，最好是结构化的数据以便于客户端解析&lt;/li&gt;
&lt;li&gt;不同类型的异常应该包含唯一标识，以便客户端精确识别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异常处理通常有两种形式，一种是层级式的，即每种具体的异常都对应了一个异常类，这些类最终继承自某个父异常；另一种是单一式的，即整个程序中只有一个异常类，再以一个字段来区分不同的异常场景。层级式异常的好处是能够显式化异常含义，但是如果层级设计不好可能导致整个程序中充斥着大量的异常类；单一式的好处是简单，而其缺点在于表意性不够。&lt;/p&gt;
&lt;p&gt;本文的示例项目使用了层级式异常，所有异常都继承自一个AppException：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class AppException extends RuntimeException {
    private final ErrorCode code;
    private final Map&amp;lt;String, Object&amp;gt; data = newHashMap();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;ErrorCode&lt;/code&gt;枚举中包含了异常的唯一标识、HTTP状态码以及错误信息；而&lt;code&gt;data&lt;/code&gt;字段表示各个异常的上下文信息。&lt;/p&gt;
&lt;p&gt;在示例系统中，在没有找到订单时抛出异常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class OrderNotFoundException extends AppException {
    public OrderNotFoundException(OrderId orderId) {
        super(ErrorCode.ORDER_NOT_FOUND, ImmutableMap.of(&quot;orderId&quot;, orderId.toString()));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在返回异常给客户端时，通过一个ErrorDetail类来统一异常格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class ErrorDetail {
    private final ErrorCode code;
    private final int status;
    private final String message;
    private final String path;
    private final Instant timestamp;
    private final Map&amp;lt;String, Object&amp;gt; data = newHashMap();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终返回客户端的数据为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  requestId: &quot;d008ef46bb4f4cf19c9081ad50df33bd&quot;,
  error: {
    code: &quot;ORDER_NOT_FOUND&quot;,
    status: 404,
    message: &quot;没有找到订单&quot;,
    path: &quot;/order&quot;,
    timestamp: 1555031270087,
    data: {
      orderId: &quot;123456789&quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;ORDER_NOT_FOUND&lt;/code&gt;与&lt;code&gt;data&lt;/code&gt;中的数据结构是一一对应的，也即对于客户端来讲，如果发现了&lt;code&gt;ORDER_NOT_FOUND&lt;/code&gt;，那么便可确定&lt;code&gt;data&lt;/code&gt;中一定存在&lt;code&gt;orderId&lt;/code&gt;字段，进而完成精确的结构化解析。&lt;/p&gt;
&lt;h1 id=&quot;后台任务与分布式锁&quot;&gt;后台任务与分布式锁&lt;/h1&gt;
&lt;p&gt;除了即时完成客户端的请求外，系统中通常会有一些定时性的例行任务，比如定期地向用户发送邮件或者运行数据报表等；另外，有时从设计上我们会对请求进行异步化处理。此时，我们需要搭建后台任务相关基础设施。Spring原生提供了任务处理(TaskExecutor)和任务计划(TaskSchedulor)机制；而在分布式场景下，还需要引入&lt;a href=&quot;https://en.wikipedia.org/wiki/Distributed_lock_manager&quot; target=&quot;_blank&quot;&gt;分布式锁&lt;/a&gt;来解决并发冲突，为此我们引入一个轻量级的分布式锁框架&lt;a href=&quot;https://github.com/lukas-krecan/ShedLock&quot; target=&quot;_blank&quot;&gt;ShedLock&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;启用Spring任务配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@EnableAsync
@EnableScheduling
public class SchedulingConfiguration implements SchedulingConfigurer {

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setScheduler(newScheduledThreadPool(10));
    }

    @Bean(destroyMethod = &quot;shutdown&quot;)
    @Primary
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(10);
        executor.setTaskDecorator(new LogbackMdcTaskDecorator());
        executor.initialize();
        return executor;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后配置Shedlock：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@EnableSchedulerLock(defaultLockAtMostFor = &quot;PT30S&quot;)
public class DistributedLockConfiguration {

    @Bean
    public LockProvider lockProvider(DataSource dataSource) {
        return new JdbcTemplateLockProvider(dataSource);
    }


    @Bean
    public DistributedLockExecutor distributedLockExecutor(LockProvider lockProvider) {
        return new DistributedLockExecutor(lockProvider);
    }


}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现后台任务处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Scheduled(cron = &quot;0 0/1 * * * ?&quot;)
    @SchedulerLock(name = &quot;scheduledTask&quot;, lockAtMostFor = THIRTY_MIN, lockAtLeastFor = ONE_MIN)
    public void run() {
        logger.info(&quot;Run scheduled task.&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了支持代码直接调用分布式锁，基于Shedlock的LockProvider创建DistributedLockExecutor：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class DistributedLockExecutor {
    private final LockProvider lockProvider;

    public DistributedLockExecutor(LockProvider lockProvider) {
        this.lockProvider = lockProvider;
    }

    public &amp;lt;T&amp;gt; T executeWithLock(Supplier&amp;lt;T&amp;gt; supplier, LockConfiguration configuration) {
        Optional&amp;lt;SimpleLock&amp;gt; lock = lockProvider.lock(configuration);
        if (!lock.isPresent()) {
            throw new LockAlreadyOccupiedException(configuration.getName());
        }

        try {
            return supplier.get();
        } finally {
            lock.get().unlock();
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用时在代码中直接调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public String doBusiness() {
        return distributedLockExecutor.executeWithLock(() -&amp;gt; &quot;Hello World.&quot;,
                new LockConfiguration(&quot;key&quot;, Instant.now().plusSeconds(60)));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文的示例项目使用了基于JDBC的分布式锁，事实上任何提供原子操作的机制都可用于分布式锁，Shedlock还提供基于Redis、ZooKeeper和Hazelcast等的分布式锁实现机制。&lt;/p&gt;
&lt;h1 id=&quot;统一代码风格&quot;&gt;统一代码风格&lt;/h1&gt;
&lt;p&gt;除了Checkstyle统一代码格式之外，项目中有些通用的公共的编码实践方式也需要在整个开发团队中进行统一，包括但不限于以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端的请求数据类统一使用相同后缀，比如Command&lt;/li&gt;
&lt;li&gt;返回给客户端的数据统一使用相同后缀，比如Represetation&lt;/li&gt;
&lt;li&gt;统一对请求处理的流程框架，比如采用传统的3层架构或者DDD战术模式&lt;/li&gt;
&lt;li&gt;提供一致的异常返回（请参考“异常处理”小节）&lt;/li&gt;
&lt;li&gt;提供统一的分页结构类&lt;/li&gt;
&lt;li&gt;明确测试分类以及统一的测试基础类（请参考“自动化测试分类”小节）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;静态代码检查&quot;&gt;静态代码检查&lt;/h1&gt;
&lt;p&gt;静态代码检查主要包含以下Gradle插件，具体配置请参考本文示例代码：&lt;/p&gt;

&lt;h1 id=&quot;健康检查&quot;&gt;健康检查&lt;/h1&gt;
&lt;p&gt;健康检查主要用于以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们希望初步检查程序是否运行正常&lt;/li&gt;
&lt;li&gt;有些负载均衡软件会通过一个健康检查URL判断节点的可达性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时，可以实现一个简单的API接口，该接口不受权限管控，可以公开访问。如果该接口返回HTTP的200状态码，便可初步认为程序运行正常。此外，我们还可以在该API中加入一些额外的信息，比如提交版本号、构建时间、部署时间等。&lt;/p&gt;
&lt;p&gt;启动本文的示例项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./run.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后访问健康检查API：&lt;a href=&quot;http://localhost:8080/about&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/about&lt;/a&gt;，结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  requestId: &quot;698c8d29add54e24a3d435e2c749ea00&quot;,
  buildNumber: &quot;unknown&quot;,
  buildTime: &quot;unknown&quot;,
  deployTime: &quot;2019-04-11T13:05:46.901+08:00[Asia/Shanghai]&quot;,
  gitRevision: &quot;unknown&quot;,
  gitBranch: &quot;unknown&quot;,
  environment: &quot;[local]&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上接口在示例项目中用了一个简单的Controller实现，事实上Spring Boot&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator&quot; target=&quot;_blank&quot;&gt;的Acuator&lt;/a&gt;框架也能够提供相似的功能。&lt;/p&gt;
&lt;h1 id=&quot;api文档&quot;&gt;API文档&lt;/h1&gt;
&lt;p&gt;软件文档的难点不在于写，而在于维护。多少次，当我对照着项目文档一步一步往下走时，总得不到正确的结果，问了同事之后得到回复“哦，那个已经过时了”。本文示例项目所采用的&lt;a target=&quot;_blank&quot;&gt;Swagger&lt;/a&gt;在一定程度上降低了API维护的成本，因为Swagger能自动识别代码中的方法参数、返回对象和URL等信息，然后自动地实时地创建出API文档。&lt;/p&gt;
&lt;p&gt;配置Swagger如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@EnableSwagger2
@Profile(value = {&quot;local&quot;, &quot;dev&quot;})
public class SwaggerConfiguration {

    @Bean
    public Docket api() {
        return new Docket(SWAGGER_2)
                .select()
                .apis(basePackage(&quot;com.ecommerce.order&quot;))
                .paths(any())
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动本地项目，访问&lt;a href=&quot;http://localhost:8080/swagger-ui.html&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/swagger-ui.html&lt;/a&gt;：&lt;br/&gt;
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5262621-d4f163fe742fda56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Swagger API文档&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据库迁移&quot;&gt;数据库迁移&lt;/h1&gt;
&lt;p&gt;在传统的开发模式中，数据库由专门的运维团队或者DBA来维护，要对数据库进行修改需要向DBA申请，告之迁移内容，最后由DBA负责数据库变更实施。在&lt;a target=&quot;_blank&quot;&gt;持续交付&lt;/a&gt;和&lt;a target=&quot;_blank&quot;&gt;DevOps&lt;/a&gt;运动中，这些工作逐步提前到开发过程，当然并不是说不需要DBA了，而是这些工作可以由开发者和运维人员一同完成。另外，在微服务场景下，数据库被包含在单个服务的边界之内，因此基于内聚性原则（咦，这好像是本文第三次提到内聚原则了，可见其在软件开发中的重要性），数据库的变更最好也与项目代码一道维护在代码库中。&lt;/p&gt;
&lt;p&gt;本文的示例项目采用了Flyway作为数据库迁移工具，加入了&lt;a href=&quot;https://flywaydb.org/&quot; target=&quot;_blank&quot;&gt;Flyway&lt;/a&gt;依赖后，在&lt;code&gt;src/main/sources/db/migration&lt;/code&gt;目录下创建迁移脚本文件即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resources/
├── db
│   └── migration
│       ├── V1__init.sql
│       └── V2__create_product_table.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;迁移脚本的命名需要遵循一定的&lt;a href=&quot;https://flywaydb.org/documentation/migrations#syntax&quot; target=&quot;_blank&quot;&gt;规则&lt;/a&gt;以保证脚本执行顺序，另外迁移文件生效之后不要任意修改，因为Flyway会检查文件的checksum，如果checksum不一致将导致迁移失败。&lt;/p&gt;
&lt;h1 id=&quot;多环境构建&quot;&gt;多环境构建&lt;/h1&gt;
&lt;p&gt;在软件的开发流程中，我们需要将软件部署到多个环境，经过多轮验证后才能最终上线。在不同的阶段中，软件的运行态可能是不一样的，比如本地开发时可能将所依赖的第三方系统stub掉；持续集成构建时可能使用的是测试用的内存数据库等等。为此，本文的示例项目推荐采用以下环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local：用于开发者本地开发&lt;/li&gt;
&lt;li&gt;ci：用于持续集成&lt;/li&gt;
&lt;li&gt;dev：用于前端开发联调&lt;/li&gt;
&lt;li&gt;qa：用于测试人员&lt;/li&gt;
&lt;li&gt;uat：类生产环境，用于功能验收(有时也称为staging环境)&lt;/li&gt;
&lt;li&gt;prod：正式的生产环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;cors&quot;&gt;CORS&lt;/h1&gt;
&lt;p&gt;在前后端分离的系统中，前端单独部署，有时连域名都和后端不同，此时需要进行跨域处理。传统的做法可以通过JSONP，但这是一种比较“trick”的做法，当前更通用的实践是采用&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot; target=&quot;_blank&quot;&gt;CORS&lt;/a&gt;机制，在Spring Boot项目中，启用CORS配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class CorsConfiguration {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping(&quot;/**&quot;);
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于使用Spring Security的项目，需要保证CORS工作于Spring Security的过滤器之前，为此Spring Security专门提供了相应配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
http
// by default uses a Bean by the name of corsConfigurationSource
.cors().and()
...
}

@Bean
CorsConfigurationSource corsConfigurationSource() {
CorsConfiguration configuration = new CorsConfiguration();
configuration.setAllowedOrigins(Arrays.asList(&quot;https://example.com&quot;));
configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));
UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration(&quot;/**&quot;, configuration);
return source;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;常用第三方类库&quot;&gt;常用第三方类库&lt;/h1&gt;
&lt;p&gt;这里列出一些比较常见的第三方库，开发者们可以根据项目所需引入：&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;本文通过一个示例项目谈及到了项目之初开发者搭建后端工程的诸多方面，其中的绝大多数实践均在笔者的项目中真实落地。读完本文之后你可能会发现，文中的很多内容都是很基础很简单的。没错，的确没有什么难的东西，但是要系统性地搭建好后端项目的基础框架却不见得是每个开发团队都已经做到的事情，而这恰恰是本文的目的。最后，需要提醒的是，本文提到的实践方式只是一个参考，一方面依然存在考虑不周的地方，另一方面示例项目中用到的技术工具还存在其他替代方案，请根据自己项目的实际情况进行取舍。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bfa08ded49eda8d15450ac6a8006ef38</guid>
<title>阿里巴巴数据治理实践.PPT</title>
<link>https://toutiao.io/k/xxb2z61</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1701ea8e25e8ba8441fa67bddf47f51c</guid>
<title>HDFS 在 HA 模式集群下 JournalNode 节点的作用</title>
<link>https://toutiao.io/k/tnpzzn3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27835051546391754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtjPpzHklv2aic0P4VPcJLtVr0uToQaX1ZYLDaTyb4rEibia3CJH2WIAl7PFVCa7ibjxjg1kC9vGWctLSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;291&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        HDFS 在非 HA 模式的集群下，NameNode 和 DataNode 是一个主从的架构。在这样的主从架构之下只有一台 NameNode。一台 NameNode 的好处是无需因为元数据的同步而考虑数据的一致性问题。但是，只有一台 NameNode 也会有很多的坏处，因为，单台 NameNode 的情况下会出现所有单机都会出现的问题。最简单的问题就是，当这一台 NameNode 挂掉后，整个集群将不可用了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        为了解决单台 NameNode 挂掉不可用的问题，HDFS 在 2.x 版本的时候引入了 HDFS 集群的 HA 模式，也就是有了 NameNode 的主备架构。在 2.x 的版本中，HDFS 支持一主一备的架构，在 3.x 的版本中最多支持 5 个，官方推荐使用 3 个。（这里只整理了 HDFS 在单 NameNode 情况下挂掉的问题，没有整理关于容量的问题）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、HDFS 两个 NN 同步哪些数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        在 HDFS 非 HA 模式的集群下，只有一个 NameNode，而在 HDFS 的 HA 模式集群下&lt;/span&gt;，存在两个 NameNode，一个是活动的 NameNode，称为 Active，另外一个是备用的 NameNode，称为 Standby。当 Active 节点出现问题时，需要将 Standby 节点切换为 Active 节点来为客户端提供服务，那么，这就需要 Standby 节点存储的元数据和 Active 节点的元数据保持相一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        那么，Standby 节点和 Active 节点是如何保持它们的数据相一致呢？先来回顾一下 NameNode 中存放的为何物。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        HDFS 的 NameNode 保存着 HDFS 集群中的 元数据。元数据的来源分为两部分，一部分是客户端提供的，比如在 HDFS 命令行或者通过 HDFS Java API （HDFS 命令行和 HDFS Java API 都可以看成是 HDFS 的客户端）创建了一个目录，那么就会在 NameNode 下创建对应的元数据；另一部分的元数据来源于 DataNode 提供的 Block 等信息的元数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        NameNode 中存放了这两种元数据，那么 Active 节点和 Standby 节点都是 NameNode，它们之间的数据是如何一致的呢？通过 HDFS 客户端操作形成的元数据，需要在 Active 节点和 Standby 节点进行同步；DataNode 提供的 Block 等信息的元数据，会同时提交给 Active 节点和 Standby 节点。那么，真正要在 Active 节点和 Standby 节点进行同步的元数据只有客户端操作产生的元数据了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、两个节点同步数据的数据一致性问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        那么在 Active 节点和 Standby 节点应该如何同步数据&lt;/span&gt;&lt;span&gt;呢？这里先不写结论，先整理一下问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        首先，假设 Active 节点和 Standby 节点使用同步阻塞的方式同步数据，那情况是这样的。客户端创建目录，Active 节点接收到命令创建了相应的元数据，然后同步给 Standby 节点，Standby &lt;span&gt;节&lt;/span&gt;&lt;span&gt;点&lt;/span&gt;同步完成信息后返回成功的确认给 Active 节点，Active 节点返回创建成功给客户端。这样一切正常。但是，如果 Standby 节点故障了，没有给 Active 返回同步成功的确认信息，那么 Active 节点可能会卡很久，等超时后告诉客户端命令执行失败了。这样可能会造成用户体验不好，影响了用户的可用性。那么问题来了，在 HA 模式下引入 Standby 节点的 NameNode 本身是要提高集群的可用性，但是由于它的延迟、故障等又影响了正常节点的可用性。这种方式的好处在于它保证了两个节点之间的数据强一致性，却可能使得整体的可用性不好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        那么，此时换一种方式，使用异步非阻塞模式。Active 节点把要同步的数据发给了 Standby 节点，然后告诉客户端已经成功了。但是使用了异步非阻塞模式，此时 Standby 节点可能什么也没做，也可能它做的过程中故障了，导致同步失败。这样，客户端和 Active 节点的可用性有了，但是 Active 节点和 Standby 节点之间的两个节点的一致性没了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        那么，HDFS 如何解决两个节点数据一致性和可用性的问题呢？答案是 HDFS 引入了 JournalNode 节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、HDFS 中的 JournalNode 节点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        为了保证 Active 节点和 Standby 节点，即可以可靠的保持数据的一致性，又不会影响集群的可用性，HDFS 在 Active 节点和 Standby 节点之间引入了另外一个节点 JournalNode 节点。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        JournalNode 节点作为 Active 节点和 Standby 节点的中间节点，它为两个节点解决了数据的同步的问题。首先 Active 节点会将元数据发送给 JournalNode &lt;span&gt;节点&lt;/span&gt;，然后 Standby &lt;span&gt;节点&lt;/span&gt;会从 JournalNode 节点获取需要同步的元数据。即使 Standby 节点故障了、产生问题了，在它恢复正常状态后，也可以从 JournalNode 节点中同步相应的数据。这就要求 JournalNode 节点需要有持久化的功能来保证元数据不丢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        但是，问题又来了，JournalNode &lt;span&gt;节点&lt;/span&gt;如果挂掉又怎么办？那么这就对 JournalNode &lt;span&gt;节点&lt;/span&gt;提出了新的要求，它需要保证自己的可靠性，才能保证为 Standby 节点提供数据。因此 JournalNode 节点本身也是一个多节点的集群，从而保证它自身的可靠性。而且 JournalNode &lt;span&gt;节点&lt;/span&gt;会在集群自动的选择一个&quot;主&quot;节点出来，Active 节点会和 JournalNode 的主节点通信，然后 JournalNode 集群的主节点会将数据发送给其他的节点，只要有过半的节点完成了数据的存储，JournalNode 集群的主节点，就会将成功信息返回给 Active 节点。当 JournalNode 集群的主节点挂掉，其他的 JournalNode 节点会快速选举出新的&quot;主&quot;节点来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        这样，通过 JournalNode 通过自身具备存储能力，和保证自身的可靠性，为 Active 节点和 Standby 节点之间的数据最终一致性提供了服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、HDFS HA 模式架构图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        HDFS HA 模式集群的架构图如下所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6005946481665014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtj7LNNfVFBKK4UOFNtqy8TWE3gkraJZjuOLpImIzialJNiaaNnGmUSs9nTNiawYIbE0pa3Gt6UXI7NAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在上图中，蓝色部分是用于故障自动切换的，除蓝色部分外，则是 HDFS HA 模式的集群。在最下方是 DataNode 节点，在 DataNode 节点的上方左右两侧各一个的是处于 Active 状态的 NameNode 节点，和处于 Standby 状态的 NameNode 节点。在 NameNode 节点的上面则是 JournalNode 的集群。这样就保障了整个 HDFS 集群系统的高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        分布式架构中保证数据的一致性是一个比较关键的问题，分布式一致性也有相关的协议，比如 Paxos 协议。虽然不同的技术使用了不同协议，只是各种技术在具体实现时的综合取舍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001028&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.0712962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        之前整理的关于 Redis 的文章：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484043&amp;amp;idx=1&amp;amp;sn=bdc040d4568d60b7c0e5c6b9e2464f72&amp;amp;chksm=e973e4b1de046da75e54d799bdbaf6e74323218c4d1983804bbb96e5ae13b1c6d7dd3cd80d50&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 的安装&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484049&amp;amp;idx=1&amp;amp;sn=1459569baaec7666a22c50339c7b22c0&amp;amp;chksm=e973e4abde046dbd968ea23ce5a633a3ade1a53a3edd3a0fe52d9a64d350b7ffa7aace8ae2c7&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 的帮助命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484059&amp;amp;idx=1&amp;amp;sn=1d86daa51437dc3420ff25cd4b77f3e0&amp;amp;chksm=e973e4a1de046db72fa7b1a673447d8a1f2aec18d5086a9905ab459e2af1b89650256e24797f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 命令分类&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484093&amp;amp;idx=1&amp;amp;sn=ae41b5834187a7768154ef1d4946e06b&amp;amp;chksm=e973e487de046d91c380c5d75cf8ccbe97968dff924474ce1893663d58d1de640d1c00f04084&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 通用命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484112&amp;amp;idx=1&amp;amp;sn=8d5d8dbce45ca2c892f1ef08f2ce2b52&amp;amp;chksm=e973e4eade046dfc12a9a2709aaf61f2a7dd3c7c073e80646d391a690eff75283709556f9c9d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 字符串相关命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484146&amp;amp;idx=1&amp;amp;sn=6a4f28894e15e8881fbdd55b79f2077e&amp;amp;chksm=e973e4c8de046dde6ca4478c8e566529718338ebcaf0b683f3f3cafcea7f21769ce4c8df1048&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 列表相关命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484157&amp;amp;idx=1&amp;amp;sn=08f87e9e9a88f0481272f77b1aff276a&amp;amp;chksm=e973e4c7de046dd1487e25d631becf85c8865057bed51d0fe593378ddcdf8f72be3554fa381a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 集合相关命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484200&amp;amp;idx=1&amp;amp;sn=753e7c54b4a2d5662dcaf20e4c32f9ba&amp;amp;chksm=e973e512de046c045df156663260874ed14d2256bbcffed995fccc8039fc566dd2cff65d064a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Redis | Redis 有序集合相关命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484209&amp;amp;idx=1&amp;amp;sn=8fe9b2fbdf5e6dbf75a1796476c30586&amp;amp;chksm=e973e50bde046c1da276dd7012bee0b2c707431dbf94ff890364e3ec57d01c175cb5fe631828&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | Redis 哈希相关命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484218&amp;amp;idx=1&amp;amp;sn=552333e96731c54df4bc0fba138d6959&amp;amp;chksm=e973e500de046c16d61f3cef0e545669066ed474ee0773c514a425583a6002a5a65359c10a2f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 源码阅读 —— 字符串&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484240&amp;amp;idx=1&amp;amp;sn=fd2c862cc17c4c9b29fec9e9cc9284a8&amp;amp;chksm=e973e56ade046c7cc5e275a7c07b7aa17574593131fa8e51ba2cd631b14ad09d88b56cccc5ee&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 源码阅读 —— 链表&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484247&amp;amp;idx=1&amp;amp;sn=318957159f7f8e52dfb09e458b9561e5&amp;amp;chksm=e973e56dde046c7ba605148c8d28921df3c4de4b44ac76298c8a4515068df9a348cb68cf6649&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | Redis Pub/Sub相关命令&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484270&amp;amp;idx=2&amp;amp;sn=ac89039c56903bf6349a65955f802254&amp;amp;chksm=e973e554de046c42e5f1f208f1a3901ff4905ff64a7b991bceca52cc6c12436075bc004143cc&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 管道 —— PipeLine&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484283&amp;amp;idx=1&amp;amp;sn=97cf2fcf827539145245df1d02e0d425&amp;amp;chksm=e973e541de046c5775477939fda934f896df3ab7022992a96767247b713382b7f5b572ba87bd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | SpringBoot整合Redis&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484316&amp;amp;idx=1&amp;amp;sn=e41060ca2f7cfb8ccd75132aed1f8c14&amp;amp;chksm=e973e5a6de046cb007f5308505393d4ab33337cea14d19dcb22300539540b622ec3ca2d3136c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | Redis 的事务一&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484328&amp;amp;idx=1&amp;amp;sn=0efd2b2285f47232385066a5327bd222&amp;amp;chksm=e973e592de046c849e16bfc2b497c6a8aea4b81f6e3d77ac456a7eea65025c93f138afa17a7f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | Redis 的事务二&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484340&amp;amp;idx=1&amp;amp;sn=d9ff89f710199856334f8aef777c1abc&amp;amp;chksm=e973e58ede046c981575d89da2457dc4b889dfd6b5dafc19577cbdfd7c72371d64545bfdfff7&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 基础数据类型应用场景&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484360&amp;amp;idx=1&amp;amp;sn=0a228a23234f9fa1b80954c6f741c330&amp;amp;chksm=e973e5f2de046ce4956c50d01dec192bd1ff9212412d6985532133847becf4926e24b3774b6c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 事务源码阅读&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484372&amp;amp;idx=1&amp;amp;sn=e65dfafe60d2614ed76e4c6648857879&amp;amp;chksm=e973e5eede046cf8a3115dfc70b93002747a531ef68901753006eda06a2e4bfd92b04bc0f214&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 事物源码阅读 —— watch&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484382&amp;amp;idx=1&amp;amp;sn=6dd53c32824a0f29e46414a19a243a96&amp;amp;chksm=e973e5e4de046cf2a59433a9800ca374fbf21d51dad3670c54015000df29deef87ea491750b7&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 慢查询&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484656&amp;amp;idx=1&amp;amp;sn=15b1c480ae8e856ad8c12cf7070f1374&amp;amp;chksm=e973e2cade046bdc086d15da81da0588e61834f6d7cb666b331efee56f5a739055f51edf3fb8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;Redis | 给接口添加缓存&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MzA2OTc4MQ==&amp;amp;mid=2247484667&amp;amp;idx=1&amp;amp;sn=8bbd03af8580dec6ecd0c2b6c0ecaad2&amp;amp;chksm=e973e2c1de046bd7b0f1ab77b93baec53cbb63f3c4bf9b44c750f56c8ee1b1329c6d3de9cb9f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍Redis | Redis 也会算距离‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Redis | Redis 也会算距离&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001022&quot; data-ratio=&quot;0.365625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/Bfv9smoHwtiad97Av4ibYh0nialo6NGGgTibF5o603r7C44eOJlatuF6gwsCiawAB5abXVcJBMiaNPpGBk8IuaibCeuEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f7aa853c878c36857c554a4dff9c939</guid>
<title>博采 27 门语言之长，提升 Python 的能力</title>
<link>https://toutiao.io/k/zj8h866</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;Python猫注：Python 语言诞生 30 年了，如今的发展势头可谓如火如荼，这很大程度上得益于其易学易用的优秀设计，而不可否认的是，Python 从其它语言中偷师了不少。本文作者是一名资深的核心开发者，他广博的视野和精准的认识，让我对 Python 的设计了解得更为全面，同时，他“利用自豪感而非恐惧感”的说法，传达出来的是“专注于自我的进步，不嫉妒他人的成功”的原则，对我也很有帮助。原文写于 2015 年，躺在我的收藏夹里很久很久了，如今顺利翻译掉，这是一件能提升自豪感的有意义的事。最后祝大家开卷有益，读有所获。&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者：Nick Coghlan&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;译者：豌豆花下猫@Python猫&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;英文：https://www.curiousefficiency.org/posts/2015/10/languages-to-improve-your-python.html&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;声明：本翻译是出于交流学习的目的，基于 CC BY-NC-SA 4.0 授权协议。为便于阅读，内容略有改动。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;拓宽我们的视野&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;过程式编程：C、Rust、Cython&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;面向对象的数据模型：Java、C#、Eiffel&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;面向对象的 C 派生：C++、D&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;面向数组的数据处理：MATLAB/Octave、Julia&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;统计数据分析：R&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算管道建模：Haskell、Scala、Clojure、F#&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;事件驱动编程：JavaScript、Go、Erlang、Elixir&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;渐变类型：TypeScript&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;动态元编程：Hy、Ruby&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;务实问题解决：Lua、PHP、Perl&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编程思维：Scratch、Logo&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为世界上最流行的编程语言之一的共同设计者，我经常看到一个令人沮丧的行为（在 Python 社区和其它社区）：有影响力者试图激发人们对“败给”其它开源社区的恐惧，从而调动人们对社区作贡献的积极性。（我自己偶尔也会犯这种错误，这让我更容易发现其他人是否也落入了同样的陷阱）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然学习其它编程语言社区的经验是件好事，但基于恐惧的方法来激励行动是有严重问题的，因为这会刺激本社区成员将其它社区的人视为争夺开源贡献者关注的敌人，而不是作为在更大挑战中的潜在盟友（推动软件开发艺术发展）。这还会告诉那些喜欢其它语言的人，在一个把他们以及他们的同伴视为“敌对竞争对手”的社区里，他们是不受欢迎的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，我们希望有多种多样的跨平台的开源编程语言供选择，因为编程语言是思考的首要工具——使我们能够以明确的方式表达我们的想法，从而让计算机也能够理解。如果有人找到了一种适合大脑的语言，能够解决眼前的问题，那就太好了，不管他们选择的是哪种（些）语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我对 Python 社区有三个具体的请求，以及一个较为宽泛的建议。首先，我的请求是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果我们要利用社区的本能来激励行动，就应该避免利用恐惧感，而应该利用自豪感。&lt;/strong&gt; 当我们将恐惧作为激励因素时，就像在说“如果我们不做 X，就会失去开发者对 Python 的关注”，这等于是故意地在自由的开源贡献者中创造悲观的情绪。然而，依赖社区的自豪感就像在说“目前尚不清楚如何在 Python 中解决 X 问题。如果我们看看 Y 语言，就可以看到他们有一个非常好的方法来解决问题 X，我们可以吸收进 Python，以提供类似的舒适的用户体验。”积极的态度让我们对自己的努力感到自豪，而不是贬低他人的努力，这有助于在 Python 社区内促成一种持续学习的文化，并促进与其它社区改善协作关系，共同发展。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;克制对其它开源编程语言社区采取轻蔑的态度，尤其当这些社区授权人们解决自己的问题，而不是等待商业软件供应商来解决问题。&lt;/strong&gt; 世界上大多数重要的问题解决起来都是无利可图的（因为受苦于这些问题的人并不富裕，而且无法左右机构基金的决定），所以我们应该鼓励试图解决这些问题的人，不管我们如何看待他们的技术选择。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果我们认识的人刚开始学习编程，并且他们选了一种我们不喜欢的语言，我们应该支持他们的选择。&lt;/strong&gt; 他们比我们更知道什么适合自己，适合我们的语言不一定适合他们。如果他们对自己最初的选择感到了沮丧，甚至已经对学习编程变得没有动力，此时再给他们推荐别的编程语言。这个建议还适用于那些在改善糟糕的网络安全状况的人：我们在面对天生不安全的语言时，采取的方法是改进操作系统的沙箱功能，逐步学习有更好的本地安全属性的语言，并改善现有语言的默认行为，而不是列举为什么从程序安全性的角度来看，他们选择的语言是一个糟糕的选择，来迷惑初学者。（如果有人部署了由初学者编写的未经审核的软件来处理安全敏感的任务，那就不是开发者的问题，而且部署者的问题，他们没有对软件的出处和安全属性进行适当的尽职调查。）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的宽泛的建议针对那些遇到了 Python 核心程序的限制，并因此希望探索 Python 中可用的“思考工具”的人。这个建议就是：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;拓宽我们的视野&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发 Python 核心程序的过程中，我们会做的一件事是查看其它语言中解决了我们正面临的问题的特性，看看是否有办法既吸收它们，又使 Python 代码更易于阅读和编写。这意味着学习其它专注于特定软件开发风格的编程语言，可以帮助我们在使用 Python 时，提高对这种编程风格的理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提供帮助，我在下面列出了一些值得探索的领域，以及可能加深对这些领域的理解的语言。我尽可能链接了维基百科的页面，而不是直接链接到语言的主页，因为维基百科经常会提供有趣的历史背景，当你为了教育目的学习一门新的编程语言，而不是直接用于实际应用时，这些背景值得去了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我知道这些语言中的大部分（并且在开发生产系统时使用过几种），但这份推荐清单中还包括我间接知道的语言（通常是通过阅读教程和设计文档，或者通过与我信任的人交谈，以获取对一门语言的优点与缺陷的洞察）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有很多本应该放但没有放进名单里的语言语言，所以下面罗列的仅是我感兴趣的部分（例如，我主要感兴趣的是 Linux、Android 和 Windows 的生态系统，所以我舍弃了 Apple 生态中的 Objective-C 和 Swift 语言，另外我也不熟悉 Processing 这种专注于艺术的编程语言，无法想象学习它们能教给 Python 开发者什么）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了考虑一门语言可能教给你的东西，如果你想获得一份更全面的清单，可以去查看 IEEE Spectrum 关于编程语言流行度和增长度的年度榜单。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过程式编程：C、Rust、Cython&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 默认的执行模型是过程式的：从主模块的顶部开始，逐条语句地执行。Python 对下面介绍的所有数据和编程建模方法的支持，都建立在这种过程式的执行模型上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C 语言仍然是无可争议的底层过程式编程的统治者。它是 Python 官方解释器以及 Linux 操作系统内核的核心实现语言。作为一名软件开发人员，学习 C 语言是更多地了解底层硬件的最好方法之一——C 语言经常被称为“可移植的汇编语言”，对于任何新的 CPU 架构来说，第一个交叉编译的应用程序将是 C 编译器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rust 是一种相对较新的编程语言，由 Mozilla 创造。Rust 的目标是吸取整个行业在不使用 C 时遇到的所有教训，设计一门能与 C 库相互操作的新语言，提供底层的系统编程所需的对硬件用途的精确控制，但使用不同的编译方法来进行数据建模和内存管理，从结构上消除许多困扰 C 程序的常见缺陷（如缓冲区溢出、指针重复释放错误、空指针访问和线程同步问题）。经过培训和早期的专业经验，我是一名嵌入式系统工程师，而 Rust 是我见过的第一种看起来有潜力缩减当前由 C 语言和自定义汇编代码所主导的生态位的新语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cython 也是一种较底层的过程式语言，但与 C 和 Rust 等通用语言不同，Cython 专门用于编写 CPython 的扩展模块。为了实现这一目标，Cython 被设计为 Python 的超集，允许程序员选择何时支持纯 Python 语法以获得灵活性，何时支持 Cython 的语法扩展，以便生成在速度和内存效率方面能与原生 C 代码相当的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，你可以加深在内存管理、算法效率、二进制接口（ABI）兼容性、软件可移植性、以及将源代码转换为运行系统等实践方面的见解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向对象的数据模型：Java、C#、Eiffel&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编程最主要做的事情之一是为现实世界建模，最流行的做法是提供原生的语法支持面向对象编程：对数据作结构化的分组，使用类方法操作那些数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 本身是经过精心设计的，无需先编写自己的类就可以使用面向对象的特性。并不是每种语言都采用这种方法——本小节中列出的语言都认为学习面向对象设计是使用该语言的必要条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 20 世纪 90 年代中后期，Sun Microsystems 公司进行了一次大规模的市场推广，Java 成为了许多高等院校中计算机科学入门课的默认语言。虽然如今在许多教学活动中，Java 已经被 Python 所取代，但它仍然是开发商用程序时最流行的语言之一。还有一些基于通用 JVM（Java 虚拟机）运行时的语言，例如 Python 的 Jython 实现。Android 系统的 Dalvik 和 ART 环境则是基于 Java 开放的 API 二次开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C# 在许多方面与 Java 相似，在 Sun 和微软未能解决他们关于微软的 Java 实现（即 J++）的业务差异之后，C# 成为了一种替代方案。像 Java 一样，这是一门开发商用程序的流行语言，还有其它一些语言共享着 .NET CLR（公共语言运行时），包括 Python 的 IronPython 实现 （最早的 IronPython 1.0 的核心组件被提取成了与语言无关的 .NET 动态语言运行库）。在很长一段时间里，. NET 是一种专用于 Windows 的技术，而 mono 作为一种跨平台的开源实现，但微软在 2015 年初转向了开源生态系统战略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与此清单中的大多数语言不同，我不推荐在日常工作中使用 Eiffel。但是，我依然推荐学习它，因为它教会了我许多关于良好的面向对象设计的知识，比如它认为“可验证的正确性”是应用程序的设计目标。（学习 Eiffel 也让我明白了为什么“可验证的正确性”并不是大多数软件开发时的设计目标，因为可验证的正确软件实在不能很好地处理模糊性，并且完全不适用于那些你不清晰相关的约束条件却需要给自己留下足够的回旋余地，以便能够通过迭代开发找出更具体的细节的情况。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，你可以深入了解继承模型、契约式设计、类不变性（class invariant）、前置条件、后置条件、协方差、逆变、类方法解析顺序、泛型编程以及其它适用于 Python 类型系统的概念。还有很多标准库模块和第三方框架使用这种“看得见的面向对象”的设计风格，比如 unittest 和 logging 模块，以及 Django 框架中基于类的视图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTMZUlOOFxxZ8NVAnZ1XIsmNqLlObVtC06Xm0a6CSLvAYd75fpNtCJm72YiaRHaGt3pIMCcayictNj5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向对象的 C 派生：C++、D&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPython 运行环境可以被视为一个“带有对象的 C”的编程环境——在其核心，CPython 使用 C 的方法实现面向对象编程，即定义 C 结构体来保存相关的数据，并将结构体的实例作为第一个参数传递给函数，然后对数据进行操作（这就是 CPython C API 中全能的 PyObject * 指针）。这种设计模式对应到 Python 层面，就是实例方法的显式 self 参数以及类方法的显式 cls 参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C++ 的目标是保持与 C 语言源代码的完全兼容，同时添加更高级的特性，例如支持原生的面向对象编程和基于模板的元编程。它是出了名的冗长和难以编程（尽管 2011 年对语言标准的更新解决了许多糟糕的问题），但它也是许多领域的编程首选，包括 3D 建模的图形化引擎和跨平台应用的开发框架（例如 Qt）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D 语言也很有趣，因为它与 C++ 的关系类似于 Rust 与 C 的关系：它的目标是保留 C++ 的大多数令人满意的特性，同时也避免它的许多问题（如缺乏内存安全）。不像 Rust，D 不是一种从头开始设计的新编程语言——恰恰相反，D 是 C++ 的衍生物，虽然它不像 C++ 一样是一个严格的 C 超集，但它遵循着一个设计原则，即任何落入 C 和 D 的共同子集的代码，在两种语言中必须要表现一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，你可以更深入地了解将高级语言的特性与底层 C 运行时模型相结合的复杂性。学习 C++，在 Python 中操作用 C++ 编写的库和工具包时，也可能会有帮助。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向数组的数据处理：MATLAB/Octave、Julia&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向数组的编程是为了支持数值编程模型：那些基于矩阵代数和相关数值方法的模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Python 的标准库不直接支持这一点，但 Python 在设计时考虑了面向数组的编程，并专门为第三方 NumPy 库和类似的面向数组的工具添加了一系列语法和语义特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在许多方面，Python 的科学技术栈 被作为商业 MATLAB 的替代方案，后者被广泛用于科学和工程领域的建模、仿真和数据分析。GNU Octave 是一个开源的方案，目标是兼容 MATLAB 代码的语法，允许人们对照这两种面向数组的编程方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Julia 是另一种相对较新的语言，重点关注面向数组的编程和基于类型的函数重载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，你可以了解 Python 的科学技术栈，以及有机会通过像 OpenCL 和 Nvidia 的 CUDA 这种技术来探索硬件层面的并行执行，并通过 Apache Spark 和专用于 Python 的 Blaze 来了解分布式数据处理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统计数据分析：R&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着对大型数据集的接触越来越多，对灵活处理这些数据集的分析工具的需求也越来越大。R 编程语言就是这样的工具，它特别关注统计性的数据分析和可视化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习 R 能会让你深入了解 Python 在科学技术栈的统计分析能力，尤其是 pandas 数据处理库和 seaborn 统计可视化库。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;计算管道建模：Haskell、Scala、Clojure、F#&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向对象的数据建模和面向数组的数据处理主要关注静态的数据，无论是以命名的属性形成集合的形式，还是以结构化数据形成数组的形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之下，函数式编程语言强调以计算流的形式对动态数据进行建模。即便只学习函数式编程的基本知识，也能极大地改进数据转换操作的结构，即使在其它过程式、面向对象或面向数组的程序中也是如此。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Haskell 是一种函数式编程语言，对 Python 的设计产生了重大影响，最显著的是在 Python 2.0 中引入的列表推导式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Scala 是一种（存疑的）JVM 函数式编程语言，加上 Java、Python 和 R，它们是 Apache Spark 数据分析平台的四种主要编程语言。尽管 Scala 的设计偏重于函数式编程，但它的语法、数据模型和执行模型的设计也最大限度地降低 Java 程序员使用的门槛（因此所谓“存疑的”——其实是因为，Scala 最好被归类为一门具有强函数式编程支持的面向对象编程语言）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Clojure 是另一种基于 JVM 的函数式编程语言，是 Lisp 的一种方言。它之所以出现在这份清单里，因为它是 Python 的 toolz 函数式编程工具包的灵感来源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;F# 不是我自己特别熟悉的语言，但它作为 .net CLR（公共语言运行时）推荐的函数式编程语言，所以还是值得关注。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，你可以深入了解 Python 自己的计算管道建模工具，包括容器推导式、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247483950&amp;amp;idx=1&amp;amp;sn=7b53bbf87c180f3f8a2737a921c97bf6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;生成器&lt;/a&gt;、生成器表达式、functools 和 itertools 标准库，以及第三方的 Python 函数工具包，比如 toolz。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事件驱动编程：JavaScript、Go、Erlang、Elixir&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算管道是处理数据转换和分析问题的一种极佳的方法，但许多问题需要程序作为持久性服务运行，等待事件发生，然后处理那些事件。在这类服务中，为了能够同时容纳多个用户（或多个操作），通常必须要并发地处理多个事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript 最初是作为 Web 浏览器的事件处理语言而开发的，允许网站开发者在本地响应客户端操作（如鼠标点击和按键敲击）和事件（如网页完成了渲染）。所有现代浏览器都支持它，它与 HTML5 领域对象模型（DOM）一起，已经成为一种定义用户界面外观和行为的事实上的标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 是谷歌设计的一种用于创建高度可伸缩的 Web 服务的专用语言，并且已经被证明是一种非常适合开发命令行应用程序的语言。从编程语言设计的角度来看，Go 最有趣的方面是在其核心并发模型中使用了通信顺序进程（Communicating Sequential Processes）概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Erlang 是由爱立信设计的专用语言，用于创建高度可靠的电话交换机以及类似的设备。它被用于开发出了流行的 RabbitMQ 消息代理中间件。Erlang 使用 Actor 模型作为核心的并发原语，在执行线程之间传递消息，而不是让它们直接共享数据。虽然我从未用过 Erlang 编程，但我的第一份全职工作涉及一个基于 Actor 的 C++ 并发框架，而该框架由一名前爱立信工程师开发，另外，我自己也开发了一个这样的框架，基于德州仪器（Texas Instrument）的轻量级 DSP/BIOS 运行时（现在的 TI-RTOS）里面的 TSK （Task）和 MBX （Mailbox）原语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elixir 出现在这份清单里，因为它被设计运行在 Erlang VM 上，提供了与 Erlang 相同的并发语义，同时还提供了一系列在语言层面上的特性，打造出一个更加全面的环境，更有可能吸引其它语言例如 Python、Java 或 Ruby 的开发者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，你可以深入了解 Python 对并发和并行的支持，包括&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247483976&amp;amp;idx=1&amp;amp;sn=3074809f0dfc1e90bc657cdd48e3e4f6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;原生协程&lt;/a&gt;、基于生成器的协程、concurrent.futures 和 asyncio 标准库模块、第三方网络服务开发框架（如 twisted 和 Tornado）、Django 中引入的 channel 概念、GUI 框架中的事件处理循环。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUyOTk2MTcwNg==&amp;amp;action=getalbum&amp;amp;album_id=1413329638813827073#wechat_redirect&quot; textvalue=&quot;Python进阶&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python进阶&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;渐变类型：TypeScript&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Python 3.5 中出现的一个比较有争议的特性是新引入的 typing 模块，它为 Python 生态带来了一个支持渐变类型的标准词典。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python猫注：Gradual typing 是 Jeremy Siek 和 Walid Taha 在 2006 年提出的理论，允许程序中同时出现动态类型与静态类型。国内有人将其翻译为“渐进类型”、“渐近类型”、“渐进定型”、“动静混合类型”等等，但我觉得并不够好。&lt;strong&gt;渐变类型&lt;/strong&gt;也许是我的首创，借鉴自 Photoshop 的渐变颜色，表达出从动态类型到静态类型的过渡（或者说交融共处的）特点。“渐变”一词有打破界限分明的状态（如大小、远近、明暗），从而达到中和状态的含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于那些主要从 C、C++ 和 Java 等语言中接触静态类型的人来说，这似乎是一个令人吃惊的糟糕特性（因此引发了争议）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微软的 TypeScript 为 Javascript 程序提供了渐变类型，因此它能更好地解释这个概念。TypeScript 代码会被编译成 JavaScript 代码（然后就不包含运行时类型检查），流行的 JavaScript 库的 TypeScript 注解会维护在专用的 DefinitelyTyped 仓中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如 Chris Neugebauer 在澳大利亚 PyCon 演讲 中指出的，这很像是 Python 与 typeshed 类型提示库、以及像 mypy 这种类型推断和分析工具之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本质上，TypeScript 和 Python 中的类型提示都是编写特定种类的测试的方式，要么使用单独的文件（就像普通测试一样），要么嵌入在代码体中（就像静态类型语言中的类型声明一样）。对于这两种情况，你都要运行一个单独的命令，来检查其余代码是否与已添加的类型断言一致（对于 TypeScript，这是在编译成 JavaScript 时隐式地发生的；对于 Python 的类型提示，这是一个完全可选的静态分析任务）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态元编程：Hy、Ruby&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C、C++、C# 和 Java 等语言的学习者在接触 Python 时，经常感到不安的一个特性是“代码即数据”（code is data）：函数和类之类的东西是运行时对象，可以像其它对象一样被操纵。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hy 是一种 Lisp 方言，可以同时在 CPython VM 和 PyPy VM 上运行。Lisp 及其方言将“代码即数据”的概念推到了极致，因为 Lisp 代码由嵌套列表组成，这些列表描述了要执行的操作（这门语言的名称本身就代表列表处理器“LISt Processor”）。Lisp 风格语言的强大之处在于，它让你非常容易编写出自己的领域特定代码。Lisp 风格语言的最大缺点是，它让你非常容易编写出自己的领域特定代码，但这可能导致每个人写的代码变得难以阅读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Ruby 语言在许多方面与 Python 相似，但对于 Python 中“支持但不鼓励”的动态元编程特性，Ruby 社区则相对开放。这包括在已有类定义中添加新的方法，以及使用闭包来实现语言的核心结构，例如迭代。（Python猫注：关于两种语言中迭代结构的实现对比，可阅读 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247495222&amp;amp;idx=1&amp;amp;sn=7512c9214057442114a59b43ac53257b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;这篇文章&lt;/a&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，可以让你深入了解 Python 自己的动态元编程特性，包括&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485013&amp;amp;idx=1&amp;amp;sn=d914c899f41d89eb5aaa51b1dd52d4bc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;函数和类装饰器&lt;/a&gt;、猴子补丁、unittest.mock 标准库、以及像 wrapt 这样的第三方对象代理模块。（我不知道学习哪种语言可以深入了解 Python 的元类系统，如果有人在这方面有任何建议，请在评论中告知我。Python 的元类驱动着很多特性，例如核心的类型系统、抽象基类、枚举类型和渐变类型表达式的运行时求值。）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;务实问题解决：Lua、PHP、Perl&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主流的编程语言并不是孤立存在的——它们作为一个更大的生态系统的一部分而存在，这个生态系统由发行者（企业和社区组织）、终端用户、框架开发者、工具开发者、教育工作者等等组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lua 是一种流行的编程语言，作为一种脚本引擎嵌入到大型程序中。标志性的例子是它被魔兽世界游戏用来编写客户端插件，它也被嵌入到了许多 Linux 发行版所使用的 RPM 组件中。与 CPython 相比，Lua 运行时的大小通常只有 CPython 的十分之一，而且由于较弱的自省能力，它更容易与程序的其它部分以及服务器的操作系统隔离开来。Lua 社区对 Python 生态的一个显著贡献是 LuaJIT FFI（Foreign Function Interface 外来函数接口），它被 CPython 和 PyPy 采用，作为支持 JIT 的 cffi 接口库的基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PHP 是另一种流行的编程语言，作为 Linux-Apache-MySQL-PHP LAMP 技术栈中的“P”而崛起，因为它专注于生成 HTML 页面，并且在早期的虚拟专用服务器（Virtual Private Server，简称 VPS） 提供商中广泛使用。尽管其设计上有诸多的概念性缺陷让人感到绝望，但它如今是几个极其流行的开源 Web 服务的基础，包括 Drupal 内容管理系统、Wordpress 博客引擎和维基百科的 MediaWiki 引擎。PHP 还支撑着一些重要的服务，比如 Ushahidi 平台，它是一个开源的社会化新闻发布社区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 PHP 一样，Perl 也是基于 Linux 而崛起。但跟 PHP 专门作为 Web 开发平台不同，Perl 是系统管理员的工具，在基于文本的 Linux 操作系统中，它使用正则表达式将命令的输出转成字符串，并进行操作。当 sh、awk 和 sed 都无法胜任某些任务时，Perl 出现并派上了用场。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习这些语言，在编程语言设计方面，不大可能获得什么漂亮审美或者优雅概念。学习它们，最可能的是了解编程语言在现实中是如何被分发和采用的，以及这些在多大程度上取决于偶然的机会、历史意外事件、以及发行商在系统中默认集成而降低了使用门槛，而不是取决于语言本身固有的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别是，它可以提供对以下项目的重要性的洞察：CKAN、OpenStack NFV、Blender、SciPy、OpenMDAO、PyGMO、PyCUDA、树莓派基金会和 Python 被大量商业组织采用，以保护它们在 Python 生态中不断的投入。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;编程思维：Scratch、Logo&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我经常跟函数式编程以及面向对象编程的拥护者们讨论，他们声称这类语言就像过程式语言一样易于学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们谈论的是通过嵌入式编程（例如机器人）进行教学，在软件中建模的对象都有现实世界的对应物，比如学生们可以触摸的传感器、马达和继电器，那么，那我会认为 OOP 的人有一定的道理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是对于其他人，我现在有一个标准的挑战：拿起一本烹饪书，把其中一个食谱翻译成你认为是容易学习的编程语言，然后找一个能理解烹饪书中语言的学生，让其按照翻译好的食谱操作。其实，他们不需要真正地操作下去——只需做一个思想实验，就足以意识到他们声称的“很容易学”是假设了多少先验知识。（我很期待看到学术研究人员在现实中做这种研究——我真的很希望看到结果）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种解决这个问题的方法是去学习那些实际上被用来教孩子们编程思维的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最受欢迎的是 Scratch，它使用了拖放编程界面，让学生们操纵一个独立的图形环境，它里面的电子图形可以移动，并响应环境中的事件。像 Scratch 这样的图形环境就相当于我们用来教孩子阅读和书写的图画书。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用特殊的教育语言来操作图形环境的想法并不新鲜，最早的例子之一是 1960 年代发明的 Logo 环境。在 Logo 中（以及类似的环境，如 Python 的 turtle 模块），你主要打交道的是一个“乌龟（turtle）”，你可以通过绘制线条来指导它移动和修改环境。这样的话，命令序列、重复和状态（例如，“起笔”、“落笔”）可以基于人们的自然直觉来使用（“想象你是那只乌龟，如果你右转 90 度会发生什么？”）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾并重新学习这些语言，有助于有经验的程序员放下固化的观念：它们所用的概念可以提醒我们，这些概念是我们如今认为理所当然的，但初学者们需要先学习。当这样做的时候，我们能够更好地与学生和其他初学者们相处，因为我们更有可能打开逻辑的枷锁，也不会再忽略那些有必要的学习步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;译者附注：以上就是全部的译文。我还翻译过不少优质的文章，分享近期的几篇如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247495222&amp;amp;idx=1&amp;amp;sn=7512c9214057442114a59b43ac53257b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;通过 for 循环，比较 Python 与 Ruby 编程思想的差别&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247494861&amp;amp;idx=1&amp;amp;sn=2d0ce5425ef047ee6cdc72331d871508&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python 官方研讨会：彻底移除 GIL 真的可行么？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247494627&amp;amp;idx=1&amp;amp;sn=f2d1298b5f2f9d6596b542429bafe5a0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;与 Python 之父聊天：更快的 Python！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247489580&amp;amp;idx=1&amp;amp;sn=65bf320762811fce27d7338b71869487&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;深入 Python 解释器源码，我终于搞明白了字符串驻留的原理！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247492664&amp;amp;idx=1&amp;amp;sn=7c06e2cf3587bd9087e3d3f53f7bdd64&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;为什么 Python 没有函数重载？如何用装饰器实现函数重载？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247489487&amp;amp;idx=1&amp;amp;sn=5ac04a26ab833a6201e5a4f82b8d0cc8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Python优化机制：常量折叠&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>88438efc548250f6ba016b1fc339f78b</guid>
<title>Raft：寻找一种易于理解的一致性算法</title>
<link>https://toutiao.io/k/79oehr1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;ol class=&quot;list-paddingleft-2&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人 T 的日志条目，并且给领导人 U 投票了，如图 9。这个投票者是产生这个矛盾的关键。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (e) 中的索引 2。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>