<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>84913401e1d36baf008d1323a5ccb08f</guid>
<title>大数据告诉你：程序员真的是吃青春饭的吗？</title>
<link>https://toutiao.io/k/wqo3p4x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;程序员真的是吃青春饭的吗？不少程序员认为编程只能干到 35 岁，事实果真如此吗？&lt;br/&gt;&lt;br/&gt;一篇基于 StackOverflow.com 上的用户数据分析做出的论文《Is Programming Knowledge Related To Age?》，给出了一些答案。&lt;br/&gt;论文地址：https://people.engr.ncsu.edu/ermurph3/papers/msr13.pdf&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据采样和清洗条件：1694981 位用户，平均年龄 30.3 岁。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来具体看下&lt;strong&gt;：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;年龄分布图&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到程序员年龄的正态分布：高点在 25 岁左右，但是中点在 29 岁左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9394495412844037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8kVlpmZh0m9tqplzkQOkC7EQDYuXSbGdIsrRwz809cYAeicnumKfaFOckGicnIacG6ETSMmHnvhBHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;能力和年龄分布图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算每个人每个月的 Reputation，这样可以找到这个用户的真正活跃时间，便于计算这个程序员的真实能力。总声望/活跃时间，可以得到他平均每个月得来的 Reputation。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9887640449438202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8kVlpmZh0m9tqplzkQOkC7gPbI1yDD6WVu3vRTPWbwRKDAkoCxj9kJwrqMZibicvePKJI0W4bJDJqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;534&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到：程序员的能力从 25 岁左右开始上升，一直到 50 岁后才会开始下降。所以说，&lt;strong&gt;程序员吃的不是青春饭&lt;/strong&gt;。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;年纪大的人是否跟不上新技术？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文作者用了最近 5 年内比较流行的技术 Tag，然后用了一套比较严谨的算法来查看那些所谓的 “老程序员” 是否在新技术上跟上不了。所谓跟不上，就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是 37 岁以上的程序员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从下表可以看到：老程序员和年轻程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.30092592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8kVlpmZh0m9tqplzkQOkC7S6WFfraS2yCZjJCUYNgqiaFbwLVtPNJfT5l0iadr1LJhOvCsRdqlJZhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后，论文得出结论：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、程序员技术能力上升是可以到 50 岁或 60 岁的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、老程序员在获取新技术上的能力并不比年轻的程序员差。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;由上面的数据分析可以看出，因为太浮燥，才会说 30 岁是程序员的顶峰。&lt;br/&gt;其实，对于大多数人来说，如果还没有编程到 30 岁，还不能成为一个 “合格” 的程序员。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;并不是编程编到 30 岁就玩完了，而是编程编到 30 岁才刚刚入门。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拒绝浮躁，加入我们！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👇👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」&lt;br/&gt;只限 VIP 会员加入的交流圈子&lt;br/&gt;大厂「内推机会」&lt;br/&gt;N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>abd618011d7eb5ea99204940b30b91c6</guid>
<title>[推荐] [译] Uber：面向领域的微服务架构</title>
<link>https://toutiao.io/k/0yy2iga</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4aca8a855105dafd2c61cabdb0a4cdac</guid>
<title>[推荐] 一文读懂，DDD 落地数据库设计实战</title>
<link>https://toutiao.io/k/6aau0fc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;作者范钢，曾任航天信息首席架构师，《大话重构》一书的作者。本文根据具体实例详细描述了DDD 落实到数据库设计的整个过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;阅读本文之前建议先阅读上一篇文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5MTIyODk1Mg==&amp;amp;mid=2247484368&amp;amp;idx=1&amp;amp;sn=30a1ec30d05a454f8451332d0b492ae3&amp;amp;chksm=fe337aa7c944f3b148ba696f2014229f817edec9a2d854e88b6c218cad382da5805faf24ddbb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;万字长文，结合电商支付业务一文搞懂DDD&lt;/a&gt;》&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;过去，系统的软件设计是以数据库设计为核心，当需求确定下来以后，团队首先开始进行数据库设计。因为数据库是各个模块唯一的接口，当整个团队将数据库设计确定下来以后，就可以按照模块各自独立地进行开发了，如下图所示。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.31003811944091486&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2cQpgGpcpsf4mDb3aPokrFrD9vp1aTzAmsmqwAtDU6sCDhoxv8JUKwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1574&quot;/&gt;&lt;/p&gt;&lt;p&gt;在上面的过程中，为了提高团队开发速度，尽量让各个模块不要交互，从而达到各自独立开发的效果。但是，随着系统规模越来越大，业务逻辑越来越复杂，我们越来越难于保证各个模块独立不交互了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着软件业的不断发展，软件系统变得越来越复杂，各个模块间的交互也越来越频繁，这时，原有的设计过程已经不能满足我们的需要了。因为如果要先进行数据库设计，但数据库设计只能描述数据结构，而不能描述系统对这些数据结构的处理。因此，在第一次对整个系统的梳理过程中，只能梳理系统的所有数据结构，形成数据库设计；接着，又要再次梳理整个系统，分析系统对这些数据结构的处理过程，形成程序设计。为什么不能一次性地把整个系统的设计梳理到位呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5656324582338902&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja28ksGdUXicNxGegP5VKSsj5MOrYBuCZXMeVl29AYO1QhtfXr4jJIeBVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现如今，我们已经按照面向对象的软件设计过程来分析设计系统了。当开始需求分析时，首先进行用例模型的设计，分析整个系统要实现哪些功能；接着进行领域模型的设计，分析系统的业务实体。在领域模型分析中，采用类图的形式，每个类可以通过它的属性来表述数据结构，又可以通过添加方法来描述对这个数据结构的处理。因此，在领域模型的设计过程中，既完成了对数据结构的梳理，又确定了系统对这些数据结构的处理，这样就把两项工作一次性地完成了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个设计过程中，其核心是领域模型的设计。以领域模型作为核心，可以指导系统的数据库设计与程序设计，此时，数据库设计就弱化为了领域对象持久化设计的一种实现方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;领域对象持久化的思想&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;什么叫领域对象的持久化呢？在当今软件架构设计的主流思想中，面向对象设计成了主流思想，在整个系统运行的过程中，所有的数据都是以领域对象的形式存在的。譬如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如我们的服务器是一台超级强大的服务器，那实际上不需要任何数据库，直接操作这些领域对象就可以了，但在现实世界中没有那么强大的服务器。因此，必须将暂时不用的领域对象持久化存储到磁盘中，而数据库只是这种持久化存储的一种实现方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按照这种设计思想，我们将暂时不使用的领域对象从内存中持久化存储到磁盘中。当日后需要再次使用这个领域对象时，根据 key 值到数据库查找到这条记录，然后将其恢复成领域对象，应用程序就可以继续使用它了，这就是领域对象持久化存储的设计思想。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，今天的数据库设计，实际上就是将领域对象的设计按照某种对应关系，转换成数据库的设计。同时，随着整个产业的大数据转型，今后的数据库设计思想也将发生巨大的转变，有可能数据库就不一定是关系型数据库了，也许是 NoSQL 数据库或者大数据平台。数据库的设计也不一定遵循 3NF（第三范式）了，可能会增加更多的冗余，甚至是宽表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据库设计在发生剧烈的变化，但唯一不变的是领域对象。这样，当系统在大数据转型时，可以保证业务代码不变，变化的是数据访问层（DAO）。这将使得日后大数据转型的成本更低，让我们更快地跟上技术快速发展的脚步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;领域模型的设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;此外，这里有个有趣的问题值得探讨：领域模型的设计到底是谁的职责，是需求分析人员还是设计开发人员？我认为，它是两个角色相互协作的产物。而未来敏捷开发的组织形成，团队将更加扁平化。过去是需求分析人员做需求分析，然后交给设计人员设计开发，这种方式就使得软件设计质量低下而结构臃肿。未来“大前端”的思想将支持更多设计开发人员直接参与需求分析，实现从需求分析到设计开发的一体化组织形式。这样，领域模型就成为了设计开发人员快速理解需求的利器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之，**DDD 的数据库设计实际上已经变成了：以领域模型为核心，如何将领域模型转换成数据库设计的过程。**那么怎样进行转换呢？在领域模型中是一个一个的类，而在数据库设计中是一个一个的表，因此就是将类转换成表的过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5829207920792079&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2icyGXibvSnzUbKPGNfhPjspXlJZQX6Q89rTuuyX29Ap7bXUNyVnvFwEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上图是一个绩效考核系统的领域模型图，该绩效考核系统首先进行自动考核，发现一批过错，然后再给一个机会，让过错责任人对自己的过错进行申辩。这时，过错责任人可以填写一张申辩申请单，在申辩申请单中有多个明细，每个明细对应一个过错行为，每个过错行为都对应了一个过错类型，这样就形成了一个领域模型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接着，要将这个领域模型转换成数据库设计，怎么做呢？很显然，领域模型中的一个类可以转换成数据库中的一个表，类中的属性可以转换成表中的字段。但这里的关键是如何处理类与类之间的关系，如何转换成表与表之间的关系。这时候，就有 5 种类型的关系需要转换，即传统的 4 种关系 + 继承关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;传统的 4 种关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;传统的关系包含一对一、多对一、一对多、多对多这 4 种，它们既存在于类与类之间，又存在于表与表之间，所以可以直接进行转换。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 一对一关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在以上案例中，“申辩申请单明细”与“过错行为”就是一对“一对一”关系。在该关系中，一个“申辩申请单明细”必须要对应一个“过错行为”，没有一个“过错行为”的对应就不能成为一个“申辩申请单明细”。这种约束在数据库设计时，可以通过外键来实现。但是，一对一关系还有另外一个约束，那就是一个“过错行为”最多只能有一个“申辩申请单明细”与之对应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说，一个“过错行为”可以没有“申辩申请单明细”与之对应，但如果有，最多只能有一个“申辩申请单明细”与之对应，这个约束暗含的是一种唯一性的约束。因此，将过错行为表中的主键，作为申辩申请单明细表的外键，并将该字段升级为申辩申请单明细表的主键。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6288532675709001&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2HbkOib8WdmQzBnyFYCyibJ4rlFZE4trXmKibS6clur4bhyhDqibQaZZIaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1622&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 多对一关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;是日常的分析设计中最常见的一种关系。在以上案例中，一个过错行为对应一个税务人员、一个纳税人与一个过错类型；同时，一个税务人员，或纳税人，或过错类型，都可以对应多个过错行为。它们就形成了“多对一”关系。在数据库设计时，通过外键就可以建立这种“多对一”关系。因此，我们进行了如下数据库的设计：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6554524361948956&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2F2msObeSGZNYENOYy1NQNPPiaQIQxLsdkoCKPiau8hdgbNcD5FwNQpbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1724&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;多对一关系在数据库设计上比较简单，然而落实到程序设计时，需要好好探讨一下。比如，以上案例，在按照这样的方式设计以后，在查询时往往需要在查询过错行为的同时，显示它们对应的税务人员、纳税人与过错类型。这时，以往的设计是增加一个 join 语句。然而，这样的设计在随着数据量不断增大时，查询性能将受到极大的影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说，join 操作往往是关系型数据库在面对大数据时最大的瓶颈之一。因此，一个更好的方案就是先查询过错行为表，分页，然后再补填当前页的其他关联信息。这时，就需要在“过错行为”这个值对象中通过属性变量，增加对税务人员、纳税人与过错类型等信息的引用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 一对多关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该关系往往表达的是一种主-子表的关系。譬如，以上案例中的“申辩申请单”与“申辩申请单明细”就是一对“一对多”关系。除此之外，订单与订单明细、表单与表单明细，都是一对多关系。一对多关系在数据库设计上比较简单，就是在子表中增加一个外键去引用主表中的主键。比如本案例中，申辩申请单明细表通过一个外键去引用申辩申请单表中的主键，如下图所示。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5017878426698451&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja23z3Y8LOXnGYBNs2VgmDibwWDr0ldSgHw1vlZZEibsibdfDANTqEGQjkibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1678&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除此之外，在程序的值对象设计时，主对象中也应当有一个集合的属性变量去引用子对象。如本例中，在“申辩申请单”值对象中有一个集合属性去引用“申辩申请单明细”。这样，当通过申辩申请单号查找到某个申辩申请单时，同时就可以获得它的所有申辩申请单明细，如下代码所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Sbsqd&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Set&amp;lt;SbsqdMx&amp;gt; sbsqdMxes;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setSbsqdMxes&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Set&amp;lt;SbsqdMx&amp;gt; sbsqdMxes&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.sbsqdMxes = sbsqdMxes;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Set&amp;lt;SbsqdMx&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getSbsqdMxes&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.sbsqdMxes;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ……&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4. 多对多关系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比较典型的例子就是“用户角色”与“功能权限”。一个“用户角色”可以申请多个“功能权限”；而一个“功能权限”又可以分配给多个“用户角色”使用，这样就形成了一个“多对多”关系。这种多对多关系在对象设计时，可以通过一个“功能-角色关联类”来详细描述。因此，在数据库设计时就可以添加一个“角色功能关联表”，而该表的主键就是关系双方的主键进行的组合，形成的联合主键，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6456692913385826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2F7s5wJ7abIGyt7TXL2FNMvCmO97WFnlE11hmmibpVqKo9SZMlL3AnoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上是领域模型和数据库都有的 4 种关系。因此，在数据库设计时，直接将相应的关系转换成数据库设计就可以了。同时，在数据库设计时还要将它们进一步细化。如在领域模型中，不论对象还是属性，在命名时都采用中文，这样有利于沟通与理解。但到了数据库设计时，就要将它们细化为英文命名，或者汉语拼音首字母，同时还要确定它们的字段类型与是否为空等其他属性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;继承关系的 3 种设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第 5 种关系就不太一样了：继承关系是在领域模型设计中有，但在数据库设计中却没有。如何将领域模型中的继承关系转换成数据库设计呢？有 3 种方案可以选择。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 继承关系的第一种方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，看看以上案例。“执法行为”通过继承分为“正确行为”和“过错行为”。如果这种继承关系的子类不多（一般就 2 ~ 3 个），并且每个子类的个性化字段也不多（3 个以内）的话，则可以使用一个表来记录整个继承关系。在这个表的中间有一个标识字段，标识表中的每条记录到底是哪个子类，这个字段的前面部分罗列的是父类的字段，后面依次罗列各个子类的个性化字段。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6769456681350955&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2Iu19owxRicyNGJ8drhxhhwMeysibuEAJNB2RhJOicnkP8DPdhTJVLwSkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1362&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;采用这个方案的优点是简单，整个继承关系的数据全部都保存在这个表里。但是，它会造成“表稀疏”。在该案例中，如果是一条“正确行为”的记录，则字段“过错类型”与“扣分”永远为空；如果是一条“过错行为”的记录，则字段“加分”永远为空。假如这个继承关系中各子类的个性化字段很多，就会造成该表中出现大量字段为空，称为“表稀疏”。在关系型数据库中，为空的字段是要占用空间的。因此，这种“表稀疏”既会浪费大量存储空间，又会影响查询速度，是需要极力避免的。所以，当子类比较多，或者子类个性化字段多的情况是不适合该方案（第一种方案）的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 继承关系的第二种方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果执法行为按照考核指标的类型进行继承，分为“考核指标1”“考核指标2”“考核指标3”……如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8019639934533551&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2sbNxTftX9r6mKTicuWZMwBZibiaoPUmNyLkHnNibggZhuibQcL8I8BgPqicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1222&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;并且每个子类都有很多的个性化字段，则采用前面那个方案就不合适了。这时，用另外两个方案进行数据库设计。其中一个方案是将每个子类都对应到一个表，有几个子类就有几个表，这些表共用一个主键，即这几个表的主键生成器是一个，某个主键值只能存在于某一个表中，不能存在于多个表中。每个表的前面是父类的字段，后面罗列各个子类的字段，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.559322033898305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2icnd2zVxic66CmkxHSTgjBwTpBV5eRtfDWab59pgRSLU5GL7H5SQdaHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果业务需求是在前端查询时，每次只能查询某一个指标，那么采用这种方案就能将每次查询落到某一个表中，方案就最合适。但如果业务需求是要查询某个过错责任人涉及的所有指标，则采用这种方案就必须要在所有的表中进行扫描，那么查询效率就比较低，并不适用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 继承关系的第三种方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果业务需求是要查询某个过错责任人涉及的所有指标，则更适合采用以下方案，将父类做成一个表，各个子类分别对应各自的表（如图所示）。这样，当需要查询某个过错责任人涉及的所有指标时，只需要查询父类的表就可以了。如果要查看某条记录的详细信息，再根据主键与类型字段，查询相应子类的个性化字段。这样，这种方案就可以完美实现该业务需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6565656565656566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2ibFeKicI0vRNhiajQDWRBicia35a07OthCCJxQwCZ3LFOyfVgfmia7DpYRXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1584&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上所述，将领域模型中的继承关系转换成数据库设计有 3 种方案，并且每个方案都有各自的优缺点。因此，需要根据业务场景的特点与需求去评估，选择哪个方案更适用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;NoSQL 数据库的设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前面我们讲的数据库设计，还是基于传统的关系型数据库、基于第三范式的数据库设计。但是，随着互联网高并发与分布式技术的发展，另一种全新的数据库类型孕育而生，那就是NoSQL 数据库。正是由于互联网应用带来的高并发压力，采用关系型数据库进行集中式部署不能满足这种高并发的压力，才使得分布式 NoSQL 数据库得到快速发展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也正因为如此，NoSQL 数据库与关系型数据库的设计套路是完全不同的。关系型数据库的设计是遵循第三范式进行的，它使得数据库能够大幅度降低冗余，但又从另一个角度使得数据库查询需要频繁使用 join 操作，在高并发场景下性能低下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，NoSQL 数据库的设计思想就是尽量干掉 join 操作，即将需要 join 的查询在写入数据库表前先进行 join 操作，然后直接写到一张单表中进行分布式存储，这张表称为“宽表”。这样，在面对海量数据进行查询时，就不需要再进行 join 操作，直接在这个单表中查询。同时，因为 NoSQL 数据库自身的特点，使得它在存储为空的字段时不占用空间，不担心“表稀疏”，不影响查询性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，NoSQL 数据库在设计时的套路就是，尽量在单表中存储更多的字段，只要避免数据查询中的 join 操作，即使出现大量为空的字段也无所谓了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5672082717872969&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icxmZjLs8UED4S2icRhZRDja2rD71opFQ9Of0ukCLcNj1s7I1X38ox83ca8EjHWIQib8hUibgVhT8ibnicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/p&gt;&lt;p&gt;增值税发票票样图&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;正因为 NoSQL 数据库在设计上有以上特点，因此将领域模型转换成 NoSQL 数据库时，设计就完全不一样了。比如，这样一张增值税发票，如上图所示，在数据库设计时就需要分为发票信息表、发票明细表与纳税人表，而在查询时需要进行 4 次 join 才能完成查询。但在 NoSQL 数据库设计时，将其设计成这样一张表：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{ _id: ObjectId(&lt;span class=&quot;code-snippet__number&quot;&gt;7d&lt;/span&gt;f78ad8902c)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  fpdm: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;3700134140&#x27;&lt;/span&gt;, fphm: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;02309723‘, &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  kprq: &#x27;&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2016&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;-25&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;9&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  je: 70451.28, se: 11976.72, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  gfnsr: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     nsrsbh: &#x27;&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;370112582247803&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     nsrmc:&#x27;&lt;/span&gt;联通华盛通信有限公司济南分公司&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;,…&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  xfnsr: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     nsrsbh: &#x27;&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;370112575587500&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     nsrmc:&#x27;&lt;/span&gt;联通华盛通信有限公司济南分公司&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;,…&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  spmx: [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     { qdbz:&#x27;&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;, wp_mc:&#x27;&lt;/span&gt;蓝牙耳机 车语者S1 蓝牙耳机&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;, sl:2, dj:68.37,… },&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     { qdbz:&#x27;&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;, wp_mc:&#x27;&lt;/span&gt;车载充电器 新在线&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;, sl:1, dj:11.11,… },&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     { qdbz:&#x27;&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;, wp_mc:&#x27;&lt;/span&gt;保护壳 非尼膜属 iPhone6 电镀壳&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;, sl:1, dj:24,…  }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在该案例中，对于“一对一”和“多对一”关系，在发票信息表中通过一个类型为“对象”的字段来存储，比如“购方纳税人（gfnsr）”与“销方纳税人（xfnsr）”字段。对于“一对多”和“多对多”关系，通过一个类型为“对象数组”的字段来存储，如“商品明细（spmx）”字段。在这样一个发票信息表中就可以完成对所有发票的查询，无须再进行任何 join 操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同样，采用 NoSQL 数据库怎样实现继承关系的设计呢？由于 NoSQL 数据库自身的特点决定了不用担心“表稀疏”，同时要避免 join 操作，所以比较适合采用第一个方案，即将整个继承关系放到同一张表中进行设计。这时，NoSQL 数据库的每一条记录可以有不一定完全相同的字段，可以设计成这样：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{ &lt;span class=&quot;code-snippet__attribute&quot;&gt;_id&lt;/span&gt;: &lt;span class=&quot;code-snippet__built_in&quot;&gt;ObjectId&lt;/span&gt;(79878ad8902c),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  name: ‘Jack’,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  type: ‘parent’,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  partner: ‘Elizabeth’,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  children: [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    { name: ‘Tom’, gender: ‘male’ },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    { &lt;span class=&quot;code-snippet__attribute&quot;&gt;name&lt;/span&gt;: ‘Mary’, gender: ‘female’}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{ &lt;span class=&quot;code-snippet__attribute&quot;&gt;_id&lt;/span&gt;: &lt;span class=&quot;code-snippet__built_in&quot;&gt;ObjectId&lt;/span&gt;(79878ad8903d),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  name: ‘Bob’,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  type: ‘kid’,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  mother: ‘Anna’,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  father: ‘David’&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上案例是一个用户档案表，有两条记录：Jack 与 Bob。但是，Jack 的类型是“家长”，因此其个性化字段是“伴侣”与“孩子”；而 Bob 的类型是“孩子”，因此他的个性化字段是“父亲”与“母亲”。显然，在 NoSQL 数据库设计时就会变得更加灵活。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;将领域模型落地到系统设计包含 2 部分内容，本文演练了第一部分内容——从 DDD 落实到数据库设计的整个过程：&lt;span&gt;传统的 4 种关系可以直接转换；&lt;/span&gt;&lt;span&gt;继承关系有 3 种设计方案；&lt;/span&gt;&lt;span&gt;转换成 NoSQL 数据库则是完全不同的思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了 DDD 的指导，可以帮助我们理清数据间的关系，以及对数据的操作。不仅如此，在未来面对大数据转型时更加从容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;号主简介：冯涛，&lt;/span&gt;&lt;span&gt;曾任职于阿里巴巴，每日优鲜等互联网公司，任技术总监，15年电商互联网经历&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后，将自己15年的微服务，高并发，JVM调优，线上故障排查等经历整理成电子书送给大家，共130页。绝对干货！&lt;span&gt;没领过的朋友，抓紧啦！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取方式：扫描或识别下方二维码关注公众号二马读书，&lt;span&gt;回复&lt;/span&gt;&lt;span&gt; &lt;strong&gt;“&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;电子书&lt;/strong&gt;&lt;/span&gt;”&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I2EApibvt9icyUP1DKTuiaQ6pLS5A16fY19TjGbnIlicIYTZcRTzpxIfWErvRjaGbicXAOCN9eIt6Hv4vnN8FtiazmBQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取方式：扫描或识别上方二维码关注公众号二马读书，回复&lt;span&gt; &lt;strong&gt;“&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;电子书&lt;/strong&gt;&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来来来加俺微信，一起交流，共同成长: ftcool2008&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，&lt;/span&gt;如果感觉本文对您有帮助，有劳转发分享或点一下“在看”！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a4a7d43c6a863257965762372a937159</guid>
<title>[推荐] 教你从头写游戏服务器框架</title>
<link>https://toutiao.io/k/906zu1i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;前言
大概已经有差不多一年没写技术文章了，原因是今年投入了一些具体游戏项目的开发。这些新的游戏项目，比较接近独立游戏的开发方式。我觉得公司的“祖传”服务器框架技术不太适合，所以从头写了一个游戏服务器端的框架，以便获得更好的开发效率和灵活性。现在项目将近上线，有时间就想总结一下，这样一个游戏服务器框架的设计和实现过程。
这个框架的基本运行环境是 Linux ，采用 C++ 编写。为了能在各种环境上运行和使用，所以采用了 gcc 4.8 这个“古老”的编译器，以 C99 规范开发。
需求
由于“越通用的代码，就是越没用的代码”，所以在设计之初，我就认为应该使用分层的模式来构建整个系统。按照游戏服务器的一般需求划分，最基本的可以分为两层：&lt;/p&gt;

&lt;p&gt;底层基础功能：包括通信、持久化等非常通用的部分，关注的是性能、易用性、扩展性等指标。
高层逻辑功能：包括具体的游戏逻辑，针对不同的游戏会有不同的设计。
&lt;img src=&quot;https://img.toutiao.io/attachment/48dde7a7278c47ac8d82c3ccec117c04/w600&quot; alt=&quot;file&quot;/&gt;
我希望能有一个基本完整的“底层基础功能”的框架，可以被复用于多个不同的游戏。由于目标是开发一个 适合独立游戏开发 的游戏服务器框架。所以最基本的需求分析为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;功能性需求&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;并发：所有的服务器程序，都会碰到这个基本的问题：如何处理并发处理。一般来说，会有多线程、异步两种技术。多线程编程在编码上比较符合人类的思维习惯，但带来了“锁”这个问题。而异步非阻塞的模型，其程序执行的情况是比较简单的，而且也能比较充分的利用硬件性能，但是问题是很多代码需要以“回调”的形式编写，对于复杂的业务逻辑来说，显得非常繁琐，可读性非常差。虽然这两种方案各有利弊，也有人结合这两种技术希望能各取所长，但是我更倾向于基础是使用异步、单线程、非阻塞的调度方式，因为这个方案是最清晰简单的。为了解决“回调”的问题，我们可以在其上再添加其他的抽象层，比如协程或者添加线程池之类的技术予以改善。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通信：支持 请求响应 模式以及 通知模式的通信（广播视为一种多目标的通知）。游戏有很多登录、买卖、打开背包之类的功能，都是明确的有请求和响应的。而大量的联机游戏中，多个客户端的位置、HP等东西都需要经过网络同步，其实就是一种“主动通知”的通信方式。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.持久化：可以存取 对象 。游戏存档的格式非常复杂，但其索引的需求往往都是根据玩家 ID 来读写就可以。在很多游戏主机如PlayStation 上，以前的存档都是可以以类似“文件”的方式存放在记忆卡里的。所以游戏持久化最基本的需求，就是一个key-value存取模型。当然，游戏中还会有更复杂的持久化需求，比如排行榜、拍卖行等，这些需求应该额外对待，不适合包含在一个最基本的通用底层中。&lt;/p&gt;

&lt;p&gt;4.缓存：支持远程、分布式的对象缓存。游戏服务基本上都是“带状态”的服务，因为游戏要求响应延迟非常苛刻，基本上都需要利用服务器进程的内存来存放过程数据。但是游戏的数据，往往是变化越快的，价值越低，比如经验值、金币、HP，而等级、装备等变化比较慢的，价值则越高，这种特征，非常适合用一个缓存模型来处理。&lt;/p&gt;

&lt;p&gt;5.协程：可以用 C++来编写协程代码，避免大量回调函数分割代码。这个是对于异步代码非常有用的特性，能大大提高代码的可读性和开发效率。特别是把很多底层涉及IO的功能，都提供了协程化API，使用起来就会像同步的 API 一样轻松惬意。&lt;/p&gt;

&lt;p&gt;6.脚本：初步设想是支持可以用 Lua来编写业务逻辑。游戏需求变化是出了名快的，用脚本语言编写业务逻辑正好能提供这方面的支持。实际上脚本在游戏行业里的使用非常广泛。所以支持脚本，也是一个游戏服务器框架很重要的能力。&lt;/p&gt;

&lt;p&gt;7.其他功能：包括定时器、服务器端的对象管理等等。这些功能很常用，所以也需要包含在框架中，但已经有很多成熟方案，所以只要选取常见易懂的模型即可。比如对象管理，我会采用类似Unity 的组件模型来实现。
&lt;strong&gt;非功能性需求&lt;/strong&gt;
1.灵活性：支持可替换的通信协议；可替换的持久化设备（如数据库）；可替换的缓存设备（如 memcached/redis）；以静态库和头文件的方式发布，不对使用者代码做过多的要求。游戏的运营环境比较复杂，特别是在不同的项目之间，可能会使用不同的数据库、不同的通信协议。但是游戏本身业务逻辑很多都是基于对象模型去设计的，所以应该有一层能够基于“对象”来抽象所有这些底层功能的模型。这样才能让多个不同的游戏，都基于一套底层进行开发。&lt;/p&gt;

&lt;p&gt;2.部署便利性：支持灵活的配置文件、命令行参数、环境变量的引用；支持单独进程启动，而无须依赖数据库、消息队列中间件等设施。一般游戏都会有至少三套运行环境，包括一个开发环境、一个内测环境、一个外测或运营环境。一个游戏的版本更新，往往需要更新多个环境。所以如何能尽量简化部署就成为一个很重要的问题。我认为一个好的服务器端框架，应该能让这个服务器端程序，在无配置、无依赖的情况下独立启动，以符合在开发、测试、演示环境下快速部署。并且能很简单的通过配置文件、或者命令行参数的不同，在集群化下的外部测试或者运营环境下启动。&lt;/p&gt;

&lt;p&gt;3.性能：很多游戏服务器，都会使用异步非阻塞的方式来编程。因为异步非阻塞可以很好的提高服务器的吞吐量，而且可以很明确的控制多个用户任务并发下的代码执行顺序，从而避免多线程锁之类的复杂问题。所以这个框架我也希望是以异步非阻塞作为基本的并发模型。这样做还有另外一个好处，就是可以手工的控制具体的进程，充分利用多核 CPU 服务器的性能。当然异步代码可读性因为大量的回调函数，会变得很难阅读，幸好我们还可以用“协程”来改善这个问题。&lt;/p&gt;

&lt;p&gt;4.扩展性：支持服务器之间的通信，进程状态管理，类似 SOA 的集群管理。自动容灾和自动扩容，其实关键点是服务进程的状态同步和管理。我希望一个通用的底层，可以把所有的服务器间调用，都通过一个统一的集权管理模型管理起来，这样就可以不再每个项目去关心集群间通信、寻址等问题。
一旦需求明确下来，基本的层级结构也可以设计了：
&lt;img src=&quot;https://img.toutiao.io/attachment/ba2a2ab719754b02851b8581517d84a5/w600&quot; alt=&quot;file&quot;/&gt;
最后，整体的架构模块类似：
&lt;img src=&quot;https://img.toutiao.io/attachment/7238d9aa95704fb88fa8e3854e578463/w600&quot; alt=&quot;file&quot;/&gt;
&lt;strong&gt;通信模块&lt;/strong&gt;
对于通信模块来说，需要有灵活的可替换协议的能力，就必须按一定的层次进行进一步的划分。对于游戏来说，最底层的通信协议，一般会使用 TCP 和 UDP 这两种，在服务器之间，也会使用消息队列中间件一类通信软件。框架必须要有能同事支持这几通信协议的能力。故此设计了一个层次为: Transport&lt;/p&gt;

&lt;p&gt;在协议层面，最基本的需求有“分包”“分发”“对象序列化”等几种需求。如果要支持“请求-响应”模式，还需要在协议中带上“序列号”的数据，以便对应“请求”和“响应”。另外，游戏通常都是一种“会话”式的应用，也就是一系列的请求，会被视为一次“会话”，这就需要协众需要有类似 Session ID 这种数据。为了满足这些需求，设计一个层次为： Protocol&lt;/p&gt;

&lt;p&gt;拥有了以上两个层次，是可以完成最基本的协议层能力了。但是，我们往往希望业务数据的协议包，能自动化的成为编程中的 对象，所以在处理消息体这里，需要一个可选的额外层次，用来把字节数组，转换成对象。所以我设计了一个特别的处理器：ObjectProcessor ，去规范通信模块中对象序列化、反序列化的接口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/87f2ecdd576140a09684d51c0e93979d/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Transport&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此层次是为了统一各种不同的底层传输协议而设置的，最基本应该支持 TCP 和 UDP 这两种协议。对于通信协议的抽象，其实在很多底层库也做的非常好了，比如 Linux 的 socket 库，其读写 API 甚至可以和文件的读写通用。C# 的 Socket 库在 TCP 和 UDP 之间，其 api 也几乎是完全一样的。但是由于作用游戏服务器，很多适合还会接入一些特别的“接入层”，比如一些代理服务器，或者一些消息中间件，这些 API 可是五花八门的。另外，在 html5 游戏（比如微信小游戏）和一些页游领域，还有用 HTTP 服务器作为游戏服务器的传统（如使用 WebSocket 协议），这样就需要一个完全不同的传输层了。
服务器传输层在异步模型下的基本使用序列，就是：&lt;/p&gt;

&lt;p&gt;1.在主循环中，不断尝试读取有什么数据可读
2.如果上一步返回有数据到达了，则读取数据
3.读取数据处理后，需要发送数据，则向网络写入数据&lt;/p&gt;

&lt;p&gt;根据上面三个特点，可以归纳出一个基本的接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Transport {
public:   
   /**
    * 初始化Transport对象，输入Config对象配置最大连接数等参数，可以是一个新建的Config对象。
    */   
   virtual int Init(Config* config) = 0;

   /**
    * 检查是否有数据可以读取，返回可读的事件数。后续代码应该根据此返回值循环调用Read()提取数据。
    * 参数fds用于返回出现事件的所有fd列表，len表示这个列表的最大长度。如果可用事件大于这个数字，并不影响后续可以Read()的次数。
    * fds的内容，如果出现负数，表示有一个新的终端等待接入。
    */
   virtual int Peek(int* fds, int len) = 0;

   /**
    * 读取网络管道中的数据。数据放在输出参数 peer 的缓冲区中。
    * @param peer 参数是产生事件的通信对端对象。
    * @return 返回值为可读数据的长度，如果是 0 表示没有数据可以读，返回 -1 表示连接需要被关闭。
    */
   virtual int Read( Peer* peer) = 0;

   /**
    * 写入数据，output_buf, buf_len为想要写入的数据缓冲区，output_peer为目标队端，
    * 返回值表示成功写入了的数据长度。-1表示写入出错。
    */
   virtual int Write(const char* output_buf, int buf_len, const Peer&amp;amp; output_peer) = 0;

   /**
    * 关闭一个对端的连接
    */
   virtual void ClosePeer(const Peer&amp;amp; peer) = 0;

   /**
    * 关闭Transport对象。
    */
   virtual void Close() = 0;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的定义中，可以看到需要有一个 Peer 类型。这个类型是为了代表通信的客户端（对端）对象。在一般的 Linux 系统中，一般我们用 fd （File Description）来代表。但是因为在框架中，我们还需要为每个客户端建立接收数据的缓存区，以及记录通信地址等功能，所以在 fd 的基础上封装了一个这样的类型。这样也有利于把 UDP 通信以不同客户端的模型，进行封装。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;///@brief 此类型负责存放连接过来的客户端信息和数据缓冲区
class Peer {
public: 
    int buf_size_;      ///&amp;lt; 缓冲区长度
    char* const buffer_;///&amp;lt; 缓冲区起始地址
    int produced_pos_;  ///&amp;lt; 填入了数据的长度
    int consumed_pos_;  ///&amp;lt; 消耗了数据的长度

    int GetFd() const;
    void SetFd(int fd);    /// 获得本地地址
    const struct sockaddr_in&amp;amp; GetLocalAddr() const;
    void SetLocalAddr(const struct sockaddr_in&amp;amp; localAddr);    /// 获得远程地址

    const struct sockaddr_in&amp;amp; GetRemoteAddr() const;
    void SetRemoteAddr(const struct sockaddr_in&amp;amp; remoteAddr);

private:
    int fd_;                            ///&amp;lt; 收发数据用的fd
    struct sockaddr_in remote_addr_;    ///&amp;lt; 对端地址
    struct sockaddr_in local_addr_;     ///&amp;lt; 本端地址
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;游戏使用 UDP 协议的特点：一般来说 UDP 是无连接的，但是对于游戏来说，是肯定需要有明确的客户端的，所以就不能简单用一个 UDP socket 的fd 来代表客户端，这就造成了上层的代码无法简单在 UDP 和 TCP 之间保持一致。因此这里使用 Peer 这个抽象层，正好可以接近这个问题。这也可以用于那些使用某种消息队列中间件的情况，因为可能这些中间件，也是多路复用一个 fd 的，甚至可能就不是通过使用 fd 的 API 来开发的。&lt;/p&gt;

&lt;p&gt;对于上面的 Transport 定义，对于 TCP 的实现者来说，是非常容易能完成的。但是对于 UDP 的实现者来说，则需要考虑如何宠妃利用 Peer ，特别是 Peer.fd_ 这个数据。我在实现的时候，使用了一套虚拟的 fd 机制，通过一个客户端的 IPv4 地址到 int 的对应 Map ，来对上层提供区分客户端的功能。在 Linux 上，这些 IO 都可以使用 epoll 库来实现，在 Peek() 函数中读取 IO 事件，在 Read()/Write() 填上 socket 的调用就可以了。&lt;/p&gt;

&lt;p&gt;另外，为了实现服务器之间的通信，还需要设计和 Tansport 对应的一个类型：Connector 。这个抽象基类，用于以客户端模型对服务器发起请求。其设计和 Transport 大同小异。除了 Linux 环境下的 Connecotr ，我还实现了在 C# 下的代码，以便用 Unity 开发的客户端可以方便的使用。由于 .NET 本身就支持异步模型，所以其实现也不费太多功夫。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @brief 客户端使用的连接器类，代表传输协议，如 TCP 或 UDP
 */
class Connector {

public:    virtual ~Connector() {}    

    /**
     * @brief 初始化建立连接等
     * @param config 需要的配置
     * @return 0 为成功
     */
    virtual int Init(Config* config) = 0;

    /**
     * @brief 关闭
     */
    virtual void Close() = 0;

    /**
     * @brief 读取是否有网络数据到来
     * 读取有无数据到来，返回值为可读事件的数量，通常为1
     * 如果为0表示没有数据可以读取。
     * 如果返回 -1 表示出现网络错误，需要关闭此连接。
     * 如果返回 -2 表示此连接成功连上对端。
     * @return 网络数据的情况
     */
    virtual int Peek() = 0;

    /**
     * @brief 读取网络数 
     * 读取连接里面的数据，返回读取到的字节数，如果返回0表示没有数据，
     * 如果buffer_length是0, 也会返回0，
     * @return 返回-1表示连接需要关闭（各种出错也返回0）
     */
    virtual int Read(char* ouput_buffer, int buffer_length) = 0;

    /**
     * @brief 把input_buffer里的数据写入网络连接，返回写入的字节数。
     * @return 如果返回-1表示写入出错，需要关闭此连接。
     */
   virtual int Write(const char* input_buffer, int buffer_length) = 0;

protected:
    Connector(){}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Protocol&lt;/strong&gt;
对于通信“协议”来说，其实包含了许许多多的含义。在众多的需求中，我所定义的这个协议层，只希望完成四个最基本的能力：&lt;/p&gt;

&lt;p&gt;1.分包：从流式传输层切分出一个个单独的数据单元，或者把多个“碎片”数据拼合成一个完整的数据单元的能力。一般解决这个问题，需要在协议头部添加一个“长度”字段。&lt;/p&gt;

&lt;p&gt;2.请求响应对应：这对于异步非阻塞的通信模式下，是非常重要的功能。因为可能在一瞬间发出了很多个请求，而回应则会不分先后的到达。协议头部如果有一个不重复的“序列号”字段，就可以对应起哪个回应是属于哪个请求的。&lt;/p&gt;

&lt;p&gt;3.会话保持：由于游戏的底层网络，可能会使用 UDP 或者 HTTP 这种非长连接的传输方式，所以要在逻辑上保持一个会话，就不能单纯的依靠传输层。加上我们都希望程序有抗网络抖动、断线重连的能力，所以保持会话成为一个常见的需求。我参考在 Web 服务领域的会话功能，设计了一个 Session 功能，在协议中加上 Session ID 这样的数据，就能比较简单的保持会话。&lt;/p&gt;

&lt;p&gt;4.分发：游戏服务器必定会包含多个不同的业务逻辑，因此需要多种不同数据格式的协议包，为了把对应格式的数据转发。&lt;/p&gt;

&lt;p&gt;除了以上三个功能，实际上希望在协议层处理的能力，还有很多，最典型的就是对象序列化的功能，还有压缩、加密功能等等。我之所以没有把对象序列化的能力放在 Protocol 中，原因是对象序列化中的“对象”本身是一个业务逻辑关联性非常强的概念。在 C++ 中，并没有完整的“对象”模型，也缺乏原生的反射支持，所以无法很简单的把代码层次通过“对象”这个抽象概念划分开来。但是我也设计了一个 ObjectProcessor ，把对象序列化的支持，以更上层的形式结合到框架中。这个 Processor 是可以自定义对象序列化的方法，这样开发者就可以自己选择任何“编码、解码”的能力，而不需要依靠底层的支持。&lt;/p&gt;

&lt;p&gt;至于压缩和加密这一类功能，确实是可以放在 Protocol 层中实现，甚至可以作为一个抽象层次加入 Protocol ，可能只有一个 Protocol 层不足以支持这么丰富的功能，需要好像 Apache Mina 这样，设计一个“调用链”的模型。但是为了简单起见，我觉得在具体需要用到的地方，再额外添加 Protocol 的实现类就好，比如添加一个“带压缩功能的 TLV Protocol 类型”之类的。&lt;/p&gt;

&lt;p&gt;消息本身被抽象成一个叫 Message 的类型，它拥有“服务名字”“会话ID”两个消息头字段，用以完成“分发”和“会话保持”功能。而消息体则被放在一个字节数组中，并记录下字节数组的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum MessageType {
    TypeError, ///&amp;lt; 错误的协议
    TypeRequest, ///&amp;lt; 请求类型，从客户端发往服务器
    TypeResponse, ///&amp;lt; 响应类型，服务器收到请求后返回
    TypeNotice  ///&amp;lt; 通知类型，服务器主动通知客户端
};

///@brief 通信消息体的基类
///基本上是一个 char[] 缓冲区
struct Message {
public:
    static int MAX_MAESSAGE_LENGTH;
    static int MAX_HEADER_LENGTH;

    MessageType type;  ///&amp;lt; 此消息体的类型(MessageType)信息

    virtual ~Message();    virtual Message&amp;amp; operator=(const Message&amp;amp; right);

    /**
     * @brief 把数据拷贝进此包体缓冲区
     */
    void SetData(const char* input_ptr, int input_length);

    ///@brief 获得数据指针
    inline char* GetData() const{
        return data_;
    }

     ///@brief 获得数据长度
    inline int GetDataLen() const{
        return data_len_;
    }

    char* GetHeader() const;
    int GetHeaderLen() const;

protected:
    Message();
    Message(const Message&amp;amp; message);

private:
    char* data_;                  // 包体内容缓冲区
    int data_len_;                // 包体长度

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据之前设计的“请求响应”和“通知”两种通信模式，需要设计出三种消息类型继承于 Message，他们是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Request 请求包&lt;/li&gt;
&lt;li&gt;Response 响应包&lt;/li&gt;
&lt;li&gt;Notice 通知包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Request 和 Response 两个类，都有记录序列号的 seq_id 字段，但 Notice 没有。Protocol 类就是负责把一段 buffer 字节数组，转换成 Message 的子类对象。所以需要针对三种 Message 的子类型都实现对应的 Encode() / Decode() 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Protocol {

public:
    virtual ~Protocol() {
    }

    /**
     * @brief 把请求消息编码成二进制数据
     * 编码，把msg编码到buf里面，返回写入了多长的数据，如果超过了 len，则返回-1表示错误。
     * 如果返回 0 ，表示不需要编码，框架会直接从 msg 的缓冲区读取数据发送。
     * @param buf 目标数据缓冲区
     * @param offset 目标偏移量
     * @param len 目标数据长度
     * @param msg 输入消息对象
     * @return 编码完成所用的字节数，如果 &amp;lt; 0 表示出错
     */
    virtual int Encode(char* buf, int offset, int len, const Request&amp;amp; msg) = 0;

    /**
     * 编码，把msg编码到buf里面，返回写入了多长的数据，如果超过了 len，则返回-1表示错误。
     * 如果返回 0 ，表示不需要编码，框架会直接从 msg 的缓冲区读取数据发送。
     * @param buf 目标数据缓冲区
     * @param offset 目标偏移量
     * @param len 目标数据长度
     * @param msg 输入消息对象
     * @return 编码完成所用的字节数，如果 &amp;lt; 0 表示出错
     */
    virtual int Encode(char* buf, int offset, int len, const Response&amp;amp; msg) = 0;

    /**
     * 编码，把msg编码到buf里面，返回写入了多长的数据，如果超过了 len，则返回-1表示错误。
     * 如果返回 0 ，表示不需要编码，框架会直接从 msg 的缓冲区读取数据发送。
     * @param buf 目标数据缓冲区
     * @param offset 目标偏移量
     * @param len 目标数据长度
     * @param msg 输入消息对象
     * @return 编码完成所用的字节数，如果 &amp;lt; 0 表示出错
     */
    virtual int Encode(char* buf, int offset, int len, const Notice&amp;amp; msg) = 0;

    /**
     * 开始编码，会返回即将解码出来的消息类型，以便使用者构造合适的对象。
     * 实际操作是在进行“分包”操作。
     * @param buf 输入缓冲区
     * @param offset 输入偏移量
     * @param len 缓冲区长度
     * @param msg_type 输出参数，表示下一个消息的类型，只在返回值 &amp;gt; 0 的情况下有效，否则都是 TypeError
     * @return 如果返回0表示分包未完成，需要继续分包。如果返回-1表示协议包头解析出错。其他返回值表示这个消息包占用的长度。
     */
    virtual int DecodeBegin(const char* buf, int offset, int len,
                            MessageType* msg_type) = 0;

    /**
     * 解码，把之前DecodeBegin()的buf数据解码成具体消息对象。
     * @param request 输出参数，解码对象会写入此指针
     * @return 返回0表示成功，-1表示失败。
     */
    virtual int Decode(Request* request) = 0;

    /**
     * 解码，把之前DecodeBegin()的buf数据解码成具体消息对象。
     * @param request 输出参数，解码对象会写入此指针
     * @return 返回0表示成功，-1表示失败。
     */
    virtual int Decode(Response* response) = 0;

    /**
     * 解码，把之前DecodeBegin()的buf数据解码成具体消息对象。
     * @param request 输出参数，解码对象会写入此指针
     * @return 返回0表示成功，-1表示失败。
     */
    virtual int Decode(Notice* notice) = 0;protected:

    Protocol() {
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一点需要注意，由于 C++ 没有内存垃圾搜集和反射的能力，在解释数据的时候，并不能一步就把一个 char[] 转换成某个子类对象，而必须分成两步处理。&lt;/p&gt;

&lt;p&gt;1.先通过 DecodeBegin() 来返回，将要解码的数据是属于哪个子类型的。同时完成分包的工作，通过返回值来告知调用者，是否已经完整的收到一个包。&lt;/p&gt;

&lt;p&gt;2.调用对应类型为参数的 Decode() 来具体把数据写入对应的输出变量。&lt;/p&gt;

&lt;p&gt;对于 Protocol 的具体实现子类，我首先实现了一个 LineProtocol ，是一个非常不严谨的，基于文本ASCII编码的，用空格分隔字段，用回车分包的协议。用来测试这个框架是否可行。因为这样可以直接通过 telnet 工具，来测试协议的编解码。然后我按照 TLV （Type Length Value）的方法设计了一个二进制的协议。大概的定义如下：&lt;/p&gt;

&lt;p&gt;协议分包： [消息类型:int:2] [消息长度:int:4] [消息内容:bytes:消息长度]
消息类型取值:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0x00 Error&lt;/li&gt;
&lt;li&gt;0x01 Request&lt;/li&gt;
&lt;li&gt;0x02 Response&lt;/li&gt;
&lt;li&gt;0x03 Notice&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/5c18d457cfe4468ca0b9d5aebb6c2052/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个名为 TlvProtocol 的类型完成对这个协议的实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Processor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;处理器层是我设计用来对接具体业务逻辑的抽象层，它主要通过输入参数 Request 和 Peer 来获得客户端的输入数据，然后通过 Server 类的 Reply()/Inform() 来返回 Response 和 Notice 消息。实际上 Transport 和 Protocol 的子类们，都属于 net 模块，而各种 Processor 和 Server/Client 这些功能类型，属于另外一个 processor 模块。这样设计的原因，是希望所有 processor 模块的代码单向的依赖 net 模块的代码，但反过来不成立。&lt;/p&gt;

&lt;p&gt;Processor 基类非常简单，就是一个处理函数回调函数入口 Process()：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;///@brief 处理器基类，提供业务逻辑回调接口

class Processor {

public:
    Processor();
    virtual ~Processor();

    /**
     * 初始化一个处理器，参数server为业务逻辑提供了基本的能力接口。
     */
    virtual int Init(Server* server, Config* config = NULL);

    /**
     * 处理请求-响应类型包实现此方法，返回值是0表示成功，否则会被记录在错误日志中。
     * 参数peer表示发来请求的对端情况。其中 Server 对象的指针，可以用来调用 Reply(),
     * Inform() 等方法。如果是监听多个服务器，server 参数则会是不同的对象。
     */
    virtual int Process(const Request&amp;amp; request, const Peer&amp;amp; peer,
                        Server* server);

    /**
     * 关闭清理处理器所占用的资源
     */
    virtual int Close();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设计完 Transport/Protocol/Processor 三个通信处理层次后，就需要一个组合这三个层次的代码，那就是 Server 类。这个类在 Init() 的时候，需要上面三个类型的子类作为参数，以组合成不同功能的服务器，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TlvProtocol tlv_protocol;   //  Type Length Value 格式分包协议，需要和客户端一致
TcpTransport tcp_transport; // 使用 TCP 的通信协议，默认监听 0.0.0.0:6666
EchoProcessor echo_processor;   // 业务逻辑处理器
Server server;  // DenOS 的网络服务器主对象
server.Init(&amp;amp;tcp_transport, &amp;amp;tlv_protocol, &amp;amp;echo_processor);    // 组装一个游戏服务器对象：TLV 编码、TCP 通信和回音服务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server 类型还需要一个 Update() 函数，让用户进程的“主循环”不停的调用，用来驱动整个程序的运行。这个 Update() 函数的内容非常明确：&lt;/p&gt;

&lt;p&gt;1.检查网络是否有数据需要处理（通过 Transport 对象）&lt;/p&gt;

&lt;p&gt;2.有数据的话就进行解码处理（通过 Protocol 对象）&lt;/p&gt;

&lt;p&gt;3.解码成功后进行业务逻辑的分发调用（通过 Processor 对象）&lt;/p&gt;

&lt;p&gt;另外，Server 还需要处理一些额外的功能，比如维护一个会话缓存池（Session），提供发送 Response 和 Notice 消息的接口。当这些工作都完成后，整套系统已经可以用来作为一个比较“通用”的网络消息服务器框架存在了。剩下的就是添加各种 Transport/Protocol/Processor 子类的工作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Server {

public:
    Server();
    virtual ~Server();

    /**
     * 初始化服务器，需要选择组装你的通信协议链
     */
    int Init(Transport* transport, Protocol* protocol, Processor* processor, Config* config = NULL);

    /**
     * 阻塞方法，进入主循环。
     */
    void Start();

    /**
     * 需要循环调用驱动的方法。如果返回值是0表示空闲。其他返回值表示处理过的任务数。
     */
    virtual int Update();
    void ClosePeer(Peer* peer, bool is_clear = false); //关闭当个连接，is_clear 表示是否最终整体清理

    /**
     * 关闭服务器
     */
    void Close();

    /**
     * 对某个客户端发送通知消息，
     * 参数peer代表要通知的对端。
     */
    int Inform(const Notice&amp;amp; notice, const Peer&amp;amp; peer);

    /**
     * 对某个  Session ID 对应的客户端发送通知消息，返回 0 表示可以发送，其他值为发送失败。
     * 此接口能支持断线重连，只要客户端已经成功连接，并使用旧的 Session ID，同样有效。
     */
    int Inform(const Notice&amp;amp; notice, const std::string&amp;amp; session_id);

    /**
     * 对某个客户端发来的Request发回回应消息。
     * 参数response的成员seqid必须正确填写，才能正确回应。
     * 返回0成功，其它值（-1）表示失败。
     */
    int Reply(Response* response, const Peer&amp;amp; peer);

    /**
     * 对某个 Session ID 对应的客户端发送回应消息。
     * 参数 response 的 seqid 成员系统会自动填写会话中记录的数值。
     * 此接口能支持断线重连，只要客户端已经成功连接，并使用旧的 Session ID，同样有效。
     * 返回0成功，其它值（-1）表示失败。
     */
    int Reply(Response* response, const std::string&amp;amp; session_id);

    /**
     * 会话功能
     */
    Session* GetSession(const std::string&amp;amp; session_id = &quot;&quot;, bool use_this_id = false);
    Session* GetSessionByNumId(int session_id = 0);
    bool IsExist(const std::string&amp;amp; session_id);

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了 Server 类型，肯定也需要有 Client 类型。而 Client 类型的设计和 Server 类似，但就不是使用 Transport 接口作为传输层，而是 Connector 接口。不过 Protocol 的抽象层是完全重用的。Client 并不需要 Processor 这种形式的回调，而是直接传入接受数据消息就发起回调的接口对象 ClientCallback。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ClientCallback {

public:

    ClientCallback() {
    }
    virtual ~ClientCallback() {
         // Do nothing
    }

    /**
     *  当连接建立成功时回调此方法。
     * @return 返回 -1 表示不接受这个连接，需要关闭掉此连接。
     */
    virtual int OnConnected() {
        return 0;
    }

    /**
     * 当网络连接被关闭的时候，调用此方法
     */
    virtual void OnDisconnected() {        // Do nothing
    }

    /**
     * 收到响应，或者请求超时，此方法会被调用。
     * @param response 从服务器发来的回应
     * @return 如果返回非0值，服务器会打印一行错误日志。
     */
    virtual int Callback(const Response&amp;amp; response) {
        return 0;
    }

    /**
     * 当请求发生错误，比如超时的时候，返回这个错误
     * @param err_code 错误码
     */
    virtual void OnError(int err_code){
        WARN_LOG(&quot;The request is timeout, err_code: %d&quot;, err_code);
    }

    /**
     * 收到通知消息时，此方法会被调用
     */
    virtual int Callback(const Notice&amp;amp; notice) {
        return 0;
    }

    /**
     * 返回此对象是否应该被删除。此方法会被在 Callback() 调用前调用。
     * @return 如果返回 true，则会调用 delete 此对象的指针。
     */
    virtual bool ShouldBeRemoved() {
        return false;
    }
};

class Client : public Updateable {

public:
    Client();    virtual ~Client();

     /**
     * 连接服务器
     * @param connector 传输协议，如 TCP， UDP ...
     * @param protocol 分包协议，如 TLV, Line, TDR ...
     * @param notice_callback 收到通知后触发的回调对象，如果传输协议有“连接概念”（如TCP/TCONND），建立、关闭连接时也会调用。
     * @param config 配置文件对象，将读取以下配置项目：MAX_TRANSACTIONS_OF_CLIENT 客户端最大并发连接数; BUFFER_LENGTH_OF_CLIENT客户端收包缓存；CLIENT_RESPONSE_TIMEOUT 客户端响应等待超时时间。
     * @return 返回 0 表示成功，其他表示失败
     */
    int Init(Connector* connector, Protocol* protocol,
             ClientCallback* notice_callback = NULL, Config* config = NULL);

    /**
     * callback 参数可以为 NULL，表示不需要回应，只是单纯的发包即可。
     */
    virtual int SendRequest(Request* request, ClientCallback* callback = NULL);

    /**
     * 返回值表示有多少数据需要处理，返回-1为出错，需要关闭连接。返回0表示没有数据需要处理。
     */
    virtual int Update();
    virtual void OnExit();
    void Close();
    Connector* connector() ;
    ClientCallback* notice_callback() ;
    Protocol* protocol() ;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，客户端和服务器端基本设计完成，可以直接通过编写测试代码，来检查是否运行正常。
图片来源：&lt;a href=&quot;http://www.diuxie.com/&quot;&gt;http://www.diuxie.com/&lt;/a&gt; 游戏&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f780b85a99f75aba68f702db1262c0f</guid>
<title>[推荐] 有哪些可以提高代码质量的书籍推荐？</title>
<link>https://toutiao.io/k/pmlwnuy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;这篇文章的内容其实很早就写了，并且，我也已经同步在了我的 Github 的一个仓库中（仓库内容还在继续完善中），地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/CodingDocs/awesome-cs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/CodingDocs/a&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;wesome-cs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 。对应的 Gitee地址：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitee.com/SnailClimb/awesome-cs&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;gitee.com/SnailClimb/aw&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;esome-cs&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; （Github无法访问或者访问速度比较慢的小伙伴可以看码云上的对应内容）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e82f1540f327273acb5ba349dbf26b44_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;642&quot; data-rawheight=&quot;942&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e82f1540f327273acb5ba349dbf26b44_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;642&quot; data-rawheight=&quot;942&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e82f1540f327273acb5ba349dbf26b44_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e82f1540f327273acb5ba349dbf26b44_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;考虑到还未发过类似的文章，所以，今天晚上就来一篇！下面推荐都是我看过并且我觉得值得推荐的书籍。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4921c369a9cf9d9fedaf01dd34f19b8f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4921c369a9cf9d9fedaf01dd34f19b8f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4921c369a9cf9d9fedaf01dd34f19b8f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4921c369a9cf9d9fedaf01dd34f19b8f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;不过，这些书籍都比较偏理论，只能帮助你建立一个写优秀代码的意识标准。如果你想要编写更高质量的代码、更高质量的软件，还是应该多去看优秀的源码，多去学习优秀的代码实践（比如设计模式、设计原则）&lt;/p&gt;&lt;h2&gt;&lt;b&gt;代码整洁之道&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/30468597/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《重构》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7168dba3218563085d6d1cadc3f77929_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;339&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;339&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7168dba3218563085d6d1cadc3f77929_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;必看书籍！无需多言。编程书籍领域的瑰宝。&lt;/p&gt;&lt;p&gt;世界顶级、国宝级别的 Martin Fowler 的书籍，可以说是软件开发领域最经典的几本书之一。目前已经出了第二版。&lt;/p&gt;&lt;p&gt;这是一本值得你看很多遍的书籍。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/4199741/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Clean Code》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-057f648da49f829e2af34de30f0e94b6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;339&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;339&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-057f648da49f829e2af34de30f0e94b6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;《Clean Code》是 Bob 大叔的一本经典著作，强烈建议小伙伴们一定要看看。&lt;/p&gt;&lt;p&gt;Bob 大叔将自己对整洁代码的理解浓缩在了这本书中，真可谓是对后生的一大馈赠。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/1477390/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《代码大全》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-80b420b872320c5d1b35dbf1a68e7743_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;346&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;346&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-80b420b872320c5d1b35dbf1a68e7743_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其实，《代码大全（第 2 版）》这本书我本身是不太想推荐给大家了。但是，看在它的豆瓣评分这么高的份上，还是拿出来说说吧！&lt;/p&gt;&lt;p&gt;这也是一本非常经典的书籍，第二版对第一版进行了重写。&lt;/p&gt;&lt;p&gt;我简单地浏览过全书的内容，感觉内容总体比较虚，对于大部分程序员的作用其实不大。如果你想要切实地提高自己的代码质量，《Clean Code》和 《编写可读代码的艺术》我觉得都要比《代码大全》这本书更好。&lt;/p&gt;&lt;p&gt;不过，最重要的还是要多看优秀的源码，多学习优秀的代码实践。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/10797189/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《编写可读代码的艺术》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1c8ebbfb12f4db53ebe318794cc3c5d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;351&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;351&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b1c8ebbfb12f4db53ebe318794cc3c5d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;《编写可读代码的艺术》这本书要表达的意思和《Clean Code》很像，你看它俩的目录就可以看出来了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7f0ae76b8e576c737f759e04e83360e1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;972&quot; data-rawheight=&quot;1584&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-7f0ae76b8e576c737f759e04e83360e1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;972&quot; data-rawheight=&quot;1584&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-7f0ae76b8e576c737f759e04e83360e1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7f0ae76b8e576c737f759e04e83360e1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在我看来，如果你看过 《Clean Code》 的话，就不需要再看这本书了。当然，如果你有时间和精力，也可以快速过一遍。&lt;/p&gt;&lt;p&gt;另外，我这里还要推荐一个叫做 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/biezhi/write-readable-code&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;write-readable-code&lt;/a&gt;&lt;/b&gt; 的仓库。这个仓库的作者免费分享了一系列基于《编写可读代码的艺术》这本书的视频。这一系列视频会基于 Java 语言来教你如何优化咱们的代码。&lt;/p&gt;&lt;p&gt;在实践中学习的效果肯定会更好！推荐小伙伴们都抓紧学起来啊！&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a141417fdf31f4ac54705bc9ac45fd4c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1894&quot; data-rawheight=&quot;1700&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-a141417fdf31f4ac54705bc9ac45fd4c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1894&quot; data-rawheight=&quot;1700&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-a141417fdf31f4ac54705bc9ac45fd4c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a141417fdf31f4ac54705bc9ac45fd4c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/3360807/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Effective java 》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-663df273be90e3a87d5bf2cba4cc3227_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;350&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;350&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-663df273be90e3a87d5bf2cba4cc3227_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Java 程序员必看！&lt;/p&gt;&lt;p&gt;又是一本 Java 领域国宝级别的书，非常经典。这本书主要介绍了在 Java 编程中很多极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。这篇文章能够非常实际地帮助你写出更加清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;程序员职业素养&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/26919457/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《 The Clean Coder》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-eca03ac2c335c0245e78347de4c3f211_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;340&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;340&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-eca03ac2c335c0245e78347de4c3f211_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;《 The Clean Coder》是 Bob 大叔的又一经典著作。&lt;/p&gt;&lt;p&gt;《Clean Code》和《 The Clean Coder》这两本书在国内都翻译为 《代码整洁之道》，我觉得这个翻译还是不够优雅的。&lt;/p&gt;&lt;p&gt;另外，两者的内容差异也很大。《Clean Code》这本书从代码层面来讲解如何提高自己的代码质量。而《The Clean Coder》这本书则是从如何成为一名更优秀的开发者的角度来写的，比如这书会教你如何在自己的领域更专业、如何说不、如何做时间管理、如何处理压力等等。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;架构整洁之道&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/30333919/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《架构整洁之道》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cd9a0a33a50807e0b44894e0eb63a02b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;365&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;365&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-cd9a0a33a50807e0b44894e0eb63a02b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;你没看错，《架构整洁之道》这本书又是 Bob 大叔的经典之作。&lt;/p&gt;&lt;p&gt;这本书我强烈安利！认真读完之后，我保证你对编程本质、编程语言的本质、软件设计、架构设计可以有进一步的认识。&lt;/p&gt;&lt;p&gt;国内的很多书籍和专栏都借鉴了《架构整洁之道》 这本书。毫不夸张地说，《架构整洁之道》就是架构领域最经典的书籍之一。&lt;/p&gt;&lt;p&gt;正如作者说的那样：&lt;/p&gt;&lt;blockquote&gt; 如果深入研究计算机编程的本质，我们就会发现这 50 年来，计算机编程基本没有什么大的变化。编程语言稍微进步了一点，工具的质量大大提升了，但是计算机程序的基本构造没有什么变化。&lt;br/&gt; 虽然我们有了新的编程语言、新的编程框架、新的编程范式，但是软件架构的规则仍然和 1946 年阿兰·图灵写下第一行机器代码的时候一样。&lt;br/&gt; 这本书就是为了把这些永恒不变的软件架构规则展现出来。&lt;br/&gt; &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;项目管理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/1102259/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《人月神话》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-874e947218716b45e7e8a63e68b4dd3d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;383&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;383&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-874e947218716b45e7e8a63e68b4dd3d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这本书主要描述了软件开发的基本定律：&lt;b&gt;一个需要 10 天才能干完的活，不可能让 10 个人在 1 天干完！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;看书名的第一眼，感觉不像是技术类的书籍。但是，就是这样一个看似和编程不沾边的书名，却成了编程领域长久相传的经典。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这本书对于现代软件尤其是复杂软件的开发的规范化有深刻的意义。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/5344973/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《领域驱动设计:软件核心复杂性应对之道》&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3182be04f8984ad9da3f1e2e0eb7ee03_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;339&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;339&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3182be04f8984ad9da3f1e2e0eb7ee03_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这本领域驱动设计方面的经典之作一直被各种推荐，但是我还来及读。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;软件质量其他书籍推荐&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/24536403/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《代码的未来》&lt;/a&gt; ：这本书的作者是 Ruby 之父松本行弘，算是一本年代比较久远的书籍（13 年出版），不过，还是非常值得一读。这本书的内容主要介绍是编程/编程语言的本质。我个人还是比较喜欢松本行弘的文字风格，并且，你看他的文章也确实能够有所收获。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/1488876/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《深入浅出设计模式》&lt;/a&gt; ： 比较有趣的风格，适合设计模式入门。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/30443578/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《软件架构设计:大型网站技术架构与业务架构融合之道》&lt;/a&gt; ： 内容非常全面。适合面试前突击一些比较重要的理论知识，也适合拿来扩充/完善自己的技术广度。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/33425123/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《微服务架构设计模式》&lt;/a&gt; ：这本书是世界十大软件架构师之一、微服务架构先驱 Chris Richardson 亲笔撰写，豆瓣评分 9.6。示例代码使用 Java 语言和 Spring 框架。帮助你设计、实现、测试和部署基于微服务的应用程序。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后再推荐两个相关的文档：&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>