<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>eea1c954513458634287fe0d16e0aaf9</guid>
<title>Java 中的映射 Map（入门篇）</title>
<link>https://toutiao.io/k/2j4xsag</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;大家好啊，我是汤圆，今天给大家带来的是《Java中的映射Map - 入门篇》，希望对大家有帮助，谢谢&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;前面介绍了集合List，这里开始简单介绍下映射&lt;code&gt;Map&lt;/code&gt;，相关类如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/kTAnEyP9cv1DXai.png&quot; alt=&quot;集合&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;Map是一种存储键值对的数据集合，键以散列或者树形结构进行存储；&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么会设计Map接口呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假设我们有一个员工类，里面有Id属性和姓名等其他信息，现在我们把所有员工都存到List里，然后要找出Id为001的员工，你会发现，你需要从List中遍历每个对象，然后取出Id进行比较；&lt;/p&gt;

&lt;p&gt;你会发现这种查找法效率很低，有点杀鸡用牛刀的感觉；&lt;/p&gt;

&lt;p&gt;这时如果有一个集合类，可以以键值对映射的方式的存储员工信息（Id作为键，员工信息作为值），那么就可以只遍历键列表，然后进行比较；&lt;/p&gt;

&lt;p&gt;你会发现这种查找法效率提高了很多，因为物尽其用了（比较的是Id，也只是取了Id，没有浪费）；&lt;/p&gt;

&lt;p&gt;这就是Map接口的作用，可以根据某个键去查找对应的信息，有点类似于数据库的设计。&lt;/p&gt;

&lt;h3&gt;Map的种类&lt;/h3&gt;

&lt;p&gt;Map主要有三种类型：HashMap(常用)、TreeMap（树形结构）、LinkedHashMap（前两者的结合）&lt;/p&gt;

&lt;p&gt;我们先来看一下Map接口主要的几个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V put(K key, V value)&lt;/code&gt;：往Map中添加键值对，其中key为键，value为值；如果key存在，则覆盖原有的值；如果不存在，则新建键值对。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V get(Object key)&lt;/code&gt;：从Map中查找键key对应的值，如果没有，则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default V getOrDefault(Object key, V defaultValue)&lt;/code&gt;：从Map中查找键key对应的值，如果没有，则返回第二个参数（设置的默认值）；这里的修饰符default是用在接口方法中，表示这个方法在接口中已经实现了，子类可以不实现（Java8开始支持）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&amp;lt;K&amp;gt; keySet()&lt;/code&gt;：返回Map中Key的集合；之所以返回Set，是因为Map中的key不能有重复，所以用Set最适合了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Collection&amp;lt;V&amp;gt; values()&lt;/code&gt;：返回Map中Values的集合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们简单看下三者的区别&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th/&gt;
&lt;th&gt;HashMap&lt;/th&gt;
&lt;th&gt;TreeMap&lt;/th&gt;
&lt;th&gt;LinkedHashMap&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;访问速度&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;适中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;元素是否有序&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;有序，默认按key排序&lt;/td&gt;
&lt;td&gt;有序，默认按插入的顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;普通的插入，查询（用的最多）&lt;/td&gt;
&lt;td&gt;需要对key进行排序的场景（比如员工按年龄排序等）&lt;/td&gt;
&lt;td&gt;需要保证查询和插入顺序一致的场景（类似队列）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;接下来我们以HashMap为例，来介绍Map接口&lt;/p&gt;

&lt;h3&gt;HashMap&lt;/h3&gt;

&lt;p&gt;HashMap内部是数组+链表的结构；&lt;/p&gt;

&lt;p&gt;因为在添加键值对的时候，Key做了hash处理，然后按照hash值进行排列；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果hash值没有重复，就按照数组的方式依次排列；&lt;/li&gt;
&lt;li&gt;如果hash值有重复的，就添加到已有的键值对后面（Java8以后是尾部插入），形成链表结构；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整体结构 如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/5qnM3zwZDgakGV4.png&quot; alt=&quot;HashMap结构&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里只是简单介绍，以后再深入了解&lt;/p&gt;

&lt;p&gt;下面用代码示范一下&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 键值对集合，键不可以重复
Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
// 添加：首先会检查对应的key是否存在，如果不存在，则新建键值对，然后填充；如果存在，则覆盖已有的值
map.put(&quot;a&quot;, 1); // 这里的1会自动装箱为Intege类型
// 查询
int value1 = map.get(&quot;a&quot;);
int value2 = map.get(&quot;b&quot;); 
System.out.println(map);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里有个很有意思的现象，你觉得value2会是多少呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答案是多少都不是，因为程序运行到这一行就出错了，报空指针异常&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/BoQ6x2Kzf3P8vMH.png&quot; alt=&quot;HashMap空指针异常&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不应该返回null吗？怎么会出错？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里涉及到拆箱和装箱的问题，上面我们在添加put的时候，int 1自动装箱为Integer；&lt;/p&gt;

&lt;p&gt;然后在获取get的时候，对应的也是要进行拆箱的，将Integer转为int；&lt;/p&gt;

&lt;p&gt;但是由于获取的value = null，所以就相当于对null进行拆箱，结果就报错了。&lt;/p&gt;

&lt;p&gt;解决办法就是严格按照Map的类型信息进行添加和获取；&lt;/p&gt;

&lt;p&gt;将上面的代码加以修改，如下所示&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 键值对集合，键不可以重复
Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
// 添加：首先会检查对应的key是否存在，如果不存在，则新建键值对，然后填充；如果存在，则覆盖已有的值
map.put(&quot;a&quot;, 1); // 这里的1会自动装箱为Intege类型
// 查询
Integer value1 = map.get(&quot;a&quot;);
Integer value2 = map.get(&quot;b&quot;);
System.out.println(map);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时value2就等于null了。&lt;/p&gt;

&lt;p&gt;关于自动装箱和拆箱，网上资源很多，这里就不再细说了&lt;/p&gt;

&lt;h3&gt;TreeMap&lt;/h3&gt;

&lt;p&gt;TreeMap在插入的时候，可以按照键的顺序进行排序&lt;/p&gt;

&lt;p&gt;它适合用在排序比较多的场景，性能会比HashMap差一些&lt;/p&gt;

&lt;h3&gt;LinkedHashMap&lt;/h3&gt;

&lt;p&gt;LinkedHashMap拥有HashMap的大部分优点，且保证了插入的顺序，使得在查询的时候，可以按照插入的顺序依次读取&lt;/p&gt;

&lt;h3&gt;三者的排序比较&lt;/h3&gt;

&lt;p&gt;下面用代码演示一下，依次插入100个数，看看他们分别是怎么排序的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashMapDemo.java&lt;/code&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class HashMapDemo {
    public static void main(String[] args) {
        // 键值对集合，键不可以重复
        Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        // 倒序插入100个数
        int i =100;
        while (i--&amp;gt;0){
            map.put(&quot;&quot;+i, i);
        }
        // 查询
        for (String str :
                map.keySet()) {
            // 这里会乱序输出
            System.out.println(str);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下所示：很乱&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/D4ow987uz1OPtHa.png&quot; alt=&quot;HashMap输出乱序&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TreeMapDemo.java&lt;/code&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class MapDemo {
    public static void main(String[] args) {

        // TreeMap
        Map&amp;lt;String, Integer&amp;gt; map1 = new TreeMap&amp;lt;&amp;gt;();
        // 连续倒序插入100个数
        int k =100;
        while (k--&amp;gt;0){
            map1.put(&quot;&quot;+k, k);
        }
        // 查询
        for (String str :
                map1.keySet()) {
            // 这里会正序输出
            System.out.println(str);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/Bhs86gVfPiN5d9W.png&quot; alt=&quot;TreeMap输出正序&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;细心的你们，应该会发现上面的输出有点别致&lt;/p&gt;

&lt;p&gt;那是因为这里的键key(0~99)其实不是整型，而是字符串类型，所以排序按照字符串的升序来排，才会出现如图所示的结果&lt;/p&gt;

&lt;p&gt;（建议实际场景不要这样搞，容易出事，字符串尽量不要用纯数字，而是要跟字母做拼接；）&lt;/p&gt;

&lt;p&gt;正确的做法是key=“a”+i，这种方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;LinkedHashMapDemo.java&lt;/code&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class MapDemo {
    public static void main(String[] args) {
        // LinkedHashMap
        Map&amp;lt;String, Integer&amp;gt; map2 = new LinkedHashMap&amp;lt;&amp;gt;();
        // 倒序插入100个数
        int j =100;
        while (j--&amp;gt;0){
            map2.put(&quot;a&quot;+j, j);
        }
        for (String str :
                map2.keySet()) {
            // 这里按照插入的顺序依次输出
            System.out.println(map2.get(str));
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/N2vaT4BheJn8OYp.png&quot; alt=&quot;LinkedHashMap按插入顺序输出&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;Map一般用到的有HashMap，TreeMap，LinkedHashMap，当然还有并发相关的，这里入门级别的先不涉及（比如ConcurrentHashMap）&lt;/p&gt;



&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8ddbc2b971837fa5725033ff1d1ae3fb</guid>
<title>从需求出发设计一条开源持续部署流水线</title>
<link>https://toutiao.io/k/we8gr61</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfUr0eQ0wjgLJuZ0pJ3X4rOmh1L6GoEau989Pb9aNch7mwm3ibzCAicVVA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;216.74740484429063&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.36203703703703705&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfS5ER1nE8P23KX8ib42JxT6sxOlicH5CcHiaEIPEsN896wia7jJu4KEE1Mg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次实践从需求出发到部署，采用大部分开源工具链Jira+GitLab+Jenkins+Spinnaker. Jira作为需求和任务管理工具，集成GitLab实现需求与代码关联，自动创建特性分支和版本分支以及合并请求的创建。GitLab代码提交触发JenkinsCI流水线，这里CI指的是Jenkins来做构建、测试、扫描、生成镜像上传镜像操作。CD由Spinnaker对各个环境部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细的内容在下面PPT：本此内容已经录制成视频教程，已经购买Jenkins实践课程的同学请耐心等待，预计两天内免费更新到课程中。欢迎更多的同学一起加入DevOps课程学习！目前还有优惠哦~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该项目涉及到Jenkins共享库中的Gitlab接口，Jenkinsfile，SPinnaker Pipeline模板。仓库地址：https://github.com/zeyangli/devops-practice  欢迎点赞关注！&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfra5HNbRWt7gmG7KN7RmmnbZZ66dr2ibPVNicc6MbZYbNwYD9rYH2hTsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf3V8nVkJvzvKmwp4g1sSgEiagu8O6tibuzEoyXnbvN5Bn1fy4CdpNlwKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf84zhWgcQO6WEJ0XSCBnciavUvtHo0SGSzCGb2R93otHyIgDRpkmHicyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfvtxmJn23LoXA6yz4vVN0nOvcOLyCiaSvvZRR9iacP8wKIwOfjibiaUttYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf4nxvOASLguQR3CeRebvRRG2tU2FongxbbGUiceO6MChL63PgQt02QWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf2A7NreiacYn4sdLFAZGdcR23I7Aiam2PP2qo3zd13mib1PT8Eq2r9LK7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfxguXCsgFuVmCcklTZyXzxXugWvY2vJbIIo0e4E0lNibCwklEdyutTmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYficWM0bIOaDT1LSlDYuNRQkhEoNfJ9YqOVtfjXribVP8bZgDulNxaCWcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfZpicKNQZSL3NnI2C99tB4Tzg5nHezoSXMvnCvmwQcsy1Mh9YkkFKPlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfJDs1Rvd1kttdvEo35SibfnWHiaiazdf6pFpct8vcO8VVaTibzJekA41Ing/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfZscMRlweexoAWdtTH0Kymo1Oheiag1XZbJCwuYWoSBfMUSGH3Gr8Y8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfu8ZyDhsek9OGznM1TeqIAicCGLL9WNMu98icSuMkfsicVrSEITyUx2sdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfILjI9KeBusicAPawHIdX7hWRqUKibZIXxYicIq7cuiaMcWp5mgVxyaaFkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfJE5eJS4lU1Mvn4r5pic1SmkHJXj71jt3fDrmO850JK6XDbpM1QbwPgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfCvyUO5ib7HktXuZaDZ6J8Ub7vHnFOVGefrpHHf6Qs7zxXU4OHJicyAcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfKWs1PvYic2Qwttjd63SxoiaYNLhHQfibtfEKsvBRNMZiaEPmnEAbCibXliaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfRqSA7pzibU8zibVoxbjEsIeCRKj8OQZWxPAD2IsDTlz5lfhjyzJaPjWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfCacn2HytkP15AqSMuutFYdzr7ncyzPJzw3rOG7ibH0NXFhDwGAG9Vxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf9OQibBJQggqx3iciccsQPS6wbHXlxKMVTo9MGWHMrrRjTuKUhWSOicPrLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfXGRwUl6ZwutGRVveZbxlQiceKJm1tevMvpj6KrBqCibHRlJw8iaDPxSZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYficasnnXktm0z0FibKul8Uz8tB9iauAzjYnFWQgu2m8z0BrJ4kb5w9Pj5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;关于我们&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;泽阳，DevOps领域实践者。专注于企业级DevOps运维开发技术实践分享，主要以新Linux运维技术、DevOps技术课程为主。丰富的一线实战经验，课程追求实用性获得多数学员认可。课程内容均来源于企业应用，在这里既学习技术又能获取热门技能，欢迎您的到来！（微信ID: devopsvip）&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;2765&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxa2c453d902cdd452&quot; data-miniprogram-path=&quot;pages/course/course?cid=2202770&quot; data-miniprogram-nickname=&quot;腾讯课堂&quot; href=&quot;&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPn3ntHUn6mrurdKQYYNbeeqzxBg8DVwNRyibicSx6y3MC2HHHuqjzrmViacQ2V8VUqQjTFdqRDnN68Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;321&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/U1oibTqyKuTMCjxUVf8T4JUicFXc750HKUIMBGIXwaPOJv7HTejgyspc4RXDSfYL7Lequhz0gu4jAfN25PenKYOw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;DevOps流水线实践课程&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;👇戳阅读原文，进入课堂&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>47bb7924872c82d90501dd93c93e1e45</guid>
<title>浮点数，你真的懂了吗？</title>
<link>https://toutiao.io/k/343f4ae</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;大家好，我是石头哥，最近有读者问我关于浮点的问题，大概问题就是 &lt;strong&gt;0.1 + 0.2 == 0.3 ？ 0.8-0.6 == 0.6-0.4 ？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.4111111111111112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibvibUqUU51FZlFjGNvuibHeksHymf1XE8IqNBcBF9ZhRPSjbJ8vnFLIgT9EtFLlmoe8JcYSSKMRQ14w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;我给他丢了一篇我早在 2014 年写的一篇文章 —— &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247483933&amp;amp;idx=1&amp;amp;sn=69b1be012cf37ccb5ce6f3a091f57f5b&amp;amp;chksm=eb4703f9dc308aef5834a6abf72255edd1767e633330531f817d7b4774c65c33f5910cd9ea75&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一个由跨平台产生的浮点数bug | 有你意想不到的结果&lt;/a&gt;，讲述了自己在开发过程中的一个“bug”，也因浮点数的表达引起的。&lt;/p&gt;&lt;p&gt;回想，当初这篇文章投稿到了著名的 CoolShell 博主 —— 左耳朵耗子那里，因为文中的表述不太清楚，还引起了一些讨论。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.48488830486202367&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibvibUqUU51FZlFjGNvuibHeksoibk84PBibg85TGQmG1d6BeVd4icx7qXgOfNtOBRImZsU7VicSgvR0m0kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/p&gt;&lt;p&gt;今天，我就借机会，再跟大家一起来探讨探讨关于浮点数的几个问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么负数要用补码表示&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;十进制小数怎么转成二进制？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;计算机是怎么存小数的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;0.1 + 0.2 == 0.3 吗？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;…&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;你能清晰的回答上述的问题吗，本篇文章将为你揭晓。详细原理请看完原文（值得收藏），&lt;strong&gt;文末有精简版回答，&lt;/strong&gt;另送一份不错的计算机基础总结。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;为什么负数要用补码表示？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;十进制转换二进制的方法相信大家都熟能生巧了，如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，贴心的小林在和你一起回忆一下。&lt;/p&gt;&lt;p&gt;十进制数转二进制采用的是&lt;strong&gt;除 2 取余法&lt;/strong&gt;，比如数字 8 转二进制的过程如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6529209621993127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaQykyJLxmvRCukLpS8jTwf0FibicoRXxWxsZjfF0iaob0IkWVdIKl24dWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接着，我们看看「整数类型」的数字在计算机的存储方式，这其实很简单，也很直观，就是将十进制的数字转换成二进制即可。&lt;/p&gt;&lt;p&gt;我们以 &lt;code&gt;int&lt;/code&gt; 类型的数字作为例子，int 类型是 &lt;code&gt;32&lt;/code&gt; 位的，其中&lt;strong&gt;最高位是作为「符号标志位」&lt;/strong&gt;，正数的符号位是 &lt;code&gt;0&lt;/code&gt;，负数的符号位是 &lt;code&gt;1&lt;/code&gt;，&lt;strong&gt;剩余的 31 位则表示二进制数据&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;那么，对于 int 类型的数字 1 的二进制数表示如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.39222042139384117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa3awC2B65Ed6vouKl0WxibibhapcFTDb2Csl6PtIMahia3rB7bb7y4a8BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;而负数就比较特殊了点，负数在计算机中是以「补码」表示的，&lt;strong&gt;所谓的补码就是把正数的二进制全部取反再加 1&lt;/strong&gt;，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.10221465076661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFao2ibSEMGoc5vZTVTUdwBZS4EYyPfwpGVR0xVPKTqowP9QMzJdia9aEiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;587&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;不知道你有没有想过，为什么计算机要用补码的方式来表示负数？在回答这个问题前，我们假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7062068965517241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa3rBgJkJYLibnoB49uyo2zYyFSe6ad7hKd2YYk93upkGtSmb5ChTawzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果采用这种方式来表示负数的二进制的话，试想一下 &lt;code&gt;-2 + 1&lt;/code&gt; 的运算过程，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.4984177215189873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaenMriaPNOkzWMlx1E53Azgb2BPy0ocCMTlOpc8d68PZWouL5oVLJ57A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;按道理，&lt;code&gt;-2 + 1 = -1&lt;/code&gt;，但是上面的运算过程中得到结果却是 &lt;code&gt;-3&lt;/code&gt;，所可以发现，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。&lt;/p&gt;&lt;p&gt;到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。&lt;/p&gt;&lt;p&gt;如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，&lt;strong&gt;还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法&lt;/strong&gt;，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的&lt;/strong&gt;。你可以看到下图，用补码表示的负数在运算 &lt;code&gt;-2 + 1&lt;/code&gt; 过程的时候，其结果是正确的：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.4984177215189873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa1Tt6Uq62YDEYvmSJHgfuX8eQ3XT1yteS97iaeaYibiaicicBLlVGL2rmySQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;十进制小数与二进制的转换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;好了，整数十进制转二进制我们知道了，接下来看看小数是怎么转二进制的，小数部分的转换不同于整数部分，它采用的是&lt;strong&gt;乘 2 取整法&lt;/strong&gt;，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。&lt;/p&gt;&lt;p&gt;话不多说，我们就以 &lt;code&gt;8.625&lt;/code&gt; 转二进制作为例子，直接上图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9325842696629213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa65IjFN7JSOcyJXPaSSTKpqiaYpRS0dyVDCDxNXsc4gFhN3tdI1NXn0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后把「整数部分 + 小数部分」结合在一起后，其结果就是 &lt;code&gt;1000.101&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制，如果我们用相同的方式，来把 &lt;code&gt;0.1&lt;/code&gt; 转换成二进制，过程如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.3650075414781297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaDQGxthXkjbbZrY9xjVoLuXQdj3HkibyNiciaeTbghMP0RibibwicJiaqr7kXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以发现，&lt;code&gt;0.1&lt;/code&gt; 的二进制表示是无限循环的，&lt;strong&gt;由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是&lt;strong&gt;负数&lt;/strong&gt;，比如二进制 &lt;code&gt;0.1&lt;/code&gt; 转成十进制就是 &lt;code&gt;2^(-1)&lt;/code&gt;，也就是十进制 &lt;code&gt;0.5&lt;/code&gt;，二进制 &lt;code&gt;0.01&lt;/code&gt; 转成十进制就是 &lt;code&gt;2^-2&lt;/code&gt;，也就是十进制 &lt;code&gt;0.25&lt;/code&gt;，以此类推。&lt;/p&gt;&lt;p&gt;举个例子，二进制 &lt;code&gt;1010.101&lt;/code&gt; 转十进制的过程，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3229946524064171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaMxHWU7L20ll8KhNXVKWGIX1ExKgQKvHLDEpcGPkxOuQl1Pxx3nzKvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;计算机是怎么存小数的？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;1000.101&lt;/code&gt; 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。&lt;/p&gt;&lt;p&gt;然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是&lt;strong&gt;浮点数&lt;/strong&gt;，名字里的「浮点」表示小数点是可以浮动的，比如 &lt;code&gt;1000.101&lt;/code&gt; 这个二进制数，可以表示成 &lt;code&gt;1.000101 x 2^(-3)&lt;/code&gt;，类似于数学上的科学记数法。&lt;/p&gt;&lt;p&gt;既然提到了科学计数法，我再帮大家复习一下，比如有个很大的十进制数 1230000，我们可以也可以表示成 &lt;code&gt;1.23 x 10^6&lt;/code&gt;，这种方式就称为科学记数法，该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为&lt;strong&gt;规格化&lt;/strong&gt;，比如 &lt;code&gt;1.0 x 10^(-9)&lt;/code&gt; 是规格化的科学记数法，而 &lt;code&gt;0.1 x 10^(-9)&lt;/code&gt; 和 &lt;code&gt;10.0 x 10^(-9)&lt;/code&gt; 就不是了。&lt;/p&gt;&lt;p&gt;因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1，所以通常将 &lt;code&gt;1000.101&lt;/code&gt; 这种二进制数，表示成 &lt;code&gt;1.000101 x 2^(-3)&lt;/code&gt;，其中，最为关键的是 000101 和 -3 这两个东西，它就可以包含了这个二进制小数的所有信息，&lt;code&gt;000101&lt;/code&gt; 称为&lt;strong&gt;尾数&lt;/strong&gt;，即小数点后面的数字，&lt;code&gt;-3&lt;/code&gt; 称为&lt;strong&gt;指数&lt;/strong&gt;，指定了小数点在数据中的位置。&lt;/p&gt;&lt;p&gt;现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1248303934871099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa09ib8nlWKVUb3TMpSUkF47m1NbL7vticrtlpohrHmxAOexrrVibicgQnZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这三个重要部分的意义如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;符号位&lt;/em&gt;：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;指数位&lt;/em&gt;：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，&lt;strong&gt;指数位的长度越长则数值的表达范围就越大&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;尾数位&lt;/em&gt;：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且&lt;strong&gt;尾数的长度决定了这个数的精度&lt;/strong&gt;，因此如果要表示精度更高的小数，则就要提高尾数位的长度；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;用 &lt;code&gt;32&lt;/code&gt; 位来表示的浮点数，则称为&lt;strong&gt;单精度浮点数&lt;/strong&gt;，也就是我们编程语言中的 &lt;code&gt;float&lt;/code&gt; 变量，而用 &lt;code&gt;64&lt;/code&gt; 位来表示的浮点数，称为&lt;strong&gt;双精度浮点数&lt;/strong&gt;，也就是 &lt;code&gt;double&lt;/code&gt; 变量，它们的结构如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.688135593220339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaIQHV8McXmNS3IibCS6vmRCsPDkvrksLwCghGHIjH068GoXlctcVb3BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 &lt;code&gt;log10(2^53)&lt;/code&gt; 约等于 &lt;code&gt;15.95&lt;/code&gt; 和 &lt;code&gt;log10(2^24)&lt;/code&gt;约等于 &lt;code&gt;7.22&lt;/code&gt; 位，因此 double 的有效数字是 &lt;code&gt;15~16&lt;/code&gt; 位，float 的有效数字是 &lt;code&gt;7~8&lt;/code&gt;位，这些是有效位是包含整数部分和小数部分；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那二进制小数，是如何转换成二进制浮点数的呢？我们就以 &lt;code&gt;10.625&lt;/code&gt; 作为例子，看看这个数字在 float 里是如何存储的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4820017559262511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaPhQq13uqibpy2ShHIiagARX79mYkpicue31KXEAy7OxjKkzcw9WPQibohw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1139&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先，我们计算出 10.625 的二进制小数为 1010.101，然后&lt;strong&gt;把小数点，移动到第一个有效数字后面&lt;/strong&gt;，即将 1010.101 右移 &lt;code&gt;3&lt;/code&gt; 位成 &lt;code&gt;1.010101&lt;/code&gt;，右移 3 位就代表 +3，左移 3 位就是 -3，&lt;strong&gt;float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了&lt;/strong&gt;，即指数位这 8 位存的是 &lt;code&gt;10000010&lt;/code&gt;（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。&lt;/p&gt;&lt;p&gt;&lt;code&gt;1.010101&lt;/code&gt; 这&lt;strong&gt;小数点右侧的数字就是 float 里的「尾数位」&lt;/strong&gt;，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 &lt;code&gt;01010100000000000000000&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在算指数的时候，你可能会有疑问为什么要加上偏移量呢？&lt;/p&gt;&lt;p&gt;前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成&lt;strong&gt;无符号整数&lt;/strong&gt;，float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 &lt;code&gt;-127 ~ +128&lt;/code&gt;，于是为了把指数转换成无符号整数，就要加个&lt;strong&gt;偏移量&lt;/strong&gt;，比如 float 的指数偏移量是 &lt;code&gt;127&lt;/code&gt;，这样指数就不会出现负数了。&lt;/p&gt;&lt;p&gt;比如，指数如果是 8，则实际存储的指数是 8 + 127 = 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去偏移量即可。&lt;/p&gt;&lt;p&gt;细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里，这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，&lt;strong&gt;既然这一位永远都是 1，那就可以不用存起来了&lt;/strong&gt;，于是就让 23 位尾数只存储小数部分，电路在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。&lt;/p&gt;&lt;p&gt;那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.17773788150807898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFabNKFDrE1CCicEZCn51csMIplPbHecKoE4xUexqOB4bFcYiclq5uEndQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;557&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7006651884700665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFasGrj7cJM8ehh03rZm2d2rMDN8V3HVyxpsIBfAic1tNDLkaGmk5lZjZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;0.1 + 0.2 == 0.3 ?&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。&lt;/p&gt;&lt;p&gt;因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值，现在基本都是用 IEEE 754 规范的单精度浮点类型或双精度浮点类型来存储小数的，根据精度的不同，近似值也会不同。&lt;/p&gt;&lt;p&gt;那计算机是存储 0.1 是一个怎么样的二进制浮点数呢？偷个懒，我就不自己手动算了，可以使用 binaryconvert 这个工具，将十进制 0.1 小数转换成 float 浮点数：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7208008898776418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaE11O6A4RYWtmyItE8Sib96oV2kojXgib5Fib1R9beBChmQp2iazE1maiaiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1798&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到，8 位指数部分是 &lt;code&gt;01111011&lt;/code&gt;，23 位的尾数部分是 &lt;code&gt;10011001100110011001101&lt;/code&gt;，可以看到尾数部分是 &lt;code&gt;0011&lt;/code&gt; 是一直循环的，只不过尾数是有长度限制的，所以只会显示一部分，所以是一个近似值，精度十分有限。&lt;/p&gt;&lt;p&gt;接下来，我们看看 0.2 的 float 浮点数：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3293492695883134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFakic3AZa3FK0HXIjSHxJ7rsVhj4LZNAfan88ctOCohzOibpI6VrPKiaj1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1506&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到，8 位指数部分是 01111100，稍微和 0.1 的指数不同，23 位的尾数部分是 10011001100110011001101 和 0.1 的尾数部分是相同的，也是一个近似值。&lt;/p&gt;&lt;p&gt;0.1 的二进制浮点数转换成十进制的结果是 &lt;code&gt;0.100000001490116119384765625&lt;/code&gt;：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7011144883485309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa0Lqm6icpOeJavck0TwkIZ5nqVWDVroxqBnEvO7TQRPgakJyn1jClssg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;0.2 的二进制浮点数转换成十进制的结果是 &lt;code&gt;0.20000000298023223876953125&lt;/code&gt;：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7011144883485309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaCQD2EyBzBzlyDhTj1AGibBiaYJNzHbj1WDj8NplhRS2iaE4B5f6z3G2hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这两个结果相加就是 &lt;code&gt;0.300000004470348358154296875&lt;/code&gt;：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7048387096774194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaK1fZJcqicS70XFyX2tjPRDpt4rQ6xLxzaicA8cW44jic4u0PJ9CvxzoBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;所以，你会看到在计算机中 0.1 + 0.2 并不等于完整的 0.3，这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。&lt;/p&gt;&lt;p&gt;我们在 JavaScript 里执行 0.1 + 0.2，你会得到下面这个结果：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2554347826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFac5I9FfdBWfIqricsBuTfYZ2l7QEMibbhcqIXaMplpaFSibsDgLE9EY9Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;184&quot; title=&quot;&quot; data-backw=&quot;304&quot; data-backh=&quot;78&quot;/&gt;&lt;/figure&gt;&lt;p&gt;结果和我们前面推到的类似，因为 JavaScript 对于数字都是使用 IEEE 754 标准下的双精度浮点类型来存储的，而我们二进制只能精准表达 2 除尽的数字 1/2, 1/4, 1/8，但是例如 0.1(1/10) 和 0.2(1/5)，在二进制中都无法精准表示时，需要根据精度舍入。&lt;/p&gt;&lt;p&gt;我们人类熟悉的十进制运算系统，可以精准表达 2 和 5 除尽的数字，例如1/2, 1/4, 1/5(0.2), 1/8, 1/10(0.1)。当然，十进制也有无法除尽的地方，例如 1/3, 1/7，也需要根据精度舍入。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;最后，再来回答开头多问题。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么负数要用补码表示？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;十进制小数怎么转成二进制？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;计算机是怎么存小数的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;0.1 + 0.2 == 0.3 吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。&lt;/p&gt;&lt;p&gt;因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。&lt;/p&gt;&lt;p&gt;0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;后记&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;浮点数其实是计算机程序设计的基础，最近我看到一份不错的&lt;span&gt;程序员硬核基础知识整理合集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaTo0PgEghzOx6tAM4k7X04GJdFkNaCY81iaHGk9XUBMIzNrkLXw09gZvqUznaicf4l7rWkDrBxEsfNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8768518518518519&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一本非常经典 PDF，从 CPU 到内存、讲解什么是二进制、磁盘、压缩算法、操作系统、汇编等知识。感兴趣的同学扫码下面二维码，后台回复 “&lt;/span&gt;&lt;span&gt;计算机基础总结&lt;/span&gt;&lt;span&gt;”领取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtdnfTuDgSCe2oO6g1Y8tiaOu0G7sKEJAibWAWXcWQvteRFX8PNPKdvP4H8pa8w0SwWgCgGCS1QYicUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;扫码回复“&lt;/span&gt;&lt;span&gt;计算机基础总结&lt;/span&gt;&lt;span&gt;”领取&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f89cd620bfe8903fea31f62402e893c0</guid>
<title>Golang 面试题：对已经关闭的的 chan 进行读写，会怎么样？为什么？</title>
<link>https://toutiao.io/k/blmg8fq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnnOGH8GxaUZDibkMDVBu32IG6PdicicjFniboatPO8svW7ciaTuwvEiayu3xEibkQg7pmcGd3GUSUic6Ca1ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对&lt;strong&gt;已经关闭&lt;/strong&gt;的的 &lt;code&gt;chan&lt;/code&gt; 进行读写，会怎么样？&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;怎么答&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;读&lt;strong&gt;已经关闭&lt;/strong&gt;的 &lt;code&gt;chan&lt;/code&gt; 能一直读到东西，但是读到的内容根据通道内&lt;code&gt;关闭前&lt;/code&gt;是否有元素而不同。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;chan&lt;/code&gt; 关闭前，&lt;code&gt;buffer&lt;/code&gt; 内有元素&lt;strong&gt;还未读&lt;/strong&gt; , 会正确读到 &lt;code&gt;chan&lt;/code&gt; 内的值，且返回的第二个 bool 值（是否读成功）为 &lt;code&gt;true&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;chan&lt;/code&gt; 关闭前，&lt;code&gt;buffer&lt;/code&gt; 内有元素&lt;strong&gt;已经被读完&lt;/strong&gt;，&lt;code&gt;chan&lt;/code&gt; 内无值，接下来所有接收的值都会非阻塞直接成功，返回 &lt;code&gt;channel&lt;/code&gt; 元素的&lt;strong&gt;零值&lt;/strong&gt;，但是第二个 &lt;code&gt;bool&lt;/code&gt; 值一直为 &lt;code&gt;false&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;写&lt;strong&gt;已经关闭&lt;/strong&gt;的 &lt;code&gt;chan&lt;/code&gt; 会 &lt;code&gt;panic&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;举例&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 写已经关闭的 chan&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5706874189364461&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnnOGH8GxaUZDibkMDVBu32IGCjRgeS4rTZKYpxCobNicaZ7YWaxicn1hzt7I4c7hbcjljtkjKDEHkOmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;注意这个 &lt;code&gt;send on closed channel&lt;/code&gt;，待会会提到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 读已经关闭的 chan&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.9213161659513591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnnOGH8GxaUZDibkMDVBu32IGpVAWDnIKE3gFibicjknjOagY0G5BjFIo9lsCibCbJJ0lOn5CaBtglBCTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1398&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多问一句&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 为什么写已经关闭的 &lt;code&gt;chan&lt;/code&gt; 就会 &lt;code&gt;panic&lt;/code&gt; 呢？&lt;/strong&gt;&lt;img data-ratio=&quot;0.4558258642765685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnnOGH8GxaUZDibkMDVBu32IGMbn9CTXtvq6LBZStvLdrbso2sMASgb7ibBfjND9keeCbMAXZ9O4ReHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1562&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当 &lt;code&gt;c.closed != 0&lt;/code&gt; 则为通道关闭，此时执行写，源码提示直接 panic，输出的内容就是上面提到的 &lt;code&gt;&quot;send on closed channel&quot;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 为什么读已关闭的 &lt;code&gt;chan&lt;/code&gt; 会一直能读到值？&lt;/strong&gt;&lt;img data-ratio=&quot;0.7656065959952886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnnOGH8GxaUZDibkMDVBu32IGNgAqmP7nlpqSj8O1QgiavXoQic0fKOCL5juDQGwtNvw9N7icjRxwCia2ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1698&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;c.closed != 0 &amp;amp;&amp;amp; c.qcount == 0&lt;/code&gt; 指通道已经关闭，且缓存为空的情况下（已经读完了之前写到通道里的值）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果接收值的地址 &lt;code&gt;ep&lt;/code&gt; 不为空&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;那接收值将获得是一个&lt;strong&gt;该类型的零值&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;typedmemclr&lt;/code&gt; 会&lt;strong&gt;根据类型清理&lt;/strong&gt;相应地址的内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这就解释了上面代码为什么关闭的 &lt;code&gt;chan&lt;/code&gt; 会返回对应类型的零值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文章推荐：&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如果你想每天学习一个知识点？&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3183856502242152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FmVWPHrDdnnOGH8GxaUZDibkMDVBu32IGVkffoB9xS4A7aXcV9jDoVHODcibptGnQGxR4FCb4ib2mAKznWib0qOVFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a7cb8bf9f25079581fa808ebf7bd60e4</guid>
<title>Elasticsearch 第三弹之存储原理</title>
<link>https://toutiao.io/k/yyhrqlm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;181&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.32344763670064874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOjRJj3rEmVIcZ4cxnPGXMbOToA3HQiafTrfmjfvOVQH0fLtCJwj3DkfC1GoPIRVmLY5oTemAhXibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;阅读本文大概需要 5 分钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上文中介绍的&lt;code&gt;ES&lt;/code&gt;内部索引的写处理流程是在&lt;code&gt;ES&lt;/code&gt;的内存中执行的，而数据被分配到特定的主、副分片上之后，最终是存储到磁盘上的，这样在断电的时候就不会丢失数据。具体的存储路径可在配置文件 ../config/elasticsearch.yml 中进行设置，默认存储在安装目录的 &lt;code&gt;Data&lt;/code&gt;文件夹下。建议不要使用默认值，因为若 ES 进行了升级，则有可能导致数据全部丢失。文件配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;path.data: /path/to/data  //索引数据&lt;br/&gt;path.logs: /path/to/logs  //日志记录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么&lt;code&gt;ES&lt;/code&gt;是怎么将索引从内存中同步到磁盘上的呢？今天我们就来说一下&lt;code&gt;ES&lt;/code&gt;的存储原理（搬着小板凳坐好）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先设想一下，&lt;code&gt;ES&lt;/code&gt;是否是直接调用 &lt;code&gt;Fsync&lt;/code&gt; 物理性地写入磁盘？答案是否定的，如果是直接写入磁盘，磁盘的 I/O 消耗会严重影响性能,那么当写数据量大的时候会造成 &lt;code&gt;ES&lt;/code&gt; 停顿卡死，查询也无法做到快速响应, &lt;code&gt;ES&lt;/code&gt; 就不会被称为近实时全文搜索引擎了。那么问题来了，&lt;code&gt;ES&lt;/code&gt; 是采用什么方式存储的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先来说几个概念，然后再具体介绍下它的整个流程及细节处理，方便大家更好的理解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引文档被拆分成多个子文档，则每个子文档叫作段。段提出来的原因是：在早期全文检索中为整个文档集合建立了一个很大的倒排索引，并将其写入磁盘中。如果索引有更新，就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，所以对数据的更新不能过于频繁，也就不能保证时效性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;特点&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引文档是以段的形式存储在磁盘上的，每一个段本身都是一个倒排索引，并且段具有不变性，一旦索引的数据被写入硬盘，就不能再修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么问题来了，不能修改，如何实现增删改呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新增：新增很好处理，由于数据是新的，所以只需要对当前文档新增一个段就可以了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除：段是不可改变的，所以既不能把文档从旧的段中移除，也不能修改旧的段来进行文档的更新。取而代之的是每个提交点（定义会在下边给出）会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。当一个文档被 “删除” 时，它实际上只是在 .del 文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新：更新相当于是删除和新增这两个动作组成。当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;一个&lt;code&gt;Lucene&lt;/code&gt;索引会包含一个提交点和多个段，段被写入到磁盘后会生成一个提交点，提交点是一个用来记录所有提交后段信息的文件。一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限。&lt;code&gt;ES&lt;/code&gt;在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段的优势&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦索引被读入内核的文件系统缓存，便会留在那里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其它缓存(像 &lt;code&gt;Filter&lt;/code&gt; 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段的缺点&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当对旧数据进行删除时，旧数据不会马上被删除，而是在 .del 文件中被标记为删除。而旧数据只能等到段更新时才能被移除，这样会造成大量的空间浪费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若有一条数据频繁的更新，每次更新都是新增新的标记旧的，则会有大量的空间浪费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次新增数据时都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源例如文件句柄的消耗会非常大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在查询的结果中包含所有的结果集，需要排除被标记删除的旧数据，这增加了查询的负担。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Refresh（刷新）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;ES&lt;/code&gt; 中，写入和打开一个新段的轻量的过程叫做 &lt;code&gt;Refresh&lt;/code&gt; （即ES内存刷新到文件缓存系统）。&lt;code&gt;ES&lt;/code&gt;首先会将文档加载到&lt;code&gt;ES&lt;/code&gt;的内存缓冲区（当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索），当达到默认的时间（1 秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh），这时数据就会被加载到文件缓存系统（操作系统的内存），创建新的段并将段打开以供搜索使用。这就是为什么我们说 &lt;code&gt;ES&lt;/code&gt; 是近实时搜索，因为文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。这就会存在一个问题：当你索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 &lt;code&gt;refresh API&lt;/code&gt; 执行一次手动刷新。配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;POST /_refresh         //刷新（Refresh）所有的索引。&lt;br/&gt;POST /blogs/_refresh   //只刷新（Refresh） blogs 索引。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注：&lt;/strong&gt; 当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管刷新是比提交轻量很多的操作，它还是会有性能开销，并不是所有的情况都需要每秒刷新：当你使用 &lt;code&gt;ES&lt;/code&gt; 索引大量的日志文件时，你可能想优化索引速度而不是近实时搜索，这时可以在创建索引时在 &lt;code&gt;Settings&lt;/code&gt; 中通过调大 &lt;code&gt;refresh_interval = &quot;30s&quot;&lt;/code&gt; 的值，降低每个索引的刷新频率，设值时需要注意后面带上时间单位，否则默认是毫秒，如果是1毫秒无疑会使你的集群陷入瘫痪。当 &lt;code&gt;refresh_interval=-1&lt;/code&gt; 时表示关闭索引的自动刷新。配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PUT /my_logs&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;settings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;refresh_interval&quot;&lt;/span&gt;: &lt;span&gt;&quot;1s&quot;&lt;/span&gt;   //每秒刷新 my_logs 索引&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;refresh_interval 可以在既存索引上进行动态更新。在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段合并&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和 &lt;code&gt;CPU&lt;/code&gt; 运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。&lt;code&gt;ES&lt;/code&gt; 通过在后台定期进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段（这些段既可以是未提交的也可以是已提交的）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49066666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNX3CanZrDGS46Pj4AUP4jPAC2zLTruJGeFS5Q3cXqHDB2YbqfcBo21EAgPeRiaQRFWW9697DaIKibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-backw=&quot;474&quot; data-backh=&quot;233&quot;/&gt;&lt;figcaption&gt;两个提交了的段和一个未提交的段正在被合并到一个更大的段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动段合并不需要你做任何事，进行索引和搜索时会自动进行：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这并不会中断索引和搜索；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、 “一旦合并结束，老的段被删除” 说明合并完成时的活动：新的段被刷新（flush）到了磁盘，写入一个包含新段且排除旧的和较小的段的新提交点，那些旧的已删除文档从文件系统中清除，被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49066666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNX3CanZrDGS46Pj4AUP4jPzraRXbDISEuRSlaicxpDMRRDtQHIk0taRaMt4LfibJShL2qgQv5vcXdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-backw=&quot;474&quot; data-backh=&quot;233&quot;/&gt;&lt;figcaption&gt;一旦合并结束，老的段被删除&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;段合并的计算量庞大，需要消耗大量的I/O和CPU资源，并会拖累写入速率，如果任其发展会影响搜索性能。&lt;code&gt;ES&lt;/code&gt; 在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。限流阈值默认是20MB/s，如果是&lt;code&gt;SSD&lt;/code&gt;，可以考虑100-200MB/s；如果是机械磁盘而非SSD，需要增加设置 &lt;code&gt;index.merge.scheduler.max_thread_count: 1&lt;/code&gt;。因为机械磁盘在并发 I/O 支持方面比较差，所以我们需要降低每个索引并发访问磁盘的线程数。这个设置允许 &lt;code&gt;max_thread_count + 2&lt;/code&gt; 个线程同时进行磁盘操作，也就是设置为 1 允许三个线程，SSD默认是 &lt;code&gt;Math.min(3, Runtime.getRuntime().availableProcessors() / 2)&lt;/code&gt;，支持很好；如果在做批量导入，不在意搜索，可以设置为none。配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PUT /_cluster/settings&lt;br/&gt;{&lt;br/&gt;    &quot;persistent&quot; : {&lt;br/&gt;        &quot;indices.store.throttle.max_bytes_per_sec&quot; : &quot;100mb&quot;&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;optimize API&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;optimize API&lt;/code&gt;大可看做是强制合并 &lt;code&gt;API&lt;/code&gt;。它会将一个分片强制合并到 &lt;code&gt;max_num_segments&lt;/code&gt; 参数指定大小的段数目。这样做的意图是减少段的数量（通常减少到一个）来提升搜索性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;optimize API&lt;/code&gt;不应该被用在一个活跃的索引--一个正积极更新的索引：后台合并流程已经可以很好地完成工作，&lt;code&gt;optimizing&lt;/code&gt; 会阻碍这个进程，不要干扰它！在特定情况下，使用 &lt;code&gt;optimize API&lt;/code&gt; 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中，老的索引实质上是只读的；它们也并不太可能会发生变化。在这种情况下，使用optimize优化老的索引，将每一个分片合并为一个单独的段就很有用了，这样既可以节省资源，也可以使搜索更加快速。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;POST /logstash-2014-10/_optimize?max_num_segments=1 //合并索引中的每个分片为一个单独的段&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;请注意，使用 &lt;code&gt;optimize API&lt;/code&gt; 触发段合并的操作不会受到任何资源上的限制。这可能会消耗掉你节点上全部的I/O资源，使其没有余力来处理搜索请求，从而有可能使集群失去响应。如果你想要对索引执行 &lt;code&gt;optimize&lt;/code&gt;，你需要先使用分片分配把索引移到一个安全的节点，再执行。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Translog&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提升写的性能，&lt;code&gt;ES&lt;/code&gt; 并没有每新增一条数据就增加一个段到磁盘上，而是采用延迟写的策略。等文件系统中有新段生成之后，在稍后的时间里再被刷新到磁盘中并生成提交点。虽然通过延时写的策略可以减少数据往磁盘上写的次数提升了整体的写入能力，但是我们知道文件缓存系统也是内存空间，属于操作系统的内存，只要是内存都存在断电或异常情况下丢失数据的危险。为了避免丢失数据，&lt;code&gt;ES&lt;/code&gt; 添加了事务日志（Translog），事务日志记录了所有还没有持久化到磁盘的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;translog&lt;/code&gt; 默认是每5秒被 &lt;code&gt;fsync&lt;/code&gt; 刷新到硬盘，或者在每次写请求完成之后执行(index, delete, update, bulk)操作也可以刷新到磁盘。在每次请求后都执行一个 &lt;code&gt;fsync&lt;/code&gt; 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是&lt;code&gt;bulk&lt;/code&gt;导入，它在一次请求中平摊了大量文档的开销）。对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 &lt;code&gt;fsync&lt;/code&gt; 还是比较有益的。我们可以通过设置 &lt;code&gt;durability&lt;/code&gt; 参数为 &lt;code&gt;async&lt;/code&gt; 来启用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PUT /my_index/_settings&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;index.translog.durability&quot;&lt;/span&gt;: &lt;span&gt;&quot;async&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;index.translog.sync_interval&quot;&lt;/span&gt;: &lt;span&gt;&quot;5s&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 &lt;code&gt;translog&lt;/code&gt; 的话，你需要保证在发生&lt;code&gt;crash&lt;/code&gt;时，丢失掉 &lt;code&gt;sync_interval&lt;/code&gt; 时间段的数据也无所谓。如果你不确定这个行为的后果，最好是使用默认的参数（ &quot;index.translog.durability&quot;: &quot;request&quot; ）来避免数据丢失。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Flush&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行一个提交并且截断 &lt;code&gt;translog&lt;/code&gt; 的行为在&lt;code&gt;ES&lt;/code&gt;中被称作一次&lt;code&gt;flush&lt;/code&gt;。分片每30分钟被自动刷新（flush）或者在 &lt;code&gt;translog&lt;/code&gt; 太大的时候也会刷新。可以通过设置&lt;code&gt;translog&lt;/code&gt; 文档来控制这些阈值，&lt;code&gt;flush API&lt;/code&gt; 可以被用来执行一个手工的刷新（flush）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;POST /blogs/_flush                //刷新（flush） blogs 索引。&lt;br/&gt;POST /_flush?wait_for_ongoing     //刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们来说一下添加了事务日志后的整个存储的流程吧：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6185344827586207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNX3CanZrDGS46Pj4AUP4jPn0nrHgu1EWVTVAqXVn5rT25c7RrQwseBaZJlYmoHpQ6qymyXX7B6yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot; data-backw=&quot;474&quot; data-backh=&quot;294&quot;/&gt;&lt;figcaption&gt;ES存储流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个新文档被索引之后，先被写入到内存中，但是为了防止数据的丢失，会追加一份数据到事务日志中。不断有新的文档被写入到内存，同时也都会记录到事务日志中（日志默认存储到文件缓存系统，每五秒刷新一下到本地磁盘，但是会导致数据丢失，也可以设置参数每个请求都同步，但是性能下降）。这时新数据还不能被检索和查询。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当达到默认的刷新时间或内存中的数据达到一定量后，会触发一次 &lt;code&gt;Refresh&lt;/code&gt;，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时虽然新段未被提交到磁盘，但是可以提供文档的检索功能且不能被修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随着新文档索引不断被写入，当日志数据大小超过 &lt;code&gt;512M&lt;/code&gt; 或者时间超过 &lt;code&gt;30&lt;/code&gt; 分钟时，会触发一次 &lt;code&gt;Flush&lt;/code&gt;。内存中的数据被写入到一个新段同时被写入到文件缓存系统，文件系统缓存中数据通过 &lt;code&gt;Fsync&lt;/code&gt; 刷新到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过这种方式当断电或需要重启时，&lt;code&gt;ES&lt;/code&gt; 不仅要根据提交点去加载已经持久化过的段，还需要读取 &lt;code&gt;Translog&lt;/code&gt; 里的记录，把未持久化的数据重新持久化到磁盘上，避免了数据丢失的可能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿Q正在将ES的知识做一个系统的学习与讲解，后续还会持续输出ES的相关知识，如果你感兴趣的话，可以关注微信公众号“阿Q说”！你也可以后台留言说出你的疑惑，阿Q将会在后期的文章中为你解答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;内容推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0040322580645162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPT7S5RYgFtCUAsTef19QwUcef3OposVMvMTicibTxGu35MiadwnDqqicK9CXgx7hG4nNxoDTY8Ql4BBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;496&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看完记得一键三连呦👇&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>