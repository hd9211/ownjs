<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8c722f50585e043a536ecd2acae2c8fd</guid>
<title>Flutter 的 Widget，刻意加上 const，真的值得吗？</title>
<link>https://toutiao.io/k/hdv64nz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYt82LBPhEciaSgpuPYiaENVLJ7KZto4Ef2vwJNK8Br1DZ7ibHibmGp94xHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hi，大家好，这里是承香墨影！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，我记起了公众号的帐号密码 &lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYMGGEalwbvneMZAUmhcKC5ia8JeCwXMANKtqBKQa8RofePA9glkz2Qpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近入坑 Flutter，又恰逢 Flutter 发布 2.0，正式全平台支持，那我也来分享一些 Flutter 相关的技术点，今天先从 &lt;code&gt;const Widget&lt;/code&gt; 这个比较小的优化点来展开。看看它的原理和使用限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Flutter 中，可谓是 &quot;一切皆 Widget&quot;，而 Widget 本质是一组信息的配置，它可以是 UI 展示，也可以是手势、导航等功能支持。但 Widget 被设计成不可变的，任何改变都是通过销毁/重建得到修改，在 Widget 不可变的背后，则是依赖 Element 可变/可复用的支持，所以 Flutter 将 Widget 设计的极其轻量，重建成本非常低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些优化的技术提到，在构建 Widget 的时候，可以使用 &lt;code&gt;const Widget&lt;/code&gt;，以此得到一个类似「缓存」的效果。虽然 Flutter 本身也会尽量的复用 Element，但是如果我们直接缓存 Widget，每次复用 Widget，最少节省了 Widget build 的步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个 &lt;code&gt;const widget&lt;/code&gt; 的优化点，背后的原理是什么？优化的收益大吗？值得我们重点关注吗？今天就唠唠这个。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、const 常量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始给 const 加上 Widget 前，我们先从 Dart 语言的 const 关键字开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到 const，不得不提与它类似的概念 final，它们都有常量的语义，即一旦赋值就不可修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的区别在于，const 是编译时常量，用 const 修饰的常量，必须在声明时初始化，并且是可以确定的值。而 final 则是运行时常量，用 final 修饰的常量，必须在声明时初始化，或者在构造函数中初始化，但它的值可以动态计算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，我们上个 Demo 就清晰了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5153970826580226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYicOIXLFN1c7YHvbHM5xiaZKRZYmLiaic4Ld5hE3mPZ7NALFH0yxDVJeWTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们用 const 声明类构造方法的时候，其相关的字段，必须是 final 的，也就是在设置后，就不可变了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么一个 Dart 类的对象，是否允许 const 修饰为常量，完全取决于类声明时，构造方法上是否被 const 修饰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子可以看到，当使用 const 构造的 Point 对象时，只要其入参一样，得到的就是同一个对象，例如示例中，p1 == p2 输出为 true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一旦 Point 的入参不同时，const 后的对象也不相同，例如示例中 &lt;code&gt;p2 == p3&lt;/code&gt; 则输出为 false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我就不带大家捋这其中的逻辑了，大家仔细对比一下代码和输出就了解了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到，const 关键字修饰的常量，必须是初始时就可以确定的值，也就是赋值的时候也必须是一个常量。例如我稍微修改一下 &lt;code&gt;const Point()&lt;/code&gt; 的入参，让它从一个方法获取，此时就会导致编译失败。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47836538461538464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYns6Fwf0Ow3kfOoSy3gMtMgib0lNjPSErXO0pRbxmthh99zlW3YshqPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1664&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，我们可以得到结论：&lt;strong&gt;使用 const 修饰的常量对象，只要保证构造时的入参不变化，我们可以得到相同的对象。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这背后的原理，无外乎就是 Dart VM 内部实现了常量池，利用享元模式复用了相同的对象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、const Widget&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说清楚 Dart 中的 &lt;code&gt;const&lt;/code&gt; 的意义以及如何使用，接下来我们把 Widget 加上，看看 &lt;code&gt;const Widget&lt;/code&gt; 优化的原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Flutter 中，Widget 本质只是一个信息配置的元素，它被定义为不可变的，任何的变化反映出来就是销毁 &amp;amp; 重建。而 Widget 不可变之所以不太会影响效率，背后是因为 Element 实现了对 Widget 变化的抽象。也就是虽然 Widget 会被重建，但是 Widget 背后的 Element，却得到了复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时 Flutter Framework，自有一套更新策略，确保 Widget 变化的同时，尽可能的复用 Element 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个策略的逻辑在 Element 的 &lt;code&gt;updateChild()&lt;/code&gt; 方法中，该方法在 Element 树建立和更新的过程中都非常的重要。我们这里只关心更新的流程，即父 Element 节点已经存在一个子 Element 节点了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父 Element 节点通过 &lt;code&gt;updateChild()&lt;/code&gt; 方法，判断如何处理自身的子 Element 节点，是新建、更新，或者直接移除。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0232558139534884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYFFsn8Zovd9H6Z9Exhl6SnaIwzRxcE3icKLFe25sybw4OeLqRqPbOURw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1376&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 &lt;code&gt;updateChild()&lt;/code&gt; 的实现可以看出，Element 依据新 Widget 更新的时候，会尽量复用已经存在的子 Element 节点，当无法被复用时，才会通过 &lt;code&gt;inflateWidget()&lt;/code&gt; 创建新的子 Element 节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;updateChild()&lt;/code&gt; 有 3 个入参，其中比较关键的是 child 和 newWidget，它们分别表示旧的 Element 子节点和新的 Widget 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Element 本身也持有 Widget 对象，若 child 持有的 widget 和 newWidget 相等时，表示新旧 Widget 没有变化，&lt;code&gt;updateChild()&lt;/code&gt; 的逻辑是直接复用 child，即旧的 Element，不会做任何额外的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果我们的 Widget 被定义成 const，在 &lt;code&gt;updateChild()&lt;/code&gt; 更新阶段，新旧 Widget 就是同一个对象，则不会重建 Widget，其背后的 Element 也不会更新，自然能起到了缓存复用的作用，加快构建的效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、const Widget 的收益大吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切优化的技巧都是手段，背后的优化效果才是我们的最终目的。一顿疯狂的操作，结果输出不明显，这肯定不是我们想要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 const Widget 优化的效果明显吗？值得我们在写代码的时候，分出点思绪专门考虑，当下这个场景是否需要使用它吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;先上结论：大可不必。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是优化，当然是做个测试，拿实测数据来说，是最有份量的。这里我找到了 @Cirzant Lai 分享的一个例子，就很能说明问题，之后再分享一些我的看法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 实测看数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里实现了一个小程序，显式一个随机显示 Image。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.226361031518625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYGFGLESm6uXgoRuLRRPJhtB3XWgoJsYknuKtibHhzia5KQ10qQNiacqY3Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;698&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就对这个 Image 是否使用 const 关键字构造来做比对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是使用 const 关键字的部分代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Image（&lt;br/&gt;  width：&lt;span&gt;100&lt;/span&gt;，&lt;br/&gt;  height：&lt;span&gt;100&lt;/span&gt;，&lt;br/&gt;  image：AssetImage（&lt;span&gt;&#x27;assets/logo.png&#x27;&lt;/span&gt;），&lt;br/&gt;）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个参照程序没有使用 const 关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 Image 通过 AnimatedPositioned 部件，每秒更新一次位置。然后使用 &lt;code&gt;--profile&lt;/code&gt; 方式运行程序，并通过 Dart DevTools 观测其 &quot;performance&quot; 和 &quot;memory&quot;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5277777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYap59FxhdWMzWJ9lQSrDhzupbdkmB1UgibeOWquda4JeAqAOiaCdeozlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了分析的严谨性，这里使用了一个较老的设备进行测试：Sony Xperia Z2，如果 Flutter 可以在此设备上依然很轻松的保持每秒 60 帧的速度，那么说明 Flutter 本身的优化已经非常好了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYZwrVrRj9WicDycbfhQeTqvcGjlwjkazsSPicpur8vNoYGqL98khsaE9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了设备之外，为了让测试数据更明显，这里逐步增多 Image 图标的数量，当增加到 1000 个时，每帧渲染所需的时间为 80ms，即约为 12.5 FPS。我想就没有继续增加数量的必要了，这个测试就以 1000 为边界，分别取 10、100、1000 三组数据，看看 &quot;performance&quot; 和 &quot;memory&quot; 分别的表现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GPU &amp;amp; UI：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23076923076923078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYgoibh0uGhO7LvpGtdzDFqto4zxskhLzgY5dD7JSWib5RKfOa6YuLibJRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Memory：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2398286937901499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktY8fLSvXCJC12TQQxJia47RqEqFYn0rh8IKgS3bPf8VVFYHlxPGs85B1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面分享的数据可以看到，当 Image 有 1000 个的时候，FPS 约提升了 8.4%，内存使用量下降了 20%。虽然这个数据看似非常的明显，但是实际体验上，2 个测试的流畅度并没有非常明显的差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我们在一个屏幕上放 1000 个 Image 的场景也不现实，对于大多数应用来说，每屏能有几十个 Widget，已经算是非常丰富了。而如果需要大量渲染，最好是直接使用 Canvas 绘制提升效率，而非依赖 const Widget 的这一点点优化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 const 对 GC 的优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Flutter 中，Widget 作为配置信息，本身被设计的非常的轻量，就是为了适应频繁的销毁重建，这个操作必然会引起对旧 Widget 对象的回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们时候 const 关键字声明常量的时候，背后是利用的是类似常量池的概念，将 const 的对象缓存在常量池中，以待后续复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常量会具备普通对象更长的生命周期，这有好处也有坏处。好处是常量对象会对 GC 不那么敏感，也就是不需要频繁的触发 GC。坏处是常量池中的声明周期较长，可能导致不常用的对象被缓存后，没有合适的释放时机，导致内存占用过高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实测下来，const 确实对 GC 有一些影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48289269051321926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktYo4j7CUu459WwTAHs1icdMzOJwGA63Bn5Uo8MNLaNDIUqQtdicn3JlXOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用的是前文中的例子，不断的创建小 Widget，最终对比使用 const 前后对内存的占用情况。可以看到使用 const 修饰 Widget 后，GC 减少了，并且也更平缓了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们应该就清楚，使用 const 修饰的 Widget，确实对 Flutter 的 build 过程有一些优化，但是优化并非很明显。在使用过程中，我们只需要按需使用就行，无需刻意的追求大量的 const 化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后小结一下，对于 Dart 语言来说。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个 Dart 类的对象是否能用 const 修饰，取决于类的构造方法上是否被 const 修饰；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 const 修饰的构造方法中，所有成员必须被 final 修饰；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;构造 const 对象时，传参也必须是 const 的常量；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;const 修饰的构造方法，不能有方法体；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Flutter 来说，const 修饰的优化点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;利用常量池复用 Widget，在更新频繁的 Widget 场景中，有优化作用，避免了 Widget 的回收和重建；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;const 对 GC 有一定的抑制左右，在会创建大量相同对象的场景下，创建的对象少了，自然 GC 也会变少；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;-- End --&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxNjc0ODExMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/liaczD18OicSyqdR0dH2EH3UXkJNVxb3VEOd59JWpUZSckeEIB0gK8xK9OszbSalkrljFOu4c7tEfExya24cdHWg/0?wx_fmt=png&quot; data-nickname=&quot;承香墨影&quot; data-alias=&quot;cxmyDev&quot; data-signature=&quot;我是承香墨影，8 年技术老司机。在这里，主要分享我个人的原创内容，不仅限于技术，职场、产品、设计思想等等，统统都有。这里已经汇集了有很多小伙伴了，欢迎你加入！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;References:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://medium.com/nerd-for-tech/flutter-performance-analysis-of-const-constructor-d2a72fd8a043&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://stackoverflow.com/questions/53492705/does-using-const-in-the-widget-tree-improve-performance/53493390#53493390&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://stackoverflow.com/questions/52581148/when-is-const-optional-in-dart-2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://dev.to/pedromassango/flutter-performance-tips-1-const-constructors-4j41&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NjU3MDA4NQ==&amp;amp;mid=2247484496&amp;amp;idx=1&amp;amp;sn=cd77008b385c5bf8b74a844e6b72e363&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;https://mp.weixin.qq.com/s?__biz=MzI0NjU3MDA4NQ==&amp;amp;mid=2247484496&amp;amp;idx=1&amp;amp;sn=cd77008b385c5bf8b74a844e6b72e363&amp;amp;scene=21#wechat_redirect&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/eSbdGBUAP50uL8kn5axFSQ&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文对你有帮助吗？&lt;strong&gt;留言、转发、点好看&lt;/strong&gt;是最大的支持，谢谢！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaczD18OicSw9ibzPDjnx4iaRwQF3W15ktY7Q8UBYGD6tel7rhMwf2dNkyyArsjrWs7TwJ4VOJyGMJnVTicRs88WhQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e7716c4e4c95addb6dbe9594cfa486cb</guid>
<title>鸿蒙系统研究第一步：从源码构建系统镜像</title>
<link>https://toutiao.io/k/mobj8bo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周末下载了 OpenHarmony OS 2.0 的源码，并 build 成功。虽然大部分的步骤都是来自官方文档，但还是碰到了一些问题，所以决定还是写下来，当作一个备忘录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我平常使用的开发环境是 Ubuntu Linux 系统，但这次切换到了 Windows 系统，原因是鸿蒙的开发工具 DevEcoStudio 和烧写工具 HiTool 只有 Windows 版本和 Mac 版本。好在 Windows 10 对 Linux 的支持非常好，其中 WSL (Windows Subsystem for Linux) 可以像 Windows 应用程序那样安装与运行，比使用虚拟机高效。WSL 已经进化到第二代，简称为 WSL2。关于 WSL2 的安装与配置，请参考相关文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我从 Microsoft Store 安装的 Linux 发行版本为 Ubuntu 18.04 LTS 版本。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5416666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv5LolY9aBs4MUak2C4crWvT8j0tNFuX6o0NicWriaibZbgwsEiahgFGmGD1PkSibbictUJC9zwicMY297f3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，WSL2 Linux 的系统镜像文件默认放置在 C 盘，如果 C 盘空间预留不是很足够的话，建议移动到其它空间比较足的盘上。具体方法如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先找到 WSL2 Linux 的系统镜像文件位置，默认为 &lt;em&gt;C:\Users&amp;lt;用户&amp;gt;\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState&lt;/em&gt; ，将其中的 &lt;strong&gt;&amp;lt;用户&amp;gt;&lt;/strong&gt; 替换为你的用户名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 &lt;em&gt;C:\Users&amp;lt;用户&amp;gt;\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState&lt;/em&gt; 移动到其它盘，比如 &lt;em&gt;D:\VirtualMachines\WSL2\Ubuntu18.04\LocalState&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建立符号链接（类似 Linux 下的软链接）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mklink /j C:\Users\chenz\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState D:\VirtualMachines\WSL2\Ubuntu18.04\LocalState&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做好上述准备后，就不会担心 C 盘被撑爆了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;言归正传，下面就说说在 Ubuntu 18.04 LTS 下如何下载和编译 OpenHarmony OS 2.0 的源码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装依赖工具&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo apt-get update&lt;br/&gt;sudo apt-get install binutils git-core git-lfs gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 python2.7 python-minimal&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取标准系统源码&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档给了三种获取系统源码的方式，如果是研究鸿蒙系统，最好直接从软件仓库下载，这样有比较完善的提交信息。所以这里只介绍如何从软件仓库克隆系统源码。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置 git 用户信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;git config --global user.name &lt;span&gt;&quot;yourname&quot;&lt;/span&gt;&lt;br/&gt;git config --global user.email &lt;span&gt;&quot;your-email-address&quot;&lt;/span&gt;&lt;br/&gt;git config --global credential.helper store&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;安装 repo 工具，可以执行如下命令。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 &amp;gt; repo&lt;br/&gt;$ chmod a+x repo&lt;br/&gt;$ sudo mv repo /usr/&lt;span&gt;local&lt;/span&gt;/bin/repo&lt;br/&gt;$ sudo apt install python3-pip&lt;br/&gt;$ pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取标准系统源码&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir OpenHarmony&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; OpenHarmony&lt;br/&gt;&lt;br/&gt;$ repo init -u https://gitee.com/openharmony/manifest.git -b master --no-repo-verify&lt;br/&gt;&lt;br/&gt;$ repo sync -c&lt;br/&gt;&lt;br/&gt;$ repo forall -c &lt;span&gt;&#x27;git lfs pull&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;strong&gt;repo sync&lt;/strong&gt; 命令后面的 &lt;strong&gt;-c&lt;/strong&gt; 参数表示只获取当前分支的源码，也就是说并不是所有分支的代码。我尝试不加这个 &lt;strong&gt;-c&lt;/strong&gt; 参数，可能是 gitee 的配置问题，超过 1G 的软件仓库，比如 linux kernel 就出现如下错误，网上搜索了很多方法也未能解决。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated.&lt;br/&gt;fatal: The remote end hung up unexpectedly&lt;br/&gt;fatal: early EOF&lt;br/&gt;fatal: index-pack failed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取预编译工具&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl https://gitee.com/landwind/script-tools/raw/master/Shell/OpenHarmony/OpenHarmony_2.0_canary_prebuilts_download.sh &amp;gt;./prebuilts_download.sh&lt;br/&gt;$ bash ./prebuilts_download.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配置NodeJS环境和获取Node_modules依赖包&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;下载Nodejs。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir -p prebuilts/build-tools/common/nodejs&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; prebuilts/build-tools/common/nodejs&lt;br/&gt;$ wget --no-check-certificate https://nodejs.org/download/release/v12.18.4/node-v12.18.4-linux-x64.tar.gz&lt;br/&gt;$ tar -zxvf node-v12.18.4-linux-x64.tar.gz&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;下载node_modules包。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ &lt;span&gt;cd&lt;/span&gt; third_party/jsframework&lt;br/&gt;$ &lt;span&gt;export&lt;/span&gt; PATH=../../prebuilts/build-tools/common/nodejs/node-v12.18.4-linux-x64/bin:&lt;span&gt;${PATH}&lt;/span&gt;&lt;br/&gt;$ npm install&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; -&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把下载的node_modules包放入OpenHarmony代码的prebuilts/build-tools/common/js-framework目录下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ mkdir -p prebuilts/build-tools/common/js-framework&lt;br/&gt;$ cp -rp third_party/jsframework/node_modules prebuilts/build-tools/common/js-framework/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装hc-gen工具&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hc-gen用于进行驱动编译，具体安装步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;下载 hc-gen 工具。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ wget https://repo.huaweicloud.com/harmonyos/compiler/hc-gen/0.65/linux/hc-gen-0.65-linux.tar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;解压 hc-gen 安装包到 ~/hc-gen 路径下。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;tar -xvf hc-gen-0.65-linux.tar -C ~/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;设置环境变量。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;vim ~/.bashrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将以下命令拷贝到.bashrc文件的最后一行，保存并退出。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; PATH=~/hc-gen:&lt;span&gt;$PATH&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;生效环境变量。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;source&lt;/span&gt; ~/.bashrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编译系统&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行脚本 build.sh 即可，后面必须加上 &lt;strong&gt;--product-name Hi3516DV300&lt;/strong&gt; 参数，目前只支持这一种产品形态的构建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ./build.sh --product-name Hi3516DV300 --ccache&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建成功以后，输出如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5416666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv5LolY9aBs4MUak2C4crWvTgmLia0tg0Kx94g5r4PSMnn9Vuq9CyzC8MI1aibj6rTSYDicA2asINTv6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手头还没有 Hi3516DV300 的板子，所以无法烧写体验鸿蒙系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常意外的是，OpenHarmony OS 2.0 没有提供模拟器的 build 选择，这对开发者相当不友好。后面我会研究一下 QEMU 模拟器，看能否在 QEMU 上把 OpenHarmony OS 2.0 运行起来，敬请关注。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv50C2zJtfH5icNbOicm63Mwia4EaZdIJtQDz9rJLxS6LBsVgWJXtbJIFBaAH2nzu7tBEic76fFUEphPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26069f61ac5f7fd5bd371306103ba9ff</guid>
<title>FP-Growth 算法原理、Spark 实现和应用介绍</title>
<link>https://toutiao.io/k/md02mcl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;Spark推荐实战系列目前已经更新：&lt;/h1&gt;&lt;section&gt;欢迎持续关注，本篇主要介绍频繁模式挖掘中FP-Growth！&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1. 背景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;啤酒和尿布的故事相信大家都已经知道了，这其中对应的则是机器学习中「频繁挖掘」的概念，其实在推荐系统中「频繁挖掘」也经常被用来进行相关商品的挖掘推荐，这其中有点协同的意思，但是和协同又不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247496047&amp;amp;idx=1&amp;amp;sn=7f82217f5b200dc27d01bd2a349aa603&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;迁移学习与跨域推荐，以及解决跨域推荐的方法&lt;/a&gt;」中，提到过使用「频繁挖掘」解决跨域推荐的问题，也可以用来进行推荐中的召回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇内容主要看一下「频繁挖掘」中「FP-Growth」算法的原理、代码实现、应用。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 原理&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍FP-Growth之前，先看一下&lt;strong&gt;关联分析&lt;/strong&gt;和&lt;strong&gt;Apriori&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 关联分析&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关联分析（association analysis）：从大规模数据集中寻找商品的隐含关系&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项集 （itemset）：包含0个或者多个项的集合称为项集&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;频繁项集：那些经常一起出现的物品集合&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持度计数（support count）：一个项集出现的次数也就是整个交易数据集中包含该项集的事物数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关联规则是形如A-&amp;gt;B的表达式，规则A-&amp;gt;B的度量包括支持度和置信度：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;项集支持度：一个项集出现的次数与数据集所有事物数的百分比称为项集的支持度，eg：support(A-&amp;gt;B)=support_count(A并B) / N&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;项集置信度（confidence）：数据集中同时包含A，B的百分比，eg：confidence(A-&amp;gt;B) = support_count(A并B) / support_count(A)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关联分析一些应用&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;购物篮分析，通过查看那些商品经常在一起出售，可以帮助商店了解用户的购物行为，这种从数据的海洋中抽取只是可以用于商品定价、市场促销、存货管理等环节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在Twitter源中发现一些公共词。对于给定的搜索词，发现推文中频繁出现的单词集合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从新闻网站点击流中挖掘新闻流行趋势，挖掘哪些新闻广泛被用户浏览到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;搜索引擎推荐，在用户输入查询时推荐同时相关的查询词项&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发现毒蘑菇的相似特征。这里只对包含某个特征元素（有毒素）的项集感兴趣，从中寻找毒蘑菇中的一些公共特征，利用这些特征来避免迟到哪些有毒的蘑菇&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Apriori&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找出所有可能是频繁项集的项集，即候选项集，然后根据最小支持度计数删选出频繁项集，最简单的办法是穷举法，即把每个项集都作为候选项集，统计他在数据集中出现的次数，如果出现次数大于最小支持度计数，则为频繁项集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如针对超市的一个购物记录：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;交易号码&lt;/th&gt;&lt;th&gt;商品&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;Cola，Egg，Ham&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;Cola，Diaper，Beer&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;300&lt;/td&gt;&lt;td&gt;Cola，Diaper，Beer，Ham&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;400&lt;/td&gt;&lt;td&gt;Diaper，Beer&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的可能项集为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;274&quot; data-backw=&quot;561&quot; data-ratio=&quot;0.4876543209876543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsInicg1eMQVITQS4cyOpX8ib4Ll9xXEibsmFU3j82eOoeic27z9fdvzCFUiaxgGoK4P2XRibVyYoT3OgLzwuBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;figcaption&gt;所有的可能的项集（E：Egg   C：Cola   D：Diaper   B：Beer   H：Ham）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;频繁项集的发现过程如下（假定给定的最小支持度为2）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;473&quot; data-backw=&quot;560&quot; data-ratio=&quot;0.8426966292134831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsInicg1eMQVITQS4cyOpX8ib4Ll9CHXRwmaeT6efp2lAibft6xLh6RKZCNB4kV1jXq7O9v65abVO1Yd5MZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;712&quot;/&gt;&lt;figcaption&gt;频繁项集的发现过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过剪枝后的图为（红色圆圈内即为剪枝去掉的部分）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;274&quot; data-backw=&quot;561&quot; data-ratio=&quot;0.4876543209876543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/02kicEWsInicg1eMQVITQS4cyOpX8ib4Ll9Ey9A88dpKP25Fbiargfvoc0ia9zaz3pySxtFzbhvwdiblFeq4sl2uflJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;figcaption&gt;剪枝后的候选集为（E：Egg   C：Cola   D：Diaper   B：Beer   H：Ham）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么CD，CB，CH，DB，DH，BH，DBH即为所求的候选集。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 FP-Growth&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FP-growth算法不同于Apriori算法生成候选项集再检查是否频繁的”产生-测试“方法，而是使用一种称为频繁模式树（FP-Tree，PF代表频繁模式，Frequent Pattern）菜单紧凑数据结构组织数据，并直接从该结构中提取频繁项集，同样以上面的购物记录为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FP-growth算法分为两个过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一是根据原始数据构造FP-Tree&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二是在FP-Tree上挖掘频繁模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做出FP-Tree，频繁模式树的挖掘形成过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先扫描一遍数据集，找出频繁项的列表L，按照他们的支持度计数递减排序，即 L = &amp;lt;（Cola：3），（Diaper：3），（Beer：3），（Ham：2）&amp;gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再次扫描数据库，利用每个事物中的频繁项构造FP-Tree，FP-Tree的根节点为null，处理每个事物时按照L中的顺序将事物中出现的频繁项添加到中的一个分支&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，第一个事物创建一个分支&amp;lt;（Cola：1），（Ham：1）&amp;gt;，第二个事物中包含频繁项排序后为&amp;lt;（Cola，Diaper，Beer）&amp;gt;，与树中的分支共享前缀（Cola），因此将树中的节点Cola的计数分别加一，在Cola节点创建分支&amp;lt;（Diaper：1），（Beer：1）&amp;gt;，依次类推，将数据集中的事物都添加到FP-Tree中，为便于遍历树，创建一个头节点表，使得每个项通过一个节点链指向他在树中的出现，相同的链在一个链表中，构造好的FP-Tree树如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;226&quot; data-backw=&quot;561&quot; data-ratio=&quot;0.4020100502512563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsInicg1eMQVITQS4cyOpX8ib4Ll9ZicJyFYWJEo7iakfd3FTKEpfoNkj7YzFDIXouNaYplancjY4bXJia0bCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;597&quot;/&gt;&lt;figcaption&gt;构造好的FP-Tree树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在FP-Tree上挖掘频繁模式：挖掘FP-Tree采用自低向上的迭代模式，首先查找以”Ham“为后缀的频繁项集，然后依次是”Beer“，”Diaper“，”Cola“。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查找以”Ham“为后缀的频繁项集：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先在FP-Tree中找出所有包含”Ham“的记录，利用头节点表和树节点的链接，找出包含”Ham“的两个分支，&amp;lt;Cola：3，Ham：1&amp;gt;和&amp;lt;（Cola：3，Diaper：2，Beer：1，Ham：1）&amp;gt;，说明在该FP-Tree所代表的数据集中记录（Cola，Ham）和（Cola，Diaper，Beer，Ham）各出现了一次，利用这两个分支所代表的记录构造”Ham“的条件模式基。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;条件模式基可以看作是一个“子数据集”，由FP-Tree中与后缀模式一起出现的前缀路径组成，Ham作为后缀模式时，”Ham“的两个前缀路径{（Cola：1），（Cola Diaper Beer：1）}构成了”Ham“的条件模式基。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;利用”Ham“的条件模式基构造FP-TRee，即“Ham”的条件FP树。“Ham ”的条件模式基中，Cola出现了2次，Diaper，Beer只出现了1次，所以Diaper，Beer是非频繁项，不包含在“Ham”的条件模式树中，“Ham”的条件模式树只有一个分支&amp;lt;Cola：2&amp;gt;，得到条件频繁项集{Cola：2}，条件频繁项集与后缀模式“Ham“合并，得到频繁项集{Cola Ham ：2}&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理查找”Beer“为后缀的频繁项集，得到{ {Diaper  Beer ：3} ，  {Cola  Diaper  Beer：2}， {Cola  Beer：2}  }
查找”Diaper“为结尾的频繁项集，得到 {Cola Diaper ：2}&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Spark实现&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FP-Growth论文地址：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;http://www.cse.msu.edu/~cse960/Papers/MineFeqPatteren-HPY-SIGMOD2000.pdf&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spark中FP_Growthd的超参数说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;minSupport&lt;/strong&gt; ：最小支持度，一个项集出现的次数与数据集所有事物数的百分比称为项集的支持度，support(A-&amp;gt;B)=support_count(A并B) / N&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;minConfidence&lt;/strong&gt;：最小置信度，数据集中同时包含A，B的百分比，confidence(A-&amp;gt;B) = support_count(A并B) / support_count(A)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;numPartitions&lt;/strong&gt;：数据的分区数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;FPGrowthModel&lt;/strong&gt; 提供的方法:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;freqItemsets&lt;/strong&gt; ：频繁项集，格式为&lt;code&gt;DataFrame(“items”[Array], “freq”[Long])&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;associationRules&lt;/strong&gt;：以高于minConfidence的置信度生成的关联规则，格式为&lt;code&gt;DataFrame(“antecedent”[Array], “consequent”[Array], “confidence”[Double])&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;transform&lt;/strong&gt;：对于itemsCol中的每个事务，transform方法将其项目与每个关联规则的前提进行比较。如果记录包含特定关联规则的所有前提(规则中的前项)，则该规则将被视为适用，并且其结果将被添加到预测结果中。transform方法将所有适用规则的结果总结为预测。预测列与itemsCol具有相同的数据类型，并且不包含itemsCol中的现有项&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;import&lt;/span&gt; spark.sqlContext.implicits._&lt;br/&gt;        &lt;span&gt;val&lt;/span&gt; train = spark.sparkContext.textFile(dataPath)&lt;br/&gt;            .map(_.split(&lt;span&gt;&quot; &quot;&lt;/span&gt;).toSet.toArray)&lt;br/&gt;            .toDF(&lt;span&gt;&quot;items&quot;&lt;/span&gt;)&lt;br/&gt;        println(&lt;span&gt;s&quot;使用的数据序列条数为：&lt;span&gt;${train.count()}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;        train.show(&lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;val&lt;/span&gt; fpgrowth = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;FPGrowth&lt;/span&gt;()&lt;br/&gt;            .setItemsCol(&lt;span&gt;&quot;items&quot;&lt;/span&gt;)&lt;br/&gt;            .setMinSupport(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;            .setMinConfidence(&lt;span&gt;0.2&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;val&lt;/span&gt; model = fpgrowth.fit(train)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Display frequent itemsets.&lt;/span&gt;&lt;br/&gt;        model.freqItemsets.show()&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Display generated association rules.&lt;/span&gt;&lt;br/&gt;        model.associationRules.show()&lt;br/&gt;        &lt;span&gt;// transform examines the input items against all the association rules and summarize the&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// consequents as prediction&lt;/span&gt;&lt;br/&gt;        model.transform(train).show()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 应用&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FpGrowth的最直接应用是差生i2i词表，基于用户的点击序列进行频繁模式挖掘，构建item的相似item列表，线上使用时直接使用用户最近点击的item进行触发。但这种方式其实可以直接使用itemcf或者其他的i2i方法了，没必要再进行fp-growth挖掘了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实频繁模式更加直观的应用是作为跨域推荐的初始方法。例如某个公司的app中包含多条业务线，其中A是比较成熟的业务，用户行为比较丰富，B是刚孵化不久的业务。这种情况下，两个业务的用户行为交集是存在的，那么如何给首次到访B业务的用户进行推荐的，就可以利用频繁模式挖掘的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其大致思路是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;筛选两个业务的共同用户群，构建用户的行为序列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于FP-Growth进行挖掘，最后得到A业务item的关联B业务item&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者是构建pair对&amp;lt;item A, item B&amp;gt;，基于相关性的方法进行计算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网页版参考：https://blog.csdn.net/Gamer_gyt/article/details/51113753&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>052d123394e0a057146d06b6c0306c59</guid>
<title>Redis：我是如何与客户端进行通信的</title>
<link>https://toutiao.io/k/dr4u4yt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;江湖上说，&lt;strong&gt;天下武功，无坚不摧，唯快不破&lt;/strong&gt;，这句话简直是为我量身定制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一个Redis服务，最引以为傲的就是我的速度，我的 QPS 能达到10万级别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的手下有数不清的小弟，他们会时不时到我这来存放或者取走一些数据，我管他们叫做客户端，还给他们起了英文名叫 Redis-client。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候一个小弟会来的非常频繁，有时候一堆小弟会同时过来，但是，即使再多的小弟我也能管理的井井有条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小弟们问我。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfoy2icYqicT72JftlHDibibSES2rlIOOYyFGNpDvc9lEy5Je4pkIpwpYjdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想当年，为了不让小弟们拖垮我傲人的速度，在设计和他们的通信协议时，我绞尽脑汁，制定了下面的三条原则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对计算机来说，解析速度快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对人类来说，可读性强&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么设计呢？先来看看一条指令发出的过程，首先在客户端需要对指令操作进行封装，使用网络进行传输，最后在服务端进行相应的解析、执行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicaLtJLCXG77p4PNzYoiaRAw5KYTmIWibRvsmxTp149neUMtI3gWFTiageu3ic5KFHm9HlmPkGxkCbZIMA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一过程如果设计成一种非常复杂的协议，那么封装、解析、传输的过程都将非常耗时，无疑会降低我的速度。什么，你问我为什么要遵循最后一条规则？算是对于程序员们的馈赠吧，我真是太善良了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把创造出来的这种协议称为 RESP (&lt;code&gt;REdis Serialization Protocol&lt;/code&gt;)协议，它工作在 TCP 协议的上层，作为我和客户端之间进行通讯的标准形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这，我已经有点迫不及待想让你们看看我设计出来的杰作了，但我好歹也是个大哥，得摆点架子，不能我主动拿来给你们看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我建议你直接使用客户端发出一条向服务器的命令，然后取出这条命令对应的报文来直观的看一下。话虽如此，不过我已经被封装的很严实了，正常情况下你是看不到我内部进行通讯的具体报文的，所以，你可以&lt;strong&gt;伪装&lt;/strong&gt;成一个Redis的服务端，来截获小弟们发给我的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现起来也很简单，我和小弟之间是基于 Socket 进行通讯，所以在本地先启动一个&lt;code&gt;ServerSocket&lt;/code&gt;，用来监听Redis服务的6379端口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;new&lt;/span&gt; ServerSocket(&lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    Socket socket = serverSocket.accept();&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;    InputStream input = socket.getInputStream();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(input.read(bytes)!=&lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;        System.out.println(&lt;span&gt;new&lt;/span&gt; String(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动&lt;code&gt;redis-cli&lt;/code&gt;客户端，发送一条命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set key1 value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，伪装的服务端就会收到报文了，在控制台打印了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*3&lt;br/&gt;$3&lt;br/&gt;set&lt;br/&gt;$4&lt;br/&gt;key1&lt;br/&gt;$6&lt;br/&gt;value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，隐隐约约看到了刚才输入的几个关键字，但是还有一些其他的字符，要怎么解释呢，是时候让我对协议报文中的格式进行一下揭秘了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我对小弟们说了，对大哥说话的时候得按规矩来，这样吧，你们在请求的时候要遵循下面的规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*&amp;lt;参数数量&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数1的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数1的数据&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数2的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数2的数据&amp;gt; CRLF&lt;br/&gt;...&lt;br/&gt;$&amp;lt;参数N的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数N的数据&amp;gt; CRLF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先解释一下每行末尾的&lt;code&gt;CRLF&lt;/code&gt;，转换成程序语言就是&lt;code&gt;\r\n&lt;/code&gt;，也就是回车加换行。看到这里，你也就能够明白为什么控制台打印出的指令是竖向排列了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命令的解析过程中，&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;key1&lt;/code&gt;、&lt;code&gt;value1&lt;/code&gt;会被认为是3个参数，因此参数数量为3，对应第一行的&lt;code&gt;*3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个参数&lt;code&gt;set&lt;/code&gt;，长度为3对应&lt;code&gt;$3&lt;/code&gt;；第二个参数&lt;code&gt;key1&lt;/code&gt;，长度为4对应&lt;code&gt;$4&lt;/code&gt;；第三个参数&lt;code&gt;value1&lt;/code&gt;，长度为6对应&lt;code&gt;$6&lt;/code&gt;。在每个参数长度的下一行对应真正的参数数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，一条指令被转换为协议报文的过程是不是就很好理解了？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyf1BJ8xSic8HRQJKdbo0xVqK3ZpxPW5jFxibEcGeajCuxuoqg8PFDkINEg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当小弟对我发送完请求后，作为大哥，我就要对小弟的请求进行&lt;strong&gt;指令回复&lt;/strong&gt;了，而且我得根据回复内容进行一下分类，要不然小弟该搞不清我的指示了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单字符串&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单字符串回复只有一行回复，回复的内容以&lt;code&gt;+&lt;/code&gt;作为开头，不允许换行，并以&lt;code&gt;\r\n&lt;/code&gt;结束。有很多指令在执行成功后只会回复一个&lt;code&gt;OK&lt;/code&gt;，使用的就是这种格式，能够有效的将传输、解析的开销降到最低。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.084033613445378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfqlJaHViaKC8OqiaoUCnUSleGjticb8hukVjQAVyzfiboxYDvhdCjbBLkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RESP协议中，错误回复可以当做简单字符串回复的变种形式，它们之间的格式也非常类似，区别只有第一个字符是以&lt;code&gt;-&lt;/code&gt;作为开头，错误回复的内容通常是错误类型及对错误描述的字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误回复出现在一些异常的场景，例如当发送了错误的指令、操作数的数量不对时，都会进行错误回复。在客户端收到错误回复后，会将它与简单字符串回复进行区分，视为异常。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.184873949579832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfg3vfSI3FdGySPRlPuGDajnFfmNmqoEyDfwzDzMo1u9fWKw01Qb8PgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;整数回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整数回复的应用也非常广泛，它以&lt;code&gt;:&lt;/code&gt;作为开头，以&lt;code&gt;\r\n&lt;/code&gt;结束，用于返回一个整数。例如当执行&lt;code&gt;incr&lt;/code&gt;后返回自增后的值，执行&lt;code&gt;llen&lt;/code&gt;返回数组的长度，或者使用&lt;code&gt;exists&lt;/code&gt;命令返回的0或1作为判断一个&lt;code&gt;key&lt;/code&gt;是否存在的依据，这些都使用了整数回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9537815126050421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfa4LiaqVYk1TOahicuRq4E2ib6nxDLEyzQsLiaRXzBtoiaKWeYzlETzhDia8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量回复，就是多行字符串的回复。它以&lt;code&gt;$&lt;/code&gt;作为开头，后面是发送的字节长度，然后是&lt;code&gt;\r\n&lt;/code&gt;，然后发送实际的数据，最终以&lt;code&gt;\r\n&lt;/code&gt;结束。如果要回复的数据不存在，那么回复长度为-1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5126050420168067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfBnACFwLBXNNhggIcPH9K5JXQjXeJna8zEqicQBA30rYW7ZnyzfDkic5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多条批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当服务端要返回多个值时，例如返回一些元素的集合时，就会使用多条批量回复。它以&lt;code&gt;*&lt;/code&gt;作为开头，后面是返回元素的个数，之后再跟随多个上面讲到过的批量回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3907563025210083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfq3s6vL0Ud67Ivib4UE6BRUibInIkmiaOUf2OX8ibWpJ4ThDSwGQ4JJZwcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，基本上我和小弟之间的通讯协议就介绍完了。刚才你尝试了伪装成一个服务端，这会再来试一试直接写一个客户端来直接和我进行交互吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;client&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    String CRLF=&lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    Socket socket=&lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (OutputStream out = socket.getOutputStream()) {&lt;br/&gt;        StringBuffer sb=&lt;span&gt;new&lt;/span&gt; StringBuffer();&lt;br/&gt;        sb.append(&lt;span&gt;&quot;*3&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$3&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;set&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$4&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$6&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;value1&quot;&lt;/span&gt;).append(CRLF);&lt;br/&gt;        out.write(sb.toString().getBytes());&lt;br/&gt;        out.flush();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; (InputStream inputStream = socket.getInputStream()) {&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] buff = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len = inputStream.read(buff);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                String ret = &lt;span&gt;new&lt;/span&gt; String(buff, &lt;span&gt;0&lt;/span&gt;, len);&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;Recv:&quot;&lt;/span&gt; + ret);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的代码，控制台输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Recv:+OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面模仿了客户端发出&lt;code&gt;set&lt;/code&gt;命令的过程，并收到了回复。依此类推，你也可以自己封装其他的命令，来实现一个自己的Redis客户端，作为小弟，来和我进行通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过记住，要叫我大哥。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7db9cc37c117dde6015278170806e2dc</guid>
<title>ZooKeeper 集群拒绝服务</title>
<link>https://toutiao.io/k/74x2gyc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;ZooKeeper作为dubbo的注册中心，可谓是重中之重，线上ZK的任何风吹草动都会牵动心弦。最近笔者就碰到线上ZK Leader宕机后，选主无法成功导致ZK集群拒绝服务的现象，于是把这个case写出来分享给大家(基于ZooKeeper 3.4.5)。&lt;/p&gt;&lt;h2&gt;Bug现场&lt;/h2&gt;&lt;p&gt;一天早上，突然接到电话，说是ZooKeeper物理机宕机了，而剩余几台机器状态都是&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sh zkServer.sh status&lt;br/&gt;it is probably not running&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;笔者看了下监控，物理机宕机的正好是ZK的leader。3节点的ZK，leader宕了后，其余两台一直未能成为leader，把宕机的那台紧急拉起来之后，依旧无法选主，&lt;br/&gt;导致ZK集群整体拒绝服务！&lt;br/&gt;&lt;img data-ratio=&quot;0.43546284224250326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0m4ibVmN3CGPSxKJJdcVq2u6cHK6chnCicGLRXE5pLPt5czKt0mcPsx4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;/p&gt;&lt;h2&gt;业务影响&lt;/h2&gt;&lt;p&gt;Dubbo如果连接不上ZK，其调用元信息会一直缓存着，所以并不会对请求调用造成实际影响。麻烦的是，如果在ZK拒绝服务期间，应用无法重启或者发布，一旦遇到紧急事件而重启(发布)不能，就会造成比较重大的影响。&lt;br/&gt;好在我们为了高可用，做了对等机房建设，所以非常淡定的将流量切到B机房，&lt;br/&gt;&lt;img data-ratio=&quot;0.5392441860465116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er04xonZeWUwegNic2KQHH3jJJGgoz1ltQRxY86ajADNBCYdaAqUd5WU5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1376&quot;/&gt;&lt;br/&gt;双机房建设就是好啊,一键切换！&lt;br/&gt;切换过后就可以有充裕的时间来恢复A机房的集群了。在紧张恢复的同时，笔者也开始了分析工作。&lt;/p&gt;&lt;h2&gt;日志表现&lt;/h2&gt;&lt;p&gt;首先，查看日志，期间有大量的client连接报错，自然是直接过滤掉，以免干扰。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;cat zookeeper.out | grep -v &#x27;client xxx&#x27; | &amp;gt; /tmp/1.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先看到的是下面这样的日志:&lt;/p&gt;&lt;h3&gt;ZK-A机器日志&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Zk-A机器:&lt;br/&gt;2021-06-16 03:32:35 ... New election. My id=3&lt;br/&gt;2021-06-16 03:32:46 ... QuoeumPeer] LEADING  // 注意，这里选主成功&lt;br/&gt;2021-06-16 03:32:46 ... QuoeumPeer] LEADING - LEADER ELECTION TOOK - 7878&#x27;&lt;br/&gt;2021-06-16 03:32:48 ... QuoeumPeer] Reading snapshot /xxx/snapshot.xxx&lt;br/&gt;2021-06-16 03:32:54 ... QuoeumPeer] Snahotting xxx to /xxx/snapshot.xxx&lt;br/&gt;2021-06-16 03:33:08 ... Follower sid ZK-B.IP&lt;br/&gt;2021-06-16 03:33:08 ... Unexpected exception causing shutdown while sock still open&lt;br/&gt;java.io.EOFException &lt;br/&gt;    at java.io.DataInputStream.readInt&lt;br/&gt;    ......&lt;br/&gt;    at quorum.LearnerHandler.run&lt;br/&gt;2021-06-16 03:33:08 ******* GOODBYE ZK-B.IP *******&lt;br/&gt;2021-06-16 03:33:27 Shutting down&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段日志看上去像选主成功了，但是和其它机器的通信出问题了，导致Shutdown然后重新选举。&lt;/p&gt;&lt;h2&gt;ZK-B机器日志&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;2021-06-16 03:32:48 New election. My id=2&lt;br/&gt;2021-06-16 03:32:48 QuoeumPeer] FOLLOWING&lt;br/&gt;2021-06-16 03:32:48 QuoeumPeer] FOLLOWING - LEADER ELECTION TOOK - 222&lt;br/&gt;2021-06-16 03:33:08.833 QuoeumPeer] Exception when following the leader&lt;br/&gt;java.net.SocketTimeoutException: Read time out&lt;br/&gt;    at java.net.SocketInputStream.socketRead0&lt;br/&gt;    ......&lt;br/&gt;    at org.apache.zookeeper.server.quorum.Follower.followLeader&lt;br/&gt;2021-06-16 03:33:08.380 Shutting down&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段日志也表明选主成功了，而且自己是Following状态，只不过Leader迟迟不返回，导致超时进而Shutdown&lt;/p&gt;&lt;h2&gt;时序图&lt;/h2&gt;&lt;p&gt;&lt;span&gt;笔者&lt;/span&gt;将&lt;span&gt;上面的日志画成时序图，以便分析:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5727513227513228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0YyjZOzPPZ1H1iatv0dJIWewJmt33kt7bSrMMhiciasLBtdsniaq8HpACSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;从ZK-B的日志可以看出，其在成为follower之后，一直等待leader，直到Read time out。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;从ZK-A的日志可以看出,其在成为LEADING后，在33:08,803才收到Follower也就是ZK-B发出的包。&lt;/span&gt;&lt;span&gt;而这时，ZK-B已经在33:08,301的时候Read timed out了。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;首先分析follower(ZK-B)的情况&lt;/h3&gt;&lt;p&gt;我们知道其在03:32:48成为follower,然后在03:33:08出错Read time out，其间正好是20s。于是笔者先从Zookeeper源码中找下其设置Read time out是多长时间。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Learner&lt;br/&gt;protected void connectToLeader(InetSocketAddress addr) {&lt;br/&gt;    ......&lt;br/&gt;    sock = new Socket()&lt;br/&gt;    // self.tockTime 2000 self.initLimit 10&lt;br/&gt;    sock.setSoTimeout(self.tickTime * self.initLimit);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其Read time out是按照zoo.cfg中的配置项而设置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tickTime=2000 self.tickTime&lt;br/&gt;initLimit=10 self.initLimit&lt;br/&gt;syncLimit=5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很明显的，ZK-B在成为follower后，由于某种原因leader在20s后才响应。那么接下来对leader进行分析。&lt;/p&gt;&lt;h3&gt;对leader(ZK-A)进行分析&lt;/h3&gt;&lt;p&gt;首先我们先看下Leader的初始化逻辑:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;quorumPeer&lt;br/&gt;    |-&amp;gt;打印 LEADING&lt;br/&gt;    |-&amp;gt;makeLeader&lt;br/&gt;        |-&amp;gt; new ServerSocket listen and bind &lt;br/&gt;    |-&amp;gt;leader.lead()&lt;br/&gt;        |-&amp;gt;打印 LEADER ELECTION TOOK&lt;br/&gt;        |-&amp;gt;loadData&lt;br/&gt;            |-&amp;gt;loadDataBase &lt;br/&gt;                |-&amp;gt;resore 打印Reading snapshot&lt;br/&gt;            |-&amp;gt;takeSnapshot&lt;br/&gt;                |-&amp;gt;save 打印Snapshotting&lt;br/&gt;            |-&amp;gt;cnxAcceptor 处理请求Accept&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，在我们的ZK启动监听端口到正式处理请求之间，还有Reading Snapshot和Snapshotting(写)动作。从日志可以看出一个花了6s多,一个花了14s多。然后就有20s的处理空档期。如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5708712613784135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0H8iawNnVj63Ic0JWnlB7EMohfSktibyMNic1ZSfa6trDQbLLoxz3rLyPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;br/&gt;由于在socket listen 20s之后才开始处理数据，所以ZK-B建立成功的连接实际还放在tcp的内核全连接队列(backlog)里面，由于在内核看来三次握手是成功的，所以能够正常接收ZK-B发送的follower ZK-B数据。在20s，ZK-A真正处理后，从buffer里面拿出来20s前ZK-B发送的数据，处理完回包的时候，发现ZK-B连接已经断开。&lt;br/&gt;同样的，另一台follower(这时候我们已经把宕机的拉起来了，所以是3台)也是由于此原因gg,而leader迟迟收不到其它机器的响应，认为自己的leader没有达到1/2的票数，而Shutdown重新选举。&lt;/p&gt;&lt;h2&gt;Snapshot耗时&lt;/h2&gt;&lt;p&gt;那么是什么导致Snapshotting读写这么耗时呢？笔者查看了下Snapshot文件大小,有将近一个G左右。&lt;/p&gt;&lt;h2&gt;调大initLimit&lt;/h2&gt;&lt;p&gt;针对这种情况，其实我们只要调大initLimit，应该就可以越过这道坎。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;zoo.cfg&lt;br/&gt;tickTime=2000 // 这个不要动，因为和ZK心跳机制有关&lt;br/&gt;initLimit=100 // 直接调成100,200s!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;这么巧就20s么？&lt;/h2&gt;&lt;p&gt;&lt;span&gt;难道就这么巧，每次选举流程都刚好卡在20s不过？反复选举了好多次，应该有一次要&amp;lt;20s成功&lt;/span&gt;吧&lt;span&gt;，不然运气也太差了。&lt;/span&gt;&lt;span&gt;如果是每次需要处理Snapshot 30s也就算了，但这个20s太接近极限值了，是否还有其它因素导致选&lt;/span&gt;主&lt;span&gt;不成功？&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;第二种情况&lt;/h2&gt;&lt;p&gt;于是笔者翻了下日志，还真有！这次leader这边处理Snapshot快了，但是follower又拉跨了!日志如下:&lt;/p&gt;&lt;h3&gt;leader(ZK-A)第二种情况&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;2021-06-16 03:38:03 New election. My id= 3&lt;br/&gt;2021-06-16 03:38:22 QuorumPeer] LEADING&lt;br/&gt;2021-06-16 03:38:22 QuorumPeer] LEADING - LEADER ELECTION TOOK 25703&lt;br/&gt;2021-06-16 03:38:22 QuorumPeer] Reading snapshot&lt;br/&gt;2021-06-16 03:38:29 QuorumPeer] Snapshotting&lt;br/&gt;2021-06-16 03:38:42 LearnerHandler] Follower sid 1&lt;br/&gt;2021-06-16 03:38:42 LearnerHandler] Follower sid 3&lt;br/&gt;2021-06-16 03:38:42 LearnerHandler] Sending DIFF&lt;br/&gt;2021-06-16 03:38:42 LearnerHandler] Sending DIFF&lt;br/&gt;2021-06-16 03:38:54 LearnerHandler] Have quorum of supporters&lt;br/&gt;2021-06-16 03:38:55 client attempting to establsh new session 到这开始接收client请求了&lt;br/&gt;......&lt;br/&gt;2021-06-16 03:38:58 Shutdown callsed&lt;br/&gt;java.lang.Exception: shutdown Leader! reason: Only 1 followers,need 1&lt;br/&gt;    at org.apache.zookeeper.server.quorum.Leader.shutdown&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从日志中我们可以看到选举是成功了的，毕竟处理Snapshot只处理了13s(可能是pagecache的原因处理变快)。其它两个follower顺利连接，同时给他们发送DIFF包，但是情况没好多久，又爆了一个follower不够的报错，这里的报错信息比较迷惑。&lt;br/&gt;我们看下代码:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Leader.lead&lt;br/&gt;void lead() {&lt;br/&gt;    while(true){&lt;br/&gt;                 Thread.sleep(self.tickTime/2);&lt;br/&gt;                 ......&lt;br/&gt;                 syncedSet.add(self.getId())&lt;br/&gt;                 for(LearnerHandler f:getLearners()){&lt;br/&gt;                     if(f.synced() &amp;amp;&amp;amp; f.getLearnerType()==LearnerType.PARTICIPANT){&lt;br/&gt;                         syncedSet.add(f.getSid());&lt;br/&gt;                     }&lt;br/&gt;                     f.ping();&lt;br/&gt;                 }&lt;br/&gt;                  // syncedSet只有1个也就是自身，不符合&amp;gt;1/2的条件，报错并跳出&lt;br/&gt;                if (!tickSkip &amp;amp;&amp;amp; !self.getQuorumVerifier().containsQuorum(syncedSet)) {&lt;br/&gt;                    shutdown(&quot;Only&quot; + syncedSet.size() + &quot; followers, need&quot; + (self.getVotingView().size()/2));&lt;br/&gt;                    return;&lt;br/&gt;              } &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;报错的实质就是和leader同步的syncedSet小于固定的1/2集群，所以shutdown了。同时在代码里面我们又可以看到syncedSet的判定是通过learnerHander.synced()来决定。我们继续看下代码:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;LearnerHandler&lt;br/&gt;    public boolean synced(){&lt;br/&gt;        // 这边isAlive是线程的isAlive&lt;br/&gt;        return isAlive() &amp;amp;&amp;amp; tickOfLastAck &amp;gt;= leader.self.tick - leader.self.syncLimit;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很明显的，follower和leader的同步时间超过了leader.self.syncLimit也就是5 * 2 = 10s&lt;/p&gt;&lt;pre&gt;&lt;code&gt;zoo.cfg&lt;br/&gt;tickTime = 2000&lt;br/&gt;syncLimit = 5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么我们的tick是怎么更新的呢,答案是在follower响应UPTODATE包,也就是已经和leader同步后，follower每个包过来就更新一次，在此之前并不更新。&lt;br/&gt;&lt;img data-ratio=&quot;0.4602346805736636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0tttT7icMDVASzFJWML5XkY093c94IgvFkt8b1QaibWQMDGRlEbVIzbOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;br/&gt;进一步推理，也就是我们的follower处理leader的包超过了10s，导致tick未及时更新，进而syncedSet小于数量，导致leader shutdown。&lt;br/&gt;&lt;img data-ratio=&quot;0.49027777777777776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0yhedbofHiaNsJib1Lg7ePTiboiaO03k5AC5SpfOpMo2AgnL6E9kvtR5mWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;h3&gt;follower(ZK-B)第二种情况&lt;/h3&gt;&lt;p&gt;带着这个结论，笔者去翻了follower(ZK-B)的日志(注:ZK-C也是如此)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2021-06-16 03:38:24 New election. My id = 3&lt;br/&gt;2021-06-16 03:38:24 FOLLOWING&lt;br/&gt;2021-06-16 03:38:24 FOLLOWING - LEADER ELECTION TOOK - 8004&lt;br/&gt;2021-06-16 03:38:42 Getting a diff from the leader&lt;br/&gt;2021-06-16 03:38:42 Snapshotting&lt;br/&gt;2021-06-16 03:38:57 Snapshotting&lt;br/&gt;2021-06-16 03:39:12 Got zxid xxx&lt;br/&gt;2021-06-16 03:39:12 Exception when following the leader&lt;br/&gt;java.net.SocketException: Broken pipe&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;又是Snapshot,这次我们可以看到每次Snapshot会花15s左右，远超了syncLimit。&lt;br/&gt;从源码中我们可以得知，每次Snapshot之后都会立马writePacket(即响应)，但是第一次回包有由于不是处理的UPTODATE包,所以并不会更新Leader端对应的tick:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;learner:&lt;br/&gt;proteced void syncWithLeader(...){&lt;br/&gt;outerloop:&lt;br/&gt;    while(self.isRunning()){&lt;br/&gt;        readPacket(qp);&lt;br/&gt;        switch(qp.getType()){&lt;br/&gt;            case Leader.UPTODATE&lt;br/&gt;            if(!snapshotTaken){&lt;br/&gt;                zk.takeSnapshot();&lt;br/&gt;                ......&lt;br/&gt;            }&lt;br/&gt;            break outerloop;&lt;br/&gt;        }&lt;br/&gt;        case Leader.NEWLEADER:&lt;br/&gt;            zk.takeSnapshot();&lt;br/&gt;            ......&lt;br/&gt;            writePacket(......) // leader收到后会更新tick&lt;br/&gt;            break;&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;    writePacket(ack,True); // leader收到后会更新tick&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，ZK-B的日志里面表明会两次Snapshotting。至于为什么两次，应该是一个微妙的Bug,(在3.4.5的官方注释里面做了fix,但看日志依旧打了两次)，笔者并没有深究。好了，整个时序图就如下所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.6382393397524071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er0JdoibkzrcpBvl1GH9RCIqtbDdlZepmmFBZ4N3Vdr2KSU8oWebetd7Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1454&quot;/&gt;&lt;br/&gt;好了，第二种情况也gg了。这一次时间就不是刚刚好出在边缘了，得将近30s才能Okay, 而synedSet只有10s(2*5)。ZK集群就在这两种情况中反复选举，直到人工介入。&lt;/p&gt;&lt;h2&gt;调大syncLimit&lt;/h2&gt;&lt;p&gt;针对这种情况，其实我们只要调大syncLimit，应该就可以越过这道坎。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;zoo.cfg&lt;br/&gt;tickTime=2000 // 这个不要动，因为和ZK心跳机制有关&lt;br/&gt;syncLimit=50  // 直接调成50,100s!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;线下复现&lt;/h2&gt;&lt;p&gt;当然了，有了分析还是不够的。我们还需要通过测试去复现并验证我们的结论。我们在线下构造了一个1024G Snapshot的ZookKeeper进行测试，在initLimit=10以及syncLimit=5的情况下确实和线上出现一模一样的那两种现象。在笔者将参数调整后:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;zoo.cfg&lt;br/&gt;tickTime=2000&lt;br/&gt;initLimit=100 // 200s&lt;br/&gt;syncLimit=50  // 100s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Zookeeper集群终于正常了。&lt;/p&gt;&lt;h2&gt;线下用新版本3.4.13尝试复现&lt;/h2&gt;&lt;p&gt;我们在线下还用比较新的版本3.4.13尝试复现，发现Zookeeper在不调整参数的情况下，很快的就选主成功并正常提供服务了。笔者翻了翻源码，发现其直接在Leader.lead()阶段和SyncWithLeader阶段(如果是用Diff的话)将takeSnapshot去掉了。这也就避免了处理snapshot时间过长导致无法提供服务的现象。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Zookeeper 3.4.13&lt;br/&gt;&lt;br/&gt;ZookeeperServer.java&lt;br/&gt;public void loadData(){&lt;br/&gt;    ...&lt;br/&gt;    // takeSnapshot() 删掉了最后一行的takeSnapshot&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;learner.java&lt;br/&gt;protected void syncWithLeader(...){&lt;br/&gt;    boolean snapshotNeeded=true&lt;br/&gt;    if(qp.getType() == Leader.DIFF){&lt;br/&gt;        ......&lt;br/&gt;        snapshotNeeded = false&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;    if(snapshotNeeded){&lt;br/&gt;        zk.takeSnapshot();&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还是升级到高版本靠谱呀，这个版本的代码顺带把那个迷惑性的日志也改了！&lt;/p&gt;&lt;h2&gt;为何Dubbo-ZK有那么多的数据&lt;/h2&gt;&lt;p&gt;最后的问题就是一个dubbo相关的ZK为什么有那么多数据了!笔者利用ZK使用的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;org.apache.zookeeper.server.SnapshotFormatter&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;工具dump出来并用shell(awk|unique)聚合了一把，发现dubbo的数据只占了其中的1/4。&lt;br/&gt;有1/2是Solar的Zookeeper(已经迁移掉，遗留在上面的)。还有1/4是由于某个系统的分布式锁Bug不停的写入进去并且不删除的(已让他们修改)。所以将dubbo-zk和其它ZK数据分离是多么的重要！随便滥用就有可能导致重大事件！&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;Zookeeper作为重要的元数据管理系统，其无法提供服务有可能会带来不可估量的影响。感谢双机房建设让我们有充足的时间和轻松的心态处理此问题。另外，虽然ZK选举虽然复杂，但是只要沉下心来慢慢分析，总归能够发现蛛丝马迹，进而找到突破口!&lt;br/&gt;&lt;img data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSh5ibqDTrYjnj6t1bAh5er05T5Z09juxXFSzp0icvzQ4vMtgDCe7dtt9oefZX3Aa5eEqpKhEwvGUUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>