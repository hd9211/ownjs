<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f2acaf33a28050099821a8fe9f60491d</guid>
<title>工具 | 滴滴开源的，高性能高可用的跨端开发框架</title>
<link>https://toutiao.io/k/afb7a01</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1529&quot; data-ratio=&quot;1.9226666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicDGyUHukUCpLTzqjcCnRkd4oyd0Aic0FOFZHqN8r3NcLbpJLxxI1PmbDUBux9j8O3OUL1nV0D22Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 37 周啦！感谢亲们的大力支持！第 037 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊 VIP 新年特惠&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」&lt;br/&gt;只限 VIP 会员加入的交流圈子&lt;br/&gt;大厂「内推机会」&lt;br/&gt;N 多福利，你值得拥有！&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;CTO 们邀请你加入码农周刊 VIP，升职加薪不再难！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;31&quot; data-cropselx2=&quot;291&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav9LRTqibic3sUoh5tv76OXCpNTWbZ0gCYsFDShjwfRVvM157WDel2cr2dy5ghjxDCCwRc2Mu8bgehnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bcfe1691f96dc402d49e615902401123</guid>
<title>我在拼多多的三年</title>
<link>https://toutiao.io/k/jkvyo8g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;p&gt;表明身份1，没必要匿名了，根据拼多多的能力，稍微匹配一下时间段，想找到谁发帖非常容易。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;表明身份2，楼主2013年入学2017年毕业，曾在cc98非常活跃，毕业后渐渐远离。2018年6月18日社招入职拼多多，工作2.5年，特地R回来cc98讲讲关于拼多多这三年的变化，总结一下，就是越来越差，希望学弟学妹们千万不要去。另外本人已离职，未收到离职证明和全年的加班费，HR承诺4-7天内寄出，本周三是第八天，如果还没有收到离职证明或者快递单号的话，楼主会来更新《如何不体面地从拼多多离职》【2021年01月13日12:33:40，已收到离职证明一份。】，离职比日常更刺激哦。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;插曲，编写本文的过程中，1月11日，某拼多多员工在校友群劝退学弟学妹，已经被开除了，还好我已经离职了，不能给公司开除我的机会。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;声明立场，楼主对拼多多不满已经很久很久了，并不是墙倒众人推才来发帖，楼主在2020年12月9日递交了辞职通知，本来想着安安静静满30天走人，写个总结。结果从2021年1月1日到现在，该公司一直整活，导致我都没空来写文了，今天能发出来也是加班加点。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;拼多多，2018环境正常，2019环境变差，2020环境很差，2021已黑化，已离职；想直接看重点的从2019开始看。&lt;/p&gt;
&lt;h1&gt;# 2018&lt;/h1&gt;
&lt;p&gt;总体来说，2018年的拼多多还是挺好的，我待的挺开心。&lt;/p&gt;
&lt;h3&gt;### 入职&lt;/h3&gt;
&lt;p&gt;入职前，轩辕（花名，常用名 flanker）：”我去了一个创业公司，缺人，岗位很适合你，你要不要来，创立者是一些上交和浙大的。”。调查了一下，学弟A也去了，每周上六天班，严格打卡，也不是不能接受吧，在被蚂蚁金服的offer放鸽子之后，就去了pdd。&lt;/p&gt;
&lt;p&gt;2018.6.18 入职，当时技术安全组里只有*个人，看到了主管轩辕（现已离职，有大瓜：拼多多安全主管），相识多年学弟B（实习结束后离职），久仰大名的学长C，一面之缘的D，出现在业内新闻中的学姐E（现已离职），打听了一下还有SRC排行第一的大佬F，以及其他几位优秀的同事。看来我成了全场唯一指定最菜的人，来这里还有很多东西要学，后来发现自己很carry，不菜。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;入职当天的感受：当时办公设施确实挺简陋的，工位很挤，没有员工食堂，吃饭需要使用”美餐”APP进行点餐，按照自己的编号去货架拿，之后带到座位上吃。 基本是饿了就可以吃的，11:30-12:00之间随缘去取餐，虽然取餐室非常小，但还不拥挤，体验普通，但比 zju 的饭还是好一些的。（这里埋下伏笔1，2019 年制度更新）&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;办公室当时是没有座位号的，需要找人时候，只能大概描述自己的位置，非常难受；数月后，行政使用”五大洲”和座位编号，解决了这个棘手的问题，非常好。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;最开始住的”员工宿舍”，说是员工宿舍，其实条件挺一般的。1990年的房子，两室零厅，客厅是一个长条，每个卧室里两张床（我旁边的床位暂空），没有别的设备了。另外两个室友人挺好的，一位室友办理了宽带，还和我一起联机打游戏，虽然下班晚，但挺乐观的，另一位室友在七天后，从拼多多离职，入职了上海的字节跳动。这个屋子可能是我毕业后见过最破的住处了，临街很吵，停留在姑且能住的水平。对短期的实习生来说，还是比较方便的，不适合长期居住。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;15 天后，我和组里的入职不久的G（现已离职）合租，住在办公室对面的、1990年建造的老破小里面，一人一个卧室，在办公室可以看到房间窗户那种，上班 3 分钟。当然这个地方也挺破的，好在室友G很会过日子，指导我活着一起买了遮光窗帘、电热毯、水泵、灯泡，姑且能活下去洗个热水澡，唯一的优点就是离公司近，非常近，拼多多周日需要上班，周六没事干，就去办公室坐着，能使用”美餐”点饭（伏笔2），有网络可以自由使用（伏笔3），和实习生H一起在办公室渡过周六的无聊时光。&lt;/p&gt;
&lt;h3&gt;### 逐渐熟悉&lt;/h3&gt;
&lt;p&gt;慢慢组里的人多了起来，项目也多了起来，其乐融融。由于人少项目多，我从零开始，在 2018 年先后创立和负责了 A、B、C、D、E 等多个项目，并且多次参与公司的安全应急响应，有些工作做得很好，获得优秀绩效，也因为和其他组的开发同事由于意见不合吵架，获得了一次差评的绩效。虽然和2020年一样，每周上六天班，但2018时真的觉得拼多多挺好的，能做很多实事，在安全组，保卫拼多多的服务器、用户安全、商家安全、防止黑客入侵，切实看到成果，这些事情让我很自豪。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;在那时候我在大厅里看到98水友 @xxx 也入职拼多多了，感觉多了一个朋友挺开心的，于是这里就不得不说一下管培生的经历了。水友xxx当时是市场管培生，而我是一个技术，公司对二者的职业安排是完全不一样的。某日，我21-22点下班了，听说水友xxx还在办公到23点，我就惊了，原来校招应届生来了的前半年是当客服的，商家客服23点下班，而且有效率评估和 KPI，有严格的汇报制度，工作内容容易让人精神崩溃，我已经察觉到这个人有些不对劲了，我把我键盘借给她了，减缓痛苦程度。反正我下班也没事干，出于人道主义，有时就送她半夜回去，然后再自己走回去。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;由于在拼多多伙食较好（后来发现是每天吃官方外卖过于油腻），从 110 吃到了 130 斤，于是开始思考减肥，和周围5个同事把头像改成了”不瘦十斤不改头像”，在那时候晚上下班有时间去跑步，有几天是23点之后跑步，现在觉得还好自己没死；后来天气冷了就在室内锻炼，差不多减到了110-120之间。&lt;/p&gt;
&lt;p&gt;除了上六天班之外，好像也没什么想吐槽的，单身时候周末真是闲的蛋疼的。&lt;/p&gt;
&lt;h3&gt;### 11.11值班&lt;/h3&gt;
&lt;p&gt;半年后，双十一来了，第一次经历这个规模的事件，要求技术人员分为三波人，分别值守11.10晚上、11.11早上、11.11晚上，安全组总共也没几个人；由于我住得近，主动给住得远的同学承担了当天晚上。当时还是很兴奋的，一方面自己想要买东西，一方面也想看看到底有没有黑客在双十一时候搞入侵，虽然凌晨才离开，但挺满足的。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;双十一时候，好像连续上了十天班，然后获得两天的休息时间，在这时候，学姐E带我去杭州见闺蜜学妹，后来她的闺蜜成了我的女朋友，在爱情的鼓励下，余下的这几个月，我一直过的很开心，一周上六天班，空闲那天去做高铁去杭州约会，早上走晚上回，一点也感觉不到累。&lt;/p&gt;
&lt;h3&gt;### 全员大会和年会&lt;/h3&gt;
&lt;p&gt;拼多多上市后，听说有商家在楼下拉横幅也没有看到，也有挺多负面言论，但我本身是一个工程师，和我没什么关系。在上市静默期结束后，公司举行了全员大会，展望未来并且鼓励大家。目前我仅记得一句话：黄峥：”有同事的提问，我们什么时候可以双休呢？”（欢呼）”等我们成为中国第二，就可以双休了”（欢呼）。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2021年了，情况好转了吗？没有。。。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;再之后便是年会了，节目中规中矩，吃的挺不错，我做出较多贡献，获得了年度优秀员工，这个 title 的人挺多的，应该是每个组拥有几个名额。听到几个熟悉的名字，感觉评价实至名归。&lt;/p&gt;
&lt;h3&gt;### 不愉快的小插曲&lt;/h3&gt;
&lt;p&gt;细节我实在是不记得了，可能时间点穿插在上文中。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;办公软件是企业QQ，有一个 xxxx 人的大群，名为上海员工群，99%的人都在群里，日常闲聊和吐槽。某日，有银行的人来办理香港银行卡，他们创建并且拉了一个微信群，同事之间相互推荐，可能有100个同事，我也在群里。突然，有HR在微信群里混进来了，请本群立刻解散，于是我被移除群聊。第二天，办公室大群宣布解散，官方给出的解散原因为：”为防止个人信息泄露，解散办公室的企业QQ群”。后来这种事情就很频繁了，包括解散了单身员工交友群（本来也没什么人说话），球类运动群，等。&lt;/p&gt;
&lt;p&gt;这件事我至今都一头雾水，不知道内部办公软件是怎样泄露个人信息的，群里都是员工是如何相互泄露信息的，公司只是随便找个借口解散大群罢了，关上员工的嘴而已。&lt;/p&gt;
&lt;h1&gt;# 2019&lt;/h1&gt;
&lt;p&gt;一切，在那件事之后就变了。。。。。&lt;/p&gt;
&lt;h3&gt;### 100元优惠券事件引发的全员7*24值班&lt;/h3&gt;
&lt;p&gt;2019.1.10 那是个周末，醒来时候女朋友和我说，”你们公司出事了，可以一百元优惠券随便领”。”扯什么呢，骗人的”。”哦，我没领到”。于是我去上班了，到了办公室，女朋友没有唬我，是真的，出大事了，后面也陆陆续续有各种各样的报道，这件事只是个导火索而已。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;这是一个非常大的问题，风控、大盘都有责任，本以为会让每个系统都接风控、全盘核查 API、重构代码等，从技术角度来解决类似问题，但拼多多的操作实在让我惊呆了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;过年后，风控组开始7*24小时值班，每个技术岗必须值班，早班7-19点，晚班19-7点。虽然说不怎么合理，但也算是个临时的办法吧。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;数日后，技术全员开始7*24小时值班，多强调几遍，技术全员！技术全员！技术全员！&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;当晚，我印象非常深刻，主管召集组里 xx 个人，在会议室，气氛沉重，”告诉大家一个坏消息，我们也要全员值班了，具体规则我原文念一下xxxxxx”。所有人非常不情愿，大致规则是：每天两个班次，每个组派出1个人，校招生半年内不值班，女生不值晚班，社招x月内不值班，晚班有额外0.5天加班费，早班可以早下班。由于我们组满足条件的人太太太太少，因此只安排晚班，不安排早班。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;从个人角度评价一下这个制度。首先，我是没有线上业务的，有线上业务的人也就那么几个，总不能让人家每天24h在线吧；然后，我没有任何权限去处理其他人的业务；再次，别人的业务挂了，我也不知道如何恢复它；最后我得到结论，我的责任就是看报障信息，谁的服务挂了就把他打电话叫醒来。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;晚班是19点到7点，按照官方解释，需要在办公室通宵，允许不干活儿，允许玩手机，允许放下手头任务专心收报警邮件，但由于体谅员工，允许员工凌晨1点下班打卡，会房间里继续值班。结合我多次值班的经历，中间就是祈祷千万千万别出锅，让我睡个安稳觉。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;分享一下第一次值班时候的回忆：19:00 签到，继续搬砖，继续搬砖，没人了，玩手机，01:00了，下班打卡，在床上玩手机，玩手机，玩手机；03:00睡觉，偶尔醒来看一下消息；07:00起床，签退。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;基本是一晚上没睡觉，换来0.5倍工资，整个过程非常枯燥无聊，纯属就是在折腾人；在看破这个本质后，出于对健康的考虑，一方面把值班交给需要的人（比如夜猫子，非贬义），一方面真给不出去，就划划水渡过，基本都是平安夜。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;最开始我还存有侥幸心理，认为这个值班持续几个月发现没有效果，就可以结束了。现在 2021 年了，我的视角里值班制度至今没有任何效果，这个制度甚至成为了默认的制度，但我无法找到明文的制度规定，最早的保护体系也不存在了，女生也值晚班，刚入职的社招也值晚班，这里我狠狠踩一脚，做决策的人就是没脑子。&lt;/p&gt;
&lt;h3&gt;### 搬工位与人满为患&lt;/h3&gt;
&lt;p&gt;由于招的人越来越多，原先的工位不够用了就必须整个组都搬走，从入职到离职，我已经搬了大约8次工位了。三个月一小搬，六个月一大搬，最开始确实是因为人数问题，后来发现这个是拼多多的传统，就是折腾人而已，频繁的搬工位只能说明行政水平差，不会提前规划。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;然后就会遇到厕所问题，例如知名的”屎”厂新闻，所有人都在骂的事情，我就不展开说了，这么多年了没有任何改进。&lt;/p&gt;
&lt;h3&gt;### 消除伏笔&lt;/h3&gt;
&lt;p&gt;上文提到 2018 年一些较好的制度，在 2019 年都不复存在，公司在更强烈地约束员工。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔1：宽松的吃饭时间被取消，像喂猪一样卡点进食&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019 年的某日，可能是因为侦测到部分员工21:30去吃夜宵，突然来了一条规定，说禁止12/18/22点之前到取餐室。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;原先的制度：9-10点早饭，12点午饭，18点晚饭，（可以早点去拿，早点吃完早点干活儿）。周二周四22:00夜宵。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;优化后的制度：时间点不变，禁止提前去吃饭。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;我个人作息是9:30到办公室，吃早饭，午饭不饿，点一份水果下午吃并且减肥（埋下伏笔4），17:00开始饿，差不多就去吃晚饭，由于取餐是随机的，取餐室虽然小但是不拥挤。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;这个新政策一来，11:59:59，门口排队一条龙，工作人员掐着表，不让你进去，一到点，所有人都哗啦啦跑去排队，开始进食！如果去晚了，没个5分钟排队是领不到饭的。其实呢，送餐的11:30就差不多送完了，饭都凉了，就是卡着不让你吃，你气不气，你气不气？？？&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;监管不严时，这个制度会放松，例如11:59:30就可以进去了，但经常会收紧，举个例子。例1：有专员看着，说没到呢，不能拿，主管批评。例2：供应商说，不能提早给你，提早给你要扣我们钱的。前者是公司的走狗，后者只是公司克扣人家钱罢了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;我愿称这个政策为喂猪政策，据我所知，只有喂猪才卡这么严格的时间，早一秒都不行。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔2：美餐的水果被移除，美餐的甜点被移除。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;原先的制度：点餐供应商丰富，午餐、晚餐可以点水果，晚餐可以点甜点。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;某日，由于有些员工住得近，周六中午点一份水果，到办公室带走，回家吃。对此，我提出批评，这个员工做的不对。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;有意思的来了，由于周六中午有不本分的员工来白嫖水果，公司决定取消每天的水果供应。我这个减肥的人表示非常苦恼，9:30吃早饭，午饭完全吃不下，只能象征性地点一份主食，对此我只想骂人。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔3：从某天起，办公网禁止访问某些网站。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;其实我是支持这个制度的，办公时间禁止刷视频，防止员工划水，也算正常。但坑爹的在于，这个网络屏蔽范围很迷，存在不合理的范围，举例：微软更新，微软商店，IntellijIdea官网，手机应用商店，华为login（无法理解），苹果更新推送（后解除），AppleStore（后解除）。一开始和管理员说一下就可以把误封的网站加白，后来不行了，要走流程，让主管审批，我就直接连热点了进行测试了（伏笔5)。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;再讲个笑话，某日大老板的某个APP无法访问，于是大赦天下，把该网站加白了；但我访问某些编程站点，确实是正规正当的请求，被拦截了，向IT提出意见，但是IT说不行，可能因为我不是大老板，是是是，他们说啥就是啥吧。&lt;/p&gt;
&lt;h3&gt;### 公司的消息流通&lt;/h3&gt;
&lt;p&gt;例如上文的三个伏笔，都是没有官方通知的，由高层转给主管，主管在群里，粘贴一下高层的意见，员工才能知道。如果这个公告容易引起舆论，公司会选择口口相传，最后让员工慢慢知道。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;官方一般只通知两件事，一是有员工被开除，二是下一个假期克扣几天假期。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;讲个笑话，公司内部发生的事情内部是没有任何公告的，员工获取公告的渠道是相互打听，去脉脉社区里闲逛，非常讽刺，称之为出口转内销。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;上文提到解散了QQ大群和部分民间微信群，终于有一天，公司变本加厉，大约是2019年6月，有用hr的微信群统统被解散，部门微信群也被责令解散，慢慢民间的微信群就消失殆尽，只有非常熟悉的几个人为了说话方便才会有微信群，一旦被hr发现，就会勒令解散，毫无人权。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;堵上员工的嘴，捂住员工的耳朵，一心搬砖领工资，这就是本分的奥义吧。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;顺带再提一下，由于长期缺乏文档和搜索功能，做什么事情基本都是靠问，技术方面举例：公司的xxx如何配置，xxx无法打日志怎么办；非技术方面举例，员工手册是什么，7*24值班的规章在哪，本分指的是什么，本分是口袋罪吗。&lt;/p&gt;
&lt;h3&gt;### 经典事件1：查监控确认考勤&lt;/h3&gt;
&lt;p&gt;拼多多上班和下班都是需要打卡的，分别是11点前20点后。举例，我10点到公司开始办公，我可以使用开机记录、浏览器记录、git记录、聊天记录等来证明自己确实来过，主管承认即可。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;某日，据传有员工替旁边员工开机的行为，高层大怒，决定以后补卡都需要HR查监控来执行，不再认可一切证明。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;当时我还是挺心疼HR的，屁大点事情都要他们来调监控。一年后，逐渐出现奇葩操作，补卡需要提供一份候选人的简历，补卡和主管绩效挂钩，主管开始强调大家上班一定要打卡。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;公司是非常不信任员工的，一切都会朝着坏的方向去思考。&lt;/p&gt;
&lt;h3&gt;### 经典事件2：周六值班旷班被集体开除&lt;/h3&gt;
&lt;p&gt;某个周六，一些不本分的员工值白班，7-19点，午饭期间溜出去，过了几个小时还没回来。几天后，查出后全部全员公告并且开除。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;员工确实做错了，但罪不至死，因为之前被开除的只有一类人，收受贿赂的运营，这是第一次技术公开被开除的事件。&lt;/p&gt;
&lt;h3&gt;### 经典事件3：查员工手机，并开除一位在脉脉发帖质疑空气质量的学弟&lt;/h3&gt;
&lt;h3&gt;### 经典事件4：变本加厉的值班&lt;/h3&gt;
&lt;p&gt;拼多多有四次大促，分别在 618、1010、1111、1212，本以为和 18 年的一样，但我还是太天真了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;这次要求，技术全员值班，所有人都需要值班到凌晨一点，第二天早班的人除外。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;对了，这个值班是公益的、无偿的，连续两个晚上凌晨下班，通俗来讲，就是白嫖。由于我做底层支持，没有线上业务，无论呆到几点都没有任何帮助，不少人也是设个现象，但没有办法，命令就得执行。凌晨一点，电梯挤得就跟爆炸一样，xxxx 人，6 部电梯，等真正到楼下，已经凌晨1:30了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;哦对了，如果大促在周一，公司会要求周末两天也要上班，也就是最多可以连上 13 天班，即 日一二三四五六日一二三四五，期间还要全员两天凌晨下班，这谁顶得住啊。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;我对公司的这种安排非常不屑，引以为耻。&lt;/p&gt;
&lt;h3&gt;### 经典事件5：公司wiki移除搜索、最近访问等功能&lt;/h3&gt;
&lt;p&gt;wiki是用来存放笔记和share工作内容的一个地方，为了防止信息泄露，官方移除了相关功能。代价就是，切断各个部门、各个业务之间的连接，自己哪天编辑过的文档也不知道放哪了，公司的组件出现问题不知道去哪搜，不知道去找谁，开发全靠问。对新入职的人来说，无疑是巨大的考验，但管理者并不 care 技术的死活，这种事也不是一天两天了。&lt;/p&gt;
&lt;h3&gt;### 经典事件6：公司禁止从事副业&lt;/h3&gt;
&lt;p&gt;某日，公司宣布禁止从事副业，需要诚实报备。按照我的认知，副业指签订劳动或者劳务合同，是不应该的行为，但这又是一个口袋罪，只有”禁止从事副业”这六个字，没有详细解释，这也是很常见的口头通知。为此有一名同事，微信里做微商卖东西被开除。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;分享这个例子，想说明公司的初衷可能是好的，但实行起来不考虑实际情况，没有明文判决，全靠大佬一句话。&lt;/p&gt;
&lt;h3&gt;### 记录日记&lt;/h3&gt;
&lt;p&gt;“正经人谁写日记呢”，确实，我不是正经人，因为我 2019年末 就想辞职了，于是专门开了一个笔记本，记录心态爆炸的瞬间，下文摘自日记。离职总是一瞬间的事，真正忙起来可能就懒得离职了，因此专门记录，防止忘掉伤痛。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年11月&lt;/p&gt;
&lt;p&gt;腱鞘炎，手快断了，去医院，医生说少活动&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年11月&lt;/p&gt;
&lt;p&gt;接到业务，本来我只是提供一些分析和参考，对网络编程完全不懂，现学现卖，补充大量不知道的知识，压力巨大，虽然我最后搞定了，但这样的功能交给专业的人来写，比我现学要好很多。那段时间每天做噩梦，非常难受。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年11-12月&lt;/p&gt;
&lt;p&gt;接到业务的测试需求，不提供账号，不提供手机，让我凭空操作；&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2019年12月&lt;/p&gt;
&lt;p&gt;生病了，基本所有人都生病了一遍，挨个传染，办公室人员太密集了；&lt;/p&gt;
&lt;p&gt;取饭时候排队的人太多了，吃饭会路过感染区，导致大面积感染，状态堪忧；&lt;/p&gt;
&lt;p&gt;生病发烧快死了，至少有女朋友可以照顾我；&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;再早的爷不记得了&lt;/p&gt;
&lt;h3&gt;### 跨年值班&lt;/h3&gt;
&lt;p&gt;说出来感觉又是个笑话，2019年快跨年了而31日是上班的，12月20日左右，作为年轻人我当然要请假出去玩，已经请好假。那么有意思的来了，大约12月25日突然发布消息，31日跨年夜要求全体员工值守在办公室，凌晨一点才下班，没有特殊原因不许请假。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;看到这个消息又一次惊呆了，第一次听说跨年还有大促，而且提前几天才通知，这不是搞人么，于是脉脉就有经典的帖子：”跨年时候整个公司的人都在办公室，大家相亲相爱，就像一个大家庭”，太讽刺了。&lt;/p&gt;
&lt;h3&gt;### 尾声&lt;/h3&gt;
&lt;p&gt;这一年我仍然在认真搬砖，拿到了优秀的绩效，但和上一年相比，我已经不大愿意推荐朋友们来拼多多了，毕竟我自己也想走，没必要带别人来，公司越来越严厉，对待员工越来越差。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;另外2020年初，爆发了疫情，世界都开始重新洗牌，我的离职计划也打乱了。&lt;/p&gt;
&lt;h1&gt;# 2020&lt;/h1&gt;
&lt;p&gt;加速，加速，加速&lt;/p&gt;
&lt;h3&gt;### 春节过后&lt;/h3&gt;
&lt;p&gt;正月初七后，由于大佬们的意见，部门主管们鼓励上海员工回去上班，这个部分懒得讲了，已经被人吐槽烂了，公司公然漠视上海的制度，已经忽视员工的健康和安全了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;上班后，我问湖北来的同事，公司表面上说没上班的日子可以用周末和值班来补，暗示当月工资照常发，据同事说，当月工资已经被扣过了，gtmd，加班的话过年才给，我也懒得加班了，就当自费请假了。&lt;/p&gt;
&lt;h3&gt;### 为什么不离职&lt;/h3&gt;
&lt;p&gt;是想走的，由于2020整年疫情带来很大的不确定性，浑浑噩噩一年也可以这么过去。我个人么，我承认，由于工资涨了，女朋友也不着急，外界环境扑朔迷离，决定再干一段时间再走，这一干，就是一整年了，这一年真是见证各种历史。&lt;/p&gt;
&lt;h3&gt;### 消除伏笔&lt;/h3&gt;
&lt;p&gt;伏笔4：取消美餐&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;可能由于公司非常非常非常喜欢让员工定点进食，早一秒钟都不行。假设员工晚饭点了面包，就可以在外面吃饭，饭后回来带走面包，就绕过了”奴隶”的进食时间。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;按照公司的管理经验，出去吃饭是不本分的行为，毕竟这表示公司的饭不好吃，是大逆不道的行为，于是取消晚饭的甜点，取消周黑鸭。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;并且由于疫情的原因，2020年不再使用美餐作为供应商，原先20+的选择，现在只有4家餐饮可以选择，这个不是重点。重点在于，公司依然执行严格的进食时间，11:59:59后才允许去拿，原先是货架上的物品，现在需要供应商手动发放，效率应该是更低了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;伏笔5：办公室进行手机信号屏蔽&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;连接手机热点，称为自费上网已经持续了好几个月了，一直用的挺好的，办公网只有10M带宽，下载个东西慢的要死。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年8月，突然发现每天一到11点，手机网络剧烈卡顿，接近无法使用的状态。由于需要上网的设备很多，平时测试时我用热点，在那之后，我的工作就受到严重的阻碍。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;一开始我认为是蜂窝网接入者过多，导致网络卡顿无法使用，经过调研发现是区域问题，仅有我所在的工位无法使用流量，其他楼层、其他工区都可以。慢慢的，各个楼层，各个工区也无法使用，越来越多的证据表示是信号干扰，怎么说呢，只能祝拼多多越办越好了呗。&lt;/p&gt;
&lt;h3&gt;### 久病成医&lt;/h3&gt;
&lt;p&gt;公司不喜欢提前发放假通知，一般都是放假前几天才通知，由于我是老本分人了，早已对假期预测了如指掌。例如清明、端午一定会扣一天，国庆一定会扣两天，大促的周末不休息等。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;入职不久的员工经常来问我假期安排，每次我预测得都很准确，我知道公司会克扣假期，甚至连规律都总结出来了，不知道是该不该笑一下。&lt;/p&gt;
&lt;h3&gt;### 记录日记&lt;/h3&gt;
&lt;p&gt;2020至今&lt;/p&gt;
&lt;p&gt;办公室网络常年爆炸，访问外网慢的要死，尤其是 github 和 github-release&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年03月07日&lt;/p&gt;
&lt;p&gt;第N次接到傻逼的需求，大老板缺乏安全感，证明其他大厂APP没有偷拼多多的数据&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年03月07日&lt;/p&gt;
&lt;p&gt;连续 3 天工作时间超 12h，左胳膊肌肉疼&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年03月07日&lt;/p&gt;
&lt;p&gt;巧妇难为无米之炊，开局一张图，无法复现全靠猜，手机也急缺，难&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年05月09日&lt;/p&gt;
&lt;p&gt;wifi又双叒叕改了，瞎屏蔽应用商店，每天认证一次&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年05月11日&lt;/p&gt;
&lt;p&gt;办公司wifi把应用商店、厂商官网给墙了&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年05月11日&lt;/p&gt;
&lt;p&gt;接到傻逼需求，为防止被抹黑，需要对某现象进行技术上的解释，就这一件小事还非常着急，跟线上故障似的&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年08月17日&lt;/p&gt;
&lt;p&gt;每到中午网络就巨差，今天4G 直接断网了，艹&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年08月25日&lt;/p&gt;
&lt;p&gt;是真的信号干扰断网，迷，只能离线办公&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年09月01日&lt;/p&gt;
&lt;p&gt;gitlab 的 readme.md 改为不展示，文档不公开，严重影响工作效率，不知道哪个脑残想出来的&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年12月10日&lt;/p&gt;
&lt;p&gt;办公室也太吵了，隔壁就跟网吧开黑一样，神经衰弱无法上班，耳塞和降噪耳机也无法解决问题，还好我要离职了&lt;/p&gt;
&lt;h3&gt;### 公众事件&lt;/h3&gt;
&lt;p&gt;2020年我对拼多多感情急速下降，其实和公众的认知是一致的，无非以下几个事件&lt;/p&gt;
&lt;p&gt;1、大楼禁止员工穿拖鞋，被保安锁喉并且轻伤，公司未做任何声明；&lt;/p&gt;
&lt;p&gt;2、由于没有坑位，情急之下在男士便池里大便，公司未做任何声明；&lt;/p&gt;
&lt;p&gt;3、网传公司使用刁钻的计算方式，给离职员工发放0.3倍的周日加班费（正常结算是1.0倍，劳动法规定是2.0倍）；&lt;/p&gt;
&lt;p&gt;4、黄峥公开表示硬核奋斗模式，非技术员工被抽调去多多买菜，全年无休，租房中介都和我说你们公司最近走了好多人；&lt;/p&gt;
&lt;p&gt;5、略，其实公众都知道的。&lt;/p&gt;
&lt;h3&gt;### 又一次校招&lt;/h3&gt;
&lt;p&gt;校招季来了。好消息和坏消息，好消息是今年校招生的水平比去年强很多了；坏消息呢，公司最近出了很多负面事件，学生也会来问评价和看法，说实话我挺难受的。&lt;/p&gt;
&lt;h3&gt;### 丧心病狂的通宵值班&lt;/h3&gt;
&lt;p&gt;由于2019年的618、1010、1111、1212、跨年被安排了，我对即将发生的一切骚操作都不再感到意外，最经典的是十二月。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;双十二大促，员工需要连续上班 13 天，并且12.11、12.12需要全员加班到凌晨一点，然后12.31再次全员加班到凌晨一点。因为我已经提交离职了，没有必要再为公司卖命，这三天依然是没有额外工资的，说白了就是全员白嫖哈，你只是个机器人，服从命令就可以了。&lt;/p&gt;
&lt;h3&gt;### 提出辞职&lt;/h3&gt;
&lt;p&gt;女朋友和我异地快两年了，一直这样也不是个办法，反正我也厌恶公司的行为，混一混个年终奖就走吧。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;2020年12月9日，我无法忍受公司的文化和制度，flanker也走了，没什么好留恋的了，我自己也有家庭原因，决定离开这个鬼地方，网传公司有卡离职的操作，当天写了辞职信并且ems。这里打住，我将可能会有更精彩的第二篇文章《如何不体面地从拼多多离职》。&lt;/p&gt;
&lt;h3&gt;### 何为本分&lt;/h3&gt;
&lt;p&gt;本来以为2021年1月10日就可以悄无声息地离开了，不料2021年更精彩，就不用我多说了吧，猝死、跳楼、看到救护车被开除、围观开除被开除。。。至此，拼多多在我心中已完全黑化，没有一丝人性了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;因为我只在腾讯和拼多多工作过，这里我要表扬一下腾讯，最开始的校招培训挺多是关于历史和价值观的，往坏了说是洗脑，至今我还记得是合作、正直、创新、进取。以前我总认为价值观这个东西没什么用，现在觉得腾讯价值观还是正确的，我在离开拼多多时思考，本分到底是什么，我粗浅地谈一下我的理解，不代表官方解释，期待有一天官方能有个解释。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;强调员工遵守公司的一切安排，无论安排合理与否；强调不做任何与公司无关的事，即使是在休息时间；强调你就是公司的一个包身工，一个雇佣兵，一个人肉电池，让你做什么你就做什么。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;拼多多是没有灵魂的，本分二字早已变味了，成为奴役员工的工具，私下调侃，例如”今天早上你本分了吗”指”今天11:00你打卡了吗”，”中午要去本分吗”指”中午在办公室吃还是去外面吃”，”今天晚上我不本分了”指”今天晚上我不加班，要早点跑了”，”你这个人不本分”指”你在发表反动言论了”，”这周日我不来本分了”指”这周日老子不来加班了”,”我以后永远都不本分了”指”我要离职了”。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;引用某位同事的反动言论：”在拼多多，除了给钱之外，其他事别多嘴，发生任何事情都不要意外”，颇有一种2077夜之城的感觉。&lt;/p&gt;
&lt;h1&gt;# 结语&lt;/h1&gt;
&lt;p&gt;劝学弟学妹不要来并不是因为加班严重，而是这个地方没有把你当做一个人，我自认为员工是一个电池、奴隶、包身工，这个地方是血汗工厂、监狱、集中营。拼多多给钱的确实比其他公司要多，如果家境普通当下缺钱的话可以来卖命，否则还是另寻他处吧。我并没有后悔加入拼多多，每个时代都有其局限性，2018年的拼多多还不是现在的拼多多，当时对我来说是最好的选择了，如果是2020年找工作，我是绝对不会考虑这个地方的。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;花了两天时间写完了我三年的回忆录，现在看着其实第一年的回忆最多，大部分都是美好的；后两年虽然痛苦，但能想起来的好像也就这么多，我认为是加班实在太严重了，无法思考我到底讨厌什么东西，还好有个日记做记录。还有其他不满是关于工作的，动不动就是”这是来自 叮当（CTO）、阿布（COO） 的紧急需求”，”这个方案不合理，但是是阿布说的”，出于保密我不能说太多，现在看看，后两年更多是流水账吧，没什么要害，只是一个一线员工的感受而已。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;后两年有多忙呢，举个例子，我平时购物都是女朋友负责的，身边大大小小的事情都由她来分担，甚至买房也是她负责，因为我太忙了无法考虑这些事情，我真的非常感谢她也非常爱她，在我离开拼多多后，终于有时间陪伴她了。&lt;/p&gt;
&lt;p/&gt;
&lt;p&gt;最后把2020年的打卡记录分享一下吧，我的工时不算长，一切尽在不言中。&lt;/p&gt;
&lt;p/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2d89cbc99b4f6d5d0056e55bfaba90bc</guid>
<title>数据全景洞察概念简介</title>
<link>https://toutiao.io/k/0t26f76</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、全景洞察简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、行业背景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;智能数字时代，数据不论形态、格式和类型，已经迅速成为企业最有战略意义的资产；数据资产已经成为了可以形成业务洞察及优势的战略资源，数据的体量、多样性和复杂性也正以指数级增长。就像其他重要的企业资产，数据需要适当的管理和治理水平,以确保它的潜在价值得到认识和发挥作用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、基础概念&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DMP数据管理平台是DataManagementPlatform简称，是把分散的多方数据进行整合纳入统一的技术平台，并对这些数据进行标准化建模和细致分析，让用户可以把这些细分结果推向现有的互动营销环境里的平台。核心作用如下：可以对统一对数据快速查询、圈选符合条件的人群，生成特定场景对数据分析报告；可以基于此结果帮助客户快进入到市场周期中，并且可以对数据对洞察分析，对市场预测并作出反应，可以提升企业各方面的竞争优势，降低信息获取、运营、人力等各项成本。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、核心因素&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;围绕实体-关系-标签这三个元素进行建模，从业务的角度出发对数据进行组织管理，以概念模型的形态透出，形成数据的画像报告，让人人都能看得懂。业务数据长期运营形成以标签为中心的智能数据体系，激活数据资产，实现数据资产的变现。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、产生作用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;精准营销投放：针对产品进行人群透视，挖掘潜在客，熟悉潜客偏好；产品研发：分析目标人群的行为特征，找到相关品类及产品特征，给新品带来数据参考；市场分析：掌握竞争趋势和差异，对于制定市场计划提供指引。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、核心概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、标签工厂&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标签管理是一件非常复杂的事情，数据基于准确的标签才会发挥出最大的价值。这里涉及到标签模型、更新&lt;/span&gt;迭代&lt;span&gt;、标签资源、标签云、私有标签池等各种功能管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、智能引擎&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个模块就是核心的业务模块，针对客户需求提供各种公共的或者定制化的营销流程，例如：主动式营销，触发式营销，周期性营销，特定时间营销等各种业务规则的引擎封装，还需要根据效果不断的优化改进。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、画像报告&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于对数据的整理分析，以及在实际业务中的使用场景和效果，形成通用的或者定制的画像分析，例如：标签画像、人群画像、行业画像、营销画像等等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、应用工厂&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于DMP系统数据，提供开放的API能力，数据分析能力、标签查询、标签补齐、分析报告等各种综合业务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5、数据安全&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对系统数据处理建立安全保护机制，保护计算机硬件、软件和数据不因偶然和人为的突发原因造成破坏、更改和泄露。最简单直白的解释和做法就是数据加密，保证数据不直白的在各种环境中流转。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、建设过程&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、数据积累&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;形成数据治理意识，专注多个数据的产生渠道，汇总数据进而管理，例如Web端，APP端等数据源头，包括用户属性信息，行为信息等，形成流动的数据链条，管理结构化和非结构化数据，搭建数据基础仓库等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、分析能力&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据的价值体现在对数据对分析报告上，通过对海量数据分析来获得各类业务画像，进而对企业对营销产生价值。对数据状态有实时精准的更新，提供高效的数据生命周期管理，给业务评估或运营带来有价值的参考。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、数据资产&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;企业数据不断积累，发展成为的企业资产，强调战略性业务成长、成本、风险与合规。数据意识，分析驱动，建立数据使用对综合能力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dc110962b631601209fd808e5f462cae</guid>
<title>一文带你解密 Go 语言之通道 channel</title>
<link>https://toutiao.io/k/jhyptjc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章主要是针对 Go channel 的重点分析，一开始写的时候以为范围不会太大，但洋洋洒洒还是写破了万字，成为了一篇覆盖面较广和有一定深度的长文分析。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.24736842105263157&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4gL0h9gxv3OeDudYzvuHrYXJcs2pOFXoEXib2iaGuYV46aa7QWAqTseJsJavGBKE5SxAqU3VEwPeatQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1520&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家觉得不错的话，欢迎关注煎鱼和三连一波 ✍️。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来和煎鱼一起正式开始 Go channel 的学习之旅！&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言中的一大利器那就是能够非常方便的使用 &lt;code&gt;go&lt;/code&gt; 关键字来进行各种并发，而并发后又必然会涉及通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Channel 自然而然就成为了 Go 语言开发者中必须要明白明了的一个 “东西” 了，更别提实际工程应用和日常面试了，属于必知必会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文目录：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.152112676056338&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gL0h9gxv3OeDudYzvuHrYXdP4QY9cVLDia0PAQqCVZu7xkBEIKYTop8cJ5IX8dGjV8GBdjITvbpsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;710&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;什么是 channel&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，channel 可以称其为通道，也可以叫管道。channel 主要常见于与 goroutine+select 搭配使用，再结合语录的描述。可以知道 channel 就是用于 goroutine 的数据通信：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ch := make(chan string)&lt;br/&gt; go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  ch &amp;lt;- &lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; msg := &amp;lt;-ch&lt;br/&gt; fmt.Println(msg)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 goroutine1 中写入 “煎鱼” 到变量 &lt;code&gt;ch&lt;/code&gt; 中，goroutine2 监听变量 &lt;code&gt;ch&lt;/code&gt;，并阻塞等待读取到值 “煎鱼” 最终返回，结束流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此 channel 承载着一个衔接器的桥梁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.424483306836248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rwRX244EkQF5w6LF2pibrHLUeo8xI5mJia8l0Tc9B57MribeMu8yvNuKrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是 channel 的经典思想了，&lt;strong&gt;不要通过共享内存来通信，而是通过通信来实现内存共享&lt;/strong&gt;（Do not communicate by sharing memory; instead, share memory by communicating）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从模式上来看，其就是在多个 goroutine 借助 channel 来传输数据，实现了跨 goroutine 间的数据传输，多者独立运行，不需要强关联，更不影响对方的 goroutine 状态。不存在 goroutine1 对 goroutine2 进行直传的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里思考一个问题，那 goroutine1 和 goroutine2 又怎么互相知道自己的数据 ”到“ 了呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel 基本特性&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言中，channel 的关键字为 &lt;code&gt;chan&lt;/code&gt;，数据流向的表现方式为 &lt;code&gt;&amp;lt;-&lt;/code&gt;，代码解释方向是从左到右，据此就能明白通道的数据流转方向了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 共有两种模式，分别是：双向和单向；三种表现方式，分别是：声明双向通道：&lt;code&gt;chan T&lt;/code&gt;、声明只允许发送的通道：&lt;code&gt;chan &amp;lt;- T&lt;/code&gt;、声明只允许接收的通道：&lt;code&gt;&amp;lt;- chan T&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 中还分为 “无缓冲 channel” 和 “缓冲 channel”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 无缓冲&lt;br/&gt;ch1 := make(chan int)&lt;br/&gt;&lt;br/&gt;// 缓冲区为 3&lt;br/&gt;ch2 := make(chan int, 3)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们进一步展开这两类来看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 channel&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无缓冲的 channel（unbuffered channel），其缓冲区大小则默认为 0。在功能上其接受者会阻塞等待并阻塞应用程序，直至收到通信和接收到数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种常用于两个 goroutine 间互相同步等待的应用场景：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7643884892086331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rm5u8zW20Lm9Kd7ibmfQzpTVB7ZQz5yZ4mUbd7ytJe15uNs3wNj48GEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1112&quot;/&gt;&lt;figcaption&gt;unbuffered channel(via @William Kennedy)&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲 channel&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有缓存的 channel（buffered channel），其缓存区大小是根据所设置的值来调整。在功能上，若缓冲区未满则不会阻塞，会源源不断的进行传输。当缓冲区满了后，发送者就会阻塞并等待。而当缓冲区为空时，接受者就会阻塞并等待，直至有新的数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5089928057553957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rDbW2LD4ySQr9Tx9O5aAahVibqu87rCYcJp1qRz2Z8hTPsaU74R9ttKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;556&quot;/&gt;&lt;figcaption&gt;buffered channel(via @William Kennedy)&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的应用场景中，两者根据业务情况选用就可以了，不需要太过纠结于两者是否有性能差距，没意义。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel 本质&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 听起来实现了一个非常酷的东西，也是日常工作中常常会被面试官问到的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实 channel 并没有那么的 &quot;神秘&quot;，就是一个环形队列的配合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们一步步的剖开 channel，看看里面到底是什么，怎么实现的跨 goroutine 通信，数据结构又是什么，两者又如何实现数据传输的？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上 channel 在设计上就是环形队列。其包含发送方队列、接收方队列，加上互斥锁 &lt;code&gt;mutex&lt;/code&gt; 等结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 是一个有锁的环形队列：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5016666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rJ1KHjk5ERZeF2dqbrQbiaXffAv4YGEzopNuHRj7bGjic3Js1BhLibjZog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hchan 结构体是 channel 在运行时的具体表现形式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// src/runtime/chan.go&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; hchan struct {&lt;br/&gt; qcount   uint      &lt;br/&gt; dataqsiz uint     &lt;br/&gt; buf      unsafe.Pointer &lt;br/&gt; elemsize uint16&lt;br/&gt; closed   uint32&lt;br/&gt; elemtype *_type &lt;br/&gt; sendx    uint  &lt;br/&gt; recvx    uint  &lt;br/&gt; recvq    waitq  &lt;br/&gt; sendq    waitq  &lt;br/&gt;&lt;br/&gt; lock mutex&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;qcount：队列中的元素总数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dataqsiz：循环队列的长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;buf：指向长度为 dataqsiz 的底层数组，仅有当 channel 为缓冲型的才有意义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;elemsize：能够接受和发送的元素大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;closed：是否关闭。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;elemtype：能够接受和发送的元素类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sendx：已发送元素在循环队列中的索引位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;recvx：已接收元素在循环队列中的索引位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;recvq：接受者的 sudog 等待队列（缓冲区不足时阻塞等待的 goroutine）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sendq：发送者的 sudog 等待队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据结构中，我们可以看到 &lt;code&gt;recvq&lt;/code&gt; 和 &lt;code&gt;sendq&lt;/code&gt;，其表现为等待队列，其类型为 &lt;code&gt;runtime.waitq&lt;/code&gt; 的双向链表结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; waitq struct {&lt;br/&gt; first *sudog&lt;br/&gt; last  *sudog&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;且无论是 &lt;code&gt;first&lt;/code&gt; 属性又或是 &lt;code&gt;last&lt;/code&gt;，其类型都为 &lt;code&gt;runtime.sudog&lt;/code&gt; 结构体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; sudog struct {&lt;br/&gt; g *g&lt;br/&gt;&lt;br/&gt; next *sudog&lt;br/&gt; prev *sudog&lt;br/&gt; elem unsafe.Pointer&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;g：指向当前的 goroutine。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next：指向下一个 g。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prev：指向上一个 g。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;elem：数据元素，可能会指向堆栈。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sudog 是 Go 语言中用于存放协程状态为阻塞的 goroutine 的双向链表抽象，你可以直接理解为一个正在等待的 goroutine 就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在后续的实现原理分析中，基本围绕着上述数据结构进行大量的讨论，建议可以认真思考一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel 实现原理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了 channel 的基本原理后，我们进入到与应用工程中更紧密相关的部分，那就是 channel 的四大块操作，分别是：“创建、发送、接收、关闭”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将针对这四块进行细致的分析和讲解。因此接下来的内容比较庞大，内容上将分为两个角度来讲述，分别是先从源码角度进行分析，再进行图示汇总。以便于大家更好的理解和思考&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建 chan&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 channel 的演示代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ch := make(chan string)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其在编译器翻译后对应 &lt;code&gt;runtime.makechan&lt;/code&gt; 或 &lt;code&gt;runtime.makechan64&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 通用创建方法&lt;br/&gt;func makechan(t *chantype, size int) *hchan&lt;br/&gt;&lt;br/&gt;// 类型为 int64 的进行特殊处理&lt;br/&gt;func makechan64(t *chantype, size int64) *hchan&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面我们得知 channel 的基本单位是 &lt;code&gt;hchan&lt;/code&gt; 结构体，那么在创建 channel 时，究竟还需要做什么是呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起分析一下 &lt;code&gt;makechan&lt;/code&gt; 方法，就能知道了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// src/runtime/chan.go&lt;br/&gt;func makechan(t *chantype, size int) *hchan {&lt;br/&gt; elem := t.elem&lt;br/&gt; mem, _ := math.MulUintptr(elem.size, uintptr(size))&lt;br/&gt;&lt;br/&gt; var c *hchan&lt;br/&gt; switch {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; mem == 0:&lt;br/&gt;  c = (*hchan)(mallocgc(hchanSize, nil, &lt;span&gt;true&lt;/span&gt;))&lt;br/&gt;  c.buf = c.raceaddr()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; elem.ptrdata == 0:&lt;br/&gt;  c = (*hchan)(mallocgc(hchanSize+mem, nil, &lt;span&gt;true&lt;/span&gt;))&lt;br/&gt;  c.buf = add(unsafe.Pointer(c), hchanSize)&lt;br/&gt; default:&lt;br/&gt;  c = new(hchan)&lt;br/&gt;  c.buf = mallocgc(mem, elem, &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; c.elemsize = uint16(elem.size)&lt;br/&gt; c.elemtype = elem&lt;br/&gt; c.dataqsiz = uint(size)&lt;br/&gt; lockInit(&amp;amp;c.lock, lockRankHchan)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 channel 的逻辑主要分为三大块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当前 channel 不存在缓冲区，也就是元素大小为 0 的情况下，就会调用 &lt;code&gt;mallocgc&lt;/code&gt; 方法分配一段连续的内存空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前 channel 存储的类型存在指针引用，就会连同 &lt;code&gt;hchan&lt;/code&gt; 和底层数组同时分配一段连续的内存空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通用情况，默认分配相匹配的连续内存空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意到一块特殊点，那就是 channel 的创建都是调用的 &lt;code&gt;mallocgc&lt;/code&gt; 方法，也就是 channel 都是创建在堆上的。因此 channel 是会被 GC 回收的，自然也不总是需要 &lt;code&gt;close&lt;/code&gt; 方法来进行显示关闭了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从整体上来讲，&lt;code&gt;makechan&lt;/code&gt; 方法的逻辑比较简单，就是创建 &lt;code&gt;hchan&lt;/code&gt; 并分配合适的 &lt;code&gt;buf&lt;/code&gt; 大小的堆上内存空间。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;发送数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 发送数据的演示代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    ch &amp;lt;- &lt;span&gt;&quot;煎鱼&quot;&lt;/span&gt;&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其在编译器翻译后对应 &lt;code&gt;runtime.chansend1&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend1(c *hchan, elem unsafe.Pointer) {&lt;br/&gt; chansend(c, elem, &lt;span&gt;true&lt;/span&gt;, getcallerpc())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其作为编译后的入口方法，实则指向真正的实现逻辑，也就是 &lt;code&gt;chansend&lt;/code&gt; 方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前置处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第一部分中，我们先看看 chan 发送的一些前置判断和处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c == nil {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)&lt;br/&gt;  throw(&lt;span&gt;&quot;unreachable&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !block &amp;amp;&amp;amp; c.closed == 0 &amp;amp;&amp;amp; full(c) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // 省略一些调试相关&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func full(c *hchan) bool {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.dataqsiz == 0 {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c.recvq.first == nil&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.qcount == c.dataqsiz&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始 &lt;code&gt;chansend&lt;/code&gt; 方法在会先判断当前的 channel 是否为 nil。若为 nil，在逻辑上来讲就是向 nil channel 发送数据，就会调用 &lt;code&gt;gopark&lt;/code&gt; 方法使得当前 Goroutine 休眠，进而出现死锁崩溃，表象就是出现 &lt;code&gt;panic&lt;/code&gt; 事件来快速失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着会对非阻塞的 channel 进行一个上限判断，看看是否快速失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;失败的场景如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若非阻塞且未关闭，同时底层数据 dataqsiz 大小为 0（缓冲区无元素），则会返回失败。。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若是 qcount 与 dataqsiz 大小相同（缓冲区已满）时，则会返回失败。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;上互斥锁&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成了 channel 的前置判断后，即将在进入发送数据的处理前，channel 会进行上锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; lock(&amp;amp;c.lock)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上锁后就能保住并发安全。另外我们也可以考虑到，这种场景会相对依赖单元测试的覆盖，因为一旦没考虑周全，漏上锁了，基本就会出问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;直接发送&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正式开始发送前，加锁之后，会对 channel 进行一次状态判断（是否关闭）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.closed != 0 {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;send on closed channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg := c.recvq.dequeue(); sg != nil {&lt;br/&gt;  send(c, sg, ep, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { unlock(&amp;amp;c.lock) }, 3)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况是最为基础的，也就是当前 channel 有正在阻塞等待的接收方，那么只需要直接发送就可以了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲发送&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非直接发送，那么就考虑第二种场景，判断 channel 缓冲区中是否还有空间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.qcount &amp;lt; c.dataqsiz {&lt;br/&gt;  qp := chanbuf(c, c.sendx)&lt;br/&gt;  typedmemmove(c.elemtype, qp, ep)&lt;br/&gt;  c.sendx++&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.sendx == c.dataqsiz {&lt;br/&gt;   c.sendx = 0&lt;br/&gt;  }&lt;br/&gt;  c.qcount++&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会对缓冲区进行判定（&lt;code&gt;qcount&lt;/code&gt; 和 &lt;code&gt;dataqsiz&lt;/code&gt; 字段），以此识别缓冲区的剩余空间。紧接进行如下操作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;chanbuf&lt;/code&gt; 方法，以此获得底层缓冲数据中位于 sendx 索引的元素指针值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;typedmemmove&lt;/code&gt; 方法，将所需发送的数据拷贝到缓冲区中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据拷贝后，对 sendx 索引自行自增 1。同时若 sendx 与 dataqsiz 大小一致，则归 0（环形队列）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自增完成后，队列总数同时自增 1。解锁互斥锁，返回结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此针对缓冲区的数据操作完成。但若没有走进缓冲区处理的逻辑，则会判断当前是否阻塞 channel，若为非阻塞，将会解锁并直接返回失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配合图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4431818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rh6icAgz61McWviceS0n1TdErxVXzfvM7S3aTAMMYv1jZMoXq5GUZa65g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1760&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞发送&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行了各式各样的层层筛选后，接下来进入阻塞等待发送的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; gp := getg()&lt;br/&gt; mysg := acquireSudog()&lt;br/&gt; mysg.releasetime = 0&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t0 != 0 {&lt;br/&gt;  mysg.releasetime = -1&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; mysg.elem = ep&lt;br/&gt; mysg.waitlink = nil&lt;br/&gt; mysg.g = gp&lt;br/&gt; mysg.isSelect = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; mysg.c = c&lt;br/&gt; gp.waiting = mysg&lt;br/&gt; gp.param = nil&lt;br/&gt; c.sendq.enqueue(mysg)&lt;br/&gt;&lt;br/&gt; atomic.Store8(&amp;amp;gp.parkingOnChan, 1)&lt;br/&gt; gopark(chanparkcommit, unsafe.Pointer(&amp;amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)&lt;br/&gt;&lt;br/&gt; KeepAlive(ep)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;getg&lt;/code&gt; 方法获取当前 goroutine 的指针，用于后续发送数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;acquireSudog&lt;/code&gt; 方法获取 &lt;code&gt;sudog&lt;/code&gt; 结构体，并设置当前 sudog 具体的待发送数据信息和状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;c.sendq.enqueue&lt;/code&gt; 方法将刚刚所获取的 &lt;code&gt;sudog&lt;/code&gt; 加入待发送的等待队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;gopark&lt;/code&gt; 方法挂起当前 goroutine（会记录执行位置），状态为 waitReasonChanSend，阻塞等待 channel。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;KeepAlive&lt;/code&gt; 方法保证待发送的数据值是活跃状态，也就是分配在堆上，避免被 GC 回收。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配合图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6289198606271778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4gYzazJ7HcwarAl724nqI0rGgbUe3ibexj9Pv7ZBYnr5fC4MYHyQVC8TEBAoBEpqkYEcFJyZcHtMfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1148&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在当前 goroutine 被挂起后，其将会在 channel 能够发送数据后被唤醒：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {&lt;br/&gt; ...&lt;br/&gt; // 从这里开始唤醒，并恢复阻塞的发送操作&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg != gp.waiting {&lt;br/&gt;  throw(&lt;span&gt;&quot;G waiting list is corrupted&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; gp.waiting = nil&lt;br/&gt; gp.activeStackChans = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; gp.param == nil {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.closed == 0 {&lt;br/&gt;   throw(&lt;span&gt;&quot;chansend: spurious wakeup&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;send on closed channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt; gp.param = nil&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg.releasetime &amp;gt; 0 {&lt;br/&gt;  blockevent(mysg.releasetime-t0, 2)&lt;br/&gt; }&lt;br/&gt; mysg.c = nil&lt;br/&gt; releaseSudog(mysg)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唤醒 goroutine（调度器在停止 g 时会记录运行线程和方法内执行的位置）并完成 channel 的阻塞数据发送动作后。进行基本的参数检查，确保是符合要求的（纵深防御），接着开始取消 mysg 上的 channel 绑定和 sudog 的释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此完成所有类别的 channel 数据发送管理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接收数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 接受数据的演示代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;msg := &amp;lt;-ch&lt;br/&gt;&lt;br/&gt;msg, ok := &amp;lt;-ch&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种方法在编译器翻译后分别对应 &lt;code&gt;runtime.chanrecv1&lt;/code&gt; 和 &lt;code&gt;runtime.chanrecv2&lt;/code&gt; 两个入口方法，其再在内部再进一步调用 &lt;code&gt;runtime.chanrecv&lt;/code&gt; 方法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，发送和接受 channel 是相对的，也就是其核心实现也是相对的。因此在理解时也可以结合来看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前置处理&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c == nil {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)&lt;br/&gt;  throw(&lt;span&gt;&quot;unreachable&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始时 &lt;code&gt;chanrecv&lt;/code&gt; 方法会判断其是否为 nil channel。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若 channel 是 nil channel，且为阻塞接收则调用 &lt;code&gt;gopark&lt;/code&gt; 方法挂起当前 goroutine。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若 channel 是非阻塞模式，则直接返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而接下来对于非阻塞模式的 channel 会进行快速失败检查，检测 channel 是否已经准备好接收。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;if&lt;/span&gt; !block &amp;amp;&amp;amp; empty(c) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; atomic.Load(&amp;amp;c.closed) == 0 {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; empty(c) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;    typedmemclr(c.elemtype, ep)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其分以下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无缓冲区：循环队列为 0 及等待队列 sendq 内没有 goroutine 正在等待。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有缓冲区：缓冲区数组为空。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会对 channel 的 closed 状态进行判断，因为 channel 是无法重复打开的，需要确定当前 channel 是否为未关闭状态。再确定接收失败，返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但若是 channel 已经关闭且不存在缓存数据了，则会清理 &lt;code&gt;ep&lt;/code&gt; 指针中的数据并返回。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;直接接收&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发现 channel 上有正在阻塞等待的发送方时，则直接进行接收：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; lock(&amp;amp;c.lock)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg := c.sendq.dequeue(); sg != nil {&lt;br/&gt;  recv(c, sg, ep, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { unlock(&amp;amp;c.lock) }, 3)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲接收&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发现 channel 的缓冲区中有元素时：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.qcount &amp;gt; 0 {&lt;br/&gt;  qp := chanbuf(c, c.recvx)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;   typedmemmove(c.elemtype, ep, qp)&lt;br/&gt;  }&lt;br/&gt;  typedmemclr(c.elemtype, qp)&lt;br/&gt;  c.recvx++&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.recvx == c.dataqsiz {&lt;br/&gt;   c.recvx = 0&lt;br/&gt;  }&lt;br/&gt;  c.qcount--&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !block {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将会调用 &lt;code&gt;chanbuf&lt;/code&gt; 方法根据 &lt;code&gt;recvx&lt;/code&gt; 的索引位置取出数据，找到要接收的元素进行处理。若所接收到的数据和所传入的变量均不为空，则会调用 &lt;code&gt;typedmemmove&lt;/code&gt; 方法将缓冲区中的数据拷贝到所传入的变量中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后数据拷贝完毕后，进行各索引项和队列总数的自增增减，并调用 &lt;code&gt;typedmemclr&lt;/code&gt; 方法进行内存数据的清扫。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;阻塞接收&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发现 channel 上既没有待发送的 goroutine，缓冲区也没有数据时。将会进入到最后一个阶段阻塞接收：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; gp := getg()&lt;br/&gt; mysg := acquireSudog()&lt;br/&gt; mysg.releasetime = 0&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; t0 != 0 {&lt;br/&gt;  mysg.releasetime = -1&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; mysg.elem = ep&lt;br/&gt; mysg.waitlink = nil&lt;br/&gt; gp.waiting = mysg&lt;br/&gt; mysg.g = gp&lt;br/&gt; mysg.isSelect = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; mysg.c = c&lt;br/&gt; gp.param = nil&lt;br/&gt; c.recvq.enqueue(mysg)&lt;br/&gt;&lt;br/&gt; atomic.Store8(&amp;amp;gp.parkingOnChan, 1)&lt;br/&gt; gopark(chanparkcommit, unsafe.Pointer(&amp;amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块接收逻辑与发送也基本类似，主体就是获取当前 goroutine，构建 sudog 结构保存当前待接收数据（发送方）的地址信息，并将 sudog 加入等待接收队列。最后调用 &lt;code&gt;gopark&lt;/code&gt; 方法挂起当前 goroutine，等待唤醒。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {&lt;br/&gt;&lt;br/&gt; // 被唤醒后从此处开始&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg != gp.waiting {&lt;br/&gt;  throw(&lt;span&gt;&quot;G waiting list is corrupted&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; gp.waiting = nil&lt;br/&gt; gp.activeStackChans = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; mysg.releasetime &amp;gt; 0 {&lt;br/&gt;  blockevent(mysg.releasetime-t0, 2)&lt;br/&gt; }&lt;br/&gt; closed := gp.param == nil&lt;br/&gt; gp.param = nil&lt;br/&gt; mysg.c = nil&lt;br/&gt; releaseSudog(mysg)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, !closed&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被唤醒后，将恢复现场，回到对应的执行点，完成最后的扫尾工作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭 chan&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭 channel 主要是涉及到 &lt;code&gt;close&lt;/code&gt; 关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;close(ch)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其对应的编译器翻译方法为 &lt;code&gt;closechan&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前置处理&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c == nil {&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;close of nil channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; lock(&amp;amp;c.lock)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.closed != 0 {&lt;br/&gt;  unlock(&amp;amp;c.lock)&lt;br/&gt;  panic(plainError(&lt;span&gt;&quot;close of closed channel&quot;&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; c.closed = 1&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本检查和关闭标志设置，保证 channel 不为 nil 和未关闭，保证边界。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;释放接收方&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成了异常边界判断和标志设置后，会将接受者的 sudog 等待队列（recvq）加入到待清除队列 glist 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt;&lt;br/&gt; var glist gList&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  sg := c.recvq.dequeue()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg == nil {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg.elem != nil {&lt;br/&gt;   typedmemclr(c.elemtype, sg.elem)&lt;br/&gt;   sg.elem = nil&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;   sg.releasetime = cputicks()&lt;br/&gt;  }&lt;br/&gt;  gp := sg.g&lt;br/&gt;  gp.param = nil&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; raceenabled {&lt;br/&gt;   raceacquireg(gp, c.raceaddr())&lt;br/&gt;  }&lt;br/&gt;  glist.push(gp)&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所取出并加入的 goroutine 状态需要均为 &lt;code&gt;_Gwaiting&lt;/code&gt;，以保证后续的新一轮调度。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;释放发送方&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，与释放接收方一样。会将发送方也加入到到待清除队列 glist 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt;&lt;br/&gt; // release all writers (they will panic)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  sg := c.sendq.dequeue()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg == nil {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  sg.elem = nil&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;   sg.releasetime = cputicks()&lt;br/&gt;  }&lt;br/&gt;  gp := sg.g&lt;br/&gt;  gp.param = nil&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; raceenabled {&lt;br/&gt;   raceacquireg(gp, c.raceaddr())&lt;br/&gt;  }&lt;br/&gt;  glist.push(gp)&lt;br/&gt; }&lt;br/&gt; unlock(&amp;amp;c.lock)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;协程调度&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将所有 glist 中的 goroutine 状态从 &lt;code&gt;_Gwaiting&lt;/code&gt; 设置为 &lt;code&gt;_Grunnable&lt;/code&gt; 状态，等待调度器的调度：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func closechan(c *hchan) {&lt;br/&gt;&lt;br/&gt; // Ready all Gs now that we&lt;span&gt;&#x27;ve dropped the channel lock.&lt;br/&gt; for !glist.empty() {&lt;br/&gt;  gp := glist.pop()&lt;br/&gt;  gp.schedlink = 0&lt;br/&gt;  goready(gp, 3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续所有的 goroutine 允许被重新调度后。若原本还在被动阻塞的发送方或接收方，将重获自由，后续该干嘛就去干嘛了，再跑回其所属的应用流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;channel send/recv 分析&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;send&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;send&lt;/code&gt; 方法承担向 channel 发送具体数据的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg.elem != nil {&lt;br/&gt;  sendDirect(c.elemtype, sg, ep)&lt;br/&gt;  sg.elem = nil&lt;br/&gt; }&lt;br/&gt; gp := sg.g&lt;br/&gt; unlockf()&lt;br/&gt; gp.param = unsafe.Pointer(sg)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;  sg.releasetime = cputicks()&lt;br/&gt; }&lt;br/&gt; goready(gp, skip+1)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {&lt;br/&gt; dst := sg.elem&lt;br/&gt; typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)&lt;br/&gt; memmove(dst, src, t.size)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;sendDirect&lt;/code&gt; 方法将待发送的数据直接拷贝到待接收变量的内存地址（执行栈）。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;例如：&lt;code&gt;msg := &amp;lt;-ch&lt;/code&gt; 语句，也就是将数据从 &lt;code&gt;ch&lt;/code&gt; 直接拷贝到了 &lt;code&gt;msg&lt;/code&gt; 的内存地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;sg.g&lt;/code&gt; 属性， 从 sudog 中获取等待接收数据的 goroutine，并传递后续唤醒所需的参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;goready&lt;/code&gt; 方法唤醒需接收数据的 goroutine，期望从 &lt;code&gt;_Gwaiting&lt;/code&gt; 状态调度为 &lt;code&gt;_Grunnable&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;recv&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;recv&lt;/code&gt; 方法承担在 channel 中接收具体数据的功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; c.dataqsiz == 0 {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;   recvDirect(c.elemtype, sg, ep)&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  qp := chanbuf(c, c.recvx)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ep != nil {&lt;br/&gt;   typedmemmove(c.elemtype, ep, qp)&lt;br/&gt;  }&lt;br/&gt;  typedmemmove(c.elemtype, qp, sg.elem)&lt;br/&gt;  c.recvx++&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; c.recvx == c.dataqsiz {&lt;br/&gt;   c.recvx = 0&lt;br/&gt;  }&lt;br/&gt;  c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz&lt;br/&gt; }&lt;br/&gt; sg.elem = nil&lt;br/&gt; gp := sg.g&lt;br/&gt; unlockf()&lt;br/&gt; gp.param = unsafe.Pointer(sg)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sg.releasetime != 0 {&lt;br/&gt;  sg.releasetime = cputicks()&lt;br/&gt; }&lt;br/&gt; goready(gp, skip+1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法在接受上分为两种情况，分别是直接接收和缓冲接收：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;直接接收（不存在缓冲区）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;recvDirect&lt;/code&gt; 方法，其作用与 &lt;code&gt;sendDirect&lt;/code&gt; 方法相对，会直接从发送方的 goroutine 调用栈中将数据拷贝过来到接收方的 goroutine。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;缓冲接收（存在缓冲区）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;chanbuf&lt;/code&gt; 方法，根据 &lt;code&gt;recvx&lt;/code&gt; 索引的位置读取缓冲区元素，并将其拷贝到接收方的内存地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拷贝完毕后，对 &lt;code&gt;sendx&lt;/code&gt; 和 &lt;code&gt;recvx&lt;/code&gt; 索引位置进行调整。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后还是常规的 goroutine 调度动作，会调用 &lt;code&gt;goready&lt;/code&gt; 方法来唤醒当前所处理的 sudog 的对应 goroutine。那么在下一轮调度时，既然已经接收了数据，自然发送方也就会被唤醒。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中我们针对 Go 语言的 channel 进行了基本概念的分析和讲解，同时还针对 channel 的设计原理和四大操作（创建、发送、接收、关闭）进行了源码分析和图示分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步看过一遍后，再翻看。不难发现，Go 的 channel 设计并不复杂，记住他的数据结构就是带缓存的环形队列，再加上对称的 sendq、recvq 等双向链表的辅助属性，就能勾画出 channel 的基本逻辑流转模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体的数据传输上，都是围绕着 “边界上下限处理，上互斥锁，阻塞/非阻塞，缓冲/非缓冲，缓存出队列，拷贝数据，解互斥锁，协程调度” 在不断地流转处理。在基本逻辑上也是相对重合的，因为发送和接收，创建和关闭总是相对的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果更进一步深入探讨，还可以围绕着 CSP 模型、goroutine 调度等进一步的思考和理解。这一块会在后续的章节中再一步展开。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7ae09870e2cca455ac661252dc73218</guid>
<title>抓包神器 Wireshark，帮你快速定位线上网络故障（五）</title>
<link>https://toutiao.io/k/oxyi4m9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; 引子 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;em&gt;&lt;em/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Wireshark 就像网络世界的显微镜，我们可以在它的帮助下了解网络中发生的一切。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上次分享借助 Wireshark 对 QQ 音乐进行抓取 HTTPS 包，并谈了谈如何脱掉 HTTPS 的加密外壳？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次简单谈谈 HTTPS 协议的握手过程，希望大家能够稍作了解，以备不时之需。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;2&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; HTTPS 协议握手一览 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本次依然基于 Wireshark 对 QQ 音乐抓取 HTTPS 包为例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;137&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.23652048885693747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKyvghqxCISnB8cZ9wcCcDQTXjdCHNJldoxiaib6qSibPwpItJ8MYWNibBaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2782&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上图，HTTPS 握手是建立在 TCP 基础上的，首先进行 TCP 的三次握手（&lt;/span&gt;&lt;span&gt;之前分享过，感兴趣的可以扒拉一下历史推文回味一下&lt;/span&gt;&lt;span&gt;），然后再进行建立 TLS 连接，下面重点谈谈 TLS 握手过程（&lt;/span&gt;&lt;span&gt;HTTPS = HTTP + TLS/SSL&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以借助 Wireshark 提供的「Statistics|Flow Graph」功能，进行展示出 HTTPS 协议握手的流程图，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;140&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.24141749723145073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKhpAdjA8fpJDKHiaNseFR6uecZpiaCORtcSpxvIJ2b1diarLJY9ldwBib7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1806&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还可以借助 Wireshark 提供的「显示过滤器」功能来筛选出重点关注的 TLS 握手数据包，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;83&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14350797266514806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWN4yO80IqcOYwFEYPRU1YDWMf9b1KZjzRVb835fPJiaVxibXCO8nRjLiaKFIAQzSBJtUtS47vhrB2hkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2634&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面两张截图，能够梳理出 HTTPS 协议握手的几个重要步骤。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤一：客户端向服务器端发送一个 Client Hello&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤二：服务器端向客户端返回一个 Server Hello&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤三：服务器端向客户端返回一个 Certificate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤四：服务器端向客户端返回 Server Key Exchange,Server Hello Done&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤五：客户端向服务器端发送 Client Key Exchange,&lt;span class=&quot;code-snippet__keyword&quot;&gt;Change&lt;/span&gt; Cipher Spec,Encrypted Handshake Message&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;步骤六：服务器端向客户端返回 &lt;span class=&quot;code-snippet__keyword&quot;&gt;New&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Session&lt;/span&gt; Ticket,&lt;span class=&quot;code-snippet__keyword&quot;&gt;Change&lt;/span&gt; Cipher Spec,Encrypted Handshake Message&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; HTTPS 协议握手剖析 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;HTTPS 握手的过程，借助 Wireshark 能够看的很清晰，接下来采取剥洋葱的方式，一层一层去分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤一：Client Hello&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7015329125338142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKJpHZa0R3TTNGibustgOvsGlBLvtNkwk0PsQw6xp5QbjM3gBxnSibrH0w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2218&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过 Wireshark 抓包分析，如上图所示，Clinet Hello 阶段主要是客户端告诉服务端客户端所支持的 TLS 协议的版本号、客户端支持的加密套件、客户端支持的压缩方法以及客户端生成的一个随机数等相关信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤二：Server Hello&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;327&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5653742110009017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKm8Onb2Q8pH2ibpKbwEQ6dxagVu5tZ5qOxu1faGjWaVjph5BuNAFotkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2218&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过抓包分析，如上图所示，主要是服务端根据客户端传递的支持的相关信息，确定使用的 SSL/TLS 协议版本；确定使用哪种加密套件及压缩方法等；产生一个随机数 Random。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤三：Certificate&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49550286181520853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKXWjtPY5UiaAiaw0ZA5wu9Jib8oj7eNFo1182GVrXKUdofPkUYHVquSgZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2446&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此步主要是服务端向客户端发送证书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤四：Server Key Exchange,Server Hello Done&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;319&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5520918785890074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kK1MZfZbFgFRnNibgcZKicYhPGDlplulk00oDXRKz5pSHForKsbSQvqiaYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2438&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Server Key E&lt;/span&gt;&lt;span&gt;xchange：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;此消息是服务端向客户端发送密钥交换算法相关参数和数据的，&lt;/span&gt;&lt;span&gt;常用的密钥交换算法有 RSA、DH、ECDH 等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Server Hello Done：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务端告诉客户端消息发送完毕。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤五：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49465899753492193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKgEk4bmBYfHia9f7V0lX87RtKBaws3SZdc629Nu4YGFS4h7eotCc5SbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2434&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Client Key Exchange：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;此消息用来交换秘钥参数，生成一个pre-master key，然后将这个 Key 传给服务器端，服务端会结合自己的私钥解密出 Key，得到第三个随机数，进而可以生成一个通信密钥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Change Cipher Spec：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;此消息是告诉服务器端后期的通信都会使用协商出来的这个密钥进行加密。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Encrypted Handshake Message&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：客户端将前面的握手消息生成摘要，然后用协商好的秘钥进行加密，若服务端接收后能解出来，说明前面协商出来的秘钥是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤六：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.49426229508196723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKwfNk0kml7opeDHk5otPevFuXRrsM1q7vUFZicxjKdFmIWM4I5iaicFM8A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;New Session Ticket：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包含了一个加密通信所需要的信息，这些数据采用一个只有服务器知道的密钥进行加密。目标是消除服务器需要维护每个客户端的会话状态缓存的要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Change Cipher Spec：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;此消息是告诉客户端后期的通信都会使用协商出来的密钥进行加密通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Encrypted Handshake Message：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务端将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。&lt;/span&gt;&lt;span&gt;客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;到这里 TLS 握手就完成啦，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;接着就是数据传输了。&lt;/span&gt;&lt;span&gt;HTTPS 数据传输如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;258&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.44635544635544633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/waH0DGXhQWOSuN9RZlrnT86FvLmib11kKa1tSibC2ry1Irp35XeyibCpodkJzu5QRhejAGJIea50ZzvmDtEKVpR3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2442&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template-id=&quot;1544239&quot; data-mpa-category=&quot;收藏&quot;&gt;&lt;section data-mpa-template-id=&quot;1495&quot; data-mpa-category=&quot;title&quot;&gt;&lt;section label=&quot;Copyright © 2017 playhudong All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;4&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; 写在最后 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;纸上得来终觉浅，绝知此事要躬行，有些传到不到的地方，还需要结合 Wireshark 抓包自行分析一番。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次 Wireshark 分享就写到这里，为了能够让分享不出现纰漏，查阅了很多文档、书籍以及官方资料，归纳汇总一下给老铁，希望对老铁能有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;资料分享：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;120&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;经典例子：https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官方文档：https://www.wireshark.org/docs/wsug_html_chunked/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;119&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;参考书籍：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;42&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;《从实践中学习Wireshark数据分析》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《Wireshark网络分析就是这么简单》&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。&lt;/strong&gt;&lt;span&gt;会持续输出精彩分享，敬请期待！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;211&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1710&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/waH0DGXhQWOwkpyEoA1IiakYviaHIX4GnoUHGE4kNCqHqAM54WmxryEd76E7Uf1xibO18pftGiafQqI8ibxqMHG34xA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;历史推文（欢迎转发&amp;amp;点赞&amp;amp;在看）：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486160&amp;amp;idx=1&amp;amp;sn=5af3be7c0fc582b3e8b839dfaf1f849d&amp;amp;chksm=fc0041ddcb77c8cba0b47c96516746037761f502cf919c486d926f96bb2fc2001d7f0977255b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（1）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486177&amp;amp;idx=1&amp;amp;sn=d9ec9b3abc9dc2f1336ee855476f3e47&amp;amp;chksm=fc0041eccb77c8facbe7adaca5804a891f8928c55b92d74b82784f33aecfd8c37a6ba8289b25&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（2）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486192&amp;amp;idx=1&amp;amp;sn=aa7aa0fdc2a87b0a72003a0313c421a2&amp;amp;chksm=fc0041fdcb77c8ebdffc493a505dbd211d25104743e21b85029039cde5eb240fbcda36079b08&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（3）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486209&amp;amp;idx=1&amp;amp;sn=ffc4867ec97f3ee45b0db1353fdc084e&amp;amp;chksm=fc00400ccb77c91a595b7b312dcca0bcda866299e44b963e4e32bfcdc850e65d9f9ce1ab7829&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;抓包神器 Wireshark，帮你快速定位线上网络故障（4）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MDg5NzYzNA==&amp;amp;mid=2247486097&amp;amp;idx=1&amp;amp;sn=bf9499abc93a31689161ffd030b108fa&amp;amp;chksm=fc00419ccb77c88a19f98965437f3a2bccd021af27416038681e32bbaabf1d06c20edb855f73&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;真实|技术人员该如何接手一个复杂的系统？吐血推荐这几招&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>