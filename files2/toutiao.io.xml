<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ab72760fe7fd2463d879645ea2aac4b3</guid>
<title>GitHub 时断时续 Flutter 开发如何设置镜像</title>
<link>https://toutiao.io/k/4f64ssc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-id=&quot;23098&quot; data-type=&quot;lspecial02&quot; data-md5=&quot;3029a&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;最近一些国外的资源网站又开始时断时续，例如 &lt;strong&gt;Github&lt;/strong&gt;，甚至在海外搭建的个人 VPN 服务器都无法使用。&lt;strong&gt;这篇文章就介绍在这种情况下如何保证 Flutter 相关资源不受影响。&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5210237659963437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oQUHic2XyiaCC2tRO5YUwx2JrO3UeBCvBUmKiadAiaatxdUoa6OHuicvEmlIIT5DNgwq39eTlgCNxa7caB3zSkZzRUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;由于 Flutter 需要支持多个平台，所以需要提供以下三个方面的镜像配置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;为 Flutter 设定镜像配置&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你在国内使用 Flutter，那么你可能需要找一个与官方同步的可信的镜像站点，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;为此设置两个环境变量: PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;// Flutter 社区的的镜像&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;export&lt;/span&gt; PUB_HOSTED_URL=https:&lt;span&gt;//pub.flutter-io.cn&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;export&lt;/span&gt; FLUTTER_STORAGE_BASE_URL=https:&lt;span&gt;//storage.flutter-io.cn&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;// 清华大学 TUNA 协会的镜像&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;export&lt;/span&gt; PUB_HOSTED_URL=https:&lt;span&gt;//pub.flutter-io.cn&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;export&lt;/span&gt; FLUTTER_STORAGE_BASE_URL=https:&lt;span&gt;//storage.flutter-io.cn&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;为 Android 添加 Maven 仓库镜像&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里使用 &lt;/span&gt;&lt;span&gt;阿里云 Maven 中央仓库&lt;/span&gt;&lt;span&gt; 作为下载源，速度更快更稳定，帮助提高研发生产效率。里面有 Android 需要的 google 和 jcenter 的镜像。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3668261562998405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oQUHic2XyiaCC2tRO5YUwx2JrO3UeBCvBUlggSUIXa7CsEPySBMzN5wUtdmFMzpNnrjJOR8QnxTT18aIDzSKffkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://avataaars.com/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;替换阿里云 Maven 中央仓库需要修改 Android 项目中 android/build.gradle 文件。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;code/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p&gt;如何为使用 Git 资源加速&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当 Github 无法访问的时候，可以使用 &lt;/span&gt;&lt;span&gt;Gitee&lt;/span&gt;&lt;span&gt; 网站来访问 Git 资源，Gitee 目前已经成为国内最大的代码托管平台。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Gitee 中的库资源会和 GitHub 同步。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.336283185840708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oQUHic2XyiaCC2tRO5YUwx2JrO3UeBCvBU2x96xUfOyEicyuRPvjvMGUq7OLzQCfJMqUlakiaibbDbx2fIeWITiaRRcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;span&gt;https://gitee.com/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们使用 pod install 或者是 flutter package 包含 git 资源时，会使用 &lt;/span&gt;&lt;span&gt;https://github.com&lt;/span&gt;&lt;span&gt; 去下载，所以会下载失败。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;所以必须使用 git 命令去更换全局的 git 镜像。这里可以使用 github.com.cnpmjs.org， 它是一个公开的一个 GitHub 代理。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;code&gt;&lt;code/&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-md5=&quot;3029a&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>13ea4a4076206d11dcf1509267b2673d</guid>
<title>Go 泛型尝鲜</title>
<link>https://toutiao.io/k/j77ejbu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;
      
      
      
      &lt;p&gt;我在二月份的文章&lt;a href=&quot;https://colobu.com/2021/02/20/merge-dev-typeparams-to-master-during-Go-1-17/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;利好！极大可能在go 1.17中就能尝试泛型&lt;/a&gt;提到，虽然Go泛型会在Go 1.18中正式发布，但是因为各种原因，代码已经开始在master分支中实现，所以极大可能你会在今年9月份发布的Go 1.17中就能尝试使用Go泛型。&lt;/p&gt;
&lt;p&gt;那么，现在，可以去掉&quot;可能&quot;这两个字了。在Go 1.17可以确定的说你能够尝试Go泛型编程了，尽管建议你还是在Go 1.18以及以后的版本才正式在产品中使用泛型。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;p&gt;即使是现在，你也可以通过自己编译master分支的方式，开始领略Go泛型的风采。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;你可以通过下面的命令按照最新的master分支(Go项目中称之为tip):&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;go get golang.org/dl/gotip&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;gotip download&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;gotip命令会clone最新的master并进行编译，编译完之后，你就是可以使用&lt;code&gt;gotip&lt;/code&gt;命令了。在需要&lt;code&gt;go&lt;/code&gt;执行程序的时候，只需要换成&lt;code&gt;gotip&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;如果因为墙或者网络的原因，你不能执行上面的&lt;code&gt;gotip download&lt;/code&gt;命令的话，你也可以直接git clone github上的go项目，执行src下的make.bash文件，也可以编译出go可执行程序。&lt;/p&gt;
&lt;p&gt;甚至你也可以结合这两种方式，相信如果有些许的下载困难不会阻碍到你。&lt;/p&gt;
&lt;h2 id=&quot;运行泛型例子&quot;&gt;运行泛型例子&lt;/h2&gt;
&lt;p&gt;比如下面一个加法的泛型例子,定义了一个&lt;code&gt;Addable&lt;/code&gt;的约束(constraint)，也就是可以执行加法的类型约束。&lt;br/&gt;然后实现了一个泛型方法add, 参数有两个(a和b),类型是满足&lt;code&gt;Addable&lt;/code&gt;约束的类型，然后返回相加的结果。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;figcaption&gt;&lt;span&gt;main.go&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;22&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;23&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;)&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Addable &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;int8&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;int16&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;int32&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;,&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;typename&quot;&gt;uint&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;uint8&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;uint16&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;uint64&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;uintptr&lt;/span&gt;,&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;typename&quot;&gt;float32&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;float64&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;complex64&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;complex128&lt;/span&gt;,&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; add[T Addable](a, b T) T {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a + b&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; main() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    fmt.Println(add&lt;span class=&quot;number&quot;&gt;(1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;,2&lt;/span&gt;))&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// FIXME&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//fmt.Println(add(&quot;foo&quot;,&quot;bar&quot;))&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;运行&lt;code&gt;gotip build -gcflags=-G=3 main.go&lt;/code&gt;可以执行这个文件，返回结果3。&lt;/p&gt;
&lt;p&gt;Go语言中两个字符串可以相加吗？&lt;/p&gt;
&lt;p&gt;&quot;是的&quot;! 字符串相加相当于&lt;code&gt;concat&lt;/code&gt;,把两个字符串连接起来，返回一个新的连接的字符串。按说，字符串也满足&lt;code&gt;Addable&lt;/code&gt;约束，但是你如果把倒数第二行的注释去掉的话，这个程序是编译不过的。&lt;/p&gt;
&lt;p&gt;原因在于Go的泛型还在开发之中，里面肯定还有大大小小的问题，所以即使Go 1.17发布了，必然还得存在一些不完善得地方，更何况现在里发布Go 1.17还早呢。&lt;/p&gt;
&lt;p&gt;更多得例子可以参照Yasuhiro Matsumoto的&lt;a href=&quot;https://github.com/mattn/go-generics-example&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mattn/go-generics-example&lt;/a&gt;项目，他提供十几个泛型的例子，包括上面的add的例子。&lt;/p&gt;
&lt;p&gt;如果你觉得好玩，不妨按照本文的安装方法，试试Go的泛型的功能。&lt;/p&gt;

      
    &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2a813b0783e32b45e7e7552610d383a2</guid>
<title>浅谈 Vite 2.0 原理，依赖预编译，插件机制是如何兼容 Rollup 的？</title>
<link>https://toutiao.io/k/2u8h9hg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;Hi，我是 ssh，春节过去了，躁动的心也该收一收，开始新一年的学习了。我目前就职于&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//webinfra.org/bytedance/web-infra&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;字节跳动的 Web Infra 团队&lt;/a&gt;，目前团队还很缺人（尤其是北京）。&lt;/p&gt;&lt;p&gt;为此我组建了一个&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/sl1673495/bytedance-apm-group/blob/main/README.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;氛围特别好的招聘社群&lt;/a&gt;，大家在里面尽情的讨论面试相关的想法和问题，也欢迎你加入，随时投递简历给我。&lt;/p&gt;&lt;p&gt;在字节跳动，大家都会自发的研究社区前沿的技术，尝试接入内部的项目并寻找提升开发效率的可能性，这种追求极致敢于创新也是被鼓励的，也有不少同学已经在尝试把新一代的构建工具 Vite 和 snowpack 引入使用。&lt;/p&gt;&lt;p&gt;这篇文章我想简单的聊聊，让尤老师如此专注的 Vite 2.0 到底有哪些亮点。&lt;/p&gt;&lt;p&gt;前几天，尤雨溪在各个社交平台宣布 Vite 2.0 发布了。&lt;/p&gt;&lt;p&gt;看得出他对 Vite 倾注了很多感情，甚至都冷落了 Vue3，停更了两个多月。&lt;/p&gt;&lt;p&gt;相关的中文公告已经有翻译了，可以在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/351147547&quot; class=&quot;internal&quot;&gt;尤雨溪的知乎文章：Vite 2.0 发布了&lt;/a&gt;中查看。&lt;/p&gt;&lt;p&gt;这篇文章来谈谈 Vite 2.0 的发布中，几个让我比较感兴趣的技术点。&lt;/p&gt;&lt;h2&gt;Vite 原理&lt;/h2&gt;&lt;p&gt;为什么会出现 Vite？在过去的 Webpack、Rollup 等构建工具的时代，我们所写的代码一般都是基于 ES Module 规范，在文件之间通过 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 形成一个很大的依赖图。&lt;/p&gt;&lt;p&gt;这些构建工具在本地开发调试的时候，也都会&lt;b&gt;提前把你的模块&lt;/b&gt;先打包成浏览器可读取的 js bundle，虽然有诸如路由懒加载等优化手段，但懒加载并不代表懒构建，Webpack 还是需要把你的异步路由用到的模块提前构建好。&lt;/p&gt;&lt;p&gt;当你的项目越来越大的时候，启动也难免变的越来越慢，甚至可能达到分钟级别。而 &lt;code&gt;HMR&lt;/code&gt; 热更新也会达到好几秒的耗时。&lt;/p&gt;&lt;p&gt;Vite 则别出心裁的利用了&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;浏览器的原生 ES Module 支持&lt;/a&gt;，直接在 html 文件里写诸如这样的代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// index.html
&amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;module&quot;&amp;gt;
  import { createApp } from &#x27;vue&#x27;
  import Main from &#x27;./Main.vue&#x27;

  createApp(Main).mount(&#x27;#app&#x27;)
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Vite 会在本地帮你启动一个服务器，当浏览器读取到这个 html 文件之后，会在执行到 import 的时候才去向服务端发送 &lt;code&gt;Main.vue&lt;/code&gt; 模块的请求，Vite 此时在利用内部的一系列黑魔法，包括 Vue 的 template 解析，代码的编译等等，解析成浏览器可以执行的 js 文件返回到浏览器端。&lt;/p&gt;&lt;p&gt;这就保证了只有在真正使用到这个模块的时候，浏览器才会请求并且解析这个模块，最大程度的做到了按需加载。&lt;/p&gt;&lt;p&gt;用 Vite 官网上的图来解释，传统的 bundle 模式是这样的：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72812741ab60bcb5bd290570db6d7892_b.jpg&quot; data-rawwidth=&quot;1918&quot; data-rawheight=&quot;1068&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-72812741ab60bcb5bd290570db6d7892_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1918&quot; data-rawheight=&quot;1068&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-72812741ab60bcb5bd290570db6d7892_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-72812741ab60bcb5bd290570db6d7892_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;而基于 ESM 的构建模式则是这样的：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8e6518e4568bb7e5ebaf3136fd4e6310_b.jpg&quot; data-rawwidth=&quot;1646&quot; data-rawheight=&quot;1030&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-8e6518e4568bb7e5ebaf3136fd4e6310_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1646&quot; data-rawheight=&quot;1030&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-8e6518e4568bb7e5ebaf3136fd4e6310_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8e6518e4568bb7e5ebaf3136fd4e6310_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;灰色部分是暂时没有用到的路由，甚至完全不会参与构建过程，随着项目里的路由越来越多，构建速度也不会变慢。&lt;/p&gt;&lt;h2&gt;依赖预编译&lt;/h2&gt;&lt;p&gt;依赖预编译，其实是 Vite 2.0 在为用户启动开发服务器之前，先用 &lt;code&gt;esbuild&lt;/code&gt; 把检测到的依赖预先构建了一遍。&lt;/p&gt;&lt;p&gt;也许你会疑惑，不是一直说好的 no-bundle 吗，怎么还是走启动时编译这条路线了？尤老师这么做当然是有理由的，我们先以导入 &lt;code&gt;lodash-es&lt;/code&gt; 这个包为例。&lt;/p&gt;&lt;p&gt;当你用 &lt;code&gt;import { debounce } from &#x27;lodash&#x27;&lt;/code&gt; 导入一个命名函数的时候，可能你理想中的场景就是浏览器去下载只包含这个函数的文件。但其实没那么理想，&lt;code&gt;debounce&lt;/code&gt; 函数的模块内部又依赖了很多其他函数，形成了一个依赖图。&lt;/p&gt;&lt;p&gt;当浏览器请求 &lt;code&gt;debounce&lt;/code&gt; 的模块时，又会发现内部有 2 个 &lt;code&gt;import&lt;/code&gt;，再这样延伸下去，这个函数内部竟然带来了 600 次请求，耗时会在 1s 左右。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c39bbfafb86f1c6f78f45e9d4753ecda_b.jpg&quot; data-rawwidth=&quot;1775&quot; data-rawheight=&quot;1040&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-c39bbfafb86f1c6f78f45e9d4753ecda_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1775&quot; data-rawheight=&quot;1040&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-c39bbfafb86f1c6f78f45e9d4753ecda_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c39bbfafb86f1c6f78f45e9d4753ecda_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这当然是不可接受的，于是尤老师想了个折中的办法，正好利用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/evanw/esbuild&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Esbuild&lt;/a&gt; 接近无敌的构建速度，让你在没有感知的情况下在启动的时候预先帮你把 &lt;code&gt;debounce&lt;/code&gt; 所用到的所有内部模块全部打包成一个传统的 &lt;code&gt;js bundle&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Esbuild&lt;/code&gt; 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6cfcfaab3e6de77ce587245332757e2d_b.jpg&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;170&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-6cfcfaab3e6de77ce587245332757e2d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;170&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-6cfcfaab3e6de77ce587245332757e2d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6cfcfaab3e6de77ce587245332757e2d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在 &lt;code&gt;httpServer.listen&lt;/code&gt; 启动开发服务器之前，会先把这个函数劫持改写，放入依赖预构建的前置步骤，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/vitejs/vite/blob/main/packages/vite/src/node/server/index.ts&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Vite 启动服务器相关代码&lt;/a&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// server/index.ts
const listen = httpServer.listen.bind(httpServer)
httpServer.listen = (async (port: number, ...args: any[]) =&amp;gt; {
  try {
    await container.buildStart({})
    // 这里会进行依赖的预构建
    await runOptimize()
  } catch (e) {
    httpServer.emit(&#x27;error&#x27;, e)
    return
  }
  return listen(port, ...args)
}) as any&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而 &lt;code&gt;runOptimize&lt;/code&gt; 相关的代码则在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/vitejs/vite/blob/main/packages/vite/src/node/optimizer/index.ts&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Github optimizer&lt;/a&gt; 中。&lt;/p&gt;&lt;p&gt;首先会根据本次运行的入口，来扫描其中的依赖：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;let deps: Record&amp;lt;string, string&amp;gt;, missing: Record&amp;lt;string, string&amp;gt;
if (!newDeps) {
  ;({ deps, missing } = await scanImports(config))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;scanImports&lt;/code&gt; 其实就是利用 &lt;code&gt;Esbuild&lt;/code&gt; 构建时提供的钩子去扫描文件中的依赖，收集到 &lt;code&gt;deps&lt;/code&gt; 变量里，在扫描到入口文件（比如 &lt;code&gt;index.html&lt;/code&gt;）中依赖的模块后，形成类似这样的依赖路径数据结构：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{
  &quot;lodash-es&quot;: &quot;node_modules/lodash-es&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后再根据分析出来的依赖，使用 &lt;code&gt;Esbuild&lt;/code&gt; 把它们提前打包成单文件的 bundle。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const esbuildService = await ensureService()
await esbuildService.build({
  entryPoints: Object.keys(flatIdDeps),
  bundle: true,
  format: &#x27;esm&#x27;,
  external: config.optimizeDeps?.exclude,
  logLevel: &#x27;error&#x27;,
  splitting: true,
  sourcemap: true,
  outdir: cacheDir,
  treeShaking: &#x27;ignore-annotations&#x27;,
  metafile: esbuildMetaPath,
  define,
  plugins: [esbuildDepPlugin(flatIdDeps, flatIdToExports, config)]
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在浏览器请求相关模块时，返回这个预构建好的模块。这样，当浏览器请求 &lt;code&gt;lodash-es&lt;/code&gt; 中的 &lt;code&gt;debounce&lt;/code&gt; 模块的时候，就可以保证只发生一次接口请求了。&lt;/p&gt;&lt;p&gt;你可以理解为，这一步和 &lt;code&gt;Webpack&lt;/code&gt; 所做的构建一样，只不过速度快了几十倍。&lt;/p&gt;&lt;p&gt;在预构建这个步骤中，还会对 &lt;code&gt;CommonJS&lt;/code&gt; 模块进行分析，方便后面需要统一处理成浏览器可以执行的 &lt;code&gt;ES Module&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;插件机制&lt;/h2&gt;&lt;p&gt;很多同学提到 Vite，第一反应就是生态不够成熟，其他构建工具有那么多的第三方插件，提供了各种各样开箱即用的便捷功能，Vite 需要多久才能赶上呢？&lt;/p&gt;&lt;p&gt;Vite 从 preact 的 WMR 中得到了启发，把插件机制做成&lt;b&gt;兼容 Rollup&lt;/b&gt; 的格式。&lt;/p&gt;&lt;p&gt;于是便有了这个&lt;b&gt;相亲相爱&lt;/b&gt;的 LOGO：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8d42dc930e38d456f2cdac5cb487c8af_b.jpg&quot; data-rawwidth=&quot;753&quot; data-rawheight=&quot;177&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-8d42dc930e38d456f2cdac5cb487c8af_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;753&quot; data-rawheight=&quot;177&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-8d42dc930e38d456f2cdac5cb487c8af_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8d42dc930e38d456f2cdac5cb487c8af_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;目前和 vite 兼容或者内置的插件，可以查看&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//vite-rollup-plugins.patak.dev/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;vite-rollup-plugins&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;简单的介绍一下 Rollup 插件，其实插件这个东西，就是 Rollup 对外提供一些时机的钩子，还有一些工具方法，让用户去写一些配置代码，以此介入 Rollup 运行的各个时机之中。&lt;/p&gt;&lt;p&gt;比如在打包之前注入某些东西，或者改变某些产物结构，仅此而已。&lt;/p&gt;&lt;p&gt;而 Vite 需要做的就是基于 Rollup 设计的接口进行扩展，在保证 Rollup 插件兼容的可能性的同时，再加入一些 Vite 特有的钩子和属性来扩展。&lt;/p&gt;&lt;p&gt;举个简单的例子，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rollup/plugins/blob/master/packages/image/src/index.js&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;@rollup/plugin-image&lt;/a&gt; 可以把图片模块解析成 base64 格式，它的源码其实很简单：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;export default function image(opts = {}) {
  const options = Object.assign({}, defaults, opts)
  const filter = createFilter(options.include, options.exclude)

  return {
    name: &#x27;image&#x27;,

    load(id) {
      if (!filter(id)) {
        return null
      }

      const mime = mimeTypes[extname(id)]
      if (!mime) {
        // not an image
        return null
      }

      const isSvg = mime === mimeTypes[&#x27;.svg&#x27;]
      const format = isSvg ? &#x27;utf-8&#x27; : &#x27;base64&#x27;
      const source = readFileSync(id, format).replace(/[\r\n]+/gm, &#x27;&#x27;)
      const dataUri = getDataUri({ format, isSvg, mime, source })
      const code = options.dom
        ? domTemplate({ dataUri })
        : constTemplate({ dataUri })

      return code.trim()
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实就是在 &lt;code&gt;load&lt;/code&gt; 这个钩子，读取模块时，把图片转换成相应格式的 &lt;code&gt;data-uri&lt;/code&gt;，所以 Vite 只需要在读取模块的时候，也去兼容执行相关的钩子即可。&lt;/p&gt;&lt;p&gt;虽然 Vite 很多行为和 Rollup 构建不同，但他们内部有很多相似的行为和时机，只要确保 Rollup 插件只使用了这些共有的钩子，就很容易做到插件的通用。&lt;/p&gt;&lt;p&gt;可以参考 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cn.vitejs.dev/guide/api-plugin.html%23rollup-%25E6%258F%2592%25E4%25BB%25B6%25E5%2585%25BC%25E5%25AE%25B9%25E6%2580%25A7&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Vite 官网文档 —— 插件部分&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt; 一般来说，只要一个 Rollup 插件符合以下标准，那么它应该只是作为一个 Vite 插件:&lt;br/&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;没有使用 moduleParsed 钩子。&lt;/li&gt;&lt;li&gt;它在打包钩子和输出钩子之间没有很强的耦合。&lt;/li&gt;&lt;li&gt;如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Vite 后面的目标应该也是尽可能和 Rollup 相关的插件生态打通，社区也会一起贡献力量，希望 Vite 的生态越来越好。&lt;/p&gt;&lt;h2&gt;比较&lt;/h2&gt;&lt;p&gt;和 Vite 同时期出现的现代化构建工具还有：&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Snowpack&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;Snowpack 和 Vite 比较相似，也是基于 ESM 来实现开发环境模块加载，但是它的构建时却是交给用户自己选择，整体的打包体验显得有点支离破碎。&lt;/p&gt;&lt;p&gt;而 Vite 直接整合了 Rollup，为用户提供了完善、开箱即用的解决方案，并且由于这些集成，也方便扩展更多的高级功能。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;WMR&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;WMR 则是为 Preact 而生的，如果你在使用 Preact，可以优先考虑使用这个工具。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;@web/dev-server&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;这个工具并未提供开箱即用的框架支持，也需要手动设置 Rollup 构建配置，不过这个项目里包含的很多工具也可以让 Vite 用户受益。&lt;/p&gt;&lt;p&gt;更具体的比较可以参考&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cn.vitejs.dev/guide/comparisons.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Vite 文档 —— 比较&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;Vite 是一个充满魔力的现代化构建工具，尤老师也在各个平台放下狠话，说要替代 Webpack。其实 Webpack 在上个世代也是一个贡献很大的构建工具，只是由于新特性的出现，使得它看起来有些落后。&lt;/p&gt;&lt;p&gt;目前我个人觉得，一些轻型的项目（不需要一些特别奇怪的依赖构建）完全可以开始尝试 Vite，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;各种框架、库中的展示 demo 项目。&lt;/li&gt;&lt;li&gt;轻量级的一些企业项目。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也衷心祝福 Vite 的生态越来越好，共同迎接这个构建的新世代。&lt;/p&gt;&lt;p&gt;不过到那个时候，我可能还会挺怀念从前 Webpack 怀念构建的时候，那几分钟一本正经的摸鱼时刻  。&lt;/p&gt;&lt;h2&gt;感谢&lt;/h2&gt;&lt;p&gt;欢迎各路前端豪杰加我 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/017d568dc1d14cd883cc3238350a39ec~tplv-k3u1fbpfcp-watermark.image&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;sshsunlight&lt;/a&gt; 交个朋友，也欢迎随时找我投递简历。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a904351555f90103727304376dc773b5</guid>
<title>万字详解整个数据仓库建设体系</title>
<link>https://toutiao.io/k/ny7vvdw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据仓库的基本概念&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库概念:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;英文名称为Data Warehouse，可简写为DW或DWH。数据仓库的目的是&lt;span&gt;构建面向分析的集成化数据环境，为企业提供决策支持&lt;/span&gt;（Decision Support）。它出于分析性报告和决策支持目的而创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;数据仓库本身并不“生产”任何数据，同时自身也不需要“消费”任何的数据，数据来源于外部，并且开放给外部应用，这也是为什么叫“仓库”，而不叫“工厂”的原因&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本特征:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库是&lt;span&gt;面向主题的&lt;/span&gt;、&lt;span&gt;集成的&lt;/span&gt;、&lt;span&gt;非易失的&lt;/span&gt;和&lt;span&gt;时变的&lt;/span&gt;数据集合，用以支持管理决策。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面向主题:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统数据库中，最大的特点是面向应用进行数据的组织，各个业务系统可能是相互分离的。而数据仓库则是面向主题的。主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;集成性:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对分散、独立、异构的数据库数据进行&lt;span&gt;抽取、清理、转换和汇总&lt;/span&gt;便得到了数据仓库的数据，这样保证了数据仓库内的数据关于整个企业的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与综合，这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;要统一源数据中所有矛盾之处&lt;/strong&gt;，如字段的同名异义、异名同义、单位不统一、字长不一致，等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;进行数据综合和计算&lt;/strong&gt;。数据仓库中的数据综合工作可以在从原有数据库抽取数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图说明一个保险公司综合数据的简单处理过程，其中数据仓库中与“保险” 主题有关的数据来自于多个不同的操作型系统。这些系统内部数据的命名可能不同，数据格式也可能不同。把不同来源的数据存储到数据仓库之前，需要去除这些不一致。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5227765726681128&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSUsp8BHsQC0TaY9027Zniaeib6QiahsNrKU26AOPNhK225rfnyuzoNTVrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;figcaption&gt;数仓主题&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非易失性（不可更新性）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库的数据反映的是一段相当长的时间内&lt;strong&gt;历史数据的内容&lt;/strong&gt;，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据非易失性主要是针对应用而言。数据仓库的用户对数据的操作大多是数据查询或比较复杂的挖掘，一旦数据进入数据仓库以后，一般情况下被较长时间保留。数据仓库中一般有大量的查询操作，但修改和删除操作很少。因此，&lt;strong&gt;数据经加工和集成进入数据仓库后是极少更新的，通常只需要定期的加载和更新&lt;/strong&gt;。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;时变性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库包含各种粒度的历史数据。数据仓库中的数据可能与某个特定日期、星期、月份、季度或者年份有关。数据仓库的目的是通过分析企业过去一段时间业务的经营状况，挖掘其中隐藏的模式。虽然&lt;span&gt;数据仓库的用户不能修改数据，但并不是说数据仓库的数据是永远不变的&lt;/span&gt;。分析的结果只能反映过去的情况，当业务变化后，挖掘出的模式会失去时效性。因此数据仓库的数据需要更新，以适应决策的需要。从这个角度讲，数据仓库建设是一个项目，更是一个过程。数据仓库的数据随时间的变化表现在以下几个方面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）数据仓库的数据时限一般要远远长于操作型数据的数据时限。&lt;br/&gt;（2）操作型系统存储的是当前数据，而数据仓库中的数据是历史数据。&lt;br/&gt;（3）数据仓库中的数据是按照时间顺序追加的，它们都带有时间属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 数据仓库与数据库的区别&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库与数据仓库的区别实际讲的是 &lt;strong&gt;OLTP&lt;/strong&gt; 与 &lt;strong&gt;OLAP&lt;/strong&gt; 的区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作型处理，叫联机事务处理 OLTP&lt;/span&gt;（On-Line Transaction Processing，），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。&lt;strong&gt;用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题&lt;/strong&gt;。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理，像Mysql，Oracle等关系型数据库一般属于OLTP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分析型处理，叫联机分析处理 OLAP&lt;/span&gt;（On-Line Analytical Processing）一般针对某些主题的历史数据进行分析，支持管理决策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要明白，数据仓库的出现，并不是要取代数据库。数据库是面向事务的设计，数据仓库是面向主题设计的。数据库一般存储业务数据，数据仓库存储的一般是历史数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库设计是尽量避免冗余，一般针对某一业务应用进行设计，比如一张简单的User表，记录用户名、密码等简单数据即可，符合业务应用，但是不符合分析。&lt;strong&gt;数据仓库在设计是有意引入冗余，依照分析需求，分析维度、分析指标进行设计&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库是为捕获数据而设计，数据仓库是为分析数据而设计&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以银行业务为例。数据库是事务系统的数据平台，客户在银行做的每笔交易都会写入数据库，被记录下来，这里，可以简单地理解为用数据库记账。数据仓库是分析系统的数据平台，它从事务系统获取数据，并做汇总、加工，为决策者提供决策的依据。比如，某银行某分行一个月发生多少交易，该分行当前存款余额是多少。如果存款又多，消费交易又多，那么该地区就有必要设立ATM了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，银行的交易量是巨大的，通常以百万甚至千万次来计算。事务系统是实时的，这就要求时效性，客户存一笔钱需要几十秒是无法忍受的，这就要求数据库只能存储很短一段时间的数据。而分析系统是事后的，它要提供关注时间段内所有的有效数据。这些数据是海量的，汇总计算起来也要慢一些，但是，只要能够提供有效的分析数据就达到目的了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据仓库，是在数据库已经大量存在的情况下，为了进一步挖掘数据资源、为了决策需要而产生的，它决不是所谓的“大型数据库”&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.  数据仓库分层架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照数据流入流出的过程，数据仓库架构可分为：&lt;strong&gt;源数据&lt;/strong&gt;、&lt;strong&gt;数据仓库&lt;/strong&gt;、&lt;strong&gt;数据应用&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5741556534508077&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSgQcmAC8vsG1DnGHibcjEBqnCdfZjKib459q8VTyQ2cqrpPAZs4Sj8VjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;数据仓库&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库的数据来源于不同的源数据，并提供多样的数据应用，数据自下而上流入数据仓库后向上层开放应用，而数据仓库只是中间集成化数据管理的一个平台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;源数据&lt;/strong&gt;：此层数据无任何更改，直接沿用外围系统数据结构和数据，不对外开放；为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据仓库&lt;/strong&gt;：也称为细节层，DW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据应用&lt;/strong&gt;：前端应用直接读取的数据源；根据报表、专题分析需求而计算生成的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库从各数据源获取数据及在数据仓库内的数据转换和流动都可以认为是ETL（&lt;strong&gt;抽取Extra, 转化Transfer, 装载Load&lt;/strong&gt;）的过程，ETL是数据仓库的流水线，也可以认为是数据仓库的血液，它维系着数据仓库中数据的新陈代谢，而数据仓库日常的管理和维护工作的大部分精力就是保持ETL的正常和稳定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;那么为什么要数据仓库进行分层呢&lt;/strong&gt;&lt;/span&gt;?&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;用空间换时间&lt;/span&gt;，通过大量的预处理来提升应用系统的用户体验（效率），因此数据仓库会存在大量冗余的数据；不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过数据分层管理可以&lt;span&gt;简化数据清洗的过程&lt;/span&gt;，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.  数据仓库元数据的管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;元数据（Meta Date），主要记录数据仓库中模型的定义、各层级间的映射关系、监控数据仓库的数据状态及ETL的任务运行状态&lt;/strong&gt;。一般会通过元数据资料库（Metadata Repository）来统一地存储和管理元数据，其主要目的是使数据仓库的设计、部署、操作和管理能达成协同和一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;元数据是数据仓库管理系统的重要组成部分&lt;/span&gt;，元数据管理是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;构建数据仓库的主要步骤之一是ETL。这时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据仓库的规模及其复杂性离不开正确的元数据管理，包括增加或移除外部数据源，改变数据清洗方法，控制出错的查询以及安排备份等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元数据可分为技术元数据和业务元数据。&lt;strong&gt;技术元数据&lt;/strong&gt;为开发和管理数据仓库的IT 人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。而&lt;strong&gt;业务元数据&lt;/strong&gt;为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个数据仓库系统运行的基础，&lt;span&gt;元数据把数据仓库系统中各个松散的组件联系起来，组成了一个有机的整体&lt;/span&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数仓建模方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库的建模方法有很多种，&lt;span&gt;每一种建模方法代表了哲学上的一个观点&lt;/span&gt;，代表了一种归纳、概括世界的一种方法。常见的有 &lt;strong&gt;范式建模法、维度建模法、实体建模法&lt;/strong&gt;等，&lt;span&gt;每种方法从本质上将是从不同的角度看待业务中的问题&lt;/span&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 范式建模法（Third Normal Form，3NF）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范式建模法其实是我们在构建数据模型常用的一个方法，该方法的主要由 Inmon 所提倡，主要解决关系型数据库的数据存储，利用的一种技术层面上的方法。目前，我们在关系型数据库中的建模方法，大部分采用的是三范式建模法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范式 是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则，而在关系型数据库中这种规则就是范式，这一过程也被称为规范化。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式（4NF）和第五范式（5NF）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据仓库的模型设计中，一般采用第三范式。一个符合第三范式的关系必须具有以下三个条件 :&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个属性值唯一，不具有多义性 ;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个非主属性必须完全依赖于整个主键，而非主键的一部分 ;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个非主属性不能依赖于其他关系中的属性，因为这样的话，这种属性应该归到其他关系中去。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4305694305694306&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSAibYQt6N6JzBkU52pKPXFE5HIhwrdeEKjWc54rvjHs3jSRc1IXqneNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1001&quot;/&gt;&lt;figcaption&gt;范式建模&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Inmon 的观点，数据仓库模型的建设方法和业务系统的企业数据模型类似。在业务系统中，企业数据模型决定了数据的来源，而企业数据模型也分为两个层次，即主题域模型和逻辑模型。同样，主题域模型可以看成是业务模型的概念模型，而逻辑模型则是域模型在关系型数据库上的实例化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 维度建模法（Dimensional Modeling）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度模型是数据仓库领域另一位大师Ralph Kimall所倡导，他的《数据仓库工具箱》是数据仓库工程领域最流行的数仓建模经典。维度建模以分析决策的需求出发构建模型，构建的数据模型为分析需求服务，因此它重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6598639455782312&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSSFd7vMs0OWkc9CBeePTG5CsQjdZjibNtKgXMzvSOF7E5KkmCvaRwkAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;figcaption&gt;维度建模&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;典型的代表是我们比较熟知的星形模型（Star-schema），以及在一些特殊场景下适用的雪花模型（Snow-schema）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度建模中比较重要的概念就是 事实表（Fact table）和维度表（Dimension table）。其最简单的描述就是，按照事实表、维度表来构建数据仓库、数据集市。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前在互联网公司最常用的建模方法就是维度建模，稍后将重点讲解。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 实体建模法（Entity Modeling）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实体建模法并不是数据仓库建模中常见的一个方法，它来源于哲学的一个流派。从哲学的意义上说，客观世界应该是可以细分的，客观世界应该可以分成由一个个实体，以及实体与实体之间的关系组成。那么我们在数据仓库的建模过程中完全可以引入这个抽象的方法，将整个业务也可以划分成一个个的实体，而每个实体之间的关系，以及针对这些关系的说明就是我们数据建模需要做的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然实体法粗看起来好像有一些抽象，其实理解起来很容易。即我们可以将任何一个业务过程划分成 3 个部分，&lt;strong&gt;实体，事件，说明&lt;/strong&gt;，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4356005788712012&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSLlqf8SqfBibvWWF1y5zu3X9NoynJ87iaRtUM67N0Cleiaq4W3zb7VjypA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;figcaption&gt;实体建模&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表述的是一个抽象的含义，如果我们描述一个简单的事实：“小明开车去学校上学”。以这个业务事实为例，我们可以把“小明”，“学校”看成是一个实体，“上学”描述的是一个业务过程，我们在这里可以抽象为一个具体“事件”，而“开车去”则可以看成是事件“上学”的一个说明。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;维度建模&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度建模是目前应用较为广泛的，专门应用于分析型数据库、数据仓库、数据集市建模的方法。数据集市可以理解为是一种&quot;小型数据仓库&quot;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1. 维度建模中表的类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 事实表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生在现实世界中的操作型事件，其所产生的可度量数值，存储在事实表中。从最低的粒度级别来看，事实表行对应一个度量事件，反之亦然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;事实表表示对分析主题的度量&lt;/strong&gt;。比如一次购买行为我们就可以理解为是一个事实。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6738197424892703&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSAcJy4kZsWh7WlId5tWU8NuiciaCbhKEHY9BUibUpIOv2so9V0tt54nSdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;figcaption&gt;事实与维度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中的订单表就是一个事实表，你可以理解他就是在现实中发生的一次操作型事件，我们每完成一个订单，就会在订单中增加一条记录。事实表的特征：表里没有存放实际的内容，他是一堆主键的集合，这些ID分别能对应到维度表中的一条记录。事实表包含了与各维度表相关联的外键，可与维度表关联。事实表的度量通常是数值类型，且记录数会不断增加，表数据规模迅速增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;明细表（宽表）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表的数据中，有些属性共同组成了一个字段（糅合在一起），比如年月日时分秒构成了时间,当需要根据某一属性进行分组统计的时候，需要截取拼接之类的操作，效率极低。如：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;local_time&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2021-03-18 06:31:42&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为了分析方便，可以事实表中的一个字段切割提取多个属性出来构成新的字段，因为字段变多了，所以称为宽表，原来的成为窄表&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将上述的&lt;code&gt;local_time&lt;/code&gt;字段扩展为如下6个字段：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;year&lt;/th&gt;&lt;th&gt;month&lt;/th&gt;&lt;th&gt;day&lt;/th&gt;&lt;th&gt;hour&lt;/th&gt;&lt;th&gt;m&lt;/th&gt;&lt;th&gt;s&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2021&lt;/td&gt;&lt;td&gt;03&lt;/td&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;06&lt;/td&gt;&lt;td&gt;31&lt;/td&gt;&lt;td&gt;42&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又因为宽表的信息更加清晰明细，所以也可以称之为明细表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2．维度表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个维度表都包含单一的主键列。维度表的主键可以作为与之关联的任何事实表的外键，当然，维度表行的描述环境应与事实表行完全对应。维度表通常比较宽，是扁平型非规范表，包含大量的低粒度的文本属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度表示你要对数据进行分析时所用的一个量，比如你要分析产品销售情况， 你可以选择按类别来进行分析，或按区域来分析。每个类别就构成一个维度。事实表的图中的用户表、商家表、时间表这些都属于维度表，这些表都有一个唯一的主键，然后在表中存放了详细的数据信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的说来，在数据仓库中不需要严格遵守规范化设计原则。因为数据仓库的主导功能就是面向分析，以查询为主，不涉及数据更新操作。&lt;strong&gt;事实表的设计是以能够正确记录历史信息为准则，维度表的设计是以能够以合适的角度来聚合主题内容为准则&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 维度建模三种模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 星型模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;星形模式(Star Schema)是最常用的维度建模方式。&lt;strong&gt;星型模式是以事实表为中心，所有的维度表直接连接在事实表上，像星星一样&lt;/strong&gt;。星形模式的维度建模由一个事实表和一组维表成，且具有以下特点：a. 维表只和事实表关联，维表之间没有关联；b. 每个维表主键为单列，且该主键放置在事实表中，作为两边连接的外键；c. 以事实表为核心，维表围绕核心呈星形分布；&lt;img data-ratio=&quot;0.7385964912280701&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSiaqZeBQv6HJdTMxfnTqiauJrkZ1BALrJANyql3DoTIuRVH46ke3uXuNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 雪花模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雪花模式(Snowflake Schema)是对星形模式的扩展。&lt;strong&gt;雪花模式的维度表可以拥有其他维度表的&lt;/strong&gt;，虽然这种模型相比星型更规范一些，但是由于这种模型不太容易理解，维护成本比较高，而且性能方面需要关联多层维表，性能也比星型模型要低。所以一般不是很常用&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6590604026845638&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSHCTWDvKM80k5llibiapp2SDftmTzkQCXnnjOYqlsc1OpYDsHkRSBjVww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;figcaption&gt;雪花模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3．星座模式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;星座模式是星型模式延伸而来，星型模式是基于一张事实表的，而&lt;strong&gt;星座模式是基于多张事实表的，而且共享维度信息&lt;/strong&gt;。前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在&lt;span&gt;业务发展后期，绝大部分维度建模都采用的是星座模式&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5879043600562588&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSPnNbhfv2fnuq3CctdicEjX6FxfSr6q6UiaJriaUAgxfa17A2OGic2EeoVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;figcaption&gt;星座模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3. 维度建模过程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道维度建模的表类型有事实表，维度表；模式有星形模型，雪花模型，星座模型这些概念了，但是实际业务中，给了我们一堆数据，我们怎么拿这些数据进行数仓建设呢，数仓工具箱作者根据自身60多年的实际业务经验，给我们总结了如下四步，请务必记住！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓工具箱中的维度建模四步走：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.606060606060606&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSvrQvIb7t0iciaWYxBnwia3OpkpeI9t5oUzNuUuiaIEdlQxxppJCdUQrzPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;231&quot;/&gt;&lt;figcaption&gt;维度建模四步走&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请&lt;strong&gt;牢记&lt;/strong&gt;以上四步，不管什么业务，就按照这个步骤来，顺序不要搞乱，因为这四步是环环相扣，步步相连。下面详细拆解下每个步骤怎么做&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、选择业务过程&lt;/strong&gt;&lt;br/&gt;维度建模是紧贴业务的，所以必须以业务为根基进行建模，那么选择业务过程，顾名思义就是在整个业务流程中选取我们需要建模的业务，根据运营提供的需求及日后的易扩展性等进行选择业务。比如商城，整个商城流程分为商家端，用户端，平台端，运营需求是总订单量，订单人数，及用户的购买情况等，我们选择业务过程就选择用户端的数据，商家及平台端暂不考虑。业务选择非常重要，因为后面所有的步骤都是基于此业务数据展开的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、声明粒度&lt;/strong&gt;&lt;br/&gt;先举个例子：对于用户来说，一个用户有一个身份证号，一个户籍地址，多个手机号，多张银行卡，那么与用户粒度相同的粒度属性有身份证粒度，户籍地址粒度，比用户粒度更细的粒度有手机号粒度，银行卡粒度，存在一对一的关系就是相同粒度。为什么要提相同粒度呢，因为维度建模中要求我们，在&lt;strong&gt;同一事实表&lt;/strong&gt;中，必须具有&lt;strong&gt;相同的粒度&lt;/strong&gt;，同一事实表中不要混用多种不同的粒度，不同的粒度数据建立不同的事实表。并且从给定的业务过程获取数据时，强烈建议从关注原子粒度开始设计，也就是从最细粒度开始，因为原子粒度能够承受无法预期的用户查询。但是上卷汇总粒度对查询性能的提升很重要的，所以对于有明确需求的数据，我们建立针对需求的上卷汇总粒度，对需求不明朗的数据我们建立原子粒度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、确认维度&lt;/strong&gt;&lt;br/&gt;维度表是作为业务分析的入口和描述性标识，所以也被称为数据仓库的“灵魂”。在一堆的数据中怎么确认哪些是维度属性呢，如果该列是对具体值的描述，是一个文本或常量，某一约束和行标识的参与者，此时该属性往往是维度属性，数仓工具箱中告诉我们&lt;strong&gt;牢牢掌握事实表的粒度，就能将所有可能存在的维度区分开&lt;/strong&gt;，并且要&lt;strong&gt;确保维度表中不能出现重复数据，应使维度主键唯一&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、确认事实&lt;/strong&gt;&lt;br/&gt;事实表是用来度量的，基本上都以数量值表示，事实表中的每行对应一个度量，每行中的数据是一个特定级别的细节数据，称为粒度。维度建模的核心原则之一&lt;strong&gt;是同一事实表中的所有度量必须具有相同的粒度&lt;/strong&gt;。这样能确保不会出现重复计算度量的问题。有时候往往不能确定该列数据是事实属性还是维度属性。记住&lt;strong&gt;最实用的事实就是数值类型和可加类事实&lt;/strong&gt;。所以可以通过分析该列是否是一种包含多个值并作为计算的参与者的度量，这种情况下该列往往是事实。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实际业务中数仓分层&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓分层要结合公司业务进行，并且需要清晰明确各层职责，要保证数据层的稳定又要屏蔽对下游影响，一般采用如下分层结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41845764854614415&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSNouOT3mnKPNzho7JqziaZ9G4QvRChVgteNoumPXghKZdMj83Z7gHIsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;figcaption&gt;数据分层架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;数据层具体实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用四张图说明每层的具体实现&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7231543624161074&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgS1hkv9ibJgDkc1ibhhLjK5wEGoGo9fME275uTEzcC2TJ75LzEkMDIRrsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;figcaption&gt;数据源层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据源层主要将各个业务数据导入到大数据平台，作为业务数据的快照存储。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.66728280961183&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgS3ibKQAKTx0X6h850g6iaZ1BZjlEcUptd8NC5YicAgINVh06QcuyQCKKJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;figcaption&gt;数据明细层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表中的每行对应一个度量，每行中的数据是一个特定级别的细节数据，称为粒度。要记住的是&lt;strong&gt;同一事实表中的所有度量必须具有相同的粒度&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度表一般都是单一主键，少数是联合主键，注意维度表不要出现重复数据，否则和事实表关联会出现&lt;strong&gt;数据发散&lt;/strong&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候往往不能确定该列数据是事实属性还是维度属性。记住&lt;strong&gt;最实用的事实就是数值类型和可加类事实&lt;/strong&gt;。所以可以通过分析该列是否是一种包含多个值并作为计算的参与者的度量，这种情况下该列往往是事实；如果该列是对具体值的描述，是一个文本或常量，某一约束和行标识的参与者，此时该属性往往是维度属性。但是还是要结合业务进行最终判断是维度还是事实。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5763993948562783&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSZc4zIxiac4opLMDxdPIII38Bqk5Fry2oyQGE5XSibgZzCmwBtP0F1AqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;figcaption&gt;数据轻度汇总层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此层命名为轻汇总层，就代表这一层已经开始对数据进行汇总，但是不是完全汇总，只是对相同粒度的数据进行关联汇总，不同粒度但是有关系的数据也可进行汇总，此时需要将粒度通过聚合等操作进行统一。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4713656387665198&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zE5iaxpss0PTFDecPH0qXOgSvoJs9NuNwQXicwEPQGcbYz2sWNJ9WEymhczUB0tXSXEibdLem5Ah7ILw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;figcaption&gt;数据应用层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据应用层的表就是提供给用户使用的，数仓建设到此就接近尾声了，接下来就根据不同的需求进行不同的取数，如直接进行报表展示，或提供给数据分析的同事所需的数据，或其他的业务支撑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术是为业务服务的，业务是为公司创造价值的，离开业务的技术是无意义的。所以数仓的建设与业务是息息相关的，公司的业务不同，数仓的建设也是不同的，只有适合的才是最好的。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU2MDYzOA==&amp;amp;mid=2247484240&amp;amp;idx=1&amp;amp;sn=c02e7ede2183e8cf9779e79b6c2f21f8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;结合公司业务分析离线数仓建设&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU2MDYzOA==&amp;amp;mid=2247483716&amp;amp;idx=1&amp;amp;sn=65cd82671c52cb80937d024549e25601&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;数仓建设中最常用模型--Kimball维度建模详解&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.0030211480362537764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPia3RFX6Mvw06kePJ7HbmI7b35o17yNJx4WHYPSQj280IElEicRPq2CviaJe8fjL2AeadmIjARqVZWnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;662&quot; data-backw=&quot;578&quot; data-backh=&quot;2&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2MzU2MDYzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFt9bNEoZic9Nc7JickzYKsp3tvxRZUE1ibhEPW4HwQvTe7esC7KQRoBoTdFyiaG9UhxgibzkxRDyibrKyQ/0?wx_fmt=png&quot; data-nickname=&quot;五分钟学大数据&quot; data-alias=&quot;LearnBigdata&quot; data-signature=&quot;专注于大数据领域研究，包括 Hadoop、Flink、Spark、Kafka、Hive、HBase 等，深入大数据技术原理，框架的使用，前沿大数据技术&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;引导&quot; data-mpa-template-id=&quot;6710&quot;&gt;&lt;section data-mpa-category=&quot;引导&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;    扫描二维码&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;   收获更多技术&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;五分钟学大数据&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;120&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;120&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZubDbBye0zHo5ICR7ia2IAFRuQhnq3AfhnzfXwmHuJNZownrjcpWPHK77tGHw9NbnV5keRXVy5mpwSaabwN6icwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;引导&quot; data-mpa-template-id=&quot;6839&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;点个&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;，支持一下&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21a7d24f5703a2f6c3213dfe01bbbfb3</guid>
<title>你可能并不懂 Apache Pulsar 的消息存储模型</title>
<link>https://toutiao.io/k/6lglrtb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.062037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VPqFa28cf5cfZGmgkE9kiaPl2gsh3WliaIHqiaz1L1q5ibm4nPq0qGfVaYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VNGBu6tl4JshCKKmP4GXjnsDic1jCibPDKjlEcYwX76ZwI9z1g7E9ceTA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;Apache Pulsar 是 Apache 软件基金会顶级项目，是下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VNGBu6tl4JshCKKmP4GXjnsDic1jCibPDKjlEcYwX76ZwI9z1g7E9ceTA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;冉小龙&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;腾讯云微服务产品中心研发工程师&lt;br/&gt;Apache Pulsar Committer&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache BookKeeper Contributor&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VMyfcZe6YIWgvMgWRqbeWLwWwxBZ5lBRrchRzT1kFIwkdO3CofC2WOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Apache Pulsar 系列第一篇文章为读者们详细解释了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247488014&amp;amp;idx=1&amp;amp;sn=2253357aff20a07a195dd89dbd27c9d0&amp;amp;chksm=9b41ea3dac36632b105337d25e558df2866fdb056194a818b587af20b1114b57a668a9562211&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Pulsar 的消息保留和过期策略&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Pulsar 的消息保留和过期策略&lt;/a&gt;，&lt;span&gt;本文是系列&lt;/span&gt;第二篇，主要从 Pulsar 设计的原理以及在 BookKeeper 中如何存储做一个梳理。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在社区中，我们经常可以看到用户有关 Backlog，storage size 和 retention 等策略的困惑，比较常见的一些问题，诸如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我没有设置 Retention 策略，为什么通过 topics stats 可以查看到 storage size 远大于 backlog size？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我的 msg backlog size 很小，但是 storage size 确一直在增长？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;…&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VMyfcZe6YIWgvMgWRqbeWLwWwxBZ5lBRrchRzT1kFIwkdO3CofC2WOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Pulsar 的消息模型&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;首先，我们先来看一下 Pulsar 的消息模型&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VQWmYAVibt2iacbkkDg4IGBKsOC0VaSYVicdBHQN4flaSBYIAk7CesVSUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上图所示，Pulsar 提供了最基本的 pub-sub 的处理模型。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Producer&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;首先 Producer 端生产消息，将消息以 append 的形式追加到 Topic 中，这里具体分发到哪一个 Topic 中，根据消息是否设置了 msg key 会有所不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在消息分发的模型中，Pulsar 与 Kafka 类似。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Consumer&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在 Consumer 之外，Pulsar 抽象了一层订阅层，用于订阅 Topic。通过订阅层的抽象，Pulsar 可以灵活的支持 Queue 和 Streaming 这两种类型的消息队列。每一个 sub 都可以拿到这个 Topic 中所有数据的完整 copy，有点类似 Kafka 中的 consumer group。根据订阅类型的不同，每一个订阅下面可以有一个或者多个 Consumer 来接收消息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前，Pulsar 支持如下四种消息订阅模型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Exclusive&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Failover&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Shared&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Key_Shared&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VMyfcZe6YIWgvMgWRqbeWLwWwxBZ5lBRrchRzT1kFIwkdO3CofC2WOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;存储模型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;消息在每个 Partition Topic 的分布式日志中只存储一次&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这就意味着，当 Producer 成功发送消息到 Topic 之后，这个消息只会在存储层存储一次，无论你有多少个 Subscription 订阅到这个 Topic 中，实际上操作的都是同一份数据。基于这个基础，我们可以看到 Apache Pulsar 从上到下的层级抽象概念如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4842593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VO2VmLgpR32wPORibJXH26Lro6ic01gxwxH0CZnV9onvA2NpWkmBVfuibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;首先第一层抽象是 Topic（Partition），用来存储 Producer 追加的 messages 信息，Topic 之下对应的是一个个的 ledger，ledger 里面又划分为一个个的分片，在一个个的分片中存储了更小粒度的 ertries，entries 中存储的是 【一条】或者 【一个 batch】 的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么需要做分层抽象呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里最直白的解释其实就是，为了确保数据被在每一个 bk 节点中打的足够散，分布的足够均匀。这也是分层分片架构设计的好处之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ack 机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Pulsar 中支持了两种 Ack 的机制，分别是单条 Ack 和批量 Ack。单条 Ack（AckIndividual）是指 Consumer 可以根据消息的 messageID 来针对某一个特定的消息进行 Ack 操作；批量 Ack（AckCumulative）是指一次 Ack 多条消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;订阅机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了更好的理解 Strorage Size 以及 Backlog， 我们首先需要去了解 Pulsar 中的订阅机制，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7916667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VkIXP2xicVBiby91cW2TZzdialhicPysj791kQNxiaH97RaFRcXicSrjBdmlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当有消息积压时，你可以通过 clear-backlog 来清除积压的消息。清除 backlog 中积压的消息是相对危险的操作，所以系统会提示你，是否确认要删除 backlog 中的消息， clear-backlog 提供了 -f(--force) 的参数来屏蔽该提示。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Producer 还是按照追加的形式不断往 Topic 中发送消息，Consumer 端会创建一个 Subscription 去订阅这个 Topic，当成功订阅时，会初始化一个 Cursor 指向具体的消息的位置，默认情况下是 Latest。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Cursor 是用来存储一个订阅中消费的状态信息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上图中，我们可以看到该订阅下面的 Topic 已经成功 Receive 并且 Ack 掉了 m4 这条消息。那么包含 m4 在内的所有的消息状态都会被标记为可删除的状态。在 Pulsar 中，使用 MarkDeletePosition 来标记这个位置。之后的所有消息，代表这个订阅还没有消费的消息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着时间的推移，假设在 AckCumulative 的场景下，上述订阅中的 Consumer 又消费了一些消息，目前 Cursor 的位置移动到了 m8 的位置，意味着 m8 之前的消息都可以进入删除状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4842593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VQ71S3aicKxPbZfolPicGxKxEDAuHjcP3qtMKJ1mukibiaNkKvDwaFte3zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;假设是在 AckIndividual 的场景下，上述订阅中的 Consumer 只消费了 m7 这条消息并且发送了 Ack 请求，m5, m6 这两条消息仍然没有被成功消费，那么目前处于可删除状态的消息是 m4 之前的消息和 m7 这条消息。也就是说，在这种场景下，由于使用单条 Ack 导致 Topic 中间出现了 Ack 的空洞。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Cursor = Offset + IndevidualDeletes, Ack 会触发 Cursor 的移动，但是不会删除任何消息&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4722222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6ViaG7VdvzA1TjjFIz6UxcQs4T2T1O8HM68sHibErBUicq6VekD0YbHssyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着时间的推移，在单条 Ack 的场景下，Ack 的空洞可能会自己消失，如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4453704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6Vs50d0KAXuPmNEe6rd9iaGPQvh0S0qlftwc0arMjFWqBib7V4Yxs3BbwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面我们描述了，单个订阅在单条 Ack 和批量 Ack 混合的场景下，Topic 中 cursor 的移动情况。假设目前有多个 Subscription 订阅了这个 Topic，那么每一个 Subscription 都可以拿到这个 Topic 中数据的完整 Copy，也就是一个 Subscription 会在这个 Topic 中初始化一个新的 Cursor， 每一个 Cursor 之间消费的进度是没有交集、互不影响的，所以就可能出现下图中的情况：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.687037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VHuVte1073DrtwrblMvj6h5fgSSGfnjN6P8Nmx2gkweM1BzNYSQ5J2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在上图中，针对该 Topic，有两个订阅：Subscription-1 和 Subscription-2。Subscription-1中的 Consumer 消费掉了 m4 之前的消息，Subscription-2 中的 Consumer 消费掉了 m8 之前的消息。而 m4-m8 之间的这四条消息，虽然被 Subscription-2 消费完成，但是 Subscription-1 还没有消费完成这部分数据，所以这部分消息还不可以被删除。目前处于可删除状态的消息是 m4 之前的消息，即这个 Topic 中消费进度最慢的那个 Subscription 所消费完成的消息。那么这就会有一个问题，假设我目前 Subscription-1 掉线了，它的 Cursor 的位置一直没有变化，这就会导致这个 Topic 中的数据一直处于不可删除的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述场景，Pulsar 引入了 TTL 的概念，即允许用户设置 TTL 的时间，当消息到达 TTL 指定的阈值 Cursor 仍然没有移动的话，那么会触发 TTL 的机制，将 Cursor 自动向后移到指定的位置。在这里需要注意的一点是，我们一直强调的是 TTL 会移动 Cursor 的位置，到目前为止，我们还没有提到消息删除的概念，不要将二者混淆了。TTL 会做的只是去移动 Cursor 的位置，不会有任何跟消息删除的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Backlog&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;为了更好的表述 Topic 中没有被消费的数据，Pulsar 引入了 Backlog 的概念来描述这一部分消息。Backlog 可以分为如下两种形式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示：Backlog A 属于 Topic Backlog；Backlog A 属于 Subscription-1 Backlog；Backlog B 属于 Subscription-2 的 Backlog。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6990741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6V6VexoAU41K5KMqHH8lqroHBtxfeDzopMR7kYXfycWBr3fg53HjtcBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着时间的推移，Backlog 的会不断的变化，如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VmdbX8kZ7dRQCp6YHfB0jov4JvNpYNJBMIq9PxfpEPVgPcc4QibicrMng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在这里需要说明的一点是，这里的 backlogSize 记录的是带 batch 的消息，也就是一个 batch 会被当作一条消息来进行处理。因为在 broker 端去解析整个 batch 会给 broker 带来一定的负担，同时浪费大量的 CPU 资源，所以，具体 batch 逻辑的解析放到了 Consumer 端来进行处理。所以 Backlog 本质上记录的是上面我们提到的 entries 的数量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Pulsar 中，针对 Backlog 有两个指标，具体如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Retention 机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 Apache Pulsar 中，使用了 BookKeeper 来作为存储层，允许用户将消息持久化，为了确保消息不会无限期的持久化下去，Pulsar 引入了 Retention 的机制，允许用户来配置消息持久化的策略。默认情况下，持久化的机制是关闭的，即消息被 Ack 之后，就会进入删除的逻辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;配置 Retention 策略时，有如下两个参数可以指定：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在引入 Retention 策略之后，整个 Topic 表示的视图如下所示，m0-m5 代表已经被所有订阅确认的消息并且已经超过了 Retention 策略的阈值，即这些消息正在&lt;strong&gt; 准备删除&lt;/strong&gt;。注意，我这里描述的是 【准备删除】具体是否可以被删除，现在还不能确定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VIRUJ4iciaEbrC3vXHTEdYAibAhvFXiaibCZD8eg2BiaU18rdNWAictBXsjUwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在最开始，我们从最上层的 Topic 一步步抽象到了一条具体的 msg，（在这里为了方便描述，我们忽略掉 batch 的概念，即一条 msg 等价于一个 entry）现在我们再反过来把所有的概念都叠加回去。因为在 bk 中，允许操作的最小的单元是一个 segment，所以在具体的 msg（entry）级别，是没办法针对一条消息进行删除的，删除操作需要针对一个 segment 来进行操作。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设 m0-m3 属于 segment3；m4-m7 属于segment2；m8-m11 属于 segment1。按照上图的描述，m0-m5 的消息都可以进行删除操作, 但是 segment 2 中包含了 m6, m7 并没有达到 Retention 的阈值，所以 segment 目前还不可以被删除。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Storage Size&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了更方便的表述当前消息占用的存储空间的大小，Pulsar 引入了 storageSize 来描述整个概念。如下图所示：当 backlog B 与 storage Size 标识的消息相同时，backlogSize 等价于 storageSize。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5064815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VwshDV8c9VgddQPJruKh6YbPUJOwaicCYib1DKlsk0HC6x4p2ic9TzQhTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当由于引入单条 Ack，Retention 策略以及 Bookkeeper 基于 segment 删除的设定，那么很有可能造成 Storage Size 大于 backlog Size 的场景，如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VgZkGjVPtZLYmpkQ8RgO6aMWFCP6jctgNE4lJFmK1qoKTqtxic1J6zvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6VMyfcZe6YIWgvMgWRqbeWLwWwxBZ5lBRrchRzT1kFIwkdO3CofC2WOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;消息在每个 Partition Topic 的分布式日志中只会存储一次&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Cursor 是用来存储一个订阅下 Consumer 的消费状态的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Cursor 等价于 offset（kafka）+ individualDeletes&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Ack 会去更新 Topic 中 Cursor 的位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当某条消息被所有订阅者都 Ack 之后，这条消息进入【可以被删除】的状态&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所有没有被确认的消息会一直保存在 Subscription backlog 中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TTL 可以通过设定一个时间阈值来自动更新 Cursor 的位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Retention 策略是用来操作那些被 Ack 之后的消息应该怎么处理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消息的删除是以 segment 为单位的，而不是 entry。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247488014&amp;amp;idx=1&amp;amp;sn=2253357aff20a07a195dd89dbd27c9d0&amp;amp;chksm=9b41ea3dac36632b105337d25e558df2866fdb056194a818b587af20b1114b57a668a9562211&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《生存还是毁灭？一文带你看懂 Pulsar 的消息保留和过期策略》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487976&amp;amp;idx=1&amp;amp;sn=9832050a54dc371d206b3f61de985cd6&amp;amp;chksm=9b41e9dbac3660cd9c07948999329a03442e57887ec1787cc6b90b1064b814fb493d347966cc&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一天，把 Pulsar 客户端的性能提升3倍+！》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487956&amp;amp;idx=1&amp;amp;sn=66c4bc8c232249f21caf933fcf1e4b44&amp;amp;chksm=9b41e9e7ac3660f1b763b85c33dfeb9be0e054486369f4c5ba36944abec49a103f763dd2789e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《超有料！万字详解腾讯微服务平台 TSF 的敏捷开发流程》&lt;/a&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAy6YtoR9oqAAAAAstQy6ubaLX4KHWvLEZgBPE54N4EFcEc-j_zNPgMItMtsqNiItQW6qqsI1PHwB9&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=RBfjicXSHKCOONJnTbRmmlD8cOQPXE48ibLwtibjm6uFJWfMz9DoRUMrDBtaziaAkQkcD6WISEeiagM7tVDRsv0flyb7LlvmBsjrqec00oh1ZWKG3MkgOPsqheTIZ1VcqPHE6EMaPSDTZ2EtqG6dQoIQ0QuiaYbSP5fQfgBRzmSDLH3GY&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=dab8c546c81d96608593d16b9074581d&amp;amp;token=cztXnd9GyrGPFuk1kLtjFwnWebLRHQVvv9sTxicdR29RQRSY8wszjCndLiaVNLxSOC&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/5ZQ3V8nVdKrBjvNlmkqvtE95icWM8ic4khGvb8G6lBAHxDzicdXm24gew/0&quot; data-username=&quot;v2_060000231003b20faec8c5e68011c3d3c905e832b077b4e1c05a41078cad0ecfbcb4a7bb918c@finder&quot; data-nickname=&quot;腾讯云中间件&quot; data-desc=&quot;腾讯云中间件，面对疾风吧！#吐槽大会#腾讯#中间件#互联网#腾讯云@腾讯云中间件 &quot; data-nonceid=&quot;1117874693651196529&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7083333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6Vdteua8DNG9BwzYnaia3RyjVxUhqhN58PatEwg6SoSSvdLD9UD3xzm1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;扫描下方二维码关注本公众号，&lt;/p&gt;&lt;p&gt;了解更多微服务、消息队列的相关信息！&lt;/p&gt;&lt;p&gt;解锁超多鹅厂周边！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5560488&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXLmia0GjyU6GAZSOJdcCf6ViaARGhYSZk1S84rDPOhd3KcdicfsjOmickvdQtVa0N8nNyaKWr1LVne4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yqVAqoZvDibHW4ynpBjRrolMxOZtKTiaYgT0HG1BkTeIUjfS0zrwEYVMy6Fj54m58z6pH9yWNOnFkbflRtKVicx0w/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳原文，了解更多消息队列TDMQ的信息&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0740740740740742&quot; data-type=&quot;png&quot; data-w=&quot;81&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7QRTvkK2qC5ricrpxA0Tln6U4mt6c9God8owkFMgicqnvogW8znAX84Syp3PSlsnkPKnE2n4ZyZs8E73qZj6XgyA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;点亮&lt;span&gt;在看&lt;/span&gt;，你最好看&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>