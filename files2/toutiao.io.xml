<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7773431d320b28c83dfe8ceb68a515f8</guid>
<title>开源微服务 API 网关，单核 2 万 QPS，今年最值得学习的开源项目</title>
<link>https://toutiao.io/k/vo7i0r2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>64cab4c9b005f164327fc80a606589e1</guid>
<title>亿级流量系统架构演进之路</title>
<link>https://toutiao.io/k/nmwgk0i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;海量用户同时进行高频访问对任何平台都是难题，也是行业乐此不疲的研究方向。但值得庆幸的是，虽然业务场景不同，设计和优化的思想却是万变不离宗。本文将结合业务与高并发系统设计的核心技术点，对系统架构调优方案进行深度剖析。&lt;/p&gt;&lt;blockquote&gt;文章根据 Authing 身份云高级工程师罗杰林，在又拍云 Open Talk 技术沙龙北京站所作主题演讲《亿级流量系统架构演进之路》整理而成，现场视频及 PPT 可下拉文末点击阅读原文查看。&lt;/blockquote&gt;&lt;p&gt;相信大家都同意，互联网发展势头的逐渐凶猛改变了我们很多的生活方式。比如网购、银行转账等业务，不再需要我们必须线下办理，这极大方便了我们的生活。这背后当然也对身为互联网从业人员的我们来说，面临的考验也越来越大，在系统架构升级上也会倾注更大的心血。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;认识高并发系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;高并发系统拥有高并发、高性能、高可用，分布式、集群化，安全性等特性。&lt;/p&gt;&lt;p&gt;我们首先来看一下高并发、高性能、高可用，也就是我们经常提到的三高系统。当我们流量非常大的情况下，我们一定要保证这三高。这其中高并发是指要支持很多并发用户，高性能是在高并发的前提下保证优秀的性能，高可用则是保证系统在某一节点出现问题时不会整体宕机且继续持续提供服务。由此可见三高的主要特性则是分布式和集群化，而我们主要要解决的问题则是安全性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e106515130f484c08c6e14bb762d074c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1092&quot; data-rawheight=&quot;687&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e106515130f484c08c6e14bb762d074c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1092&quot; data-rawheight=&quot;687&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e106515130f484c08c6e14bb762d074c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e106515130f484c08c6e14bb762d074c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是一些常见的与我们生活息息相关的高并发场景。左上电商秒杀是最常见的场景了，去年疫情期间口罩紧缺抢口罩就是这个场景，很多人在一个统一的时间去点击同一个页面，这个的并发数是特别高的。右上则是抢票，这个大家也很熟悉了，特别是春节需要回家的在外地工作的朋友们，肯定都是开个抢票软件一直刷给自己抢票的，这种的并发流量特别大。左下则是银行交易系统，我们所有的线上、线下扫码其实都需要通过银行系统，这就让它的日交易量极大。最后是 Authing 身份证，我们主要是给用户做整套的身份认证和用户管理体系，这个体系让开发者避免了重复构建身份的操作，减少了开发者编写的代码，提高他们的效率。以下图作为例子：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bfce5f82da75d59991a80c88fa2454a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;879&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfce5f82da75d59991a80c88fa2454a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;879&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfce5f82da75d59991a80c88fa2454a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bfce5f82da75d59991a80c88fa2454a7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;图中展示的是我们的核心组件，表面上看是一个简单的登录框，也就是用户认证界面，但是其背后有一个庞大的由用户体系、管理体系、认证体系等一系列服务组成的后台支撑。尽管用户只是进行了用户名和密码的输入，但是我们要考虑到的不仅仅是用户的安全认证、多种登录方式，还有很多用户同时认证时要如何处理等等多种事项。除此之外，我们还需要考虑到如何让包括私有化用户在内的多种类型的客户实现高可用和快速部署，完成快速集成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2bee968a9431386077553a9d6427287b_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;638&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-2bee968a9431386077553a9d6427287b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;728&quot; data-rawheight=&quot;638&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-2bee968a9431386077553a9d6427287b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2bee968a9431386077553a9d6427287b_b.jpg&quot;/&gt;&lt;figcaption&gt;△ CPA 理论&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果有做高并发的朋友，对于 CAP 理论一定不陌生。它的主要观点是分布式系统无法同时满足三个，只能够满足其中两个。即分布式系统要么满足 CA，要么满足 CP，但无法同时满足CAP。其中的意思是说如果满足了可用性和分区的容错性，那可能意味着要牺牲一致性，进而达到最终的数据一致性。它是告诉我们要作出取舍。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;从单体应用架构说起&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3872d4056d14d9b93622523c74c379f7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;636&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3872d4056d14d9b93622523c74c379f7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;636&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3872d4056d14d9b93622523c74c379f7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3872d4056d14d9b93622523c74c379f7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图中示意的单体应用构架是早期常用的模式。早期因为人手紧缺通常会将 Web 和 Server 一起开发再一起部署，之后和数据库连在一起就可以正常提供服务。这么做的优点是维护简单，但是迭代比较麻烦。&lt;/p&gt;&lt;p&gt;现在前后端分离后，我们通常把 Web 和 Server 分开为两个服务部署，为快速迭代提供了便利。如果我们有一个 Server 需要修复，我们可以单独对这个服务进行代码修改和部署，然后快速上线服务。但是它的缺点是随着业务的增多，Server 包含的内容也越来越多，这会让它耦合很深进而导致服务变慢。这一点我深有体会，多年前我有个朋友架构出了问题，有段时间每到周末他会买一袋瓜子来我家一起琢磨。为什么要买一袋瓜子呢？因为耦合的太深了，服务启动要 5 分钟，改一个东西又要等 5 分钟重启，所以我们嗑着瓜子聊天等待。&lt;/p&gt;&lt;p&gt;类似上面提到的依赖复杂、臃肿繁杂是单体应用会遇到的一个问题，除此之外单体应用还有以下问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;单点瓶颈&lt;/li&gt;&lt;li&gt;稳定差&lt;/li&gt;&lt;li&gt;扩展性差&lt;/li&gt;&lt;li&gt;业务模型缺失&lt;/li&gt;&lt;li&gt;新业务扩展差&lt;/li&gt;&lt;li&gt;业务流程基础能力缺乏&lt;/li&gt;&lt;li&gt;前后端耦合严重&lt;/li&gt;&lt;li&gt;API 杂乱难维护&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;既然痛点如此明显，那么如何去优化就很重要。不过在谈这个问题之前需要思考一个新问题——CPU 越多性能就会越好吗？&lt;/p&gt;&lt;p&gt;大多数情况是这样的，因为 CPU 可以提高运算速度。但这不是绝对的，假如我们的程序里有很多锁的概念，那就无法体现出多线程的多核性。那可能 CPU 的多少就不会有显著效果。一般遇到这种情况，许多公司会考虑把服务拆开。这就涉及到成本问题，也就是说增加 CPU 并不是最优解，我们还是需要考虑如何去优化锁。不过思考具体优化前我们可以先了解下池化技术。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-af3167f1fb98d7103d3e0a88b368895b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1268&quot; data-rawheight=&quot;617&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-af3167f1fb98d7103d3e0a88b368895b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1268&quot; data-rawheight=&quot;617&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-af3167f1fb98d7103d3e0a88b368895b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-af3167f1fb98d7103d3e0a88b368895b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是池化技术的抽象概念，一般获取连接以及线程用完后都会放入资源池资源池。同时我们还需要有以下四个概念：连接池、线程池、常量池、内存池。&lt;/p&gt;&lt;p&gt;一般用连接池较多，因为系统之间的调用、请求外部服务时都会通过请求连接来进行。曾经我们使用的是短连接，但是由于 HTTP 的每次连接都需要重复建立和关闭连接的过程，非常耗时，所以现在开始使用连接池。它每次请求完后创建的连接都是重复可用的，非常有助于节省开销。同时我们的任务最后都是需要拆出来的，而那些拆出来的异步任务则都放置在线程池内进行。常量池和内存池的概念是想通的，我们会申请一块大的内存复用。&lt;/p&gt;&lt;p&gt;了解池化技术后，我们回到具体优化。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;应用架构优化&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;Web Server 优化&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42cf6d69ed8ef3721d7a9244cfd39392_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1121&quot; data-rawheight=&quot;634&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-42cf6d69ed8ef3721d7a9244cfd39392_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1121&quot; data-rawheight=&quot;634&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-42cf6d69ed8ef3721d7a9244cfd39392_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-42cf6d69ed8ef3721d7a9244cfd39392_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先来看一下 Web Server 的优化，它主要通过代码优化、热点缓存、算法优化等等步骤实现。&lt;/p&gt;&lt;p&gt;第一步是代码优化，将不合理的代码进行优化。比如查询接口通常都会查询很多内容，使得运算缓慢，这就需要优先进行优化。&lt;/p&gt;&lt;p&gt;第二步是热点缓存，将全部的热点数据进行缓存从而尽可能减少数据库的操作。比如 Authing 身份认证在拿到 token 后不可能每次进行数据库运算，这样 QPS 会非常慢，我们可以通过将热点数据全部缓存来提高 QPS。&lt;/p&gt;&lt;p&gt;第三步是算法优化，因为我们的业务通常都非常复杂，所以这个概念非常广泛。比如查询一个列表，是需要一次性列出全部列表还是在内存中计算完毕后将结果返回给前端呢？这就需要针对不同的业务场景进行优化，从而提高性能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;单独部署&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a430d747e55a22b7cc5e5a36929af03d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a430d747e55a22b7cc5e5a36929af03d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a430d747e55a22b7cc5e5a36929af03d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a430d747e55a22b7cc5e5a36929af03d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;完成单体应用优化后，如果这些服务都部署在同一台服务器上，那可能会出现 CPU 和内存被占用的情况。这时候我们可以把 Web、以及加载完缓存的应用程序拎出来分别部署到一个单独服务器上。同时将静态资源全部存储在 CDN 上，通过就近访问加快页面加载速度。通过这些方式，让我们的 Auting 达到了 50 毫秒内响应的需求。单独部署的方式也非常适合系统之间的需求，无论你是什么业务场景，如果需要提升响应速度，那大家可以考虑这个方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;垂直拆分&lt;/b&gt;&lt;/p&gt;&lt;p&gt;之后我们需要对业务进行拆分。业务拆分有以下三种方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;按照业务场景拆分，比如将用户、订单、账务进拆分。&lt;/li&gt;&lt;li&gt;按照业务是同步还是异步进拆分，这样做的好处是可以很好控制异步流量，不让它影响我们的核心服务运行。&lt;/li&gt;&lt;li&gt;按照模型拆分，因为业务拆分主要是为了解决系统之间耦合严重依懒性问题，为了后期尽量减少系统间的以来，所以前期的模型一定要尽可能的建设好。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在完成系统拆分后，我们需要评判优化后的系统能承载多少业务量，优化了多少。那么我就需要对它进行一次压测。压测会涉及到大家都有所了解的木桶理论，我们将系统比作一个木桶，那么木桶能够承载多少水量取决于最低的那块木板。所以压测时我们不需要关注那些占用资源少的部分，我们要关心那些高的已经达到了系统瓶颈的部分。通过这部分来查找我们系统的潜在问题点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;横向拆分&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-42301fc3b13e366f8c8b75ca8ce69757_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;719&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-42301fc3b13e366f8c8b75ca8ce69757_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;719&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-42301fc3b13e366f8c8b75ca8ce69757_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-42301fc3b13e366f8c8b75ca8ce69757_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在我们将服务进行垂直拆分后，随着请求量逐渐增多可能还是无法满足需求。这时候我们可以将系统进行水平拆分，然后进行水平扩容，一个不够就增加两个甚至更多。同时通过负载均衡的服务器将请求量均匀分给这些水平节点。通常我们会选择使用 NG 来作负载均衡服务器。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3f85938d64e4bafd6dc2d59959f8865d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;594&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3f85938d64e4bafd6dc2d59959f8865d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;594&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3f85938d64e4bafd6dc2d59959f8865d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3f85938d64e4bafd6dc2d59959f8865d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是我们的负载均衡服务器。负载均衡下面会有很多网关系统，我们看到中间有一个 Nginx 集群。我们都知道 Nginx 能够承受的并发量非常大，所以流量小的时候不需要这个集群，需要它的时候一定是并发量非常大的情况。当你的并发量极大，到 Nginx 集群都无法承受的时候，我们最好不要在它的集群前面再放一层 Nginx，因为效果并不明显。同时我个人也不太建议大家选择 F5，因为 F5 是一个硬件，它的成本比较大。我个人建议大家选择 LVS，它是 Linux 下面的一个虚拟服务，如果配置的好，它的性能完全比得上 F5。&lt;/p&gt;&lt;p&gt;说完了负载均衡，我们回到水平拆分。&lt;/p&gt;&lt;p&gt;在进行水平拆分时我们不能忽略缓存问题。在单机模式下缓存都是本地缓存，而当我们成为分布式后，如果有一个服务器拿到 token 并存到本地，另一个服务器就会因为没有拿到而无法通信。因此我们引入分布式缓存，比如将缓存放到 Redis 这种分布式缓存里，让所有应用都请求 Redis 拿缓存。&lt;/p&gt;&lt;p&gt;当我们水平拆分后，还需要关注分布式 ID。因为单体时候生成 ID 的方法可能不适用于分布式服务。以时间戳举例，以前在单体时有，请求我们就生成一个 ID，这是有唯一性的。在分布式情况下多个服务器收到请求可能会生成重复 ID，做不到唯一性。所以我们需要单独做一个 ID 服务来生成 ID。&lt;/p&gt;&lt;p&gt;&lt;b&gt;配置中心&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在我们把服务进行了水平和垂直的拆分后，如何让配置统一同步的配置到每一个服务就成了问题。最好的办法就是当我们修改配置后，让所有服务都同时感知到这个更改，然后自己应用并配置。因此我们引入了配置中心。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bd5592213816ebf3af65badc23a9b2c8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;639&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-bd5592213816ebf3af65badc23a9b2c8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;639&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-bd5592213816ebf3af65badc23a9b2c8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bd5592213816ebf3af65badc23a9b2c8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是配置中心的大体流程，目前比较流行的配置中心方案有两个是，一个是阿里开源的 Nacos，另一个是 Spring Cloud 组建的 Spring Cloud config，感兴趣的朋友们可以了解一下。&lt;/p&gt;&lt;p&gt;接下来我们具体看一下上图。这其中 Server 是存放我们配置的控制台。一般开发者会在控制台通过 API 修改配置，修改后的配置可以持久放置在 Mysql 或其他数据库内。Client 包含了我们所有的应用，在它里面会有一个监听 Server 内是否有配置更改的监听，当有配置更改时则去获取这个配置，这样所有的应用就可以在前端更新后及时更新了。同时为了防止 App 在获取更新时因为网络问题而获取失败的情况，我们会在本地做一个快照，当网络出现问题时，App 可以降级到本地获取文件。&lt;/p&gt;&lt;p&gt;&lt;b&gt;数据库拆分&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们完成了系统的拆分，做好了负载均衡，并完成了配置中心。在请求量不太大的情况下，我们其实已经完成了系统的优化。等到后期业务继续扩张时，我们遇到的瓶颈就不再是系统，而是数据库了。那么要如何解决这个问题呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一种方式是主从复制与读写分离。&lt;/b&gt;读写分离可以解决数据读写全都在一个库上的问题，通过将主从库拆分为 master 和 slave，让写这一环节全部由 master 来处理，将写的压力分摊从而提高数据库性能。之后随着业务量的继续增大，单独的主从复制已经无法满足我们的需求时，我们通过第二种方式来处理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二种方式是进行垂直拆分。&lt;/b&gt;垂直拆分的概念和业务的拆分相似，我们根据服务将数据库拆分为 Users、Orders、Apps 等等，让每一个服务都拥有自己的数据库，避免统一请求从而提升并发性。伴随业务量的继续增长，即便是单独的库也会到达瓶颈，这时我们就需要用到第三种方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三种方式是水平拆分。&lt;/b&gt;比如我们将 Users 这个数据库内的表进一步拆分为 Users1，Users2，Users3 等等多个表。要完成这个拆分我们需要考虑，面对多个表我们在查询时要如何去做的问题。这时我们需要按照我们的具体业务来判断。比如查询用户，我们可以根据用户 ID，将 ID 拆分分片，然后使用哈希算法让他们统一在一定范围内。之后我们每次拿到 Users 就通过哈希来计算具体在哪一片并快速抵达相应位置。Auting 多租户的设计就用到了拆分的概念，如下图所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9c8c858f49b535f705d1ada152ba45e7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;609&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-9c8c858f49b535f705d1ada152ba45e7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;609&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-9c8c858f49b535f705d1ada152ba45e7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9c8c858f49b535f705d1ada152ba45e7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;服务限流&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;等到业务量多到一定程度后我们肯定会涉及到服务限流，这是一个变相的降级策略。虽然我们的理想都是系统能够承受越来越多的用户越来越多的量，但是因为资源总是有限的，所以你必须要进行限制。&lt;/p&gt;&lt;p&gt;&lt;b&gt;请求拒绝&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-333dd6c4ffa901a4473086da042373b6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;633&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-333dd6c4ffa901a4473086da042373b6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;633&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-333dd6c4ffa901a4473086da042373b6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-333dd6c4ffa901a4473086da042373b6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;服务限流有两种主要算法，漏桶算法与令牌桶算法。我们可以看一下上图，它画的比较形象。漏桶算法中我们可以将流量想象成一杯水，在水流流出的地方进行限制，无论水流流入的速度有多快，但是流出速度是一样的。令牌桶则是建立一个发放令牌的任务，让每一个请求进入前都需要先拿到令牌，如果请求速度过快令牌不够用时就采取对应的限流策略。除去这两种算法，一般还会用到大家都很熟悉的计数器算法，感兴趣的朋友也可以去自行了解一下，这里我们就不细谈了。&lt;/p&gt;&lt;p&gt;这几种算法其实本质上都是在流量过量的时候，拒绝过量的部分的请求。而除去这种拒绝式的策略，我们还有一种排队的策略。&lt;/p&gt;&lt;p&gt;&lt;b&gt;消息队列&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们的业务有无法限流、拒绝的情况存在时，我们就需要用到队列消息。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d7e7c3f223acfde7bb8c80ce65eecc67_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;667&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d7e7c3f223acfde7bb8c80ce65eecc67_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;667&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d7e7c3f223acfde7bb8c80ce65eecc67_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d7e7c3f223acfde7bb8c80ce65eecc67_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如图所示，消息队列的主要概念是生产者会将消息放入队列中，由消费者从队列中获取消息并解决。我们通常使用 MQ、Redis、Kafka 来做消息队列。队列负责解决发布/订阅和客户端推拉两个问题，生产者负责解决以下问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;缓冲：为入口处过大的流量设置缓冲&lt;/li&gt;&lt;li&gt;削峰：与缓冲的效果类似&lt;/li&gt;&lt;li&gt;系统解耦：如果两个服务没有依赖调用关系，可以通过消息队列进行解耦&lt;/li&gt;&lt;li&gt;异步通信&lt;/li&gt;&lt;li&gt;扩展：基于消息队列可以做很多监听者进行监听&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;服务熔断&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在业务正常提供服务时，我们可能会遇到下图这种情况：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3b32e2effd2e778f765e82dca6296386_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;373&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-3b32e2effd2e778f765e82dca6296386_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;373&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-3b32e2effd2e778f765e82dca6296386_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3b32e2effd2e778f765e82dca6296386_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;服务 A、B 分别调用服务 C、D，而这两者则都会调用服务 E，一旦服务 E 挂掉就会因为请求堆积而拖垮前面的全部服务。这个现象我们一般称之为服务雪崩。&lt;/p&gt;&lt;p&gt;而为了避免这个情况的发生，我们引入了服务熔断的概念，让它起到一个保险丝的作用。当服务 E 的失败量到达一定程度后，下一个请求就不会让服务 E 继续处理，而是直接返回失败信息，避免继续调用服务 E 的请求堆积。&lt;/p&gt;&lt;p&gt;简单来讲这是一种服务降级，通常的服务降级还有以下几种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;页面降级：可视化界面禁用点击按钮、调整静态页面&lt;/li&gt;&lt;li&gt;延迟服务：如定时任务延迟处理、消息入 MQ 后延迟处理&lt;/li&gt;&lt;li&gt;写降级：直接禁止相关写操作的服务请求&lt;/li&gt;&lt;li&gt;读降级：直接禁止相关读的服务请求&lt;/li&gt;&lt;li&gt;缓存降级：使用缓存方式来降级部分读频繁的服务接口&lt;/li&gt;&lt;li&gt;停服务：关闭不重要的功能，为核心服务让出资源&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;压测&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-205dec075460c52bc0df8400893b6522_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-205dec075460c52bc0df8400893b6522_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;608&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-205dec075460c52bc0df8400893b6522_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-205dec075460c52bc0df8400893b6522_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图就是我们具体压测要关注的东西。首先我们要知道压测其实是一个闭环，因为我们可能会需要重复这个流程很多次，不断地重复发现问题、解决问题、验证是否生效、发现新问题这个过程，直到最终达到我们的压测目标。&lt;/p&gt;&lt;p&gt;在压测开始前我们会制定压测目标，然后依据目标来准备环境。压测模型可以是线上的，也可以是线下。一般线下考虑到成本问题，因此会选择单机或小集群来进行，这可能让结果不太精准，所以通常大家都选择在线上或者机房来进行压测，数据更精准。在压测过程中我们会发现新的问题，然后解决它，并验证结果直到达到压测目标。&lt;/p&gt;&lt;p&gt;在压测的过程中我们需要关注以下几点。首先是 QPS，即每秒查询量。它和 TPS 的区别在于，TPS 有事务的概念，需要完成事务才算一次请求。而 QPS 没有这个概念，它只要查询到结果就算做一次请求。其次是 RT（响应时间），这个需要我们重点关注，而且越是高并发的系统，RT 越重要。之后在压测中我们需要关注系统到底能承载多大的并发数和吞吐量。成功率则是指在压测过程中，当压力越来越大的时候我们的业务是否能按照原计划执行并得到既定结果。GC 则是指垃圾回收，这也是个很大的问题，因为如果我们代码写的不好，那么随着压力的增大 GC 逐渐频繁最终会导致系统停顿。&lt;/p&gt;&lt;p&gt;之后则是硬件方面，需要我们关注 CPU、内存、网络、I/O 的占有率，有一种任意一项卡主就有可能导致一个系统瓶颈。最后是数据库，这里暂不展开细讲。&lt;/p&gt;&lt;p&gt;&lt;b&gt;日志&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在压测过程中发生的问题我们要如何才能知道呢？那就要依靠日志了，它让系统变得可视化，方便我们发现问题的根源。&lt;/p&gt;&lt;p&gt;那日志要如何做呢？这里主要是依靠埋点来完成，比如通过埋点请求进入每一个系统、每一层的时间和响应时间，然后通过这两个时间差看出系统的耗时。由此可以看出只有埋点清晰，才能精准发现问题的所在。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-10a4983927c617b54d84cbf8136c289c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;574&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-10a4983927c617b54d84cbf8136c289c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;574&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-10a4983927c617b54d84cbf8136c289c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-10a4983927c617b54d84cbf8136c289c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是一个比较通用的日志处理方案，每一个服务产生的日志都是通过 Filbeat 收集到 Kafka，然后到 Logstach，最后到 ElasticSearch。其中 Kibana 是一个可视化界面，方便我们分析日志。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-06ff523eb232c14e8e0b88822d401359_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1226&quot; data-rawheight=&quot;733&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-06ff523eb232c14e8e0b88822d401359_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1226&quot; data-rawheight=&quot;733&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-06ff523eb232c14e8e0b88822d401359_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-06ff523eb232c14e8e0b88822d401359_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图是 Auting 的日志和监控系统。中间是 K8S 集群，左边是业务上的消息队列，右边则是我们的监控系统。监控系统我们只要是使用 Grafana 根据业务报警，比如我们会配置当成功率低于多少时就报警的情况。主要的日志系统则是使用 logstash 抽取 log 文件到 ES 内使用 Kibana 查看。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2d4c9444574181393ebac46bf48612d4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1109&quot; data-rawheight=&quot;789&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2d4c9444574181393ebac46bf48612d4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1109&quot; data-rawheight=&quot;789&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2d4c9444574181393ebac46bf48612d4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2d4c9444574181393ebac46bf48612d4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后，我想说的是所有的高可用系统一定不能忘记一个核心概念，那就是异地多活。举例来讲就是我们需要在多地备署多个机房，拥有多地备份和多地容灾。上图是我对上述全部的应用架构优化进行的总结，希望能够为大家提供参考，谢谢。&lt;/p&gt;&lt;p&gt;现场视频、PPT 以及更多 Open Talk 技术干货请戳：&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/opentalk/460.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-afbdec37bdc2d0027d987b8c36520c98_180x120.jpg&quot; data-image-width=&quot;1440&quot; data-image-height=&quot;810&quot; data-text=&quot;亿级流量系统架构演进之路&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>737d6bcc8ed9066fe4b6bc2be2e7fee7</guid>
<title>一个 HTTP 请求进来都经过了什么（2021 版）</title>
<link>https://toutiao.io/k/5xhuidu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;四年前我写过一篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484226&amp;amp;idx=2&amp;amp;sn=cb8df0d23713a8842140963fa2522c56&amp;amp;chksm=fafde9eccd8a60fa7a9ac71d9819da3b16e2995e368a3e5f7404ab202743904f380efa591e53&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个请求过来都经过了什么》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个请求过来都经过了什么》&lt;/a&gt;，这个问题是每隔一段时间我就要重新梳理一遍的。因为每个阶段接触的信息不同，看到的想到的也不同。今天来比较一下与4年前认知上有什么变化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;提出问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;高技术含量开放性面试题驾到：&lt;span&gt;”请描述一个请求过来到响应完成都做了什么，越详细越好。” &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解决问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设立场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;假设我在超市买了我喜爱的经典搭配：烤肠+酸奶。然后我就微信扫码付款了。付款时序图大体是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.734533183352081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwyMoVfkKaltdY7gIqsowo8keN6ic7ibzrHZZWVGq0eo5aNOxU5OXdFUNMMoqkq8g5Z2qol66SA9gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;/p&gt;&lt;p&gt;看的眼晕没关系，和主题关系不大。咱们zoom in（把镜头拉近，只看一部分）一下：&lt;/p&gt;&lt;p&gt;1.1返带订单ID的URL到微信的处理，我不是腾讯的哈，他们内部怎么做的我不知道，这里只是举个例子。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;链路处理流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3200455580865604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibWOZhIhGUzRAS6f1CibTnTUZ40wlbh4GakMGCqWw9uibeVfTW39oA8pcnPmWc4HzvxicAkXNAiaKTBlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，请求从外网过来，到达一个机房。首先要经过外网DMZ区，DMZ区可以简单理解为隔离区。&lt;/p&gt;&lt;p&gt;通过防火墙后，会进入内网DMZ，这个也是一个隔离区。在这个区域，一般会设置蜜罐。蜜罐技术本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;核心交换机：一般公司里会有生产环境、测试环境和办公环境。一般都是走了一个交换机设备将其分离开。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;防火墙：这里的防火墙是策略的加强。生产环境、测试环境和办公环境的防火策略不同。之后可以部署一些与外部通信的设备，比如MQ。&lt;/p&gt;&lt;p&gt;生产云spine交换机和生产云leaf交换机这种架构叫做脊叶网络，是目前公司普遍使用的一种架构。spine是脊梁，就是主干的意思。leaf是叶子的意思，就是分支了。一般一台spine交换机下面会对应几十组leaf交换机，一起进行流量分发。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;F5是负载均衡设备，同时它还可以进行https卸载，就是https转http。关于https可以参考我之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485862&amp;amp;idx=1&amp;amp;sn=414f61b537094b14dab2682a343700e9&amp;amp;chksm=fafde308cd8a6a1e993ed8774cef1c8dc1233761a17b27395b89e3d2c74b0908e0971aeedf9a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《架构师之路-https的底层原理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《架构师之路-https的底层原理》&lt;/a&gt;，普遍评价说是比较好理解。&lt;/p&gt;&lt;p&gt;F5设备怎么卖，处理能力怎么样，我还专门查了一下，截图如下：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35912408759124087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibWOZhIhGUzRAS6f1CibTnTU60icLeVcicq6Uwic2YQQnLp49uXH5mpe69NSs8iasXWujHDrwwUWb1cIYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1370&quot;/&gt;&lt;/p&gt;&lt;p&gt;        咱们看看最贵的：&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;产品概述&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;设备类型&lt;/th&gt;&lt;td&gt;&lt;span&gt;负载均衡器&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;硬件配置&lt;/th&gt;&lt;td&gt;&lt;span&gt;处理器：英特尔四核Xeon处理器（共8个超线程逻辑处理器内核&lt;br/&gt;内存：32GB&lt;br/&gt;硬盘：400GB SSD&lt;span/&gt;&lt;br/&gt;接口：标配8个万兆/千兆位光纤端口，最大32个&lt;br/&gt;硬件SSL：标配4000/Blade，最大10000 TPS(2K keys)，9Gbps批量加密&lt;br/&gt;硬件DDoS保护：每秒40M SYN cookies&lt;br/&gt;高度：4U&lt;br/&gt;服务器缓存：缺省提供内存仿真cache，提供静态页面加速，降低后台服务器压力&lt;br/&gt;电源：标配两个交流100-240 VAC（800W），50/60Hz自动测距，每插槽电流10A（最大），直流电源（可选）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;性能应用概述&lt;/th&gt;&lt;td&gt;&lt;span&gt;每秒L7请求数：1M&lt;br/&gt;每秒L4连接数：400K&lt;br/&gt;每秒L4 HTTP请求数：7M&lt;br/&gt;最大L4并发连接数：24M&lt;br/&gt;L4吞吐量：40Gbps&lt;br/&gt;L7吞吐量：18Gbps&lt;br/&gt;最大软件压缩：10Gbps&lt;br/&gt;软件架构：64位TMOS&lt;br/&gt;虚拟化支持：每个刀片8个，最大4个刀片&lt;br/&gt;支持的虚拟服务器数量 VIP：无限制&lt;br/&gt;Real Server：无限制&lt;br/&gt;IP Version：支持ipv4 和ipv6&lt;br/&gt;协议层保护：提供HTTP（S）,FTP(S)，SMTP等协议层安全&lt;br/&gt;安全的管理：可以通过HTTPS、SSH进行安全的远程管理，本地可以通过CONSOLE终端进行管理&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;其他处理流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从链路处理流程，在公司的软件架构地图上再点一下zoom in，理论上要到达公司的整体架构了。但是公司的整体架构和组织架构之间密不可分，通常是业务架构而不是技术架构。&lt;/p&gt;&lt;p&gt;一个http请求要经过很多个部门甚至事业群的处理才会再传送到外部机构那边。外部机构下游链条也很长，比如支付请求从微信二维码开始到达腾讯内网处理之后，至少要再经过网联(支付监管)再达到银行侧，从银行处理之后原路返回。&lt;/p&gt;&lt;p&gt;再zoom in一下，只看一个部门所做的事情，对一个支付请求来说，至少要经过渠道、交易核心和支付网关三层，在一个大公司，这往往是三个团队，一个大组十几个人的样子。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;渠道&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;渠道是指业务渠道，比如智能终端设备比如扫码枪、小白盒和二维码会分属不同渠道。它们可能会由不同的应用系统来承建。&lt;/p&gt;&lt;p&gt;上面说的只能终端设备很多朋友可能不知道名字，但是一般都在超市等地方见过。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibWOZhIhGUzRAS6f1CibTnTU4ZLicIlGM2pBarHzKPJQOsT9m0RkkDg2GfEYh4gCZZia0icHIhY8JZTrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面是一个扫码枪的图片，生活中我在小卖店见的比较多。我买了东西放到柜台上结账，收银员就会拿出扫码枪对着我的商品条码扫一下，他们就能看着电脑告诉我付多少钱。这个是用来创建商品订单的，和支付没有关系，一般需要另外扫码或现金支付。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.622286541244573&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibWOZhIhGUzRAS6f1CibTnTUexwnqnfbdNR17JRLIt4M75wYrtGlkiaw0TtLqG22rpuwB6xUjhs0PdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;盒子设备我在大超市见的多一些，这个是真正的支付设备。商品订单已经生成好了，支付费用也已经汇总好了，拿自己的付款码一扫就可以支付。这种方式的好处是支持离线。就是网络不好也能支付成功，等待网络恢复再进行真正的扣款。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibWOZhIhGUzRAS6f1CibTnTUrSQ3R8ibKPrxnhqYtcpicC4Onx7vuibMjSwVzqibquAdIaHPusoyKvumaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面这个是大家最熟悉的扫码付款。来来来，欢迎大家扫描上面二维码发起支付，熟悉一下整个付款流程。扫码付款对于扫描的人来说，扫描时解析的数据只有商家的信息没有付款人的信息，所以需要经过互联网几次交互才能支付成功，商家才会放你离开。&lt;/p&gt;&lt;p&gt;综上所述，每种支付渠道支付流程都就有不少差异化信息，所以渠道侧经常需要快速迭代业务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;交易核心&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不管何种渠道，它们最终都需要落单，就是把支付订单统一存储，最终进行清算。交易核心的数据一般需要提供多个部门使用，比如清算、营销、会员、风控。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;支付网关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;支付网关就相当于是业务架构的防腐层，一般公司都提供多种支付方式，也叫支付渠道。比如同时支持微信、支付宝、余额支付、银行卡。不同支付渠道提供的接口不同，需要网关层做一个统一适配。&lt;/p&gt;&lt;p&gt;再zoom in一下，到一个团队，也一般会有几个或者几十个应用系统构成。一个应用的部署架构有两地三中心或者双机房容灾的部署。一个应用web容器内也请求分发和请求处理两种大类的线程。请求处理线程的处理流程在做详细设计的时候一般需要画出活动图来描述处理流程，举例如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;452&quot; data-backw=&quot;244&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.855807743658211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibWOZhIhGUzRAS6f1CibTnTU9wF3c5REothPvfcPou24icw2u7HgGbsNaibqNtSibN5UricfACDpqVCCcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;749&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;思考！-你的工作&lt;br/&gt;&lt;/section&gt;&lt;p&gt;----程序员修炼之道&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c06be872683302290b27f273fd6aefc</guid>
<title>偷天换日，用 JavaAgent 欺骗你的 JVM</title>
<link>https://toutiao.io/k/4vf942k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉Spring的小伙伴们应该都对aop比较了解，面向切面编程允许我们在目标方法的前后织入想要执行的逻辑，而今天要给大家介绍的Java Agent技术，在思想上与aop比较类似，翻译过来可以被称为&lt;strong&gt;Java代理&lt;/strong&gt;、&lt;strong&gt;Java探针&lt;/strong&gt;技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java Agent出现在JDK1.5版本以后，它允许程序员利用agent技术构建一个独立于应用程序的代理程序，用途也非常广泛，可以协助监测、运行、甚至替换其他JVM上的程序，先从下面这张图直观的看一下它都被应用在哪些场景：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5509433962264151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MCsN27dESvlrlywMqh18mzu7AiaQ2jjyF1TlyibbqgK9rW2mcSUBFjPlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里你是不是也很好奇，究竟是什么神仙技术，能够应用在这么多场景下，那今天我们就来挖掘一下，看看神奇的Java Agent是如何工作在底层，默默支撑了这么多优秀的应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到文章开头的类比，我们还是用和aop比较的方式，来先对Java Agent有一个大致的了解：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;作用级别：aop运行于应用程序内的方法级别，而agent能够作用于虚拟机级别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组成部分：aop的实现需要目标方法和逻辑增强部分的方法，而Java Agent要生效需要两个工程，一个是agent代理，另一个是需要被代理的主程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行场合：aop可以运行在切面的前后或环绕等场合，而Java Agent的执行只有两种方式，jdk1.5提供的&lt;code&gt;preMain&lt;/code&gt;模式在主程序运行前执行，jdk1.6提供的&lt;code&gt;agentMain&lt;/code&gt;在主程序运行后执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就分别看一下在两种模式下，如何动手实现一个agent代理程序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Premain模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Premain模式允许在主程序执行前执行一个agent代理，实现起来非常简单，下面我们分别实现两个组成部分。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;agent&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先写一个简单的功能，在主程序执行前打印一句话，并打印传递给代理的参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyPreMainAgent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;premain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;premain start&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写完了agent的逻辑后，需要把它打包成&lt;code&gt;jar&lt;/code&gt;文件，这里我们直接使用maven插件打包的方式，在打包前进行一些配置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;Premain-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.agent.MyPreMainAgent&lt;span&gt;&amp;lt;/&lt;span&gt;Premain-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;                            &lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;Can-Set-Native-Method-Prefix&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置的打包参数中，通过&lt;code&gt;manifestEntries&lt;/code&gt;的方式添加属性到&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件中，解释一下里面的几个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Premain-Class&lt;/code&gt;：包含&lt;code&gt;premain&lt;/code&gt;方法的类，需要配置为类的全路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Can-Redefine-Classes&lt;/code&gt;：为&lt;code&gt;true&lt;/code&gt;时表示能够重新&lt;strong&gt;定义&lt;/strong&gt;class&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Can-Retransform-Classes&lt;/code&gt;：为&lt;code&gt;true&lt;/code&gt;时表示能够重新&lt;strong&gt;转换&lt;/strong&gt;class，实现字节码替换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Can-Set-Native-Method-Prefix&lt;/code&gt;：为&lt;code&gt;true&lt;/code&gt;时表示能够设置native方法的前缀&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;Premain-Class&lt;/code&gt;为必须配置，其余几项是非必须选项，默认情况下都为&lt;code&gt;false&lt;/code&gt;，通常也建议加入，这几个功能我们会在后面具体介绍。在配置完成后，使用&lt;code&gt;mvn&lt;/code&gt;命令打包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mvn clean package&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打包完成后生成&lt;code&gt;myAgent-1.0.jar&lt;/code&gt;文件，我们可以解压&lt;code&gt;jar&lt;/code&gt;文件，看一下生成的&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4099009900990099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9Mla3YlKFBFBSnplLPv5iaNkht3j9cPH1oYgpYGI95fd1gpqFZIVJicI6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;505&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，添加的属性已经被加入到了文件中。到这里，agent代理部分就完成了，因为代理不能够直接运行，需要附着于其他程序，所以下面新建一个工程来实现主程序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;主程序&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主程序的工程中，只需要一个能够执行的&lt;code&gt;main&lt;/code&gt;方法的入口就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AgentTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;main project start&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主程序完成后，要考虑的就是应该如何将主程序与agent工程连接起来。这里可以通过&lt;code&gt;-javaagent&lt;/code&gt;参数来指定运行的代理，命令格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -javaagent:myAgent.jar -jar AgentTest.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，可以指定的代理的数量是没有限制的，会根据指定的顺序先后依次执行各个代理，如果要同时运行两个代理，就可以按照下面的命令执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -javaagent:myAgent1.jar -javaagent:myAgent2.jar  -jar AgentTest.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以我们在idea中执行程序为例，在&lt;code&gt;VM options&lt;/code&gt;中加入添加启动参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-javaagent:F:\Workspace\MyAgent\target\myAgent-1.0.jar=Hydra&lt;br/&gt;-javaagent:F:\Workspace\MyAgent\target\myAgent-1.0.jar=Trunks&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行&lt;code&gt;main&lt;/code&gt;方法，查看输出结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42237061769616024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MLiaCzLZPe73l3jYtXt8nnmYgQ5gcic1Nx02XCEWicm89iaM9Rd9nBtCZvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;599&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据执行结果的打印语句可以看出，在执行主程序前，依次执行了两次我们的agent代理。可以通过下面的图来表示执行代理与主程序的执行顺序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6906354515050167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MmeEibAx9Zk3hiaYWfZMBvOgb84Lc8ItWgRf5goFc8H6NSdfZzXZeEEzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;598&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;缺陷&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在提供便利的同时，premain模式也有一些缺陷，例如如果agent在运行过程中出现异常，那么也会导致主程序的启动失败。我们对上面例子中agent的代码进行一下改造，手动抛出一个异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;premain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;premain start&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;error&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次运行主程序：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3743743743743744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9M3ookJCtnkTeN8vjcE4vsickPW8BHofCicy2ulZ9ygQWfnfF0o8xuvXVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在agent抛出异常后主程序也没有启动。针对premain模式的一些缺陷，在jdk1.6之后引入了agentmain模式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Agentmain模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;agentmain模式可以说是premain的升级版本，它允许代理的目标主程序的jvm先行启动，再通过&lt;code&gt;attach&lt;/code&gt;机制连接两个jvm，下面我们分3个部分实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;agent&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;agent部分和上面一样，实现简单的打印功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyAgentMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;agentmain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation instrumentation)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;agent main start&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;args:&quot;&lt;/span&gt;+agentArgs);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改maven插件配置，指定&lt;code&gt;Agent-Class&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;addClasspath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;Agent-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.agent.MyAgentMain&lt;span&gt;&amp;lt;/&lt;span&gt;Agent-Class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;Can-Redefine-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;span&gt;Can-Retransform-Classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;manifestEntries&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;archive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;主程序&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们直接启动主程序等待代理被载入，在主程序中使用了&lt;code&gt;System.in&lt;/code&gt;进行阻塞，防止主进程提前结束。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AgentmainTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        System.in.read();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;attach机制&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和premain模式不同，我们不能再通过添加启动参数的方式来连接agent和主程序了，这里需要借助&lt;code&gt;com.sun.tools.attach&lt;/code&gt;包下的&lt;code&gt;VirtualMachine&lt;/code&gt;工具类，需要注意该类不是jvm标准规范，是由Sun公司自己实现的，使用前需要引入依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.sun&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;tools&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;system&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;${JAVA_HOME}\lib\tools.jar&lt;span&gt;&amp;lt;/&lt;span&gt;systemPath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;VirtualMachine&lt;/code&gt;代表了一个要被&lt;strong&gt;附着&lt;/strong&gt;的java虚拟机，也就是程序中需要监控的目标虚拟机，外部进程可以使用&lt;code&gt;VirtualMachine&lt;/code&gt;的实例将agent加载到目标虚拟机中。先看一下它的静态方法&lt;code&gt;attach&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; VirtualMachine &lt;span&gt;attach&lt;/span&gt;&lt;span&gt;(String var0)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;attach&lt;/code&gt;方法可以获取一个jvm的对象实例，这里传入的参数是目标虚拟机运行时的进程号&lt;code&gt;pid&lt;/code&gt;。也就是说，我们在使用&lt;code&gt;attach&lt;/code&gt;前，需要先获取刚才启动的主程序的&lt;code&gt;pid&lt;/code&gt;，使用&lt;code&gt;jps&lt;/code&gt;命令查看线程&lt;code&gt;pid&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;11140&lt;br/&gt;16372 RemoteMavenServer36&lt;br/&gt;16392 AgentmainTest&lt;br/&gt;20204 Jps&lt;br/&gt;2460 Launcher&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取到主程序&lt;code&gt;AgentmainTest&lt;/code&gt;运行时&lt;code&gt;pid&lt;/code&gt;是16392，将它应用于虚拟机的连接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AttachTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            VirtualMachine  vm= VirtualMachine.attach(&lt;span&gt;&quot;16392&quot;&lt;/span&gt;);&lt;br/&gt;            vm.loadAgent(&lt;span&gt;&quot;F:\\Workspace\\MyAgent\\target\\myAgent-1.0.jar&quot;&lt;/span&gt;,&lt;span&gt;&quot;param&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在获取到&lt;code&gt;VirtualMachine&lt;/code&gt;实例后，就可以通过&lt;code&gt;loadAgent&lt;/code&gt;方法可以实现注入agent代理类的操作，方法的第一个参数是代理的本地路径，第二个参数是传给代理的参数。执行&lt;code&gt;AttachTest&lt;/code&gt;，再回到主程序&lt;code&gt;AgentmainTest&lt;/code&gt;的控制台，可以看到执行了了agent中的代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2754777070063694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MdHRPc00Ww9TVUf3wqNfa2uAra0OqldYhicsaAe1jndcBHACpymPFpwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，一个简单的agentMain模式代理就实现完成了，可以通过下面这张图再梳理一下三个模块之间的关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2588699080157687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MXM1iahCcAaIY4mUXS6UqbXq2FK33GwxvXKTVek8Eic9ricWWVShFdlyaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;761&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，我们就已经简单地了解了两种模式的实现方法，但是作为高质量程序员，我们肯定不能满足于只用代理单纯地打印语句，下面我们再来看看能怎么利用Java Agent搞点实用的东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的两种模式中，agent部分的逻辑分别是在&lt;code&gt;premain&lt;/code&gt;方法和&lt;code&gt;agentmain&lt;/code&gt;方法中实现的，并且，这两个方法在签名上对参数有严格的要求，&lt;code&gt;premain&lt;/code&gt;方法允许以下面两种方式定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;premain&lt;/span&gt;&lt;span&gt;(String agentArgs)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;premain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;agentmain&lt;/code&gt;方法允许以下面两种方式定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;agentmain&lt;/span&gt;&lt;span&gt;(String agentArgs)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;agentmain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在agent中同时存在两种签名的方法，带有&lt;code&gt;Instrumentation&lt;/code&gt;参数的方法优先级更高，会被jvm优先加载，它的实例&lt;code&gt;inst&lt;/code&gt;会由jvm自动注入，下面我们就看看能通过&lt;code&gt;Instrumentation&lt;/code&gt;实现什么功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Instrumentation&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先大体介绍一下&lt;code&gt;Instrumentation&lt;/code&gt;接口，其中的方法允许在运行时操作java程序，提供了诸如改变字节码，新增jar包，替换class等功能，而通过这些功能使Java具有了更强的动态控制和解释能力。在我们编写agent代理的过程中，&lt;code&gt;Instrumentation&lt;/code&gt;中下面3个方法比较重要和常用，我们来着重看一下。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;addTransformer&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;addTransformer&lt;/code&gt;方法允许我们在类加载之前，重新定义Class，先看一下方法的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addTransformer&lt;/span&gt;&lt;span&gt;(ClassFileTransformer transformer)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ClassFileTransformer&lt;/code&gt;是一个接口，只有一个&lt;code&gt;transform&lt;/code&gt;方法，它在主程序的&lt;code&gt;main&lt;/code&gt;方法执行前，装载的每个类都要经过&lt;code&gt;transform&lt;/code&gt;执行一次，可以将它称为转换器。我们可以实现这个方法来重新定义Class，下面就通过一个例子看看具体如何使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，在主程序工程创建一个&lt;code&gt;Fruit&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;getFruit&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;banana&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译完成后复制一份class文件，并将其重命名为&lt;code&gt;Fruit2.class&lt;/code&gt;，再修改&lt;code&gt;Fruit&lt;/code&gt;中的方法为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;getFruit&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;apple&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建主程序，在主程序中创建了一个&lt;code&gt;Fruit&lt;/code&gt;对象并调用了其&lt;code&gt;getFruit&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TransformMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Fruit().getFruit();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时执行结果会打印&lt;code&gt;apple&lt;/code&gt;，接下来开始实现premain代理部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代理的&lt;code&gt;premain&lt;/code&gt;方法中，使用&lt;code&gt;Instrumentation&lt;/code&gt;的&lt;code&gt;addTransformer&lt;/code&gt;方法拦截类的加载：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TransformAgent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;premain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        inst.addTransformer(&lt;span&gt;new&lt;/span&gt; FruitTransformer());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;FruitTransformer&lt;/code&gt;类实现了&lt;code&gt;ClassFileTransformer&lt;/code&gt;接口，转换class部分的逻辑都在&lt;code&gt;transform&lt;/code&gt;方法中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FruitTransformer&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ClassFileTransformer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined,&lt;br/&gt;                            ProtectionDomain protectionDomain, &lt;span&gt;byte&lt;/span&gt;[] classfileBuffer){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!className.equals(&lt;span&gt;&quot;com/cn/hydra/test/Fruit&quot;&lt;/span&gt;))&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; classfileBuffer;&lt;br/&gt;&lt;br/&gt;        String fileName=&lt;span&gt;&quot;F:\\Workspace\\agent-test\\target\\classes\\com\\cn\\hydra\\test\\Fruit2.class&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getClassBytes(fileName);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getClassBytes(String fileName){&lt;br/&gt;        File file = &lt;span&gt;new&lt;/span&gt; File(fileName);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;(InputStream is = &lt;span&gt;new&lt;/span&gt; FileInputStream(file);&lt;br/&gt;            ByteArrayOutputStream bs = &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream()){&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; length = file.length();&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[(&lt;span&gt;int&lt;/span&gt;) length];&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; n;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((n = is.read(bytes)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                bs.write(bytes, &lt;span&gt;0&lt;/span&gt;, n);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; bytes;&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;transform&lt;/code&gt;方法中，主要做了两件事：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;因为&lt;code&gt;addTransformer&lt;/code&gt;方法不能指明需要转换的类，所以需要通过&lt;code&gt;className&lt;/code&gt;判断当前加载的class是否我们要拦截的目标class，对于非目标class直接返回原字节数组，注意&lt;code&gt;className&lt;/code&gt;的格式，需要将类全限定名中的&lt;code&gt;.&lt;/code&gt;替换为&lt;code&gt;/&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读取我们之前复制出来的class文件，读入二进制字符流，替换原有&lt;code&gt;classfileBuffer&lt;/code&gt;字节数组并返回，完成class定义的替换&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将agent部分打包完成后，在主程序添加启动参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-javaagent:F:\Workspace\MyAgent\target\transformAgent-1.0.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次执行主程序，结果打印：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;banana&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，就实现了在&lt;code&gt;main&lt;/code&gt;方法执行前class的替换。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;redefineClasses&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以直观地从方法的名字上来理解它的作用，重定义class，通俗点来讲的话就是实现指定类的替换。方法定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;redefineClasses&lt;/span&gt;&lt;span&gt;(ClassDefinition... definitions)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  ClassNotFoundException, UnmodifiableClassException&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的参数是可变长的&lt;code&gt;ClassDefinition&lt;/code&gt;数组，再看一下&lt;code&gt;ClassDefinition&lt;/code&gt;的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ClassDefinition&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; theClass,&lt;span&gt;byte&lt;/span&gt;[] theClassFile)&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ClassDefinition&lt;/code&gt;中指定了的Class对象和修改后的字节码数组，简单来说，就是使用提供的类文件字节，替换了原有的类。并且，在&lt;code&gt;redefineClasses&lt;/code&gt;方法重定义的过程中，传入的是&lt;code&gt;ClassDefinition&lt;/code&gt;的数组，它会按照这个数组顺序进行加载，以便满足在类之间相互依赖的情况下进行更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通过一个例子来看一下它的生效过程，premain代理部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedefineAgent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;premain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; UnmodifiableClassException, ClassNotFoundException &lt;/span&gt;{&lt;br/&gt;        String fileName=&lt;span&gt;&quot;F:\\Workspace\\agent-test\\target\\classes\\com\\cn\\hydra\\test\\Fruit2.class&quot;&lt;/span&gt;;&lt;br/&gt;        ClassDefinition def=&lt;span&gt;new&lt;/span&gt; ClassDefinition(Fruit&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;FruitTransformer&lt;/span&gt;.&lt;span&gt;getClassBytes&lt;/span&gt;(&lt;span&gt;fileName&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;        inst.redefineClasses(&lt;span&gt;new&lt;/span&gt; ClassDefinition[]{def});&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主程序可以直接复用上面的，执行后打印：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;banana&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，用我们指定的class文件的字节替换了原有类，即实现了指定类的替换。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;retransformClasses&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;retransformClasses&lt;/code&gt;应用于agentmain模式，可以在类加载之后重新定义Class，即触发类的重新加载。首先看一下该方法的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;retransformClasses&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt;... classes)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; UnmodifiableClassException&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的参数&lt;code&gt;classes&lt;/code&gt;是需要转换的类数组，可变长参数也说明了它和&lt;code&gt;redefineClasses&lt;/code&gt;方法一样，也可以批量转换类的定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我们通过例子来看看如何使用&lt;code&gt;retransformClasses&lt;/code&gt;方法，agent代理部分代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RetransformAgent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;agentmain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; UnmodifiableClassException &lt;/span&gt;{&lt;br/&gt;        inst.addTransformer(&lt;span&gt;new&lt;/span&gt; FruitTransformer(),&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        inst.retransformClasses(Fruit&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;retransform success&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下这里调用的&lt;code&gt;addTransformer&lt;/code&gt;方法的定义，与上面略有不同：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addTransformer&lt;/span&gt;&lt;span&gt;(ClassFileTransformer transformer, &lt;span&gt;boolean&lt;/span&gt; canRetransform)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ClassFileTransformer&lt;/code&gt;转换器依旧复用了上面的&lt;code&gt;FruitTransformer&lt;/code&gt;，重点看一下新加的第二个参数，当&lt;code&gt;canRetransform&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;时，表示允许重新定义class。这时，相当于调用了转换器&lt;code&gt;ClassFileTransformer&lt;/code&gt;中的&lt;code&gt;transform&lt;/code&gt;方法，会将转换后class的字节作为新类定义进行加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主程序部分代码，我们在死循环中不断的执行打印语句，来监控类是否发生了改变：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RetransformMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;){&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Fruit().getFruit();&lt;br/&gt;            TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，使用attach api注入agent代理到主程序中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AttachRetransform&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        VirtualMachine vm = VirtualMachine.attach(&lt;span&gt;&quot;6380&quot;&lt;/span&gt;);&lt;br/&gt;        vm.loadAgent(&lt;span&gt;&quot;F:\\Workspace\\MyAgent\\target\\retransformAgent-1.0.jar&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到主程序控制台，查看运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46634615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9M4Yfgzj40BEWQ6meuOyS9nsgvgtARdTdzl2t8Xc4ia7z2Bw0pTa5XS7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到在注入代理后，打印语句发生变化，说明类的定义已经被改变并进行了重新加载。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;其他&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这几个主要的方法外，&lt;code&gt;Instrumentation&lt;/code&gt;中还有一些其他方法，这里仅简单列举一下常用方法的功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;removeTransformer&lt;/code&gt;：删除一个&lt;code&gt;ClassFileTransformer&lt;/code&gt;类转换器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getAllLoadedClasses&lt;/code&gt;：获取当前已经被加载的Class&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getInitiatedClasses&lt;/code&gt;：获取由指定的&lt;code&gt;ClassLoader&lt;/code&gt;加载的Class&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getObjectSize&lt;/code&gt;：获取一个对象占用空间的大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;appendToBootstrapClassLoaderSearch&lt;/code&gt;：添加jar包到启动类加载器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;appendToSystemClassLoaderSearch&lt;/code&gt;：添加jar包到系统类加载器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;isNativeMethodPrefixSupported&lt;/code&gt;：判断是否能给native方法添加前缀，即是否能够拦截native方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;setNativeMethodPrefix&lt;/code&gt;：设置native方法的前缀&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Javassist&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的几个例子中，我们都是直接读取的class文件中的字节来进行class的重定义或转换，但是在实际的工作环境中，可能更多的是去动态的修改class文件的字节码，这时候就可以借助javassist来更简单的修改字节码文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，javassist是一个分析、编辑和创建java字节码的类库，在使用时我们可以直接调用它提供的api，以编码的形式动态改变或生成class的结构。相对于ASM等其他要求了解底层虚拟机指令的字节码框架，javassist真的是非常简单和快捷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我们就通过一个简单的例子，看看如何将Java agent和Javassist结合在一起使用。首前先引入javassist的依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.javassist&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;javassist&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.20.0-GA&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要实现的功能是通过代理，来计算方法执行的时间。premain代理部分和之前基本一致，先添加一个转换器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Agent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;premain&lt;/span&gt;&lt;span&gt;(String agentArgs, Instrumentation inst)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        inst.addTransformer(&lt;span&gt;new&lt;/span&gt; LogTransformer());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogTransformer&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ClassFileTransformer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined, &lt;br/&gt;                                ProtectionDomain protectionDomain, &lt;span&gt;byte&lt;/span&gt;[] classfileBuffer) &lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; IllegalClassFormatException {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!className.equals(&lt;span&gt;&quot;com/cn/hydra/test/Fruit&quot;&lt;/span&gt;))&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; calculate();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;calculate&lt;/code&gt;方法中，使用javassist动态的改变了方法的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] calculate() &lt;span&gt;throws&lt;/span&gt; Exception {&lt;br/&gt;    ClassPool pool = ClassPool.getDefault();&lt;br/&gt;    CtClass ctClass = pool.get(&lt;span&gt;&quot;com.cn.hydra.test.Fruit&quot;&lt;/span&gt;);&lt;br/&gt;    CtMethod ctMethod = ctClass.getDeclaredMethod(&lt;span&gt;&quot;getFruit&quot;&lt;/span&gt;);&lt;br/&gt;    CtMethod copyMethod = CtNewMethod.copy(ctMethod, ctClass, &lt;span&gt;new&lt;/span&gt; ClassMap());&lt;br/&gt;    ctMethod.setName(&lt;span&gt;&quot;getFruit$agent&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    StringBuffer body = &lt;span&gt;new&lt;/span&gt; StringBuffer(&lt;span&gt;&quot;{\n&quot;&lt;/span&gt;)&lt;br/&gt;            .append(&lt;span&gt;&quot;long begin = System.nanoTime();\n&quot;&lt;/span&gt;)&lt;br/&gt;            .append(&lt;span&gt;&quot;getFruit$agent($$);\n&quot;&lt;/span&gt;)&lt;br/&gt;            .append(&lt;span&gt;&quot;System.out.println(\&quot;use \&quot;+(System.nanoTime() - begin) +\&quot; ns\&quot;);\n&quot;&lt;/span&gt;)&lt;br/&gt;            .append(&lt;span&gt;&quot;}&quot;&lt;/span&gt;);&lt;br/&gt;    copyMethod.setBody(body.toString());&lt;br/&gt;    ctClass.addMethod(copyMethod);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ctClass.toBytecode();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，主要实现了这些功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;利用全限定名获取类&lt;code&gt;CtClass&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据方法名获取方法&lt;code&gt;CtMethod&lt;/code&gt;，并通过&lt;code&gt;CtNewMethod.copy&lt;/code&gt;方法复制一个新的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改旧方法的方法名为&lt;code&gt;getFruit$agent&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;setBody&lt;/code&gt;方法修改复制出来方法的内容，在新方法中进行了逻辑增强并调用了旧方法，最后将新方法添加到类中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主程序仍然复用之前的代码，执行查看结果，完成了代理中的执行时间统计功能：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2981878088962109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9Mic7DYGxlweUWn2pX1n9vRDffTd9ibVPzkiaulcSRMyHIUBdmTiaHB0Yc5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们可以再通过反射看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (Method method : Fruit&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getDeclaredMethods&lt;/span&gt;()) &lt;/span&gt;{&lt;br/&gt;    System.out.println(method.getName());&lt;br/&gt;    method.invoke(&lt;span&gt;new&lt;/span&gt; Fruit());&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;-------&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看结果，可以看到类中确实已经新增了一个方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47796610169491527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicaicNO4xaHoiaBp8MfVCzYc9MHMCAoIKB0FR0urfTstXQfiarQOD1JmwaCvKVGLcSauT1kKeh0vB6law/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，javassist还有很多其他的功能，例如新建Class、设置父类、读取和写入字节码等等，大家可以在具体的场景中学习它的用法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们在平常的工作中，直接用到Java Agent的场景可能并不是很多，但是在热部署、监控、性能分析等工具中，它们可能隐藏在业务系统的角落里，一直在默默发挥着巨大的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从Java Agent的两种模式入手，手动实现并简要分析了它们的工作流程，虽然在这里只利用它们完成了一些简单的功能，但是不得不说，正是Java Agent的出现，让程序的运行不再循规蹈矩，也为我们的代码提供了无限的可能性。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5087ff4dee4ad190eb291a12e8aa4e97</guid>
<title>Redis 核心原理与实践：Redis 事务应用与源码分析</title>
<link>https://toutiao.io/k/3w0wy2c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Redis支持事务机制，但Redis的事务机制与传统关系型数据库的事务机制并不相同。&lt;br/&gt;Redis事务的本质是一组命令的集合（命令队列）。事务可以一次执行多个命令，并提供以下保证：&lt;br/&gt;（1）事务中的所有命令都按顺序执行。事务命令执行过程中，其他客户端提交的命令请求需要等待当前事务所有命令执行完成后再处理，不会插入当前事务命令队列中。&lt;br/&gt;（2）事务中的命令要么都执行，要么都不执行，即使事务中有些命令执行失败，后续命令依然被执行。因此Redis事务也是原子的。&lt;br/&gt;注意Redis不支持回滚，如果事务中有命令执行失败了，那么Redis会继续执行后续命令而不是回滚。&lt;br/&gt;可能有读者疑惑Redis是否支持ACID？笔者认为，ACID概念起源于传统的关系型数据库，而Redis是非关系型数据库，而且Redis并没有声明是否支持ACID，所以本文不讨论该问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;事务的应用示例&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Redis提供了MULTI、EXEC、DISCARD和WATCH命令来实现事务功能：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt; MULTI&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;&lt;span&gt;&amp;gt; SET points 1&lt;/span&gt;&lt;br/&gt;QUEUED&lt;br/&gt;&lt;span&gt;&amp;gt; INCR points&lt;/span&gt;&lt;br/&gt;QUEUED&lt;br/&gt;&lt;span&gt;&amp;gt; EXEC&lt;/span&gt;&lt;br/&gt;1) (integer) 1&lt;br/&gt;2) (integer) 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MULTI命令可以开启一个事务，后续的命令都会被放入事务命令队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;EXEC命令可以执行事务命令队列中的所有命令，DISCARD命令可以抛弃事务命令队列中的命令，这两个命令都会结束当前事务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;WATCH命令可以监视指定键，当后续事务执行前发现这些键已修改时，则拒绝执行事务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;表17-1展示了一个WATCH命令的简单使用示例。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000508&quot; data-ratio=&quot;0.6248085758039816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Of81vjDNtAzgsSUA7UrnAIzwfosY7I5M2HFiaUiafjy555mgGzHXdkYNiahy7cL4V6TwZOC0j7p6uFokNn86zUuOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot; title=&quot;picture 1&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;br/&gt;可以看到，在执行EXEC命令前如果WATCH的键被修改，则EXEC命令不会执行事务，因此WATCH常用于实现乐观锁。&lt;h2&gt;&lt;span&gt;事务的实现原理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;server.h/multiState结构体负责存放事务信息：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;multiState&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    multiCmd *commands;&lt;br/&gt;    ...&lt;br/&gt;} multiState;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端属性client.mstate指向一个multiState变量，该multiState作为客户端的事务上下文，负责存放该客户端当前的事务信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面看一下MULTI、EXEC和WATCH命令的实现。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;WATCH命令的实现&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;em&gt;提示：本章代码如无特殊说明，均在multi.c中。&lt;/em&gt;&lt;br/&gt;WATCH命令的实现逻辑较独立，我们先分析该命令的实现逻辑。&lt;br/&gt;redisDb中定义了字典属性watched_keys，该字典的键是数据库中被监视的Redis键，字典的值是监视字典键的所有客户端列表，如图17-1所示。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000509&quot; data-ratio=&quot;0.3463302752293578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Of81vjDNtAzgsSUA7UrnAIzwfosY7I5MdpHia6jIxaE2PkToJOPGwv4hFemPA2MLIzFCTUUE5BD0s76kcs2stGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot; title=&quot;picture 2&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;client中也定义了列表属性watched_keys，记录该客户端所有监视的键。&lt;br/&gt;watchCommand函数负责处理WATCH命令，该函数会调用watchForKey函数处理相关逻辑：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void watchForKey(client *c, robj *key) {&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    clients = dictFetchValue(c-&amp;gt;db-&amp;gt;watched_keys,key);&lt;br/&gt;    ...&lt;br/&gt;    listAddNodeTail(clients,c);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;    wk = zmalloc(sizeof(*wk));&lt;br/&gt;    wk-&amp;gt;key = key;&lt;br/&gt;    wk-&amp;gt;db = c-&amp;gt;db;&lt;br/&gt;    incrRefCount(key);&lt;br/&gt;    listAddNodeTail(c-&amp;gt;watched_keys,wk);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【1】将客户端添加到redisDb.watched_keys字典中该Redis键对应的客户端列表中。&lt;br/&gt;【2】初始化watchedKey结构体（wk变量），该结构体可以存储被监视键和对应的数据库。将wk变量添加到client.watched_keys中。&lt;br/&gt;Redis中每次修改数据时，都会调用signalModifiedKey函数，将该数据标志为已修改。&lt;br/&gt;signalModifiedKey函数会调用touchWatchedKey函数，通知监视该键的客户端数据已修改：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;touchWatchedKey&lt;/span&gt;&lt;span&gt;(redisDb *db, robj *key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    clients = dictFetchValue(db-&amp;gt;watched_keys, key);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!clients) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    listRewind(clients,&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;&lt;br/&gt;        c-&amp;gt;flags |= CLIENT_DIRTY_CAS;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从redisDb.wzatched_keys中获取所有监视该键的客户端，给这些客户端添加CLIENT_ DIRTY_CAS标志，该标志代表客户端监视的键已被修改。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;MULTI、EXEC命令的实现&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;MULTI命令由multiCommand函数处理，该函数的处理非常简单，就是打开客户端CLIENT_MULTI标志，代表该客户端已开启事务。&lt;br/&gt;前面说过，processCommand函数执行命令时，会检查客户端是否已开启事务。如果客户端已开启事务，则调用queueMultiCommand函数，将命令请求添加到客户端事务命令队列client.mstate.commands中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int processCommand(client *c) {&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;flags &amp;amp; CLIENT_MULTI &amp;amp;&amp;amp;&lt;br/&gt;        c-&amp;gt;cmd-&amp;gt;proc != execCommand &amp;amp;&amp;amp; c-&amp;gt;cmd-&amp;gt;proc != discardCommand &amp;amp;&amp;amp;&lt;br/&gt;        c-&amp;gt;cmd-&amp;gt;proc != multiCommand &amp;amp;&amp;amp; c-&amp;gt;cmd-&amp;gt;proc != watchCommand)&lt;br/&gt;    {&lt;br/&gt;        queueMultiCommand(c);&lt;br/&gt;        addReply(c,shared.queued);&lt;br/&gt;    } ...&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; C_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，如果当前客户端开启了事务，则除了MULTI、EXEC、DISCARD和WATCH命令，其他命令都会放入到事务命令队列中。&lt;br/&gt;EXEC命令由execCommand函数处理：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void execCommand(client *c) {&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [1]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;flags &amp;amp; (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) {&lt;br/&gt;        addReply(c, c-&amp;gt;flags &amp;amp; CLIENT_DIRTY_EXEC ? shared.execaborterr : shared.nullarray[c-&amp;gt;resp]);&lt;br/&gt;        discardTransaction(c);&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; handle_monitor;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [2]&lt;/span&gt;&lt;br/&gt;    unwatchAllKeys(c);&lt;br/&gt;    ...&lt;br/&gt;    addReplyArrayLen(c,c-&amp;gt;mstate.count);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; c-&amp;gt;mstate.count; j++) {&lt;br/&gt;        c-&amp;gt;argc = c-&amp;gt;mstate.commands[j].argc;&lt;br/&gt;        c-&amp;gt;argv = c-&amp;gt;mstate.commands[j].argv;&lt;br/&gt;        c-&amp;gt;cmd = c-&amp;gt;mstate.commands[j].cmd;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// [3]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!must_propagate &amp;amp;&amp;amp;&lt;br/&gt;            !server.loading &amp;amp;&amp;amp;&lt;br/&gt;            !(c-&amp;gt;cmd-&amp;gt;flags &amp;amp; (CMD_READONLY|CMD_ADMIN)))&lt;br/&gt;        {&lt;br/&gt;            execCommandPropagateMulti(c);&lt;br/&gt;            must_propagate = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// [4]&lt;/span&gt;&lt;br/&gt;        int acl_keypos;&lt;br/&gt;        int acl_retval = ACLCheckCommandPerm(c,&amp;amp;acl_keypos);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (acl_retval != ACL_OK) {&lt;br/&gt;            ...&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            call(c,server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);&lt;br/&gt;        }&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// [5]&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    discardTransaction(c);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// [6]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (must_propagate) {&lt;br/&gt;        int is_master = server.masterhost == &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;        server.dirty++;&lt;br/&gt;        ...&lt;br/&gt;    }    &lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【1】当客户端监视的键被修改（客户端存在CLIENT_DIRTY_CAS标志）或者客户端已拒绝事务中的命令（客户端存在CLIENT_DIRTY_EXEC标志）时，直接抛弃事务命令队列中的命令，并进行错误处理。&lt;br/&gt;当服务器处于异常状态（如内存溢出）时，Redis将拒绝命令，并给开启了事务的客户端添加CLIENT_DIRTY_EXEC标志。&lt;br/&gt;【2】取消当前客户端对所有键的监视，所以WATCH命令只能作用于后续的一个事务。&lt;br/&gt;【3】在执行事务的第一个写命令之前，传播MULTI命令到AOF文件和从节点。MULTI命令执行完后并不会被传播（MULTI命令并不属于写命令），如果事务中执行了写命令，则在这里传播MULTI命令。&lt;br/&gt;【4】检查用户的ACL权限，检查通过后执行命令。&lt;br/&gt;【5】执行完所有命令，调用discardTransaction函数重置客户端事务上下文client.mstate，并删除CLIENT_MULTI、CLIENT_DIRTY_CAS、CLIENT_DIRTY_EXEC标志，代表当前事务已经处理完成。&lt;br/&gt;【6】如果事务中执行了写命令，则修改server.dirty，这样会使server.c/call函数将EXEC命令传播到AOF文件和从节点，从而保证一个事务的MULTI、EXEC命令都被传播。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;关于Redis不支持回滚机制，Redis在官网中给出了如下解释：&lt;br/&gt;（1）仅当使用了错误语法（并且该错误无法在命令加入队列期间检测）或者Redis命令操作数据类型错误（比如对集合类型使用了HGET命令）时，才可能导致事务中的命令执行失败，这意味着事务中失败的命令是编程错误的结果，所以这些问题应该在开发过程中发现并处理，而不是依赖于在生产环境中的回滚机制来规避。&lt;br/&gt;（2）不支持回滚，Redis事务机制实现更简单并且性能更高。&lt;br/&gt;Redis的事务非常简单，即在一个原子操作内执行多条命令。Redis的Lua脚本也是事务性的，所以用户也可以使用Lua脚本实现事务。Redis Lua脚本会在后续章节详细分析。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;总结：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文内容摘自作者新书《Redis核心原理与实践》。&lt;/span&gt;&lt;span&gt;本书通过深入分析Redis 6.0源码，总结了Redis核心功能的设计与实现。&lt;/span&gt;&lt;span&gt;通过阅读本书，读者可以深入理解Redis内部机制及最新特性，并学习到Redis相关的数据结构与算法、Unix编程、存储系统设计，分布式系统架构等一系列知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;经过该书编辑同意，我会继续在个人技术公众号（binecy）发布书中部分章节内容，作为书的预览内容，欢迎大家查阅，谢谢。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;书籍详情：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDQzMTU2MA==&amp;amp;mid=2247484112&amp;amp;idx=1&amp;amp;sn=c7d2d153a65a72fb3cd074803c7c2fbc&amp;amp;chksm=ea688977dd1f0061831cae4f5361182603b2e5778cae8aa0fc8f7e92ab75bc08c81afd717e6c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;新书介绍 -- 《Redis核心原理与实践》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>