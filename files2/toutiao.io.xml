<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>03095fd1ea30d853a5feeb96e74f87ac</guid>
<title>​Golang 并发编程指南</title>
<link>https://toutiao.io/k/adoo89l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：dcguo，腾讯 CSIG 电子签开放平台中心&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分享 Golang 并发基础库，扩展以及三方库的一些常见问题、使用介绍和技巧，以及对一些并发库的选择和优化探讨。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;go 原生/扩展库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提倡的原则&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要通过共享内存进行通信;相反，通过通信来共享内存。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Goroutine&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;goroutine 并发模型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度器主要结构&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要调度器结构是 M，P，G&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;M，内核级别线程，goroutine 基于 M 之上，代表执行者，底层线程，物理线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;P，处理器，用来执行 goroutine，因此维护了一个 goroutine 队列，里面存储了所有要执行的 goroutine，将等待执行的 G 与 M 对接，它的数目也代表了真正的并发度( 即有多少个 goroutine 可以同时进行 )；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;G，goroutine 实现的核心结构，相当于轻量级线程，里面包含了 goroutine 需要的栈，程序计数器，以及所在 M 的信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;P 的数量由环境变量中的 GOMAXPROCS 决定，通常来说和核心数对应。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;映射关系&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户空间线程和内核空间线程映射关系有如下三种:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;N:1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1:1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;M:N&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调度图&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关系如图，灰色的 G 则是暂时还未运行的，处于就绪态，等待被调度，这个队列被 P 维护&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2WL31ZM4xF0G7ux5yEiafmhF2sDl0bB5gp3IQJxjtoddJYW3a1RcI4HQ/640?wx_fmt=jpeg&quot; data-cropx1=&quot;12.24170616113744&quot; data-cropx2=&quot;738&quot; data-cropy1=&quot;13.990521327014218&quot; data-cropy2=&quot;641.8151658767772&quot; data-ratio=&quot;0.8663911845730028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2754ibbyib5MZzMC6W1UH3j4El7TUNV9oe8mvUibia9FYBMAicqcvYIemibibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;726&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注:&lt;/strong&gt; 简单调度图如上，有关于 P 再多个 M 中切换，公共 goroutine 队列，M 从线程缓存中创建等步骤没有体现，复杂过程可以参考文章简单了解 &lt;a href=&quot;##%E5%8F%82%E8%80%83&quot;&gt;goroutine 如何实现&lt;/a&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;goroutine 使用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;demo1&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; list.Sort()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;demo2&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Announce&lt;/span&gt;&lt;span&gt;(message &lt;span&gt;string&lt;/span&gt;, delay time.Duration)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        time.Sleep(delay)&lt;br/&gt;        fmt.&lt;span&gt;println&lt;/span&gt;(message)&lt;br/&gt;    }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel 特性&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建 channel&lt;/span&gt;&lt;br/&gt;a := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;b := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 单向 channel&lt;/span&gt;&lt;br/&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;d := &lt;span&gt;make&lt;/span&gt;(&amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存入/读取/关闭&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20519159456118666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2HaM8cicRPRy49N7yUIOV1HicDicd24f9NGJpAX61qMsbe4iaDichtdKecMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;tip:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;v, ok := &amp;lt;-a  &lt;span&gt;// 检查是否成功关闭(ok = false：已关闭)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel 使用/基础&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;use channel&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;ci := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;cj := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;cs := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; *os.File, &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    list.Sort()&lt;br/&gt;    c &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}()&lt;br/&gt;doSomethingForValue&lt;br/&gt;&amp;lt;- c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt;&lt;span&gt;(queue &lt;span&gt;chan&lt;/span&gt; *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; req := &lt;span&gt;range&lt;/span&gt; queue {&lt;br/&gt;      sem &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            process(req)&lt;br/&gt;            &amp;lt;- sem&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt;&lt;span&gt;(queue &lt;span&gt;chan&lt;/span&gt; *Requet)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; req := &lt;span&gt;range&lt;/span&gt; queue {&lt;br/&gt;      sem &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(req *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;          process(req)&lt;br/&gt;            &amp;lt;- sem&lt;br/&gt;        }(req)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Serve&lt;/span&gt;&lt;span&gt;(queue &lt;span&gt;chan&lt;/span&gt; *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; req := &lt;span&gt;range&lt;/span&gt; queue {&lt;br/&gt;        req := req&lt;br/&gt;        sem &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            process(req)&lt;br/&gt;          &amp;lt;-sem&lt;br/&gt;        }()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;channel 使用/技巧&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;等待一个事件，也可以通过 close 一个 channel 就足够了。&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// close 的 channel 会读到一个零值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;}()&lt;br/&gt;&amp;lt;-c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阻塞程序&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源项目【是一个支持集群的 im 及实时推送服务】里面的基准测试的案例&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.648331830477908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2EDc9a69aslicKiaIZNe4T98LBPQmxam5jKJaQEtGDhS1tEg7HV93Gtwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1109&quot;/&gt;&lt;/figure&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;取最快结果&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ret := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;cap&lt;/span&gt;(ret); i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; call(ret)&lt;br/&gt; }&lt;br/&gt;    fmt.Println(&amp;lt;-ret)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;call&lt;/span&gt;&lt;span&gt;(ret &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; ret &amp;lt;- &lt;span&gt;&quot;result&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;协同多个 goroutines&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注:&lt;/strong&gt; 协同多个 goroutines 方案很多，这里只展示 channel 的一种。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;limits := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 缓冲区满了就会阻塞在这&lt;/span&gt;&lt;br/&gt;  limits &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;  do()&lt;br/&gt;  &amp;lt;-limits&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;搭配 select 操作&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; a := &amp;lt;- testChanA:&lt;br/&gt;        &lt;span&gt;// todo a&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; b, ok := testChanB:&lt;br/&gt;        &lt;span&gt;// todo b, 通过 ok 判断 tesChanB 的关闭情况&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;// 默认分支&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;main go routinue 确认 worker goroutinue 真正退出的方式&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;worker&lt;/span&gt;&lt;span&gt;(testChan &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// todo some&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// case ...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &amp;lt;- testChan:&lt;br/&gt;         testChan &amp;lt;- &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    testChan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; worker(testChan)&lt;br/&gt;    testChan &amp;lt;- &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &amp;lt;- testChan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关闭的 channel 不会被阻塞&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;testChan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;close&lt;/span&gt;(testChan)&lt;br/&gt;&lt;br/&gt;zeroValue := &amp;lt;- testChan&lt;br/&gt;fmt.Println(zeroValue) &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;testChan &amp;lt;- &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// panic: send on closed channel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注:&lt;/strong&gt; 如果是 &lt;code&gt;buffered channel&lt;/code&gt;, 即使被 close, 也可以读到之前存入的值，读取完毕后开始读零值，写入则会触发 panic&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nil channel 读取和存入都不会阻塞，close 会 panic&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;略&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;range 遍历 channel&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;br/&gt;c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  c &amp;lt;- i&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;}()&lt;br/&gt;&lt;span&gt;// 当 c 被关闭后，取完里面的元素就会跳出循环&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; x := &lt;span&gt;range&lt;/span&gt; c {&lt;br/&gt; fmt.Println(x)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;例: 唯一 id&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newUniqueIdService&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; id := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; counter &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   id &amp;lt;- fmt.Sprintf(&lt;span&gt;&quot;%x&quot;&lt;/span&gt;, counter)&lt;br/&gt;   counter += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; id&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newUniqueIdServerMain&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; id := newUniqueIdService()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  fmt.Println(&amp;lt;- id)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;带缓冲队列构造&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;略&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时 timeout 和心跳 heart beat&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;超时控制&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; done := do()&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;  &lt;span&gt;// logic&lt;/span&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;3&lt;/span&gt; * time.Second):&lt;br/&gt;  &lt;span&gt;// timeout&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;demo&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;开源 im/goim 项目中的应用&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6190053285968028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2wq45RIub3diaRxlfY1WCqe2YLNAc5mqs1x6t185zTiaNtVRibXofzibSuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;心跳&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(done)&lt;br/&gt; }()&lt;br/&gt; ticker := time.NewTicker(&lt;span&gt;10&lt;/span&gt; * time.Second)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;    ticker.Stop()&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-ticker.C:&lt;br/&gt;    message.Touch()&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多个 goroutine 同步响应&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; do(c)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;(c &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 会阻塞直到收到 close&lt;/span&gt;&lt;br/&gt; &amp;lt;-c&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;利用 channel 阻塞的特性和带缓冲的 channel 来实现控制并发数量&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    count := &lt;span&gt;10&lt;/span&gt; &lt;span&gt;// 最大并发&lt;/span&gt;&lt;br/&gt; sum := &lt;span&gt;100&lt;/span&gt;  &lt;span&gt;// 总数&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    c := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, count)&lt;br/&gt;    sc := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, sum)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(c)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(sc)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i:=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;sum; i++ {&lt;br/&gt;        c &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(j &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            fmt.Println(j)&lt;br/&gt;            &amp;lt;- c &lt;span&gt;// 执行完毕，释放资源&lt;/span&gt;&lt;br/&gt;            sc &amp;lt;- &lt;span&gt;struct&lt;/span&gt; {}{} &lt;span&gt;// 记录到执行总数&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i:=sum; i&amp;gt;&lt;span&gt;0&lt;/span&gt;; i++ {&lt;br/&gt;        &amp;lt;- sc&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;go 并发编程(基础库)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这块东西为什么放到 channel 之后，因为这里包含了一些低级库，实际业务代码中除了 context 之外用到都较少(比如一些锁 mutex，或者一些原子库 atomic)，实际并发编程代码中可以用 channel 就用 channel，这也是 go 一直比较推崇得做法 &lt;code&gt;Share memory by communicating; don’t communicate by sharing memory&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Mutex/RWMutex&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;锁，使用简单，保护临界区数据&lt;/p&gt;&lt;p&gt;使用的时候注意锁粒度，每次加锁后都要记得解锁&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Mutex demo&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; mutex sync.Mutex&lt;br/&gt; wait := sync.WaitGroup{}&lt;br/&gt;&lt;br/&gt; now := time.Now()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;3&lt;/span&gt;; i++ {&lt;br/&gt;  wait.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mutex.Lock()&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;   mutex.Unlock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wait.Done()&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wait.Wait()&lt;br/&gt; duration := time.Since(now)&lt;br/&gt; fmt.Print(duration)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt; 可以看到整个执行持续了 3 s 多，内部多个协程已经被 “锁” 住了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26744186046511625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2UylbnzCia52Dxz5Jq9gt4ao3VThTry9MsRTgDBbo7cN8hdZ6Ggo2f8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;516&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RWMutex demo&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意:&lt;/strong&gt; 这东西可以并发读，不可以并发读写/并发写写，不过现在即便场景是读多写少也很少用到这，一般集群环境都得分布式锁了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; m *sync.RWMutex&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m = &lt;span&gt;new&lt;/span&gt;(sync.RWMutex)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; write()&lt;br/&gt;&lt;br/&gt; time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; m.RLock()&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;startR&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;endR&quot;&lt;/span&gt;)&lt;br/&gt; m.RUnlock()&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; m.Lock()&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;startW&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;endW&quot;&lt;/span&gt;)&lt;br/&gt; m.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;输出:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.92578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2Kiakefr7R9AMD7j8FhYIeVbialQBYlAhzsG6UXVenIWR8G1AEC1vsASw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;256&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Atomic&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以对简单类型进行原子操作&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;int32&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int64&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;uint32&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;uint64&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;uintptr&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unsafe.Pointer&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以进行得原子操作如下&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;增/减&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;比较并且交换&lt;/p&gt;&lt;p&gt;假定被操作的值未曾被改变, 并一旦确定这个假设的真实性就立即进行值替换&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;载入&lt;/p&gt;&lt;p&gt;为了原子的读取某个值(防止写操作未完成就发生了一个读操作)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储&lt;/p&gt;&lt;p&gt;原子的值存储函数&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;交换&lt;/p&gt;&lt;p&gt;原子交换&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo:增&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync/atomic&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; sum &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; c := &lt;span&gt;0&lt;/span&gt;; c &amp;lt; &lt;span&gt;100&lt;/span&gt;; c++ {&lt;br/&gt;    atomic.AddUint64(&amp;amp;sum, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; wg.Wait()&lt;br/&gt; fmt.Println(sum)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3463203463203463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2fnRSzrvvvAficJDWfzZ2LJC7yhvBFFBV2KvQSxSSeiaJJ0Ih4qSnOZQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;462&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;WaitGroup/ErrGroup&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;code&gt;waitGroup 是一个 waitGroup 对象可以等待一组 goroutinue 结束，但是他对错误传递，goroutinue 出错时不再等待其他 goroutinue(减少资源浪费) 都不能很好的解决，那么 errGroup 可以解决这部分问题&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;errGroup 中如果多个 goroutinue 错误，只会获取第一个出错的 goroutinue 的错误信息，后面的则不会被感知到；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;errGroup 里面没有做 panic 处理，代码要保持健壮&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo: errGroup&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; urls = []&lt;span&gt;string&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;https://github.com/&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;errUrl&quot;&lt;/span&gt;,&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, url := &lt;span&gt;range&lt;/span&gt; urls {&lt;br/&gt;  url := url&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   resp, err := http.Get(url)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    _ = resp.Body.Close()&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; err := g.Wait()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(&lt;span&gt;&quot;getErr&quot;&lt;/span&gt;, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1609702315325248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2gWGxzW19FhkgHMjUs16UuhVT1g7jpFveEx7FKCebxN1icdRhlV8myVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;907&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;once&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;保证了传入的函数只会执行一次，这常用在单例模式，配置文件加载，初始化这些场景下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;times := &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; (&lt;br/&gt;  o  sync.Once&lt;br/&gt;  wg sync.WaitGroup&lt;br/&gt; )&lt;br/&gt; wg.Add(times)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; times; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   o.Do(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    fmt.Println(i)&lt;br/&gt;   })&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24153498871331827&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK26gmEy40rwttKMzDXFWnHVlPScEwXUX9EEGaAb6Rkv0vPUX6qnmQAsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;443&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;go 开发已经对他了解了太多&lt;/p&gt;&lt;p&gt;可以再多个 goroutinue 设置截止日期，同步信号，传递相关请求值&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对他的说明文章太多了，详细可以跳转看这篇 &lt;a href=&quot;https://km.woa.com/articles/show/426551?kmref=search&amp;amp;from_page=1&amp;amp;no=3&quot; data-linktype=&quot;2&quot;&gt;一文理解 golang context&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这边列一个遇到得问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;grpc 多服务调用，级联 cancel&lt;/p&gt;&lt;p&gt;A -&amp;gt; B -&amp;gt; C&lt;/p&gt;&lt;p&gt;A 调用 B，B 调用 C，当 A 不依赖 B 请求 C 得结果时，B 请求 C 之后直接返回 A，那么 A，B 间 context 被 cancel，而 C 得 context 也是继承于前面，C 请求直接挂掉，只需要重新搞个 context 向下传就好，记得带上 reqId, logId 等必要信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并行&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;某些计算可以再 CPU 之间并行化，如果计算可以被划分为不同的可独立执行的部分，那么他就是可并行化的，任务可以通过一个 channel 发送结束信号。&lt;/p&gt;&lt;p&gt;假如我们可以再数组上进行一个比较耗时的操作，操作的值在每个数据上独立，如下:&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; vector []&lt;span&gt;float64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(v vector)&lt;/span&gt; &lt;span&gt;DoSome&lt;/span&gt;&lt;span&gt;(i, n &lt;span&gt;int&lt;/span&gt;, u Vector, c &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; ; i &amp;lt; n; i ++ {&lt;br/&gt;        v[i] += u.Op(v[i])&lt;br/&gt;    }&lt;br/&gt;    c &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以再每个 CPU 上进行循环无关的迭代计算，我们仅需要创建完所有的 goroutine 后，从 channel 中读取结束信号进行计数即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发编程/工作流方案扩展&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这部分如需自己开发，内容其实可以分为两部分能力去做&lt;/p&gt;&lt;p&gt;需要去解决一些基础问题&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;并发编程:&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;启动 goroutine 时，增加防止程序 panic 能力&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;去封装一些更简单的错误处理方案，比如支持多个错误返回&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;限定任务的 goroutine 数量&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;工作流:&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在每个工作流执行到下一步前先去判断上一步的结果&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;工作流内嵌入一些拦截器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;singlelFlight(go 官方扩展同步包)&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般系统重要的查询增加了缓存后，如果遇到缓存击穿，那么可以通过任务计划，加索等方式去解决这个问题，singleflight 这个库也可以很不错的应对这种问题。&lt;/p&gt;&lt;p&gt;它可以获取第一次请求得结果去返回给相同得请求
核心方法 &lt;code&gt;Do&lt;/code&gt; 执行和返回给定函数的值，确保某一个时间只有一个方法被执行。&lt;br/&gt;如果一个重复的请求进入，则重复的请求会等待前一个执行完毕并获取相同的数据，返回值 shared 标识返回值 v 是否是传递给重复的调用请求。&lt;/p&gt;&lt;p&gt;一句话形容他的功能，它可以用来归并请求，但是最好加上超时重试等机制，防止第一个 &lt;code&gt;执行&lt;/code&gt; 得请求出现超时等异常情况导致同时间大量请求不可用。&lt;/p&gt;&lt;p&gt;场景: 数据变化量小(key 变化不频繁，重复率高)，但是请求量大的场景&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;demo&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/singleflight&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;math/rand&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; g singleflight.Group&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; (&lt;br/&gt; funcKey = &lt;span&gt;&quot;key&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; times = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt; randomNum = &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; rand.Seed(time.Now().UnixNano())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; wg.Add(times)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; times; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   num, err := run(funcKey)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    log.Fatal(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   log.Println(num)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; v, err, isShare := g.Do(key, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  time.Sleep(time.Second * &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;  num = rand.Intn(randomNum) &lt;span&gt;//[0,100)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; num, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; data := v.(&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; log.Println(isShare)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; data, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连续执行 3 次，返回结果如下，全部取了共享得结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.8753180661577606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK21oibsxqvxIwxBr8yMibwmFzUhQQKGHibzTaTsIPwJMcFAdAictFRZc4wPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;393&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是注释掉 &lt;code&gt;time.Sleep(time.Second * 5)&lt;/code&gt; 再尝试一次看看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8963730569948186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2VzWKtCRoqOxxkBl5TCInGvjbvKSgFGibhR8CQywywNwtibRLpx5O9XKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;386&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次全部取得真实值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实践:&lt;/strong&gt; 伙伴部门高峰期可以减少 20% 的 Redis 调用, 大大减少了 Redis 的负载&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实践&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发案例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt; 下面用到的方案因为开发时间较早，并不一定是以上多种方案中最优的，选择有很多种，使用那种方案只有有所考虑可以自圆其说即可。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;建议:&lt;/strong&gt; 项目中逐渐形成统一解决方案，从混乱到统一，逐渐小团队内对此类逻辑形成统一的一个解决标准，而不是大家对需求之外的控制代码写出各式各样的控制逻辑。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;批量校验&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;批量校验接口限频单账户最高 100qps/s，整个系统多个校验场景公用一个账户&lt;/p&gt;&lt;p&gt;限频需要限制批量校验最高为 50~80 qps/s(需要预留令牌供其他场景使用，否则频繁调用批量接口时候其他场景均会失败限频)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;设计&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 go routine 来并发进行三要素校验，因为 go routinue，所以每次开启 50 ~ 80 go routine 同时进行单次三要素校验；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每轮校验耗时 1s，如果所有 routinue 校验后与校验开始时间间隔不满一秒，则需要主动程序睡眠至 1s，然后开始下轮校验；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;因为只是校验场景，如果某次校验失败，最容易的原因其实是校验方异常，或者被其他校验场景再当前 1s 内消耗过多令牌；&lt;/p&gt;&lt;p&gt;那么整个批量接口返回 err，运营同学重新发起就好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;代码&lt;/p&gt;&lt;p&gt;代码需要进行的优化点：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加锁(推荐使用，最多不到 100 的竞争者数目，使用锁性能影响微乎其微)；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给每个传入 routine 的 element 数组包装，增加一个 key 属性，每个返回的 result 包含 key
通过 key 映射可以得到需要的一个顺序。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;sleep 1s 这个操作可以从调用前开始计时，调用完成后不满 1s 补充至 1s，而不是每次最长调用时间 elapsedTime + 1s；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通道中获取的三要素校验结果顺序和入参数据数组顺序不对应，这里通过两种方案：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分组调用 getElementResponseConcurrent 方法时，传入切片可以省略部分计算，直接使用切片表达式。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3765527950310559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavYvtWT99MRVkXmGaGLiaAK2eu5GOZe7IibcgyEltox1r5lOlibH7yj0G1RFtfbhSlOIuALcoibA33Zqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1288&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;elementNum := &lt;span&gt;len&lt;/span&gt;(elements)&lt;br/&gt;m := elementNum / &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;n := elementNum % &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; m &amp;lt; &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; results, err := getElementResponseConcurrent(ctx, elements, conn, caller); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                response.Results = results&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; response, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        results := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; n != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;                m = m + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; result []&lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= m; i++ {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; i == m {&lt;br/&gt;                        result, err = getElementResponseConcurrent(ctx, elements[(i&lt;span&gt;-1&lt;/span&gt;)*&lt;span&gt;80&lt;/span&gt;:(i&lt;span&gt;-1&lt;/span&gt;)*&lt;span&gt;80&lt;/span&gt;+n], conn, caller)&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        result, err = getElementResponseConcurrent(ctx, elements[(i&lt;span&gt;-1&lt;/span&gt;)*&lt;span&gt;80&lt;/span&gt;:i*&lt;span&gt;80&lt;/span&gt;], conn, caller)&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;                }&lt;br/&gt;                results = &lt;span&gt;append&lt;/span&gt;(results, result...)&lt;br/&gt;        }&lt;br/&gt;        response.Results = results&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// getElementResponseConcurrent&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getElementResponseConcurrent&lt;/span&gt;&lt;span&gt;(ctx context.Context, elements []*api.ThreeElements, conn *grpc.ClientConn,&lt;br/&gt;        caller *api.Caller)&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        results := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; chResult = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt;        chanErr := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; error)&lt;br/&gt;        &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(chanErr)&lt;br/&gt;        wg := sync.WaitGroup{}&lt;br/&gt;&lt;br/&gt;        faceIdClient := api.NewFaceIdClient(conn)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; _, element := &lt;span&gt;range&lt;/span&gt; elements {&lt;br/&gt;                wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(element *api.ThreeElements)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;                        param := element.Param&lt;br/&gt;                        verificationRequest := &amp;amp;api.CheckMobileVerificationRequest{&lt;br/&gt;                                Caller:       caller,&lt;br/&gt;                                Param:        param,&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; verification, err := faceIdClient.CheckMobileVerification(ctx, verificationRequest); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                                chanErr &amp;lt;- err&lt;br/&gt;                                &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;                        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                                result := verification.Result&lt;br/&gt;                                chanErr &amp;lt;- &lt;span&gt;nil&lt;/span&gt; &lt;br/&gt;                                chResult &amp;lt;- result&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;                }(element)&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(elements); i++ {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; err := &amp;lt;-chanErr; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;var&lt;/span&gt; result = &amp;lt;-chResult&lt;br/&gt;                results = &lt;span&gt;append&lt;/span&gt;(results, result)&lt;br/&gt;        }&lt;br/&gt;        wg.Wait()&lt;br/&gt;        time.Sleep(time.Second)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; results, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;历史数据批量标签&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;场景:&lt;/strong&gt; 产品上线一年，逐步开始做数据分析和统计需求提供给运营使用，接入 Tdw 之前是直接采用接口读历史表进行的数据分析，涉及全量用户的分析给用户记录打标签，数据效率较低，所以采用并发分组方法，考虑协程比较轻量，从开始上线时间节点截止当前时间分共 100 组，代码较为简单。&lt;/p&gt;&lt;p&gt;问题: 本次接口不是上线最终版，核心分析方法仅测试环境少量数据就会有 N 多条慢查询，所以这块还需要去对整体资源业务背景问题去考虑，防止线上数据量较大还有慢查询出现 cpu 打满。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>063d948a1c7e3b547fb05583d1e744b0</guid>
<title>CURD系统怎么做出技术含量惊艳面试官完善版</title>
<link>https://toutiao.io/k/2jsbhve</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;十几年前的一天，有段时间在读张爱玲的小说，同事看见了就说原来你爱看这种东西。我到现在都不知道他说的是哪种东西。那时候我只是单纯的觉得张爱玲写的东西有种特质，这种特质掌握了做什么事情都不会太差。后来我想明白了，这种特制叫做：善于运用技巧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个例子，张爱玲有个神作《金锁记》，女主经历了不幸的一生心灵扭曲，害了儿女的一生。她女儿名字叫长安。女儿30岁了，终于有人上门提亲，她却说自己女儿怎么怎么不好，还抽大烟，最后吓跑了提亲的人。这时候是这么描写长安的：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;55&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;长安悄悄的走下楼来,玄色花绣鞋与白丝袜停留在日色昏黄的楼梯上。停了一会,又上去了,一级一级,走进没有光的所在。&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;张爱玲施展她高超的绘画功力，手绘了一个电影中的分镜。不写长安的表情，不写她的心里，只给她的脚一个特写镜头。黑白的主体轮廓，昏黄的背景，画的尽头没有光，简直是野兽派画风的一幅画。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;镜头不动，只有人物的脚在动。整体包含三个画面：第一个画面是走下楼梯；第二个画面，停了一会儿，画外音：听到了提亲时的对话正好说到抽大烟的事；第三个画面是沉重的脚步走回了没有光的所在，那就是她的余生。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此时无声胜有声，一切尽在不言中。&lt;/p&gt;&lt;p/&gt;&lt;h1&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485928&amp;amp;idx=1&amp;amp;sn=d60b63b554e5d1b054f273e898ed12c5&amp;amp;chksm=fafde346cd8a6a50fbf7d2d4b3eafc36ba356e161251504203465effcf187dc5368cff9f04b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《CURD系统怎么做出技术含量--怎样引导面试》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;《CURD系统怎么做出技术含量--怎样引导面试》&lt;/a&gt;有朋友开玩笑说都用上了领域驱动了，就不叫CURD系统了吧。这里我解释一下，怕大家对DDD领域驱动设计有什么误解。&lt;/h1&gt;&lt;p&gt;DDD是为解决软件复杂性而生，但不仅仅可以被用于复杂的系统。它里面提到了很多技巧，其实&lt;span&gt;CURD就是其中一种技巧。这些技巧适用于任何系统，哪怕是非常小型的系统，比如&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485928&amp;amp;idx=1&amp;amp;sn=d60b63b554e5d1b054f273e898ed12c5&amp;amp;chksm=fafde346cd8a6a50fbf7d2d4b3eafc36ba356e161251504203465effcf187dc5368cff9f04b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《CURD系统怎么做出技术含量--怎样引导面试》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;《CURD系统怎么做出技术含量--怎样引导面试》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里提到的谦卑对象模型、充血模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天咱们再提高一下CURD系统的门槛，连DDD技巧，咱也不用。就用写咱们平时都在写的最简单的接口。能说明设计理念，也能惊艳到面试官：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大纲&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三种设计方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;n+m返回值设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一个接口入参有n个值，需要的返回值是m个值。在返回值中可以把入参和返回值一起返回。&lt;/p&gt;&lt;p&gt;这种设计便于追踪和排查问题：&lt;/p&gt;&lt;p&gt;为了防止调用方没有日志追踪号、打印日志过多等原因造成不方便跟踪请求的问题，可以设计返回值将入参一起打印。这样调用方可以通过一条日志方便的获取到入参和返回值。线上排查问题会非常方便。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;建议使用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;假设有个场景，调用方的系统设计不方便请求追踪，比如没有线程追踪号。在高并发量场景下可能日志是这样的：&lt;/p&gt;&lt;p&gt;1、thread-1|ClassName|参数1：11，参数2:11&lt;/p&gt;&lt;p&gt;2、thread-2|ClassName|参数1：22，参数2:22&lt;/p&gt;&lt;p&gt;3、thread-1|ClassName|参数1：33，参数2:33&lt;/p&gt;&lt;p&gt;4、thread-2|ClassName|返回值：44&lt;/p&gt;&lt;p&gt;5、thread-1|ClassName|返回值：55&lt;/p&gt;&lt;p&gt;6、thread-1|ClassName|返回值：66&lt;/p&gt;&lt;p&gt;你能决定55和66对应的谁是1，谁是3的返回值吗？&lt;/p&gt;&lt;p&gt;但是如果返回值包含了入参，就好办多了，举个返回值例子：&lt;/p&gt;&lt;p&gt;thread-1|ClassName|{参数1：11，参数2:11，返回值：55}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这样就一目了然。有的时候可能是调用方本身的设计问题，但是如果被调用方能通过巧妙的设计帮助调用方。一旦遇到问题，调用方可以自己先进行排查，不用马上联系被调用方帮忙。即节约了自身的成本，又体现了专业性，何乐不为。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不建议使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、公司内有规范的、完善的、各个部门严格执行的全链路追踪标准&lt;/p&gt;&lt;p&gt;2、入参很大，不建议全量打印，可选取部分关键或者完全不用&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;终态设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484245&amp;amp;idx=1&amp;amp;sn=60bb5324704d43cfb0e72cb642ac4604&amp;amp;chksm=fafde9fbcd8a60edf8c96f162bfac9980c9623708bb03937969b25ef87eb4526d5a1f41aba26&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《实战并发-使用分布式缓存和有限状态机》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;《实战并发-使用分布式缓存和有限状态机》&lt;/a&gt;里我讲过有限状态自动机。有限状态机涉及状态流转。状态从分类上可以分成三种：初始状态、中间状态和终态。这段时间不是一直在讲TCP底层通信嘛，来一张TCP状态的流转图体会一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1457905544147844&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9LBKNIvtzhGvak690hYJBokOn5mtWNNFSxAA3fS8p2n6Z1VBzuxic8r4vDNPtsY0nkHPokZ5LtkoA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;有限状态机的重点在于有限，要有起点和终点。也就是一定要有终态。在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484510&amp;amp;idx=1&amp;amp;sn=dbe4c622a7ef5d667f675420d5e4464c&amp;amp;chksm=fafdeef0cd8a67e64981d80c89c2c0a8fcb36177e5e19dcde180bc1e9718b577dce4d5d2d937&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《稳定性三十六计-超时处理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《稳定性三十六计-超时处理》&lt;/a&gt;我讲过：&lt;/p&gt;&lt;p&gt;在传统的单机系统中，调用一个函数，要么返回成功，要么返回失败。这就是两态系统(2-state system)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在分布式系统中，由于系统是分布在不同机器上的。还可能有一种状态叫：超时。成功、失败和超时是分布式系统调用的三态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9903846153846154&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicVYPeHOxevrQLEBUbDBBKiciaDnUCKK0N50iax8Y2X76Opom64icx9fJ01FGHpfACwXp46wDE51oU72w/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;超时不是终态，而是一种中间状态：最终有可能下游是成功了，也有可能是失败了。这时候我们需要在超时之后推定一种状态，推定成功或者失败。究竟是成功还是失败因功能而已。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;建议使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如付款操作，不知道是否成功就推定是成功的，那用户可能没有付款就拿到了商品或者享受了服务。商家就会资金损失。所以一般会推定失败。让用户再次支付。最终通过查询或者对账发现用户实际是支付成功的，可以再把钱给用户退回去，保证交易的公平性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;退款恰恰相反，需要推定成功。告诉用户，钱退给你了。最终通过查询或者对账发现实际是退款失败了，可以系统重新发起退款，直到真正退成功为止。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后台管理系统也很需要这种终态设计。比如发布系统，发布了一个功能，发布系统如果出现了问题，这次发布没有结束。用户可能没有办法进行下一次发布。这时候可以设置超时自动结束，防止未结束的流程始终在那里，起码会干扰视线，增加判断成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不建议使用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这十几年的开发还没有遇到过什么场景不需要终态。但是有些终态是隐式的。举个例子：&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485963&amp;amp;idx=1&amp;amp;sn=285f1bc91108e036bd4d4a1d5e1d244d&amp;amp;chksm=fafde0a5cd8a69b35572258dcd12f73218c3c72a7014e5c124b85078922bf5967605a4d867c4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个反直觉的sql》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个反直觉的sql》&lt;/a&gt;里提到的&lt;span&gt;&lt;strong&gt;事件溯源模式&lt;/strong&gt;&lt;/span&gt;，就是说比如在一张数据表中，只做数据记录用，只有插入操作没有更新操作。比如一个用户行为记录表，会记录用户什么时候登陆，因为用户是APP登陆的，所以2年都没有登出操作。是不是就没有终态呢？我们从这张表本身来看，因为是事件记录，所以落库的那一瞬间，状态就是“记录完成”，本身就是终态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;两码一态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;两码是指系统码和业务码，一态是说通过两码就可以确定最终的状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多情况下咱们是已经隐式的使用了两码一态，比如自己设计了一个单点登录接口给外部调用。一般是这样设计：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际上这个接口有个返回值，比如登录成功会返回用户信息或者直接返回&lt;span&gt;是否成功的布尔值&lt;/span&gt;。但是这个接口是给外部调用的，需要包装一层，最终就是返回&lt;span&gt;Re&lt;/span&gt;&lt;span&gt;sult&lt;/span&gt;&lt;span&gt;&amp;lt;User&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;或者Result&amp;lt;Boolean&amp;gt;。Result是怎么定义的呢？&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Result&amp;lt;T&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; isSuccess;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; errorCode;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; errorMessage;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; T data;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有没有感觉和自己平时写的代码很像？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分析一下：最外层isSuccess很多人都把它当成最终的状态来使用。比如在这个登录的场景下就代表了登录成功。但是如果isSuccess=true但是data==null？这就让人很迷惑，究竟是成功还是没有成功呢。成功了为啥我的数据没有吐给我？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;稍微合理一点的是&lt;span&gt;isSuccess&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;代表系统处理成功，就是没有抛出什么异常。究竟业务是否成功看data。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在更加规范的场合是这么定义的：&lt;/p&gt;&lt;pre&gt;&lt;br/&gt;&lt;span&gt;@Data&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public class &lt;/span&gt;Result&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;private &lt;/span&gt;String &lt;span&gt;sysCode&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;String &lt;span&gt;sysMessage&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;String &lt;span&gt;bizCode&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;String &lt;span&gt;bizMessage&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private &lt;/span&gt;&lt;span&gt;T &lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;如果系统码sysCode为成功，是否业务成功需要看bizCode；如果sysCode失败，bizCode就不用看了，也很可能根本就没有拿到；如果sysCode为失败，看系统码是多少就可以定位问题范围，或者至少说这个问题开发人员应该查查；如果bizCode为失败，如果业务码也能定位问题范围，而这种问题一般不需要开发人员来处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;建议使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如后台管理系统中，可以定义：连接数据库异常、空指针异常等为系统失败，对两种异常分配不同的系统码，比如S001、S002；系统正常码可以分配S000；必填参数为空、参数校验失败为业务码，比如B001、B002；业务正常可以分配B000。最终状态由两个码共同决定。当系统码异常开发人员需要处理。当业务码异常可以联系运营人员培训一下怎么老填错或者不处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如我在之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485988&amp;amp;idx=1&amp;amp;sn=efad5a030bc0a933ac5af2ee09f3c6c4&amp;amp;chksm=fafde08acd8a699c198d0d65c413273f05f2796cfd873160c2ba81ed3f33aebfaccb62234cb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个http请求进来都经过了什么(2021版)》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个http请求进来都经过了什么(2021版)》&lt;/a&gt;中设立过一个场景&lt;/p&gt;&lt;p&gt;假设我在超市买了我喜爱的经典搭配：烤肠+酸奶。然后我就微信扫码付款了。付款时序图大体是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.734533183352081&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwyMoVfkKaltdY7gIqsowo8keN6ic7ibzrHZZWVGq0eo5aNOxU5OXdFUNMMoqkq8g5Z2qol66SA9gg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;不用理解这个图，关系不大。我要说的是像支付这种场景后面会涉及多个环节，比如微信支付自身还要调用银行呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候的系统码和状态码中可以加一位，代表那个环节。比如系统码定义：&lt;/p&gt;&lt;p&gt;WS000、&lt;span&gt;W&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;001……&lt;span&gt;BS&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;、B&lt;/span&gt;&lt;span&gt;S001&lt;/span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;S代表系统。W代表微信，比如下游请求银行，银行处理成功了，自身异常了，会设置这个码；B代表银行，比如银行自身异常了会设置这个码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同理，业务码&lt;span&gt;定义&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;WB&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;WB&lt;/span&gt;&lt;span&gt;001……&lt;span&gt;BB&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;、BB&lt;/span&gt;&lt;span&gt;001&lt;/span&gt;……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;第二个B代表业务。W代表微信，比如自身校验没有通过，根本不会请求银行，会设置这个码；第一个B代表银行，比如银行最后发现用户余额不足会设置这个码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不建议使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果是给一个进程内部自身使用的，当然就没有必要定义这么复杂。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e250015b75462f4a9053b907b9acbfd</guid>
<title>分布式锁用Redis好？还是Zookeeper好？</title>
<link>https://toutiao.io/k/dliy2zu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过目前互联网项目越来越多的项目采用集群部署，也就是分布式情况，这两种锁就有些不够用了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来两张图举例说明下，本地锁的情况下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6891891891891891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLn5KdSrodIRt9JZ61sjZSc1wYc9YoUAWNbEfiau0VzGGd3STmtHPMe1vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式锁情况下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5166163141993958&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnzia31jH6lMRCKkPwJBFQ6x3WvX3uiaRJ50tsRc4HobC4ZCJU7q2u771w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就其思想来说，就是一种“我全都要”的思想，所有服务都到一个统一的地方来取锁，只有取到锁的才能继续执行下去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.539440203562341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnuDDxL5hD60aq2Z3R0mYJZgBQicIdha8cr704sOian7y1gopppAZqXapQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;393&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完思想，下面来说一下具体的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为实现分布式锁，在 Redis 中存在 &lt;code&gt;SETNX key value&lt;/code&gt; 命令，意为 &lt;code&gt;set if not exists&lt;/code&gt;（如果不存在该 key，才去 set 值），就比如说是张三去上厕所，看厕所门锁着，他就不进去了，厕所门开着他才去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22657952069716775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLngSF64JxibJlXgjHYmmGleA9TcQQbTdrdWDtn7fgeia9dfIseibr5uxHXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，第一次 set 返回了 1，表示成功，但是第二次返回 0，表示 set 失败，因为已经存在这个 key 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然只靠 setnx 这个命令可以吗？当然是不行的，试想一种情况，张三在厕所里，但他在里面一直没有释放，一直在里面蹲着，那外面人想去厕所全部都去不了，都想锤死他了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 同理，假设已经进行了加锁，但是因为宕机或者出现异常未释放锁，就造成了所谓的“死锁”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9063829787234042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnwM8cSicdKUa7R30GLDfkTAK2OUpa7EPdicKpVStgJJmKZIV5IIPF6b3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;235&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聪明的你们肯定早都想到了，为它设置过期时间不就好了，可以 &lt;code&gt;SETEX key seconds value&lt;/code&gt; 命令，为指定 key 设置过期时间，单位为秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样又有另一个问题，我刚加锁成功，还没设置过期时间，Redis 宕机了不就又死锁了，所以说要保证原子性吖，要么一起成功，要么一起失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们能想到的 Redis 肯定早都为你实现好了，在 Redis 2.8 的版本后，Redis 就为我们提供了一条组合命令 &lt;code&gt;SET key value ex seconds nx&lt;/code&gt;，加锁的同时设置过期时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2768670309653916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnZyXGRgcvmUPhpgMXcE96w55AiaBDMnPNV32ic6qV9pIaF2vAhoNvy9Nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就好比是公司规定每人最多只能在厕所呆 2 分钟，不管释放没释放完都得出来，这样就解决了“死锁”问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样就没有问题了吗？怎么可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想又一种情况，厕所门肯定只能从里面开啊，张三上完厕所后张四进去锁上门，但是外面人以为还是张三在里面，而且已经过了 3 分钟了，就直接把门给撬开了，一看里面却是张四，这就很尴尬啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换成 Redis 就是说比如一个业务执行时间很长，锁已经自己过期了，别人已经设置了新的锁，但是当业务执行完之后直接释放锁，就有可能是删除了别人加的锁，这不是乱套了吗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在加锁时候，要设一个随机值，在删除锁时进行比对，如果是自己的锁，才删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多说无益，烦人，直接上代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//基于jedis和lua脚本来实现&lt;/span&gt;&lt;br/&gt;privatestaticfinal String LOCK_SUCCESS = &lt;span&gt;&quot;OK&quot;&lt;/span&gt;;&lt;br/&gt;privatestaticfinal Long RELEASE_SUCCESS = &lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt;privatestaticfinal String SET_IF_NOT_EXIST = &lt;span&gt;&quot;NX&quot;&lt;/span&gt;;&lt;br/&gt;privatestaticfinal String SET_WITH_EXPIRE_TIME = &lt;span&gt;&quot;PX&quot;&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 获取锁的超时时间，超过这个时间则放弃获取锁&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; end = System.currentTimeMillis() + acquireTimeout;&lt;br/&gt;        &lt;span&gt;// 随机生成一个 value&lt;/span&gt;&lt;br/&gt;        String requireToken = UUID.randomUUID().toString();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (System.currentTimeMillis() &amp;lt; end) {&lt;br/&gt;            String result = jedis&lt;br/&gt;                .set(lockKey, requireToken, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (LOCK_SUCCESS.equals(result)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; requireToken;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                Thread.currentThread().interrupt();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;acquire lock due to error&quot;&lt;/span&gt;, e);&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    returnnull;&lt;br/&gt;}&lt;br/&gt; &lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(String identify)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (identify == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        returnfalse;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//通过lua脚本进行比对删除操作，保证原子性&lt;/span&gt;&lt;br/&gt;    String script = &lt;span&gt;&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;&lt;/span&gt;;&lt;br/&gt;    Object result = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        result = jedis.eval(script, Collections.singletonList(lockKey),&lt;br/&gt;            Collections.singletonList(identify));&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (RELEASE_SUCCESS.equals(result)) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;release lock success, requestToken:{}&quot;&lt;/span&gt;, identify);&lt;br/&gt;            returntrue;&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;release lock due to error&quot;&lt;/span&gt;, e);&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (jedis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            jedis.close();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    log.info(&lt;span&gt;&quot;release lock failed, requestToken:{}, result:{}&quot;&lt;/span&gt;, identify, result);&lt;br/&gt;    returnfalse;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;思考：加锁和释放锁的原子性可以用 lua 脚本来保证，那锁的自动续期改如何实现呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redisson 实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson 顾名思义，Redis 的儿子，本质上还是 Redis 加锁，不过是对 Redis 做了很多封装，它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在引入 Redisson 的依赖后，就可以直接进行调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.redisson&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;redisson&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.13.4&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来一段 Redisson 的加锁代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//分布式锁名  锁的粒度越细，性能越好&lt;/span&gt;&lt;br/&gt;    RLock lock = redissonClient.getLock(&lt;span&gt;&quot;test_lock&quot;&lt;/span&gt;);&lt;br/&gt;    lock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//具体业务......&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这么简单，使用方法 jdk 的 ReentrantLock 差不多，并且也支持 ReadWriteLock（读写锁）、Reentrant Lock（可重入锁）、Fair Lock（公平锁）、RedLock（红锁）等各种锁，详细可以参照redisson官方文档来查看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8220640569395018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnxzrsS3T54ic8vywwjvIWtwG4aObh1FrDnFTgic2jtdm0RjiarY4ibIcfVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;281&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 Redisson 到底有哪些优势呢？锁的自动续期（默认都是 30 秒），如果业务超长，运行期间会自动给锁续上新的 30s，不用担心业务执行时间超长而锁被自动删掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁的业务只要运行完成，就不会给当前续期，即便不手动解锁，锁默认在 30s 后删除，不会造成死锁问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面也提到了锁的自动续期，我们来看看 Redisson 是如何来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说明一下，这里主要讲的是 Redisson 中的 RLock，也就是可重入锁，有两种实现方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 最常见的使用方法&lt;/span&gt;&lt;br/&gt;lock.lock();&lt;br/&gt; &lt;br/&gt;&lt;span&gt;// 加锁以后10秒钟自动解锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 无需调用unlock方法手动解锁&lt;/span&gt;&lt;br/&gt;lock.lock(&lt;span&gt;10&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而只有无参的方法是提供锁的自动续期操作的，内部使用的是“看门狗”机制，我们来看一看源码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9658536585365853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnAP5Eib55JI6vWhLtFfftvbzYfLFCB4ic8pwLlfniaOMDmlQPajPo0licGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;205&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9158415841584159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnFTHc1ibIaaG4kJKOrDicgHIuwJzeCwvoXVvV1plF1K6dyfgR7tK0TvIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;404&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是空参还是带参方法，它们都调用的是同一个 lock 方法，未传参的话时间传了一个 -1，而带参的方法传过去的就是实际传入的时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6795048143053645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnsypK9ZKONpOSjV1bk0CkEzPEjC5ibBTyNqTGCOFHStrP24Fh7hB11rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续点进 scheduleExpirationRenewal 方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38394160583941606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnC5GYE6C26nY7JCDDIvoq6Wzx2oDu5EZLwT5BLoKzmPIq8DJGicEkEpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点进 renewExpiration 方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9939849624060151&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnwTx0dPRMMWR1icmBLXJ0AwljSE4fEicJVqubACPlBHic1NROhpOmfUJicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，就是当我们指定锁过期时间，那么锁到时间就会自动释放。如果没有指定锁过期时间，就使用看门狗的默认时间 30s，只要占锁成功，就会启动一个定时任务，每隔 10s 给锁设置新的过期时间，时间为看门狗的默认时间，直到锁释放。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;小结：虽然 lock() 有自动续锁机制，但是开发中还是推荐使用 &lt;code&gt;lock(time，timeUnit)&lt;/code&gt;，因为它省掉了整个续期带来的性能损，可以设置过期时间长一点，搭配 &lt;code&gt;unlock()&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若业务执行完成，会手动释放锁，若是业务执行超时，那一般我们服务也都会设置业务超时时间，就直接报错了，报错后就会通过设置的过期时间来释放锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    RLock lock = redissonClient.getLock(&lt;span&gt;&quot;test_lock&quot;&lt;/span&gt;);&lt;br/&gt;    lock.lock(&lt;span&gt;30&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//.......具体业务&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//手动释放锁&lt;/span&gt;&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;推荐下自己做的 Spring Boot 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/ruoyi-vue-pro&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴都知道在分布式系统中，可以用 ZK 来做注册中心，但其实在除了做祖册中心以外，用 ZK 来做分布式锁也是很常见的一种方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看一下 ZK 中是如何创建一个节点的？ZK 中存在 &lt;code&gt;create [-s] [-e] path [data]&lt;/code&gt; 命令，&lt;code&gt;-s&lt;/code&gt; 为创建有序节点，&lt;code&gt;-e&lt;/code&gt; 创建临时节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12410501193317422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnpnCq8RKArGPxtDiaQib5b9snLdwzDl98tFkrrRqQCBicjHA9NoMLIgicbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就创建了一个父节点并为父节点创建了一个子节点，组合命令意为创建一个临时的有序节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 ZK 中分布式锁主要就是靠创建临时的顺序节点来实现的。至于为什么要用顺序节点和为什么用临时节点不用持久节点？先考虑一下，下文将作出说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还有 ZK 中如何查看节点？ZK 中 &lt;code&gt;ls [-w] path&lt;/code&gt; 为查看节点命令，&lt;code&gt;-w&lt;/code&gt; 为添加一个 watch（监视器），&lt;code&gt;/&lt;/code&gt; 为查看根节点所有节点，可以看到我们刚才所创建的节点，同时如果是跟着指定节点名字的话为查看指定节点下的子节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1815068493150685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLn1icCA1xmYRuXbCCaLrn17WTOBZ6HMFfXSzJ6MRibictY1OQX5nboh3O7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的 00000000 为 ZK 为顺序节点增加的顺序。注册监听器也是 ZK 实现分布式锁中比较重要的一个东西。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5086505190311419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnb156HMyHiaXDZCGXrBBJq96GJib7Twe7iagUrqMsJBAEtaUKJm0OxqD1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看一下 ZK 实现分布式锁的主要流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当第一个线程进来时会去父节点上创建一个临时的顺序节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个线程进来发现锁已经被持有了，就会为当前持有锁的节点注册一个 watcher 监听器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三个线程进来发现锁已经被持有了，因为是顺序节点的缘故，就会为上一个节点去创建一个 watcher 监听器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当第一个线程释放锁后，删除节点，由它的下一个节点去占有锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，聪明的小伙伴们都已经看出来顺序节点的好处了。非顺序节点的话，每进来一个线程进来都会去持有锁的节点上注册一个监听器，容易引发“羊群效应”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4533333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupXicOvg8iaQo6eW4ibiaH0NOyLnz7bD4b3MDaNVXUdd5CibG7wGSeGkm8x13Q4AIcbIBj2XWcJib5vUFGFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么大一群羊一起向你飞奔而来，不管你顶不顶得住，反正 ZK 服务器是会增大宕机的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而顺序节点的话就不会，顺序节点当发现已经有线程持有锁后，会向它的上一个节点注册一个监听器，这样当持有锁的节点释放后，也只有持有锁的下一个节点可以抢到锁，相当于是排好队来执行的，降低服务器宕机风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么使用临时节点，和 Redis 的过期时间一个道理，就算 ZK 服务器宕机，临时节点会随着服务器的宕机而消失，避免了死锁的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来上一段代码的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ZooKeeperDistributedLock&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Watcher&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ZooKeeper zk;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String locksRoot = &lt;span&gt;&quot;/locks&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String productId;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String waitNode;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String lockNode;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch connectedLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sessionTimeout = &lt;span&gt;30000&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ZooKeeperDistributedLock&lt;/span&gt;&lt;span&gt;(String productId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.productId = productId;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            String address = &lt;span&gt;&quot;192.168.189.131:2181,192.168.189.132:2181&quot;&lt;/span&gt;;&lt;br/&gt;            zk = &lt;span&gt;new&lt;/span&gt; ZooKeeper(address, sessionTimeout, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            connectedLatch.await();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;process&lt;/span&gt;&lt;span&gt;(WatchedEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (event.getState() == KeeperState.SyncConnected) {&lt;br/&gt;            connectedLatch.countDown();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.latch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch.countDown();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquireDistributedLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.tryLock()) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                waitForLock(waitNode, sessionTimeout);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//获取锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 传入进去的locksRoot + “/” + productId&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 假设productId代表了一个商品id，比如说1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// locksRoot = locks&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// /locks/10000000000，/locks/10000000001，/locks/10000000002&lt;/span&gt;&lt;br/&gt;        lockNode = zk.create(locksRoot + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + productId, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;// 看看刚创建的节点是不是最小的节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// locks：10000000000，10000000001，10000000002&lt;/span&gt;&lt;br/&gt;        List&amp;lt;String&amp;gt; locks = zk.getChildren(locksRoot, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        Collections.sort(locks);&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(lockNode.equals(locksRoot+&lt;span&gt;&quot;/&quot;&lt;/span&gt;+ locks.get(&lt;span&gt;0&lt;/span&gt;))){&lt;br/&gt;            &lt;span&gt;//如果是最小的节点,则表示取得锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;//如果不是最小的节点，找到比自己小1的节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; previousLockIndex = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; locks.size(); i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(lockNode.equals(locksRoot + “/” + locks.get(i))) {&lt;br/&gt;                    previousLockIndex = i - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;       }&lt;br/&gt; &lt;br/&gt;       &lt;span&gt;this&lt;/span&gt;.waitNode = locks.get(previousLockIndex);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException(e);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;waitForLock&lt;/span&gt;&lt;span&gt;(String waitNode, &lt;span&gt;long&lt;/span&gt; waitTime)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, KeeperException &lt;/span&gt;{&lt;br/&gt;        Stat stat = zk.exists(locksRoot + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + waitNode, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (stat != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch.await(waitTime, TimeUnit.MILLISECONDS);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.latch = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;//释放锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;unlock &quot;&lt;/span&gt; + lockNode);&lt;br/&gt;            zk.delete(lockNode, -&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            lockNode = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            zk.close();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (KeeperException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//异常&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockException&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;RuntimeException&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LockException&lt;/span&gt;&lt;span&gt;(String e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(e);&lt;br/&gt;        }&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LockException&lt;/span&gt;&lt;span&gt;(Exception e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;推荐下自己做的 Spring Cloud 的实战项目：&lt;/p&gt;&lt;p&gt;https://github.com/YunaiV/onemall&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然明白了 Redis 和 ZK 分别对分布式锁的实现，那么总该有所不同的吧。没错，我都帮大家整理好了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现方式的不同，Redis 实现为去插入一条占位数据，而 ZK 实现为去注册一个临时节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到宕机情况时，Redis 需要等到过期时间到了后自动释放锁，而 ZK 因为是临时节点，在宕机时候已经是删除了节点去释放锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 在没抢占到锁的情况下一般会去自旋获取锁，比较浪费性能，而 ZK 是通过注册监听器的方式获取锁，性能而言优于 Redis。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过具体要采用哪种实现方式，还是需要具体情况具体分析，结合项目引用的技术栈来落地实现。&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>32b5f42bb99883478488d80c86294b63</guid>
<title>优质网站同好者周刊（第 44 期）- 倾城之链 - 悠然宜想亭</title>
<link>https://toutiao.io/k/1o7k62m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot; rel=&quot; nofollow ugc&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot; rel=&quot; nofollow ugc&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%AE%BE%E8%AE%A1&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;设计&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E9%85%8D%E8%89%B2&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;配色&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/CSS&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;CSS&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：webdesign, ui, ux, ui kit, gradients, backdrop, sketch, photoshop, freebie, free, web, webdev, css3, css, colors, animation, psd, palette, colour, background&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Come to WebGradients.com for 180 beautiful linear gradients in CSS3, Photoshop and Sketch. This collection is curated by top designers and totally free.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/webgradients.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Fresh Background Gradients | WebGradients.com 💎&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://webgradients.com/&quot; rel=&quot; nofollow ugc&quot;&gt;WebGradients.com 💎&lt;/a&gt; 是 180 个线性渐变的免费集合（同类网站还有 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://uigradients.com/&quot; rel=&quot; nofollow ugc&quot;&gt;uiGradients&lt;/a&gt; ），您可以将其用作网站任何部分的&lt;strong&gt;内容背景&lt;/strong&gt;。轻松复制 CSS3 跨浏览器代码并立即使用！他们还准备了每个渐变的 &lt;code&gt;.PNG&lt;/code&gt; 版本。作为奖励，还有&lt;a href=&quot;https://nicelinks.site/post/5a954cd40b0590113aa144cd&quot; rel=&quot; nofollow ugc&quot;&gt;Sketch&lt;/a&gt; 和  &lt;code&gt;Photoshop&lt;/code&gt; 包 。值得一提的是，该系列由顶级设计师策划，完全免费。发现这网站后，有在&lt;a href=&quot;https://nicelinks.site/post/6143390948b293062990b351&quot; rel=&quot; nofollow ugc&quot;&gt;曼妙句子&lt;/a&gt;中运用，产生非常出色的效果。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61b9f1c848f785032a2400bb&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Fresh Background Gradients | WebGradients.com 💎&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%9F%AD%E8%A7%86%E9%A2%91&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;短视频&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/AI&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%B3%E5%8F%B0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;平台&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;来画是有创意的 AI 动画短视频制作平台，仅需几张图片，几段文字和声音简单组合，即可在短时间内生成一个有趣的动画短视频。丰富视频模板素材免费用！对于企业用户，还有动画高端定制服务。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.laihua.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 来画-一站式数字创作创意平台&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.laihua.com/&quot; rel=&quot; nofollow ugc&quot;&gt;来画&lt;/a&gt;，一站式数字创作创意平台（隶属深圳市前海手绘科技文化有限公司（简称“来画”），于 2015 年 7 月 30 号在深圳前海注册），累计了数千万用户，产生了上千万部作品，目前是国家文化和旅游部、新华社、人民日报的合作伙伴。&lt;/p&gt;

&lt;p&gt;秉持“科技创新，让创作更简单，让创意更美好”的使命，来画着力打造了&lt;strong&gt;来画动画&lt;/strong&gt;（动画短视频云端创作平台）、&lt;strong&gt;来画演示&lt;/strong&gt;（创意演示工具）、&lt;strong&gt;来画视频&lt;/strong&gt;（AR视频演示工具）、&lt;strong&gt;来画设计&lt;/strong&gt;（新一代设计软件）、&lt;strong&gt;来画白板&lt;/strong&gt;（实时协作的在线白板软件）等 5 大系列工具产品，并搭建了创意服务供给平台来画梦工厂，以及数字创意职业教育培训平台&lt;strong&gt;来画学园&lt;/strong&gt;，为企业和个人真正提供高效、卓越的数字创意服务。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;来画动画&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;来画动画，动画视频云端智能创作平台&lt;/strong&gt;。拥有 Web 端、APP 端两大视频创作工具，平台上配置了海量的视频模版和素材，以动画风格为主，实拍类素材为辅。用户只通过简单的模块化操作、拖拽与编辑，就能轻松将图片、文字、音乐、人物角色、道具、图表等素材完美结合，真正实现“像做PPT一样做动画”。&lt;/p&gt;

&lt;h3&gt;来画视频&lt;/h3&gt;

&lt;p&gt;2021 年，来画推出了一个&lt;strong&gt;真人与内容实时互动&lt;/strong&gt;的 AR 视频演示工具，也是首个将视频制作、视频录制、视频会议结合在一起的视频演示产品，让演示内容和真人完美融合，让会议、汇报、演讲、课件等变得生动有趣。&lt;/p&gt;

&lt;h3&gt;来画演示&lt;/h3&gt;

&lt;p&gt;2021年7月，来画演示（来画Perfoo）重磅登场，这是一款&lt;strong&gt;拥有上帝视角&lt;/strong&gt;的创意演示工具，让创意冲破空间的束缚，开启前所未有的酷炫演示体验。它颠覆了 PPT 的线性叙事结构，采用从整体到局部的全新演示方式，让用户清晰、准确地表述自己的逻辑想法，打造出立体思维导图式的演示内容，随时随地掌控全局。同时也能帮助观众更快速地理解内容，跟随演示者的思维去发现、去思考。&lt;/p&gt;

&lt;p&gt;无边界画布功能，打破传统演示内容编辑的界限，将用户置身上帝视角，可以在画布上随意放置各种想要展示的内容，加上镜头缩放、旋转、平移等多种转场特效，整个演示过程就像 3D 动画电影一样，极具视觉冲击力和电影故事感。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;来画设计&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;来画设计，简单、智能的新一代设计软件&lt;/strong&gt;，解决专业图表设计难题和日常设计需求。平台上拥有海量的&lt;strong&gt;数据可视化模板&lt;/strong&gt;，只需简单拖放，即可轻松做出专业的数据图表、商业报告、思维导图、宣传海报等，让你的内容展示更具吸引力、说服力，适用于商务汇报、项目总结、政府报告、教育培训等众多场景。&lt;/p&gt;

&lt;p&gt;同时，平台上线了精美的&lt;strong&gt;平面设计模板&lt;/strong&gt;，包括新媒体配图、电商海报、来画动画配图、信息图表等类型，即使不懂设计，不会PS，直接换字换图，也能快速搞定。轻松解决金融宣传、微课教育、知识科普等各种设计难题。&lt;/p&gt;

&lt;h3&gt;来画白板&lt;/h3&gt;

&lt;p&gt;来画白板，一款&lt;strong&gt;实时协作&lt;/strong&gt;的在线白板软件。可以随时随地将团队聚集在一起，开启在线讨论和创意分享。&lt;/p&gt;

&lt;p&gt;在平台上，创作者可自由邀请其他成员加入白板，进行会议讨论和头脑风暴。使用画笔、便签、形状条等功能，可以表达更多的想法和建议；添加箭头、符号、图标等元素，能更好地梳理想法，展示其中的逻辑与关系；你还可以使用表情进行评论、点赞，让整个讨论过程更加有趣，更有吸引力。&lt;/p&gt;

&lt;h3&gt;画梦工厂&lt;/h3&gt;

&lt;p&gt;来画梦工厂是来画精心打造的创意服务供给平台，提供动画定制、创意定制、短视频大赛、创作者联盟、手绘城市墙、视频营销等多项创意服务，依靠个性化表达、高质量内容，致力于解决数字化经济中全行业品牌升级和发展难题。&lt;/p&gt;

&lt;h3&gt;来画学园&lt;/h3&gt;

&lt;p&gt;来画学园是顺应 5G 时代下数字经济和文化科技的发展浪潮，以“授人以鱼不如授人以渔”为办学理念，着力打造的数字创意职业教育培训平台。它分为线上线下两大板块，线上搭建用户社区：来画数创公社；线下打造培训基地：来画数创职业教育基地和来画数创成长教育基地，实现全方位、多渠道的高效数字创意教育培训，为短视频业态注入新活力。&lt;/p&gt;


&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61b9ed1d48f785032a2400b9&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 来画-一站式数字创作创意平台&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;网站生成器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BA%94%E7%94%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;应用&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E5%8F%91%E8%80%85&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;开发者&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Build Web3 projects in minutes with smart contracts you control, tools that accelerate your workflow and intuitive SDKs and widgets for developers.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/thirdweb.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - thirdweb&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://thirdweb.com/&quot; rel=&quot; nofollow ugc&quot;&gt;thirdweb&lt;/a&gt;，轻松构建 web3 应用程序和游戏；您控制的智能合约，加速您的工作流程的工具。面向开发人员的直观 SDK 和小部件。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;⛏️ 生成等功能NFT的，商场，令牌和更多的点击几下；&lt;/li&gt;
&lt;li&gt;🧰 工具 SDK 的，窗口小部件和接口集成 WEB3 功能为您的应用程序；&lt;/li&gt;
&lt;li&gt;🕹️ 的权力游戏 blockchain，DAO 的、NFT 卡平台、生成艺术掉落等等；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;背景故事：Furqan（一名连续创业者）与一群试图启动 NFT 和 web3 项目的团队合作。在那段时间里，他们了解到，开发这些体验的最大障碍是学习新的编程语言和&lt;strong&gt;区块链&lt;/strong&gt;。这就是为什么我们推出了 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://thirdweb.com/&quot; rel=&quot; nofollow ugc&quot;&gt;thirdweb&lt;/a&gt;：一个让构建 web3 应用程序和游戏变得难以置信的简单的平台。通过将他们的智能合约与你的钱包（你拥有的）进行部署，来解决区块链的复杂性，并提供SDK、小工具和接口，将 web3 功能整合到任何应用程序、游戏或 DAO 中。&lt;/p&gt;

&lt;p&gt;通过 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://thirdweb.com/&quot; rel=&quot; nofollow ugc&quot;&gt;thirdweb&lt;/a&gt;，你可以推出 NFT，创建市场，引入新的社会代币，创建 NFT 的包等等。你可以通过团队权限、自定义版税分割，和你熟悉的语言的 SDK 来完成这些工作。Javascript, Typescript, Python, Golang, Unity 等等。目前，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://thirdweb.com/&quot; rel=&quot; nofollow ugc&quot;&gt;thirdweb&lt;/a&gt; 已经在为超过 1000 名开发者、区块链游戏、市场、DAO、NFT 投放和正在建立 web3 生态系统的创作者提供加速。&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.producthunt.com/posts/thirdweb&quot; rel=&quot; nofollow ugc&quot;&gt;ProductHunt&lt;/a&gt; 有网友评价道：作为一个长期接触 web3 的开发者，我很高兴发现了 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://thirdweb.com/&quot; rel=&quot; nofollow ugc&quot;&gt;thirdweb&lt;/a&gt;：一个直观、简单的平台，让你只需点击几下，就可以轻松地使用分散的所有权创建应用程序、游戏、体验和项目。thirdweb 消除了学习新的编码语言的头痛问题，并为你提供所需的工具，使你的业务更上一层楼！为创作者、开发游戏工作室、消费者品牌和许多许多人提供了一个完美的解决方案。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61b9e73048f785032a2400b7&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - thirdweb&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/SEO&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;SEO&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Looking for the best SEO Audit Tool to analyze and grade your website? SEOptimer is the web&#x27;s best SEO Checker. Improve your website, rank better in Search Engines and win more customers with beautiful SEO Reports. Audit your SEO today!&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.seoptimer.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Analyze Websites With Free SEO Audit &amp;amp; Reporting Tool - SEOptimer&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.seoptimer.com/&quot; rel=&quot; nofollow ugc&quot;&gt;SEOptimer&lt;/a&gt;，免费的 SEO 审计和报告工具分析网站，可以改善您的网站，在搜索引擎中获得更好的排名，并通过漂亮的 SEO 报告赢得更多客户。&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.seoptimer.com/&quot; rel=&quot; nofollow ugc&quot;&gt;SEOptimer&lt;/a&gt; 非常适合数字机构和 SEO 自由职业者。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.seoptimer.com/&quot; rel=&quot; nofollow ugc&quot;&gt;SEOptimer&lt;/a&gt; 有以下三个目标：用漂亮的白标 SEO 审计报告，给他们的客户和潜在客户留下深刻印象；通过提供定制的可嵌入审计表格，在他们的代理网站上产生新的业务线索 ；为代理提供全套 SEO 工具，而成本相对较低；该团队将根据客户反馈不断构建功能并进行产品更新；欲了解更多，你可以参考其公开路线图：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://seoptimer.upvoty.com/b/feature-requests/&quot; rel=&quot; nofollow ugc&quot;&gt;SEOptimer&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61b978d648f785032a2400b5&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Analyze Websites With Free SEO Audit &amp;amp; Reporting Tool - SEOptimer&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%9C%A8%E7%BA%BF&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;在线&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%A1%A8%E6%A0%BC&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;表格&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Easily create even complex LaTeX tables with our online generator – you can paste data from a spreadsheet, merge cells, edit borders and more.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.tablesgenerator.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Create LaTeX tables online – TablesGenerator.com&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.tablesgenerator.com/&quot; rel=&quot; nofollow ugc&quot;&gt;TablesGenerator.com&lt;/a&gt; 是一个在线表格转换工具；支持 LaTeX、Html、Text、Markdown、MediaWiki 等多种格式互相转换。Markdown 等语言越来越流行，但用 Markdown、Html 来书写表格数据，颇为不便，基于 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.tablesgenerator.com/&quot; rel=&quot; nofollow ugc&quot;&gt;TablesGenerator.com&lt;/a&gt; 则可以解决这困难。另外值得一提的是，其体验很好，可以轻松编辑内容，支持在线预览、一键拷贝、导入、导出。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/61b624a648f785032a2400b3&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Create LaTeX tables online – TablesGenerator.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;本期文末寄语&lt;/h2&gt;

&lt;p&gt;我认为，至深的平和，一定经过命运浮沉的洗礼，一定经过生离死别的考验，一定经过爱与恨的煎熬。一切都经过了，一切都走过了，一切都熬过了，生命的底色里，增了韧，添了柔。这时候平和下来的生命，已经沉静到扰不乱，已经稳健到动不摇，已经淡定到风打不动。── 当代作家 · 马德&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;您可能感兴趣的文章&lt;/h3&gt;


                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9ba14f4955a8c4a87ae25d2a94e3a157</guid>
<title>Rpa vs bpa vs Dpa 过程自动化技术综述</title>
<link>https://toutiao.io/k/9vc0otp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content custom&quot;&gt;&lt;h1 id=&quot;rpa-vs-dpa-vs-bpa-过程自动化技术综述&quot;&gt;&lt;a href=&quot;#rpa-vs-dpa-vs-bpa-过程自动化技术综述&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; RPA vs DPA vs BPA 过程自动化技术综述&lt;/h1&gt; &lt;p&gt;在当今世界，顾客就是王者。事实上，调查显示，良好的客户服务使86% 的一次性客户成为了长期的品牌拥护者，而65% 的客户因为糟糕的体验而转向了竞争对手。在所有行业和规模的企业中，没有任何地方可以容纳错过的最后期限、丢失的信息或者漫长的等待时间。&lt;/p&gt; &lt;p&gt;因此，外包数字过程自动化的质量保证已成为现代企业的标准做法。阅读这篇博客可以发现你可以使用的不同类型的自动化，并学习每一种自动化如何满足你独特的业务需求。&lt;/p&gt; &lt;p&gt;过程自动化指的是简化复杂的手工任务，以加快操作速度。它的三个功能包括简化流程、集中信息和减少人工接触点。&lt;/p&gt; &lt;p&gt;在项目管理中，过程自动化可以改变游戏规则。例如，如果你想启动一个新网站，这里有必要的步骤:&lt;/p&gt; &lt;p&gt;Create a pre-launch page. 创建一个启动前页面
Produce high-quality content. 生产高质量的内容
Develop a lead-generation process. 开发一个领先的生成过程
Generate inbound links. 生成导入链接
Set up alerts for brand mentions. 设置提及品牌的提醒
Research potential keywords. 研究潜在的关键词
List your site on Google. 在谷歌上列出你的网站&lt;/p&gt; &lt;p&gt;鉴于分配给各个部门的繁琐任务，正在启动网站的公司可以应用流程自动化实践，以确保预期的结果。从创建网站地图和漏斗，到关键字列表，有许多过程你可以简化。
自动化您的过程还可以帮助程序员、开发人员、信息架构师和可视化设计师无缝地协同工作。这样做可以为你的网站访问者提供统一的体验。&lt;/p&gt; &lt;p&gt;组织何时使用过程自动化？
你是否曾经收到过一封零售品牌的生日邮件，一封亚马逊的促销信息，或者一条关于预约的短信提醒？这些都是自动化的简单应用。然而，当您决定自动化您的工作流程时，您将发现它可以满足您的不同需求。&lt;/p&gt; &lt;p&gt;下面是一些您可以使用过程自动化的变革性方法。&lt;/p&gt; &lt;p&gt;提升客户体验。有了正确的工具，您就可以始终如一地满足服务水平协议(sla)。通过自动化，您还可以开发和交付标准产品和及时提供服务
简化乏味的任务。如果您处理成堆的发票、销售订单和收据，流程自动化可以帮助您节省时间和金钱，同时最大限度地减少同一时间人为错误
分享大数据。现代劳动力通常由来自不同地点的远程团队组成。为了使这种设置能够工作，向全职员工和外包员工提供必要的信息是至关重要的执行任务
现在让我们来看看不同类型的过程自动化技术:&lt;/p&gt; &lt;p&gt;什么是机器人过程自动化？
随着现代商业环境的竞争性质，组织应该注重创新和效率来蓬勃发展。对于这样的需求，机器人过程自动化(RPA)是当今最可靠的技术之一。&lt;/p&gt; &lt;p&gt;RPA 允许公司自动化重复的、耗时的任务。机器人接管的任务越单调，员工就能花更多的时间在高价值的活动上，包括那些需要情商和推理的活动。&lt;/p&gt; &lt;p&gt;以下是使 RPA 从其他自动化类型中脱颖而出的三个要素:&lt;/p&gt; &lt;p&gt;Solid Business Process Management (BPM) and Digital Process Automation (DPA) foundations: 坚实的业务流程管理(BPM)和数字流程自动化(DPA)基础:使用 RPA 解决方案，您可以将 IT 基础设施转换为响应性更好的敏捷工具。&lt;/p&gt; &lt;p&gt;Low code: 低代码:RPA 是集成应用程序以实现整体数字转换的理想工具。使用 RPA 和低代码工具，您可以使用类似人类的互动。&lt;/p&gt; &lt;p&gt;Deployable as Platform as service (PaaS): 可部署为平台即服务(PaaS) :有了这个工具，您可以专注于代码而不是构建、测试、部署和维护基础设施。&lt;/p&gt; &lt;p&gt;什么是数字过程自动化？
数字过程自动化(DPA)是利用软件优化工作流程的过程。最终的目标是实现完全的数字化转换。这个工具的重点是通过最小化业务操作中的摩擦来改善员工和客户的体验。您可以使用 DPA 来维护透明性、执行与客户相关的任务和触发通知。&lt;/p&gt; &lt;p&gt;DPA 有三个类别:&lt;/p&gt; &lt;p&gt;Programmatic: 计划性:您可以使用这种 DPA 类型来减少后台办公过程中的繁文缛节，包括客户入职、信用审批和满意度评估&lt;/p&gt; &lt;p&gt;Transactional: 交易型:另一方面，事务性 DPA 简化了需要人工干预的任务，包括抵押贷款应用程序、产品培训会话和顾客投诉
Exploratory: 探索:这些任务包括遵守和执行欺诈解决&lt;/p&gt; &lt;p&gt;什么是业务流程自动化？
业务流程自动化(Business Process Automation，BPA)意味着使用技术来改进您的操作。虽然它可能看起来类似于数字过程自动化技术，双酚 a 侧重于提高效率和最小化运营成本。实现预期结果的最佳方法是培训人工操作员，以减少整个员工的接触点。&lt;/p&gt; &lt;p&gt;以下是 BPA 的一些核心元素:&lt;/p&gt; &lt;p&gt;第一步是确定如何使用过程控制自动化，包括您的目标和参数
接下来，确定如何收集和组织符合数据模型
对于 BPA 来说，最后一个必要的组件是非结构化数据/模型或者那些没有遵循预定义模型的组件或态度&lt;/p&gt; &lt;p&gt;RPA vs DPA vs BPA&lt;/p&gt; &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;name&lt;/th&gt; &lt;th&gt;RPA&lt;/th&gt; &lt;th&gt;DPA&lt;/th&gt; &lt;th&gt;BPA&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;tr&gt;&lt;td&gt;自动化&lt;/td&gt; &lt;td&gt;有助于使任务自动化&lt;/td&gt; &lt;td&gt;帮助自动化多个步骤的过程&lt;/td&gt; &lt;td&gt;帮助将需要人工干预的流程自动化&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;过程&lt;/td&gt; &lt;td&gt;它可以在现有的流程中工作&lt;/td&gt; &lt;td&gt;它可以简化现有的流程&lt;/td&gt; &lt;td&gt;它可以通过自动化改善用户体验&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;融合&lt;/td&gt; &lt;td&gt;$在桌面上与现有的 ui 一起工作&lt;/td&gt; &lt;td&gt;需要数据库访问和 API 集成，以便跨不同系统收集信息&lt;/td&gt; &lt;td&gt;它有助于优化数字处理过程&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;效率&lt;/td&gt; &lt;td&gt;使用低代码或无代码特性使用户能够成为公民开发人员&lt;/td&gt; &lt;td&gt;由于它是复杂的，它需要 IT 和专业技能来进行开发&lt;/td&gt; &lt;td&gt;它需要专注于优化端到端用户体验的业务参与机制(比如卓越中心交互)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;结果&lt;/td&gt; &lt;td&gt;它可以帮助节省成本，而不需要重新设计任何流程&lt;/td&gt; &lt;td&gt;它需要对现有流程进行再工程和分析，以实现最大价值&lt;/td&gt; &lt;td&gt;它有助于与软件系统创建以客户为中心的响应式交互&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; &lt;p&gt;如何实现过程自动化
对于组织来说，没有放之四海而皆准的解决方案，但是这些步骤通常是相同的。请继续阅读，了解如何在所有部门无缝地实现流程自动化。&lt;/p&gt; &lt;p&gt;识别需要自动化的任务和过程
成功实现自动化的第一步是确定哪些任务可以用软件简化。以下是一些你可以考虑自动化的职责:&lt;/p&gt; &lt;p&gt;Cumbersome, repetitive tasks 繁琐重复的任务
Time-sensitive duties 时间紧迫的工作
Multi-department projects 跨部门项目
Assignments involving big data 涉及大数据的任务
High-return functions 高回报函数&lt;/p&gt; &lt;p&gt;设定组织目标
设定目标可以让你的团队专注于他们需要达到的预期结果。当你与组织分享你的目标时，你为团队提供了执行任务所必需的愿景和动力。在设定目标之后，确定自动化如何帮助完成目标。&lt;/p&gt; &lt;p&gt;选择正确的工具包
请记住，并非所有的过程自动化工具都是相同的。为了达到你想要的结果，有必要根据你不同的需求选择最好的解决方案。找到一个工具包，它提供了一个直观的界面，您可以使用它来简化流程并应用您需要的更改。&lt;/p&gt; &lt;p&gt;变革管理
在使用自动化软件之前，有必要帮助员工适应新的流程。让团队从计划到实施都参与进来，可以帮助你确保工作的有效性。&lt;/p&gt; &lt;p&gt;测量和监控
和任何项目一样，根据你的目标来衡量和监控结果是必不可少的。你不必把自动化工具固定在石头上。无论何时，只要你发现性能下降，你就可以相应地调整策略。&lt;/p&gt; &lt;p&gt;总结
过程自动化ーー无论你选择 RPA、 DPA 还是 BPA ーー都可以帮助你把你的业务提升到一个新的水平。这是提升客户体验、流程简化和协作效果的最经济有效的方法之一。如果你在基于项目的过程中需要帮助，考虑外包你的需求。&lt;/p&gt; &lt;h3 id=&quot;author&quot;&gt;&lt;a href=&quot;#author&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; author&lt;/h3&gt; &lt;p&gt;石头 磊哥 seven 随便叫&lt;/p&gt; &lt;h3 id=&quot;company&quot;&gt;&lt;a href=&quot;#company&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; company&lt;/h3&gt; &lt;p&gt;HSBC
大家好，我已经加入了HSBC&lt;/p&gt; &lt;h3 id=&quot;roles&quot;&gt;&lt;a href=&quot;#roles&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; roles&lt;/h3&gt; &lt;p&gt;QA（营生） dev（front-end dev 兴趣爱好）&lt;/p&gt; &lt;h3 id=&quot;联系方式&quot;&gt;&lt;a href=&quot;#联系方式&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 联系方式&lt;/h3&gt; &lt;p&gt;如果想转载或者高薪挖我 请直接联系我 哈哈&lt;/p&gt; &lt;h4 id=&quot;wechat&quot;&gt;&lt;a href=&quot;#wechat&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; wechat:&lt;/h4&gt; &lt;p&gt;qileiwangnan&lt;/p&gt; &lt;h4 id=&quot;email&quot;&gt;&lt;a href=&quot;#email&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; email:&lt;/h4&gt; &lt;p&gt;qileilove@gmail.com&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>