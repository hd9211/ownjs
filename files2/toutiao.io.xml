<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7451a5008d4f11572968adb94ba28482</guid>
<title>[推荐] 结合电商支付业务一文搞懂 DDD</title>
<link>https://toutiao.io/k/5stu129</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;作者范钢，曾任航天信息首席架构师，《大话重构》一书的作者。本文结合电商支付场景详细描述了领域驱动模型的实际应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2004 年，软件大师 Eric Evans 的不朽著作《领域驱动设计：软件核心复杂性应对之道》面世，从书名可以看出，这是一本应对软件系统越来越复杂的方法论的图书。然而，在当时，中国的软件业才刚刚起步，软件系统还没有那么复杂，即使维护了几年，软件退化了，不好维护了，推倒重新开发就好了。因此，在过去的那么多年里，真正运用领域驱动设计开发（DDD）的团队并不多。一套优秀的方法论，因为现实阶段的原因而一直不温不火。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过，这些年随着中国软件业的快速发展，软件规模越来越大，生命周期也越来越长，推倒重新开发的成本和风险越来越大。这时，软件团队急切需要在较低成本的状态下持续维护一个系统很多年。然而，事与愿违。随着时间的推移，程序越来越乱，维护成本越来越高，软件退化成了无数软件团队的噩梦。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时，微服务架构成了规模化软件的解决之道。不过，微服务对设计提出了很高的要求，强调“小而专、高内聚”，否则就不能发挥出微服务的优势，甚至可能令问题更糟糕。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，微服务的设计，微服务的拆分都需要领域驱动设计的指导。那么，领域驱动为什么能解决软件规模化的问题呢？我们先从问题的根源谈起，即软件退化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;软件退化的根源&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;最近 10 年的互联网发展，从电子商务到移动互联，再到“互联网+”与传统行业的互联网转型，是一个非常痛苦的转型过程。而近几年的人工智能与 5G 技术的发展，又会带动整个产业向着大数据与物联网发展，另一轮的技术转型已经拉开帷幕。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么，在这个过程中，一方面会给我们带来诸多的挑战，另一方面又会给我们带来无尽的机会，它会带来更多的新兴市场、新兴产业与全新业务，给我们带来全新的发展机遇。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而，在面对全新业务、全新增长点的时候，我们能不能把握住这样的机遇呢？我们期望能把握住，但每次回到现实，回到正在维护的系统时，却令人沮丧。我们的软件总是经历着这样的轮回，软件设计质量最高的时候是第一次设计的那个版本，当第一个版本设计上线以后就开始各种需求变更，这常常又会打乱原有的设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，需求变更一次，版本迭代一次，软件就修改一次，软件修改一次，质量就下降一次。不论第一次的设计质量有多高，软件经历不了几次变更，就进入一种低质量、难以维护的状态。进而，团队就不得不在这样的状态下，以高成本的方式不断地维护下去，维护很多年。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候，维护好原有的业务都非常不易，又如何再去期望未来更多的全新业务呢？比如，这是一段电商网站支付功能的设计，最初的版本设计质量还是不错的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOD6iaQGOdaJ8xxnNUIM21BttRyONBZc5VvNBpLbCjo3Rzf9g0RVKX8Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当第一个版本上线以后，很快就迎来了第一次变更，变更的需求是增加商品折扣功能，并且这个折扣功能还要分为限时折扣、限量折扣、某类商品的折扣、某个商品的折扣。当我们拿到这个需求时怎么做呢？很简单，增加一个 if 语句，if 限时折扣就怎么怎么样，if 限量折扣就怎么怎么样……代码开始膨胀了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接着，第二次变更需要增加 VIP 会员，除了增加各种金卡、银卡的折扣，还要为会员发放各种福利，让会员享受各种特权。为了实现这些需求，我们又要在 payoff() 方法中加入更多的代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三次变更增加的是支付方式，除了支付宝支付，还要增加微信支付、各种银行卡支付、各种支付平台支付，此时又要塞入一大堆代码。经过这三次变更，你可以想象现在的 payoff() 方法是什么样子了吧，变更是不是就可以结束了呢？其实不能，接着还要增加更多的秒杀、预订、闪购、众筹，以及各种返券。程序变得越来越乱而难以阅读和维护，每次变更也变得越来越困难。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.80625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOricyejrzyXCrW1WyJANz92twbibljeUKmONeqOzHX4xKiculRxeaIbrfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题来了：为什么软件会退化，会随着变更而设计质量下降呢？在这个问题上，我们必须寻找到问题的根源，才能对症下药、解决问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要探寻软件退化的根源，先要从探寻软件的本质及其规律开始，软件的本质就是对真实世界的模拟，每个软件都能在真实世界中找到它的影子。因此，软件中业务逻辑正确与否的唯一标准就是是否与真实世界一致。如果一致，则软件是 OK 的；不一致，则用户会提 Bug、提新需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这里发现了一个非常重要的线索，那就是，软件要做成什么样，既不由我们来决定，也不由用户来决定，而是由客观世界决定。用户为什么总在改需求，是因为他们也不确定客观世界的规则，只有遇到问题了他们才能想得起来。因此，对于我们来说，与其唯唯诺诺地按照用户的要求去做软件，不如在充分理解业务的基础上去分析软件，这样会更有利于我们减少软件维护的成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么，真实世界是怎样的，我们就怎样开发软件，不就简单了吗？其实并非如此，因为真实世界是非常复杂的，要深刻理解真实世界中的这些业务逻辑是需要一个过程的。因此，我们最初只能认识真实世界中那些简单、清晰、易于理解的业务逻辑，把它们做到我们的软件里，即每个软件的第一个版本的需求总是那么清晰明了、易于设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而，当我们把第一个版本的软件交付用户使用的时候，用户却会发现，还有很多不简单、不明了、不易于理解的业务逻辑没做到软件里。这在使用软件的过程中很不方便，和真实业务不一致，因此用户就会提 Bug、提新需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在我们不断地修复 Bug，实现新需求的过程中，软件的业务逻辑也会越来越接近真实世界，使得我们的软件越来越专业，让用户感觉越来越好用。但是，在软件越来越接近真实世界的过程中，业务逻辑就会变得越来越复杂，软件规模也越来越庞大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;你一定有这样一个认识：简单软件有简单软件的设计，复杂软件有复杂软件的设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如，现在的需求就是将用户订单按照“单价 × 数量”公式来计算应付金额，那么在一个 PaymentBus 类中增加一个 payoff() 方法即可，这样的设计没有问题。不过，如果现在的需要在付款的过程中计算各种折扣、各种优惠、各种返券，那么我们必然会做成一个复杂的程序结构。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.52734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHO4YUzJ1o33XzAG2IRyYp98ulLlPyEkRS5Rfo7AiciclmZWBZjiaV5ia2Ziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是，真实情况却不是这样的。真实情况是，起初我们拿到的需求是那个简单需求，然后在简单需求的基础上进行了设计开发。但随着软件的不断变更，软件业务逻辑变得越来越复杂，软件规模不断扩大，逐渐由一个简单软件转变成一个复杂软件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时，如果要保持软件设计质量不退化，就应当逐步调整软件的程序结构，逐渐由简单的程序结构转变为复杂的程序结构。如果我们总是这样做，就能始终保持软件的设计质量，不过非常遗憾的是，我们以往在维护软件的过程中却不是这样做的，而是不断地在原有简单软件的程序结构下，往 payoff() 方法中塞代码，这样做必然会造成软件的退化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是说，软件退化的根源不是版本迭代和需求变更，版本迭代和需求变更只是一个诱因。如果每次软件变更时，适时地进行解耦，进行功能扩展，再实现新的功能，就能保持高质量的软件设计。但如果在每次软件变更时没有调整程序结构，而是在原有的程序结构上不断地塞代码，软件就会退化。这就是软件发展的规律，软件退化的根源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;杜绝软件退化：两顶帽子&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;前面谈到，要保持软件设计质量不退化，必须在每次需求变更的时候，对原有的程序结构适当地进行调整。那么应当怎样进行调整呢？还是回到前面电商网站付款功能的那个案例，看看每次需求变更应当怎样设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在交付第一个版本的基础上，很快第一次需求变更就到来了。第一次需求变更的内容如下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;增加商品折扣功能，该功能分为以下几种类型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以往我们拿到这个需求，就很不冷静地开始改代码，修改成了如下一段代码：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOYgO4eGGXkZGwCeteGz5A6m8jQcAH4BQqcnKMZRPH3kLQspzHzJZ0aQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里增加了的 if else 语句，并不是一种好的变更方式。如果每次都这样变更，那么软件必然就会退化，进入难以维护的状态。这种变更为什么不好呢？因为它违反了“开放-封闭原则”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;开闭原则（OCP） &lt;/strong&gt;分为开放原则与封闭原则两部分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前面的设计，在实现新功能的同时，新代码与老代码在同一个类、同一个方法中了，违反了“开闭原则”。怎样才能既满足“开闭原则”，又能够实现新功能呢？在原有的代码上你发现什么都做不了！难道“开闭原则”错了吗？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题的关键就在于，当我们在实现新需求时，应当采用“两顶帽子”的方式进行设计，这种方式就要求在每次变更时，将变更分为两个步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;两顶帽子：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按以上案例为例，为了实现新的功能，我们在原有代码的基础上，在不添加新功能的前提下调整原有程序结构，我们抽取出了 Strategy 这样一个接口和“不折扣”这个实现类。这时，原有程序变了吗？没有。但是程序结构却变了，增加了这样一个接口，称之为“可扩展点”。在这个可扩展点的基础上再实现各种折扣，既能满足“开放-封闭原则”来保证程序质量，又能够满足新的需求。当日后发生新的变更时，什么类型的折扣有变化就修改哪个实现类，添加新的折扣类型就增加新的实现类，维护成本得到降低。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.73203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOcqHQibsGpibbqOhwqAar1DZMicIffxAzSbOSiaJxKyXib9KWXEykPMZDSlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“两顶帽子”的设计方式意义重大。过去，我们每次在设计软件时总是担心日后的变更，就很不冷静地设计了很多所谓的“灵活设计”。然而，每一种“灵活设计”只能应对一种需求变更，而我们又不是先知，不知道日后会发生什么样的变更。最后的结果就是，我们期望的变更并没有发生，所做的设计都变成了摆设，它既不起什么作用，还增加了程序复杂度；我们没有期望的变更发生了，原有的程序依然不能解决新的需求，程序又被打回了原形。因此，这样的设计不能真正解决未来变更的问题，被称为“过度设计”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了“两顶帽子”，我们不再需要焦虑，不再需要过度设计，正确的思路应当是“活在今天的格子里做今天的事儿”，也就是为当前的需求进行设计，使其刚刚满足当前的需求。所谓的“高质量的软件设计”就是要掌握一个平衡，一方面要满足当前的需求，另一方面要让设计刚刚满足需求，从而使设计最简化、代码最少。这样做，不仅软件设计质量提高了，设计难点也得到了大幅度降低。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简而言之，保持软件设计不退化的关键在于每次需求变更的设计，只有保证每次需求变更时做出正确的设计，才能保证软件以一种良性循环的方式不断维护下去。这种正确的设计方式就是“两顶帽子”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是，在实践“两顶帽子”的过程中，比较困难的是第一步。在不添加新功能的前提下，如何重构代码，如何调整原有程序结构，以适应新功能，这是有难度的。很多时候，第一次变更、第二次变更、第三次变更，这些事情还能想清楚；但经历了第十次变更、第二十次变更、第三十次变更，这些事情就想不清楚了，设计开始迷失方向。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么，有没有一种方法，让我们在第十次变更、第二十次变更、第三十次变更时，依然能够找到正确的设计呢？有，那就是“领域驱动设计”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;保持软件质量：领域驱动&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;前面谈到，软件的本质就是对真实世界的模拟。因此，我们会有一种想法，能不能将软件设计与真实世界对应起来，真实世界是什么样子，那么软件世界就怎么设计。如果是这样的话，那么在每次需求变更时，将变更还原到真实世界中，看看真实世界是什么样子的，根据真实世界进行变更。这样，日后不论怎么变更，经过多少轮变更，都按照这样的方法进行设计，就不会迷失方向，设计质量就可以得到保证，这就是“领域驱动设计”的思想。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么，如何将真实世界与软件世界对应起来呢？这样的对应就包括以下三个方面的内容：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOdkTKM96RbduqVFGGO0KGySqHmxdnvfYaT1MTgUL4STZz0UuM3en8ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;真实世界与软件世界的对应图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在领域驱动设计中，就将以上三个对应，先做成一个领域模型，然后通过这个领域模型指导程序设计；在每次需求变更时，先将需求还原到领域模型中分析，根据领域模型背后的真实世界进行变更，然后根据领域模型的变更指导软件的变更，设计质量就可以得到提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;结合电商支付实际演练DDD&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在，我们以电商网站的支付功能为例，来演练一下基于 DDD 的软件设计及其变更的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;运用 DDD 进行软件设计&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;开发人员在最开始收到的关于用户付款功能的需求描述是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以往当拿到这个需求时，开发人员往往草草设计以后就开始编码，设计质量也就不高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而采用领域驱动的方式，在拿到新需求以后，应当先进行需求分析，设计领域模型。按照以上业务场景，可以分析出：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，我们对订单可以进行“下单”“付款”“查看订单状态”等操作。因此形成了以下领域模型图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7159904534606205&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOU3wf2VZXhwciaP0FnVDrLB7pUDLMTpU5YCoHk5GgTUiamdAXSk6lMaIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了这样的领域模型，就可以通过该模型进行以下程序设计：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHO3S22N6iblxV1zhe1fReiaSDibQo4GJCSPYHFPa89aojFgbnlSQAK9AibjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过领域模型的指导，将“订单”分为订单 Service 与值对象，将“用户”分为用户 Service 与值对象，将“商品”分为商品 Service 与值对象……然后，在此基础上实现各自的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;商品折扣的需求变更&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当电商网站的付款功能按照领域模型完成了第一个版本的设计后，很快就迎来了第一次需求变更，即增加折扣功能，并且该折扣功能分为限时折扣、限量折扣、某类商品的折扣、某个商品的折扣与不折扣。当我们拿到这个需求时应当怎样设计呢？很显然，在 payoff() 方法中去插入 if else 语句是不 OK 的。这时，按照领域驱动设计的思想，应当将需求变更还原到领域模型中进行分析，进而根据领域模型背后的真实世界进行变更。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.50625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOibzklibyf2eHmPXAHqY0bMia25VL9eM0tt6DmTj1UYpeMfvze0atrYGww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是上一个版本的领域模型，现在我们要在这个模型的基础上增加折扣功能，并且还要分为限时折扣、限量折扣、某类商品的折扣等不同类型。这时，我们应当怎么分析设计呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;首先要分析付款与折扣的关系。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;付款与折扣是什么关系呢？你可能会认为折扣是在付款的过程中进行的折扣，因此就应当将折扣写到付款中。这样思考对吗？我们应当基于什么样的思想与原则来设计呢？这时，另外一个重量级的设计原则应该出场了，那就是“单一职责原则”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单一职责原则：&lt;/strong&gt;软件系统中的每个元素只完成自己职责范围内的事，而将其他的事交给别人去做，我只是去调用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;单一职责原则是软件设计中一个非常重要的原则，但如何正确地理解它成为一个非常关键的问题。在这句话中，准确理解的关键就在于“职责”二字，即自己职责的范围到底在哪里。以往，我们错误地理解这个“职责”就是做某一个事，与这个事情相关的所有事情都是它的职责，正因为这个错误的理解，带来了许多错误的设计，而将折扣写到付款功能中。那么，怎样才是对“职责”正确的理解呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“一个职责就是软件变化的一个原因”是著名的软件大师 Bob 大叔在他的《敏捷软件开发：原则、模式与实践》中的表述。但这个表述过于精简，很难深刻地理解其中的内涵。这里我好好解读一下这句话。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先思考一下什么是高质量的代码？你可能立即会想到“低耦合、高内聚”，以及各种设计原则，但这些评价标准都太“虚”。最直接、最落地的评价标准就是，当用户提出一个需求变更时，为了实现这个变更而修改软件的成本越低，那么软件的设计质量就越高。当来了一个需求变更时，怎样才能让修改软件的成本降低呢？如果为了实现这个需求，需要修改 3 个模块的代码，完后这 3 个模块都需要测试，其维护成本必然是“高”。那么怎样才能降到最低呢？如果只需要修改 1 个模块就可以实现这个需求，维护成本就要低很多了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么，怎样才能在每次变更的时候都只修改一个模块就能实现新需求呢？那就需要我们在平时就不断地整理代码，将那些因同一个原因而变更的代码都放在一起，而将因不同原因而变更的代码分开放，放在不同的模块、不同的类中。这样，当因为这个原因而需要修改代码时，需要修改的代码都在这个模块、这个类中，修改范围就缩小了，维护成本降低了，修改代码带来的风险自然也降低了，设计质量也就提高了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之，单一职责原则要求我们在维护软件的过程中需要不断地进行整理，将软件变化同一个原因的代码放在一起，将软件变化不同原因的代码分开放。按照这样的设计原则，回到前面那个案例中，那么应当怎样去分析“付款”与“折扣”之间的关系呢？只需要回答两个问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当这两个问题的答案是否定时，就说明“付款”与“折扣”是软件变化的两个不同的原因，那么把它们放在一起，放在同一个类、同一个方法中，合适吗？不合适，就应当将“折扣”从“付款”中提取出来，单独放在一个类中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同样的道理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后发现，不同类型的折扣也是软件变化不同的原因。将它们放在同一个类、同一个方法中，合适吗？通过以上分析，我们做出了如下设计：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.60703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOsw9lzdx55IF8thQL0EamzyGaWaGqQhdmuxOciaIKFibWnLahysHmy9Kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在该设计中，将折扣功能从付款功能中独立出去，做出了一个接口，然后以此为基础设计了各种类型的折扣实现类。这样的设计，当付款功能发生变更时不会影响折扣，而折扣发生变更的时候不会影响付款。同样，当“限时折扣”发生变更时只与“限时折扣”有关，“限量折扣”发生变更时也只与“限量折扣”有关，与其他折扣类型无关。变更的范围缩小了，维护成本就降低了，设计质量提高了。这样的设计就是“单一职责原则”的真谛。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接着，在这个版本的领域模型的基础上进行程序设计，在设计时还可以加入一些设计模式的内容，因此我们进行了如下的设计：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.68203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOicaqYQlU4EiboWZWy8HuUd3zyooRyOp5Gpkg3hgqY6rH7BrGCe36U2vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;显然，在该设计中加入了“策略模式”的内容，将折扣功能做成了一个折扣策略接口与各种折扣策略的实现类。当哪个折扣类型发生变更时就修改哪个折扣策略实现类；当要增加新的类型的折扣时就再写一个折扣策略实现类，设计质量得到了提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;VIP 会员的需求变更&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在第一次变更的基础上，很快迎来了第二次变更，这次是要增加 VIP 会员，业务需求如下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;增加 VIP 会员功能：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们拿到这样的需求又应当怎样设计呢？同样，先回到领域模型，分析“用户”与“VIP 会员”的关系，“付款”与“VIP 会员”的关系。在分析的时候，还是回答那两个问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过分析发现，“用户”与“VIP 会员”是两个完全不同的事物。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过以上的分析，我们做出了以下版本的领域模型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHObjrNKiaukTCuM0zVoFlNLp7oQz5rjUtCSCuFlaL7g2BKp9hb9cNCWwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了这些领域模型的变更，然后就可以以此作为基础，指导后面程序代码的变更了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;支付方式的需求变更&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同样，第三次变更是增加更多的支付方式，我们在领域模型中分析“付款”与“支付方式”之间的关系，发现它们也是软件变化不同的原因。因此，我们果断做出了这样的设计：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.590625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOiaAFgQQQoQnwXw02nesJt1D0EE0ZPibXaBibzUz5iaZTLq7XA88ZJuT2aQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而在设计实现时，因为要与各个第三方的支付系统对接，也就是要与外部系统对接。为了使第三方的外部系统的变更对我们的影响最小化，在它们中间果断加入了“适配器模式”，设计如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/I2EApibvt9icy4NiadhglhianfJGpg4NpIHOTHGPFQQp4o2DUdHZhkYBbSIiayjQUu1m0p9icWDpJibjC35VGvNkd28nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过加入适配器模式，订单 Service 在进行支付时调用的不再是外部的支付接口，而是“支付方式”接口，与外部系统解耦。只要保证“支付方式”接口是稳定的，那么订单 Service 就是稳定的。比如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;日后不论哪种变更，要修改的代码范围缩小了，维护成本自然降低了，代码质量就提高了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;软件发展的规律就是逐步由简单软件向复杂软件转变。简单软件有简单软件的设计，复杂软件有复杂软件的设计。因此，当软件由简单软件向复杂软件转变时，就需要通过两顶帽子适时地对程序结构进行调整，再实现新需求，只有这样才能保证软件不退化。然而，在变更的时候，如何调整代码以适应新的需求呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DDD 给了我们思路：在每次变更的时候，先回到领域模型，基于业务进行领域模型的变更。然后，再基于领域模型的变更，指导程序的变更。这样，不论经历多少次需求变更，始终能够保持设计质量不退化。这样的设计，才能保障系统始终在低成本的状态下，可持续地不断维护下去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文我们演练了如何运用 DDD 进行软件的设计与变更，以及在设计与变更的过程中如何分析思考、如何评估代码、如何实现高质量。后续文章，我们将结合具体案例分析如何将领域模型的设计进一步落实到软件系统的微服务设计与数据库设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;号主简介：冯涛，&lt;/span&gt;&lt;span&gt;曾任职于阿里巴巴，每日优鲜等互联网公司，任技术总监，15年电商互联网经历&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后，将自己15年的微服务，高并发，JVM调优，线上故障排查等经历整理成电子书送给大家，共130页。绝对干货！&lt;span&gt;没领过的朋友，抓紧啦！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取方式：扫描或识别下方二维码关注公众号二马读书，&lt;span&gt;回复&lt;/span&gt;&lt;span&gt; &lt;strong&gt;“&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;电子书&lt;/strong&gt;&lt;/span&gt;”&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/I2EApibvt9icyUP1DKTuiaQ6pLS5A16fY19TjGbnIlicIYTZcRTzpxIfWErvRjaGbicXAOCN9eIt6Hv4vnN8FtiazmBQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取方式：扫描或识别上方二维码关注公众号二马读书，回复&lt;span&gt; &lt;strong&gt;“&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;电子书&lt;/strong&gt;&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来来来加俺微信，一起交流，共同成长: ftcool2008&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，&lt;/span&gt;如果感觉本文对您有帮助，有劳转发分享或点一下“在看”！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40c10cb783e32e542da21d41ba222c90</guid>
<title>[推荐] 面试过 200 人的经验，都在这里了 | 码农周刊第 325 期</title>
<link>https://toutiao.io/k/xvysg5s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;面试过 200 人的经验，都在这里了 | 码农周刊第 325 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第325期（2020-11-25）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;相比 cocos2d 引擎有着更低的入门门槛和维护成本，为复杂动画的实现提供了一种全新的方式，新的复杂动画开发将会变得更加简单高效。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;让您享受极简编程体验，快速访问支付宝开放平台开放的各项核心能力。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;一个不错的 Python 学习教程，30 天循序渐进地教你学会 Python。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;白皮书从技术、市场、趋势、挑战等多维度，对我国开源产业生态进行了全面、深度的剖析，指出了我国开源产业发展的几大重要趋势。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;经验总结&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;供参考&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;收藏吧&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;使用方便&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;良心教程&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;你怎么看？&lt;/p&gt;
        
        &lt;p&gt;深入研究&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;技术总结，经验分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451179 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;分享计算机视觉与机器学习技术的最前沿&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 359575 即可&lt;/p&gt;
        
        &lt;p&gt;聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 351247 即可&lt;/p&gt;
        
        &lt;p&gt;学习就是不停的积累&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 24912 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本手册以开发工程师为中心视角，划分为单元测试、安全规约、MySQL 数据库、工程结构等七个维度，相应的扩展解释和说明、正例和反例，全面、立体、形象地帮助开发工程师成长。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;一直被追赶，从未被超越&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>175bad14da1c94c68cc1af40f28bc3e5</guid>
<title>[推荐] 如何理解 Kafka 的消息可靠性策略？</title>
<link>https://toutiao.io/k/55mybdz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4psjPOibic6BZSicnBFh6uWzCFp3uqN5R114Fq85DmuCzdL3eESlQ37bFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span&gt;Kafka作为一款性能优秀的消息队列，主要用于异步、削峰、解耦处理，在分布式事务中有着广泛的应用，但仍有很多开发者在运用过程中存在疑惑。文本将为大家由浅入深剖析Kafka基础原理以及它的消息可靠性策略，帮助大家理解这一技术知识。文章作者：张璇，腾讯应用开发工程师。&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、背景&lt;/strong&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;部门的开发同学最近在开发一个活动的过程中，需要关注大量的应用后台逻辑，捕捉各种事件的触发。在设计时打算采用Kafka消息队列进行业务逻辑的解耦，这样活动开发和后台开发同学的工作就分离开了。但是使用的同学不是很熟悉其原理，担心以下几个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些问题都很正常，在开始接触和使用时总会有这样或那样的问题。&lt;/span&gt;&lt;span&gt;一般情况下，不做了解，使用各种默认的推荐值，也是可以work的。&lt;/span&gt;&lt;span&gt;但是我们要优雅的提升自己的姿(知)势(识)。&lt;/span&gt;&lt;span&gt;学习其背后的原理，至少在遇到一般的问题时，能够分析和处理问题，做到心中有数。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、什么时候使用消息队列&lt;/strong&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单来说，有3个关键词， &lt;strong&gt;异步、削峰、解耦&lt;/strong&gt;。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;可以理解为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我做完了，后面的我不管了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;工作太多了，先放一放我慢慢处理；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;怎么产生的我不管/怎么处理我不管。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以下图为例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4305750350631136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8w6ArTBfznWhHDtK3XbFMxqicsPX2rvR1bWNI4JPvPf6BCabKNj2AO3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用户提交评论中， 写入数据库后，存在需要捕捉评论事件的多个逻辑步骤。&lt;/span&gt;&lt;span&gt;如果在接口处理过程中，顺序的处理不同的步骤，非常繁琐。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;我们可以批量的通知各个步骤(异步)，无需返回直接处理当次的支付其他逻辑(解耦)。&lt;/span&gt;&lt;span&gt;看起来就清爽多了。另外，消息队列也可以作为缓存暂存发出的消息，不再需要考虑调用各个步骤时时延逻辑的异常场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;附注：本文以讲解Kafka中的可靠性设计为例，其它消息队列的选型暂不涉及。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、Kafka基本概念&lt;/strong&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;     &lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;在回答文章前面的问题之前，需要简单介绍一下各种概念。&lt;/span&gt;&lt;span&gt; Kafka从拓扑上分有如下角色：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: 消费者，一般以API形式存在于各个业务svr中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: 生产者，一般以API形式存在于各个业务svr中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kafka broker&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: Kafka集群中的服务器，topic里的消息数据存在上面。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2906574394463668&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8fVNoJ0QsXicicWPgV6EOj7cpvvQR2zPqibxh6ZG1kK0EgzCfUpISyczRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Producer采用发送push的方式将消息发到broker上，broker存储后。由consumer采用pull模式订阅并消费消息。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6344827586206897&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8mX3bNIRmcuFkiagj7hoiafNbR7oUQ6CzfRB4DZ7czvTicWG9zicgy4IFvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图所示，Kafka从存储结构上，有如下角色：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Topic：Kafka处理的消息的逻辑大类集合，可以理解为表。写入不同的topic即写入不同的表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Partition: Topic下的物理分组，1个topic可以分为多个partition, 每个partition是一个有序的队列(大文件)。Partition中每一条消息都有一个有序的offset。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Msg: 消息，通信的基本单位。每个msg在topic下的不同partiton仅有一份，在partition中有一个唯一的offset用于定位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Replica: 副本，partition的数据冗余备份，用于实现分布式的数据可靠性，但引入了不同副本间的数据一致性问题，带来了一定的复杂度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Leader/follower: replica的角色，leader replica 用来提供该partition的读写服务。Follower 不停的从leader侧同步写入的消息。它们之间的消息状态采用一致性策略来解决。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、Kakfa 的存储格式&lt;/strong&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了方便后文更好的理解broker上的消息状态一致性策略，需要再简单介绍一下消息的存储格式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当Producer 发送一条消息到broker中, 会根据分配 partition 规则选择被存储到哪一个 partition, 如果 partition 规则设置的合理，消息会均匀的分布到不同的 partition 里，这样就实现了水平扩展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Pruducer可以认为partition是一个大的串行文件，msg存储时被分配一个唯一的offset。Offset是一个逻辑意义上的偏移，用于区分每一条消息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6091205211726385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8e2fiaW0GEa7Ls72t2zbVicZngsIQIgRvREoXODianlJGqHrchFpCOdLrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而partition本身作为文件，可以有多个多个副本replica(leader/follower)。多个replica分布在在不同的broker上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果要回答如何在broker之间保证存储的消息和状态不会丢失，就要回答broker之间的各个replica的消息状态一致性如何解决，包括producer已经提交了哪些消息，哪些消息已经落地，哪些消息在节点故障后不会丢失。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;五、异步发送时的消息可靠性保证&lt;/strong&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;       &lt;br/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;回到文章开头提到的几个问题，在使用Kafka消息队列做异步发送时，如何保证消息的可靠性？&lt;/span&gt;&lt;span&gt;这&lt;/span&gt;&lt;span&gt;里可以分为3个部分讲解。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 生产者的可靠性保证&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回答生产者的可靠性保证，即回答：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发消息之后有没有ack？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发消息收到ack后，是不是消息就不会丢失了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而Kafka通过配置来指定producer生产者在发送消息时的ack策略：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;如果想实现Kafka配置为 CP(Consistency &amp;amp; Partition tolerance) 系统, 配置需要如下:&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;request.required.acks=-1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min.insync.replicas = &lt;span class=&quot;code-snippet__variable&quot;&gt;${N/2 + 1}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;unclean.leader.election.enable = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41836734693877553&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8RqosqLThCB5rlYXiaEbYuTaKxYU17rmicwI34dDDzB9JUVxL15tIQo9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;588&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图所示，在acks=-1 的情况下，新消息只有被ISR中的所有 follower(f1和f2, f3) 都从leader复制过去才会回ack, ack后，无论那种机器故障情况(全部或部分), 写入的msg4，都不会丢失， 消息状态满足一致性C 要求。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正常情况下，所有follower复制完成后，leader回producer ack。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;异常情况下，如果当数据发送到 leader后部分副本(f1和f2同步)， leader挂了？此时任何 follower 都有可能变成新的 leader， producer 端会得到返回异常，producer 端会重新发送数据，但这样数据可能会重复(但不会丢失)， 暂不考虑数据重复的情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;min.insync.replicas 参数用于保证当前集群中处于正常同步状态的副本follower数量，当实际值小于配置值时，集群停止服务。如果配置为 N/2+1, 即多一半的数量，则在满足此条件下，通过算法保证强一致性。当不满足配置数时，牺牲可用性即停服。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;异常情况下，leader挂掉，此时需要重新从follower选举leader。可以为f2或者f3。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.44502617801047123&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8wehtUZTejQuJvZMArhWWbLbqjebpbnxxzv69I1yn2XPnnzKYYGWo9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;573&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果选举f3为新leader, 则可能会发生消息截断，因为f3还未同步msg4的数据。Kafka通过unclean.leader.election.enable来控制在这种情况下，是否可以选举f3为leader。旧版本中默认为true,在某个版本下已默认为false，避免这种情况下消息截断的出现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过ack和min.insync.replicas和unclean.leader.election.enable的配合，保证在Kafka配置为CP系统时，要么不工作，要么得到ack后，消息不会丢失且消息状态一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;min.insync.replicas 参数默认值为1，即满足高可用性，只要有1台能工作即可。但此时可工作的broker状态不一定正确。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;如果想实现Kafka配置为AP(Availability &amp;amp; Partition tolerance)系统：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;request.&lt;span class=&quot;code-snippet__keyword&quot;&gt;required&lt;/span&gt;.acks=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;min&lt;/span&gt;.insync.replicas = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;unclean.leader.election.enable = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;     &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当配置为acks=1 时，即leader接收消息后回ack，这时会出现消息丢失的问题：如果 leader接受到了 第4 条消息，此时还没有同步到 follower中，leader机器挂了，其中一个follower被选为 leader, 则 第 4 条消息丢失了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然这个也需要unclean.leader.election.enable参数配置为false来配合。但是leader回ack的情况下，follower未同步的概率会大大提升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过producer策略的配置和Kafka集群通用参数的配置，可以针对自己的业务系统特点来进行合理的参数配置，在通讯性能和消息可靠性下寻得某种平衡。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2. Broker的可靠性保证&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;消息通过producer发送到broker之后，还会遇到很多问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Partition leader 写入成功，follower什么时候同步？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Leader写入成功，消费者什么时候能读到这条消息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Leader写入成功后，leader重启，重启后消息状态还正常嘛？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Leader重启，如何选举新的leader？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些问题集中在：消息落到broker后，集群通过何种机制来保证不同副本间的消息状态一致性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3. Kafka消息备份和同步&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Kafka通过分区的多副本策略来解决消息的备份问题。通过HW和LEO的标识，来对应ISR和OSR的概念，用于类比共识性算法解决数据同步一致性的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分区多副本即前文提到的Partition 的replica(副本) 分布在跟 partition 不相同的机器上， 通过数据冗余保证故障自动转移。而不同副本的状态形成了ISR和OSR的概念。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ISR : leader 副本保持一定同步的 follower 副本, 包括 leader 副本自己，叫 In Sync Replica；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;AR: 所有副本 (replicas) 统称为 assigned replicas, 即 AR；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OSR: follower 同 leader 同步数据有一些延迟的节点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ISR是Kafka的同步策略中独有的概念，区别于raft等共识性算法。Raft要求集群中要求N/2+1台正常，其在这种条件下通过复杂的算法保证选举出的新leader符合一致性状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而kafka的ISR同步策略，通过ISR列表的可伸缩性和HW&amp;amp;LEO更新，一定程度上解决了消息一致性和吞吐性能之间的平衡。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ISR通过HW和LEO的概念表示消息的同步状态：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HW&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: Highwatermark, 俗称高水位，它表示了一个特定的消息偏移量(offset), 在一个parttion中consumer只能拉取这个 offset 之前的消息(此 offset 跟 consumer offset 不是一个概念) ;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;LEO: LogEndOffset&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;, 日志末端偏移量, 用来表示当前日志文件中下一条写入消息的offset；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;leader HW&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: 该Partititon所有副本的LEO最小值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;follower HW&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: min(follower自身LEO 和 leader HW)；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Leader HW &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;= 所有副本LEO最小值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Follower HW&lt;/strong&gt; = min(follower 自身 LEO 和 leader HW)；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;Leader不仅保存了自己的HW &lt;/span&gt;&lt;span&gt;&amp;amp; &lt;/span&gt;&lt;span&gt;LEO，&lt;/span&gt;&lt;span&gt;还保存了远端副本的HW &amp;amp; &lt;/span&gt;&lt;span&gt;LEO。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单来说，每个副本都有HW和LEO的存储，而leader不但保存自己的HW和LEO, 还保存了每个远端副本的LEO，用于在自身的HW更新时计算值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看出由于LEO远端存储的特性，其实会导致副本真实的LEO和leader存储的LEO有短暂的数值差异，这会带来一些问题，下文也会展开讲述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;HW和LEO的更新策略如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;follower自己的LEO&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Follower从leader副本拉取消息，写入磁盘后，更新LEO值&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Leader自己的LEO&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Leader收到producer消息，写入磁盘后，更新LEO值&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Leader的远程LEO&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Follower fech时带上自己的LEO, leader使用这个值更新远程LEO&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Follower的自己HW&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;followerfetch成功更新LEO后，比较leader发来的hw和自己的hw,取较小值&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Leader自己的hw&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;Leader更新LEO之后，更新完远程LEO之后，取所有副本的最小LEO&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一次完整的写请求的HW / LEO更新流程如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.530035335689046&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8ABzLpW2KHuAek3nON2QywOQM7ic0QX2DaIJxvxOPzicJRnuLHVc6K3sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;（1）初始状态&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Leader 所有的 HW&amp;amp;LEO都为0， follower 与 leader 建立连接，follower fetch leader, follower 所有 HW &amp;amp; LEO 都为0&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;（2）Follower 第一次 fetch&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Producer 发来一条消息到 leader, 此时 leader 的 LEO=1, follower 带着自己的 HW&amp;amp;LEO(都为0) 开始 fetch, leader的 HW=min(all follower LEO)=0, leader 记录follower的LEO=0；follower 拉取到一条消息，带着消息和leader的 HW(0)&amp;amp;LEO(1)返回自身更新自己的LEO=1,  更新自己的HW=min(follower 自身 LEO(1) 和 leader HW(0))=0&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;（3）Follower 第二次fetch&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Follower带着自己的 HW(0)&amp;amp;LEO(1) 去请求leader .此时leader 的HW更新为1，leader 保存的follower的 LEO更新为1，带着leader 的 HW(1)&amp;amp;LEO(1)返回自身，更新自己的 HW&amp;amp;LEO&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此时回到刚才提到的问题，这种HW和LEO更新策略有个很明显的问题，即follower的HW更新需要follower的2轮fetch中的leader返回才能更新，而Leader的HW已更新。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这之间，如果follower和leader的节点发生故障，则follower的HW和leader的HW会处于不一致状态，带来比较多的一致性问题。比如如下场景：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Leader更新完分区HW后，follower HW还未更新，此时follower重启；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Follower重启后，LEO设置为之前的follower HW值(0), 此时发生消息截断(临时状态)；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Follower重新同步leader, 此时leader宕机，则不选举则不可用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Follower被选举为leader, 则msg 1 永久丢失了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0884476534296028&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8vuMwMwYnxnvia3YrUb52wLsIWBQ0MgpcM5OshibAaglGjIMeezmEicjKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在Kafka配置为AP系统的情况下，由于min.insync.replicas为1，这种重启后follower发生截断发生的概率会大大提升， 而在多个副本存在的情况下，情况可能还会更加糟糕。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而kafka新版本为了解决这个HW&amp;amp;LEO的同步机制更新缺陷，引入了Epoch的概念。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Leader epoch 分两部分组成:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Leader epoch(1, 120) 说明这个leader 的版本号为1，版本的起始位置是 第120条消息开始的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Kafka Broker 会在内存中为每个分区都缓存 Leader Epoch 数据，同时它还会定期地将这些信息持久化到一个 checkpoint 文件中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当 Leader 副本写入消息到磁盘时，Broker 会尝试更新这部分缓存。如果该 Leader 是首次写入消息，那么 Broker 会向缓存中增加一个 Leader Epoch 条目，否则就不做更新。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样，每次有 Leader 变更时，新的 Leader 副本会查询这部分缓存，取出对应的 Leader Epoch 的起始位移，以避免数据丢失和不一致的情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;示意图如下:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6862745098039216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97RPvEEqykOeTAqRp6cW2w8u2ibAWhYgJHk4PLIbmK3AVpsJf53ef0EX6STzByiaEBm63kdjy9pxDOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;561&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; Kafka通过ISR的同步机制及优化策略，用 HW &amp;amp; LEO的方式很好的确保了数据不丢失以及吞吐率。而ISR的管理最终都会反馈到Zookeeper上，其实现和leader的选举策略不再赘述。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;六、Consumer 的可靠性策略&lt;/strong&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;    &lt;br/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Consumer的可靠性策略集中在consumer的投递语义上，即：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;何时消费，消费到什么？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费是否会丢？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费是否会重复？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些语义场景，可以通过Kafka消费者的部分参数进行配置，简单来说有以下3种场景：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. AutoCommit（at most once, commit后挂，实际会丢）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;enable.&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt;.commit = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt;.commit.interval.ms&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;配置如上的consumer收到消息就返回正确给 brocker, 但是如果业务逻辑没有走完中断了，实际上这个消息没有消费成功。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种场景适用于可靠性要求不高的业务。其中auto.commit.interval.ms代表了自动提交的间隔。比如设置为1s提交1次，那么在1s内的故障重启，会从当前消费offset进行重新消费时，1s内未提交但是已经消费的msg, 会被重新消费到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 手动Commit（at least once, commit前挂，就会重复, 重启还会丢）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;enable.&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt;.commit = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;配置为手动提交的场景下，业务开发者需要在消费消息到消息业务逻辑处理整个流程完成后进行手动提交。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果在流程未处理结束时发生重启，则之前消费到未提交的消息会重新消费到，即消息显然会投递多次。此处应用与业务逻辑明显实现了幂等的场景下使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;特别应关注到在golang中sarama库的几个参数的配置：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.offset&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.initial&lt;/span&gt;  （&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;oldest&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;newest&lt;/span&gt;）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;offsets&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.retention&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.minutes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;       &lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;intitial = oldest代表消费可以访问到的topic里的最早的消息，大于commit的位置，但是小于HW。同时也受到broker上消息保留时间的影响和位移保留时间的影响。不能保证一定能消费到topic起始位置的消息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果设置为newest则代表访问commit位置的下一条消息。如果发生consumer重启且autocommit没有设置为false, 则之前的消息会发生丢失，再也消费不到了。在业务环境特别不稳定或非持久化consumer实例的场景下，应特别注意。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般情况下， offsets.retention.minutes为1440s。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. Exactly once（很难，需要msg持久化和commit是原子的）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;        &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;消息投递且仅投递一次的语义是很难实现的。&lt;/span&gt;&lt;span/&gt;&lt;span&gt;首先要消费消息并且提交保证不会重复投递，其次提交前要完成整体的业务逻辑关于消息的处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在Kafka本身没有提供此场景语义接口的情况下，这几乎是不可能有效实现的。一般的解决方案，也是进行原子性的消息存储，业务逻辑异步慢慢的从存储中取出消息进行处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/  文末福利  /&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;腾讯云十周年筑梦，感恩有你！扫描下方二维码，即可领取腾讯云定制红包封面一份，名额有限，先到先得哦&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;20&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96nE2y85ib3xplniakcWaee0GUphKea6pk3IlK9L4ibKCibPJtmoEg4BzNCPXdtnY6g5DhH5UibODOgeJg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.8&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;880&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96nE2y85ib3xplniakcWaee0G2NyNShbndulfUJoLqEdA5OVxgjRbMabdYJ6F8dhEau8Nk3cc58P7oQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.59375&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4xV7ckfbmtFLyUjFID2k7yO4q8hvB4OqYoNkARZ2xuvzKvMtnmVN2BQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d827e236b6a0f8512fcd66587d7cded6</guid>
<title>[推荐] 超全面分布式缓存高可用方案：哨兵机制</title>
<link>https://toutiao.io/k/1k0udg9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;1&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;2&quot;&gt;开发工作中对于分布式缓存高可用方案（搭建Redis缓存高可用方案），Redis主从架构下是如何保证高可用的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;3&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;4&quot;&gt;我们知道是应用了哨兵机制来实现。那Redis 服务部署的哨兵模式主要是什么，又解决了什么问题呢，于是利用周末时间整理了下，相信看完这篇文章，你也可以去给别人做技术分享了。O(∩_∩)O哈哈~&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id-heading0=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;5&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;6&quot;&gt;问题铺垫&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;7&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;8&quot;&gt;在讨论哨兵模式之前，我们先来看一个应用问题：&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;9:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;Redis服务主机宕机&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;10&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;11&quot;&gt;实际使用过程中，会出现master宕机的情况（这样会导致没有写服务，只有读服务）。那我们要保证服务的可用，就需要从其他salve节点中选取一个来作为master节点，来继续提供服务能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;13&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;那主要的动作抽象下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;将宕机的master下线&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;找一个slave作为master&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;通知所有的slave连接新的master&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;全量数据或者部分数据同步&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;27&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;28&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;其中存在几个问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;39&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;40&quot;&gt;其实引入&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;41:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;哨兵机制&lt;/strong&gt;&lt;/span&gt;，就可以很好的解决上述问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4745011086474501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGeE7b36CFd05okdB5QbQjNicl4DjZaHu0HTtZluCRXb33ycxDnMHTTHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵-Redis集群&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id-heading1=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;46&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;47&quot;&gt;什么是哨兵？&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;48&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;49&quot;&gt;Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例组成的Sentinel 系统可以监视任意多个主服务，以及这些主服务器属下的所有从服务，并在被监视的主服务进入下线（不可服务）状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;50&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;51&quot;&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;52&quot;&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;总结一下哨兵的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;58&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;59&quot;&gt;    不断的检查master和slave是否正常运行（master存活检测、master与slave运行情况检测）&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;64&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;65&quot;&gt;    当被监控的服务器出现问题时，向其他哨兵、客户端发送通知&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;70&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;71&quot;&gt;    断开故障master与slave的连接，选取一个slave作为新master，将其他slave连接到新的master并告知客户端新的服务器地址。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;74&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;75&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;76&quot;&gt;注意：哨兵也是一台Redis服务器，只是不提供数据服务；通常哨兵配置的数量为单数。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-id-heading2=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;77&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;78&quot;&gt;哨兵的工作原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;79&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;80&quot;&gt;下面主要针对哨兵在进行故障转移过程中经历的三个阶段分别进行阐述。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading3=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;81&quot;&gt;&lt;span&gt;1、集群监控&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;84&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;step1：哨兵1连接到Redis集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span&gt;发送info命令到master，并建立cmd连接；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span&gt;哨兵端保存哨兵状态（SentinelStatus），保存所有哨兵状态，主节点和从节&lt;/span&gt;&lt;span&gt;点的信息；master端会记录 redis 实例的信息（SentinelRedisInstance）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span&gt;哨兵根据master中获取的每个slave信息，去连接每个slave，发送同样也是info命令。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5700197238658777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGxxPLNq0TXY3mJAGKUGGVJywOJazQmAvGFTUicJdozhhPuc2PADdSQtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群监控&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;97&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;step2：哨兵2加入进来后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span&gt;同样会发送info命令到master节点，并建立cmd连接；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span&gt;发现master中存在其他哨兵节点的信息，哨兵2中保存哨兵信息（区别与哨兵1的是它保存了哨兵1和哨兵2的2个哨兵节点信息）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span&gt;为了每个哨兵的信息都一致它们之间建立了一个发布订阅。为了哨兵之间的信息长期对称它们之间也会互发 ping 命令。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.46991869918699186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGlojD0ib1yRRRG9n5Kp2y12BleUZjsmC7t0aY3IB1XCic99ZbKR0tczPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群监控&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;111&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;112&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;step3：哨兵3加入后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6419354838709678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGZt1atOq0us0xswSM2DQ1ahy13bgE5Y75lXS46oo2jZo9vTqUvwFibpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群监控&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;123&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;124&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;小结一下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading4=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;132&quot;&gt;&lt;span&gt;2、消息通知&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;134&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;135&quot;&gt;1）Sentinel节点会通过master/slave 节点建立的cmd连接获取其工作状态&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;136&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;137&quot;&gt;2）Sentinel收到反馈结果之后，会在哨兵内部进行信息的互通&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4048059149722736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQG8bwmsMVNqs7DysCvA5Nps2UHSop6fbYAzyDJiby1oGZDcmyniabPeh7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息通知&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading5=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;141&quot;&gt;&lt;span&gt;3、故障转移&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;143&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;144&quot;&gt;关于故障转移，严格来讲可划分两个步骤：&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;145:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;故障判定&lt;/strong&gt;&lt;/span&gt;、&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;147:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;故障转移&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id-heading6=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;149&quot;&gt;&lt;span&gt;Q1：如何判断一个节点出现故障？&lt;/span&gt;&lt;/h4&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;155&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;156&quot;&gt;&lt;span&gt;直到主节点故障，哨兵报出 sdown，同时此哨兵还会向其他哨兵发布消息说这个主节点挂了。发送的指令是 sentinel is-master-down-by-address-port。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;164&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;165&quot;&gt;&lt;span&gt;其余的哨兵也会发送他们收到的信息并且发送指令 sentinel is-master-down-by-address-port 到自己的内网，确认一下第一个发送 sentinel is-master-down-by-address-port 的哨兵说你说的对，这个家伙确实挂了。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;173&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;174&quot;&gt;&lt;span&gt;当一个哨兵认为主节点挂了标记的是 sdown，当半数哨兵都认为挂了其标记的状态是 odown。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;176&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;177&quot;&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;178&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;179&quot;&gt;一个哨兵认为master节点挂了称为主观下线（sdown），超半数哨兵认为master节点挂了则称为客观下线（odown）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.46855345911949686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGpV8htDDEVhmloCiahrbBbCDTGp7dulSXEe8HOicP9aEPzZXVz1tJ7Tag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/p&gt;&lt;h4 data-id-heading7=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;183&quot;&gt;&lt;span&gt;Q2：如何进行故障转移？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;1）首先，哨兵选举出哨兵Leader去处理故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; 此时选举方式应用的是Raft协议，这个之前有过介绍，感兴趣的同学可以移步了解：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDg5MDkzOA==&amp;amp;mid=2448762601&amp;amp;idx=1&amp;amp;sn=8bfef19e832b46b423d7e48bdf836ed4&amp;amp;chksm=8b34623cbc43eb2a5abcf0a6e40c1c01d36929e4052cb9f77f82cc0c19fa9870e433c7cc8224&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一致性算法Raft 简易入门&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;2）其次，哨兵Leader从所有的slave节点找出一个作为master节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;193&quot;&gt;&lt;span&gt;主要的规则：&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;207&quot;&gt;&lt;span&gt;假如以上优先级均一致，会考虑其他优先原则：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;213&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;214&quot;&gt;&lt;span&gt;假如说 slave1 的 offset 为 50，slave2 偏移量为 55，则哨兵就会选择 slave2 为新的主节点。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;222&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;223&quot;&gt;&lt;span&gt;这点类似于职场中的论资排辈，也就说根据 runid 的创建时间来判断，时间早的先上位。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;225&quot;&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;227&quot;&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;3）数据转移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id-heading8=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;236&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;237&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;238&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;239&quot;&gt;Redis 主从复制的作用中有这么一句话“主从复制是高可用的基石”，那实现高可用必不可少的就是哨兵和集群。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading9=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;240&quot;&gt;&lt;span&gt;1、Sentinel的作用&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;246&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;247&quot;&gt;不断的检查master和slave是否正常运行（master存活检测、master与slave运行情况检测）&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;252&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;253&quot;&gt;当被监控的服务器出现问题时，向其他哨兵、客户端发送通知&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;258&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;259&quot;&gt;断开故障master与slave的连接，选取一个slave作为新master，将其他slave连接到新的master并告知客户端新的服务器地址。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading10=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;260&quot;&gt;&lt;span&gt;2、Sentinel的工作方式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;269&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;270&quot;&gt;&lt;span&gt; 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;279&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;280&quot;&gt;&lt;span&gt;若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;395&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;395&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSxEpr7AzM5lGCicdEjfuE6jaiae9Rmj1CVCg85GJKaFKuico89ZlnhGicQiciciccOiaqVibE5cmKXwO1AOuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「技术架构精进」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56ce23d41dd795d050b9877710a762b4</guid>
<title>[推荐] 用 WebRTC 和 Node.js 开发实时视频聊天应用</title>
<link>https://toutiao.io/k/5shq47n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;话不多说，我们直奔主题。这篇文章教大家如何编写一个视频聊天应用，使已连接的两用户端能共享视频和音频。操作很简单，非常适合JavaScript语言训练——更准确地说是WebRTC技术和&lt;a href=&quot;https://tsh.io/services/web-development/node/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/services/web-development/node/&quot;&gt;Node.js&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;什么是WebRTC&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;Web Real-Time Communications 网页实时通信，简称WebRTC。WebRTC是一个HTML5规范，它允许用户在浏览器之间直接进行实时通信，不需要任何第三方插件。WebRTC可用于多种情境（比如文件共享），但端对端实时音频和视频通信是其主要功能。本文将着重为大家介绍这两项。&lt;/p&gt;



&lt;p&gt;WebRTC所做的就是允许接入设备。你可以借WebRTC来实时使用麦克风、摄像头和分享你的屏幕。&lt;/p&gt;



&lt;p&gt;所以，WebRTC可以用最简单的方式在网页中实现音频和视频通信。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC JavaScript API&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC说起来很复杂，它涉及到很多技术。但建立连接、通信和传输数据的操作是通过一套JS API来实现的，还比较简单。其中主要的API包括：&lt;/p&gt;



&lt;p&gt;RTCPeerConnection：创建和导航端对端连接。&lt;/p&gt;



&lt;p&gt;RTCSessionDescription：描述连接（或潜在连接）的一端，以及它的配置方式。&lt;/p&gt;



&lt;p&gt;navigator.getUserMedia：捕捉音频和视频。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;为什么选择Node.js&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;若要在两个或多个设备之间进行远程连接，你就需要一个服务器。在这种情况下，你也需要一个处理实时通信的服务器。Node.js是为实时可扩展的应用而构建的。要开发自由数据交换的双向连接应用程序，你可能会用到WebSockets，它允许在客户端和服务器之间建立一个会话窗口。来自客户端的请求会以循环的方式，更准确的说是事件循环进行处理，这时Node.js是我们很好的一个选择，因为它采取 “非阻塞（non-blocking） “的方式来解决请求。这样我们在这该过程中就能实现低延迟和高吞吐量。&lt;/p&gt;



&lt;p&gt;如果你对开发微服务感兴趣的话，一定要看看查看我们内含650多位微服务专家意见的&lt;a href=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot;&gt;2020年微服务状态报告&lt;/a&gt;！&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;思路拓展：我们要创建的是什么？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们会创建一个非常简单的应用程序，它能让我们将音频和视频流传输到连接的设备——一个基础款视频聊天应用程序。我们会用到的技术有:&lt;/p&gt;



&lt;p&gt;Express库，提供静态文件，比如代表用户界面（UI）的HTML文件；&lt;/p&gt;



&lt;p&gt;socket.io库，在两个设备之间用WebSockets建立连接；&lt;/p&gt;



&lt;p&gt;WebRTC，允许媒体设备（摄像头和麦克风）在连接的设备之间传输音频和视频流。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;实现视频会话&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们要做的第一件事是给我们的应用程序提供一个作为UI的HTML文件。让我们通过运行：npm init.js来初始化新的node.js项目。然后，我们需要通过运行：npm i -D typescript ts-node nodemon @types/express @types/socket.io安装一些开发依赖项，运行：npm i express socket.io安装生产依赖项。&lt;/p&gt;



&lt;p&gt;之后我们就可以在package.json文件中定义脚本，来运行我们的项目了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;{
 &quot;scripts&quot;: {
   &quot;start&quot;: &quot;ts-node src/index.ts&quot;,
   &quot;dev&quot;: &quot;nodemon --watch &#x27;src/**/*.ts&#x27; --exec &#x27;ts-node&#x27; src/index.ts&quot;
 },
 &quot;devDependencies&quot;: {
   &quot;@types/express&quot;: &quot;^4.17.2&quot;,
   &quot;@types/socket.io&quot;: &quot;^2.1.4&quot;,
   &quot;nodemon&quot;: &quot;^1.19.4&quot;,
   &quot;ts-node&quot;: &quot;^8.4.1&quot;,
   &quot;typescript&quot;: &quot;^3.7.2&quot;
 },
 &quot;dependencies&quot;: {
   &quot;express&quot;: &quot;^4.17.1&quot;,
   &quot;socket.io&quot;: &quot;^2.3.0&quot;
 }
}&lt;/pre&gt;



&lt;p&gt;当我们运行npm run dev命令时，nodemon会监控src文件夹中每个以.ts结尾的文件有无任何变化。现在，我们要创建一个src文件夹。在这个文件夹中，我们会创建两个typescript文件：index.ts和server.ts。&lt;/p&gt;



&lt;p&gt;在server.ts中，我们会创建server类，并使其与express和socket.io一起工作。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import express, { Application } from &quot;express&quot;;
import socketIO, { Server as SocketIOServer } from &quot;socket.io&quot;;
import { createServer, Server as HTTPServer } from &quot;http&quot;;
 
export class Server {
 private httpServer: HTTPServer;
 private app: Application;
 private io: SocketIOServer;
 
 private readonly DEFAULT_PORT = 5000;
 
 constructor() {
   this.initialize();
 
   this.handleRoutes();
   this.handleSocketConnection();
 }
 
 private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 }
 
 private handleRoutes(): void {
   this.app.get(&quot;/&quot;, (req, res) =&amp;gt; {
     res.send(`&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;`); 
   });
 }
 
 private handleSocketConnection(): void {
   this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     console.log(&quot;Socket connected.&quot;);
   });
 }
 
 public listen(callback: (port: number) =&amp;gt; void): void {
   this.httpServer.listen(this.DEFAULT_PORT, () =&amp;gt;
     callback(this.DEFAULT_PORT)
   );
 }
}&lt;/pre&gt;



&lt;p&gt;为正常运行服务器，我们需要在index.ts文件中创建一个新的Server类实例并调用listen方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import { Server } from &quot;./server&quot;;
 
const server = new Server();
 
server.listen(port =&amp;gt; {
 console.log(`Server is listening on http://localhost:${port}`);
});&lt;/pre&gt;



&lt;p&gt;现在，如果我们运行：npm run dev会看到下面这样的情景：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-1_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;当打开浏览器，输入&lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000&lt;/a&gt;，我们应该注意到左上的 “Hello World “信息。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-2_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们就可以在public/index.html中创建一个新的HTML文件了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
 &amp;lt;head&amp;gt;
   &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
   &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;
   &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt;
   &amp;lt;title&amp;gt;Dogeller&amp;lt;/title&amp;gt;
   &amp;lt;link
     href=&quot;https://fonts.googleapis.com/css?family=Montserrat:300,400,500,700&amp;amp;display=swap&quot;
     rel=&quot;stylesheet&quot;
   /&amp;gt;
   &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&amp;gt;
   &amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;container&quot;&amp;gt;
     &amp;lt;header class=&quot;header&quot;&amp;gt;
       &amp;lt;div class=&quot;logo-container&quot;&amp;gt;
         &amp;lt;img src=&quot;./img/doge.png&quot; alt=&quot;doge logo&quot; class=&quot;logo-img&quot; /&amp;gt;
         &amp;lt;h1 class=&quot;logo-text&quot;&amp;gt;
           Doge&amp;lt;span class=&quot;logo-highlight&quot;&amp;gt;ller&amp;lt;/span&amp;gt;
         &amp;lt;/h1&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/header&amp;gt;
     &amp;lt;div class=&quot;content-container&quot;&amp;gt;
       &amp;lt;div class=&quot;active-users-panel&quot; id=&quot;active-user-container&quot;&amp;gt;
         &amp;lt;h3 class=&quot;panel-title&quot;&amp;gt;Active Users:&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
       &amp;lt;div class=&quot;video-chat-container&quot;&amp;gt;
         &amp;lt;h2 class=&quot;talk-info&quot; id=&quot;talking-with-info&quot;&amp;gt; 
           Select active user on the left menu.
         &amp;lt;/h2&amp;gt;
         &amp;lt;div class=&quot;video-container&quot;&amp;gt;
           &amp;lt;video autoplay class=&quot;remote-video&quot; id=&quot;remote-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
           &amp;lt;video autoplay muted class=&quot;local-video&quot; id=&quot;local-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
         &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;script src=&quot;./scripts/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;



&lt;p&gt;在这个新文件中，我们创建了两个视频元素：一个用于远程视频连接，另一个用于本地视频。你可能已经注意到我们也在导入本地脚本了。现在我们就来创建一个新的文件夹“脚本”，并在这个目录下创建index.js文件。至于样式，你可以从&lt;a href=&quot;https://github.com/Miczeq22/simple-chat-app&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;GitHub库&lt;/a&gt;中下载它们。&lt;/p&gt;



&lt;p&gt;接下来你需要给浏览器提供index.html。首先，你需要告诉express你想提供哪些静态文件。为了实现这一点，我们决定在Server类中实现一个新方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private configureApp(): void {
   this.app.use(express.static(path.join(__dirname, &quot;../public&quot;)));
 }&lt;/pre&gt;



&lt;p&gt;不要忘记在initialize中调用configureApp。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 
   this.configureApp();
   this.handleSocketConnection();
 }&lt;/pre&gt;



&lt;p&gt;当你输入&lt;a href=&quot;http://localhost:5000&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;http://localhost:5000&lt;/a&gt;后，你应该能看到你的index.html文件在运行。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-3_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;下一步要实现的是允许摄像头和视频访问并将其流式传输到local-video元素。要做到这一点，你需要打开public/scripts/index.js文件，并用以下方法实现它。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;当回到浏览器时，界面会出现一个提示请求访问你的媒体设备，在接受请求后，你电脑的摄像头就开始工作了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-4_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;更多细节详见&lt;a href=&quot;https://tsh.io/blog/simple-guide-concurrency-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;A simple guide to concurrency in Node.js and a few traps that come with it&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;如何处理socket&lt;/strong&gt;&lt;strong&gt;连接？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;接下来我们讲讲如何处理socket连接。我们需要将客户端与服务器连接起来。为此，我们将使用socket.io。在public/scripts/index.js中，添加以下代码：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;页面刷新后，电脑会弹出一条消息，显示 “Socket已连接”&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-5_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们回到server.ts中，把已连接的socket存储在内存中，这只是为了保留唯一连接。所以，我们需要在Server类中添加一个新的私有字段，如下：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private activeSockets: string[] = [];&lt;/pre&gt;



&lt;p&gt;然后我们需要在socket连接中检查socket是否已经存在。如果不存在，把新的socket推送到内存中，并向已连接的用户发送数据。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;你还需要在socket断开连接时及时响应，所以在socket连接中，你需要添加：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;disconnect&quot;, () =&amp;gt; {
   this.activeSockets = this.activeSockets.filter(
     existingSocket =&amp;gt; existingSocket !== socket.id
   );
   socket.broadcast.emit(&quot;remove-user&quot;, {
     socketId: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;客户端(即public/scripts/index.js)这边，你需要妥善处理那些信息：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;update-user-list&quot;, ({ users }) =&amp;gt; {
 updateUserList(users);
});
 
socket.on(&quot;remove-user&quot;, ({ socketId }) =&amp;gt; {
 const elToRemove = document.getElementById(socketId);
 
 if (elToRemove) {
   elToRemove.remove();
 }
});&lt;/pre&gt;



&lt;p&gt;以下是 updateUserList 函数：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function updateUserList(socketIds) {
 const activeUserContainer = document.getElementById(&quot;active-user-container&quot;);
 
 socketIds.forEach(socketId =&amp;gt; {
   const alreadyExistingUser = document.getElementById(socketId);
   if (!alreadyExistingUser) {
     const userContainerEl = createUserItemContainer(socketId);
     activeUserContainer.appendChild(userContainerEl);
   }
 });
}&lt;/pre&gt;



&lt;p&gt;以及createUserItemContainer函数:&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function createUserItemContainer(socketId) {
 const userContainerEl = document.createElement(&quot;div&quot;);
 
 const usernameEl = document.createElement(&quot;p&quot;);
 
 userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user&quot;);
 userContainerEl.setAttribute(&quot;id&quot;, socketId);
 usernameEl.setAttribute(&quot;class&quot;, &quot;username&quot;);
 usernameEl.innerHTML = `Socket: ${socketId}`;
 
 userContainerEl.appendChild(usernameEl);
 
 userContainerEl.addEventListener(&quot;click&quot;, () =&amp;gt; {
   unselectUsersFromList();
   userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user active-user--selected&quot;);
   const talkingWithInfo = document.getElementById(&quot;talking-with-info&quot;);
   talkingWithInfo.innerHTML = `Talking with: &quot;Socket: ${socketId}&quot;`;
   callUser(socketId);
 }); 
 return userContainerEl;
}&lt;/pre&gt;



&lt;p&gt;需要注意的是，我们给用户容器元素添加了一个可以调用callUser函数的点击监听器——但现在，它可以是一个空的函数。接下来，当运行两个浏览器窗口（其中一个作为私人窗口）时，你应该注意到你的Web应用程序中有两个已经连接的socket。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-6_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;点击列表中的活跃用户，这时我们需要调用callUser函数。但是在实现之前，你还需要在window对象中声明两个类。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;const { RTCPeerConnection, RTCSessionDescription } = window;&lt;/pre&gt;



&lt;p&gt;我们会在callUser函数用到这两个类：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;async function callUser(socketId) {
 const offer = await peerConnection.createOffer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(offer));
 
 socket.emit(&quot;call-user&quot;, {
   offer,
   to: socketId
 });
}&lt;/pre&gt;



&lt;p&gt;现在我们要创建一个本地请求并发送给选定的用户。服务器会监听一个叫做call-user的事件、拦截请求并将其转发给选定的用户。让我们用server.ts来实现该操作：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-user&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;call-made&quot;, {
     offer: data.offer,
     socket: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，你需要就call-made事件作出调整：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.offer)
 );
 const answer = await peerConnection.createAnswer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(answer));
 
 socket.emit(&quot;make-answer&quot;, {
   answer,
   to: data.socket
 });
});&lt;/pre&gt;



&lt;p&gt;之后，在你从服务器得到的请求上设置一个远程描述，并为这个请求创建一个答复。对于服务器端，你只需要将适当的数据传递给选定的用户即可。然后我们再在server.ts里面添加一个监听器。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;make-answer&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;answer-made&quot;, {
     socket: socket.id,
     answer: data.answer
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，我们需要处理 answer-made 事件。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;answer-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.answer)
 );
 
 if (!isAlreadyCalling) {
   callUser(data.socket);
   isAlreadyCalling = true;
 }
});&lt;/pre&gt;



&lt;p&gt;我们可以使用标志isAlreadyCalling，它能帮助确保我们只需调用一次用户。&lt;/p&gt;



&lt;p&gt;最后你需要做的是添加本地轨道，包括音频和视频到你的连接端。只有做到这一点，我们才能够与连接的用户共享视频和音频。要做到这一点，我们需要在navigator.getMediaDevice回调中调用peerConnection对象的addTrack函数。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 
   stream.getTracks().forEach(track =&amp;gt; peerConnection.addTrack(track, stream));
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;另外，我们还需要为ontrack事件添加一个适当的处理程序。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;peerConnection.ontrack = function({ streams: [stream] }) {
 const remoteVideo = document.getElementById(&quot;remote-video&quot;);
 if (remoteVideo) {
   remoteVideo.srcObject = stream;
 }
};&lt;/pre&gt;



&lt;p&gt;如图示，我们已经从传递的对象中获取了流，并改变了远程视频中的srcObject来使用接收到的流。所以现在当你点击活跃用户后，你应该建立一个视频和音频连接，像下图这样：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-7_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;欲了解细节，请参阅：&lt;a href=&quot;https://tsh.io/blog/dependency-injection-in-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Node.js and dependency injection – friends or foes?&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;现在你知道如何编写一个视频聊天应用了吧！&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC是一个很大的话题，内容非常庞杂。如果你想了解它的运作原理，就需要花很大功夫。幸运的是，我们可以访问易于使用的JavaScript API，它可以帮助我们创建很简洁的应用程序，例如视频共享、聊天应用程序等等。&lt;/p&gt;



&lt;p&gt;如果你想深入了解WebRTC，点击此&lt;a href=&quot;http://Node.js%20and%20dependency%20injection%20–%20friends%20or%20foes%3F&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;WebRTC官方文档的链接&lt;/a&gt;。另外，我也推荐你阅读&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;MDN的文档说明&lt;/a&gt;，它能帮助你更加了解此技术。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：Mikołaj Wargowski&lt;/p&gt;&lt;/blockquote&gt;



&lt;p/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>