<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>56579331c3fbdd6b67189183fd49be03</guid>
<title>每个 gopher 都需要了解的 Go AST</title>
<link>https://toutiao.io/k/w1je9qc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近业务迁移，大约 100+ 个接口需要从旧的服务，迁到公司框架。遇到几个痛点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;结构体 dto 做 diff, 对比结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义的结构体与 protobuf 生成的互相转换，基于 json tag&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类工作要么手写(编译期), 要么 reflect 反射实现(运行时)。其中 #1 考滤到性能问题，手写最优，但是结构体太大，同时 100+ 个接口迁移，工作量可以想象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;google 开源的 &lt;span&gt;go-cmp&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;, 输出美观，反射性能开销大了点。当前业务大量使用，堆机器吧又不是不能用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;#2 目前不好解决，可以简单的 json Marshal 再 Unmarshal, 但有些字段类型不一致，同时如何做 json tag 到 pb tag 转换呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们当前的方案是通过解析 ast, 读源码生成结构体树，然后 BFS 遍历自动生成转换代码&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;//go:generate ast-tools --action convert --target-pkg aaa/dto/geresponse --src-pkg bbb/dto --source aaaResponse  --target bbbResponse&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合 go generate 自动生成，这是我们的目标&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go AST 基础&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不搞编译器的大多只需要懂前端，不涉及 IR 与后端，同时 go 官方还提供了大量开箱即用的库 &lt;span&gt;go/ast&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9OBDxDDV6f01FFTBgpjIxuCCzU4fdExTVQ04kKL1zVTxlD7U3vMrKTToDTHwqIsgv8UTmXyvhibEfJYEy8jumnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Node &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Pos() token.Pos &lt;span&gt;// position of first character belonging to the node&lt;/span&gt;&lt;br/&gt; End() token.Pos &lt;span&gt;// position of first character immediately after the node&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有实现 &lt;code&gt;Pos&lt;/code&gt; &lt;code&gt;End&lt;/code&gt; 的都是 Node&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Comments&lt;/code&gt; 注释， //-style 或是 /*-style&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Declarations&lt;/code&gt; 声明，&lt;code&gt;GenDecl&lt;/code&gt; (generic declaration node) 代表 import, constant, type 或 variable declaration. &lt;code&gt;BadDecl&lt;/code&gt; 代表有语法错误的 node&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Statements&lt;/code&gt; 常见的语句表达式，return, case, if 等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File&lt;/code&gt; 代表一个 go 源码文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Package&lt;/code&gt; 代表一组源代码文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Expr&lt;/code&gt; 表达式 ArrayExpr, StructExpr, SliceExpr 等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一个例子吧，&lt;span&gt;goast可视化界面&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 更直观一些&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Manager ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Manager &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Same      &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; All       &lt;span&gt;bool&lt;/span&gt;   &lt;span&gt;`json:&quot;all&quot;`&lt;/span&gt;&lt;br/&gt; Version   &lt;span&gt;int&lt;/span&gt;    &lt;span&gt;`json:&quot;-&quot;`&lt;/span&gt;&lt;br/&gt; NormalStruct  pkgcmd.RootApp&lt;br/&gt; PointerStruct *pkgcmd.RootApp&lt;br/&gt; SlicesField       []&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; MapField           &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们定义结构体 &lt;code&gt;Manager&lt;/code&gt; 来看一下 goast 输出结果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;29&lt;/span&gt;  .  &lt;span&gt;1&lt;/span&gt;: *ast.GenDecl {&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;  .  .  Doc: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;  .  .  TokPos: foo:&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;  .  .  Tok: &lt;span&gt;type&lt;/span&gt;&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;  .  .  Lparen: -&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;  .  .  Specs: []ast.Spec (&lt;span&gt;len&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;  .  .  .  &lt;span&gt;0&lt;/span&gt;: *ast.TypeSpec {&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;  .  .  .  .  Doc: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;  .  .  .  .  Name: *ast.Ident {&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;  .  .  .  .  .  NamePos: foo:&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;  .  .  .  .  .  Name: &lt;span&gt;&quot;Manager&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;  .  .  .  .  .  Obj: *ast.Object {&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;  .  .  .  .  .  .  Kind: &lt;span&gt;type&lt;/span&gt;&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;  .  .  .  .  .  .  Name: &lt;span&gt;&quot;Manager&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;43&lt;/span&gt;  .  .  .  .  .  .  Decl: *(obj @ &lt;span&gt;35&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;44&lt;/span&gt;  .  .  .  .  .  .  Data: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;  .  .  .  .  .  .  Type: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;46&lt;/span&gt;  .  .  .  .  .  }&lt;br/&gt;&lt;span&gt;47&lt;/span&gt;  .  .  .  .  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*ast.GenDecl&lt;/code&gt; 通用声明，&lt;code&gt;*ast.TypeSpec&lt;/code&gt; 代表是个类型的定义，名称是 &lt;code&gt;Manager&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;48&lt;/span&gt;    .  Assign: -&lt;br/&gt;&lt;span&gt;49&lt;/span&gt;    .  Type: *ast.StructType {&lt;br/&gt;&lt;span&gt;50&lt;/span&gt;    .  .  Struct: foo:&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;51&lt;/span&gt;    .  .  Fields: *ast.FieldList {&lt;br/&gt;&lt;span&gt;52&lt;/span&gt;    .  .  .  Opening: foo:&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;53&lt;/span&gt;    .  .  .  List: []*ast.Field (&lt;span&gt;len&lt;/span&gt; = &lt;span&gt;7&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;54&lt;/span&gt;    .  .  .  .  &lt;span&gt;0&lt;/span&gt;: *ast.Field {&lt;br/&gt;&lt;span&gt;55&lt;/span&gt;    .  .  .  .  .  Doc: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;56&lt;/span&gt;    .  .  .  .  .  Names: []*ast.Ident (&lt;span&gt;len&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;57&lt;/span&gt;    .  .  .  .  .  .  &lt;span&gt;0&lt;/span&gt;: *ast.Ident {&lt;br/&gt;&lt;span&gt;58&lt;/span&gt;    .  .  .  .  .  .  .  NamePos: foo:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;59&lt;/span&gt;    .  .  .  .  .  .  .  Name: &lt;span&gt;&quot;Same&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;60&lt;/span&gt;    .  .  .  .  .  .  .  Obj: *ast.Object {&lt;br/&gt;&lt;span&gt;61&lt;/span&gt;    .  .  .  .  .  .  .  .  Kind: &lt;span&gt;var&lt;/span&gt;&lt;br/&gt;&lt;span&gt;62&lt;/span&gt;    .  .  .  .  .  .  .  .  Name: &lt;span&gt;&quot;Same&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;63&lt;/span&gt;    .  .  .  .  .  .  .  .  Decl: *(obj @ &lt;span&gt;54&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;64&lt;/span&gt;    .  .  .  .  .  .  .  .  Data: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;65&lt;/span&gt;    .  .  .  .  .  .  .  .  Type: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;66&lt;/span&gt;    .  .  .  .  .  .  .  }&lt;br/&gt;&lt;span&gt;67&lt;/span&gt;    .  .  .  .  .  .  }&lt;br/&gt;&lt;span&gt;68&lt;/span&gt;    .  .  .  .  .  }&lt;br/&gt;&lt;span&gt;69&lt;/span&gt;    .  .  .  .  .  Type: *ast.Ident {&lt;br/&gt;&lt;span&gt;70&lt;/span&gt;    .  .  .  .  .  .  NamePos: foo:&lt;span&gt;8&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;71&lt;/span&gt;    .  .  .  .  .  .  Name: &lt;span&gt;&quot;string&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;72&lt;/span&gt;    .  .  .  .  .  .  Obj: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;73&lt;/span&gt;    .  .  .  .  .  }&lt;br/&gt;&lt;span&gt;74&lt;/span&gt;    .  .  .  .  .  Tag: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;75&lt;/span&gt;    .  .  .  .  .  Comment: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;76&lt;/span&gt;    .  .  .  .  }&lt;br/&gt;&lt;span&gt;77&lt;/span&gt;    .  .  .  .  &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*ast.StructType&lt;/code&gt; 代表类型是结构体，&lt;code&gt;*ast.Field&lt;/code&gt; 数组保存结构体成员声明，一共 7 个元素，第 0 个字段名称 &lt;code&gt;Same&lt;/code&gt;, 类型 &lt;code&gt;string&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;131  .  3: *ast.Field {&lt;br/&gt;132  .  .  Doc: nil&lt;br/&gt;133  .  .  Names: []*ast.Ident (len = 1) {&lt;br/&gt;134  .  .  .  0: *ast.Ident {&lt;br/&gt;135  .  .  .  .  NamePos: foo:11:2&lt;br/&gt;136  .  .  .  .  Name: &lt;span&gt;&quot;NormalStruct&quot;&lt;/span&gt;&lt;br/&gt;137  .  .  .  .  Obj: *ast.Object {&lt;br/&gt;138  .  .  .  .  .  Kind: var&lt;br/&gt;139  .  .  .  .  .  Name: &lt;span&gt;&quot;NormalStruct&quot;&lt;/span&gt;&lt;br/&gt;140  .  .  .  .  .  Decl: *(obj @ 131)&lt;br/&gt;141  .  .  .  .  .  Data: nil&lt;br/&gt;142  .  .  .  .  .  Type: nil&lt;br/&gt;143  .  .  .  .  }&lt;br/&gt;144  .  .  .  }&lt;br/&gt;145  .  .  }&lt;br/&gt;146  .  .  Type: *ast.SelectorExpr {&lt;br/&gt;147  .  .  .  X: *ast.Ident {&lt;br/&gt;148  .  .  .  .  NamePos: foo:11:16&lt;br/&gt;149  .  .  .  .  Name: &lt;span&gt;&quot;pkgcmd&quot;&lt;/span&gt;&lt;br/&gt;150  .  .  .  .  Obj: nil&lt;br/&gt;151  .  .  .  }&lt;br/&gt;152  .  .  .  Sel: *ast.Ident {&lt;br/&gt;153  .  .  .  .  NamePos: foo:11:23&lt;br/&gt;154  .  .  .  .  Name: &lt;span&gt;&quot;RootApp&quot;&lt;/span&gt;&lt;br/&gt;155  .  .  .  .  Obj: nil&lt;br/&gt;156  .  .  .  }&lt;br/&gt;157  .  .  }&lt;br/&gt;158  .  .  Tag: nil&lt;br/&gt;159  .  .  Comment: nil&lt;br/&gt;160  .  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*ast.SelectorExpr&lt;/code&gt; 代表该字段类型是 A.B，其中 A 代表 package, 具体 B 是什么类型不知道，还需要遍历包 A&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;221&lt;/span&gt;  .  &lt;span&gt;6&lt;/span&gt;: *ast.Field {&lt;br/&gt;&lt;span&gt;222&lt;/span&gt;  .  .  Doc: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;223&lt;/span&gt;  .  .  Names: []*ast.Ident (&lt;span&gt;len&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;&lt;span&gt;224&lt;/span&gt;  .  .  .  &lt;span&gt;0&lt;/span&gt;: *ast.Ident {&lt;br/&gt;&lt;span&gt;225&lt;/span&gt;  .  .  .  .  NamePos: foo:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;226&lt;/span&gt;  .  .  .  .  Name: &lt;span&gt;&quot;MapField&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;227&lt;/span&gt;  .  .  .  .  Obj: *ast.Object {&lt;br/&gt;&lt;span&gt;228&lt;/span&gt;  .  .  .  .  .  Kind: &lt;span&gt;var&lt;/span&gt;&lt;br/&gt;&lt;span&gt;229&lt;/span&gt;  .  .  .  .  .  Name: &lt;span&gt;&quot;MapField&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;230&lt;/span&gt;  .  .  .  .  .  Decl: *(obj @ &lt;span&gt;221&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;231&lt;/span&gt;  .  .  .  .  .  Data: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;232&lt;/span&gt;  .  .  .  .  .  Type: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;233&lt;/span&gt;  .  .  .  .  }&lt;br/&gt;&lt;span&gt;234&lt;/span&gt;  .  .  .  }&lt;br/&gt;&lt;span&gt;235&lt;/span&gt;  .  .  }&lt;br/&gt;&lt;span&gt;236&lt;/span&gt;  .  .  Type: *ast.MapType {&lt;br/&gt;&lt;span&gt;237&lt;/span&gt;  .  .  .  Map: foo:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;238&lt;/span&gt;  .  .  .  Key: *ast.Ident {&lt;br/&gt;&lt;span&gt;239&lt;/span&gt;  .  .  .  .  NamePos: foo:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;240&lt;/span&gt;  .  .  .  .  Name: &lt;span&gt;&quot;string&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;241&lt;/span&gt;  .  .  .  .  Obj: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;242&lt;/span&gt;  .  .  .  }&lt;br/&gt;&lt;span&gt;243&lt;/span&gt;  .  .  .  Value: *ast.Ident {&lt;br/&gt;&lt;span&gt;244&lt;/span&gt;  .  .  .  .  NamePos: foo:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;245&lt;/span&gt;  .  .  .  .  Name: &lt;span&gt;&quot;string&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;246&lt;/span&gt;  .  .  .  .  Obj: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;247&lt;/span&gt;  .  .  .  }&lt;br/&gt;&lt;span&gt;248&lt;/span&gt;  .  .  }&lt;br/&gt;&lt;span&gt;249&lt;/span&gt;  .  .  Tag: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;250&lt;/span&gt;  .  .  Comment: &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;251&lt;/span&gt;  .  }&lt;br/&gt;&lt;span&gt;252&lt;/span&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*ast.MapType&lt;/code&gt; 代表类型是字段，&lt;code&gt;Key&lt;/code&gt;, &lt;code&gt;Value&lt;/code&gt; 分别定义键值类型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容有点多，大家感兴趣自行实验&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;遍历&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看懂了 go ast 相关基础，我们就可以遍历获取结构体树形结构，广度 + 深度相结合&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *Parser)&lt;/span&gt; &lt;span&gt;IterateGenNeighbours&lt;/span&gt;&lt;span&gt;(dir &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; path, err := filepath.Abs(dir)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; p.visitedPkg[dir] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; pkgs, err := parser.ParseDir(token.NewFileSet(), path, filter, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; todo := &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; pkgName, pkg := &lt;span&gt;range&lt;/span&gt; pkgs {&lt;br/&gt;  nbv := NewNeighbourVisitor(path, p, todo, pkgName)&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, astFile := &lt;span&gt;range&lt;/span&gt; pkg.Files {&lt;br/&gt;   ast.Walk(nbv, astFile)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// update import specs per file&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; name := &lt;span&gt;range&lt;/span&gt; nbv.locals {&lt;br/&gt;   fmt.Sprintf(&lt;span&gt;&quot;IterateGenNeighbours find struct:%s pkg:%s path:%s\n&quot;&lt;/span&gt;, name, nbv.locals[name].importPkg, nbv.locals[name].importPath)&lt;br/&gt;   nbv.locals[name].importSpecs = nbv.importSpec&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; path := &lt;span&gt;range&lt;/span&gt; todo {&lt;br/&gt;  dir := os.Getenv(&lt;span&gt;&quot;GOPATH&quot;&lt;/span&gt;) + &lt;span&gt;&quot;/src/&quot;&lt;/span&gt; + strings.Replace(path, &lt;span&gt;&quot;\&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, visited := p.visitedPkg[dir]; visited {&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  p.IterateGenNeighbours(dir)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的工作量比较大，涉及 import 包，调试了很久，有些 linter 只需读单一文件即可，工作量没法比&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;模板输出&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一步就是输出结果，这里要 BFS 广度遍历结构体树，然后渲染模板&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; convertSlicePointerScalarTemplateString = &lt;span&gt;`&lt;br/&gt;    {% if ArrayLength == &quot;&quot; %}&lt;br/&gt;    dst.{{ TargetFieldName }} = make([]{{ TargetType }}, len(src.{{ SrcFieldName }}))&lt;br/&gt;    {% endif %}&lt;br/&gt;    for i := range src.{{ SrcFieldName }} {&lt;br/&gt;     if src.{{ SrcFieldName }}[i] == nil {&lt;br/&gt;      continue&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;     tmp := *src.{{ SrcFieldName }}[i] &lt;br/&gt;     dst.{{ TargetFieldName }}[i] = &amp;amp;tmp&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是转换 &lt;code&gt;[8]*Scalar&lt;/code&gt; 可以是数组或切片，模板使用 &lt;span&gt;pongo2&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 实现的 jinji2 语法，非常强大&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ConvertDtoInsuranceOptionToCommonInsuranceOptionV2 only convert exported fields&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConvertDtoInsuranceOptionToCommonInsuranceOptionV2&lt;/span&gt;&lt;span&gt;(src *dto.InsuranceOption)&lt;/span&gt; *&lt;span&gt;common&lt;/span&gt;.&lt;span&gt;InsuranceOptionV2&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; src == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    dst := &amp;amp;common.InsuranceOptionV2{}&lt;br/&gt;    dst.ID = src.ID&lt;br/&gt;    dst.OptionPremium = src.OptionPremium&lt;br/&gt;    dst.InsuranceSignature = src.InsuranceSignature&lt;br/&gt;    dst.Title = src.Title&lt;br/&gt;    dst.Subtitle = src.Subtitle&lt;br/&gt;    dst.ErrorText = src.ErrorText&lt;br/&gt;    dst.IsIncluded = src.IsIncluded&lt;br/&gt;    starCurrency := ConvertDtoCurrencyDTOToCommonCurrencyDTO(src.Currency)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; starCurrency != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        dst.Currency = *starCurrency&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dst&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是输出结果的样例，整体来讲比手写靠谱多了，遇到个别 case 还是需要手工 fix&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AST 其它应用场景&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 规则&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作当中用到编译原理的场景非常多，比如去年高老板分享的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxODcxMTIzNQ==&amp;amp;mid=2247486008&amp;amp;idx=1&amp;amp;sn=3121686a3df62752b1e8e86feabe080c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;用规则引擎让你一天上线十个需求&lt;/a&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;If aa.bb.cc == &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;// 说明是多车型发单&lt;/span&gt;&lt;br/&gt;  Unmarshal(bb.cc.ee)&lt;br/&gt;  看&lt;span&gt;type&lt;/span&gt;是否为 &lt;span&gt;4&lt;/span&gt; &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;  &lt;span&gt;// 单车型发单&lt;/span&gt;&lt;br/&gt; Unmarshal(bb.cc.ff)&lt;br/&gt;  看&lt;span&gt;type&lt;/span&gt;是否为 &lt;span&gt;4&lt;/span&gt; &lt;br/&gt;(&lt;span&gt;type&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 的是拼车)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务需要多种多样，订阅 MQ 根据需求做各种各样的统计，入库，供业务查询。如果业务类型少还好，但是 DIDI 业务复杂，如果每次都人工手写 go 代码效率太低&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后解决思路是 &lt;code&gt;JPATH + Expression Eval&lt;/code&gt;, 需求只需要写表达式，服务解析表达示即可。Eval 库也是现成的 &lt;span&gt;govaluate&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 模板&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jinja2 就是这类的代表&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.563302752293578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9OBDxDDV6f01FFTBgpjIxuCCzU4fdExTQ1qyZqsKbibbkdXl65wlQJUFJFfDffs6WqoM7eEV2ACKG0NjDlA9H4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理非常简单，感兴趣的可以看官方实现&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Inject 代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要介绍两个项目 pingcap &lt;span&gt;failpoint&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 和 uber-go 的 gopatch&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.65390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9OBDxDDV6f01FFTBgpjIxuCCzU4fdExT4zC2RCQCkqYaoRoMRX1Wia8kMeUNU8aJml9pF8qlCDLVC2TuiageEWFg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;failpoint 实现很简单，代码里写 &lt;code&gt;Marker&lt;/code&gt; 函数，这些空函数在正常编译时会被编译器优化去掉，所以正常运行时 zero-cost&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; outerVar = &lt;span&gt;&quot;declare in outer scope&quot;&lt;/span&gt;&lt;br/&gt;failpoint.Inject(&lt;span&gt;&quot;failpoint-name-for-demo&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(val failpoint.Value)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;unit-test&quot;&lt;/span&gt;, val, outerVar)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故障注入时通过 failctl 将 &lt;code&gt;Marker&lt;/code&gt; 函数转换为故障注入函数，这里就用到了 go-ast 做劫持转换&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;uber-go 的 gopatch 也非常强大，假如你的代码有很多 &lt;code&gt;go func&lt;/code&gt; 开启的 goroutine, 你想批量加入 &lt;code&gt;recover&lt;/code&gt; 逻辑，如果数据特别多人工加很麻烦，这时可以用 gopatcher&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; patchTemplateString = &lt;span&gt;`@@&lt;br/&gt;@@&lt;br/&gt;+ import &quot;runtime/debug&quot;&lt;br/&gt;+ import &quot;{{ Logger }}&quot;&lt;br/&gt;+ import &quot;{{ Statsd }}&quot;&lt;br/&gt;&lt;br/&gt;go func(...) {&lt;br/&gt;+    defer func(){&lt;br/&gt;+        if err := recover(); err != nil {&lt;br/&gt;+            statsd.Count1(&quot;{{ StatsdTag }}&quot;, &quot;{{ FileName }}&quot;)&lt;br/&gt;+            logging.Error(&quot;{{ LoggerTag }}&quot;, &quot;{{ FileName }} recover from panic, err=%+v, stack=%v&quot;, err, string(debug.Stack()))&lt;br/&gt;+        }&lt;br/&gt;+    }()&lt;br/&gt;   ...&lt;br/&gt; }()&lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写模板，上面的例子自动在 &lt;code&gt;go func(...) {&lt;/code&gt; 开头注入 &lt;code&gt;recover&lt;/code&gt; 语句块，非常方便&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个库能做的事情特别多，感兴趣自行实验&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. linter&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分 linter 工具都是用 go ast 实现的，比如对于大写的 Public 函数，如果没有注释报错&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// BuildArgs write a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BuildArgs&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    a = a + bbb.c&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看下该代码的 ast 代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;29  .  .  1: *ast.FuncDecl {&lt;br/&gt;30  .  .  .  Doc: *ast.CommentGroup {&lt;br/&gt;31  .  .  .  .  List: []*ast.Comment (len = 1) {&lt;br/&gt;32  .  .  .  .  .  0: *ast.Comment {&lt;br/&gt;33  .  .  .  .  .  .  Slash: foo:7:1&lt;br/&gt;34  .  .  .  .  .  .  Text: &lt;span&gt;&quot;// BuildArgs write a&quot;&lt;/span&gt;&lt;br/&gt;35  .  .  .  .  .  }&lt;br/&gt;36  .  .  .  .  }&lt;br/&gt;37  .  .  .  }&lt;br/&gt;38  .  .  .  Recv: nil&lt;br/&gt;39  .  .  .  Name: *ast.Ident {&lt;br/&gt;40  .  .  .  .  NamePos: foo:8:6&lt;br/&gt;41  .  .  .  .  Name: &lt;span&gt;&quot;BuildArgs&quot;&lt;/span&gt;&lt;br/&gt;42  .  .  .  .  Obj: *ast.Object {&lt;br/&gt;43  .  .  .  .  .  Kind: func&lt;br/&gt;44  .  .  .  .  .  Name: &lt;span&gt;&quot;BuildArgs&quot;&lt;/span&gt;&lt;br/&gt;45  .  .  .  .  .  Decl: *(obj @ 29)&lt;br/&gt;46  .  .  .  .  .  Data: nil&lt;br/&gt;47  .  .  .  .  .  Type: nil&lt;br/&gt;48  .  .  .  .  }&lt;br/&gt;49  .  .  .  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;linter 只需要检查 &lt;code&gt;FuncDecl&lt;/code&gt; 的 Name 如果是可导出的，同时 &lt;code&gt;Doc.CommentGroup&lt;/code&gt; 不存在，或是注释不以函数名开头，报错即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外如果大家对代码 cycle 有要求，那么是不是可以 ast 扫一遍来发现呢？如果大家要求函数不能超过 100 行，是不是也可以实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;玩法很多 ^^&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译原理虽然难，但是搞业务的只需要前端知识即可，不用研究的太深，有需要的场景，知道 AST 如何解决问题就行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的分享就这些，写文章不容易，如果对大家有所帮助和启发，请大家帮忙点击&lt;code&gt;再看&lt;/code&gt;，&lt;code&gt;点赞&lt;/code&gt;，&lt;code&gt;分享&lt;/code&gt; 三连&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 &lt;code&gt;Go AST&lt;/code&gt; 大家有什么看法，欢迎留言一起讨论，大牛多留言 ^_^&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;go-cmp: &lt;em&gt;https://github.com/google/go-cmp,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;go ast: &lt;em&gt;https://pkg.go.dev/go/ast,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;goast-viewer 可视化界面: &lt;em&gt;https://yuroyoro.github.io/goast-viewer/index.html,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;go pongo2 jinja2: &lt;em&gt;github.com/flosch/pongo2,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;govaluate: &lt;em&gt;https://github.com/Knetic/govaluate,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;pingcap failpoint: &lt;em&gt;https://github.com/pingcap/failpoint,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a6a311170f38483bf6d284da04315dd4</guid>
<title>Golang本地缓存选型对比及原理总结</title>
<link>https://toutiao.io/k/0jakz0b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4psjPOibic6BZSicnBFh6uWzCFp3uqN5R114Fq85DmuCzdL3eESlQ37bFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;提到本地缓存大家都不陌生，只要是个有点经验的后台开发人员，都知道缓存的作用和弊端。本篇文章我们就来简单聊聊在golang做业务开发的过程中，本地缓存的一些可选的开源方案，分析它们的特点，以及内部的实现原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、本地缓存需求分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fc176b1e788c8c9af9d30f250205c2bd&quot;&gt;&lt;span&gt;首先来梳理一下业务开发过程中经常面临的本地缓存的一些需求。我们一般做&lt;/span&gt;&lt;span&gt;缓存就是为了能提高系统的读写性能&lt;/span&gt;&lt;span&gt;，缓&lt;/span&gt;&lt;span&gt;存的命中率越高，也就意味着缓存的效果越好&lt;/span&gt;&lt;span&gt;。其次本地缓存一般都受限于本地内存的大小，所有全量的数据一般存不下。那基于这样的场景一方面是想缓存的数据越多，则命中率理论上也会随着缓存数据的增多而提高；另外一方面是想，既然所有的数据存不下那就想办法利用有限的内存存储有限的数据。这些有限的数据需要是经常访问的，同时有一定时效性(不会频繁改变)的。基于这两个点展开，我们一般对本地缓存会要求其满 足支持过期时间、支持淘汰策略。最后再使用自动管理内存的语言例如golang等开发时，还需要考虑在加入本地缓存后引发的GC问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;b13a5699e7474be20a43c0832506c1ff&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;b13a5699e7474be20a43c0832506c1ff&quot;&gt;&lt;span&gt;分析完我们日常本地缓存的诉求，再结合我们日常开发用到的golang语言，我们可以提炼得到golang本地缓存组件必须具备以下几个能力：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96Ea0lvkice7wKKMQn8UgCybUibw2fgE0wDq8t7v3spCPr2YgFibLDcdK2hgTBMy1p1RHshQbRXgEunA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;7abd04b2af99817156ac807999525c36&quot;&gt;&lt;span&gt;分析清楚了我们的需求，也明确了我们需要的能力。那自然优先考虑golang内置的标准库中是否存在这样的组件可以直接使用呢？很遗憾，没有。golang中内置的可以直接用来做本地缓存的无非就是map和sync.Map。而这两者中，map是非并发安全的数据结构，在使用时需要加锁；而sync.Map虽然是线程安全的。但是需要在并发读写时加锁。此外二者均无法支持数据的过期和淘汰，同时在存储大量数据时，又会产生比较频繁的GC问题，更严重的情况下导致线上服务无法稳定运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e194e270efbcd3f4b7e65ba4b49fae85&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e194e270efbcd3f4b7e65ba4b49fae85&quot;&gt;&lt;span&gt;既然标准库中没有我们满足上述需求的本地缓存组件，那我们就想只有两种解决方案了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;d43503b75313967a42d2a5e9ef12cadb&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;d43503b75313967a42d2a5e9ef12cadb&quot;&gt;&lt;span&gt;那首先面临的第一个问题就是方案的调研和选型，没有合适的方案时自己再来动手构建。下面我们就来给大家介绍下golang中哪些可以直接来使用的本地缓存组件吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、golang本地缓存组件概览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;dc5b94e7a5e1602c74bc758c9953e1d5&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;37d3aa647eff69e20956e681b4f5d616&quot;&gt;&lt;span&gt;golang中本地缓存方案可选的有如下一些：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;0ba3aeb034981dce05ac8cee26ad827d&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;0ba3aeb034981dce05ac8cee26ad827d&quot;&gt;&lt;span&gt;下面通过笔者一段时间的调研和研究，将golang可选的开源本地缓存组件汇总为下表，方便大家在方案选型时作参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.509375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96Ea0lvkice7wKKMQn8UgCybKGjVYq9s7blXrkBXtWeQKiaAQEs37eYEveFavPic48YQ5xoaBL4PPc6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;08e57ec08e270d5fe2551a147a80b937&quot;&gt;&lt;span&gt;在上述方案中，freecache、bigcache、fastcache、ristretto、groupcache这几个大家根据实际的业务场景首选，offheap有定制需求时可考虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;0b8466081593a86f1c85c27fd9e60130&quot;&gt;&lt;span&gt;通过上表的总结，个人想再此再谈几点关于本地缓存组件的理解：&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;83436ed5ddd750ea867c0a106caefdb4&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;83436ed5ddd750ea867c0a106caefdb4&quot;&gt;&lt;span&gt;（一）上述本地缓存组件中，实现零GC的方案主要就两种&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;83436ed5ddd750ea867c0a106caefdb4&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ce8ba7704f006af54e33e36d61bb4fd4&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;45382bba3c40bc0d4eef0be27eae875f&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e519087e7f65acb93cce23e882658696&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e519087e7f65acb93cce23e882658696&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;e519087e7f65acb93cce23e882658696&quot;&gt;&lt;span&gt;（二）实现高性能的关键&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;17ce80ecb7dfc2e34f804135e625f290&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;17ce80ecb7dfc2e34f804135e625f290&quot;&gt;&lt;span&gt;数据分片(降低锁的粒度)&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;05a8a9dfdfc6634bb480832f3b176c86&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;05a8a9dfdfc6634bb480832f3b176c86&quot;&gt;&lt;span&gt;上述几种缓存组件每种组件的实现都是（一）和（二）的几个分支的组合。下面我们大概给大家介绍每种组件的核心原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、主流缓存组件实现原理剖析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8342c0d15a1fadd6c24e2d7d7e1ce0c2&quot;&gt;&lt;span&gt;在本节中我们会重点分析下freecache、bigcache、fastcache、offheap这几个组件内部的实现原理。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;3779d22e4c36308a96ef0cd290a73f63&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;3779d22e4c36308a96ef0cd290a73f63&quot;&gt;&lt;span&gt;（一）freecache实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;96a454b41c72e652d4e283700011a649&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;96a454b41c72e652d4e283700011a649&quot;&gt;&lt;span&gt;首先分析下freecache的内部实现原理。在freecache中它通过segment来进行对数据分片，freecache内部包含256个segment，每个segment维护一把互斥锁，每一条kv数据进来后首先会根据k进行计算其hash值，然后根据hash值决定当前的这条数据落入到哪个segment中。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a5989805b05fab9c65f00e49dfc2c641&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a5989805b05fab9c65f00e49dfc2c641&quot;&gt;&lt;span&gt;对于每个segment而言，它由索引、数据两部分构成。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;0bc2514dbb21b0964171003302270987&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;0bc2514dbb21b0964171003302270987&quot;&gt;&lt;span&gt;索引&lt;/span&gt;&lt;span&gt;：其中索引最简单的方式采用map来维护，例如map[uint64]uint32这种。而freecache并没有采用这种做法，而是通过采用slice来底层实现一套无指针的map，以此避免GC扫描。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;b9e25aec4f45ad57601af1592a80b838&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;b9e25aec4f45ad57601af1592a80b838&quot;&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;：数据采用环形缓冲区来循环使用，底层采用[]byte进行封装实现。数据写入环形缓冲区后，记录写入的位置index作为索引，读取时首先读取数据header信息，然后再读取kv数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;1aad1d1412f60144dad2edc06336023d&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;1aad1d1412f60144dad2edc06336023d&quot;&gt;&lt;span&gt;在freecache中数据的传递过程是：freecache-&amp;gt;segment-&amp;gt;(slot，ringbuffer) 下图是freecache的内部实现框架图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96Ea0lvkice7wKKMQn8UgCyblUGNy2vOVfe8P4tlVOoe5KLvrKlYTpgFM6qic83Eich7l3LpUczicZxIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6e1ac14910fc4630cb58a002493672b8&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt;：freecache通过利用数据分片减小锁的粒度，然后再存储时索引并没有采用内置的map来维护而是采用自建map减少指针来避免GC，同时数据存储时采用预先分配内存然后后边循环使用。通过上述两种方法保证了在堆上分配内存同时减少GC对系统性能的影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6e1ac14910fc4630cb58a002493672b8&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6e1ac14910fc4630cb58a002493672b8&quot;&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;efba603afd6eec1bcc820cbbd11bd325&quot;&gt;&lt;span&gt;（二）bigcache实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;7995fe1b1333a090f8480b1322317722&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;7995fe1b1333a090f8480b1322317722&quot;&gt;&lt;span&gt;bigcache和freecache类似，也是一个零GC、高性能的cache组件，但是它的实现和freecache还是有些差异，有篇&lt;/span&gt;&lt;span&gt;英文博客&lt;/span&gt;&lt;span&gt;（https://blog.allegro.tech/2016/03/writing-fast-cache-service-in-go.html）&lt;/span&gt;&lt;span&gt;介绍bigcache设计原理的，内容稍长感兴趣的可以阅读下，下面我们介绍一下bigcache的实现原理。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;81cacf823cd53d566aafbe2fe377b0d9&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;81cacf823cd53d566aafbe2fe377b0d9&quot;&gt;&lt;span&gt;bigcache同样是采用分片的方式构成，一个bigcache对象包含2^n个cacheShard对象，默认是1024个。每个cacheShard对象维护着一把sync.RWLock锁(读写锁)。所有的数据会分散到不同的cacheShard中。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;64acdc4ae2a0bf9cd23127190cf1d7a2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;64acdc4ae2a0bf9cd23127190cf1d7a2&quot;&gt;&lt;span&gt;每个cacheShard同样由索引和数据构成。索引采用map[uint64]uint32来存储，数据采用entry([]byte)环形队列存储。索引中存储的是该条数据在entryBuffer写入的位置pos。每条kv数据按照TLV的格式写入队列。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c678846faad46a0a088c1c7915a0f694&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;c678846faad46a0a088c1c7915a0f694&quot;&gt;&lt;span&gt;不过值得注意的是，和bigcache和freecache不同的一点在于它的环形队列可以自动扩容。同时bigcache中数据的过期是通过全局的时间窗口维护的，每个单独的kv无法设置不同的过期时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8add312177cf339ee5074773501d872f&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8add312177cf339ee5074773501d872f&quot;&gt;&lt;span&gt;下面是bigcache的内容实现原理框架图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96Ea0lvkice7wKKMQn8UgCybb8ibfOjSNI1ibhu4ygPp1d6QZ31l4yzWsxQKw7RFl7yyD7HCw2HscmZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;1eb1f3c752b6a29fee40e2b40a1a2269&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt;：bigcache思路和freecache大体相同，只不过在索引存储时更为巧妙，直接采用内置的map结构加上基础数据类型来实现。同时底层存储数据的队列也可以根据空间大小来决定是否扩容。唯一的缺陷是无法针对每个key进行设置不同的过期时间。这个个人认为如果想用bigcache同时想要这个特性，可以进行二次开发一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;784d65c7566368a65384a3ee616cb276&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;784d65c7566368a65384a3ee616cb276&quot;&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;性能测试数据&lt;/span&gt;&lt;span&gt;（https://github.com/allegro/bigcache-bench）&lt;/span&gt;&lt;span&gt;来看，bigcache性能要比freecache稍微好一点。大家可以思考下他们性能的差异可能会在哪里呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;fb04b40df55314e0fc24a90d02f2cc65&quot;&gt;&lt;span&gt;（三）fastcache实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;ed686a0ee2ea98e7cc6239b84721a897&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;ed686a0ee2ea98e7cc6239b84721a897&quot;&gt;&lt;span&gt;本节介绍下fastcache的实现原理，根据fastcache官方文档介绍，它的灵感来自于bigcache。所以整体的思路和bigcache很类似，数据通过bucket进行分片。fastcache由512个bucket构成。每个bucket维护一把读写锁。在bucket内部数据同理是索引、数据两部分构成。索引用map[uint64]uint64存储。数据采用chunks二维的切片(二维数组)存储。不过值得注意的是fastcache有一个很大的特性是，它的内存分配是在堆外分配的，而不是在堆上分配的。堆外分配的内存。这样做也就避免了golang GC的影响。下图是fastcache内部实现框架图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.56171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96Ea0lvkice7wKKMQn8UgCyb4tchV9YCtZfaEt6lf7rg0E6yKsJP0M22tM4gEY5R8oaicibTwMhx3Afg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6c137d1f37ec956f74d3aa063bfbf8d6&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt;：fastcache一方面充分利用了分片来降低锁的粒度，另一方面在索引存储时采用了对map的优化，同时在分配内存时，直接从堆外申请内存，自己实现了分配和释放内存的逻辑。通过上述手段使得GC的影响降到了最低。fastcache唯一的缺陷是官方提供的版本没有提供针对kv数据的过期时间这个特性。所以如果需要这个特性的话，需要自己动手二次开发。整体从性能上来看是比bigcache和freecache都更优。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;a3492df1bb06648bc1f852b1a24fd1a2&quot;&gt;&lt;span&gt;（四）offheap实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;36bd70d70495a36613b87330392d6135&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;36bd70d70495a36613b87330392d6135&quot;&gt;&lt;span&gt;本节介绍下offheap的相关内容，offheap其实功能就比较简单了，就是一个基于堆外内存构建的哈希表。它通过直接调用系统调用函数来分配内存。然后在内部通过数组来实现哈希表。实现过程中当发生哈希冲突时，它是采用探测法来解决。由于是在堆外分配的内存上构建的哈希表。导致它的GC开销非常的小。下图是offheap的内部实现框架图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.665625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96Ea0lvkice7wKKMQn8UgCybMAlPILdI7icnOIKZQDeEPrlrLnVicaJ3fxLiaJUbuxlzXwJlfVZ4yibWOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;7c11d6cb507118fdb8029f214753c4b4&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt;：offheap内部由于是采用探测法解决哈希冲突的，所以当哈希冲突严重时数据删除、查询都会带来非常复杂的处理流程。而且性能也会有一些损耗。可以作为学习和研究的项目还是非常不错的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;73d1864181e6db56d8b7269a77202ffc&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;90aa1ee57d97b2b1e7c5efeadf74f333&quot;&gt;&lt;span&gt;本文主要从日常需求出发，分析了日常业务过程中对本地缓存的需求，再调研了业界可选的一些组件并进行了对比，希望对本地缓存选型上起到一些参考和帮助。最后再对其中比较重要的几个组件如freecache、bigcache、fastcache、offheap等做了内部实现的简单介绍。上述内容只是从架构层面展开介绍，后续有时间再从源码层面做一些分析。由于篇幅限制本篇内容并未对map、sync.Map、go-cache、groupcache进行介绍。感兴趣的读者可以自行搜索资料进行阅读。如果大致理解了上述原理的童鞋也可以自己动手实践起来，造个轮子看看。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;90aa1ee57d97b2b1e7c5efeadf74f333&quot;&gt;&lt;/p&gt;&lt;h1 data-lines=&quot;1&quot; data-sign=&quot;381759e8570981ca8c2525ac43ac6e29&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/h1&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;dff82711a4d247732b97d4a892564a8c&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;1.Writing a very fast cache service with millions of entries in Go&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.深入理解Freecache&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.如何打造高性能的Go缓存库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.freecache和bigcache性能测试数据对比&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1.0198511166253101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96Ea0lvkice7wKKMQn8UgCybU19kGz5Yhxkef0c52o6HeDEbfM3MibYRO5ojictKkgUVTUYibxZsAjnicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;403&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;文小飞&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Cloud9项目组后台开发工程师，3年后台开发经验，熟悉推荐系统后台工作；对网络、存储、分布式共识算法(raft)等技术比较感兴趣。目前在PCG Cloud9项目组，主要负责后台核心模块研发工作。个人微信公众号：毛里求斯的爱。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247535846&amp;amp;idx=1&amp;amp;sn=60598abb377b94b95fac71b21e839586&amp;amp;chksm=eaa856b6dddfdfa0e1167701d230692cdbca6830cdad8476e939652e0c520db93db42679a106&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;图文并茂！推荐算法架构——粗排&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;图文并茂！推荐算法架构——粗排&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247535827&amp;amp;idx=1&amp;amp;sn=18464a7c3008e698738ee42e2eb6216e&amp;amp;chksm=eaa85683dddfdf9556550a021207d4a9301d121e9c83ca47d5d8a479ba8b0ee93b809dca0ac3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;第四届 Techo TVP 开发者峰会回来了！这次我们线上见&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;第四届 Techo TVP 开发者峰会回来了！这次我们线上见&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247535783&amp;amp;idx=1&amp;amp;sn=e9736107bfb467fedb5cbcd4bcfa6f01&amp;amp;chksm=eaa856f7dddfdfe1cba3fa86754926632aaabf63870cd129ff3dbf11385199f4413bf9fe4240&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;来了！Go的2个黑魔法技巧&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;来了！Go的2个黑魔法技巧&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247535713&amp;amp;idx=1&amp;amp;sn=a37218245c7f62e2a12cb72fa6d86d25&amp;amp;chksm=eaa85631dddfdf27006a788a4101efcbab827be8ef986785a1dd91561e434e39f4859ab77bc1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka 3.0新特性全面曝光，真香！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Kafka 3.0新特性全面曝光，真香！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96FK2eEg86vUicOR3n6kAHk1PHvTb8VBicYk0RmNQYsQyibgg8iaZqT0bCEU9VKo3Z3iceoQfgycyMpKWQ/0?wx_fmt=png&quot; data-nickname=&quot;云加社区&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4xV7ckfbmtFLyUjFID2k7yO4q8hvB4OqYoNkARZ2xuvzKvMtnmVN2BQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b039abdd80acf9ad00022a7974cf7518</guid>
<title>想活得更久？「程序员延寿指南」已开源，收好！</title>
<link>https://toutiao.io/k/xvjb20a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660216765&amp;amp;idx=2&amp;amp;sn=3297f27c0bc85c7da3f6ed416b194afc&amp;amp;chksm=84bbadecb3cc24fa09b2f49a4279b1c2aeef351715deaa4d5456a205affeb92d4ce5e59b4a06&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibHVJLA1Veb2tAXpnl02QjBcWiaSWj9vUVqq42f2lQNOicxEyUB86OwrE3YovoAQTWY9eMNzz74SttQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660216765&amp;amp;idx=2&amp;amp;sn=3297f27c0bc85c7da3f6ed416b194afc&amp;amp;chksm=84bbadecb3cc24fa09b2f49a4279b1c2aeef351715deaa4d5456a205affeb92d4ce5e59b4a06&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;选对圈子，一切都‍对了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;选对圈子，一切都对了！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GitHub 上真是啥都有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想活得更久？这份「程序员延寿指南」收好！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;术语&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关键结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;降低66.67%全因死亡率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;增加~20年预期寿命&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;维持多巴胺于中轴&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主要参考：对ACM的学术文献相对较多，可以作为主要参考&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;增加寿命与ACM关系非线性：显然增加寿命与ACM关系是非线性函数，这里假设 DeltaLifeSpan=(1/(1-ACM)-1)*10&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;变量无法简单叠加：显然各个变量之间并不符合独立同分布假设，变量之间的实际影响也并不明确&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;存在矛盾观点：所有的证据都有文献/研究对应，但注意到：有些文献之间有显著矛盾的观点（如对于碳水摄入比例的矛盾）；有些文献存在较大争议（如认为22点前睡觉会提升43%全因死亡率）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;研究仅表达相关：所有文献表明的更多是相关而非因果，在阅读时要考虑文献是否充分证明了因果 —— 如某文献表明了日均&amp;gt;=7000步的人有显著低的全因死亡率。但步数少的人可能包含更多长期病患，如果没有合理的排除这块数据，那此文献调查失真&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;行动&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;固体：吃白肉（-3%~-11% ACM）、蔬果为主（-17%~-26% ACM），多吃辣（-23% ACM），多吃坚果（-4%~-27% ACM），少吃蛋黄（否则+7% ACM/0.5颗/天），中量碳水、多吃植物蛋白（-10% ACM）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;液体：喝咖啡（-12%~-22% ACM），喝牛奶（-10%~-17% ACM），喝茶（-8%~15% ACM），少喝或不喝甜味饮料（否则每天一杯+7% ACM，+多巴胺），戒酒或每周100g（纯酒精量(g)=饮酒量(ml)×酒精浓度(%)×酒精密度0.8g/ml）内（否则+~50% ACM，无上限）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;气体：不吸烟（否则+~50% ACM，-11~-12年寿命）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;光照：晒太阳（-~40% ACM）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;药物：二甲双胍（糖尿病人相比正常人可以+3年）、复合维生素（-8%癌症风险）、亚精胺（-30%~-60% ACM）、葡萄糖胺（-39% ACM）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下文&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;GitHub &lt;/span&gt;&lt;span&gt;地址：&lt;/span&gt;&lt;span&gt;https://github.com/geekan/HowToLiveLonger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;成为「码农周刊VIP会员」，做更好的开发者！&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;318&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6F3uclDbSh5Wo7uh5ubSztrWSpyiccyad8PsxCYRDflRhWklWl0tw96zrIeHlOlvaiatmgObzuSmnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>913a19baef56ef2680e01a7f716ba2d0</guid>
<title>今晚发车，别说我没提醒你哦～</title>
<link>https://toutiao.io/k/n6kc8vf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;提个醒！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;第 089 期「码农周刊 VIP 会员专属邮件周报」，将于本周五晚发送。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;想邮件订阅周报？点此即刻订阅！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;255&quot; data-backw=&quot;453&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibxN2ZVP72EwkSLibibWpkyHxyJ9h3jlN45cDia9gELfqK5QibDhPb4YXaryX2SQkhlwnwKlyHTuEc6Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;码农周刊是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;span&gt;码农周刊VIP会员&lt;/span&gt;」服务。&lt;br/&gt;&lt;strong&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何加入「码农周刊VIP会员」？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;47&quot; data-cropselx2=&quot;438&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;527&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8VtEoYeI2aW2FrTZROXlicl84Pu8zqAqakWxWxVB1rUnmuc1ic5UdESLxvcQfRTHQDe3rFq5H02F4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快订阅吧！&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>87b70eef31b2cb90cd95891c1aeccef9</guid>
<title>Linux下跨语言调用C++实践</title>
<link>https://toutiao.io/k/umur1kx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第504&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第021篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;93&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.9966329966329966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVLR21NicmyQxcmiaqQ2KOJJj2JLwgJL4KSbo7CcuMF1hLf4xFjGQiaDRhSPyERxWGChWYP47Oc4sKGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;不同的开发语言适合不同的领域，例如Python适合做数据分析，C++适合做系统的底层开发，假如它们需要用到相同功能的基础组件，组件使用多种语言分别开发的话，不仅增加了开发和维护成本，而且不能确保多种语言间在处理效果上是一致的。本文以美团搜索实际场景下的案例，讲述在Linux系统下跨语言调用的实践，即开发一次C++语言的组件，其他语言通过跨语言调用技术调用C++组件。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1 背景介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2 方案概述&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3 实现详情&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 功能代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 打包发布&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 业务使用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 易用性优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 原理介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.1 为什么需要一个c_wrapper&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.2 跨语言调用如何实现参数传递&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.3 扩展阅读（JNA直接映射）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.4 性能分析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5 应用案例&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6 总结&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 背景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;查询理解（&lt;/span&gt;&lt;span&gt;QU, Query Understanding&lt;/span&gt;&lt;span&gt;）是美团搜索的核心模块，主要职责是理解用户查询，生成查询意图、成分、改写等基础信号，应用于搜索的召回、排序、展示等多个环节，对搜索基础体验至关重要。该服务的线上主体程序基于C++语言开发，服务中会加载大量的词表数据、预估模型等，这些数据与模型的离线生产过程有很多文本解析能力需要与线上服务保持一致，从而保证效果层面的一致性，如文本归一化、分词等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而这些离线生产过程通常用Python与Java实现。如果在线、离线用不同语言各自开发一份，则很难维持策略与效果上的统一。同时这些能力会有不断的迭代，在这种动态场景下，不断维护多语言版本的效果打平，给我们的日常迭代带来了极大的成本。因此，我们尝试通过跨语言调用动态链接库的技术解决这个问题，即开发一次基于C++的so，通过不同语言的链接层封装成不同语言的组件库，并投入到对应的生产过程。这种方案的优势非常明显，主体的业务逻辑只需要开发一次，封装层只需要极少量的代码，主体业务迭代升级，其它语言几乎不需要改动，只需要包含最新的动态链接库，发布最新版本即可。同时C++作为更底层的语言，在很多场景下，它的计算效率更高，硬件资源利用率更高，也为我们带来了一些性能上的优势。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文对我们在实际生产中尝试这一技术方案时，遇到的问题与一些实践经验做了完整的梳理，希望能为大家提供一些参考或帮助。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 方案概述&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;310&quot; data-ratio=&quot;0.5358649789029536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7icEdm9KuDfAp3iaVXGnaKW58I9ibQZ7LQ2C9v1gZayCOawaphgOB1LiawQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 1&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 实现详情&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Python、Java支持调用C接口，但不支持调用C++接口，因此对于C++语言实现的接口，必须转换为C语言实现。为了不修改原始C++代码，在C++接口上层用C语言进行一次封装，这部分代码通常被称为“胶水代码”(&lt;/span&gt;&lt;span&gt;Glue Code&lt;/span&gt;&lt;span&gt;)。具体方案如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;501&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;401&quot; data-ratio=&quot;0.8003992015968064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7wSxeETdIwW7tSSLMhe34rhw9iaH4D5069k4BB41XDIwuRaTcrRJibPZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;501&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本章节各部分内容如下：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【功能代码】部分，通过打印字符串的例子来讲述各语言部分的编码工作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【打包发布】部分，介绍如何将生成的动态库作为资源文件与Python、Java代码打包在一起发布到仓库，以降低使用方的接入成本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【业务使用】部分，介绍开箱即用的使用示例。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【易用性优化】部分，结合实际使用中遇到的问题，讲述了对于Python版本兼容，以及动态库依赖问题的处理方式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 功能代码&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 C++代码&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;作为示例，实现一个打印字符串的功能。为了模拟实际的工业场景，对以下代码进行编译，分别生成动态库 libstr_print_cpp.so、静态库libstr_print_cpp.a。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;str_print.h&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt;pragma&lt;/span&gt; once&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StrPrint&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;amp; text)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;};&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;str_print.cpp&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;str_print.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;StrPrint::print&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;amp; text)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; text &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 c_wrapper代码&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;如上文所述，需要对C++库进行封装，改造成对外提供C语言格式的接口。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;c_wrapper.cpp&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;#include &quot;str_print.h&quot;&lt;/span&gt;&lt;br/&gt;extern &lt;span&gt;&quot;C&quot;&lt;/span&gt; {&lt;br/&gt;void str_print(const char* text) {&lt;br/&gt;    StrPrint cpp_ins;&lt;br/&gt;    std::string str = text;&lt;br/&gt;    cpp_ins.print(str);&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.3 生成动态库&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;为了支持Python与Java的跨语言调用，我们需要对封装好的接口生成动态库，生成动态库的方式有以下三种。&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;方式一&lt;/strong&gt;：源码依赖方式，将c_wrapper和C++代码一起编译生成libstr_print.so。这种方式业务方只需要依赖一个so，使用成本较小，但是需要获取到C++源码。对于一些现成的动态库，可能不适用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;g++ -o libstr_print.so str_print.cpp c_wrapper.cpp -fPIC -shared&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;方式二&lt;/strong&gt;：动态链接方式，这种方式生成的libstr_print.so，发布时需要携带上其依赖库libstr_print_cpp.so。业务方需要同时依赖两个so，使用的成本相对要高，但是不必提供原动态库的源码。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;g++ -o libstr_print.so c_wrapper.cpp -fPIC -shared -L. -lstr_print_cpp&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;方式三&lt;/strong&gt;：静态链接方式，这种方式生成的libstr_print.so，发布时无需携带上libstr_print_cpp.so。业务方只需依赖一个so，不必依赖源码，但是需要提供静态库。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;g++ c_wrapper.cpp libstr_print_cpp.a -fPIC -shared -o libstr_print.so&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上述三种方式，各自有适用场景和优缺点。在我们本次的业务场景下，因为工具库与封装库均由我们自己开发，能够获取到源码，因此选择第一种方式，业务方依赖更加简单。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.4 Python接入代码&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Python标准库自带的ctypes可以实现加载C的动态库的功能，使用方法如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;str_print.py&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ctypes&lt;br/&gt;&lt;span&gt;# 加载 C lib&lt;/span&gt;&lt;br/&gt;lib = ctypes.cdll.LoadLibrary(&lt;span&gt;&quot;./libstr_print.so&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 接口参数类型映射&lt;/span&gt;&lt;br/&gt;lib.str_print.argtypes = [ctypes.c_char_p]&lt;br/&gt;lib.str_print.restype = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 调用接口&lt;/span&gt;&lt;br/&gt;lib.str_print(&lt;span&gt;&#x27;Hello World&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;LoadLibrary会返回一个指向动态库的实例，通过它可以在Python里直接调用该库中的函数。argtypes与restype是动态库中函数的参数属性，前者是一个ctypes类型的列表或元组，用于指定动态库中函数接口的参数类型，后者是函数的返回类型（&lt;/span&gt;&lt;span&gt;默认是c_int，可以不指定，对于非c_int型需要显示指定&lt;/span&gt;&lt;span&gt;）。该部分涉及到的参数类型映射，以及如何向函数中传递struct、指针等高级类型，可以参考附录中的文档。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.5 Java接入代码&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Java调用C lib有JNI与JNA两种方式，从使用便捷性来看，更推荐JNA方式。&lt;/span&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.5.1 JNI接入&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;Java从1.1版本开始支持JNI接口协议，用于实现Java语言调用C/C++动态库。JNI方式下，前文提到的c_wrapper模块不再适用，JNI协议本身提供了适配层的接口定义，需要按照这个定义进行实现。JNI方式的具体接入步骤为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java代码里，在需要跨语言调用的方法上，增加native关键字，用以声明这是一个本地方法。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; java.lang.String;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JniDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;通过javah命令，将代码中的native方法生成对应的C语言的头文件。这个头文件类似于前文提到的c_wrapper作用。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;javah JniDemo&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;得到的头文件如下（&lt;/span&gt;&lt;span&gt;为节省篇幅，这里简化了一些注释和宏&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;#include &amp;lt;jni.h&amp;gt;&lt;br/&gt;#ifdef __cplusplus&lt;br/&gt;extern &lt;span&gt;&quot;C&quot;&lt;/span&gt; {&lt;br/&gt;#&lt;span&gt;endif&lt;br/&gt;JNIEXPORT &lt;span&gt;void&lt;/span&gt; JNICALL &lt;span&gt;Java_JniDemo_print&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;(JNIEnv *, jobject, jstring)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;#ifdef __cplusplus&lt;br/&gt;}&lt;br/&gt;#endif&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;jni.h在JDK中提供，其中定义了Java与C语言调用所必需的相关实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;JNIEXPORT和JNICALL是JNI中定义的两个宏，JNIEXPORT标识了支持在外部程序代码中调用该动态库中的方法，JNICALL定义了函数调用时参数的入栈出栈约定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;Java_JniDemo_print是一个自动生成的函数名，它的格式是固定，由Java_{className}_{methodName}构成，JNI会按照这个约定去注册Java方法与C函数的映射。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;三个参数里，前两个是固定的。JNIEnv中封装了jni.h里的一些工具方法，jobject指向Java中的调用类，即JniDemo，通过它可以找到Java里class中的成员变量在C的堆栈中的拷贝。jstring指向传入参数text，这是对于Java中String类型的一个映射。有关类型映射的具体内容，会在后文详细展开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;编写实现Java_JniDemo_print方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JniDemo.cpp&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;JniDemo.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;str_print.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT &lt;span&gt;void&lt;/span&gt; JNICALL &lt;span&gt;Java_JniDemo_print&lt;/span&gt; &lt;span&gt;(JNIEnv *env, jobject obj, jstring text)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* str=(&lt;span&gt;char&lt;/span&gt;*)env-&amp;gt;GetStringUTFChars(text,JNI_FALSE);&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; tmp = str;&lt;br/&gt;    StrPrint ins;&lt;br/&gt;    ins.print(tmp);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;编译生成动态库。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;g++ -o libJniDemo.so JniDemo.cpp str_print.cpp -fPIC -shared -I&amp;lt;&lt;span&gt;$JAVA_HOME&lt;/span&gt;&amp;gt;/include/ -I&amp;lt;&lt;span&gt;$JAVA_HOME&lt;/span&gt;&amp;gt;/include/linux&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;编译运行。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;java -Djava.library.path=&amp;lt;path_to_libJniDemo.so&amp;gt; JniDemo&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;JNI机制通过一层C/C++的桥接，实现了跨语言调用协议。这一功能在Android系统中一些图形计算相关的Java程序下有着大量应用。一方面能够通过Java调用大量操作系统底层库，极大的减少了JDK上的驱动开发的工作量，另一方面能够更充分的利用硬件性能。但是通过3.1.5.1中的描述也可以看到，JNI的实现方式本身的实现成本还是比较高的。尤其桥接层的C/C++代码的编写，在处理复杂类型的参数传递时，开发成本较大。为了优化这个过程，Sun公司主导了JNA(&lt;/span&gt;&lt;span&gt;Java Native Access&lt;/span&gt;&lt;span&gt;)开源工程的工作。&lt;/span&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.5.2 JNA接入&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;JNA是在JNI基础上实现的编程框架，它提供了C语言动态转发器，实现了Java类型到C类型的自动转换。因此，Java开发人员只要在一个Java接口中描述目标native library的函数与结构，不再需要编写任何Native/JNI代码，极大的降低了Java调用本地共享库的开发难度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JNA的使用方法如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在Java项目中引入JNA库。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.sun.jna&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jna&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.4.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;声明与动态库对应的Java接口类。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CLibrary&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Library&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;str_print&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 方法名和动态库接口一致，参数类型需要用Java里的类型表示，执行时会做类型映射，原理介绍章节会有详细解释&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;加载动态链接库，并实现接口方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JnaDemo.java&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;package&lt;/span&gt; com.jna.demo;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.sun.jna.Library;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.sun.jna.Native;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JnaDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CLibrary cLibrary;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CLibrary&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Library&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;str_print&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;JnaDemo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        cLibrary = Native.load(&lt;span&gt;&quot;str_print&quot;&lt;/span&gt;, CLibrary&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;str_print&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt;&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        cLibrary.str_print(text);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;对比可以发现，相比于JNI，JNA不再需要指定native关键字，不再需要生成JNI部分C代码，也不再需要显示的做参数类型转化，极大地提高了调用动态库的效率。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 打包发布&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;为了做到开箱即用，我们将动态库与对应语言代码打包在一起，并自动准备好对应依赖环境。这样使用方只需要安装对应的库，并引入到工程中，就可以直接开始调用。这里需要解释的是，我们没有将so发布到运行机器上，而是将其和接口代码一并发布至代码仓库，原因是我们所开发的工具代码可能被不同业务、不同背景（&lt;/span&gt;&lt;span&gt;非C++&lt;/span&gt;&lt;span&gt;）团队使用，不能保证各个业务方团队都使用统一的、标准化的运行环境，无法做到so的统一发布、更新。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.1 Python 包发布&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Python可以通过setuptools将工具库打包，发布至pypi公共仓库中。具体操作方法如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;创建目录。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  .&lt;br/&gt;  ├── MANIFEST.in            &lt;span&gt;#指定静态依赖&lt;/span&gt;&lt;br/&gt;  ├── setup.py               &lt;span&gt;# 发布配置的代码&lt;/span&gt;&lt;br/&gt;  └── strprint               &lt;span&gt;# 工具库的源码目录&lt;/span&gt;&lt;br/&gt;      ├── __init__.py        &lt;span&gt;# 工具包的入口&lt;/span&gt;&lt;br/&gt;      └── libstr_print.so    &lt;span&gt;# 依赖的c_wrapper 动态库&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;编写__init__.py， 将上文代码封装成方法。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  &lt;span&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; ctypes&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; os&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;  dirname, _ = os.path.split(os.path.abspath(__file__))&lt;br/&gt;  lib = ctypes.cdll.LoadLibrary(dirname + &lt;span&gt;&quot;/libstr_print.so&quot;&lt;/span&gt;)&lt;br/&gt;  lib.str_print.argtypes = [ctypes.c_char_p]&lt;br/&gt;  lib.str_print.restype = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;str_print&lt;/span&gt;&lt;span&gt;(text)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;      lib.str_print(text)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;编写setup.py。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  &lt;span&gt;from&lt;/span&gt; setuptools &lt;span&gt;import&lt;/span&gt; setup, find_packages&lt;br/&gt;  setup(&lt;br/&gt;      name=&lt;span&gt;&quot;strprint&quot;&lt;/span&gt;,&lt;br/&gt;      version=&lt;span&gt;&quot;1.0.0&quot;&lt;/span&gt;,&lt;br/&gt;      packages=find_packages(),&lt;br/&gt;      include_package_data=&lt;span&gt;True&lt;/span&gt;,&lt;br/&gt;      description=&lt;span&gt;&#x27;str print&#x27;&lt;/span&gt;,&lt;br/&gt;      author=&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;,&lt;br/&gt;      package_data={&lt;br/&gt;          &lt;span&gt;&#x27;strprint&#x27;&lt;/span&gt;: [&lt;span&gt;&#x27;*.so&#x27;&lt;/span&gt;]&lt;br/&gt;      },&lt;br/&gt;  )&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;编写MANIFEST.in。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;include strprint/libstr_print.so&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;打包发布。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;python setup.py sdist upload&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.2 Java接口&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;对于Java接口，将其打包成JAR包，并发布至Maven仓库中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;编写封装接口代码JnaDemo.java。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  &lt;span&gt;package&lt;/span&gt; com.jna.demo;&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; com.sun.jna.Library;&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; com.sun.jna.Native;&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; com.sun.jna.Pointer;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JnaDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;private&lt;/span&gt; CLibrary cLibrary;&lt;br/&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CLibrary&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Library&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;Pointer &lt;span&gt;create&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;str_print&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; JnaDemo &lt;span&gt;create&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          JnaDemo jnademo = &lt;span&gt;new&lt;/span&gt; JnaDemo();&lt;br/&gt;          jnademo.cLibrary = Native.load(&lt;span&gt;&quot;str_print&quot;&lt;/span&gt;, CLibrary&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;//System.out.println(&quot;test&quot;);&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; jnademo;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(String text)&lt;/span&gt;&lt;br/&gt;      &lt;/span&gt;{&lt;br/&gt;          cLibrary.str_print(text);&lt;br/&gt;      }&lt;br/&gt;  }&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;创建resources目录，并将依赖的动态库放到该目录。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过打包插件，将依赖的库一并打包到JAR包中。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-assembly-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;appendAssemblyId&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;span&gt;appendAssemblyId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;descriptorRefs&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;descriptorRef&lt;/span&gt;&amp;gt;&lt;/span&gt;jar-with-dependencies&lt;span&gt;&amp;lt;/&lt;span&gt;descriptorRef&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;descriptorRefs&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;make-assembly&lt;span&gt;&amp;lt;/&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;package&lt;span&gt;&amp;lt;/&lt;span&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;assembly&lt;span&gt;&amp;lt;/&lt;span&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 业务使用&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1 Python使用&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;安装strprint包。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  pip install strprint==1.0.0&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;使用示例：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  &lt;span&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;  &lt;span&gt;from&lt;/span&gt; strprint &lt;span&gt;import&lt;/span&gt; *&lt;br/&gt;  str_print(&lt;span&gt;&#x27;Hello py&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2 Java使用&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;pom引入JAR包。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  &amp;lt;dependency&amp;gt;&lt;br/&gt;      &amp;lt;groupId&amp;gt;com.jna.demo&amp;lt;/groupId&amp;gt;&lt;br/&gt;      &amp;lt;artifactId&amp;gt;jnademo&amp;lt;/artifactId&amp;gt;&lt;br/&gt;      &amp;lt;version&amp;gt;&lt;span&gt;1.0&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;  &amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;使用示例：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;  JnaDemo jnademo = &lt;span&gt;new&lt;/span&gt; JnaDemo();&lt;br/&gt;  jnademo.str_print(&lt;span&gt;&quot;hello jna&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 易用性优化&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.1 Python版本兼容&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Python2与Python3版本的问题，是Python开发用户一直诟病的槽点。因为工具面向不同的业务团队，我们没有办法强制要求使用统一的Python版本，但是我们可以通过对工具库做一下简单处理，实现两个版本的兼容。Python版本兼容里，需要注意两方面的问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Python代码的封装里，基本不牵扯语法兼容问题，我们的工作主要集中在数据编码问题上。由于Python 3的str类型使用的是unicode编码，而在C中，我们需要的char* 是utf8编码，因此需要对于传入的字符串做utf8编码处理，对于C语言返回的字符串，做utf8转换成unicode的解码处理。于是对于上例子，我们做了如下改造：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ctypes&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; os&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;dirname, _ = os.path.split(os.path.abspath(__file__))&lt;br/&gt;lib = ctypes.cdll.LoadLibrary(dirname + &lt;span&gt;&quot;/libstr_print.so&quot;&lt;/span&gt;)&lt;br/&gt;lib.str_print.argtypes = [ctypes.c_char_p]&lt;br/&gt;lib.str_print.restype = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;is_python3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; sys.version_info[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;encode_str&lt;/span&gt;&lt;span&gt;(input)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; is_python3() &lt;span&gt;and&lt;/span&gt; type(input) &lt;span&gt;is&lt;/span&gt; str:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bytes(input, encoding=&lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; input&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;decode_str&lt;/span&gt;&lt;span&gt;(input)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; is_python3() &lt;span&gt;and&lt;/span&gt; type(input) &lt;span&gt;is&lt;/span&gt; bytes:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; input.decode(&lt;span&gt;&#x27;utf8&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; input&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;str_print&lt;/span&gt;&lt;span&gt;(text)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    lib.str_print(encode_str(text))&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.2 依赖管理&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在很多情况下，我们调用的动态库，会依赖其它动态库，比如当我们依赖的gcc/g++版本与运行环境上的不一致时，时常会遇到&lt;/span&gt;&lt;code&gt;&lt;span&gt;glibc_X.XX not found&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的问题，这时需要我们提供指定版本的&lt;/span&gt;&lt;code&gt;&lt;span&gt;libstdc.so&lt;/span&gt;&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;&lt;span&gt;libstdc++.so.6&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了实现开箱即用的目标，在依赖并不复杂的情况下，我们会将这些依赖也一并打包到发布包里，随工具包一起提供。对于这些间接依赖，在封装的代码里，并不需要显式的load，因为Python与Java的实现里，加载动态库，最终调用的都是系统函数dlopen。这个函数在加载目标动态库时，会自动的加载它的间接依赖。所以我们所需要做的，就只是将这些依赖放置到dlopen能够查找到路径下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dlopen查找依赖的顺序如下：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从dlopen调用方ELF&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Executable and Linkable Format&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;的DT_RPATH所指定的目录下寻找，ELF是so的文件格式，这里的DT_RPATH是写在动态库文件的，常规手段下，我们无法修改这个部分。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从环境变量LD_LIBRARY_PATH所指定的目录下寻找，这是最常用的指定动态库路径的方式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从dlopen调用方ELF的DT_RUNPATH所指定的目录下寻找，同样是在so文件中指定的路径。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从/etc/ld.so.cache寻找，需要修改/etc/ld.so.conf文件构建的目标缓存，因为需要root权限，所以在实际生产中，一般很少修改。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从/lib寻找， 系统目录，一般存放系统依赖的动态库。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从/usr/lib寻找，通过root安装的动态库，同样因为需要root权限，生产中，很少使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;从上述查找顺序中可以看出，对于依赖管理的最好方式，是通过指定LD_LIBRARY_PATH变量的方式，使其包含我们的工具包中的动态库资源所在的路径。另外，对于Java程序而言，我们也可以通过指定java.library.path运行参数的方式来指定动态库的位置。Java程序会将java.library.path与动态库文件名拼接到一起作为绝对路径传递给dlopen，其加载顺序排在上述顺序之前。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，在Java中还有一个细节需要注意，我们发布的工具包是以JAR包形式提供，JAR包本质上是一个压缩包，在Java程序中，我们能够直接通过Native.load()方法，直接加载位于项目resources目录里的so，这些资源文件打包后，会被放到JAR包中的根目录。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是dlopen无法加载这个目录。对于这一问题，最好的方案可以参考【3.1.3生成动态库】一节中的打包方法，将依赖的动态库合成一个so，这样无须做任何环境配置，开箱即用。但是对于诸如libstdc++.so.6等无法打包在一个so的中系统库，更为通用的做法是，在服务初始化时将so文件从JAR包中拷贝至本地某个目录，并指定LD_LIBRARY_PATH包含该目录。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 原理介绍&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 为什么需要一个c_wrapper&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。为了保证签名唯一，C++通过name mangling机制为相同名字不同实现的函数生成不同的签名，生成的签名会是一个像__Z4funcPN4printE这样的字符串，无法被dlsym识别（&lt;/span&gt;&lt;span&gt;注：Linux系统下可执行程序或者动态库多是以ELF格式组织二进制数据，其中所有的非静态函数(non-static)以“符号(symbol)”作为唯一标识，用于在链接过程和执行过程中区分不同的函数，并在执行时映射到具体的指令地址，这个“符号”我们通常称之为函数签名&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了解决这个问题，我们需要通过extern &quot;C&quot; 指定函数使用C的签名方式进行编译。因此当依赖的动态库是C++库时，需要通过一个c_wrapper模块作为桥接。而对于依赖库是C语言编译的动态库时，则不需要这个模块，可以直接调用。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 跨语言调用如何实现参数传递&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;C/C++函数调用的标准过程如下：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在内存的栈空间中为被调函数分配一个栈帧，用来存放被调函数的形参、局部变量和返回地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将实参的值复制给相应的形参变量（&lt;/span&gt;&lt;span&gt;可以是指针、引用、值拷贝&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;控制流转移到被调函数的起始位置，并执行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;控制流返回到函数调用点，并将返回值给到调用方，同时栈帧释放。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;由以上过程可知，函数调用涉及内存的申请释放、实参到形参的拷贝等，Python/Java这种基于虚拟机运行的程序，在其虚拟机内部也同样遵守上述过程，但涉及到调用非原生语言实现的动态库程序时，调用过程是怎样的呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于Python/Java的调用过程基本一致，我们以Java的调用过程为例来进行解释，对于Python的调用过程不再赘述。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.1 内存管理&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在Java的世界里，内存由JVM统一进行管理，JVM的内存由栈区、堆区、方法区构成，在较为详细的资料中，还会提到native heap与native stack，其实这个问题，我们不从JVM的角度去看，而是从操作系统层面出发来理解会更为简单直观。以Linux系统下为例，首先JVM名义上是一个虚拟机，但是其本质就是跑在操作系统上的一个进程，因此这个进程的内存会存在如下左图所示划分。而JVM的内存管理实质上是在进程的堆上进行重新划分，自己又“虚拟”出Java世界里的堆栈。如右图所示，native的栈区就是JVM进程的栈区，进程的堆区一部分用于JVM进行管理，剩余的则可以给native方法进行分配使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;123&quot; data-ratio=&quot;0.21343537414965985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7wDmd3mRKyefN4mXUH08HYUjAuJtsicOHiaibFZaPiamAcXibu25XGU8zVMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.2 调用过程&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;前文提到，native方法调用前，需要将其所在的动态库加载到内存中，这个过程是利用Linux的dlopen实现的，JVM会把动态库中的代码片段放到Native Code区域，同时会在JVM Bytecode区域保存一份native方法名与其所在Native Code里的内存地址映射。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一次native方法的调用步骤，大致分为四步：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从JVM Bytecode获取native方法的地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;准备方法所需的参数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;切换到native栈中，执行native方法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;native方法出栈后，切换回JVM方法，JVM将结果拷贝至JVM的栈或堆中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;602&quot; data-ratio=&quot;1.0413105413105412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7Efq11gxvOOibuAMvwJp9ndUQ3K11viafp4mhRS0vta6a4m5xMyGkxTEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由上述步骤可以看出，native方法的调用同样涉及参数的拷贝，并且其拷贝是建立在JVM堆栈和原生堆栈之间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于原生数据类型，参数是通过值拷贝方式与native方法地址一起入栈。而对于复杂数据类型，则需要一套协议，将Java中的object映射到C/C++中能识别的数据字节。原因是JVM与C语言中的内存排布差异较大，不能直接内存拷贝，这些差异主要包括：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;类型长度不同，比如char在Java里为16字节，在C里面却是8个字节。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JVM与操作系统的字节顺序（&lt;/span&gt;&lt;span&gt;Big Endian还是Little Endian&lt;/span&gt;&lt;span&gt;）可能不一致。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JVM的对象中，会包含一些meta信息，而C里的struct则只是基础类型的并列排布，同样Java中没有指针，也需要进行封装和映射。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;435&quot; data-ratio=&quot;0.7967032967032966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7gzDQRHIJbJEWfDWReC7AwSpxq2dzvkKP5NpyqTCgib7z0QQ4MHMIicgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;546&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图展示了native方法调用过程中参数传递的过程，其中映射拷贝在JNI中是由C/C++链接部分的胶水代码实现，类型的映射定义在jni.h中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java基本类型与C基本类型的映射（&lt;/span&gt;&lt;span&gt;通过值传递。将Java对象在JVM内存里的值拷贝至栈帧的形参位置&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;   jboolean;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; short  jchar;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; short           jshort;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;           jfloat;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;          jdouble;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; jint            jsize;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;Java复杂类型与C复杂类型的映射（&lt;/span&gt;&lt;span&gt;通过指针传递。首先根据基本类型一一映射，将组装好的新对象的地址拷贝至栈帧的形参位置&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;typedef&lt;/span&gt; _jobject *jobject;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; _jclass *jclass;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; _jthrowable *jthrowable;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; _jstring *jstring;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; _jarray *jarray;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;注&lt;/strong&gt;：在Java中，非原生类型均是Object的派生类，多个object的数组本身也是一个object，每个object的类型是一个class，同时class本身也是一个object。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;jobject&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;jclass&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; _jobject {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;jthrowable&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; _jobject {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;jarray&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; _jobject {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;jcharArray&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; _jarray {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;jobjectArray&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; _jarray {};&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;jni.h 中配套提供了内存拷贝和读取的工具类，比如前面例子中的&lt;/span&gt;&lt;code&gt;&lt;span&gt;GetStringUTFChars&lt;/span&gt;&lt;/code&gt;&lt;span&gt;能够将JVM中的字符串中的文本内容，按照utf8编码的格式，拷贝到native heap中，并将char*指针传递给native方法使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整个调用过程，产生的内存拷贝，Java中的对象由JVM的GC进行清理，Native Heap中的对象如果是由 JNI框架分配生成的，如上文JNI示例中的参数，均由框架进行统一释放。而在C/C++中新分配的对象，则需要用户代码在C/C++中手动释放。简而言之，Native Heap中与普通的C/C++进程一致，没有GC机制的存在，并且遵循着谁分配谁释放的内存治理原则。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 扩展阅读（JNA直接映射）&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;相比于JNI，JNA使用了其函数调用的基础框架，其中的内存映射部分，由JNA工具库中的工具类自动化的完成类型映射和内存拷贝的大部分工作，从而避免大量胶水代码的编写，使用上更为友好，但相应的这部分工作则产生了一些性能上的损耗。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JNA还额外提供了一种“直接映射”(&lt;/span&gt;&lt;span&gt;DirectMapping&lt;/span&gt;&lt;span&gt;)的调用方式来弥补这一不足。但是直接映射对于参数有着较为严格的限制，只能传递原生类型、对应数组以及Native引用类型，并且不支持不定参数，方法返回类型只能是原生类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;直接映射的Java代码中需要增加native关键字，这与JNI的写法一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DirectMapping示例&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; com.sun.jna.*;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JnaDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;cos&lt;/span&gt;&lt;span&gt;(DoubleByReference x)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        Native.register(Platform.C_LIBRARY_NAME);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(cos(&lt;span&gt;new&lt;/span&gt; DoubleByReference(&lt;span&gt;1.0&lt;/span&gt;)));&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;DoubleByReference即是双精度浮点数的Native引用类型的实现，它的JNA源码定义如下（&lt;/span&gt;&lt;span&gt;仅截取相关代码&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;//DoubleByReference&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DoubleByReference&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ByReference&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DoubleByReference&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;        setValue(value);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ByReference&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ByReference&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;PointerType&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;ByReference&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; dataSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        setPointer(&lt;span&gt;new&lt;/span&gt; Memory(dataSize));&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;Memory类型是Java版的shared_ptr实现，它通过引用引数的方式，封装了内存分配、引用、释放的相关细节。这种类型的数据内存实际上是分配在native的堆中，Java代码中，只能拿到指向该内存的引用。JNA在构造Memory对象的时候通过调用malloc在堆中分配新内存，并记录指向该内存的指针。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在ByReference的对象释放时，调用free，释放该内存。JNA的源码中ByReference基类的finalize 方法会在GC时调用，此时会去释放对应申请的内存。因此在JNA的实现中，动态库中的分配的内存由动态库的代码管理，JNA框架分配的内存由JNA中的代码显示释放，但是其触发时机，则是靠JVM中的GC机制释放JNA对象时来触发运行。这与前文提到的Native Heap中不存在GC机制，遵循谁分配谁释放的原则是一致的。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;finalize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    dispose();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** Free the native memory and set peer to zero */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dispose&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (peer == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// someone called dispose before, the finalizer will call dispose again&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        free(peer);&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        peer = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// no null check here, tracking is only null for SharedMemory&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// SharedMemory is overriding the dispose method&lt;/span&gt;&lt;br/&gt;        reference.unlink();&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 性能分析&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;提高运算效率是Native调用中的一个重要目的，但是经过上述分析也不难发现，在一次跨语言本地化的调用过程中，仍然有大量的跨语言工作需要完成，这些过程也需要支出对应的算力。因此并不是所有Native调用，都能提高运算效率。为此我们需要理解语言间的性能差异在哪儿，以及跨语言调用需要耗费多大的算力支出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;语言间的性能差异主要体现在三个方面：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Python与Java语言都是解释执行类语言，在运行时期，需要先把脚本或字节码翻译成二进制机器指令，再交给CPU进行执行。而C/C++编译执行类语言，则是直接编译为机器指令执行。尽管有JIT等运行时优化机制，但也只能一定程度上缩小这一差距。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上层语言有较多操作，本身就是通过跨语言调用的方式由操作系统底层实现，这一部分显然不如直接调用的效率高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Python与Java语言的内存管理机制引入了垃圾回收机制，用于简化内存管理，GC工作在运行时，会占用一定的系统开销。这一部分效率差异，通常以运行时毛刺的形态出现，即对平均运行时长影响不明显，但是对个别时刻的运行效率造成较大影响。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;而跨语言调用的开销，主要包括三部分：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于JNA这种由动态代理实现的跨语言调用，在调用过程中存在堆栈切换、代理路由等工作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;寻址与构造本地方法栈，即将Java中native方法对应到动态库中的函数地址，并构造调用现场的工作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内存映射，尤其存在大量数据从JVM Heap向Native Heap 进行拷贝时，这部分的开销是跨语言调用的主要耗时所在。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;我们通过如下实验简单做了一下性能对比，我们分别用C语言、Java、JNI、JNA以及JNA直接映射五种方式，分别进行100万次到1000万次的余弦计算，得到耗时对比。在6核16G机器，我们得到如下结果：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6894639556377079&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz71kUMJd5AErTXkibrRS6T02ia3PZbjrBLLoTicbRDSiau0nZYF39VOpVN8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;348&quot; data-ratio=&quot;0.6019690576652602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7VMvtlhAZMM50qp48NxFZQsv0ic9ibCB26lwvq7P8SQWpsvjibBHAPYtZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;346&quot; data-ratio=&quot;0.59875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7djHOfQysvlLz1bZ8GnwmqvWfBtGGDebmyn0BQbWH8xtZNvQ1a28aPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 7&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由实验数据可知，运行效率依次是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;C &amp;gt; Java &amp;gt; JNI &amp;gt; JNA DirectMapping &amp;gt; JNA&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。C语言高于Java的效率，但两者非常接近。JNI与JNA DirectMapping的方式性能基本一致，但是会比原生语言的实现要慢很多。普通模式下的JNA的速度最慢，会比JNI慢5到6倍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上所述，跨语言本地化调用，并不总是能够提升计算性能，需要综合计算任务的复杂度和跨语言调用的耗时进行综合权衡。我们目前总结到的适合跨语言调用的场景有：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;离线数据分析&lt;/strong&gt;：离线任务可能会涉及到多种语言开发，且对耗时不敏感，核心点在于多语言下的效果打平，跨语言调用可以节省多语言版本的开发成本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;跨语言RPC调用转换为跨语言本地化调用&lt;/strong&gt;：对于计算耗时是微秒级以及更小的量级的计算请求，如果通过RPC调用来获得结果，用于网络传输的时间至少是毫秒级，远大于计算开销。在依赖简单的情况下，转化为本地化调用，将大幅缩减单请求的处理时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于一些复杂的模型计算，Python/Java跨语言调用C++可以提升计算效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5 应用案例&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;如上文所述，通过本地化调用的方案能够在性能和开发成本上带来一些收益。我们将这些技术在离线任务计算与实时服务调用做了一些尝试，并取得了比较理想的结果。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 离线任务中的应用&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;搜索业务中会有大量的词表挖掘、数据处理、索引构建等离线计算任务。这个过程会用到较多查询理解里的文本处理和识别能力，如分词、名命体识别等。因为开发语言的差异，将这些能力在本地重新开发一遍，成本上无法接受。因此之前的任务中，在离线计算过程中会通过RPC方式调用线上服务。这个方案带来如下问题：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;离线计算任务的量级通常较大，执行过程中请求比较密集，会占用占用线上资源，影响线上用户请求，安全性较低。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单次RPC的耗时至少是毫秒级，而实际的计算时间往往非常短，因此大部分时间实际上浪费在了网络通信上，严重影响任务的执行效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;RPC服务因为网络抖动等因为，调用成功率不能达到100%，影响任务执行效果。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;离线任务需引入RPC调用相关代码，在Python脚本等轻量级计算任务里，这部分的代码往往因为一些基础组件的不完善，导致接入成本较高。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;371&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;181&quot; data-ratio=&quot;0.48787061994609165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7ALVpOf3L7hibmwp6GFJjNcmcwf0zNticZX5k8iaBibnYLKfUyNZictBPAjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 8&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将RPC调用改造为跨语言本地化调用后，上述问题得以解决，收益明显。&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不再调用线上服务，流量隔离，对线上安全不产生影响。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于1000万条以上的离线任务，累计节省至少10小时以上的网络开销时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消除网络抖动导致的请求失败问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过上述章节的工作，提供了开箱即用的本地化工具，极大的简化了使用成本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;183&quot; data-ratio=&quot;0.3153759820426487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7d37IeFdY5KD6jqZujInaKzwBCyeCfz4Kq84icPFEk2F0nrKZFDibicM4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;图 9&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 在线服务中的应用&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;查询理解作为美团内部的基础服务平台，提供分词词性、查询纠错、查询改写、地标识别、异地识别、意图识别、实体识别、实体链接等文本分析，是一个较大的CPU密集型服务，承接了公司内非常多的本文分析业务场景，其中有部分场景只是需要个别信号，甚至只需要查询理解服务中的基础函数组件，对于大部分是通过Java开发的业务服务，无法直接引用查询理解的C++动态库，此前一般是通过RPC调用获取结果。通过上述工作，在非C++语言的调用方服务中，可以将RPC调用转化为跨语言本地化调用，能够明显的提升调用端的性能以及成功率，同时也能有效减少服务端的资源开销。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;174&quot; data-ratio=&quot;0.3021223470661673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUZwgCRT3IibKB8g48hV0Fz7XhbibP37oiaFkhHZdZMm77thx3DNKPsjUNPPqlfWx1xHX4aPEbKWnlIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 10&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6 总结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;微服务等技术的发展使得服务创建、发布和接入变得越来越简单，但是在实际工业生产中，并非所有场景都适合通过RPC服务完成计算。尤其在计算密集型和耗时敏感型的业务场景下，当性能成为瓶颈时，远程调用带来的网络开销就成了业务不可承受之痛。本文对语言本地化调用的技术进行了总结，并给出一些实践经验，希望能为大家解决类似的问题提供一些帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然，本次工作中还有许多不足，例如因为实际生产环境的要求，我们的工作基本都集中在Linux系统下，如果是以开放库形式，让使用方可以自由使用的话，可能还需要考虑兼容Windows下的DLL，Mac OS下的dylib等等。本文可能还存在其他不足之处，欢迎大家指留言指正、探讨。&lt;br/&gt;&lt;br/&gt;本文例子的源代码请访问：&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/linyang02/python_java_on_cpp&quot; textvalue=&quot;GitHub&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;GitHub&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7 参考文献&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8 本文作者&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;林阳、朱超、识瀚，均来自美团平台/搜索与NLP部/搜索技术部。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;美团搜索与NLP部/NLP中心是负责美团人工智能技术研发的核心团队，使命是打造世界一流的自然语言处理核心技术和服务能力，依托NLP（&lt;/span&gt;&lt;span&gt;自然语言处理&lt;/span&gt;&lt;span&gt;）、Deep Learning（&lt;/span&gt;&lt;span&gt;深度学习&lt;/span&gt;&lt;span&gt;）、Knowledge Graph（&lt;/span&gt;&lt;span&gt;知识图谱&lt;/span&gt;&lt;span&gt;）等技术，处理美团海量文本数据，为美团各项业务提供智能的文本语义理解服务。NLP中心长期招聘自然语言处理算法专家/机器学习算法专家，感兴趣的同学可以将简历发送至：&lt;/span&gt;&lt;span&gt;tech@meituan.com&lt;/span&gt;&lt;span&gt;（邮件主题：美团搜索与NLP部）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753676&amp;amp;idx=1&amp;amp;sn=b5f75addee662172daac802f075f217d&amp;amp;chksm=bd1255818a65dc979db9da570664f16826f1b52c76d48f4aa0e6b0e21d31ad9e51fac8a03d86&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基本功 | Java即时编译器原理解析及实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753676&amp;amp;idx=1&amp;amp;sn=b5f75addee662172daac802f075f217d&amp;amp;chksm=bd1255818a65dc979db9da570664f16826f1b52c76d48f4aa0e6b0e21d31ad9e51fac8a03d86&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基本功 | Java即时编译器原理解析及实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基本功 | Java即时编译器原理解析及实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651767029&amp;amp;idx=1&amp;amp;sn=a22cec4736c5ff7f8e8f15117954c7d3&amp;amp;chksm=bd1219b88a6590aeb25d81bf3d4efeb2e0d2e735457817a9b46af1d2c115f7df0894fdc87fc8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java系列 | 远程热部署在美团的落地实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Java系列 | 远程热部署在美团的落地实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651755958&amp;amp;idx=1&amp;amp;sn=214edb1f692725be9408c5b4dbb78b70&amp;amp;chksm=bd124cfb8a65c5edbcb731f07cc7f02df931c6d34950c68cde2d96354ac1496d8dd243d7dc50&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;C++服务编译耗时优化原理及实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;C++服务编译耗时优化原理及实践&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>