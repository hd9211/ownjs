<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f51b8bfcd26e79563274022b552b94ea</guid>
<title>五一没地方去？来这里吧！</title>
<link>https://toutiao.io/k/m70wnkv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08ef86ecde4a6fd4f549105e553ad41f</guid>
<title>connection reset案例的穿越之旅</title>
<link>https://toutiao.io/k/ut7lfeg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;事情要从周五晚上说起，好学的朋友在群里问我有没有能够通过框架和项目能对IO有深入学习的。我当时正照例刷着电影解说，感受着逻辑的力量。等看到消息时，已经看到其他朋友热心得给出了神回复：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.1855072463768117&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGTaubp7Qa2MF1eKicSv7RP7GDcgaRG5qETZpPscvGactrIBIzP8kpKYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在我进行了仔细阅读之后，断线一秒钟，之后由衷感叹自己技术不精，没有弄懂问题和回答之间的逻辑关系。于是给出了自己的回复：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通信框架都需要IO知识，服务治理框架、redis和mysql等存储中间件、MQ都有很强的关联。但是一般很少有很强的动力研究的很深。我个人而言，排查生产问题会引出大量想学习的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后群里简短的介绍了一个案例：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A与B是两个公司的两个服务，A要调用B服务，他们之间可谓万水千山：&lt;/p&gt;&lt;p&gt;A---服务器--F5--交换机1--交换机2--F5--SSL（透传）--F5--交换机--山石防火墙--H3C交换机--思科路由器---专线--网联思科路由器--H3C交换机--思科防火墙--思科交换机--H3C交换机--思科防火墙--F5-SSL-服务器--F5--交换机1--交换机2--F5--SSL--F5--交换机--山石防火墙--H3C交换机--思科路由器---专线--网联思科路由器--H3C交换机--思科防火墙--思科交换机--H3C交换机--思科防火墙--F5--SSL（非透传）--B&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们简化一下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A请求B，B正常返回结果，但是A反馈收不到。后来B抓包发现在请求还在进行read数据时就收到了connection reset，连接断开。但是并非每笔请求都是如此。而是A有小于30%的概率收不到。而B对接的其他公司却都正常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在排查日志时发现B收到的请求分成两种，一种是A可以正常收到的，连接是长连接，一种是A不能正常收到的，连接是短连接。但是长连接还是短连接并不是不能正常返回数据的理由。因为数据是分段传输的，每段之间可以灵活采用自己的连接方式，就像传信时，第一段是采用飞鸽传书，第二段是快递员拿到信用快马送到驿站交到仆人手中，第三段是仆人一路小跑将信递交到我手中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我猛然一惊，这不是穿越剧，而是技术文章。所以放弃长短连接，看看还没有别的线索，终于发现A不能收到的与能收到的相比http header的 X-Forwarded-For 参数中都多出了2个值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;X-Forwarded-For（XFF）是用来识别通过 HTTP 代理或负载均衡方式连接到 Web 服务器的客户端最原始的 IP 地址的 HTTP 请求头字段。在传输过程中，每一个驿站都有可能通过这个字段打上自己的标记。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;将 XFF 的值拿给专业人士验证，竟然有人在B服务前面的万水千山之上又加了一座秦岭。更准确的说是加了30%个秦岭。B服务前被加上了一层nginx，且已经灰度了30%的流量。这就对应了有接近30%的请求有问题。也解释了为什么会有短连接，因为nginx在默认不设置时采用短连接。但是还不能解释为什么只有A有问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在nginx的日志中发现了lua异常，对于一个lua完全不懂的人果断向百事通大师谷歌求助。但谷歌大师是西域来的，据说见他要翻墙。翻墙不是体力好就更翻得了的，要付费。看着手上唯一个「顺治通宝」，正犹豫之时，又听人说咱们有个国产美人「度娘」在情报方面也很厉害，甚至慢慢在赶超谷歌大师。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我连忙前去请教，得到答复：lua脚本一旦抛出异常，就会中断处理。这就解释了为什么会发生connection reset。nginx抛出异常中断了与上层SSL客户端的连接。SSL又作为服务端感知到了异常，主动发connection reset中断了自己与上层的连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种异常场景最好能复现，但是不懂lua怎么复现，这次咱们要来个大手笔，找到真正的大师求助。于是问题上报到了「编程一生」用户交流群，立即得到了lua可以在线调试的重要线索，问题得到复现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27830451756832125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGKEibndNIk5XlRNyogriaSpy5hNOedyOkaHtr6MzZzLVKHVpGu3qicjLicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1793&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原来处理请求和响应的lua脚本，里面打印日志时for循环遍历请求和响应的数组，遍历时认为每一项都是一个字符串，A应用在传输过程中，将http header的 XFF 变成了一个数组，lua中数组(table)不能直接强转为字符串，被判断为异常触发reset。这也解释了为什么只有A有问题，因为只有他在传输过程中将原本的字符串转成了数组。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在nginx日志还有一个支线线索是：access日志中显示请求结果是200(正常返回结果)，但是响应的 &lt;span&gt;Content-Length 为0 ！就是说响应为空。看到上面我们可以知道B返回了信息给nginx，nginx异常导致被处理后的响应丢失。出现这个问题的实际不是A一个，还有另外一家。本身B服务请求量很小，没有报出来也很正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从规律上来说：我怀疑可能是commons-httpclient-3.1-rc1版本以下会采用这种策略，因为从请求日志头中看到出现问题的只有两个httpclient版本过来的请求，另外一个是commons-httpclient-3.0-rc3 版本。这里再顺便介绍一下apache各个类型的版本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Alpha：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Alpha是内部测试版，表示最初的版本，一般不向外部发布。Alpha版会有很多Bug，除非你想去测试最新的功能，否则一般不建议使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Beta：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该版本相对于Alpha版已有了很大的改进，消除了严重的错误，但还是存在着一缺陷，需要经过多次测试来进一步消除。这个阶段的版本会一直加入新的功能。`&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;RC：(Release Candidate)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Candidate是候选人的意思，用在软件上就是候选版本。Release.Candidate.就是发行候选版本。和Beta版最大的差别在于Beta阶段会一直加入新的功能，但是到了RC版本，几乎就不会加入新的功能了，而主要着重于除错! RC版本是最终发放给用户的最接近正式版的版本，发行后改正bug就是正式版了，就是正式版之前的最后一个测试版。`&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;GA：（general availability）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如：Apache Struts 2 GA这是Apache Struts 2首次发行稳定的版本，GA意味着General Availability，也就是官方开始推荐广泛使用了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Release:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从案例来看，用过老的或者不用稳定版本，当了别人的小白鼠，可以获得很多技术精进的机会。因为你会踩很多其他开发者没有踩过的坑。同时还可以获得头发护理的永久免费：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGFP8FXQRwM4qynL7kRayhWZupgKODdicgy3cgVWKMC4qRKnpfU8xaEJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后澄清一下，文章是原创，但是作者不是我，是咱们。有事群里常交流，你们说我来听~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6595460614152203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ibYmZwVq4fSlc6gonEZpJGibx3PNYHFs1LxQ06iagH3wUrLv8be66fPl5HcicQHeKNaYjhgR94YPUdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;749&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;编程一生&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想知道自己错过了哪些更新，可参考我不定期更新的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487380&amp;amp;idx=2&amp;amp;sn=4e71d679e2c22f9c5af4ea3abc667b76&amp;amp;chksm=fafde53acd8a6c2c9d2fb5eb83de5e5a2e3f244a57fa275394d9d61a0cdfa154290fe7a21fe8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系列文章分类汇总&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;em&gt;&lt;strong&gt;系列文章分类汇总&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>afd95957d2416c9b3af84aefe35ca446</guid>
<title>干掉 BeanUtils！这款 Bean 自动映射神器出 Spring 插件了！</title>
<link>https://toutiao.io/k/zrz0j1r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;之前安利过&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&amp;amp;mid=2247494988&amp;amp;idx=1&amp;amp;sn=d5c1f888ce670ff5197c6a00cd63f966&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Mapstruct&lt;/a&gt; 这个神器，它可以代替&lt;code&gt;BeanUtil&lt;/code&gt;来进行&lt;strong&gt;DTO&lt;/strong&gt;、&lt;strong&gt;VO&lt;/strong&gt;、&lt;strong&gt;PO&lt;/strong&gt;之间的转换。它使用的是Java编译期的  annotation processor 机制，说白了它就是一个代码生成器，代替你手工进行类型转换期间的取值赋值操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前很多项目都使用了它，代码清爽得很，增加了大量摸鱼时间，用过的都说好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Mapper&lt;/span&gt;(componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;AreaMapping&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;List&amp;lt;AreaInfoListVO&amp;gt; &lt;span&gt;toVos&lt;/span&gt;&lt;span&gt;(List&amp;lt;Area&amp;gt; areas)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这么几行就把一个&lt;strong&gt;PO&lt;/strong&gt;的集合转换成了对应&lt;strong&gt;VO&lt;/strong&gt;的集合。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// spring bean &lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;AreaMapping areaMapping&lt;br/&gt;    &lt;br/&gt;&lt;span&gt;// 转换源 areas    &lt;/span&gt;&lt;br/&gt;List&amp;lt;Area&amp;gt; areas = ……;&lt;br/&gt;&lt;span&gt;// 转换目标 vos &lt;/span&gt;&lt;br/&gt;List&amp;lt;AreaInfoListVO&amp;gt; vos = areaMapping.toVos(areas)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换成你手写试试，起码得五分之一炷香的功夫。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样写还是不太爽，每次都要挂对应的Mapper类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Converter&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring framework&lt;/strong&gt;提供了一个&lt;code&gt;Converter&amp;lt;S,T&amp;gt;&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;S&lt;/span&gt;, &lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Nullable&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;T &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(S source)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt; &amp;lt;U&amp;gt; &lt;span&gt;Converter&amp;lt;S, U&amp;gt; &lt;span&gt;andThen&lt;/span&gt;&lt;span&gt;(Converter&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, ? extends U&amp;gt; after)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Assert.notNull(after, &lt;span&gt;&quot;After Converter must not be null&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (s) -&amp;gt; {&lt;br/&gt;            T initialResult = &lt;span&gt;this&lt;/span&gt;.convert(s);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; initialResult != &lt;span&gt;null&lt;/span&gt; ? after.convert(initialResult) : &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        };&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的作用是将&lt;code&gt;S&lt;/code&gt;转换为&lt;code&gt;T&lt;/code&gt;，这和&lt;strong&gt;Mapstruct&lt;/strong&gt;的作用不谋而合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Converter&lt;/code&gt;会通过&lt;code&gt;ConverterRegistry&lt;/code&gt;这个注册接口注册到&lt;code&gt;ConversionService&lt;/code&gt;，然后你就可以通过&lt;code&gt;ConversionService&lt;/code&gt;的&lt;code&gt;convert&lt;/code&gt;方法来进行转换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(@Nullable Object source, Class&amp;lt;T&amp;gt; targetType)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MapStruct Spring Extensions&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上面的机制官方推出了&lt;strong&gt;MapStruct Spring Extensions&lt;/strong&gt;插件， 它实现了一种机制，所有的&lt;strong&gt;Mapstruct&lt;/strong&gt;映射接口(&lt;strong&gt;Mapper&lt;/strong&gt;)只要实现了&lt;code&gt;Converter&lt;/code&gt;，都会自动注册到&lt;code&gt;ConversionService&lt;/code&gt;，我们只需要通过&lt;code&gt;ConversionService&lt;/code&gt;就能完成任何转换操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; felord.cn&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt; 1.0.0&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Mapper&lt;/span&gt;(componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CarMapper&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;Car&lt;/span&gt;, &lt;span&gt;CarDto&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping&lt;/span&gt;(target = &lt;span&gt;&quot;seats&quot;&lt;/span&gt;, source = &lt;span&gt;&quot;seatConfiguration&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;CarDto &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(Car car)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用时：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; ConversionService conversionService;&lt;br/&gt;&lt;br/&gt;Car car = ……;&lt;br/&gt;CarDto carDto = conversionService.convert(car,CarDto&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MapStruct Spring Extensions&lt;/strong&gt; 会自动生成一个适配类处理&lt;strong&gt;Mapper&lt;/strong&gt;注册：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; org.mapstruct.extensions.spring.converter;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; cn.felord.mapstruct.entity.Car;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; cn.felord.mapstruct.entity.CarDto;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.context.annotation.Lazy;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.core.convert.ConversionService;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Component;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; felord.cn&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt; 1.0.0&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConversionServiceAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConversionService conversionService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ConversionServiceAdapter&lt;/span&gt;&lt;span&gt;(@Lazy &lt;span&gt;final&lt;/span&gt; ConversionService conversionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.conversionService = conversionService;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CarDto &lt;span&gt;mapCarToCarDto&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Car source)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (CarDto)&lt;span&gt;this&lt;/span&gt;.conversionService.convert(source, CarDto&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自定义&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自定义适配类的包路径和名称&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，生成的适配类将位于包&lt;code&gt;org.mapstruct.extensions.spring.converter&lt;/code&gt;中，名称固定为&lt;code&gt;ConversionServiceAdapter&lt;/code&gt;。如果你希望修改包路径或者名称，你可以这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; cn.felord.mapstruct.config;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.mapstruct.MapperConfig;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.mapstruct.extensions.spring.SpringMapperConfig;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; felord.cn&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt; 1.0.0&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@MapperConfig&lt;/span&gt;(componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@SpringMapperConfig&lt;/span&gt;(conversionServiceAdapterPackage = &lt;span&gt;&quot;cn.felord.mapstruct.config&quot;&lt;/span&gt;,&lt;br/&gt;        conversionServiceAdapterClassName = &lt;span&gt;&quot;MapStructConversionServiceAdapter&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MapperSpringConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不指定&lt;code&gt;conversionServiceAdapterPackage&lt;/code&gt;元素，生成的 Adapter 类将与注解的 Config 驻留在同一个包中，所以上面的路径是可以省略的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;指定ConversionService&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的&lt;strong&gt;Spring IoC&lt;/strong&gt;容器中有多个&lt;code&gt;ConversionService&lt;/code&gt;，你可以通过&lt;code&gt;@SpringMapperConfig&lt;/code&gt;注解的&lt;code&gt;conversionServiceBeanName&lt;/code&gt;参数指定。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; cn.felord.mapstruct.config;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.mapstruct.MapperConfig;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.mapstruct.extensions.spring.SpringMapperConfig;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; felord.cn&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt; 1.0.0&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@MapperConfig&lt;/span&gt;(componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@SpringMapperConfig&lt;/span&gt;(conversionServiceAdapterPackage = &lt;span&gt;&quot;cn.felord.mapstruct.config&quot;&lt;/span&gt;,&lt;br/&gt;        conversionServiceAdapterClassName = &lt;span&gt;&quot;MapStructConversionServiceAdapter&quot;&lt;/span&gt;,&lt;br/&gt;                   conversionServiceBeanName = &lt;span&gt;&quot;myConversionService&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MapperSpringConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;集成Spring的内置转换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring&lt;/strong&gt;内部提供了很多好用的&lt;code&gt;Converter&amp;lt;S,T&amp;gt;&lt;/code&gt;实现，有的并不直接开放，如果你想用&lt;strong&gt;Mapstruct&lt;/strong&gt;的机制使用它们，可以通过&lt;code&gt;@SpringMapperConfig&lt;/code&gt;注解的 &lt;code&gt;externalConversions&lt;/code&gt;注册它们。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@MapperConfig&lt;/span&gt;(componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@SpringMapperConfig&lt;/span&gt;(&lt;br/&gt;   externalConversions = &lt;span&gt;@ExternalConversion&lt;/span&gt;(sourceType = String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;targetType&lt;/span&gt; &lt;/span&gt;= Locale&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;MapstructConfig&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会在适配器中自动生成相应的转换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConversionServiceAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConversionService conversionService;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ConversionServiceAdapter&lt;/span&gt;&lt;span&gt;(@Lazy &lt;span&gt;final&lt;/span&gt; ConversionService conversionService)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.conversionService = conversionService;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Locale &lt;span&gt;mapStringToLocale&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String source)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; conversionService.convert(source, Locale&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;mapstruct-spring-annotations&lt;/strong&gt; 使开发人员能够通过&lt;code&gt;ConversionService&lt;/code&gt;使用定义的 &lt;strong&gt;Mapstruct&lt;/strong&gt; 映射器，而不必单独导入每个 &lt;strong&gt;Mapper&lt;/strong&gt;，从而允许 &lt;strong&gt;Mapper&lt;/strong&gt; 之间的松散耦合。它本身不会影响&lt;strong&gt;Mapstruct&lt;/strong&gt;的机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目源码地址&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://gitee.com/felord/mapstruct-spring-extensions&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扫描下方二维码即可加我微信啦，&lt;code&gt;2022，抱团取暖，一起牛逼。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CKvMdchsUwm2Jjda5jicZYCPAmEWkzptcDX9KPUUXMyp6bK6lXicoojwQEheDgzHJqJoexw75iaoMJ5JpFuHyaksA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&amp;amp;mid=2247486362&amp;amp;idx=1&amp;amp;sn=fb6d71d328e8eee34976a86135dc6a7d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1Nzg4NjgyMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwnfLzMS3eAE7gXUvx6GYmnzuANVe5zJIGp0C084ANIia7Xo1nSADddF3eiajuhKDf0EofjI4t7hdqyA/0?wx_fmt=png&quot; data-nickname=&quot;macrozheng&quot; data-alias=&quot;&quot; data-signature=&quot;专注Java技术分享，涵盖SpringBoot、SpringCloud、Docker、中间件等实用技术，作者Github开源项目mall（50K+Star）。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/CKvMdchsUwlkU1ysoMgG69dVYbCQcI6Byneb8ibzZWPfUCr3T8CuBicCSGyFE6SpAtxpxtDCp6VlZ4F1hEL1BNyg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cbb3bac7ff9c021a565f96aa0111274a</guid>
<title>站点可靠性工程之旅</title>
<link>https://toutiao.io/k/bwetmpf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;SRE经过谷歌的实践和推广，已经被很多互联网公司所采用。如果想要实践SRE，成为SRE工程师，需要做好哪些方面的知识储备？本文介绍了SRE相关的技术，提供了大量有益的资源，有志于这一方向的同学可以以此作为技术发展路线图。原文：A Journey To The Site Reliability Engineering&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6662857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WrVqfT3aWFNBjy45NCuXyQXPQt3NL2jYasTInWd9vSxgRnhwV235FaEPvLatGQN166yic4ytVaroA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mukuko Studio @ Unsplash&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很多组织都已经开始采用站点可靠性工程（SRE，Site Reliability Engineering）实践来代替传统的运维。LinkedIn上最新的工作搜索显示，全球范围内有超过19万个SRE工程师职位空缺。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3382857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WrVqfT3aWFNBjy45NCuXyQFxLesCJ9gMVibM7lpfUkHo5x6Ho361niaTTLfghntr0yOBzXZWgkYjYw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LinkedIn职位搜索&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果你还不熟悉SRE，那么可以看看谷歌是如何描述的~&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;SRE是当你要求软件工程师设计一个运营团队时所发生的事情。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;SRE由7个重要原则定义 --&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;运维是一个软件问题（Operations is a software problem）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;按服务水平目标管理（Managed by Service Level Objectives）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;尽量减少工作量（Work to minimize the toil）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;把今年的工作自动化（Automate this year’s job away）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过减少失败的代价来快速行动（Move fast by reducing the cost of failure）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;与开发者分享所有权（Share ownership with the developers）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;无论是什么职能或职位，都使用相同的工具（Use the same tooling, regardless of function or job title）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;对于拥有运维支持、系统管理、基础架构、DevOps工程师等背景的人来说，SRE工程是一个很好的职业发展方向。&lt;/p&gt;&lt;p&gt;在本文中，我将提供各种资源，帮助你开始SRE工程师之旅。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;掌握SLO的艺术（Mastering the Art of Service Level Objectives(SLOs)）&lt;/h3&gt;&lt;p&gt;为了旅程顺利，我们有必要从理解&lt;span&gt;服务水平指标(SLIs, Service Level Indicators)&lt;/span&gt;和&lt;span&gt;服务水平目标(SLOs, Service Level Objectives)&lt;/span&gt;的概念开始。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;SLI: 服务&lt;span&gt;可靠性&lt;/span&gt;的&lt;span&gt;可量化&lt;/span&gt;度量&lt;br/&gt;&lt;/em&gt;&lt;em&gt;SLO: 为SLI设置&lt;span&gt;可靠性目标&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;有很多关于SLI和SLO的资源，但我建议通过SLO艺术工作坊&lt;span&gt;[2]&lt;/span&gt;来深入理解这一概念。&lt;/p&gt;&lt;p&gt;如果你是某个尝试采用SRE实践的组织的一员，那么我建议在组织内为有抱负的SRE开展这个工作坊。&lt;/p&gt;&lt;p&gt;工作坊旨在向你介绍如何以&lt;span&gt;数据驱动&lt;/span&gt;、客观和以用户为中心的方式通过&lt;span&gt;SLO和错误预算（Error Budgets）&lt;/span&gt;来度量和管理服务的可靠性。&lt;/p&gt;&lt;p&gt;工作坊可以指导我们选择正确的SLI，并通过案例帮助我们获得定义SLI/SLO的实践经验。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在学习的过程中，请保持开放的思维和新鲜的视角，因为我看到很多人认为SLI/SLO类似于他们使用的APM工具所做的基础设施监控，但事实并非如此！&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;h3&gt;云技术（Cloud Expertise）&lt;/h3&gt;&lt;p&gt;根据Gartner的报告&lt;span&gt;[3]&lt;/span&gt;，超过75%的企业都有云优先战略。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8137254901960784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WrVqfT3aWFNBjy45NCuXyQeOZu0K5DByzJzFrRaYc2w0ic5MNGsevW3JPWIRwib9E9afYPFMvHAPpQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;510&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源-https://www.gartner.com/en/information-technology/insights/cloud-strategy&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;因此，熟悉AWS、GCP和Azure等云服务是非常必要的。&lt;/p&gt;&lt;p&gt;许多组织都在积极使用云技术进行应用程序现代化转型之旅，SRE被要求在这一转变过程中发挥重要作用。&lt;/p&gt;&lt;p&gt;在互联网上有很多像Udemy, PluralSight, Coursera, CloudGuru等网站来提升我们的知识储备。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;基础设施即代码（Infrastructure as Code(IaC)）&lt;/h3&gt;&lt;p&gt;随着组织在云中迁移工作负载，高效、动态的管理基础设施的需求就更加突出了。因此，SRE应该拥有下面这样的IaC工具：&lt;/p&gt;&lt;p&gt;即使所有云服务提供商都有自己的SDK/Shell来管理服务，使用IaC工具仍然有很多好处。&lt;/p&gt;&lt;p&gt;下面的内容引用自《Quickly Deploy Applications Using Terraform With Kubernetes on GCP&lt;span&gt;[4]&lt;/span&gt;》：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;Terraform能够显示当前状态和期望状态之间的差异，这意味着一旦我们编辑了Terraform配置文件，就能看到将要做的改变。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Terraform不仅负责初始部署，还负责维护。我们可以使用命令轻松的创建、更新和删除跟踪的资源。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;清理Terraform构建的所有东西非常容易。如果使用脚本，我们还必须编写一个清理脚本。但对于Terraform，可以简单的通过“terraform destry”命令来实现。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Terraform能够检查配置文件中声明的动作的顺序。这意味着，如果我们想运行基于Kubernetes的服务或部署，即使我们错误的声明了操作的顺序，Terraform仍然将首先创建集群。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;你可以查看以下链接来了解关于这个主题的更多信息。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;https://learn.hashicorp.com/terraform&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://www.ansible.com/resources/get-started&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h3&gt;容器及容器编排平台（Containers &amp;amp; Container Orchraction Platforms）&lt;/h3&gt;&lt;p&gt;由于SRE在应用程序部署中扮演着关键角色，所以了解容器和容器编排平台非常重要。&lt;/p&gt;&lt;p&gt;许多组织使用Docker和Kubernetes平台进行服务部署，可以在网上找到大量关于这个话题的资源。&lt;/p&gt;&lt;p&gt;这里有一些可以作为开始的链接：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;https://www.docker.com/101-tutorial&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://kubernetes.io/training/&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h3&gt;持续集成及持续部署（Continuous Integration &amp;amp; Continous Deployment(CI/CD)）&lt;/h3&gt;&lt;p&gt;SRE需要将尽可能多的工作自动化，为应用程序提供适当的CI/CD流水线是快速交付的重要部分。许多组织使用下面这样的平台：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;GitLab&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GitHub&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Azure DevOps&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Jenkins&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等等&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，拥有建立CI/CD流水线的专业知识是一项基本技能。这些平台中有很多都支持免费服务，可以不用花一分钱就能自学。&lt;/p&gt;&lt;p&gt;这里有一些学习资源：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;https://about.gitlab.com/learn/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://lab.github.com/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://azure.microsoft.com/en-us/overview/devops-tutorial/&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;h3&gt;发布策略（Release Strategies）&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32685714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0WrVqfT3aWFNBjy45NCuXyQviaa1Zj2HNhWpBtXlicPyFowm7ibyMLNsFuKgz6ziaib4BLLqkA27IgIgEQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源-https://sre.google/workbook/canarying-releases/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;作为SRE角色的一部分，我们需要不断为用户部署新特性。这么做的同时，还需要确保在部署新特性时没有消耗错误预算（Error Budget），因此需要熟悉如下发布策略：&lt;/p&gt;&lt;p&gt;熟悉特性标记(feature-flag)&lt;span&gt;[7]&lt;/span&gt;的开发策略将增加优势。如果使用像Kubernetes这样的容器编排平台，可以使用Kubernetes的定义文件描述这些策略&lt;span&gt;[8]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;在谷歌的SRE工作手册中深入介绍了金丝雀发布的过程&lt;span&gt;[9]&lt;/span&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;事故响应和非指责的事后剖析（Incident Response &amp;amp; Blameless Postmortems）&lt;/h3&gt;&lt;p&gt;随叫随到是SRE的另一个重要职责。因此，SRE需要对事故响应流程有非常好的理解。&lt;/p&gt;&lt;p&gt;PagerDuty事故响应课程&lt;span&gt;[10]&lt;/span&gt;涵盖了如下话题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;什么是事故？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;事故级别&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;事故管理的各种角色&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;事故电话礼仪&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等等&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将事故响应过程记录下来是很重要的，因为如果人们知道事故发生时如何应对，就能更好的管理突发事故。&lt;/p&gt;&lt;p&gt;PagerDuty还有另一个关于如何在SRE团队中培养非指责文化的课程&lt;span&gt;[11]&lt;/span&gt;，其中提供了一些非常详细的模板，可以用来执行无指责的事后分析。&lt;/p&gt;&lt;p&gt;强烈推荐这两门课程。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;安全（Security）&lt;/h3&gt;&lt;p&gt;因为SRE负责整个应用，对应用安全性有基本的了解总是好的。&lt;/p&gt;&lt;p&gt;强烈建议你熟悉下面提到的概念：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;OWASP Top 10&lt;span&gt;[12]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Application Threat Modelling&lt;span&gt;[13]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于自动化部署，SRE需要管理各种服务凭证，因此应该熟悉凭证管理工具，如HashiCorp Vault&lt;span&gt;[14]&lt;/span&gt;或云原生加密管理解决方案，如Azure密钥库、谷歌加密管理器等。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;文档（Documentation）&lt;/h3&gt;&lt;p&gt;SREs需要确保所有重要的文件都定期更新，易于遵循，因此应该专注于制作高质量的文档，比如：&lt;/p&gt;&lt;p&gt;谷歌提供免费的技术写作课程&lt;span&gt;[15]&lt;/span&gt;，建议大家在日常生活中学习并运用其中的原则，当然如果你有时间的话也可以报名参加有导师指导的培训课程。&lt;/p&gt;&lt;p&gt;另外，我也写过一篇关于工程师技术写作最佳实践的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247484894&amp;amp;idx=1&amp;amp;sn=7b8924d85b22769788b8f48e7b986c35&amp;amp;chksm=fc73b805cb043113a75afb32b7c33585f404c21547debf3beff5833ca0cf95e1b3e9270e721e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《软件工程师文档写作最佳实践》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《软件工程师文档写作最佳实践》&lt;/a&gt;&lt;span&gt;[16]&lt;/span&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;灾难恢复测试/混沌工程（Disaster Recovery Testing / Chaos Engineering）&lt;/h3&gt;&lt;p&gt;为了测试平台的健壮性，SRE还负责执行灾难恢复测试。谷歌将灾难恢复测试作为其健壮服务的一部分，《Weathering the Unexpected》&lt;span&gt;[17]&lt;/span&gt;是一篇关于谷歌DiRT项目的详细文章。&lt;/p&gt;&lt;p&gt;最近Netflix的混沌工程理念变得非常流行，我在《Why Every Software Developer Needs to Learn Chaos Engineering》&lt;span&gt;[18]&lt;/span&gt;里也写过关于混沌工程的内容。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;非抽象大规模设计（Non-Abstract Large Scale Designs(NALSD)）&lt;/h3&gt;&lt;p&gt;当我们开始讨论大型、复杂、分布式系统时，谷歌已经设计了一个流程&lt;span&gt;[19]&lt;/span&gt;，可以帮助SRE发展评估、设计和衡量大型系统的能力。&lt;/p&gt;&lt;p&gt;NALSD过程包含了问题陈述、需求收集，以及帮助评估大规模系统对不同故障模式的容忍度的迭代系统设计。&lt;/p&gt;&lt;p&gt;谷歌还提供了一个工作坊，带领我们了解分布式消息队列(如pub/sub)的系统设计，并解释如何对其实现NALSD原则。&lt;/p&gt;&lt;p&gt;我个人从中学到了很多。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;社区&lt;/h3&gt;&lt;p&gt;为了更多的向他人学习，并了解行业最新动态，建议加入以下在线社区：&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;结论&lt;/h3&gt;&lt;p&gt;总的来说，SRE工程流程非常有趣，并且正在被许多组织所采用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] A Journey To The Site Reliability Engineering: https://deshpandetanmay.medium.com/a-journey-towards-site-reliability-engineering-7c893dae23ab&lt;br/&gt;[2] The Art of SLOs: https://sre.google/resources/practices-and-processes/art-of-slos/&lt;br/&gt;[3] The Latest Cloud Computing Technology and Security: https://www.gartner.com/en/information-technology/insights/cloud-strategy&lt;br/&gt;[4] Quickly Deploy Applications Using Terraform With Kubernetes on GCP: https://medium.com/google-cloud/quickly-deploy-applications-using-terraform-with-kubernetes-on-gcp-6a4d7d142839&lt;br/&gt;[5] Canary Release: https://martinfowler.com/bliki/CanaryRelease.html&lt;br/&gt;[6] Blue Green Deployment: https://martinfowler.com/bliki/BlueGreenDeployment.html&lt;br/&gt;[7] Feature Toggles: https://martinfowler.com/articles/feature-toggles.html&lt;br/&gt;[8] Kubernetes Deployment: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&lt;br/&gt;[9] Canarying Releases: https://sre.google/workbook/canarying-releases/&lt;br/&gt;[10] PagerDuty Incident Response: https://response.pagerduty.com/&lt;br/&gt;[11] PagerDuty Postmortems: https://postmortems.pagerduty.com/culture/blameless/&lt;br/&gt;[12] OWASP Top 10: https://owasp.org/www-project-top-ten/&lt;br/&gt;[13] Application Threat Modelling: https://deshpandetanmay.medium.com/threat-model-what-is-that-b45eac2c4104&lt;br/&gt;[14] Vault: https://www.vaultproject.io/&lt;br/&gt;[15] Technical Writing Courses for Engineers: https://developers.google.com/tech-writing/&lt;br/&gt;[16] Best Practices When Documenting Your Code for Software Engineers: https://betterprogramming.pub/best-practices-when-documenting-your-code-for-software-engineers-941f0897aa0&lt;br/&gt;[17] Weathering the Unexpected: https://queue.acm.org/detail.cfm?id=2371516&lt;br/&gt;[18] Why Every Software Developer Needs to Learn Chaos Engineering: https://betterprogramming.pub/why-every-software-developer-needs-to-learn-chaos-engineering-ef08992f4354&lt;br/&gt;[19] Introducing Non-Abstract Large System Design: https://sre.google/workbook/non-abstract-design/&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>25bf23c786ca64fa8df0950a5bef3105</guid>
<title>专家带你吃透 Flink 架构：一个新版 Connector 的实现</title>
<link>https://toutiao.io/k/glbmp7d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h1 name=&quot;%E4%B8%80%E3%80%81%E5%8F%AF%E6%90%9C%E7%B4%A2%E5%BF%AB%E7%85%A7%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86&quot;&gt;作者：刘泽善，腾讯CSIG专家工程师&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 name=&quot;%E4%B8%80%E3%80%81%E5%8F%AF%E6%90%9C%E7%B4%A2%E5%BF%AB%E7%85%A7%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n2&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Flink 可以说已经是流计算领域的事实标准，其开源社区发展迅速，提出了很多改进计划（Flink Improvement Proposals，简称 FLIP [1]）并不断迭代，几乎每个新的版本在功能、性能和使用便捷性上都有所提高。Flink 提供了丰富的数据连接器（connecotr）来连接各种数据源，内置了 kafka [2]、jdbc [3]、hive [4]、hbase [5]、elasticsearch [6]、file system [7] 等常见的 connector，此外 Flink 还提供了灵活的机制方便开发者开发新的 connector。对于 source connector 的开发，有基于传统的 SourceFunction [8] 的方式和基于 Flink 改进计划 FLIP-27 [9] 的 Source [10] 新架构的方式。本文首先介绍基于 SourceFunction 方式的不足，接着介绍 Source 新架构以及其设计上的深层思考，然后基于 Flink 1.13 ，以从零开发一个简单的 FileSource connector 为例，介绍开发 source connector 的基本要素，尽量做到理论与实践相结合加深大家的理解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;流计算 Oceanus 是大数据产品生态体系的实时化分析利器，是基于 Apache Flink 构建的具备一站开发、无缝连接、亚秒延时、低廉成本、安全稳定等特点的企业级实时大数据分析平台。流计算 Oceanus 以实现企业数据价值最大化为目标，加速企业实时化数字化的建设进程。流计算 Oceanus 提供了便捷的控制台环境，方便用户编写 SQL 分析语句、ETL 作业或者上传运行自定义 JAR 包，支持作业运维管理。欢迎大家试用，目前还有新用户&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTc0NTcyMw==&amp;amp;mid=2247486172&amp;amp;idx=1&amp;amp;sn=9e07440d545ecd090c87734445aaed9d&amp;amp;chksm=fa818f08cdf6061e553f8fe283dc29ae5b870fac1c1daeed39bb2d1785379ce7d076c9c6390f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1元秒杀&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span md-inline=&quot;link&quot;&gt;1元秒杀&lt;/span&gt;&lt;/a&gt;&lt;span md-inline=&quot;plain&quot;&gt;活动，机会难得，不容错过。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 name=&quot;%E4%B8%80%E3%80%81%E5%8F%AF%E6%90%9C%E7%B4%A2%E5%BF%AB%E7%85%A7%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86&quot;&gt;&lt;span&gt;Source 旧架构&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在 Flink 1.12 之前，开发一个 source connector 通过实现 SourceFunction [8] 接口来完成，官方给出的通用的实现模式如下。当 source 开始发送数据时，run 方法被调用，其参数 SourceContext 用于发送数据。run 方法是一个无限循环，通过一个标识 isRunning 来跳出循环结束 source。批模式和流模式通常需要不同的处理逻辑，例如示例的批模式通过一个计数器来结束批数据。此外，还需要通过 checkpoint 锁来保证状态更新和数据发送的原子性。值得一提的是，Flink 在 SourceFunction 之上抽象出了 InputFormatSourceFunction，开发者只需要实现 InputFormat，批模式 source connector（如 HBase）通常基于 InputFormat 实现，当然 InputFormat 也可以用于流模式，在一定程度上体现了批流融合的思想，但整体上来看至少在接口层面上流批并没有完全一致。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  public class ExampleCountSource implements SourceFunction&amp;lt;Long&amp;gt;, CheckpointedFunction {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      private long count = 0L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      private volatile boolean isRunning = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      private transient ListState&amp;lt;Long&amp;gt; checkpointedCount;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      public void run(SourceContext&amp;lt;T&amp;gt; ctx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          while (isRunning &amp;amp;&amp;amp; count &amp;lt; 1000) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              // this synchronized block ensures that state checkpointing,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              // internal state updates and emission of elements are an atomic operation&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              synchronized (ctx.getCheckpointLock()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  ctx.collect(count);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  count++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      public void cancel() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          isRunning = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      public void initializeState(FunctionInitializationContext context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          this.checkpointedCount = context&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              .getOperatorStateStore()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              .getListState(new ListStateDescriptor&amp;lt;&amp;gt;(&quot;count&quot;, Long.class));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          if (context.isRestored()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              for (Long count : this.checkpointedCount.get()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  this.count += count;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      public void snapshotState(FunctionSnapshotContext context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          this.checkpointedCount.clear();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          this.checkpointedCount.add(count);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;在基于 SourceFunction 的开发模式下，以 Kafka Source 为例，见下图，FlinkKafkaConsumer 为 SourceFunction 的实现类，该类中集中了 kafka partition 发现逻辑（KafkaPartitionDiscoverer）、数据读取逻辑（KafkaFetcher）、基于阻塞队列实现的生产者消费者模型（KafkaConsumerThread -&amp;gt; Handover -&amp;gt; SourceContext）等等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkyOUvXYicpAibpyJOqXLibUmp7Op0q0IdqS1bVWCoU5sicdX5trMStd46Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们可以发现，这种开发模式存在如下不足：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n10&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;首先对于批模式和流模式需要不同的处理逻辑，不符合批流融合的业界趋势。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据分片（例如 kafka partition、file source 的文件 split）和实际数据读取逻辑混合在 SourceFunction 中，导致复杂的实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据分片在接口中并不明确，这使得很难以独立于 source 的方式实现某些功能，例如事件时间对齐（event-time alignment）、分区 watermarks（per-partition watermarks）、动态数据分片分配、工作窃取（work stealing）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n18&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;没有更好的方式来优化 Checkpoint 锁，在锁争用下，一些线程（例如 checkpoint 线程）可能无法获得锁。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;没有通用的构建模式，每个源都需要实现自行实现复杂的线程模型，这使得开发和测试一个新的 source 变得困难，也提高了开发者对现有 source 的作出贡献的门槛。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;有鉴于此，Flink 社区提出了 FLIP-27 [9] 的改进计划，并在 Flink 1.12 实现了基础框架，在 Flink 1.13 中 kafka、hive 和 file source 已移植到新架构，开源社区的 Flink CDC connector 2.0 [11] 也基于新架构实现。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n22&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Source 新架构&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4786206896551724&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkibvhtNH6zicOAOED9OribwSlVltIIrxibyHTice5A5uvvmAOUvSCNEDjCaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1450&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于 FLIP-27 的 Source 新架构如上图所示，由两个主要部件组成：SplitEnumerator 和 SourceReader。SplitEnumerator 负责数据分片和分配，SourceReader 则负责具体分片数据的读取。当一个新的分片被 SplitEnumerator 添加到 SourceReader，首先初始化分片状态并放入状态哈希表中，然后分片被分配给 SplitReader 读取数据。读取的数据以小批量模式封装于 RecordsWithSplitIds 并放置于中间队列 Queue，这种批量数据模式可以提高性能。SourceReader 从 Queue 中获取一批数据，遍历每一条数据，并查找数据相应的分片状态，数据和分片状态一并传递给 RecordEmitter，RecordEmitter 先把数据传递给 SourceOutput，然后更新分片状态。状态哈希表中的状态在 checkpoint 时持久化到状态存储。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Source 新架构具有以下特点。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n26&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;数据分片与数据读取分离&lt;/strong&gt;。例如在 FileSource 中，SplitEnumerator 负责列出所有的文件，并有可能把文件按块或者范围进行切分，SourceReader 则负责具体的文件/块的数据读取。又例如在 KafkaSource 中，SplitEnumerator 负责发现需要读取的 kafka partition，SourceReader 则负责具体 partition 数据的读取。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;批流融合&lt;/strong&gt;。基于新架构开发的 Source 既可以工作于批模式也可以工作于流模式，批仅仅是有界的流。大多数情况下，只有 SplitEnumerator 需要感知数据源是否有界。例如对于 FileSource，批模式下 SplitEnumerator 只需要一次性的列出目录下的所有文件，流模式下则需要周期性的列出所有文件，并为新增的文件生成数据分片。对于 KafkaSource，批模式下 SplitEnumerator 列出所有的 partition，并把每个 partition 的当前最新的数据偏移作为数据分片的结束点，流模式下 SplitEnumerator 则把无穷大作为 partition 数据分片的结束点，即会持续的读取每个 partition 的新增数据，流模式下还可以周期性的监测 partition 的变化并为新增的 partitition 生成数据分片。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n28&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;双向通信&lt;/strong&gt;。SplitEnumerator 运行在 JobManager，SourceReader 运行在 TaskManager，SplitEnumerator 和 SourceReader 之间可以双向通信，SourceReader 可以主动向 SplitEnumerator 请求数据分片实现 pull 模式的数据分片分配（例如 FileSource），SplitEnumerator 也可以把数据分片直接分配给 SourceReader 实现 push 模式的分配（例如 KafkaSource）。此外，根据需要还可以定制化一些消息实现 SplitEnumerator 和 SourceReader 之间的交互需求。基于双向通信的能力，比较容易实现事件时间对齐（event-time alignment）的功能，实现数据分片之间事件时间的均衡推进。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;通用线程模型&lt;/strong&gt;。考虑到外部数据源系统的客户端 API 调用方式的差异（阻塞、非阻塞、异步），SourceReader 在设计上支持单分片串行读取、多分片多路复用、多分片多线程三种模式。Flink 1.13 内核的 SingleThreadMultiplexSourceReaderBase/SingleThreadFetcherManager 抽象出的框架支持前两种线程模型，开发者基于此开发 source connector 变得容易。例如 FileSource 采用了单分片串行读取模式，在一个数据分片读取后，再向 SplitEnumerator 请求新的数据分片。KafkaSource 采用了多分片多路复用模式，SplitEnumerator 把启动时读取的 partition 列表和定期监测时发现的新的 partition 列表批量分配给 SourceReader，SourceReader 使用 KafkaConsumer API 读取所有分配到的 partition 的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1189083820662769&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkWgddMK82jcic6xs6TwpCOEqS5J4RAUiaIOEcXH2xyy4r2bs2sCY2rWSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;容错&lt;/strong&gt;。SplitEnumerator 和 SourceReader 通过 Flink 的分布式快照机制持久化状态，发生异常时从状态恢复。通常 SplitEnumerator 状态保存了未分配的数据分片，SourceReader 状态保存了分配的数据分片以及分片读取状态（例如 kafka offset，文件 offset）。例如流模式下 FileSource 的 SplitEnumerator 状态保存了未分配的分片以及处理过的文件列表，并定期监测文件列表的变化，为新增文件生成数据分片；SourceReader 状态保存了当前读取的分片信息和文件读取 offset。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n32&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;FileSource 开发实践&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面我们进入实际操作阶段，基于新架构开一个简单的 FileSource connector，该 connector 工作于流模式，读取指定目录下的文件，并定期监测新增文件。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n34&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;初始化项目&lt;/span&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n35&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们使用 IntelliJ IDEA 作为开发工具，并按照 Flink 编码规范配置 IntelliJ IDEA [12]，在菜单栏选择 &quot;File -&amp;gt; New -&amp;gt; Project...&quot;，填写必要的信息，按照提示操作完成项目创建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.739021329987453&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkcMP7x7LQvKianN7NPoibbzTqEQsyPluLpIayLj2Ld1IzZKj1sU4PfQYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7309388783868935&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkMNicETXNMNd4nAIqdhuG6WaEC1WgnB09K6PWwOj9FCJM4H2sG94NGicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1587&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot; cid=&quot;n40&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在 pom.xml [13] 文件添加必要的 Flink 依赖。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n44&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Flink 基于 Java SPI 机制l发现和加载自定义 connector，我们在 resources 目录下创建目录 &lt;code&gt;META-INF/services&lt;/code&gt;，并在该目录下创建文件 &lt;code&gt;org.apache.flink.table.factories.Factory&lt;/code&gt;，文件内容为：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;CSS&quot; cid=&quot;n45&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;com.tencent.cloud.oceanus.connector.file.table.FileDynamicTableFactory&lt;/span&gt;&lt;/pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;4&quot; cid=&quot;n46&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;创建 Java 类 &lt;code&gt;com.tencent.cloud.oceanus.connector.file.table.FileDynamicTableFactory&lt;/code&gt; 实现 &lt;code&gt;DynamicTableSourceFactory&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;现在，我们项目初始化已经完成，可以在 IntelliJ IDEA 项目右侧选择 &quot;Maven -&amp;gt; flink-connector-files -&amp;gt; LifeCyle -&amp;gt; package&quot; 构建项目，能够在 target 目录下正确构建出名为 flink-connector-files-1.0.0.jar 的二进制包。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n51&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Connector 开发&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;我们按照 Flink 官方的自定义 connector 开发文档 [14] 来一步步完成 FileSource connector 的开发。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n53&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;Metadata 层&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p cid=&quot;n54&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;简单起见，我们的 connector 只支持按行读取指定目录的文件，在 SQL 语句中按如下方式使用 connector。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CREATE TABLE test (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  `line` STRING&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) WITH (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &#x27;connector&#x27; = &#x27;file&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &#x27;path&#x27; = &#x27;file:///path/to/files&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 cid=&quot;n56&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;Planning 层&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n57&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n59&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;创建类 FileDynamicTableFactory [15]，添加自定义 connector 标识 &lt;code&gt;file&lt;/code&gt;和参数 &lt;code&gt;path&lt;/code&gt;。校验参数并创建 FileDynamicSource [16]。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;FileDynamicSource [16] 创建 Runtime 层的 FileSource [17]。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 cid=&quot;n62&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;Runtime 层&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n63&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;FileSource [17]&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;实现 Source [10] 接口，需要三个类型参数：第一类型参数为 Source 输出数据类型，由于我们的 connector 用于 SQL 作业场景，这里设置为 RowData 类型。第二个类型参数为数据分片类型 SourceSplit [18]。第三个类型参数为 SplitEnumerator checkpoint 数据类型。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n65&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;FileSource 是一个工厂类，用于创建 SplitEnumerator、SourceReader、数据分片序列化器、SplitEnumerator checkpoint 序列化器。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n66&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;FileSourceSplit [19]&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;实现 SourceSplit [18]。该类保存了数据分片 id、文件路径、数据分片起始位置的文件偏移（我们这里整个文件作为一个数据分片，不再细分，因此偏移始终为 0）、文件长度、文件读取进度（恢复时从该位置继续数据读取）。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n68&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;FileSourceSplitSerializer [20]&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n69&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据分片序列化器，对 FileSourceSplit [19] 序列化和反序列化。数据分片在从 SplitEnumerator 传输到 SourceReader，以及被 SourceReader checkpoint 持久化时都需要序列化。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n70&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;PendingSplitsCheckpoint [21]&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SplitEnumerator checkpoint 数据，保存了未分配的分片以及处理过的文件列表。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n72&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;PendingSplitsCheckpointSerializer [22]&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SplitEnumerator checkpoint 序列化器，对 PendingSplitsCheckpoint [21] 序列化和反序列化。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n74&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;FileSourceEnumerator [23]&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;定期监测目录下的文件，生成数据分片，并分配给 SourceReader。Flink 内核提供了定时回调接口&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n76&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SplitEnumeratorContext#callAsync [24] 方便我们使用。这里我们采用 pull 模式的数据分片分配策略。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n77&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;FileSourceReader [25]&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;继承自 SingleThreadMultiplexSourceReaderBase，在读取完一个数据分片（文件）后再向 FileSourceEnumerator [23] 请求下一个分片。我们需要实现数据分片状态初始化接口 initializedState [26]，当新的数据分片加入时会调用该接口。实现接口 toSplitType [27]，把可变的数据分片状态 FileSourceSplitState [28] 转换为不可变的数据分片 FileSourceSplit [19]，checkpoint 时会调用该接口得到最新状态的 FileSourceSplit 并持久化。FileSourceRecordEmitter [29] 发送数据到下游，并更新 FileSourceSplitState 的分片读取进度。具体分片数据读取逻辑在 FileSourceSplitReader [30] 实现，这里我们简单的每次读取一行数据。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Connector 测试&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n80&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;基本功能&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1.从 Flink 官网下载已经编译好的二进制包 Apache Flink 1.13.3 for Scala 2.11 [31] 并解压，进入解压后的目录。拷贝我们开发的 connector 二进制包 flink-connector-files-1.0.0.jar [32] 到 lib 目录。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tar -zxvf flink-1.13.3-bin-scala_2.11.tgz&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cd flink-1.13.3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cp flink-connector-files-1.0.0.jar lib/ -avi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n87&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2.启动本地集群。可在本地浏览器里打开 &lt;/span&gt;&lt;span&gt;http://localhost:8081&lt;/span&gt;&lt;span&gt; 进入 Flink UI 验证集群是否启动成功。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./bin/start-cluster.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n87&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3.创建测试数据目录，我们的 connector 从该目录下读取文件。然后进入 sql client 命令行。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mkdir -p /tmp/file-connector&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./bin/sql-client.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n95&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;4.在 sql client 命令行输入。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;create table `source` (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    `line` STRING&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) with (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &#x27;connector&#x27; = &#x27;file&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &#x27;path&#x27; = &#x27;/tmp/file-connector&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;select * from `source`;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;5.我们往目录 &lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;code&gt;/tmp/file-connector&lt;/code&gt;&lt;/span&gt;&lt;span&gt; 写入几个文件测试一下，可见我们的 connector 能正常的读取文件数据。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cd /tmp/file-connector&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;echo &quot;Hello World&quot; &amp;gt; 1.txt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;echo &quot;tencent&quot; &amp;gt; 2.txt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;echo &quot;oceanus&quot; &amp;gt; 3.txt  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;echo &quot;我爱我的祖国&quot; &amp;gt; 4.txt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37595419847328243&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXktYrUgFSXZIFHUCMmjcYKKnfq8Vd8MZtEjrNttslia1LykZYLfp43FTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;/p&gt;&lt;h3 cid=&quot;n102&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;状态和容错&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n105&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;1.在 Flink 配置 &lt;code&gt;conf/flink-conf.yaml&lt;/code&gt; 添加状态存储配置，设置 checkpoint 和 savepoint 目录，checkpoint 时间间隔，以及 Flink 重启策略。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;http&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;state.backend&lt;/span&gt;: filesystem&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;state.checkpoints.dir&lt;/span&gt;: file:///tmp/flink-checkpoints&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;state.savepoints.dir&lt;/span&gt;: file:///tmp/flink-savepoints&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;execution.checkpointing.interval&lt;/span&gt;: 30s&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;restart-strategy&lt;/span&gt;: fixed-delay&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;restart-strategy.fixed-delay.attempts&lt;/span&gt;: 30&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;restart-strategy.fixed-delay.delay&lt;/span&gt;: 5s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n109&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;2.重启集群，并重新进入 sql client 命令行。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./bin/&lt;span class=&quot;code-snippet__keyword&quot;&gt;stop&lt;/span&gt;-cluster.sh&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./&lt;span class=&quot;code-snippet__keyword&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt;-cluster.sh&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./&lt;span class=&quot;code-snippet__keyword&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;sql&lt;/span&gt;-client.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n113&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;3.重新提交作业。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`source`&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;`line`&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;STRING&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;connector&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;file&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;path&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;/tmp/file-connector&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`source`&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n117&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;4.这次我们准备一个大的数据文件 &lt;code&gt;bigfile.txt&lt;/code&gt;，例如有上千万行，拷贝文件到目录 &lt;code&gt;/tmp/file-connector&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;5.在浏览器输入  &lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;http://localhost:8081&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; 进入 Flink UI 界面，点击 &#x27;Running Jobs&#x27;，可看到我们正在运行的作业，点击作业进入作业详情，选择 Checkpoints 标签页，然后选择 History 的子标签页，点击右侧的 Refresh 按钮。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29245283018867924&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkP7wHypE2sN50cOnBBoxoM5HXx0Gk9uiaUDrNFdND9C0wIp80uY5DXcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1378&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.14601905932984938&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkibF41ETwD0EdSTdr5QsuIkJ5jKUGdSicf6Lib2TVvYMIPic7X4ftOOG6zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3253&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;6.在观察到一次成功的 checkpoint 之后，我们重启 taskmanager。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./bin/taskmanager.sh &lt;span class=&quot;code-snippet__keyword&quot;&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./&lt;span class=&quot;code-snippet__keyword&quot;&gt;bin&lt;/span&gt;/taskmanager.sh &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n128&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;7.稍等一会儿，我们可在 Flink UI 里观察到作业从 checkpoint 恢复的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45911772969935377&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXk7Ve3elWM5lJNstkdqmLdPEF3fHTZgQsAvuTcbGCAoWksFEZMsIXP3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3559&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;8.同时我们在 taskmanager 日志里可观察到作业恢复时的数据分片信息包含 checkpoint 时保存的文件读取 offset 信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3530361757105943&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5CXH0Xf7yddBl70EgvoDfXkPnpX6q1bJh6mm8Kas4UACibq4E5Ee6Zjqlv1UF0Eg6JZ0q4wag97MZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3096&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;FileSource 开发实践总结&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;作为流计算领域的事实标准，Flink 有着优秀的架构设计，其强大的可扩展能力让我们开发一个自定义 connector 变得简单。Flink 社区的文档也非常丰富和详细，这里我们按照 Flink 自定义 connector 开发文档，基于 FLIP-27 的 Source 新架构开发了一个简单 FileSource connector，并演示了其基本功能和错误恢复功能。我们在开发新的 connector 时可以多参考社区已有 connector 的设计和开发模式，甚至可以对现有 connector 进行功能增强来满足需求。我们这里的 FileSource connector 就是参考内核的 filesystem connector [7]，进行了简化以方便大家理解。内核的 filesystem connector 不支持同一个文件的增量数据读取，如果我们实际业务场景一定需要这种能力，我们可以给 filesystem connector 添加该功能并贡献到社区。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 cid=&quot;n136&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n137&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;本文首先介绍了 Flink Source Connector 开发时基于传统的 SourceFunction 方式的不足，接着介绍了 FLIP-27 的 Source 新架构特点及其优势，然后基于新架构从零开发了一个简单的 FileSource connector，介绍开发 source connector 的基本要素。最后，欢迎大家猛击（ &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTc0NTcyMw==&amp;amp;mid=2247486172&amp;amp;idx=1&amp;amp;sn=9e07440d545ecd090c87734445aaed9d&amp;amp;chksm=fa818f08cdf6061e553f8fe283dc29ae5b870fac1c1daeed39bb2d1785379ce7d076c9c6390f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1元秒杀&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1元秒杀&lt;/span&gt;&lt;/a&gt;）体验流计算 Oceanus，免费学习 Flink。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTc0NTcyMw==&amp;amp;mid=2247486172&amp;amp;idx=1&amp;amp;sn=9e07440d545ecd090c87734445aaed9d&amp;amp;chksm=fa818f08cdf6061e553f8fe283dc29ae5b870fac1c1daeed39bb2d1785379ce7d076c9c6390f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;流计算 Oceanus 限量秒杀专享活动火爆进行中↓↓&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;流计算 Oceanus &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;限量秒杀专享活动火爆进行中↓↓&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002700&quot; data-ratio=&quot;2.424&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/o2eWePa4j5AvdJBV93L0GQiamO4EN6q1gLhA4BsWXXicvYAOHMicTKbicoasicn3YkL7KCf9Stian7HwXK6thVIufd4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1 cid=&quot;n138&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[1] Flink Improvement Proposals：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://cwiki.apache.org/confluence/display/FLINK/Flink+Improvement+Proposals&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[2] kafka：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/connectors/table/kafka/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n141&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[3] jdbc：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/connectors/table/jdbc/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n142&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[4] hive：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/connectors/table/hive/overview/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n143&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[5] hbase：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/connectors/table/hbase/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n144&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[6] elasticsearch：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/connectors/table/elasticsearch/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n145&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[7] file system：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/connectors/table/filesystem/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n146&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[8] SourceFunction：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/streaming/api/functions/source/SourceFunction.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[9] FLIP-27：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://cwiki.apache.org/confluence/display/FLINK/FLIP-27%3A+Refactor+Source+Interface&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n148&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[10] Source：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/api/connector/source/Source.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[11] Flink CDC connector 2.0：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://ververica.github.io/flink-cdc-connectors/master/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[12] 配置 IntelliJ IDEA：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/flinkdev/ide_setup/#intellij-idea&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[13] pom.xml：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/pom.xml&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n152&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[14] 自定义 connector 开发：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/docs/dev/table/sourcessinks/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n153&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[15] FileDynamicTableFactory：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/table/FileDynamicTableFactory.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[16] FileDynamicSource：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/table/FileDynamicSource.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n155&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[17] FileSource：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/source/FileSource.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n156&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[18] SourceSplit：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/api/connector/source/SourceSplit.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n157&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[19] FileSourceSplit：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/split/FileSourceSplit.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[20] FileSourceSplitSerializer：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/split/FileSourceSplitSerializer.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n159&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[21] PendingSplitsCheckpoint：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/enumerator/PendingSplitsCheckpoint.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n160&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[22] PendingSplitsCheckpointSerializer：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/enumerator/PendingSplitsCheckpointSerializer.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n161&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[23] FileSourceEnumerator：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/enumerator/FileSourceEnumerator.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[24] SplitEnumeratorContext#callAsync：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/api/connector/source/SplitEnumeratorContext.html#callAsync-java.util.concurrent.Callable-java.util.function.BiConsumer-long-long-&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n163&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[25] FileSourceReader：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/reader/FileSourceReader.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n164&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[26] initializedState：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/connector/base/source/reader/SourceReaderBase.html#initializedState-SplitT-&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[27] toSplitType：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/connector/base/source/reader/SourceReaderBase.html#toSplitType-java.lang.String-SplitStateT-&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[28] FileSourceSplitState：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/reader/FileSourceSplitState.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n167&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[29] FileSourceRecordEmitter：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/reader/FileSourceRecordEmitter.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n168&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[30] FileSourceSplitReader：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/blob/master/flink-connector-files/src/main/java/com/tencent/cloud/oceanus/connector/file/reader/FileSourceSplitReader.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[31] Apache Flink 1.13.3 for Scala 2.11：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://www.apache.org/dyn/closer.lua/flink/flink-1.13.3/flink-1.13.3-bin-scala_2.11.tgz&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n170&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;[32] flink-connector-files-1.0.0.jar：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/lzshlzsh/tflink-playgrounds/releases/download/v0.1.0/flink-connector-files-1.0.0.jar&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;点击文末&lt;/span&gt;&lt;span&gt;「阅读原文」&lt;/span&gt;&lt;span&gt;，了解腾讯云流计算 Oceanus 更多信息&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;~&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_sig_022&#x27;)&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;腾讯云大数据&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002699&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/o2eWePa4j5DaCQzdVZibTicwrQId09Q0DzibuXlpp9fRibyulbDiafDHDk1ImSnbiaJ7PUHiajfOQLQlnLiczls7BVJFqQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; title=&quot;https://image.ipaiban.com/upload-ueditor-image-20200619-1592556685554099336.jpg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;长按二维码&lt;br/&gt;关注我们&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>