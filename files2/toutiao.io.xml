<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bb73838b8993b5616875182294f4d7d7</guid>
<title>新生代农民工，必读！</title>
<link>https://toutiao.io/k/wswq9zl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;昨天，人社部发布了《2020 年北京市外来新生代农民工监测报告》，引发网民热议。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6028084252758275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MjrqyjUCqickLUYno7Qn1LicPXNe9ZV3HFUYEGptZq1a6rmYx5Ynj9vGvk8II5NSRn8sqsAuF9vPoddKl8BGCGTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;span&gt;之所以引发网民热议，是在于软件和信息技术服务业一直是个备受青睐的行业，和传统认知中的农民工似乎完全不搭边。&lt;span&gt;但该报告似乎让 “码农” 这一称呼从软件和信息技术服务业从业者的自我调侃变为官方认证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报告指出，北京新生代农民工占比达到 50.1%，男性占比高于女性。其中，就业集中于劳动密集型行业，从事信息传输、软件和信息技术服务业的新生代农民工占比大幅提高。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然官宣了，那&lt;span&gt;属于咱 “新生代农民工” 的《码农周刊》&lt;/span&gt;，自然要推荐下哦～&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8Byw4xNoV6O2YGutfKmQLKuMZEIhBJF6MrQvoShfIAT6u3dXs6VZRzwSa2eT9jcekfaYuaOD6Hhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d46ac94cbdf0261058ab2deeb23f1afd</guid>
<title>[推荐] [译] 图解 Go 微服务熔断器</title>
<link>https://toutiao.io/k/ewzp9hr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;原文中 &lt;code&gt;Circuit Breakers&lt;/code&gt; 这里翻译为了熔断器，大家也可以理解叫为断路器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;fallback&lt;/code&gt;本文翻译为兜底，大家也可以理解为容错补救。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文翻译自https://ioshellboy.medium.com/circuit-breakers-in-golang-1779da9b001，由于本人翻译水平有限，翻译不当之处烦请指出。希望大家看了这篇文章能有所帮助。感谢捧场。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是熔断器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你看到 “熔断器” 这个术语时，你会想到什么呢?&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4915254237288136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBzicBRv73lFAxic69Chc2eIlTgm4KVr7A46tkSjOCzYich396LjVW0P4mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图片字面意思理解是使用一个锤子破坏了一个电路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般都会在自己家里安装熔断器，以阻止异常的电流从电网流向家里。在开始“微服务的熔断器”之前，让我们先看看它是如何工作的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.494140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBGXhZWJfTqCzciaicicwO6icQRpBqGhc3NUZ4Eouo0tV1oIQzeXro0veyFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，一个典型的熔断器装置有 2 个主要部件:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用火线紧紧包裹的软铁芯&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;触体。只要接触点能够形成一个连接点，电流就会从外部电源流向我们的房子。相反，如果连接断开，电流就停止流动。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当电流通过缠绕在软铁芯周围的导线时，软铁芯就像一块电磁铁，当流过它的电流高于预期的安培时，电磁铁就会变得强大到足以吸引邻近的触点，从而导致短路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你一定在想，这与微服务架构有什么关系呢？在我看来，这是高度相关的，正如我们下面将要看到的！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微服务架构中的级联故障&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务架构已经很好地取代了单体架构，但是为了使我们的系统具有高度的弹性，我们还需要解决一些关键问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务的一个问题是级联故障。举一个例子来更好地理解它。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5707142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB57LL42icEKQqiby96uB4ZKBuEPyvjbyCYeXbLibWbyssAlneookK7ahGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，参与者调用我们的主服务，它依赖于上游服务——A，B，C。现在假定，服务 A 是一个读取量较大的系统，它依赖于数据库。这个数据库有其自身的局限性，并且在过载时，可能导致连接重置。这个问题不仅会影响服务 A 的性能，还会影响主服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是人们所说的“一块臭肉坏了整锅汤”，喝过这锅汤的人肯定会有同感。下面让我们用一个例子来验证这一点。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29428571428571426&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBSy2CNq0qAkyuZHibt3d6cCaaNeiamySLR1nahS3zPn5KMia5zN8JibskEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们构建一个 Netflixisc 应用程序。其中一个微服务负责提供feed页面的&lt;strong&gt;电影服务&lt;/strong&gt;。此服务还依赖于&lt;strong&gt;推荐服务&lt;/strong&gt;为用户提供适当的推荐。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Recommendation Service&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; logGoroutines()&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/recommendations&quot;&lt;/span&gt;, recoHandler)&lt;br/&gt; log.Fatal(http.ListenAndServe(&lt;span&gt;&quot;:9090&quot;&lt;/span&gt;, nil))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;logGoroutines&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ticker := time.NewTicker(500 * time.Millisecond)&lt;br/&gt; &lt;span&gt;done&lt;/span&gt; := make(chan bool)&lt;br/&gt; go &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   select {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-&lt;span&gt;done&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; t := &amp;lt;-ticker.C:&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;\n%v - %v&quot;&lt;/span&gt;, t, runtime.NumGoroutine())&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func recoHandler(w http.ResponseWriter, r *http.Request) {&lt;br/&gt; a := `{&lt;span&gt;&quot;movies&quot;&lt;/span&gt;: [&lt;span&gt;&quot;Few Angry Men&quot;&lt;/span&gt;, &lt;span&gt;&quot;Pride &amp;amp; Prejudice&quot;&lt;/span&gt;]}`&lt;br/&gt; w.Write([]byte(a))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐服务&lt;/strong&gt;暴露一个路由接口 &lt;code&gt;/recommendations&lt;/code&gt;，它返回一个推荐电影列表，同时每 500 毫秒打印一次 goroutine 的数量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Movies App&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MovieResponse struct {&lt;br/&gt; Feed           []string&lt;br/&gt; Recommendation []string&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/movies&quot;&lt;/span&gt;, fetchMoviesFeedHandler)&lt;br/&gt; log.Fatal(http.ListenAndServe(&lt;span&gt;&quot;:8080&quot;&lt;/span&gt;, nil))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func fetchMoviesFeedHandler(w http.ResponseWriter, r *http.Request) {&lt;br/&gt; mr := MovieResponse{&lt;br/&gt;  Feed: []string{&lt;span&gt;&quot;Transformers&quot;&lt;/span&gt;, &lt;span&gt;&quot;Fault in our stars&quot;&lt;/span&gt;, &lt;span&gt;&quot;The Old Boy&quot;&lt;/span&gt;},&lt;br/&gt; }&lt;br/&gt; rms, err := fetchRecommendations()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  w.WriteHeader(500)&lt;br/&gt; }&lt;br/&gt; mr.Recommendation = rms&lt;br/&gt; bytes, err := json.Marshal(mr)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  w.WriteHeader(500)&lt;br/&gt; }&lt;br/&gt; w.Write(bytes)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func fetchRecommendations() ([]string, error) {&lt;br/&gt; resp, err := http.Get(&lt;span&gt;&quot;http://localhost:9090/recommendations&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; defer resp.Body.Close()&lt;br/&gt; body, err := ioutil.ReadAll(resp.Body)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; var mvsr map[string]interface{}&lt;br/&gt; err = json.Unmarshal(body, &amp;amp;mvsr)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; mvsb, err := json.Marshal(mvsr[&lt;span&gt;&quot;movies&quot;&lt;/span&gt;])&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; var mvs []string&lt;br/&gt; err = json.Unmarshal(mvsb, &amp;amp;mvs)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; []string{}, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; mvs, nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;电影服务&lt;/strong&gt;暴露一个路由 &lt;code&gt;/movies&lt;/code&gt;，它返回电影列表和推荐列表。为了获取推荐，它反过来调用上游的&lt;strong&gt;推荐服务&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过此设置，让我们以每秒 100 个请求的速率访问电影服务，持续 3 秒钟。在 99% 的毫秒范围内，我们可以获得 100% 的成功。这是预期的，因为只提供静态数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，假设推荐服务的响应时间过长，并在 &lt;code&gt;recoHandler&lt;/code&gt; 添加20秒的等待时间，然后重新进行测试。成功率会下降，而响应时间也会开始受到影响。此外，在测试期间阻塞在推荐服务上的&lt;code&gt;goroutine&lt;/code&gt;数量将急剧增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐服务的停工时间影响了终端用户，因为本来可以提供给他的电影feed列表都没有提供。这正是级联故障对我们的系统造成的影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;熔断器救援&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断器是一个非常简单但相当重要的概念，因为它可以让我们保持服务的高可用性。熔断器有三种状态:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭状态是指数据通过的时候连接处关闭的状态。这是我们的理想状态，其中上游服务正如预期的那样工作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7614035087719299&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB0BhqXxRjFp07HS5dIRhJpvz5Ub8NJIayEicgmvD0XKvWaFkXCDne3FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开状态指的是由于上游服务未按预期响应而导致电路短路的状态。这种短路可以避免上游服务在已经挣扎的情况下不堪重负。此外，下游服务的业务逻辑可以更快地获得上游可用性状态的反馈，而无需等待上游的响应。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9162303664921466&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBoicHzjLC5WEBJfKKglhjvFsNmY8DrDMwia8Y5TF9RfPGeGbQ0E65JIiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Half Open State&lt;/strong&gt; 半开状态&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9294117647058824&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBUGNym8GFg8kkhms5CRdOFpxhia49hbaSxeFA4rojfQxib87NjKh4EseQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果熔断器是打开状态，我们希望它在上游服务再次可用时立即关闭它。虽然你可以通过手动干预来实现，但首选的方法应该是在电路最后一次打开，让一些请求延迟之后通过电路，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这些请求请求上游服务成功，我们就可以安全地接通整个链路。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9275123558484349&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB51zWicyecmQDdstqiccUKC1icuqaBMqgegOfAqNgBu3bOE2xkEVbdh5uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，如果这些请求失败，熔断器仍然处于打开状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断器的状态图如下:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9530916844349681&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgB4c5JJ7pJUha3sz398gSQKQfRGfy0c2xiaNYJyGfeNiaNWK7kKSpRETkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始状态下熔断器是关闭的，当故障超过配置的阈值，则会打开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;熔断器是打开状态，在经过一段熔断时间后，部分会打开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果熔断器是半开的，它可以&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;再次打开，如果允许通过的请求也失败了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭，如果允许通过的请求成功响应&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;熔断器在 Golang 的应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然有多个库可供选择，但最常用的是 &lt;span&gt;hystrix&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。正如文档建议的那样，hystrix 是 Netflix 设计的一个延迟和容错库，用于隔离远程系统、服务和第三方库的访问，阻止级联故障，并在不可避免的故障发生的复杂分布式系统中实现恢复能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hystrix 熔断器的实现取决于以下配置:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;超时 ー 上游服务响应的等待时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大并发请求 ー 上游服务允许调用的最大并发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求容量阈值 ー 在熔断之前的请求数，断路器在需要更改状态时无法评估的请求数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;睡眠窗口 ー 开放状态与半开放状态之间的延迟时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;误差百分比阈值ー熔断器短路时的误差百分比阈值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来让我们在电影和推荐示例中使用它，并在获取推荐时实现熔断器模式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var downstreamErrCount int&lt;br/&gt;var circuitOpenErrCount int&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; downstreamErrCount = 0&lt;br/&gt; circuitOpenErrCount = 0&lt;br/&gt; hystrix.ConfigureCommand(&lt;span&gt;&quot;recommendation&quot;&lt;/span&gt;, hystrix.CommandConfig{&lt;br/&gt;  Timeout: 100,&lt;br/&gt;  RequestVolumeThreshold: 25,&lt;br/&gt;  ErrorPercentThreshold:  5,&lt;br/&gt;  SleepWindow:            1000,&lt;br/&gt; })&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/movies&quot;&lt;/span&gt;, fetchMoviesFeedHandlerWithCircuitBreaker)&lt;br/&gt; log.Fatal(http.ListenAndServe(&lt;span&gt;&quot;:8080&quot;&lt;/span&gt;, nil))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func fetchMoviesFeedHandlerWithCircuitBreaker(w http.ResponseWriter, r *http.Request) {&lt;br/&gt; mr := MovieResponse{&lt;br/&gt;  Feed: []string{&lt;span&gt;&quot;Transformers&quot;&lt;/span&gt;, &lt;span&gt;&quot;Fault in our stars&quot;&lt;/span&gt;, &lt;span&gt;&quot;The Old Boy&quot;&lt;/span&gt;},&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; output := make(chan bool, 1)&lt;br/&gt; errors := hystrix.Go(&lt;span&gt;&quot;recommendation&quot;&lt;/span&gt;, func() error {&lt;br/&gt;  // talk to other services&lt;br/&gt;  rms, err := fetchRecommendations()&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;  }&lt;br/&gt;  mr.Recommendation = rms&lt;br/&gt;  output &amp;lt;- &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt; }, func(err error) error {&lt;br/&gt;     // 写你的fallback(兜底)逻辑&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; select {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; err := &amp;lt;-errors:&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err == hystrix.ErrCircuitOpen {&lt;br/&gt;   circuitOpenErrCount = circuitOpenErrCount + 1&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   downstreamErrCount = downstreamErrCount + 1&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; _ = &amp;lt;-output:&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; bytes, err := json.Marshal(mr)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  w.WriteHeader(500)&lt;br/&gt; }&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;\ndownstreamErrCount=%d, circuitOpenErrCount=%d&quot;&lt;/span&gt;, downstreamErrCount, circuitOpenErrCount)&lt;br/&gt; w.Write(bytes)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Hystrix，您还可以在熔断器打开时实现兜底逻辑。这种逻辑可能因情况而异。如果熔断器打开，则从缓存中获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个更新的逻辑，让我们尝试以每秒100个请求的速率重新攻击 3 秒钟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哇! ！100% 的成功率，在打开的情况下，我们只提供 Feed 和返回 0个推荐。此外，由于每当熔断器熔断，我们不再调用上游服务，因此推荐服务不会不堪重负，阻塞的 goroutine 数量不会像以前那么多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扩展阅读&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的建议:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关于 Netflix Hystrix&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Hystrix 是怎样工作的？&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Hystrix bucketing&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.81328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqa5dSIH3gibmwLbeqnaibsPgBgxQ2I3OXoIPx2umXAPzBHwRXaic01CaPRDr0vFaqy6Dib9DYXVKs24Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;sup/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;hystrix: &lt;span&gt;https://github.com/afex/hystrix-go/hystrix&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;关于 Netflix Hystrix: &lt;span&gt;https://github.com/Netflix/Hystrix/wiki&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;Hystrix 是怎样工作的？: &lt;span&gt;https://github.com/Netflix/Hystrix/wiki/How-it-Works&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;Hystrix bucketing: &lt;span&gt;https://raw.githubusercontent.com/wiki/Netflix/Hystrix/images/circuit-breaker-1280.png&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9eed8c5fa68f2a857b8ce912c4ec1bc</guid>
<title>[推荐] 推荐两款超实用的 gRPC 客户端调试工具</title>
<link>https://toutiao.io/k/622rri2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5SNVibS2GEO9xecx5Easr5WvO40Lb3PkkykLL9BmicibsDGYTtycbMOwGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图片拍摄于2021年7月10日，湖州安吉。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;介绍&lt;/h3&gt;&lt;p md-src-pos=&quot;108..158&quot;&gt;&lt;span&gt;正好看到董泽润老哥一篇关于使用&lt;/span&gt;&lt;code md-src-pos=&quot;126..137&quot;&gt;&lt;span&gt;WireShark&lt;/span&gt;&lt;/code&gt;&lt;span&gt;分析&lt;/span&gt;&lt;code md-src-pos=&quot;141..147&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;流量的文章&lt;/span&gt;，&lt;span&gt;学到了。原文地址:&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5MTYyNzM3OQ==&amp;amp;mid=2247484266&amp;amp;idx=1&amp;amp;sn=624672bb75251908072931f161be7d8c&amp;amp;chksm=cfcb3176f8bcb860edd532a80af4fd9fad9650bf9e84436cd1e13fa54c8c62bd50b931650584&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;小技巧！Wireshark 让调试 grpc 不再困难&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;160..194&quot;&gt;&lt;span&gt;那我就介绍使用过的两款&lt;/span&gt;&lt;code md-src-pos=&quot;178..184&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;客户端调试工具吧&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;Evans&lt;/h3&gt;&lt;p md-src-pos=&quot;206..271&quot;&gt;&lt;code md-src-pos=&quot;206..213&quot;&gt;&lt;span&gt;Evans&lt;sup&gt;[1&lt;/sup&gt;&lt;sup&gt;]&lt;/sup&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;有两种运行模式&lt;/span&gt;：&lt;/span&gt;&lt;code md-src-pos=&quot;220..226&quot;&gt;&lt;span&gt;REPL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code md-src-pos=&quot;229..234&quot;&gt;&lt;span&gt;CLI&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;206..271&quot;&gt;&lt;span&gt;&lt;span&gt;比起其他&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;240..246&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;客户端,&lt;code md-src-pos=&quot;206..213&quot;&gt;Evans&lt;/code&gt;更具有表现力，并且它还支持自动补全功能。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;273..307&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;code md-src-pos=&quot;206..213&quot;&gt;&lt;span&gt;Evans&lt;/span&gt;&lt;/code&gt;的安装非常方便&lt;/span&gt;，&lt;span&gt;在&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;284..289&quot;&gt;&lt;span&gt;Mac&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;上我们只需要执行以下两行命令即可&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6306818181818182&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5o89yRVibBB62AgdwMsRHAibf8V5cSMwugYsy4CyLia9qhgZT9K6lr7VJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;365..383&quot;&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;365..383&quot;&gt;&lt;span&gt;我们来学习一下&lt;/span&gt;&lt;code md-src-pos=&quot;373..379&quot;&gt;&lt;span&gt;REPL&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;模式&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;385..485&quot;&gt;&lt;span&gt;首先我们需要有一个&lt;/span&gt;&lt;code md-src-pos=&quot;395..399&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;文件，假设你的文件在&lt;/span&gt;&lt;code md-src-pos=&quot;411..426&quot;&gt;&lt;span&gt;api/api.proto&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;我们只需要这样：&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7858672376873662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5RoBztNZ2AG2TiaTyFlUex6voEVyamfQxfzyh4b7qVj9TM1ic5GK1dNQg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;934&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;385..485&quot;&gt;&lt;span&gt;默认地址为&lt;/span&gt;&lt;code md-src-pos=&quot;493..510&quot;&gt;&lt;span&gt;127.0.0.1:50051&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;当然你可以通过&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;519..527&quot;&gt;&lt;span&gt;--host&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code md-src-pos=&quot;530..538&quot;&gt;&lt;span&gt;--port&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来指定服务器。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9702127659574468&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5FxxeztTlChp2TswzU7KcId6SRia4oWc3FPGvf0LdRfQGPxQUibd7nVjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;598..604&quot;&gt;&lt;span&gt;&lt;span&gt;上图的命令&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;&lt;ul md-src-pos=&quot;605..702&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;608..622&quot;&gt;&lt;span&gt;show package&lt;/span&gt;&lt;/code&gt;&lt;span&gt;读取&lt;/span&gt;&lt;code md-src-pos=&quot;626..630&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;包名&lt;/span&gt;，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;637..651&quot;&gt;&lt;span&gt;show service&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;显示对应服务列表&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code md-src-pos=&quot;665..675&quot;&gt;&lt;span&gt;call xxx&lt;/span&gt;&lt;/code&gt;&lt;span&gt;调用&lt;/span&gt;&lt;code md-src-pos=&quot;679..685&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;服务&lt;/span&gt;......&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;.....&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p md-src-pos=&quot;704..716&quot;&gt;&lt;span&gt;&lt;span&gt;更多命令可自行查阅官网&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;718..861&quot;&gt;&lt;span&gt;除了上述这种直接引入&lt;/span&gt;&lt;code md-src-pos=&quot;729..733&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;文件外，我们还可以通过&lt;/span&gt;&lt;code md-src-pos=&quot;746..752&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;反射包&lt;/span&gt;(&lt;/span&gt;&lt;code md-src-pos=&quot;757..769&quot;&gt;&lt;span&gt;reflection&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)， &lt;span&gt;将&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;774..787&quot;&gt;&lt;span&gt;grpc.Server&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;注册到反射服务中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;718..861&quot;&gt;&lt;span&gt;这样的话，就可以通过&lt;/span&gt;&lt;code md-src-pos=&quot;809..821&quot;&gt;&lt;span&gt;reflection&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;提供的反射服&lt;/span&gt;务&lt;span&gt;查询到对应的&lt;/span&gt;&lt;/span&gt;&lt;code md-src-pos=&quot;836..842&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;服务，或者直接调用&lt;/span&gt;&lt;code md-src-pos=&quot;850..856&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;服务&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;863..871&quot;&gt;&lt;span&gt;注册反射服务操作也很简单，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.701123595505618&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y54g0tMroG31tA4kzTViaS5Z9uKelFN7iciaXdEYMv3oCjnnvDdSE7ta4Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;863..871&quot;&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1021..1098&quot;&gt;&lt;span&gt;回到&lt;/span&gt;&lt;code md-src-pos=&quot;1024..1031&quot;&gt;&lt;span&gt;Evans&lt;/span&gt;&lt;/code&gt;&lt;span&gt;工具， 如果一个&lt;/span&gt;&lt;code md-src-pos=&quot;1041..1047&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;服务注册了反射，我们就可以使用&lt;/span&gt;&lt;code md-src-pos=&quot;1064..1083&quot;&gt;&lt;span&gt;-r&lt;/span&gt;&lt;/code&gt;&lt;span&gt;选项来启动&lt;/span&gt;&lt;code md-src-pos=&quot;1090..1097&quot;&gt;&lt;span&gt;Evans&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1100..1158&quot;&gt;&lt;span&gt;比如像下面这样&lt;/span&gt;： &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6867469879518072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5SkPqgIfCn4YbiaBRhJbKnjUO2iaoUkSSGgLWTicpvRuMwrpyOLou0Ogicw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1100..1158&quot;&gt;&lt;span&gt;对另外一种模式感兴趣的可以自行查看官网，这里不再演示。&lt;/span&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 md-src-pos=&quot;181..187&quot;&gt;BloomRPC&lt;/h3&gt;&lt;p md-src-pos=&quot;1175..1215&quot;&gt;&lt;code md-src-pos=&quot;1175..1185&quot;&gt;&lt;span&gt;BloomRPC&lt;sup&gt;[2&lt;/sup&gt;&lt;sup&gt;]&lt;/sup&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是一个简单的&lt;/span&gt;&lt;code md-src-pos=&quot;1192..1197&quot;&gt;&lt;span&gt;GUI&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;客户端工具，使用这个那就更简单了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1217..1289&quot;&gt;&lt;span&gt;只需要导入&lt;/span&gt;&lt;code md-src-pos=&quot;1223..1227&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;文件，然后点两下即可&lt;/span&gt;。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.552821997105644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkVfNnnUQnlHs65Y8RHabCwhUJERZ5Y5ggXIlBBuBRpJTg8IGFibthsHuDPEZJ2MBp3UeUhib2ibsT1kJUcxSW5Rg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1382&quot;/&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1291..1321&quot;&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1291..1321&quot;&gt;&lt;span&gt;当然有个不好点在于，每次修改了&lt;/span&gt;&lt;code md-src-pos=&quot;1307..1311&quot;&gt;&lt;span&gt;pb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;span&gt;都不得不重新导入&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p md-src-pos=&quot;1291..1321&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;1324..1330&quot;&gt;总结&lt;/h3&gt;&lt;p md-src-pos=&quot;1331..1410&quot;&gt;&lt;span&gt;以上介绍了两款&lt;/span&gt;&lt;code md-src-pos=&quot;1339..1345&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;客户端工具。不知道你们平常都使用&lt;/span&gt;&lt;code md-src-pos=&quot;1363..1369&quot;&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;哪些周边工具，欢迎一起讨论&lt;/span&gt;。&lt;/p&gt;&lt;h3 md-src-pos=&quot;1324..1330&quot;&gt;相关文章推荐&lt;/h3&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247483901&amp;amp;idx=1&amp;amp;sn=807de1cd6962dd1ccc53e8b5ec75a5b0&amp;amp;chksm=fa80d06acdf7597c5c28884216b70bbc7f5e266443d47cdc04ffad9767803dbf264f31313472&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;gRPC入门教程汇总&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247487354&amp;amp;idx=1&amp;amp;sn=f2f1121193603f69c9fde18ece2c71b9&amp;amp;chksm=fa80deedcdf757fbfa3ce5393d473bc2a79447466423c81ee2c8feb9091825afa1a0311af985&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Interceptor拦截器 -- gRPC生态里的中间件&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486329&amp;amp;idx=1&amp;amp;sn=04cf6ab2613ac1174808fa727b18212f&amp;amp;chksm=fa80daeecdf753f8c4625bc522bce5960383da9eadf2edd5ef57a8ae384c99f7ebb45d43e397&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;gRPC服务注册发现及负载均衡的实现方案与源码解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 md-src-pos=&quot;8529..8535&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 md-src-pos=&quot;8529..8535&quot;&gt;&lt;span&gt;附录&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;span&gt;https://github.com/ktr0731/evans&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;span&gt;https://github.com/uw-labs/bloomrpc&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果文章对你有所帮助，点赞、转发&lt;strong&gt;、&lt;/strong&gt;留言都是一种支持！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span data-darkmode-color-16222629164135=&quot;rgb(160, 160, 160)&quot; data-darkmode-original-color-16222629164135=&quot;#fff|rgb(160, 160, 160)&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>182ad916374f8cd6e8c4d0c69398d50b</guid>
<title>[推荐] 简单的 Postman，还能玩出花？</title>
<link>https://toutiao.io/k/94q54nm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postman是一款我们在工作中使用频率非常高的API调试工具，估计很多童鞋在使用它时也比较粗暴，填好接口地址、参数，直接send就完事了，估计大家要说了，这么简单的东西还能玩出什么花来。今天就和大家安利几个非常实用、但是可能一直被忽视的功能，用完之后，简直不要太香！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;环境变量&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一个例子来看一下环境变量的用法，在一个项目的生命周期中，可能会有开发环境、测试环境、预上线环境、线上环境等众多的不同环境，这时候就可以通过环境变量来管理接口的地址以及端口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击左侧的&lt;code&gt;Environments&lt;/code&gt;，系统中默认已经存在了一个&lt;code&gt;Globals&lt;/code&gt;的全局环境，在这里可以存放一些通用的公共变量的值。先在这里写入&lt;code&gt;host&lt;/code&gt;和&lt;code&gt;port&lt;/code&gt;信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40132827324478176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDodsJRLuibttrK5fB6XMSKfUw479Xg87jJglIggpp20ZxL4xb1gOkyx9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要使用变量时，可以在访问接口时使用双大括号包裹变量，以&lt;code&gt;{{variable}}&lt;/code&gt;的方式进行引用：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42005420054200543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDo318tNtAia9ZcnqQib54InyvJ2nNbmau6TpXfDrsge77ggUKK7YIia9iaMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了默认的全局环境外，也可以自己创建新的环境来存放变量。在下面的例子中，创建了&lt;code&gt;local&lt;/code&gt;和&lt;code&gt;test&lt;/code&gt;两个环境，这样我们可以直接在两个环境间进行切换激活，简化了开发中测试接口的过程，不再需要频繁的改动接口的地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2954063604240283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoEx2iao3B5ElM2Z5c0vrJh0YiaVy4dJSHm3KuHicuJLdSdtkB0HIicKicrpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1415&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果激活的环境和全局环境中有名称重复的变量，那么当前激活的环境中的变量具有更高的优先级，它会直接覆盖&lt;code&gt;globals&lt;/code&gt;环境中变量的值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7780104712041885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDobKWDzqgMPDkmw2SlZJx2gzhzib0ibTQBJpT6aYyB85FibJNsIO2mJcgGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;955&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面，我们将环境变量分为了两类，普通环境变量和全局变量。总的来说，全局变量具有更高的使用范围，即使切换到自己创建的环境，全局变量仍然可用。但是我们自己创建的环境之间是相互隔离的，如果切换到一个环境，那么其他环境中的变量将不再可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像上面这样手动写入变量的值，在某些时候可能不太方便满足一些需求，因此postman提供了一种方法，允许使用脚本来改变环境变量的值。我们来看一下发送请求中的&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;模块，它们是在请求发送前或完成后执行的脚本，具体的使用在后面具体介绍，现在我们只需要知道能在这里执行js代码就可以了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3506311360448808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoSB7LpO5Bf4NiaLlWXibw1NN3d1C5xLoTmOavj4Omzzw6FSsHPmLzugiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，在&lt;code&gt;Pre-request Script&lt;/code&gt;中加入两行js代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.globals.set(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;,&lt;span&gt;&quot;value1&quot;&lt;/span&gt;);&lt;br/&gt;pm.environment.set(&lt;span&gt;&quot;key2&quot;&lt;/span&gt;,&lt;span&gt;&quot;value2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完成请求后再次查看环境变量，全局环境和当前环境中都写入了新的值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.536547433903577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoVj7vo3FYicdiag0LcFCf7RvDdqSJFick8M1SyECxI6ttoQTqia4icxODRAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，也可以使用脚本删除变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.globals.unset(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;);&lt;br/&gt;pm.environment.unset(&lt;span&gt;&quot;key2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的两类变量外，postman中的&lt;code&gt;Collection&lt;/code&gt;也可以存储变量。&lt;code&gt;Collection&lt;/code&gt;可以理解为一个集合，通常在使用中我们会将一个应用系统中的接口放在一个集合中，集合中的变量拥有更小的使用范围，仅在当前集合内可用：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24489795918367346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoiaXrOPxm1xLScqvLzamUkicuKtakBXlibGa71acA3he1470IkmP27q5MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，也可以在脚本中对它进行操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.collectionVariables.set(&lt;span&gt;&quot;key3&quot;&lt;/span&gt;,&lt;span&gt;&quot;value3&quot;&lt;/span&gt;);&lt;br/&gt;pm.collectionVariables.unset(&lt;span&gt;&quot;key3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有了环境变量的基础后，再回头看一下上面提到的&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;，它们是两个比较类似的功能，用处也非常广泛。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Pre-request Script&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;运行js脚本&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pre-request Script&lt;/code&gt;可以翻译为预请求脚本，是在请求发送前被执行的代码逻辑，可以在这里执行一些&lt;code&gt;js&lt;/code&gt;代码。通过下面的简单例子进行一下演示，先准备一个后台接口，将前端传递过来的时间戳转换为时间并打印：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(@RequestParam(&lt;span&gt;&quot;time&quot;&lt;/span&gt;)&lt;/span&gt; String time)&lt;/span&gt;{&lt;br/&gt;     Date date = &lt;span&gt;new&lt;/span&gt; Date(Long.parseLong(time));&lt;br/&gt;     System.out.println(date);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Pre-request Script&lt;/code&gt;中利用js代码获取当前时间，并放到集合变量中，在请求中传给后端：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34386391251518833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoCTmuX5U6kUeISPmGiazibLlqgM5GJCmVDFGThV1zXMYxiczOwVPuuNOqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送请求，控制台打印了前端接口的调用时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Tue Aug 01 14:14:29 CST 2021&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;发送get请求&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pre-request Script&lt;/code&gt;的另一大用途就是，在请求当前接口前，通过执行脚本来先请求一下其他接口。在postman中，已经内置了&lt;code&gt;sendRequest&lt;/code&gt;方法来发送&lt;code&gt;get&lt;/code&gt;方法请求。我们在这里调用一个本地接口，并将信息打印到&lt;code&gt;console&lt;/code&gt;控制台（可以通过 &lt;code&gt;Show Postman Console&lt;/code&gt;开启）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28221343873517785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoPPlnfEJVfIyncLq416jWNQxW31ZbwNelrHgzekXLzbOZFVvR8AibqVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1265&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过控制台的打印顺序，也可以看到，是在先执行了&lt;code&gt;Pre-request&lt;/code&gt;中的请求后，才去执行的真正目标接口的请求。直接像上面这样调用&lt;code&gt;sendRequest&lt;/code&gt;时，默认发送的&lt;code&gt;get&lt;/code&gt;的请求，如果需要使用&lt;code&gt;post&lt;/code&gt;请求、配置请求&lt;code&gt;header&lt;/code&gt;或使用&lt;code&gt;json&lt;/code&gt;传参的话，可以使用下面单独封装请求的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;发送post请求&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，我们通过一个例子来演示&lt;code&gt;Pre-request Script&lt;/code&gt;在具体的工作中能够怎样应用。有一个很普遍的场景，通常在调试需要权限认证的接口时，需要提前通过一个接口获取token，然后再访问目标接口时携带这个token。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就可以在&lt;code&gt;Pre-request Script&lt;/code&gt;中先调用获取token的接口，再将token设置到集合的环境变量中，在之后的接口调用中引用它。在这里先准备了一个应用了&lt;code&gt;Shiro+JWT&lt;/code&gt;的项目，其中通过登录接口获取token，之后的其他接口都需要带上这个token用于认证 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在&lt;code&gt;sendRequest&lt;/code&gt;发送&lt;code&gt;get&lt;/code&gt;请求的基础上，进行一些修改。首先定义一个变量，在其中使用&lt;code&gt;url&lt;/code&gt;指定请求地址，&lt;code&gt;method&lt;/code&gt;指定请求方法，&lt;code&gt;body&lt;/code&gt;携带参数，最后使用&lt;code&gt;sendRequest&lt;/code&gt;进行请求的发送。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47566182749786506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoTXTCct1PunhU6UnNhX7Tib9ibveTeo2n7PELXoaGmadl4mEUr2uGhvow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1171&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在获取完成token后，通过下面的代码将获取的token放入了&lt;code&gt;Collection&lt;/code&gt;的变量中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.collectionVariables.set(&lt;span&gt;&quot;TOKEN&quot;&lt;/span&gt;,response.json().data.token);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看&lt;code&gt;Collection&lt;/code&gt;中的变量，已经保存了刚才获取的token：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3617407071622847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoexhRpgNGBpFZeQOow3bpYBDuGcG95QafSQ6QcDqBq0xtrH0ayxayug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1103&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要认证的接口&lt;code&gt;header&lt;/code&gt;中，引用这个token，就可以正常的调用接口了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6576271186440678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoXshQwMc6IXgGKOhMZKtDialHgQs2qXM0FWucohbhppsRjTb7rsnG7RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的例子中，我们使用的是&lt;code&gt;urlencoded&lt;/code&gt;的表单传参方式，如果接口定义是使用json方式传参，可以写成下面的格式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;body: {&lt;br/&gt;  &lt;span&gt;mode&lt;/span&gt;: &lt;span&gt;&#x27;raw&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;raw&lt;/span&gt;: &lt;span&gt;JSON&lt;/span&gt;.stringify({ &lt;span&gt;key&lt;/span&gt;: &lt;span&gt;&#x27;value&#x27;&lt;/span&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要传递&lt;code&gt;header&lt;/code&gt;请求头信息，也可以在自定义的请求中添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; loginRequest = {&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;...&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;header&lt;/span&gt;: [&lt;br/&gt;      &lt;span&gt;&#x27;Key1 : Value1&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;Key2 : Value2&#x27;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  ...&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的使用中需要添加什么字段非常的灵活，可以由我们自行进行配置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Tests&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;code&gt;Pre-request Script&lt;/code&gt;相对，&lt;code&gt;Tests&lt;/code&gt;是在请求完成后执行的操作。这里我们回顾一下上面&lt;code&gt;Pre-request Script&lt;/code&gt;中发送&lt;code&gt;post&lt;/code&gt;请求的例子，其实可以通过&lt;code&gt;Tests&lt;/code&gt;来进行改进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在上面的例子中，获取到的token是&lt;code&gt;JWT&lt;/code&gt;生成的，具有一定有效时间，在一段时间内是都可以复用的。因此我们可以先手动调用一次&lt;code&gt;login&lt;/code&gt;接口获取token，完成后在&lt;code&gt;Tests&lt;/code&gt;中使用脚本将获取的token放入&lt;code&gt;Collection&lt;/code&gt;的变量中，就不需要在每次调用接口前都调用&lt;code&gt;login&lt;/code&gt;接口重复获取token了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用&lt;code&gt;login&lt;/code&gt;接口并存入缓存的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41159695817490494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDovdAGuyMXdaqxK4JgSEz86S5OSI5ic231mZeaNicjfH8daREoVvSicASaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后在调用其他需要携带这个token的接口时，使用&lt;code&gt;{{TOKEN}}&lt;/code&gt;的方式，就会自动填充刚才保存的&lt;code&gt;TOKEN&lt;/code&gt;值。这样在获取到新的token后，每个接口中的token都会自动更新，就不需要再手动复制到每个接口了，极大的减少了工作量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在postman中，在&lt;code&gt;Collection&lt;/code&gt;中可以创建&lt;code&gt;Folder&lt;/code&gt;文件夹，并且集合和文件夹上也可以添加&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;脚本。我们来看一下位于&lt;code&gt;Folder&lt;/code&gt;中的请求，在执行&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;时顺序是怎样的，在每个环节中加入对应的打印语句，最后输出的结果是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6504424778761062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoHqWmkM8wACqLhrypMkcicCu85o12JZ4Jzo6eZFfVaS6VOoibRW7qvCPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;452&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，在发送请求前，postman会先执行所有&lt;code&gt;Pre-request Script&lt;/code&gt;，并且顺序是集合最先、文件夹次之、最后是请求中的，在执行完成真正的请求后执行所有的&lt;code&gt;Tests&lt;/code&gt;，顺序同上。这也就要求我们在使用&lt;code&gt;Pre-request Script&lt;/code&gt;及&lt;code&gt;Tests&lt;/code&gt;功能前，首先要求我们对接口的调用顺序、数据的流向有一个明确的了解，这样才能保证不会出现取不到值或更新错误的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9358638743455497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoiat3YsiacTibBr4CHXFxAicaTWw9f72U4AGch8wbj1seRRRG1nEJAznwiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;764&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b85a46037cf9a10b536b4002c45d7933</guid>
<title>[推荐] 面试必问的 ThreadLocal 细节，其他文章里写的真的对吗？</title>
<link>https://toutiao.io/k/12dqepa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;ThreadLocal的作用是什么？使用时有哪些注意事项？为什么ThreadLocalMap中的Entry要使用WeakReference？netty中FastThreadLocal又做了什么优化？答案尽在本文中。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;用ThreadLocal&lt;/span&gt;&lt;t&gt;&lt;span&gt;修饰的变量，一般我们&lt;/span&gt;称&lt;span&gt;为线程本地变量。&lt;/span&gt;&lt;span&gt;那么一般什么情况下&lt;/span&gt;会&lt;span&gt;使用ThreadLocal呢？&lt;/span&gt;&lt;/t&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;解决线程安全问题。线程安全问题一般是多个线程对共享可变变量变量的修改问题，那么如果线程之间不共享变量，自然就解决了这个问题，通过线程本地变量就可以不共享，每个线程只能获取到自己的线程本地变量，线程间互不打扰。比如&lt;code&gt;java.text.SimpleDateFormat&lt;/code&gt;不是线程安全的，如果多个线程都使用同一个SimpleDateFormat对象进行日期操作，则会出现线程安全问题。一种解决方案就是把SimpleDateFormat对象进行ThreadLocal封装，代码示例如下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt; simpleDateFormat = ThreadLocal.withInitial(SimpleDateFormat::&lt;span&gt;new&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    simpleDateFormat.get().format(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同一线程内代码间传递上下文信息 在一些框架中，需要在不同的代码间传递信息，比如分布式追踪(tracing)框架一般都需要在各个开源框架中进行埋点上报，比如上报一个请求处理开始和请求处理结束的埋点，但是如果开始和请求在不同的方法中，该怎么不修改框架方法参数实现埋点串联id的传递呢？通过通过ThreadLocal我们就可以实现id的透传；spring在aop、事务等功能中都使用了ThreadLocal来进行线程内方法间的对象传递 ; 在业务代码中，也经常会用ThreadLocal传递一些公共参数比如请求的用户id，这样可以减少参数的传递。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal的方法和使用介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;ThreadLocal提供的方法有get(),set(T value), remove()，并且有一个可以override的initialValue()方法。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;&lt;th&gt;方法介绍&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;get&lt;/td&gt;&lt;td&gt;获取这个ThreadLocal在当前线程内的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set(T value)&lt;/td&gt;&lt;td&gt;设置这个ThreadLocal在当前线程内的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;删除这个ThreadLocal在当前线程内的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;initialValue()&lt;/td&gt;&lt;td&gt;如果这个ThreadLocal在当前线程内没有值，会通过initialValue()进行初始化，默认返回null。可以通过匿名内部类或Thread.withInitial(Supplier&amp;lt;? extends S&amp;gt; supplier)实现override initialValue()方法&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;一般我们定义ThreadLocal变量都定义成static final的变量，然后就可以通过这个ThreadLocal变量进行get set了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt; simpleDateFormat = ThreadLocal.withInitial(SimpleDateFormat::&lt;span&gt;new&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    simpleDateFormat.get().format(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;了解了ThreadLocal的作用后，我们开始分析一下内部实现。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6752232142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfAhkMkS9hMY3Oyx53T7SBT1bPD6XNbgPVK4defYY1wKLtnlZdlPGVSia4ugGfBg8HWLWlpALoLHMyXotffED7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先，每个线程Thread对象内有一个ThreadLocalMap类型的threadLocals字段，里面保存着key为ThreadLocal到value为Object的映射。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;&lt;/span&gt;{ &lt;br/&gt;    &lt;span&gt;/* ThreadLocal values pertaining to this thread. This map is maintained&lt;br/&gt;     * by the ThreadLocal class. */&lt;/span&gt;&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ThreadLocal的get,set,remove方法都是通过操作当前线程内的ThreadLocalMap字段实现的，操作的key为自己(this)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每个ThreadLocal的hashCode，用来在ThreadLocalMap中寻找自己的位置。ThreadLocalMap使用的是线性探查的开放寻址法解决hash冲突而不是HashMap中的链表法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadLocalHashCode = nextHashCode();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 用来生成分配ThreadLocal的hashCode的AtomicInteger&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger nextHashCode =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// AtomicInteger每次增加的间隔，0x61c88647这个魔数在映射到2的次方的数组中能够保证比较高好的分散性，减少冲突&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// https://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HASH_INCREMENT = &lt;span&gt;0x61c88647&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 生成hashCode，在ThreadLocal对象构造的时候（构造代码块中）调用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextHashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nextHashCode.getAndAdd(HASH_INCREMENT);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 覆盖initialValue()可以定制ThreadLocal的默认值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; T &lt;span&gt;initialValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取当前线程Thread对象&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt; &lt;span&gt;// 从Thread对象拿到ThreadLocalMap字段&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt; &lt;span&gt;// 如果map不为空，从map中尝试获取当前ThreadLocal对应的value值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                T result = (T)e.value;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt; &lt;span&gt;// map为空，或者map中没有找到当前ThreadLocal对应的value的映射，则会进行创建ThreadLocalMap、在map中设置初始默认值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setInitialValue();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; T &lt;span&gt;setInitialValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        T value = initialValue();&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            createMap(t, value);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; &lt;span&gt;instanceof&lt;/span&gt; TerminatingThreadLocal) {&lt;br/&gt;            TerminatingThreadLocal.register((TerminatingThreadLocal&amp;lt;?&amp;gt;) &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取当前Thread，从中取出ThreadLocalMap&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;// map不空则调用map的set设置当前ThreadLocal到value的映射&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;// map为空则创建包含当前ThreadLocal到value映射的map&lt;/span&gt;&lt;br/&gt;     createMap(t, value);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         ThreadLocalMap m = getMap(Thread.currentThread());&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (m != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 从当前map中删除映射&lt;/span&gt;&lt;br/&gt;             m.remove(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;         }&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;ThreadLocalMap &lt;span&gt;getMap&lt;/span&gt;&lt;span&gt;(Thread t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; t.threadLocals;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;createMap&lt;/span&gt;&lt;span&gt;(Thread t, T firstValue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        t.threadLocals = &lt;span&gt;new&lt;/span&gt; ThreadLocalMap(&lt;span&gt;this&lt;/span&gt;, firstValue);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的ThreadLocal的实现中大部分都是对ThreadLocalMap的操作封装，那么ThreadLocalMap是怎么实现的呢？ThreadLocalMap是ThreadLocal类的静态内部类。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;线性探查法的Map&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ThreadLocalMap和HashMap有所不同，ThreadLocalMap使用线性探查法而不是拉链法解决hash冲突问题。&lt;/p&gt;&lt;p&gt;线性探查法可以用一个小例子来理解，想象一个停车场的场景，停车场中有一排停车位，停车时，会计算车子的hashCode算出在停车位中的序号，停上去，如果那个车位有车了， 则尝试停到它的下一个车位，如果还有车则继续尝试，到末尾之后从头再来。当取车时，则按照hashCode去找车，找到对应的位置后，要看一下对应的车位上是不是自己的车，如果不是， 尝试找下一个车位，如果找到了自己的车，则说明车存在，如果遇到车位为空，说明车不在。要开走车时，不光是简单开走就可以了，还得把自己车位后面的车重新修改车位，因为那些车可能因为 hash冲突更换了位置，修改车位的范围是当前位置到下一个为空的车位位置。当然还有扩容的情况，后面代码里会具体介绍。&lt;/p&gt;&lt;p&gt;那么为什么使用线性探测法而不是链表法呢？主要是因为数组结构更节省内存空间，并且一般ThreadLocal变量不会很多，通过0x61c88647这个黄金分割的递增hashCode也能比较好的分布在数组上减少冲突。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;使用WeakReference引用ThreadLocal对象&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Map中的元素用一个Entry类表示，Entry包含了对ThreadLocal的WeakReference，以及对ThreadLocal值的强引用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Map中的Entry，也是数组中的元素，会使用WeakReference引用ThreadLocal对象，value的对象是默认的强引用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    Object value;&lt;br/&gt;&lt;br/&gt;    Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;        value = v;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么使用WeakReference对象引用呢? 很多文章都提到内存泄漏，但是都没有说明白具体是什么样的内存泄漏，不少文章写道是因为value是强引用，如果线程一直存活会一直让value释放不了，这个其实并不准确，因为如果ThreadLocal字段是static的，这个static变量对象的声明周期和class对象是一致的，而class对象出现卸载的条件非常少，大部分类加载后一直存活，因此即使Entry声明成WeakReference，GC后static的ThreadLocal对象也不会被回收。原因究竟是为什么呢？这个要从要求ThreadLocal变量声明成static final说起。如果不是static final，比如是实例字段，则这个ThreadLocal字段可能会出现非常多个ThreadLocal实例，而不是静态常量一样一个classloader内只有一个。如果有非常多ThreadLocal实例，想想ThreadLocal的实现，是在线程内有一个Map保存ThreadLocal到value的映射。这样即使ThreadLocal实例对象已经不使用了，只要Thread对象存活，被引用的对象就无法释放。这就是使用WeakReference的原因，WeakReference引用不会影响对象被GC。这样gc后会清理掉ThreadLocalMap中已经失效的映射。也就是当我们没有正确使用ThreadLocal时（没有使用static字段），是可能出现内存泄露的，因为ThreadLocalMap中保存了对ThreadLocal的引用，ThreadLocalMap通过WeakReference以及清理机制在一定程度上缓解了这个问题。&lt;/p&gt;&lt;p&gt;下面用一段代码来阐述一下。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;&lt;span&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; People().say();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;People&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; AtomicInteger counter = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; threadLocal = ThreadLocal.withInitial(() -&amp;gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt; + counter.getAndIncrement());&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(threadLocal.get());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们创建了一个People类，并且创建了一个类型为ThreadLocal&lt;string&gt;的实例字段，我们在main方法中连续调用say()方法，会发现打印出来的threadLocal的值是不一样的，虽然我们这些调用都在 同一个线程中，但是因为每次调用的ThreadLocal对象是不同的，也就是ThreadLocalMap的key不相同。如果我们把ThreadLocal字段加上static，就会发现打印出来的都是相同的值了。长时间运行的线程是有可能出现的，比如tomcat的http处理线程，grpc的rpc业务处理线程等都是长时间一直运行的。&lt;/string&gt;&lt;/p&gt;&lt;p&gt;另外因为Entry有对value的强引用，所以在线程业务处理的最后可以主动调用remove方法清理ThreadLocal，加快垃圾对象的回收，可以避免长时间存活而晋升到老年代。例如如果我们在Filter中使用ThreadLocal,一般在处理之前获取设置ThreadLocal，处理完成后，remove()删除ThreadLocal。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; userNameThreadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilterInternal&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response,&lt;br/&gt; FilterChain filterChain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; userNameThreadLocal.set(getName(request));&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  filterChain.doFilter(request, response);&lt;br/&gt; } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;  userNameThreadLocal.remove();&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面看一下ThreadLocalMap的实现，也就是线性探测法的具体实现。使用数组存放ThreadLocal到value的映射Entry，也有一个threshold(按照数组长度乘以2/3得到)，元素数量达到threshold时，会触发resize。在ThreadLocalMap中也有清理stale Entry的处理，当ThreadLocal对象没有强引用后，Entry.get()就会返回null，这个Entry就称为stale entry，就可以触发清理工作来回收空间。&lt;/p&gt;&lt;p&gt;ThreadLocalMap中定义了Entry[]数组，可以想象成循环数组，在线性探查中，如果遍历到边界后会从另一头继续遍历。threshold是扩容的阈值，当Map中元素数量达到threshold的时候会进行扩容，threshold通过数组长度乘以2/3得到，2/3就是Map的load factor（也翻译成负载因子）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 初始数组的大小&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 存放Entry的数组，和HashMap一样是惰性创建的，并且长度是2的次方，每次扩容乘以2.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 触发resize的阈值，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threshold; &lt;span&gt;// Default to 0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// threshold是数组长度乘以2/3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     threshold = len * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 线性探测法使用的计算后一个数组index的方法，到达数组最后之后会从0开始&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; ((i + &lt;span&gt;1&lt;/span&gt; &amp;lt; len) ? i + &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 线性探测法使用的计算前一个数组index的方法，到达数组最前面后会总数组的最后开始&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;prevIndex&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; ((i - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;0&lt;/span&gt;) ? i - &lt;span&gt;1&lt;/span&gt; : len - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;getEntry方法返回ThreadLocal对应的Entry，通过与操作得到非负数的数组index&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 获取某个ThreadLocal对应的Entry&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntry&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 通过hashCode和（数组长度-1）做与操作，在数组长度为2的次方时，等价于对数组长度取余并且不会返回负数，因为数组长度-1的高位都是0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    Entry e = table[i];&lt;br/&gt;    &lt;span&gt;// 数组对应index位置的元素是当前ThreadLocal对象时，直接返回这个Entry&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == key)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 其他情况都调用getEntryAfterMiss处理，会到后面的位置继续查找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getEntryAfterMiss(key, i, e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;getEntryAfterMiss方法在ThreadLocal计算的hashCode直接找到的数组中的位置和ThreadLocal不匹配时，继续在后面的Entry查找（直接找到的Entry不为空的情况，为空直接返回null） 如果遇到Entry.get返回null情况，说明这个Entry的ThreadLocal对象没有强引用了，也就是stale entry，会进行清理，也就是调用expungeStaleEntry方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntryAfterMiss&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, &lt;span&gt;int&lt;/span&gt; i, Entry e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从i数组位置开始不断遍历，直到数组Entry为null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// 调用Entry.get获取ThreadLocal对象&lt;/span&gt;&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;        &lt;span&gt;// 如果是同一个对象，说明找到了，返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;        &lt;span&gt;// 如果ThreadLocal对象为null，说明被回收了，需要进行清理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;// expungeStaleEntry方法会负责清理，并且如果后面的元素是因为和当前i所在的ThreadLocal冲突而后移的，则会把后面的元素向左移动归位&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(i);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 否则，继续遍历下一个元素，到头之后从0重来&lt;/span&gt;&lt;br/&gt;            i = nextIndex(i, len);&lt;br/&gt;        &lt;span&gt;// 获取下一个位置的Entry对象&lt;/span&gt;&lt;br/&gt;        e = tab[i];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;set方法负责在Map中写入ThreadLocal到value的映射。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; Entry[] tab = table;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;// 计算出index&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从index开始遍历，会不会出现满了没有地方添加的情况呢？是不会的，因为这个方法的最后有判断threshold(load factor 2/3，数组初始大小为16)扩容的逻辑&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;br/&gt;  e != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  e = tab[i = nextIndex(i, len)]) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 找到了相同的ThreadLocal，说明Entry已经存在，进行value覆盖&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;br/&gt;            e.value = value;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 如果ThreadLocal对象是null，调用replaceStaleEntry替换stale entry&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            replaceStaleEntry(key, value, i);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt; }&lt;br/&gt;    &lt;span&gt;// 说明没有找到ThreadLocal或替换stale entry，则会创建一个新的Entry放在i的位置。&lt;/span&gt;&lt;br/&gt; tab[i] = &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;br/&gt;    &lt;span&gt;// 记录元素数量&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; sz = ++size;&lt;br/&gt;    &lt;span&gt;// 先清理一部分数组中的stale entry，再判断下元素数量是否超过threshold&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;        &lt;span&gt;// 如果元素数量达到了threshold，进行rehash扩容&lt;/span&gt;&lt;br/&gt;     rehash();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;remove方法，会从Map中删除ThreadLocal对象的映射，并且也会触发expungeStaleEntry清理&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;br/&gt;        e != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        e = tab[i = nextIndex(i, len)]) {&lt;br/&gt;        &lt;span&gt;// 找到了TheadLocal对应的Entry后&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.get() == key) {&lt;br/&gt;            &lt;span&gt;// 调用clear清理掉队ThreadLocal的引用，clear完之后中调用get就会返回null，相当于是stale entry了&lt;/span&gt;&lt;br/&gt;            e.clear();&lt;br/&gt;            &lt;span&gt;// 触发清理，也会释放对value的引用&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(i);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;replaceStaleEntry会替换staleSlot上的Entry为ThreadLocal对象到value的映射&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;replaceStaleEntry&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value,&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; staleSlot)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    Entry e;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 向前找第一个不为null的数组位置，作为这次replace中会清理的起点，避免频繁全量rehash&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; slotToExpunge = staleSlot;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = prevIndex(staleSlot, len);&lt;br/&gt;        (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        i = prevIndex(i, len)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            slotToExpunge = i;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = nextIndex(staleSlot, len);&lt;br/&gt;        (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        i = nextIndex(i, len)) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 找到了元素，进行替换&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;br/&gt;            e.value = value;&lt;br/&gt;&lt;br/&gt;            tab[i] = tab[staleSlot];&lt;br/&gt;            tab[staleSlot] = e;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (slotToExpunge == staleSlot)&lt;br/&gt;                slotToExpunge = i;&lt;br/&gt;            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 在上面for循环中没有找到stale entry的情况下，如果这个for循环中找到了，替换slotToExpunge&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; slotToExpunge == staleSlot)&lt;br/&gt;            slotToExpunge = i;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 如果没有找到原有的key，则直接替换staleSlot&lt;/span&gt;&lt;br/&gt;    tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    tab[staleSlot] = &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 清理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (slotToExpunge != staleSlot)&lt;br/&gt;        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;expungeStaleEntry方法从staleSlot开始清理stale entry，直到遇到一个null的entry&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;expungeStaleEntry&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; staleSlot)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 先清理staleSlot位置的Entry的引用&lt;/span&gt;&lt;br/&gt;    tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    tab[staleSlot] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    size--;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从staleSlot后面开始重新计算Entry位置，直到遇到null数组元素&lt;/span&gt;&lt;br/&gt;    Entry e;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = nextIndex(staleSlot, len);&lt;br/&gt;        (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        i = nextIndex(i, len)) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;        &lt;span&gt;// k == null说明是stale entry，清理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            e.value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            tab[i] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            size--;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 否则重新计算存放entry位置&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (len - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (h != i) {&lt;br/&gt;                tab[i] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// Unlike Knuth 6.4 Algorithm R, we must scan until&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// null because multiple entries could have been stale.&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (tab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    h = nextIndex(h, len);&lt;br/&gt;                tab[h] = e;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rehash方法会先完整清理一遍，然后再check下size，如果刚才的清理后size还是大于3/4 threshold，也就是大约1/2 数组长度，则发起resize扩容&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Use lower threshold for doubling to avoid hysteresis&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;resize扩容，会把数组长度扩大一倍，并且对Entry元素重新计算存放位置&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] oldTab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; oldLen = oldTab.length;&lt;br/&gt;    &lt;span&gt;// 计算新数组长度为老数组的两倍&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; newLen = oldLen * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 创建新数组&lt;/span&gt;&lt;br/&gt;    Entry[] newTab = &lt;span&gt;new&lt;/span&gt; Entry[newLen];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 循环遍历老数组的元素，依次放到新数组中，相当于依次调用set方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Entry e : oldTab) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;            &lt;span&gt;// 如果resize的时候发现stale entry，把value设置成null释放对应的引用&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                e.value = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// Help the GC&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 否则在新数组中寻找可以存放的位置，先计算hash index&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (newLen - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;// 如果数组中对应位置有元素，则一直向后遍历&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (newTab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    h = nextIndex(h, newLen);&lt;br/&gt;                &lt;span&gt;// 直到一个新位置可以存放&lt;/span&gt;&lt;br/&gt;                newTab[h] = e;&lt;br/&gt;                &lt;span&gt;// 计数加一&lt;/span&gt;&lt;br/&gt;                count++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 数组元素转移完成，修改threshold&lt;/span&gt;&lt;br/&gt;    setThreshold(newLen);&lt;br/&gt;    &lt;span&gt;// 修改size&lt;/span&gt;&lt;br/&gt;    size = count;&lt;br/&gt;    &lt;span&gt;// 替换table数组&lt;/span&gt;&lt;br/&gt;    table = newTab;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;expungeStaleEntries方法清理数组中所有的staleEntry&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;expungeStaleEntries&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;// 遍历所有的数组元素&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;        Entry e = tab[j];&lt;br/&gt;        &lt;span&gt;// 如果entry不为空但是get出来的ThreadLocal为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;// 从j位置开始清理&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(j);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;ThreadLocal的使用注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ThreadLocal字段应该声明成static final&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal在线程处理完成后建议主动remove&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意跨线程使用ThreadLocal的问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal通过避免线程间共享数据，可以解决一些线程安全问题，并且可以跨代码区域传递参数，但是也带来了一些隐式约定，要避免滥用作参数隐式传递&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;延伸: netty中FastThreadLocal的优化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;jdk中ThreadLocal的实现就是最好的吗？并不见得，高性能的io框架netty中就对ThreadLocal进行了优化，提供了FastThreadLocal。那么FastThreadLocal究竟Fast快在哪里呢？&lt;/p&gt;&lt;p&gt;在上面ThreadLocal的实现分析中我们可以看到ThreadLocal中是有可能出现hash冲突而进行线性探测的问题的，而FastThreadLocal通过简单的方法巧妙的解决了这个问题。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FastThreadLocal类中保存了一个数组中的index，这样get操作就变成了先直接拿到index再从数组中按照index读取，而不会像ThreadLoacl还可能需要向后遍历。index是通过0开始递增分配的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FastTheadLocal中增加了UNSET和initialValue的null做区分，避免ThreadLocal在get遇到initialValue()返回null时每次get()总会调用setInitialValue的问题&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;FastThreadLocal要搭配FastThreadLocalThread使用, FastThreadLocalThread继承Thread并定义了一个InternalThreadLocalMap对象，和ThreadLocalMap类似，InternalThreadLocalMap也是存放当前线程的FastThreadLocal到value的映射。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FastThreadLocalThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; InternalThreadLocalMap threadLocalMap;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;get方法实现是获取当前线程FastThreadLocalThread的InternalThreadLocalMap，然后从FastThreadLocal拿到index调用indexedVariable获取value。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FastThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每个FastThreadLocal对象有自己的index，对应数组中的位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;FastThreadLocal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        index = InternalThreadLocalMap.nextVariableIndex();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();&lt;br/&gt;        Object v = threadLocalMap.indexedVariable(index);&lt;br/&gt;        &lt;span&gt;// 如果initialValue返回了null，则不会多次执行initialize方法&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (v != InternalThreadLocalMap.UNSET) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (V) v;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; initialize(threadLocalMap);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; V &lt;span&gt;initialize&lt;/span&gt;&lt;span&gt;(InternalThreadLocalMap threadLocalMap)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        V v = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            v = initialValue();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            PlatformDependent.throwException(e);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        threadLocalMap.setIndexedVariable(index, v);&lt;br/&gt;        addToVariablesToRemove(threadLocalMap, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; v;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;InternalThreadLocalMap的indexedVariable方法直接按照index获取数组元素&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InternalThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger nextIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object UNSET = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InternalThreadLocalMap &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Thread thread = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; thread &lt;span&gt;instanceof&lt;/span&gt; FastThreadLocalThread ? fastGet((FastThreadLocalThread)thread) : slowGet();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InternalThreadLocalMap &lt;span&gt;fastGet&lt;/span&gt;&lt;span&gt;(FastThreadLocalThread thread)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (threadLocalMap == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            thread.setThreadLocalMap(threadLocalMap = &lt;span&gt;new&lt;/span&gt; InternalThreadLocalMap());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; threadLocalMap;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Object[] indexedVariables;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;indexedVariable&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object[] lookup = indexedVariables;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; index &amp;lt; lookup.length? lookup[index] : UNSET;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UnpaddedInternalThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过FastThreadLocal没有做内存泄漏保护，如果我们使用不正确，比如创建了大量ThreadLocal对象，则可能会出现数组内存不断增长，这就需要我们在使用时注意ThreadLocal声明成static，并且尽量在线程处理完成后主动remove&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>