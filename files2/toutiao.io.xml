<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>300d4735d3a0c4edeefa6fabbb91dfa3</guid>
<title>双非渣本后端三个月逆袭字节</title>
<link>https://toutiao.io/k/faz5prg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-topic-des nc-post-content&quot;&gt;
&lt;h2 id=&quot;个人背景介绍&quot;&gt;个人背景介绍&lt;/h2&gt; 
&lt;p&gt;2017年毕业于一所不知名双非本科大学，毕业时就有着一颗想进大厂的心，但又想留在成都，不愿意去北上广，现在其实相当后悔。当年在成都的大厂少之又少，再加上校招时非常努力地玩耍，导致投的几个大厂面试都全部挂掉。也错失了进大厂最好的机会，所以我奉劝大三的同学如果对自己的职业有追求，有进大厂的梦想，在大三的时候一定要好好准备，在校招的时候拿offer。&lt;br/&gt;&lt;span&gt;最后我在成都一家本地科技公司做了Java开发，中间也跳过一次槽，也是做的Java。但这几年时间里总感觉公司能给的成长太慢，虽然自己也在学习，还是免不了焦虑，特别是像自己这种学历和公司背景都一般的程序员，要保证自己以后不被淘汰，必须得做点什么。所以在听到一个前同事被公司裁掉，最后进入大厂这个事情之后，彻底点燃了我心中想进大厂的那把火，我也准备内推试试&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8&quot; target=&quot;_blank&quot;&gt;字节跳动&lt;/a&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为疫情原因，很多企业生存困难。我也保持了理智，没有辞职进行面试。而是给自己制定了学习计划，不得不说，在职的情况下复习确实很难，因为可能加班打乱计划。于是我把所有能利用的个人时间全部利用了起来，比如早上十点上班，我六点钟就会起床，刷两个小时LeetCode，八点钟洗漱之后去上班。晚上如果有时间就会把早上刷过的题拿出来继续复习，花了两个月的时间，一边复习（预习）数据结构，一边做题，LeetCode上面的高频题基本都过了一遍。花了那么多时间&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%88%B7%E9%A2%98&quot; target=&quot;_blank&quot;&gt;刷题&lt;/a&gt;，都是因为自己&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;太菜，以前没有进行专门的练习。题做得差不多之后，就开始复习专业知识了，具体内容我都会总结出来。前前后后准备了三个月，我才敢进行内推，经历了八次面试之后，面试时间又持续三个月，皇天不负有心人，终于在这个月等到了oc。&lt;/span&gt;&lt;br/&gt;下面是面试内容，时间太久了，可能记得不太全，但基本上包含了所有问题，白天上班，我都是选择晚上进行面试，哈哈&lt;/p&gt; 
&lt;h2 id=&quot;一面a部门&quot;&gt;一面A部门&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;讲&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，串起来讲，可能遇到的问题，怎么解决，怎么实现，讲了发送客服消息&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;Spring里面的bean怎么回事&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;HashMap和ConcurrentHashMap，HashMap中的&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;，两者rehash的区别&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;Mysql的一致性是什么，数据库redolog，undo log，MySQL的索引结构，为什么二级索引叶子节点不能直接存储行数据的指针，这样可以不回表，怎么考虑的？&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;里面的zset，跳表怎么实现，怎么增删，&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;是怎么rehash的&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;转双向&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;二面a部门&quot;&gt;二面A部门&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;自我介绍&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;再一次聊&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，功能，架构，角色，量级&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;Spring里面有哪些设计模式&lt;/li&gt; 
 &lt;li&gt;SpringMVC和SpringBoot有什么区别&lt;/li&gt; 
 &lt;li&gt;SpringBoot的自动配置是怎么实现的&lt;/li&gt; 
 &lt;li&gt;刚刚你说了线程池，你线程池是用的什么，参数有哪些，为什么这么设置 &lt;/li&gt; 
 &lt;li&gt;线程池核心线程满了怎么办，里面的阻塞队列是干什么的&lt;/li&gt; 
 &lt;li&gt;说说ThreadLocal是什么&lt;/li&gt; 
 &lt;li&gt;CAP理论知道吗，为什么不能同时满足&lt;/li&gt; 
 &lt;li&gt;Redis里面的数据结构有什么场景&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;Redis怎么实现锁（&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;锁的所有坑都说了一遍）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;分布式事务知道吗，有哪些方案（说了2PC，3PC，TCC，MQ）&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95%E9%A2%98&quot; target=&quot;_blank&quot;&gt;算法题&lt;/a&gt;，&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84&quot; target=&quot;_blank&quot;&gt;树的直径&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;有什么要问我的&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;三面a部门&quot;&gt;三面A部门&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;介绍&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;场景题，设计一个朋友圈，读QPS 1000w，写QPS 10w&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95%E9%A2%98&quot; target=&quot;_blank&quot;&gt;算法题&lt;/a&gt;LFU&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;你有什么问题&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;这个面试官是个leader，比较强势，很多细节回答的不是很好，所以脸色一直不好，给人压力较大，面完就觉得凉了。果然面完之后和前两次不一样，HR那里就没有任何通知了，到这里还是很失落，准备了那么久，因为最后一面没表现好导致挂掉。之后等了一个月，这一个月没有任何消息，一个月过后又接到字节HR的电话，说我之前两面面评都不错，让我试试他们部门，我就同意了。&lt;/p&gt; 
&lt;h2 id=&quot;一面b部门&quot;&gt;一面B部门&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;介绍&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，细节&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;怎么做服务拆分，边界怎么划分的&lt;/li&gt; 
 &lt;li&gt;分布式之后会遇到什么问题，CAP的各个情况介绍一下&lt;/li&gt; 
 &lt;li&gt;dubbo调用过程是怎样的，PB知道吗&lt;/li&gt; 
 &lt;li&gt;thrift了解过吗&lt;/li&gt; 
 &lt;li&gt;zk介绍一下，有哪些节点类型，特点&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;怎么知道&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;中接口的重要性，怎么做监控，你说的自动化测试是怎么做到的（这个问题回答完，他笑了。。。）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;你所理解的SLA是什么，要达到什么等级&lt;/li&gt; 
 &lt;li&gt;说说你理解的k8s&lt;/li&gt; 
 &lt;li&gt;nginx的upstream是干什么的&lt;/li&gt; 
 &lt;li&gt;nginx有哪些负载均衡策略&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95%E9%A2%98&quot; target=&quot;_blank&quot;&gt;算法题&lt;/a&gt;：&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F&quot; target=&quot;_blank&quot;&gt;岛屿数量&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;你有什么问题要问我&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;二面b部门&quot;&gt;二面B部门&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;介绍&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，细节&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;锁有哪些实现方式&lt;/li&gt; 
 &lt;li&gt;分布式锁的实现方式&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;JVM的内存模型，垃圾回收&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;MySQL的事务介绍，ACID的实现原理是什么（想问MySQL的日志）&lt;/li&gt; 
 &lt;li&gt;HashMap的原理，其他线程安全的Map&lt;/li&gt; 
 &lt;li&gt;Redis的高可用，有哪些持久化方式&lt;/li&gt; 
 &lt;li&gt;Redis的数据结构，线程模型&lt;/li&gt; 
 &lt;li&gt;用过什么消息队列，有什么特点&lt;/li&gt; 
 &lt;li&gt;怎么保证消息幂等消费&lt;/li&gt; 
 &lt;li&gt;docker的网络模式&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95%E9%A2%98&quot; target=&quot;_blank&quot;&gt;算法题&lt;/a&gt;：&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7&quot; target=&quot;_blank&quot;&gt;比较版本号&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;提问&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;三面b部门（交叉面）&quot;&gt;三面B部门（交叉面）&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;介绍&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，细节&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;Linux的内存管理&lt;/li&gt; 
 &lt;li&gt;浏览器打开一个网站的过程中会经历哪些网络处理，DNS的具体过程是啥&lt;/li&gt; 
 &lt;li&gt;zk是什么分布式模型（想问的CAP定理），主从怎么做选举&lt;/li&gt; 
 &lt;li&gt;zk只有一个主节点，写性能不高，zk怎么解决的&lt;/li&gt; 
 &lt;li&gt;etcd或consul知道吗&lt;/li&gt; 
 &lt;li&gt;多个服务中如何快速排查问题&lt;/li&gt; 
 &lt;li&gt;Redis中的淘汰方式有哪些，Redis性能高的原因是啥&lt;/li&gt; 
 &lt;li&gt;docker的实现原理&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95%E9%A2%98&quot; target=&quot;_blank&quot;&gt;算法题&lt;/a&gt;：相交&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;四面b部门-（leader面）&quot;&gt;四面B部门 （leader面）&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;介绍&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;，细节&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE&quot; target=&quot;_blank&quot;&gt;项目&lt;/a&gt;量级多大，QPS最高的接口是怎么做的&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;rpc怎么实现服务发现&lt;/li&gt; 
 &lt;li&gt;zk中的watch机制是怎么实现的&lt;/li&gt; 
 &lt;li&gt;分布式锁有哪些实现，MySQL，zk，Redis都说了一遍，并且分析了各自的优缺点，这个问题问的频率太高了&lt;/li&gt; 
 &lt;li&gt;怎么提高数据库读写性能&lt;/li&gt; 
 &lt;li&gt;k8s了解吗&lt;/li&gt; 
 &lt;li&gt;servicemesh有做过吗&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;五面b部门（hr面）&quot;&gt;五面B部门（HR面）&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;离职原因&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92&quot; target=&quot;_blank&quot;&gt;职业规划&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;期望薪资&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;常用集合、数据结构（数据增删改查操作的原理具体实现、各参数的含义，以及如何组合使用）&lt;/li&gt; 
 &lt;li&gt;Java的语法，OO的思想要熟悉，常用设计模式要知道场景&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;JVM内存模型，垃圾回收&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;，垃圾收集器的区别，GC调优&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;线程模型&lt;/li&gt; 
 &lt;li&gt;IO模型（包括操作系统底层IO模型和常见BIO、NIO、AIO、IO多路复用的原理）&lt;/li&gt; 
 &lt;li&gt;Redis（数据结构的内部实现、淘汰原理策略、持久化、集群、扩容、数据同步、以及一些常见缓存问题的解决方案）&lt;/li&gt; 
 &lt;li&gt;MySQL（索引原理，查询优化，三大日志）&lt;/li&gt; 
 &lt;li&gt;消息队列（内部原理，常见消息问题解决方案）&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;分布式原理、&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;、rpc原理（paxos、raft、zoo&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=keep&quot; target=&quot;_blank&quot;&gt;keep&lt;/a&gt;er的原理）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;分布式场景题（高可用，高性能相关）&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2 id=&quot;其他知识&quot;&gt;其他知识&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;位运算&lt;/li&gt; 
 &lt;li&gt;大数据量操作（在有限时间内完成、在有限空间内完成）&lt;/li&gt; 
 &lt;li&gt;设计题（看一些常见的分布式ID、分布式计数服务等等）&lt;/li&gt; 
&lt;/ol&gt; 
 
&lt;ol&gt; 
 &lt;li&gt;数组&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;位运算&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;（dfs，bfs，相当重要，只要会了&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;二叉树&lt;/a&gt;，回溯那些&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;也会了）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;设计题&lt;/li&gt; 
 &lt;li&gt;LRU/LFU&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;a class=&quot;content-link  js-post-content-keyword&quot; href=&quot;/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;排序&lt;/a&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;查找&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src=&quot;https://uploadfiles.nowcoder.com/files/20210311/1219786_1615453294383/008eGmZEgy1goeugqrbrrj31360u0451.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt; 
&lt;p&gt;我给大家的建议就是慢慢来，不管是社招还是校招，制定自己的计划，一定要有自己的知识体系，针对自己薄弱的地方进行强化复习，不放过任何一个细节。&lt;br/&gt;简历上写的东西一定要会，一般都是针对简历来提问的。如果在预习的过程中感到困难或者吃力，那就对了，等你熬过去了，就是胜利。祝福大家都能拿到满意的offer。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7cb134268a884dc91ab7b91dbac59260</guid>
<title>[推荐] [译] 七个改变我生活的 Git 小技巧</title>
<link>https://toutiao.io/k/kly6lxt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Git 是当前最流行最普遍的版本控制系统之一，它被应用于私有系统和公开网站上各种各样的开发工作。不论我变得对 Git 有多熟悉，似乎总有些功能等待着被发掘。下面分享下和 Git 相关的改变我工作方式的一些小技巧。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;1、Git 中的自动纠错&lt;/p&gt;&lt;p&gt;我们每个人都不时在输入时犯拼写错误，但是如果你使能了 Git 的自动纠错功能，你就能让 Git 自动纠正一些输入错误的子命令。&lt;/p&gt;&lt;p&gt;假如你想用命令 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxb09d89502b7e2152&quot; data-miniprogram-path=&quot;pages/command?command=git&quot; data-miniprogram-nickname=&quot;Linux&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;git status&lt;/a&gt; 来检查状态，但是你恰巧错误地输入了 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxb09d89502b7e2152&quot; data-miniprogram-path=&quot;pages/command?command=git&quot; data-miniprogram-nickname=&quot;Linux&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;git stats&lt;/a&gt;。通常情况下，Git 会告诉你 ‘stats’ 不是个有效的命令：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; stats&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;stats&lt;/span&gt;&lt;span&gt;’&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; command&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;See&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;help&lt;/span&gt;&lt;span&gt;’.&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;The&lt;/span&gt;&lt;span&gt; most similar command &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;status&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;为了避免类似情形，只需要在你的 Git 配置中使能自动纠错功能。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; config &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; help&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;autocorrect &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;如果你只想对当前的仓库生效，就省略掉选项 &lt;code&gt;--global&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这个命令会使能自动纠错功能。在相应的 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgit-scm.com%2Fbook%2Fen%2Fv2%2FCustomizing-Git-Git-Configuration%23_code_help_autocorrect_code&amp;amp;title=Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Git 官方文档&lt;/a&gt; 中可以看到这个命令的详细说明，但是试着敲一下上面的错误命令会使你对这个设置干了什么有个直观的了解：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; stats&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;stats&lt;/span&gt;&lt;span&gt;’&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; command&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;See&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;help&lt;/span&gt;&lt;span&gt;’.&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;On&lt;/span&gt;&lt;span&gt; branch master&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;Your&lt;/span&gt;&lt;span&gt; branch &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; up to &lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;origin&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;’.&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;nothing to commit&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; working tree clean&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;在上面的例子中，Git 直接运行了它建议命令的第一个，也就是 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxb09d89502b7e2152&quot; data-miniprogram-path=&quot;pages/command?command=git&quot; data-miniprogram-nickname=&quot;Linux&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;git status&lt;/a&gt;，而不是给你展示它所建议的子命令。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;2、对提交进行计数&lt;/p&gt;&lt;p&gt;需要对提交进行计数的原因有很多。例如，一些开发人员利用提交计数来判断什么时候递增工程构建序号，也有一些开发人员用提交计数来对项目进展取得一个整体上的感观。&lt;/p&gt;&lt;p&gt;对提交进行计数相当简单而且直接，下面就是相应的 Git 命令：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;count branch&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;在上述命令中，参数 &lt;code&gt;branch-name&lt;/code&gt; 必须是一个你当前仓库里的有效分支名。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;count master&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;32&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;count dev&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;34&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;3、仓库优化&lt;/p&gt;&lt;p&gt;你的代码仓库不仅对你来说很宝贵，对你所在的组织也一样。通过少数几个惯例你就能使自己的仓库整洁并且保持最新。&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Farticle%2F20%2F8%2Fdont-ignore-gitignore&amp;amp;title=%E4%BD%BF%E7%94%A8%20.gitignore%20%E6%96%87%E4%BB%B6&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;使用 .gitignore 文件&lt;/a&gt; 就是这些最好的惯例之一。通过使用这个文件你可以告诉 Git 不要保存一些不需要记录的文件，如二进制文件、临时文件等等。&lt;/p&gt;&lt;p&gt;当然，你还可以使用 Git 的垃圾回收来进一步优化你的仓库。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; gc &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;prune&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;now &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;aggressive&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这个命令在你和你的团队经常使用 &lt;code&gt;pull&lt;/code&gt; 或者 &lt;code&gt;push&lt;/code&gt; 操作的时候很有帮助。&lt;/p&gt;&lt;p&gt;它是一个内部工具，能清理掉你的仓库里没法访问或者说“空悬”的 Git 对象。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;4、给未追踪的文件来个备份&lt;/p&gt;&lt;p&gt;大多数时候，删除所有未追踪的文件是安全的。但很多时候也有这么一种场景，你想删掉这些未追踪的文件同时也想做个备份防止以后需要用到。&lt;/p&gt;&lt;p&gt;Git 组合一些 Bash 命令和管道操作，可以让你可以很容易地给那些未追踪的文件创建 zip 压缩包。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;files &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;others &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;exclude&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;standard &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;z &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;\&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;xargs&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;tar&lt;/span&gt;&lt;span&gt; rvf &lt;/span&gt;&lt;span&gt;~/&lt;/span&gt;&lt;span&gt;backup&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;untracked&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;上面的命令就生成了一个名字为 &lt;code&gt;backup-untracked.zip&lt;/code&gt; 的压缩包文件（当然，在 &lt;code&gt;.gitignore&lt;/code&gt; 里面忽略了的文件不会包含在内）。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;5、了解你的 .git 文件夹&lt;/p&gt;&lt;p&gt;每个仓库都有一个 &lt;code&gt;.git&lt;/code&gt; 文件夹，它是一个特殊的隐藏文件夹。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;Git 主要通过两个东西来工作：&lt;/p&gt;&lt;section&gt;&lt;section&gt;1. 当前工作树（你当前检出的文件状态）&lt;/section&gt;&lt;section&gt;2. 你的 Git 仓库的文件夹（准确地说，包含版本信息的 &lt;code&gt;.git&lt;/code&gt; 文件夹的位置）&lt;/section&gt;&lt;/section&gt;&lt;p&gt;这个文件夹存储了所有参考信息和一些其他的如配置、仓库数据、HEAD 状态、日志等更多诸如此类的重要细节。&lt;/p&gt;&lt;p&gt;一旦你删除了这个文件夹，尽管你的源码没被删，但是类似你的工程历史记录等远程信息就没有了。删除这个文件夹意味着你的工程（至少本地的复制）不再在版本控制的范畴之内了。这也就意味着你没法追踪你的修改；你没法从远程仓拉取或推送到远程仓了。&lt;/p&gt;&lt;p&gt;通常而言，你需要或者应当对你的 &lt;code&gt;.git&lt;/code&gt; 文件夹的操作并不多。它是被 Git 管理的，而且大多数时候是一个禁区。然而，在这个文件夹内还是有一些有趣的工件，比如说当前的 HEAD 状态在内的就在其中。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;HEAD&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; refs&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;heads&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;它也隐含着对你仓库地描述：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这是一个未命名的仓库；通过编辑文件 ‘description’ 可以给这个仓库命名。&lt;/p&gt;&lt;p&gt;Git 钩子文件夹连同一些钩子文件例子也在这里。参考这些例子你就能知道 Git 钩子能干什么了。当然，你也可以 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Flife%2F16%2F8%2Fhow-construct-your-own-git-server-part-6&amp;amp;title=%E5%8F%82%E8%80%83%E8%BF%99%E4%B8%AA%20Seth%20Kenlon%20%E5%86%99%E7%9A%84%20Git%20%E9%92%A9%E5%AD%90%E4%BB%8B%E7%BB%8D&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;参考这个 Seth Kenlon 写的 Git 钩子介绍&lt;/a&gt;。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;6、浏览另一个分支的文件&lt;/p&gt;&lt;p&gt;有时，你会想要浏览另一个分支下某个文件的内容。这其实用一个简单的 Git 命令就可以实现，甚至都不用切换分支。&lt;/p&gt;&lt;p&gt;设想你有一个命名为 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=http%3A%2F%2FREADME.md&amp;amp;title=README.md&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;README.md&lt;/a&gt; 的文件，并且它在 &lt;code&gt;main&lt;/code&gt; 分支上。当前你正工作在一个名为 &lt;code&gt;dev&lt;/code&gt; 的分支。&lt;/p&gt;&lt;p&gt;用下面的 Git 命令，在终端上就行。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; show main&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;README&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;md&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;一旦你执行这个命令，你就能在你的终端上看到 &lt;code&gt;main&lt;/code&gt; 分支上该文件的内容。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;7、Git 中的搜索&lt;/p&gt;&lt;p&gt;用一个简单的命令你就能在 Git 中像专业人士一样搜索了。更有甚者，尽管你不确定你的修改在哪次提交或者哪个分支上，你依然能搜索。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;all &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;xargs&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;例如，假设你想在你的仓库中搜索字符串 &lt;code&gt;“font-size: 52 px;&quot;&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;$ &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; rev&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;all &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;xargs&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;font&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt; px&lt;/span&gt;&lt;span&gt;;’&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;F3022&lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt;9e12&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;HtmlTemplate&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; font&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt; px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;E9211&lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt;8244&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;RR&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; font&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;&lt;span&gt; px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaJJbPMBUMmEc4WZHpTcL9yqYTus3C9jRvy6GibnETwghlrBazkGrTj0jYsRM9AHBWI/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;p&gt;试试这些小技巧&lt;/p&gt;&lt;p&gt;我希望这些小技巧对你是有用的，或者增加你的生产力或者节省你的大量时间。&lt;/p&gt;&lt;p&gt;你也有一些喜欢的 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Facompiler.com%2Fgit-tips%2F&amp;amp;title=Git%20%E6%8A%80%E5%B7%A7&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Git 技巧&lt;/a&gt; 吗？在评论区分享吧。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;via: &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Farticle%2F20%2F10%2Fadvanced-git-tips&amp;amp;title=https%3A%2F%2Fopensource.com%2Farticle%2F20%2F10%2Fadvanced-git-tips&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;https://opensource.com/article/20/10/advanced-git-tips&lt;/a&gt;&lt;/p&gt;&lt;p&gt;作者：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fopensource.com%2Fusers%2Facompiler&amp;amp;title=Rajeev%20Bera&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Rajeev Bera&lt;/a&gt; 选题：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Flujun9972&amp;amp;title=lujun9972&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;lujun9972&lt;/a&gt; 译者：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2FBoosterY&amp;amp;title=BoosterY&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;BoosterY&lt;/a&gt; 校对：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fwxy&amp;amp;title=wxy&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;wxy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文由 &lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2FLCTT%2FTranslateProject&amp;amp;title=LCTT&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;LCTT&lt;/a&gt; 原创编译，&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Flinux.cn%2F&amp;amp;title=Linux%E4%B8%AD%E5%9B%BD&quot; data-miniprogram-type=&quot;text&quot; href=&quot;&quot;&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ4MjYwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc6ibPlQXlgCmnlaz6glKp60FFhghXwSx3k5JVavk34FiaMu4ztUTl2Fib0DCUqSkRCvoWPDNczKzFefIg/0?wx_fmt=png&quot; data-nickname=&quot;Linux中国&quot; data-alias=&quot;linux-cn&quot; data-signature=&quot;[Linux中国](https://linux.cn/)开源社区官方公众号。专注于开源技术研究、开源思想传播。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/B2EfAOZfS1iaS9dgibME2dgeAKXscn7JcaSlibdzBCLU0WhPzcyiaM881yKtHiaAfwsbKAVJWfCT9ycWraQiazdMxjianJEVSm5vb1m/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;512&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;欢迎遵照 CC-BY-NC-SA 协议规定转载，&lt;/section&gt;&lt;section&gt;如需转载，请在文章下留言 “&lt;span&gt;转载：公众号名称&lt;/span&gt;”，&lt;/section&gt;&lt;section&gt;我们将为您添加白名单，授权“&lt;span&gt;转载文章时可以修改&lt;/span&gt;”。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>22ed3766d45b09a255ec0717186c4442</guid>
<title>[推荐] Redis：我是如何与客户端进行通信的</title>
<link>https://toutiao.io/k/dr4u4yt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;江湖上说，&lt;strong&gt;天下武功，无坚不摧，唯快不破&lt;/strong&gt;，这句话简直是为我量身定制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一个Redis服务，最引以为傲的就是我的速度，我的 QPS 能达到10万级别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的手下有数不清的小弟，他们会时不时到我这来存放或者取走一些数据，我管他们叫做客户端，还给他们起了英文名叫 Redis-client。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候一个小弟会来的非常频繁，有时候一堆小弟会同时过来，但是，即使再多的小弟我也能管理的井井有条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小弟们问我。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfoy2icYqicT72JftlHDibibSES2rlIOOYyFGNpDvc9lEy5Je4pkIpwpYjdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想当年，为了不让小弟们拖垮我傲人的速度，在设计和他们的通信协议时，我绞尽脑汁，制定了下面的三条原则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对计算机来说，解析速度快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对人类来说，可读性强&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么这么设计呢？先来看看一条指令发出的过程，首先在客户端需要对指令操作进行封装，使用网络进行传输，最后在服务端进行相应的解析、执行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicaLtJLCXG77p4PNzYoiaRAw5KYTmIWibRvsmxTp149neUMtI3gWFTiageu3ic5KFHm9HlmPkGxkCbZIMA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一过程如果设计成一种非常复杂的协议，那么封装、解析、传输的过程都将非常耗时，无疑会降低我的速度。什么，你问我为什么要遵循最后一条规则？算是对于程序员们的馈赠吧，我真是太善良了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把创造出来的这种协议称为 RESP (&lt;code&gt;REdis Serialization Protocol&lt;/code&gt;)协议，它工作在 TCP 协议的上层，作为我和客户端之间进行通讯的标准形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这，我已经有点迫不及待想让你们看看我设计出来的杰作了，但我好歹也是个大哥，得摆点架子，不能我主动拿来给你们看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我建议你直接使用客户端发出一条向服务器的命令，然后取出这条命令对应的报文来直观的看一下。话虽如此，不过我已经被封装的很严实了，正常情况下你是看不到我内部进行通讯的具体报文的，所以，你可以&lt;strong&gt;伪装&lt;/strong&gt;成一个Redis的服务端，来截获小弟们发给我的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现起来也很简单，我和小弟之间是基于 Socket 进行通讯，所以在本地先启动一个&lt;code&gt;ServerSocket&lt;/code&gt;，用来监听Redis服务的6379端口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;new&lt;/span&gt; ServerSocket(&lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    Socket socket = serverSocket.accept();&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;    InputStream input = socket.getInputStream();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(input.read(bytes)!=&lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;        System.out.println(&lt;span&gt;new&lt;/span&gt; String(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后启动&lt;code&gt;redis-cli&lt;/code&gt;客户端，发送一条命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set key1 value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，伪装的服务端就会收到报文了，在控制台打印了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*3&lt;br/&gt;$3&lt;br/&gt;set&lt;br/&gt;$4&lt;br/&gt;key1&lt;br/&gt;$6&lt;br/&gt;value1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，隐隐约约看到了刚才输入的几个关键字，但是还有一些其他的字符，要怎么解释呢，是时候让我对协议报文中的格式进行一下揭秘了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我对小弟们说了，对大哥说话的时候得按规矩来，这样吧，你们在请求的时候要遵循下面的规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*&amp;lt;参数数量&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数1的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数1的数据&amp;gt; CRLF&lt;br/&gt;$&amp;lt;参数2的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数2的数据&amp;gt; CRLF&lt;br/&gt;...&lt;br/&gt;$&amp;lt;参数N的字节长度&amp;gt; CRLF&lt;br/&gt;&amp;lt;参数N的数据&amp;gt; CRLF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先解释一下每行末尾的&lt;code&gt;CRLF&lt;/code&gt;，转换成程序语言就是&lt;code&gt;\r\n&lt;/code&gt;，也就是回车加换行。看到这里，你也就能够明白为什么控制台打印出的指令是竖向排列了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命令的解析过程中，&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;key1&lt;/code&gt;、&lt;code&gt;value1&lt;/code&gt;会被认为是3个参数，因此参数数量为3，对应第一行的&lt;code&gt;*3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个参数&lt;code&gt;set&lt;/code&gt;，长度为3对应&lt;code&gt;$3&lt;/code&gt;；第二个参数&lt;code&gt;key1&lt;/code&gt;，长度为4对应&lt;code&gt;$4&lt;/code&gt;；第三个参数&lt;code&gt;value1&lt;/code&gt;，长度为6对应&lt;code&gt;$6&lt;/code&gt;。在每个参数长度的下一行对应真正的参数数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，一条指令被转换为协议报文的过程是不是就很好理解了？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyf1BJ8xSic8HRQJKdbo0xVqK3ZpxPW5jFxibEcGeajCuxuoqg8PFDkINEg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当小弟对我发送完请求后，作为大哥，我就要对小弟的请求进行&lt;strong&gt;指令回复&lt;/strong&gt;了，而且我得根据回复内容进行一下分类，要不然小弟该搞不清我的指示了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单字符串&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单字符串回复只有一行回复，回复的内容以&lt;code&gt;+&lt;/code&gt;作为开头，不允许换行，并以&lt;code&gt;\r\n&lt;/code&gt;结束。有很多指令在执行成功后只会回复一个&lt;code&gt;OK&lt;/code&gt;，使用的就是这种格式，能够有效的将传输、解析的开销降到最低。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.084033613445378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfqlJaHViaKC8OqiaoUCnUSleGjticb8hukVjQAVyzfiboxYDvhdCjbBLkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RESP协议中，错误回复可以当做简单字符串回复的变种形式，它们之间的格式也非常类似，区别只有第一个字符是以&lt;code&gt;-&lt;/code&gt;作为开头，错误回复的内容通常是错误类型及对错误描述的字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误回复出现在一些异常的场景，例如当发送了错误的指令、操作数的数量不对时，都会进行错误回复。在客户端收到错误回复后，会将它与简单字符串回复进行区分，视为异常。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.184873949579832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfg3vfSI3FdGySPRlPuGDajnFfmNmqoEyDfwzDzMo1u9fWKw01Qb8PgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;整数回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整数回复的应用也非常广泛，它以&lt;code&gt;:&lt;/code&gt;作为开头，以&lt;code&gt;\r\n&lt;/code&gt;结束，用于返回一个整数。例如当执行&lt;code&gt;incr&lt;/code&gt;后返回自增后的值，执行&lt;code&gt;llen&lt;/code&gt;返回数组的长度，或者使用&lt;code&gt;exists&lt;/code&gt;命令返回的0或1作为判断一个&lt;code&gt;key&lt;/code&gt;是否存在的依据，这些都使用了整数回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9537815126050421&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfa4LiaqVYk1TOahicuRq4E2ib6nxDLEyzQsLiaRXzBtoiaKWeYzlETzhDia8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量回复，就是多行字符串的回复。它以&lt;code&gt;$&lt;/code&gt;作为开头，后面是发送的字节长度，然后是&lt;code&gt;\r\n&lt;/code&gt;，然后发送实际的数据，最终以&lt;code&gt;\r\n&lt;/code&gt;结束。如果要回复的数据不存在，那么回复长度为-1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5126050420168067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfBnACFwLBXNNhggIcPH9K5JXQjXeJna8zEqicQBA30rYW7ZnyzfDkic5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多条批量回复&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当服务端要返回多个值时，例如返回一些元素的集合时，就会使用多条批量回复。它以&lt;code&gt;*&lt;/code&gt;作为开头，后面是返回元素的个数，之后再跟随多个上面讲到过的批量回复。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3907563025210083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZ08KPRWFa6JlBqaskXvoyfq3s6vL0Ud67Ivib4UE6BRUibInIkmiaOUf2OX8ibWpJ4ThDSwGQ4JJZwcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，基本上我和小弟之间的通讯协议就介绍完了。刚才你尝试了伪装成一个服务端，这会再来试一试直接写一个客户端来直接和我进行交互吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;client&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    String CRLF=&lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    Socket socket=&lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (OutputStream out = socket.getOutputStream()) {&lt;br/&gt;        StringBuffer sb=&lt;span&gt;new&lt;/span&gt; StringBuffer();&lt;br/&gt;        sb.append(&lt;span&gt;&quot;*3&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$3&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;set&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$4&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;).append(CRLF)&lt;br/&gt;                .append(&lt;span&gt;&quot;$6&quot;&lt;/span&gt;).append(CRLF).append(&lt;span&gt;&quot;value1&quot;&lt;/span&gt;).append(CRLF);&lt;br/&gt;        out.write(sb.toString().getBytes());&lt;br/&gt;        out.flush();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; (InputStream inputStream = socket.getInputStream()) {&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] buff = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len = inputStream.read(buff);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                String ret = &lt;span&gt;new&lt;/span&gt; String(buff, &lt;span&gt;0&lt;/span&gt;, len);&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;Recv:&quot;&lt;/span&gt; + ret);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的代码，控制台输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Recv:+OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面模仿了客户端发出&lt;code&gt;set&lt;/code&gt;命令的过程，并收到了回复。依此类推，你也可以自己封装其他的命令，来实现一个自己的Redis客户端，作为小弟，来和我进行通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过记住，要叫我大哥。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c673f0e51603fc6df3e3a9840bb6b328</guid>
<title>[推荐] 一些贼好用的开发原则</title>
<link>https://toutiao.io/k/qphrwr6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「197」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不知道在看这篇文章的程序员伙计们平时是如何写代码的？有参照什么原则吗？还是说写到哪算哪？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你在搜索引擎里搜一下「软件开发原则」，可以搜到N多种原则，每一个原则看上去都很有道理，很对。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图就是我之前整理的一个与设计原则相关的思维导图。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8003003003003003&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1cT2xBHHePKia1bSxwVetpCLxquI1ibyMWTg2Zf7pwLQ5lHIn1jZTwK9jPE1qeLVuUzRByEcqs0B3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是不管你整理的多好，很多人到实际写代码的时候完全想不起这些原则。&lt;/span&gt;&lt;span&gt;不用自我怀疑，大多数人都是如此，你并不是特例。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;之所以会有这样的情况，是因为总结后的原则大多都太抽象了，往往只有一句话，甚至只是一个词，自然不会有太多深刻的印象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们今天不聊这些刻板的名词，来聊聊Z哥在工作中常用到的一些“原则”，以及它们的适用场景，帮助你更好地记住它们。另外，我还给它们做了一下分类，更便于你记忆。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  耦合/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;避免循环依赖&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个原则不管是在单体应用，还是分布式应用里都是非常重要的一个原则，它可以避免「big ball of mud」项目的产生。而且，如果项目里存在着过多的循环依赖，也更容易一不小心写出循环调用的代码，让整个系统陷入死循环。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;尽量单向依赖&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在满足「01」的前提下，尽量做到单向依赖可以大大降低阅读代码、排查问题时的复杂度。如果实在对上游有依赖的话，尽量通过IOC的思路来处理，用隐性依赖代替显性依赖。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果实在没法通过IOC来解决的话，可以将依赖上游的数据在当前系统冗余一份，然后通过MQ来保持数据同步，在业务处理的时候直接使用本地的这份冗余数据。当然，这个方法的复杂度明显比上面的更高，所以还是优先考虑上面的方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;避免跨层调用&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在满足「1」和「2」的前提下，尽量做到避免跨层调用，可以很起到更好的封装效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个最简单的反例，就拿三层架构来说，如果应用层的代码可以直接访问数据访问层，那么业务逻辑层自然会形同虚设。而且，后续一旦涉及到某数据表增加一个参数，要修改的相关调用代码可多了……这也是为什么很多维护不善的老项目越往后大家就越不敢乱动代码的主要原因之一。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  对象设计/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;单一职责原则&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实我在后面会提到SOLID原则，这里为什么将单一原则单独拿出来说呢，因为我觉得它是SOLID的六大原则里最重要的，虽然它看上去最简单。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;37&quot; data-source-title=&quot;Robert C. Martin《敏捷软件开发：原则、模式和实践》&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A37%2C%22text%22%3A%22%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E8%A7%84%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%BA%94%E8%AF%A5%E6%9C%89%E4%B8%94%E4%BB%85%E6%9C%89%E4%B8%80%E4%B8%AA%E5%BC%95%E8%B5%B7%E5%AE%83%E5%8F%98%E5%8C%96%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%90%A6%E5%88%99%E7%B1%BB%E5%BA%94%E8%AF%A5%E8%A2%AB%E6%8B%86%E5%88%86%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22Robert%20C.%20Martin%E3%80%8A%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%9A%E5%8E%9F%E5%88%99%E3%80%81%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AE%9E%E8%B7%B5%E3%80%8B%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;Robert C. Martin《敏捷软件开发：原则、模式和实践》&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只有深刻理解这个概念，你才能真正发挥面向对象编程语言的最大优势。并且，这个思路也可以运用在模块的划分上。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;遵循这一原则最关键的地方在于职责的划分，很多人其实并没有掌握好正确的划分思路。因为这个的确很难，需要你对业务有深入的了解，因为职责存在于业务里。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，在电商系统里体现「一个商品在某个平台销售」这个业务，你可以既在「商品」类上设置「销售渠道」属性，也可以在「销售渠道」上设置「在售商品列表」属性，还可以单独设计一个「商品绑定销售渠道」的类。但是我们从单一职责原则来考虑的话，就应该选择最后一个方案。为什么呢？因为在不同的渠道销售商品，其实对商品和销售渠道本身都没有什么影响，商品还是那个商品、渠道还是那个渠道，因此这个业务不是它们的职责。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;减少if else&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这一点可能算不上传统意义上的原则吧。但是我觉得这是很容易体现开发水平高低的一点。所以也列了一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大部分的 if-else 都可以合理运用设计模式来消灭掉。比如， 状态模式、策略模式、命令模式、责任链模式、代理模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果对这些设计模式的形态有些模糊了，那么赶紧去回顾一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数据冗余&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;冗余数据的确可以带来很多便利，比如减少RPC请求查询其它程序内的数据。但是副作用也是很明显的，付出了需要解决数据一致性问题为代价。因此仅当存在性能要求时，才考虑数据冗余。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在平时的代码设计中，你可以有很多方法来降低不必要的数据冗余，比如：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;给每一个API或者Function区分必要参数和可选参数。如此一来，对调用方来说能够减少为了传入可选参数而做的不必要的数据冗余以及RPC请求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果是会对外提供访问的API，一定要最小化参数，可以自行获取的数据尽量在内部自行获取，不要求外部传入。目的同1。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我觉得能意识到上面的这些设计原则，已经算得上是一个合格的程序员了。如果想要更近一步，还可以在以下这几个方面考虑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/01  对象设计/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;SOLID原则&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个原则鼎鼎大名了，应该大家都知道，就不展开说了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Single Responsibility Principle：单一职责原则&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Open Closed Principle：开闭原则&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Liskov Substitution Principle：里氏替换原则&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Law of Demeter：迪米特法则&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Interface Segregation Principle：接口隔离原则&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dependence Inversion Principle：依赖倒置原则&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我为什么将它们放到进阶里面呢，因为我觉得这里面除了单一职责，其它几个原则还兼顾着在可扩展性上的考量。所以，除了单一职责以外的原则没做到位，最多牺牲了可扩展性和一定的耦合度。但是单一职责没做好，可会存在非常大的耦合问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  数据准确性/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;可重试&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这点可能在单体应用中感受不明显。但是在分布式系统却重要得多。因为网络是不可靠的，如果设计的代码不可重试，那么会存在大量的数据不一致问题需要手动去处理。可头疼死你。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;幂等&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重视「幂等」的原因和「可重试」一样，在单体应用中作用不大，最多对瞬时的重复点击有作用。但是在不可靠网络的分布式系统中，某个请求被重复提交的可能性大大增加，如何保证多次请求的结果是一致的就至关重要了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;CAP、BASE&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面的「可重试」和「幂等」更多是在代码级别的数据准确性设计。如果在整个大系统层面考虑数据准确性，需要基于经典的CAP定理、BASE理论去设计。什么业务场景需要保证强一致性，什么业务场景可以接受存在延迟的最终一致性，是需要仔细考量的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多提一句，如果采用最终一致性方案的话，尽可能地增加一个后续的核对机制，以解决某些异步消息在中途丢失、长期异常挂起等等导致的数据不一致问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/03  数据存储/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;数据安全&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实，要在代码设计上考虑数据安全，只需要一些非常基础的业务意识就够了。你只要能识别到哪些数据是敏感的，针对这些数据做一些保护机制，防止数据泄漏。比如，加密、脱敏、避免越权、减少非必要传输等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上的这些是我目前暂时想到的在工作中最常用的开发原则。如果后续再想到什么我会补充在评论区，也欢迎你在评论区发表你的经验之谈。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还是总结一下，这篇呢Z哥与你分享了一些我在工作中常用的开发原则。总体来说，他们分为4类。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;耦合：避免循环依赖、尽量单向依赖、避免跨层调用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对象设计：单一职责原则、减少if else、数据冗余、SOLID原则。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据准确性：可重试、幂等、CAP、BASE。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据存储：数据安全。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望对你有所帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“大道理都懂，但还是过不好这一生”。这句话也能适用在这里，“开发原则都懂，但发现眼前的项目还是如此不堪”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;之所以如此，我觉得是因为很多时候，我们假装没看到项目里的代码坏味道，认为与自己没啥关系，孰不知，它很有可能在不久的将来给你一击“反噬”，让你不得不硬着头皮面对它。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」一下吧，鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以分享我的公众号名片给有需要的朋友们。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2NzEwMDc4OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1ENbrFbGjEucl1Az92hEuwmUSdaNXxibiaWuO9sLTPHokw00p8ZxAYdIJJJ7FXj77Ts0YoV5KwEKCA/0?wx_fmt=png&quot; data-nickname=&quot;跨界架构师&quot; data-alias=&quot;Zachary_ZF&quot; data-signature=&quot;坚持原创。专注大型互联网技术，涉猎产品、运营。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b144105616152d8d36cb5964fa175d60</guid>
<title>[推荐] [译] 2021 年 Java 集合面试 Top 问题（一）</title>
<link>https://toutiao.io/k/zbogucw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;原文:https://dzone.com/articles/top-java-collection-interview-questions-for-2021&lt;/p&gt;&lt;p&gt;作者: Sonia Mathias&lt;/p&gt;&lt;p&gt;翻译: 祝坤荣&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在Java中，集合是一种提供了存储与操作批量对象的框架。在JDK1.2中“集合框架”就被定义了，而且它提供了所有的集合类和接口。Java集合类中最主要的两个主要接口是Collection接口（java.util.Collection）和Map接口（java.util.Map）。Java集合框架提供的接口包括Set,List,Queue,Deque，提供类包括ArrayList,Vector,LinkedList,HashSet,PriorityQueue,TreeSet和LinkedHashSet。&lt;/p&gt;&lt;h2&gt;需要一个分离的集合框架&lt;/h2&gt;&lt;p&gt;如果我们不使用集合框架，标准的用于给Java对象分组的方法是Arrays,Vectors或者HashTable。他们都没有通用的接口。他们的实现都是被单独定义的且互相之间没有任何联系。因此，要去记住所有不同的方法，语法，和创建函数都很困难。&lt;/p&gt;&lt;p&gt;比如，如果要给Vector加一个元素我们会使用addElement()方法，而给Hashtable加一个元素则使用put()方法。&lt;/p&gt;&lt;h2&gt;使用集合框架的好处&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;降低编程负担：一个开发者可以聚焦在集合的最佳使用方法上而不是聚焦在集合的设计上。这对实现抽象有好处。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;提升编程速度：集合提供了一种数据结构的高性能实现，这可以提升速度。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;由于Java已经是一种广泛使用的语言了，大大小小的组织都在使用它。为自己准备好基础的和高级的Java面试题可以对面试有好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;让我们看看java面试中被问得最多的一些问题。&lt;/p&gt;&lt;h2&gt;对初级开发者问的最多的问题&lt;/h2&gt;&lt;p&gt;问题1：什么是Java中的框架？答：框架是提供了脚手架功能的一组类和对象的集合。理想的面向对象设计都应该有一个框架提供了对于集合类的同类型任务提供同样的操作。&lt;/p&gt;&lt;p&gt;问题2：定义Java的集合框架。答：Java的集合框架是一组接口和类的集合，提供了高效保存和处理数据的方法。Java集合框架提供的接口有Set，List，Queue，Deque，提供的类包括ArrayList,Vector,LinkedList,HashSet,PriorityQueue,TreeSet和LinkedHashSet。&lt;/p&gt;&lt;p&gt;问题3：Java集合框架中ArrayList与Vector的不同之处。答：ArrayList&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;不是synchronized的&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它可以以其数组大小的50%来扩展其大小&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它不是线程安全的&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它不是遗留类 Vector：&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它是synchronized的&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它可以增加自己双倍的大小&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它是线程安全的&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它是遗留类&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;问题4：Iterator与Enumeration的不同点。答：Iterator&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它可以遍历遗留类和非遗留类&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它比Enumeration慢&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它在遍历集合时可以执行remove操作&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它是fail-fast的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Enumeration&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它只能遍历遗留元素&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它比Iterator快&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它只能在集合上执行traverse&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它不是fail-fast的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;问题5：LinkedList与ArrayList的区别？答：ArrayList&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;这个类实现了list接口&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;这个类使用了动态数组来存储元素&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;插入与移除操作的最佳复杂度是O（1），而最差复杂度是O（n）。查询操作（如存储一个特定索引的元素）会需要O（1）的时间。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;ArrayList在存储和查询数据时能干的比较好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;LinkedList&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;这个类实现了list接口和deque接口。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;这个类存储元素使用了双链列表。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;插入与移除操作提供了O（1）的性能。查询操作（比如查询一个特定索引的元素）需要O（n）的时间。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;LinkedList在操作存储好的数据时性能更好。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;问题6：解释一下Queue接口的poll（）与remove（）方法的不同。答：两个方法都返回并移除队列头的内容。它们只有在队列为空时行为不一样；remove（）会抛一个异常而poll（）会返回null。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;问题7：Comparable与Comparator的不同。答：Comparable&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它提供了被排序元素使用的compareTo（）方法&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它属于java.lang包&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;排序逻辑必须要与我们想要排序的对象在同一个类中&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它提供单独的排序序列。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;实际类被改过了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Comparator&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它提供排序元素用的compare（）方法&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它在java.util包中&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;排序逻辑必须要在不同的类中，以便根据不同对象的不同属性来编写排序方法&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;它提供多种排序序列&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;实际类没有被改动&lt;/span&gt;&lt;/p&gt;&lt;p&gt;问题8：计算机内存中Stack的定义是？答：stack是计算机内存中一个特殊区域，用来存储函数创建的临时变量。在stack中，变量是在运行时被声明，存储和初始化的。&lt;/p&gt;&lt;p&gt;问题9：列出map接口的集合视图。答：集合视图（Collection view）方法可以让Map在以下&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;三种方式视为一个集合：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;键集合视图：Map中保存的所有键的Set集合。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;值集合视图：Map中保存的所有值的集合。这个集合不是一个Set，因为不同的主键key可以被映射到同一个值value。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Entry集合视图：Map中键值对的集合Set。Map接口提供了一个小的内嵌接口Map.Entry，元素都存储在这个Set。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;问题10：定义EnumSet。答：它是可以使用enum枚举类型的Set实现。所有的元素都必须属于一个特定的enum类型。它不是synchronized。NULL key是不允许的。&lt;/p&gt;&lt;p&gt;问题11：什么方法能让集合变成线程安全的？答：这些方法是：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Collections.synchronizedList(list);&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Collections.synchronizedMap(map);&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Collections.synchronizedSet(set);&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;问题12：Queue与Deque的不同点 答：Queue&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;众所周知是单向队列&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;队列中的元素在填加或删除都在同一端&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Less versatile Deque&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;是双端队列&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;队列中的元素可以从队尾填加或者从两端填加和删除。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;More versatile&lt;/span&gt;&lt;/p&gt;&lt;p&gt;问题13：hashmap与hashtable的不同 答：Hashmap&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;不是synchronized，不是线程安全&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;继承了AbstractMap类&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;允许一个null key和多个null value。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可以被iterator遍历 Hashtable&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Synchronized的，线程安全&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;继承了Dictionary类&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;不允许空key或者值&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可以被enumerator和iterator遍历&lt;/span&gt;&lt;/p&gt;&lt;p&gt;问题14：定义Iterator。答：Iterator（）是一个提供了遍历集合方法的接口。它提供了一种普世的方式来遍历集合中的元素，并实现了iterator设计模式。&lt;/p&gt;&lt;p&gt;问题15：什么是navigable map？答：NavigableMap接口，Java集合框架的成员，属于java.util包。它是SortedMap的子接口，提供了如lowerKey，floorKey，ceilingKey和higherKey这样方便的导航方法。它也提供了从现有map创建一个子map的方法。&lt;/p&gt;&lt;p&gt;问题16：什么是queue接口的peek（）？答：Peek（）返回了队列的头。它不移除任何元素。当队列为空时返回null。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;未完待续&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;本文来自祝坤荣(时序)的微信公众号「麦芽面包」，公众号id「darkjune_think」 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;开发者/科幻爱好者/硬核主机玩家/业余翻译 转载请注明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;微博:祝坤荣 B站: https://space.bilibili.com/23185593/&lt;/p&gt;&lt;p&gt;交流Email: &lt;span&gt;zhukunrong@yeah.net&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; zhukunrong@yeah.net: &lt;em&gt;mailto:zhukunrong@yeah.net&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>