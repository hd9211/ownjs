<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f3edf1b859ee8ff280db3074224f9fba</guid>
<title>从维护性工作到软件开发革命，运维 15 年间的大逆转</title>
<link>https://toutiao.io/k/xr13s7n</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
&lt;p id=&quot;app&quot;/&gt;
&lt;img src=&quot;https://static001.infoq.cn/static/infoq/img/logo-121-75.yuij86g.png&quot; alt=&quot;从维护性工作到软件开发革命，运维15年间的大逆转_DevOps_Tina_InfoQ精选文章&quot;/&gt;





    

&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>60b906bc208db3d6569275c07c574c47</guid>
<title>如何学习架构，一个系列帮助你构筑架构知识体系</title>
<link>https://toutiao.io/k/i9clyuy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-default-content content__default&quot;&gt;&lt;h1 id=&quot;♥架构---知识体系详解♥&quot;&gt;&lt;a href=&quot;#♥架构---知识体系详解♥&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; ♥架构 - 知识体系详解♥&lt;/h1&gt; &lt;div class=&quot;custom-block tip&quot;&gt;&lt;p class=&quot;custom-block-title&quot;&gt;TIP&lt;/p&gt; &lt;p&gt;本系列将带你梳理下架构相关的知识体系。@pdai&lt;/p&gt;&lt;/div&gt;  &lt;h2 id=&quot;如何学习架构&quot;&gt;&lt;a href=&quot;#如何学习架构&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 如何学习架构&lt;/h2&gt;  &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/arch/arch-x-overview-learn2.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;h3 id=&quot;基础到方法论&quot;&gt;&lt;a href=&quot;#基础到方法论&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 基础到方法论&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;包括架构的概述，特点，目标，本质以及方法论等&lt;/p&gt;&lt;/blockquote&gt;  &lt;h3 id=&quot;如何理解架构&quot;&gt;&lt;a href=&quot;#如何理解架构&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 如何理解架构&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;理解架构，包括架构的视角，架构的演进，服务化演进，架构的核心要素&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-view.html&quot;&gt;架构 - 理解构架的视角&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在学习架构时，我认为首先要理清楚架构的视角，&lt;strong&gt;因为你所认知的架构和别人所说的架构可能是两码事&lt;/strong&gt;。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-evolution.html&quot;&gt;架构 - 理解架构的演进&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在学习架构时，&lt;strong&gt;第一步不要去学习框架，而是要学习架构的演进&lt;/strong&gt;。强烈推荐李智慧老师的《大型网站技术架构》，这本书翻起来很快，对构筑你自己的体系很有帮助，本文的内容来源于它，在此基础上拓展了下。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-service.html&quot;&gt;架构 - 理解架构的服务演化&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Kubernetes、Service Mesh 和 Serverless应该是最近比较火的了，而上文主要从&lt;strong&gt;逻辑架构角度&lt;/strong&gt;分析了架构演进，本文将从&lt;strong&gt;服务演化&lt;/strong&gt;和&lt;strong&gt;容器编排化&lt;/strong&gt;的角度帮你增强对架构演进的认识。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-pattern.html&quot;&gt;架构 - 理解架构的模式1&lt;/a&gt; &lt;ul&gt;&lt;li&gt;架构演进中有很多知识点，总体上可以归结为以下模式，&lt;strong&gt;这里说的模式本质是架构中技术点的抽象&lt;/strong&gt;。强烈推荐李智慧老师的《大型网站技术架构》，本文的内容也是来源于它，在此基础上拓展了下。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-pattern-2.html&quot;&gt;架构 - 理解架构的模式2&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-x-core-metrics.html&quot;&gt;架构 - 理解架构的核心要素&lt;/a&gt; &lt;ul&gt;&lt;li&gt;一般来说软件架构需要关注&lt;strong&gt;性能、可用性、伸缩性、扩展性和安全性这5个架构要素&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;h3 id=&quot;架构高并发和高可用&quot;&gt;&lt;a href=&quot;#架构高并发和高可用&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 架构高并发和高可用&lt;/h3&gt; &lt;blockquote&gt;&lt;p&gt;架构高并发和高可用技术点主要包含如下方面。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-cache.html&quot;&gt;架构之高并发：缓存&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;高并发实现的三板斧：缓存，限流和降级&lt;/strong&gt;。缓存在高并发系统中有者极其广阔的应用，需要重点掌握，本文重点介绍下缓存及其实现。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-ratelimit.html&quot;&gt;架构之高并发：限流&lt;/a&gt; &lt;ul&gt;&lt;li&gt;每个系统都有服务的上线，所以当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。限流其实就是：当高并发或者瞬时高并发时，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价或者延迟处理请求为代价，保证系统整体服务可用。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-reduce.html&quot;&gt;架构之高并发：降级和熔断&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在高并发环境下，&lt;strong&gt;服务之间的依赖关系导致调用失败，解决的方式通常是: 限流-&amp;gt;熔断-&amp;gt;隔离-&amp;gt;降级, 其目的是防止雪崩效应&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-loadbalance.html&quot;&gt;架构之高可用：负载均衡&lt;/a&gt; &lt;ul&gt;&lt;li&gt;负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/arch/arch-y-backup.html&quot;&gt;架构之高可用：容灾备份,故障转移&lt;/a&gt; &lt;ul&gt;&lt;li&gt;容灾技术是系统的高可用性技术的一个组成部分，容灾系统更加强调处理外界环境对系统的影响，特别是灾难性事件对整个IT节点的影响，提供节点级别的系统恢复功能。故障转移（failover），即当活动的服务或应用意外终止时，快速启用&lt;strong&gt;冗余&lt;/strong&gt;或备用的服务器、系统、硬件或者网络接替它们工作。故障恢复是在计划内或计划外中断解决后&lt;strong&gt;切换回主站点&lt;/strong&gt;的过程。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;此外还需要关注下架构的安全。&lt;/p&gt;  &lt;h3 id=&quot;分层下看架构技术点&quot;&gt;&lt;a href=&quot;#分层下看架构技术点&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 分层下看架构技术点&lt;/h3&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/arch/arch-x-overview-layer2.jpg&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;p&gt;以上采用七层逻辑架构，第一层客户层，第二层前端优化层，第三层应用层，第四层服务层，第五层数据存储层，第六层大数据存储层，第七层大数据处理层。&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;客户层&lt;/strong&gt;：减少Http请求数，浏览器缓存，启用压缩，Js异步，减少Cookie传输；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;前端层&lt;/strong&gt;：DNS负载均衡，CDN本地加速，反向代理服务；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;：业务拆分；负载均衡，分级管理，应用缓存，服务集群，快速失败，异步调用，服务降级，消息队列，幂等设计等。&lt;/li&gt; &lt;li&gt;&lt;strong&gt;服务层&lt;/strong&gt;：提供公用服务，比如用户服务，订单服务，支付服务等；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;数据层&lt;/strong&gt;：分布式, 数据库集群，读写分离，NOSQL集群，文件系统集群；分布式缓存；冗余备份（冷，热备[同步，异步]，温备），失效转移（确认，转移，恢复）。CAP理论，一致性算法。&lt;/li&gt; &lt;li&gt;&lt;strong&gt;大数据存储层&lt;/strong&gt;：支持应用层和服务层的日志数据收集，关系数据库和NOSQL数据库的结构化和半结构化数据收集；&lt;/li&gt; &lt;li&gt;&lt;strong&gt;大数据处理层&lt;/strong&gt;：通过Mapreduce进行离线数据分析或Storm实时数据分析，并将处理后的数据存入关系型数据库。（实际使用中，离线数据和实时数据会按照业务要求进行分类处理，并存入不同的数据库中，供应用层或服务层使用）。&lt;/li&gt;&lt;/ul&gt; &lt;h3 id=&quot;架构案例分析&quot;&gt;&lt;a href=&quot;#架构案例分析&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 架构案例分析&lt;/h3&gt;  &lt;p&gt;&lt;strong&gt;更多待整合的文章&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;如何从 0 到 1 设计、构建移动分析架构
https://blog.csdn.net/weixin_44326589/article/details/93463878&lt;/p&gt; &lt;p&gt;蚂蚁金服面对亿级并发场景的组件体系设计
https://juejin.im/post/5cda3131e51d4514df42076f&lt;/p&gt; &lt;p&gt;高德服务单元化方案和架构实践
https://yq.aliyun.com/articles/728021&lt;/p&gt; &lt;p&gt;从 0 到 100——知乎架构变迁史
https://www.infoq.cn/article/2014/12/zhihu-architecture-evolution/
https://www.jianshu.com/p/2639b7bb0d74&lt;/p&gt; &lt;p&gt;蚂蚁金服 11.11：支付宝和蚂蚁花呗的技术架构及实践
https://www.infoq.cn/article/technical-architecture-of-alipay-and-ant-check-later/&lt;/p&gt; &lt;p&gt;新浪微博王传鹏：微博推荐架构的演进
http://www.uml.org.cn/zjjs/2015092801.asp&lt;/p&gt; &lt;p&gt;互联网公司技术架构，微信/淘宝/微博/腾讯/阿里/美团点评/百度/Google/Facebook/Amazon/eBay的架构
https://github.com/davideuler/architecture.of.internet-product&lt;/p&gt;&lt;/div&gt; &lt;footer class=&quot;page-edit&quot;&gt; &lt;p class=&quot;last-updated&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;上次更新: &lt;/span&gt; &lt;span class=&quot;time&quot;&gt;2022/5/17 下午10:43:17&lt;/span&gt;&lt;/p&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ddbdb065bf9499af70fdb18f8f106621</guid>
<title>从HTTP.TRANSPORT看连接池的设计</title>
<link>https://toutiao.io/k/sl5a7p7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content e-content&quot; itemprop=&quot;description articleBody&quot;&gt;&amp;#13;
            &lt;pre&gt;&lt;code class=&quot;&quot;&gt;版权声明 本站原创文章 由 萌叔 发表
转载请注明 萌叔 | http://vearne.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文基于Golang 1.17.6&lt;/p&gt;
&lt;h2&gt;1.前言&lt;/h2&gt;
&lt;p&gt;之前萌叔曾在文章&lt;br/&gt;
&lt;a href=&quot;https://vearne.cc/archives/448&quot;&gt;imroc/req 连接池使用须知&lt;/a&gt; 提及过Golang标准库net/http提供的连接池http.Transport，但是是浅尝辄止。&lt;br/&gt;
本文萌叔想从http.Transport出发来谈谈一个连接池设计应该考虑哪些问题？&lt;/p&gt;
&lt;h2&gt;2.连接池的功能特征&lt;/h2&gt;
&lt;p&gt;下图是针对Grpc和Thrift压测结果(见参考资料1)。我么可以看出，长连接相比与短连接相比，QPS大概提升了1倍多。这是因为长连接减少连接建立的所需的3次握手。&lt;br/&gt;
&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220620/607da666-f04a-11ec-8e33-5626e1cdcfe1.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
要对长连接进行管理，特别是对闲置的长连接进行管理，就不可避免的引入连接池。&lt;/p&gt;
&lt;h2&gt;特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;需要一个连接时，并不一定真的创建新连接，而是优先尝试从连接池选出空闲连接;如果连接池对应的连接为空，才创建新连接。&lt;/li&gt;
&lt;li&gt;销毁并不是真的销毁，而是将使用完毕的连接放回连接池中（逻辑关闭）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里引出了几个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q1:获取连接阶段，我们有没有办法知道从连接池中取出的空闲连接(复用)是有效的，还是无效的？&lt;/li&gt;
&lt;li&gt;Q2:把使用完毕的连接放回连接池的阶段，空闲连接数量是否要做上限的约束。如果空闲连接数量有上限约束且空闲连接的数量已经达到上限。那么把连接放回连接池的过程，必然需要将之前的某个空闲连接进行关闭，那么按照什么规则选择这个需要关闭的连接。&lt;/li&gt;
&lt;li&gt;Q3:放置在连接池中的连接，随着时间的流逝，它可能会变成无效连接(stale)。比如由于Server端定时清理空闲连接。那么为了确保连接池中连接的有效性，是否需要引入定时的检查逻辑？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.net/http中连接池的实现&lt;/h2&gt;
&lt;p&gt;net/http中连接池的实现代码在&lt;br/&gt;
&lt;a href=&quot;https://github.com/golang/go/blob/go1.17.6/src/net/http/transport.go#L95&quot;&gt;net/http/transport.go&lt;/a&gt; 中&lt;/p&gt;
&lt;h3&gt;获取连接&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;Transport.RoundTrip() -&amp;gt; Transport.getConn()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;放回连接(逻辑关闭)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;Response.Body.Close() -&amp;gt; bodyEOFSignal.Close() -&amp;gt; Transport.tryPutIdleConn()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220620/a7f64d94-f05a-11ec-9d25-5626e1cdcfe1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了约束空闲连接的数量，连接池引入了几个变量:&lt;br/&gt;
&lt;code&gt;MaxIdleConns&lt;/code&gt; MaxIdleConns controls the maximum number of idle (keep-alive) connections across all hosts.&lt;br/&gt;
所有host总的最大空闲连接数量，默认值是100&lt;br/&gt;
&lt;code&gt;MaxIdleConnsPerHost&lt;/code&gt;if non-zero, controls the maximum idle&lt;br/&gt;
(keep-alive) connections to keep per-host。&lt;br/&gt;
针对每个Host能够保持的最大空闲连接数量。默认值是2&lt;br/&gt;
这个是一个比较有意思的变量，因为默认情况，所有的HTTP请求都使用同一个连接池，由于&lt;code&gt;MaxIdleConns&lt;/code&gt;存在，如果针对某个Host的 连接占用了大量空间，那么针对其它Host的连接可能就没有存储空间了。&lt;br/&gt;
&lt;code&gt;MaxConnsPerHost&lt;/code&gt; MaxConnsPerHost optionally limits the total number of connections per host, including connections in the dialing, active, and idle states.&lt;br/&gt;
默认值是0，表示不限制。&lt;/p&gt;
&lt;h3&gt;有意思的点&lt;/h3&gt;
&lt;p&gt;transport中的连接是按照key存储，key可以对应到下面的结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;type connectMethod struct {
    _            incomparable
    proxyURL     *url.URL // nil for no proxy, else full proxy URL
    targetScheme string   // &quot;http&quot; or &quot;https&quot;
    // If proxyURL specifies an http or https proxy, and targetScheme is http (not https),
    // then targetAddr is not included in the connect method key, because the socket can
    // be reused for different targetAddr values.
    targetAddr string
    onlyH1     bool // whether to disable HTTP/2 and force HTTP/1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;connectMethod.key().String()&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;|http|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|https|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|https,h1|foo.com&lt;/td&gt;
&lt;td&gt;https directly to server w/o HTTP/2, no proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;http to proxy, then CONNECT to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http://proxy.com|http&lt;/td&gt;
&lt;td&gt;http to proxy, http to anywhere after that&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;socks5://proxy.com|http|foo.com&lt;/td&gt;
&lt;td&gt;socks5 to proxy, then http to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;socks5://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;socks5 to proxy, then https to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;https://proxy.com|https|foo.com&lt;/td&gt;
&lt;td&gt;https to proxy, then CONNECT to foo.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;https://proxy.com|http&lt;/td&gt;
&lt;td&gt;https to proxy, http to anywhere after that&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 目标地址如果是同一个域名则算作同一个Host&lt;/p&gt;
&lt;h3&gt;Q2：把连接放回连接池的过程，必然需要将之前的某个空闲连接进行关闭，那么按照什么规则选择这个需要关闭的连接。&lt;/h3&gt;
&lt;h3&gt;A2：&lt;/h3&gt;
&lt;p&gt;如果连接池已经满了（MaxIdleConns），那么放回空闲连接的同时，还需要从连接池中选出一个旧连接进行关闭。这个选择的规则依据LRU进行筛选。net/http使用的双向链表。&lt;/p&gt;
&lt;h3&gt;Q3: 为了确保连接池中连接的有效性，是否需要引入定时的检查逻辑？&lt;/h3&gt;
&lt;h3&gt;A3:&lt;/h3&gt;
&lt;p&gt;net/http没有引入定期检查逻辑，但是额外的增加了一个变量&lt;br/&gt;
&lt;code&gt;IdleConnTimeout&lt;/code&gt;: IdleConnTimeout is the maximum amount of time an idle (keep-alive) connection will remain idle before closing itself.&lt;br/&gt;
超过&lt;code&gt;IdleConnTimeout&lt;/code&gt;的空闲连接将强制关闭。默认设置是90秒。&lt;/p&gt;
&lt;p&gt;这个逻辑可能是：”过长时间的空闲连接都是不可信赖的”&lt;/p&gt;
&lt;p&gt;一个从连接池中获得的连接只有在真正使用时，才能确定它是否有效。&lt;br/&gt;
如果连接在使用时报错，需要执行shouldRetryRequest()以确定是否需要获取新连接来执行失败的HTTP请求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;&quot;&gt;func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool {
        ...
    if err == errServerClosedIdle {
        // The server replied with io.EOF while we were trying to
        // read the response. Probably an unfortunately keep-alive
        // timeout, just as the client was writing a request.
        return true
    }
    return false // conservatively
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如如果是&lt;code&gt;errServerClosedIdle&lt;/code&gt;，服务端关闭了空闲连接导致请求失败，那么显然应该重新获取一个新连接，再发起一次请求。&lt;/p&gt;
&lt;h2&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;看net/http的连接池，萌叔发现它与数据库的连接池、甚至与进程内的本地缓存在设计要点有很多相似之处。比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接池大小的限制  缓存大小的限制&lt;/li&gt;
&lt;li&gt;stale空闲连接的检查  过期key的清理&lt;/li&gt;
&lt;li&gt;达到空闲连接上限后，连接的换入换出  缓存满了之后，数据的换入换出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. 参考资料&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://blog.csdn.net/Com_ma/article/details/97134775&quot;&gt;grpc和thrift性能对比&lt;/a&gt;&lt;br/&gt;
2.&lt;a href=&quot;https://juejin.cn/post/6844903853872119822&quot;&gt;如何设计并实现一个db连接池？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;请我喝瓶饮料&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ut-bucket01.sh1a.qingstor.com/woshiaotian/20220421/e824ac06-c136-11ec-8e0e-5626e1cdcfe2.jpg&quot; alt=&quot;微信支付码&quot;/&gt;&lt;/p&gt;


            &lt;p class=&quot;clear&quot;/&gt;&amp;#13;
        &lt;/div&gt;&amp;#13;
        
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>352eb263dd2770c89f70f6ba4cb9c644</guid>
<title>字节跳动基于 Iceberg 的海量特征存储实践</title>
<link>https://toutiao.io/k/kekzyb3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;火山引擎开发者社区&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;VolcanoEngineToD&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;火山引擎开发者社区是火山引擎的 TOD 社区，致力于链接火山引擎和开发者，为大家提供前沿技术内容和丰富的技术活动，打造更好的开发者文化和氛围，共建开源生态。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b129f9abf21eb4be07a6a3ae2025e3b8</guid>
<title>通过 Goyacc 构建 Elasticsearch Querystring 解析器 - 领域特定语言语法分析实践</title>
<link>https://toutiao.io/k/ymqs51t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;领域特定语言（DSL），如 SQL、Elasticsearch Querystring 等，往往是为专门的目的设计的。在特定的任务中，DSL 通过在表达能力上做的妥协换取在某一领域内的高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在飞书套件日志系统的私有化研发过程中，为了符合研发同学查询日志的习惯，尝试使用 Elasticquery Querystring（下简称为 Querystring）作为过滤器的查询条件语句，由此需要可用的 Golang Querystring 解析器。由于目前开源界无法找到完善的实现，尝试使用 Goyacc 自行构建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Yacc 是一个被普遍采用的编译器代码生成器，生成出的代码主要用于语法分析阶段，常常与作为词法分析器的 lex 匹配使用，使用 LALR 算法，将源代码构建为抽象语法树（AST）。Goyacc 是 yacc 的 Golang 版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文尝试实现的 Querystring 解析器本质上是词法分析器和语法分析器的组合。语法分析器由 Goyacc 生成；为了方便实现符合 Querystring 习惯的反转义，词法分析器是自行实现的。Yacc 和它在各个语言上的实现，中文互联网上较少有具体的介绍。本文会尽量详细的描述 Goyacc 实践中可能需要注意的点。所述的 Querystring 解析器代码可在 https://github.com/bytedance/go-querystring-parser 此处查看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;框架&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一套完整的应用 Goyacc 的 DSL 解析器包含以下部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语法分析器（parser）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;词法分析器（lexer）&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;较为简单的做法，是采用&lt;code&gt;Scanner&lt;/code&gt;来进行构建；当存在特殊需求时，一般自行构建。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;AST 节点的定义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;包装实体与工具函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致流程为，语法分析器调用词法分析器将源代码拆解为基本「Token（记号）」，根据语法规程将若干个「Token」组合成「Expr（表达式）」（Token 本身也被作为 Expr 处理）。「Expr」的结构构建在「AST」中，得到结果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;语法分析器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语法分析（syntactic analysis，或 parsing）是根据某种给定的形式文法对由记号序列构成的输入文本进行分析并确定其语法结构的一种过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语法分析器的作用是进行语法检查、并构建由输入的记号组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的「记号」，并将记号流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本例中，即为工具自动生成。使用巴科斯范式描述对应的语法定义，并使用 goyacc 生成 golang 代码，提供一个 LALR 语法分析器，并定义了供 lexer 返回的 token 定义。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装 Goyacc&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在安装了 golang 的环境中，执行：&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;go &lt;span&gt;get&lt;/span&gt; -u golang.org/x/tools/cmd/goyacc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如安装后无法正常运行，请检查 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 是否加入到了 &lt;code&gt;$PATH&lt;/code&gt; 中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goyacc 语法定义文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 yacc 语法定义文件，一般由以下若干部分构成。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;头部目标语言代码&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可参考「附录一:L1-L3」，使用 &lt;code&gt;%{&lt;/code&gt; 和 &lt;code&gt;}%&lt;/code&gt; 将需要的目标语言原生代码段落包围起来。目标语言往往涉及到语言应用中的一些头部代码。在例子里，golang 所需的包名称定义等需要通过这一部分添加进来。其他的例子如常量的定义、结构体的定义等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;Union（集合）声明&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可参考「附录一:L5-L9」，以 &lt;code&gt;%union{}&lt;/code&gt; 格式定义，只可定义一次。「Union」这一概念包含了下述类型声明中的各个类型，及这些类型对应的目标语言类型（即 Golang 中的类型）。与 c 语言中 union 的概念类似，在目标代码中（生成为 &lt;code&gt;yySymType&lt;/code&gt;），union 将被生成为一个结构体（struct），根据「类型声明」，将匹配出的值放到结构体的对应字段中，作为存放/传递值的媒介而存在。在例子中，&lt;code&gt;s&lt;/code&gt;即为&lt;code&gt;string&lt;/code&gt;，类型声明中凡是标记为 s 类型的「表达式」，都会被保存到&lt;code&gt;s&lt;/code&gt;字段中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;Token（记号）声明&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可参考「附录一:L11-L14」，以 &lt;code&gt;%token&lt;/code&gt; 为行首的记号声明列表。对于 lexer 会直接分析出的 token，需要通过「Token 声明」来列出。Token 声明本身不需要关注顺序和组合，只需要单独列出需要由 lexer 输出的 token 类型即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;Type（类型）声明&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可参考「附录一:L11-L14」，以 &lt;code&gt;%type &amp;lt;%TYPE%&amp;gt;&lt;/code&gt; 为行首的记号声明列表，&lt;code&gt;%TYPE%&lt;/code&gt; 为本行所列举的「Expr」将会保存到的 union 中的字段/类型。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;声明与语法定义规则间的分隔符&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各个声明与语法规则定义间，以 &lt;code&gt;%%&lt;/code&gt; 分隔（L23）。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;语法规则定义&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可参考「附录一:L25-L202」，语法规则使用巴科斯范式（Backus Normal Form，缩写为 BNF）定义。在 Goyacc（及它仿造的 yacc）中，以摘自「附录一:L53-L64」定义的一个 expr 为例，大致由以下部分构成：&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;searchLogicPart:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;searchLogicSimplePart {&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    $$ = $1&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;}&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;|&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;searchLogicSimplePart tAND searchLogicPart {&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;    $$ = NewAndCondition($1, $3)&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;}&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;searchLogicSimplePart tOR searchLogicPart {&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;    $$ = NewOrCondition($1, $3)&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;L1 被定义的 expr 的名称，本例中 expr 的名称为 &lt;code&gt;searchLogicPart&lt;/code&gt;，在其他位置上将通过这个名称来引用这个 expr 及其格式定义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;L2-L4、L6-L8、L10-L12 expr 语法规则，以 L6-L8 部分为例，由两个部分构成：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;L6 匹配格式，本语句由三个部分构成，分别是：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个 &lt;code&gt;searchLogicSimplePart&lt;/code&gt; expr，在「附录一:L66」处定义，逻辑语句的单一元素，或 NOT 逻辑元素，或使用括号强制优先结合的若干元素集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 &lt;code&gt;tAND&lt;/code&gt; expr，实际上为 token，在 lexer 中分析并给出的类型，源码中为&lt;code&gt;AND&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 &lt;code&gt;searchLogicPart&lt;/code&gt; expr，即本段落中定义的语句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;L7 行为（action），即匹配完成后对匹配到的元素进行的行为，在匹配格式后以 &lt;code&gt;{&lt;/code&gt;、&lt;code&gt;}&lt;/code&gt; 包围&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实际上是代码生成模板，以目标语言（Golang）完成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;$$&lt;/code&gt; 将生成为当前 expr 的 union 中对应的字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例如 L7 中的 &lt;code&gt;$$&lt;/code&gt;，因 &lt;code&gt;searchLogicPart&lt;/code&gt; 在 type 声明中，使用的 type 是 q（见「附录一:L20」），因此将生成为 &lt;code&gt;yyVAL.q&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以此类推，&lt;code&gt;$1&lt;/code&gt;、&lt;code&gt;$3&lt;/code&gt; 分别将生成为第一个匹配项和第三个匹配项对应的类型字段，也即第一和第三匹配项的值，根据类型定义，即 &lt;code&gt;yyDollar[1].q&lt;/code&gt; 和 &lt;code&gt;yyDollar[3].q&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;L7 在目标代码中，将生成为 &lt;code&gt;yyVAL.q = NewAndCondition(yyDollar[1].q,&lt;/code&gt; &lt;code&gt;yyDollar[3].q)&lt;/code&gt;，&lt;code&gt;NewAndCondition&lt;/code&gt; 为另行定义的函数。也即使用匹配到的第一个项和第三个项，构成一个 AND 逻辑组合条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行为可以由不定行代码生成模板构成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;L5、L9 使用 &lt;code&gt;|&lt;/code&gt; 分隔 expr 可能的语法规则，也就是说，将匹配三种规则中的任意一种。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;L12 一个 expr 语法规则定义完成后，使用 &lt;code&gt;;&lt;/code&gt; 作为结尾。需要额外注意的点：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对语法的定义不应当有二义性，也不可以对不定个数的元素进行匹配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在有需要的场景下，可以直接操作 parser 函数上下文中含有的其他变量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span&gt;yacc 的生成&lt;/span&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用命令 &lt;code&gt;goyacc -o querystring.y.go querystring.y&lt;/code&gt; 生成目标语言代码，在 yacc 定义中使用的 golang 函数/结构体等，都应当预先定义在同一包/目标语言代码中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目标语言代码的使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成出的代码，将包含一个主入口 &lt;code&gt;yyParse&lt;/code&gt; 函数。主入口函数接收 &lt;code&gt;yyLexer&lt;/code&gt; 即词法分析器实例这一参数。在实际使用中，可使用词法分析器实例将分析结果 AST 返回。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;词法分析器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;词法分析（lexical analysis）是计算机科学中将字符序列转换为记号（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称 lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的记号是一个字串，是构成源代码的最小单位。在这个过程中，词法分析器还会对记号进行分类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Goyacc 的实际使用中，词法分析器提供了三个特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;词法分析，即 &lt;code&gt;Lex(lval *yySymType) (tokenType int)&lt;/code&gt; 函数，从源代码流中，读出下一个记号，将这一记号的值通过传入的 union 指针返回（即 &lt;code&gt;lval&lt;/code&gt;），将这一记号的类型通过返回值返回（即 &lt;code&gt;tokenType&lt;/code&gt;）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误记录，即 &lt;code&gt;Error(s string)&lt;/code&gt; 函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AST 的返回，由于 yyParse 没有提供其他有效的返回途径，这一实例还作为整体解析上下文来使用，带回解析完成的 AST。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个较为简单的实现方式，是使用 Scanner 配合对字符的匹配，将值放置于传入的指针，并返回对应的类型。由于 Querystring 在转义/反转义上的特殊习惯，本例中对应的 lexer 是自行实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现一个词法分析器，大致需要以下部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个字符串流，记录了内容、目前读到的位置等信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前状态的管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AST 节点的定义&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据语法的定义，构建 AST 的过程中，需要根据语义分别使用不同的节点类型，以方便对 AST 的使用。这一过程中，需要对 AST 节点进行定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Querystring AST 中，定义了以下类型的节点，并提供了若干工具函数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;AndCondition&lt;/code&gt;，与逻辑条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;OrCondition&lt;/code&gt;，或逻辑条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NotCondition&lt;/code&gt;，非逻辑条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MatchCondition&lt;/code&gt;，匹配条件，根据字段类型决定为全等匹配或全文匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;RegexpCondition&lt;/code&gt;，正则条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;WildcardCondition&lt;/code&gt;，通配符条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NumberRangeCondition&lt;/code&gt;，数值 Range 条件，数值相关的各类条件都归一到此类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TimeRangeCondition&lt;/code&gt;，时间 Range 条件，时间相关的各类条件都归一到此类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些开源库中，会在这一部分添加遍历相关的 Method，以方便使用者对 AST 进行遍历。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;包装实体与工具函数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于语法分析器提供的函数多为私有函数，也需要通过词法分析器对输入的源代码进行包裹，一般需要若干个工具函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本例中，主要提供了解析入口函数，主要功能为：输入一个 Querystring 格式的字符串，使用 lexer 实例进行包装，运行 parser，并返回过程中输出的错误。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AST 的使用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Querystring 作为查询条件，使用过程中，一般需要注意以下几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;查询条件的优化。用户输入的查询条件经常是无序的：有时相同的条件会多次出现在不同的位置，可以予以合并；对同一字段的过滤行为可以合并在一起，来降低 local cache 成本；有的条件可能是逻辑上无效的，可以剔除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类型推断。在数值类型中，根据 Elasticsearch 的官方实现，Querystring 中形似数字的值，可能作为整数、浮点数、字符串或时间处理。应当通过被过滤的数据的情况，对值的类型做二次推断。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;附录一：Querystring goyacc 定义&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可通过 https://github.com/bytedance/go-querystring-parser/blob/main/querystring.y 查看&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt; 1&lt;/span&gt;&lt;span&gt;%{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  2&lt;/span&gt;&lt;span&gt;package querystring&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  3&lt;/span&gt;&lt;span&gt;%}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  5&lt;/span&gt;&lt;span&gt;%union {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  6&lt;/span&gt;&lt;span&gt;    s   string&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  7&lt;/span&gt;&lt;span&gt;    n   int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  8&lt;/span&gt;&lt;span&gt;    q   Condition&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  9&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 10&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 11&lt;/span&gt;&lt;span&gt;%token tSTRING tPHRASE tNUMBER&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 12&lt;/span&gt;&lt;span&gt;%token tAND tOR tNOT tTO tPLUS tMINUS tCOLON&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 13&lt;/span&gt;&lt;span&gt;%token tLEFTBRACKET tRIGHTBRACKET tLEFTRANGE tRIGHTRANGE&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 14&lt;/span&gt;&lt;span&gt;%token tGREATER tLESS tEQUAL&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 15&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 16&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; &amp;lt;s&amp;gt;                tSTRING&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 17&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; &amp;lt;s&amp;gt;                tPHRASE&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 18&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; &amp;lt;s&amp;gt;                tNUMBER&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 19&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; &amp;lt;s&amp;gt;                posOrNegNumber&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; &amp;lt;q&amp;gt;                searchBase searchParts searchPart searchLogicPart searchLogicSimplePart&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 21&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt; &amp;lt;n&amp;gt;                searchPrefix&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 22&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 23&lt;/span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 24&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 25&lt;/span&gt;&lt;span&gt;input:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 26&lt;/span&gt;&lt;span&gt;searchParts {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 27&lt;/span&gt;&lt;span&gt;    yylex.(*lexerWrapper).query = &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 28&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 29&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 30&lt;/span&gt;&lt;span&gt;searchParts:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 31&lt;/span&gt;&lt;span&gt;searchPart searchParts {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 32&lt;/span&gt;&lt;span&gt;    $$ = NewAndCondition(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;$2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 33&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 34&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 35&lt;/span&gt;&lt;span&gt;searchPart {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 36&lt;/span&gt;&lt;span&gt;    $$ = &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 37&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 38&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 39&lt;/span&gt;&lt;span&gt;searchPart:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 40&lt;/span&gt;&lt;span&gt;searchPrefix searchBase {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 41&lt;/span&gt;&lt;span&gt;    switch(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 42&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; queryMustNot:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 43&lt;/span&gt;&lt;span&gt;        $$ = NewNotCondition(&lt;/span&gt;&lt;span&gt;$2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 44&lt;/span&gt;&lt;span&gt;    default:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 45&lt;/span&gt;&lt;span&gt;        $$ = &lt;/span&gt;&lt;span&gt;$2&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 46&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 47&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 48&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 49&lt;/span&gt;&lt;span&gt;searchLogicPart {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 50&lt;/span&gt;&lt;span&gt;    $$ = &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 51&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 52&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 53&lt;/span&gt;&lt;span&gt;searchLogicPart:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 54&lt;/span&gt;&lt;span&gt;searchLogicSimplePart {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 55&lt;/span&gt;&lt;span&gt;    $$ = &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 56&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 57&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 58&lt;/span&gt;&lt;span&gt;searchLogicSimplePart tAND searchLogicPart {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 59&lt;/span&gt;&lt;span&gt;    $$ = NewAndCondition(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;$3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 60&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 61&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 62&lt;/span&gt;&lt;span&gt;searchLogicSimplePart tOR searchLogicPart {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 63&lt;/span&gt;&lt;span&gt;    $$ = NewOrCondition(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;$3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 64&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 65&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 66&lt;/span&gt;&lt;span&gt;searchLogicSimplePart:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 67&lt;/span&gt;&lt;span&gt;searchBase {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 68&lt;/span&gt;&lt;span&gt;    $$ = &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 69&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 70&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 71&lt;/span&gt;&lt;span&gt;tLEFTBRACKET searchLogicPart tRIGHTBRACKET {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 72&lt;/span&gt;&lt;span&gt;    $$ = &lt;/span&gt;&lt;span&gt;$2&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 73&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 74&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 75&lt;/span&gt;&lt;span&gt;tNOT searchLogicSimplePart {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 76&lt;/span&gt;&lt;span&gt;    $$ = NewNotCondition(&lt;/span&gt;&lt;span&gt;$2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 77&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 78&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 79&lt;/span&gt;&lt;span&gt;searchPrefix:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 80&lt;/span&gt;&lt;span&gt;tPLUS {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 81&lt;/span&gt;&lt;span&gt;    $$ = queryMust&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 82&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 83&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 84&lt;/span&gt;&lt;span&gt;tMINUS {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 85&lt;/span&gt;&lt;span&gt;    $$ = queryMustNot&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 86&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 87&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 88&lt;/span&gt;&lt;span&gt;searchBase:&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 89&lt;/span&gt;&lt;span&gt;tSTRING {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 90&lt;/span&gt;&lt;span&gt;    $$ = newStringCondition(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 91&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 92&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 93&lt;/span&gt;&lt;span&gt;tNUMBER {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 94&lt;/span&gt;&lt;span&gt;    $$ = NewMatchCondition(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 95&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 96&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 97&lt;/span&gt;&lt;span&gt;tPHRASE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 98&lt;/span&gt;&lt;span&gt;    phrase := &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 99&lt;/span&gt;&lt;span&gt;    q := NewMatchCondition(phrase)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;101&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;102&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;103&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tSTRING {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;104&lt;/span&gt;&lt;span&gt;    q := newStringCondition(&lt;/span&gt;&lt;span&gt;$3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;105&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;106&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;107&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;108&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;109&lt;/span&gt;&lt;span&gt;tSTRING tCOLON posOrNegNumber {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;110&lt;/span&gt;&lt;span&gt;    val := &lt;/span&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;    q := NewNumberRangeCondition(&amp;amp;val, &amp;amp;val, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;112&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;113&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;114&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;115&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;116&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tPHRASE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;117&lt;/span&gt;&lt;span&gt;    q := NewMatchCondition(&lt;/span&gt;&lt;span&gt;$3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;118&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;119&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;120&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;121&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;122&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tGREATER posOrNegNumber {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;    val := &lt;/span&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;124&lt;/span&gt;&lt;span&gt;    q := NewNumberRangeCondition(&amp;amp;val, nil, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;125&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;126&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;127&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;128&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;129&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tGREATER tEQUAL posOrNegNumber {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;130&lt;/span&gt;&lt;span&gt;    val := &lt;/span&gt;&lt;span&gt;$5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;131&lt;/span&gt;&lt;span&gt;    q := NewNumberRangeCondition(&amp;amp;val, nil, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;132&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;133&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;134&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;135&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;136&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tLESS posOrNegNumber {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;137&lt;/span&gt;&lt;span&gt;    val := &lt;/span&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;138&lt;/span&gt;&lt;span&gt;    q := NewNumberRangeCondition(nil, &amp;amp;val, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;139&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;140&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;141&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;142&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;143&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tLESS tEQUAL posOrNegNumber {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;144&lt;/span&gt;&lt;span&gt;    val := &lt;/span&gt;&lt;span&gt;$5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;145&lt;/span&gt;&lt;span&gt;    q := NewNumberRangeCondition(nil, &amp;amp;val, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;146&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;147&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;148&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;149&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tGREATER tPHRASE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;151&lt;/span&gt;&lt;span&gt;    phrase := &lt;/span&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;152&lt;/span&gt;&lt;span&gt;    q := NewTimeRangeCondition(&amp;amp;phrase, nil, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;153&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;154&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;155&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;156&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;157&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tGREATER tEQUAL tPHRASE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;158&lt;/span&gt;&lt;span&gt;    phrase := &lt;/span&gt;&lt;span&gt;$5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;159&lt;/span&gt;&lt;span&gt;    q := NewTimeRangeCondition(&amp;amp;phrase, nil, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;160&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;161&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;162&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;163&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;164&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tLESS tPHRASE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;165&lt;/span&gt;&lt;span&gt;    phrase := &lt;/span&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;166&lt;/span&gt;&lt;span&gt;    q := NewTimeRangeCondition(nil, &amp;amp;phrase, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;167&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;168&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;169&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;170&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;171&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tLESS tEQUAL tPHRASE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;172&lt;/span&gt;&lt;span&gt;    phrase := &lt;/span&gt;&lt;span&gt;$5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;173&lt;/span&gt;&lt;span&gt;    q := NewTimeRangeCondition(nil, &amp;amp;phrase, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;174&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;175&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;176&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;177&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;178&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tLEFTRANGE posOrNegNumber tTO posOrNegNumber tRIGHTRANGE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;179&lt;/span&gt;&lt;span&gt;    min := &lt;/span&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;180&lt;/span&gt;&lt;span&gt;    max := &lt;/span&gt;&lt;span&gt;$6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;181&lt;/span&gt;&lt;span&gt;    q := NewNumberRangeCondition(&amp;amp;min, &amp;amp;max, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;182&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;183&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;184&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;185&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;186&lt;/span&gt;&lt;span&gt;tSTRING tCOLON tLEFTRANGE tPHRASE tTO tPHRASE tRIGHTRANGE {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;187&lt;/span&gt;&lt;span&gt;    min := &lt;/span&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;188&lt;/span&gt;&lt;span&gt;    max := &lt;/span&gt;&lt;span&gt;$6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;189&lt;/span&gt;&lt;span&gt;    q := NewTimeRangeCondition(&amp;amp;min, &amp;amp;max, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;190&lt;/span&gt;&lt;span&gt;    q.SetField(&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;191&lt;/span&gt;&lt;span&gt;    $$ = q&lt;/span&gt;&lt;br/&gt;&lt;span&gt;192&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;193&lt;/span&gt;&lt;br/&gt;&lt;span&gt;194&lt;/span&gt;&lt;span&gt;posOrNegNumber:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;195&lt;/span&gt;&lt;span&gt;tNUMBER {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;196&lt;/span&gt;&lt;span&gt;    $$ = &lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;197&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;198&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;br/&gt;&lt;span&gt;199&lt;/span&gt;&lt;span&gt;tMINUS tNUMBER {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;    $$ = &lt;/span&gt;&lt;span&gt;&quot;-&quot;&lt;/span&gt;&lt;span&gt; + &lt;/span&gt;&lt;span&gt;$2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;201&lt;/span&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;附录二：参考链接&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://godoc.org/golang.org/x/tools/cmd/goyacc&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://about.sourcegraph.com/go/gophercon-2018-how-to-write-a-parser-in-go/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://github.com/xwb1989/sqlparser&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.lysator.liu.se/c/ANSI-C-grammar-y.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>