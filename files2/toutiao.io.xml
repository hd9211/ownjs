<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6da516fae7465adace861f0d1f853646</guid>
<title>越是不确定性的时代，你越需要这份确定！</title>
<link>https://toutiao.io/k/uy0frh6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>adfc131b7ca050fd0791f4f6a39f4b78</guid>
<title>全栈工程师修炼手册</title>
<link>https://toutiao.io/k/9z9qrw5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4Njk2NDAzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ5p4x0RLv7ZmauGJfcichQt3zPj5VRgP8EPt6fC2siaonvQPEwQBCSGicvz84j80wse9l297PtLEd8Bg/0?wx_fmt=png&quot; data-nickname=&quot;开发者头条&quot; data-alias=&quot;kaifazhetoutiao&quot; data-signature=&quot;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;第一次接触编程是在小学三年级，至今有二十多年了，虽然现在的主要职责是管理公司的工程师与数据团队，但仍时不时会手痒写点程序。这么多年来，从游戏到网站到移动应用，从前端到后端到系统架构，自动化运维，大数据平台，所有这些领域我都有所接触。以前像我这样乱点技能树的，只能叫作万精油，但如今这就叫全栈工程师。&lt;/p&gt;&lt;p&gt;回想起来，我觉得自己还是挺幸运的，比起某某某领域专家，我更喜欢自己现在的状态。如果你也想尝试这条路，今天我可以给你一些建议。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;全栈适合你吗？&lt;/h2&gt;&lt;p&gt;在开始之前，这是你该问自己的第一个问题。因为全栈只是一种选择，你也可以选择朝垂直领域专家的方向努力。如果你已经有自己的答案，那就跟随你的意愿去做。如果你在犹豫，那么让我来问你几个问题&lt;/p&gt;&lt;p&gt;第一个问题，你现在在大公司还是创业公司？将来又想去哪儿呢？虽然没有绝对，但在创业公司，你可以迅速锻炼全栈的能力。而大公司有更多的机会深入研究某个领域的问题。特别是对于运维和大数据方面，大公司有得天独厚的优势，许多挑战与经验是创业公司无法提供的。&lt;/p&gt;&lt;p&gt;第二个问题，你将来是否想成为一个管理者？现在很多公司提供了 dual-stack，就是说管理线与技术线是并行的，要走哪条路你自己选。我的建议是，如果你希望将来转管理，在做技术的时候，广度比深度更重要，也就是说你更应该往全栈方向发展。管理者到一定层次都需要对项目负责，而任何一个典型的互联网项目，前后端开发、线上部署、数据分析，这些部分都缺一不可。拥有全栈的知识，你就可以对项目与团队有更好的把控力。&lt;/p&gt;&lt;p&gt;第三个问题，首席科学家与首席架构师，哪个更吸引你？如果你不走管理线，继续走技术线，那前面两个选择基本就是你发展的目标。如果你选架构师，那你就更适合往全栈发展。其实架构师也是一个管理者，只是他管的不是人，而是一个个技术模块。架构师的功力体现在如何选取最适合的模块，并让它们之间无缝连接。所以你的技术知识面越宽广，你可设计的版图就越大。&lt;/p&gt;&lt;p&gt;最后一个问题，你在学生时代是否偏科？开半个玩笑，我想说的是人要学会从自己的过去总结经验。偏科可能预示着你更适合钻研一项技术而不适合全面发展，或许有一天你就能成为某个领域的大牛，不也是好事一桩？&lt;/p&gt;&lt;p&gt;除去个人的偏好外，你也要关注时代的趋势。这是个开了变速齿轮的时代，短短几年间，技术的热点一直在变化，从移动开发，到大数据，VR，再到深度学习，区块链。身上不多背几项技能，可能没几天就被淘汰了。但到最后“能否快速掌握一项新技术”或许才是唯一不会被淘汰的技能。而在成为全栈工程师的道路上，你可以很好地锻炼这项终极技能。&lt;/p&gt;&lt;h2&gt;全栈工程师修炼手册&lt;/h2&gt;&lt;p&gt;全栈并不是毫无章法的遍地开花，好的学习计划与方法可以事半功倍，以下是我总结的几点经验&lt;/p&gt;&lt;h4&gt;一到多再到一&lt;/h4&gt;&lt;p&gt;从编程入门开始，先花一至两年时间熟练掌握一门主流的编程语言。这个阶段的目标就是一个扎实的基本功，包括程序中的基本概念，例如值与引用，变量的作用域，对象与类，常用数据结构与算法等等。一旦基础扎实了，接下去的三年左右时间就要从一到多，迅速扩冲你的技能池。要做到快速学习，第一项要领就是读技术资料时要学会跳读。因为很多的技术有相通之处，学习一项新技术，只需学习它与你已掌握的技术之间的 diff 就行了。当你有了一定的技术储备之后，一到两天内学会一门新的语言与框架其实并不难。这个阶段的另一个要领是 20/80 原则，也就是用 20% 的时间来了解一项技术中 80% 的基础内容，将剩下最难啃的 20% 留在将来需要深挖时再研究。&lt;/p&gt;&lt;p&gt;那为什么最后还要再回到一呢？当你有了足够的技术广度之后，你对技术的洞察力与理解力都会提升一个层次，这使你能更准确地发现适合自己且有前途的技术领域。与初入行时的随大流不同，你此时的选择是经过深思熟虑，为自己量身定制的。在接下去的时间里重点深挖一个或少数几个领域，这样在俱备了技术广度的同时，你也拥有了自己的杀手锏，个人价值会再次大幅提升。&lt;/p&gt;&lt;h4&gt;任务导向&lt;/h4&gt;&lt;p&gt;所谓任务导向就是一切学习都应该以输出为目的。仅凭兴趣学习，往往是低效的。比如你的公司要做一款移动应用，初期的流程是开发 -&amp;gt; 上线 -&amp;gt; 运营，对应的技术能力就是前后端开发，自动化运维，数据平台与用户分析。当用户数到达一定体量以后，就需要高可用架构，推荐算法等技术。你技术学习的脉络应该顺应业务的发展，这样才有机会学以致用。&lt;/p&gt;&lt;p&gt;那如果你身在大公司，又该怎么做呢？有些大公司提供轮岗的机会，比如我之前在 Google，公司每 18 个月提供一次换岗机会。可以借此扩展你的技能池，要好好利用。在选择下一个岗位时，应保持一种连续性，比如从前端开发转后端开发，从开发部门转运维或是数据部门等。&lt;/p&gt;&lt;p&gt;不过总体来说，全栈工程师与创业公司或是发展期公司才是最佳组合。&lt;/p&gt;&lt;h4&gt;移花接木&lt;/h4&gt;&lt;p&gt;学技术要了解其思想，而不要留于表面形式。优秀的技术思想会从它的发源地流向其他领域。例如，&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;前端的 MVC 结构在后端一样适用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当你理解了 Java 的 Annotation 以后，再看 Python 的 Decorator 就会觉得非常熟悉（尽管两者的实现方式完全不同）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当编译语言用类型推断（Type Inference）去除类型声明的同时，脚本语言却在用类型提示（Type Hint）添加类型声明。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不可变（Immutable）的思想始于函数式编程，但可以用于运维（Immutable Infrastructure)，也可以用于大数据管理（Functional Data Engineering)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运维的核心是对各类服务器数据的监控与报警，同样的理念也可以用于产品与运营数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;技术之间的联系，有些是显而易见的，有些需要你沉淀思考。真正的全栈工程师可以用一个技术领域的思想，去解决另一个技术领域的问题。再举一个我公司的例子，在学习用 Ansible 做运维时，发现它的 Playbook 不是用脚本语言而是用 YAML 来写的，这让我意识到原来 YAML 不仅可以用来描述数据，也可以用来描述逻辑关系。这个思想后来被用在我们很多的项目中，比如在设计数据产品的报表时，各种指标的计算，包括指标之间的依赖与派生关系都是直接在 YAML 中定义的，主体程序不涉及任何业务逻辑，仅仅是解析与执行这些 YAML 文件。&lt;/p&gt;&lt;p&gt;所以我建议在学习技术时，多做一些交叉领域的思考，这会使你在提升技术广度的同时，加强你的技术思维。&lt;/p&gt;&lt;h4&gt;层次切换&lt;/h4&gt;&lt;p&gt;记得以前刚进 Google 时，听的第一个内部讲座就是 Life of a Search Request，讲从用户输入一个搜索关键词到得到结果的整个过程，这个过程涉及浏览器，TCP/IP的网络传输，后台的 Web 服务集群，索引数据库群等等。对于你公司的业务，你是否能清楚地描述从用户输入到产生结果的整个周期？对于每一个环节，你又能深入细节到什么程度？&lt;/p&gt;&lt;p&gt;有次和公司的 CEO 聊天，他说他衡量一个产品经理的能力时，会看这个人能否从产品细节到长期战略之间的各个层次来回切换。我觉得衡量一个全栈工程师能力也是类似的，看他是否在了解系统的全貌的同时，又能深入到单个模块的细节。当系统遇到真正棘手的难题时，就非常考验技术人员在各层次之间切换的能力。就如同玩竞技类游戏，只有同时拥有良好大局观与精湛微操作的选手，才能成为顶尖高手。&lt;/p&gt;&lt;p&gt;在学习全栈的路上，不但要试着横向地切换层次（前台，后台，运维），也要尝纵向地切换层次，除了写业务代码之外，向下了解一些框架的底层运行机制，读一读它们的源码。向上学习一下系统设计与分布式架构。你可能会觉得什么都学会不会精力太分散？我觉得并不会，只要你顺着一条合理的脉络去学（任务导向），花三到五年的时间迅速延展你的技术广度是非常值得的。这会使你比同龄人更具竞争优势。目标要定得高，实践时量力而为。&lt;/p&gt;&lt;h2&gt;全栈修炼入门级套餐&lt;/h2&gt;&lt;p&gt;每个人的技术学习路线可能都不太一样，这也是为什么这篇文章着重讲的是方法而不是具体的学习内容。不过对于刚进入移动互职网开发的新人，我可以推荐一个全栈学习的新手包。编程语言方面，可以优先去学习以下语言&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;JavaScript&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SQL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Swift (如果不做 iOS 开发,可以不学)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Java 不但可以写 Android 应用，也是目前大部分国内公司的后端主力语言，在分布式系统与大数据平台方面的生态圈非常完整，所以即使你公司不用 Java 也应该学。&lt;/p&gt;&lt;p&gt;写前端，JavaScript 是必备技能，要掌握一个主流前端框架，建议学 React。这是一个非常出色的框架，生态圈成熟，适用性广，在有了 ReactNative 加持之后还可以做移动应用开发。另外，在熟悉了 JS 之后，也可以用 NodeJS 来写后端。&lt;/p&gt;&lt;p&gt;Python 也是个全能型语言，如果之后要做自动化运维，大数据分析与机器学习，Python 在这些方面优势明显。国外有很多公司用 Python 写后端，国内相对少些，但对创业公司而言，用 Python 做大后端的主力语言（业务后端 + 运维 + 数据分析）其实是个不错的选择。&lt;/p&gt;&lt;p&gt;学 SQL 前期是为了研发与上线时的数据库查询与管理，后期是为了数据分析与商业智能。即使目前各数 NoSQL 百花齐放，但传统的关系型数据库，如 MySQL 或是 PostgreSQL，势头依然强劲 。而在大数据端，各类的数据仓库与数据计算框架都会提供类 SQL 的接口。在较小的公司里，开发人员还经常兼做数据分析师。所以我认为熟练掌握 SQL 是对全栈工程师一项基本要求。&lt;/p&gt;&lt;p&gt;除了这些编程语言外，另一部分就是了解运维的基础知识，包括 Linux 命令行，Docker，以及各类常用的基础服务与数据库，如 Nginx，MySQL，Redis，MongoDB 等。&lt;/p&gt;&lt;p&gt;有了这些技术基础之后，你对于一个移动应用的系统全貌，就有了大致的了解。可以再根据公司实际的业务情况，选择进一步学习的内容。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;全栈的路很慢长，也很有趣，祝大家成功！今天的分享就到这里，欢迎留言。&lt;/p&gt;&lt;p&gt;（完）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入「码农周刊VIP会员」，成为更好的开发者！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7c8889c6b806bdd185e8322a56287bf</guid>
<title>博文推荐｜深入解析 BookKeeper 多副本协议（一）</title>
<link>https://toutiao.io/k/8vk008d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;本文翻译自《A Guide to the BookKeeper Replication Protocol (TLA+ Series Part 2)》，作者 Jack Vanlightly。原文链接：https://medium.com/splunk-maas/a-guide-to-the-bookkeeper-replication-protocol-tla-series-part-2-29f3371fe395。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;h1&gt;译者简介&lt;/h1&gt;&lt;p&gt;王嘉凌@中国移动云能力中心，移动云Pulsar产品负责人，Apache Pulsar Contributor，活跃于 Apache Pulsar 等开源项目和社区&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们知道关系型数据库中的数据是按表结构来存储，客户端可以将数据存储到表中以及从表中读取数据。Apache BookKeeper 中的数据是按日志结构来存储，客户端以日志的形式读写数据。日志结构是一种只支持数据追加操作的简单数据结构，支持多个客户端同时读取，以及非破坏性读取。&lt;/p&gt;&lt;p&gt;作为数据结构，日志和队列的功能非常相似，区别在于日志支持多个客户端同时独立地从不同位置读取完整的数据。因此，日志必须支持非破坏性读取。而队列则是破坏性读取， 队列的头部元素被读取后会被删除。这意味着队列中的每个元素只会被一个客户端读取到。&lt;/p&gt;&lt;p&gt;作为 Apache Pulsar 数据存储层的 Apache BookKeeper，本身也是一个复杂的分布式系统。BookKeeper 利用多副本机制来实现数据的安全和高可用。多副本指的是每一份 entry 数据都会被复制到多个节点保存，以便在发生部分节点故障时仍然可以提供读写服务，并且保证已保存的数据不会丢失。BookKeeper 使用一套独有的多副本协议，这个协议规定了多个服务节点之间如何协同来实现服务的高可用以及保证数据的安全。&lt;/p&gt;&lt;h1&gt;基于分片的日志数据结构&lt;/h1&gt;&lt;p&gt;诸如 Apache Kafka 和 RabbitMQ 这样使用基于队列和日志的消息队列，都是将每个队列或分区的数据视为一个整体来存储，这样一来整个数据必须全部存储在同一个存储节点。BookKeeper 使用了一套基于分片的日志数据结构，每个日志数据由一系列的分片数据（Segment）串联组成。Pulsar 的一个 Topic 分区 数据实际上是分为多个数据分片来保存。&lt;/p&gt;&lt;p&gt;我们知道每个 Pulsar Topic 都有一个唯一的 Pulsar broker 作为 owner，这个 broker 负责给所属的 Topic 创建数据分片，并将这些数据分片进行串联以便在逻辑上组成一个完整的日志数据。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;80&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPlQseAkmjic5zfNFy3lTtex1xMzaltbNkj8cV9DT5xArkkWmFamk9mEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1：Pulsar Topic 的数据由一组数据分片串联组成&lt;/span&gt;&lt;/p&gt;&lt;p&gt;BookKeeper 将这些数据分片称为 Ledger，并将它们保存在 BookKeeper server 节点（称为 bookie 节点）。&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;412&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7320837927232635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPDysaXNr1wmic17ZQbeOoibYlmF86zdpJ3KOmUttRrRaV7QTXl9QBh3CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2：Pulsar broker 将 topic 数据存储到多个 Bookie 节点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;BookKeeper 多副本协议和每个 ledger 的生命周期息息相关。多副本协议本身的实现封装在 BookKeeper 客户端类库中， 每个 Pulsar broker 通过调用BookKeeper 客户端类库中的接口来和 BookKeeper 进行交互，如创建 ledger，关闭 ledger，以及读写 entry。这些接口背后包含了非常复杂的协议逻辑，在本篇博客中我们会逐层分析并展示协议的实现细节。&lt;/p&gt;&lt;p&gt;首先，创建 ledger 的客户端即为这个 ledger 的唯一owner，只有 owner 可以往 ledger 里写数据。对于 Pulsar 来说，这个客户端就是作为分区 Topic owner 的 broker，Broker 负责创建 ledger 来组成这个 Topic 的数据段。当这个客户端由于某些原因发生故障时，另一个客户端（对于 Pulsar 来说就是另一个 broker）会介入并接管这个 Topic，这个时候需要修复之前的 ledger 中处于正在复制（under-replicated ）状态的 entry 数据（即 recovery 操作）并将 ledger 关闭。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;220&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWP0XCURyDexdFbeMX70zrZ0uiaAeM8CQeCoVBwNcuazwzicdSKOhOAEEyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3: Ledger 的生命周期&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个 Pulsar topic 仅包含一个 open 状态的 ledger 和多个 close 状态的 ledger。所有的写操作都会写入到 open 状态的 ledger，而读操作则可以从任何 ledger 中读取数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;108&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1925925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPricxEhy8kACQA3Ev4G8B9o0NialRDAGXsvwO3Bd5K4X1TbTicDyNZiaibjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4: 写操作只会写入到 open 状态的 ledger&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个 ledger 都会保存到多个 bookie 节点上，每个 ledger 和存有这个 ledger 的 bookie 池（称为 ensemble）的对应关系保存在 ZooKeeper。当 open 状态的 ledger 大小达到了阈值，或者这个 ledger 的 owner 发生了故障，就会关闭这个 ledger 并重新创建一个新的 ledger。根据配置的多副本参数，新创建的 ledger 可能会被保存到另一组 bookie 池上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;346&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6153846153846154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPCSZ4g5p2t85WwYBFTM4MjmNA8e8FibutqrwBTldGRbUhkdBU5Qjl0Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5：Ledger 数据的多个副本保存在多个 bookie 节点，每个 Ledger 的元数据以及一个 Topic 包含的 ledger 信息保存在 ZooKeeper&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;数据写入 ledger 的过程&lt;/h1&gt;&lt;p&gt;BookKeeper 包含以下 ledger 多副本配置相关的参数：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• Write quorum (每份 entry 数据需要写入多少个 bookie 节点), 简称 WQ。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Ack Quorum (需要从多少个 bookie 节点收到写入成功的响应后可以确认这份 entry 写入成功 ), 简称 AQ。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Ensemble size (用于存储 ledger 数据的 bookie 池的节点数量), 简称 E。当 E &amp;gt; WQ 时，entry 数据会交错地写入到不同的 bookie 节点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一条 entry 数据实际写入的 bookie 节点的集合成为写入集合。当 E &amp;gt; WQ 时，相邻的 entry 的写入集合可能会不一样。&lt;/p&gt;&lt;p&gt;Pulsar 为每个 Topic 暴露了设置 AQ、WQ、E 参数的 API 来自定义副本设置。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;596&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0612855007473843&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPs7UXQFJrDP5NLQgdLXKAmhbF5QCOzdLZsVzb80xicbFyevAOU3x16vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6：WQ=3，AQ=2 时的消息写入和确认&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;最后添加确认 (Last Add Confirmed, LAC)&lt;/h1&gt;&lt;p&gt;BookKeeper 客户端会持续更新已确认写入的 entry 中连续且最高的 entry ID，我们称之为 Last Add Confirmed (LAC)。这是一条水位线，高于这个 entry ID 的 entry 都还没有被确认写入，而低于和等于这个 entry ID 的 entry 都已经被确认写入。每一条发往 bookie 的 entry 数据中包含了当前最新的 LAC，这样每个 bookie 都可以知道当前 LAC 的值，尽管有一些延迟存在。我们还会在下文看到 LAC 除了作为已提交 entry 的水位线，还发挥着其他作用。&lt;/p&gt;&lt;h1&gt;Ledger 数据段&lt;/h1&gt;&lt;p&gt;Ledger 本身也可以分成一个或多个数据段（fragment）。当 Ledger 创建时，包含了一个数据段，分配了一个 bookie 池用于存储这个 Ledger 的数据。当发生某个 bookie 写入失败时，客户端会用一个新的 bookie 来替代。这个时候会创建一个新的数据段，并重新发送未确认的 entry 数据和之后的 entry 数据到新的 bookie 上。当 bookie 再次写入失败时，又会再次创建一个新的数据段，以此类推。Bookie 写入失败并不意味着这个 bookie 节点不可用，网络波动等其他情况也会造成单次的写入失败。不同数据段的数据存储在不同的 bookie 池上。数据段也通常被认为是写入集合（Ensemble）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;572&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0170261066969353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPc9bg9MyP91X3hicQAjibKibfuTUK3bjibGq3HYdbwkghKDeqNhYdcjoeicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7：第二个数据段的创建过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Ledger 数据段可以看作是告诉 BookKeeper 客户端去哪里找到某个 ledger 中的 entry 数据的元数据。Bookie 节点自身是不知道这些元数据信息的，它们只负责存储接收到的 entry 数据并创建基于 ledger ID 和 entry ID 的索引。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8425324675324676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPwkSc2zTo1MVXllhmB7YiaDRMkTHwYZyYfwmX7XR2nKLGUoAibA29r97g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8：往 B3 bookie 节点写入 entry 1000 失败并导致 ledger 创建第二个数据段 &lt;/span&gt;&lt;/p&gt;&lt;h1&gt;从 ledger 读取数据的过程&lt;/h1&gt;&lt;p&gt;从 ledger 中读取数据的操作分为以下几种情况：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 正常读取 entry 数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 长轮询读取 LAC 数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Quorum LAC 机制下的读取数据 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 恢复性读取数据&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;和写数据不一样的是，我们只需要读取一个存有数据的 bookie 节点就可以得到想要的数据。如果这次读取失败了，也只需要从存有这个数据其他副本的 bookie 节点上重新读取数据即可。&lt;/p&gt;&lt;p&gt;客户端通常只希望读取到已确认的数据，所以只会读取到 LAC 值标识的位置。在读取历史数据时，bookie 节点会依据当前的 LAC 值来通知客户端何时停止读取。当客户端读取到 LAC 值并停止读取时，可以发起长轮询读取 LAC 数据。这个请求会先被 bookie 挂起，直到有新的 entry 数据被确认时才响应并返回新的 entry 数据。&lt;/p&gt;&lt;p&gt;另外两种读取数据的情况主要发生在数据修复时，我们稍后再介绍。&lt;/p&gt;&lt;h1&gt;完成不同的操作需要不同的响应数量&lt;/h1&gt;&lt;p&gt;完成不同的操作需要从 bookie 节点接收到的成功响应的数量不一样。比如，对于正常读数据的操作，只需要从一个 bookie 节点成功收到响应即可完成。而有些操作则需要从多个 bookie 节点（quorum）收到成功的响应才可完成。&lt;/p&gt;&lt;p&gt;这些操作根据需要收到响应数量的不同，可以分为以下几种类型：&lt;/p&gt;&lt;p&gt;Quorum Coverage (QC) 和 Ensemble Coverage (EC) 都满足于以下定义（以下两种定义本质上相同，只是说法不同），QC 和 EC 的区别仅在于“集合”的范围 ：&lt;/p&gt;&lt;p&gt;对于 Quorum Coverage (QC) 来说，这个集合是指某个 entry 的写入集合。QC 主要用于保证单个 entry 数据一致性的场景，如校验单个 entry 写入操作是否已被客户端确认。对于Ensemble Coverage (EC) 来说，这个集合是指存储当前 ledger 数据段对应的 bookie 池，EC 主要用于保证 ledger 数据段一致性的场景，如设置 ledger 的 fence 状态。&lt;/p&gt;&lt;p&gt;WQ 和 AQ 主要用于写数据，而 QC 和 EC 主要用于 ledger 修复过程。&lt;/p&gt;&lt;h1&gt;Ledger 修复的过程&lt;/h1&gt;&lt;p&gt;前面我们讲到每个 ledger 只有一个客户端作为 owner，当这个客户端不可用时，另一个客户端就会介入并触发 ledger 修复过程然后关闭这个 ledger。对于 Pulsar 来说就相当于作为一个 Topic owner 的 broker 变得不可用，然后这个 Topic 的所有权转移到另一个 broker 上。 &lt;/p&gt;&lt;p&gt;Ledger 修复过程包括找到最高的已被 bookie 确认的 entry ID，保证在这之前的每个 entry 都已复制了足够多的副本数量。之后将这个 ledger 关闭，此时会将这个 ledger 的状态设置为 CLOSED，并将最新的 entry ID 设置为最后被确认的 entry ID。&lt;/p&gt;&lt;h2&gt;如何防止脑裂&lt;/h2&gt;&lt;p&gt;BookKeeper 是一个分布式系统，这意味着网络波动可能会导致集群被分隔成两个或者更多的区块。我们设想如果一个客户端和 ZooKeeper 断开连接，那么这个客户端就被认为已不可用，另一个客户端会接管这个客户端负责的 ledger 并开始 ledger 修复流程。但这个客户端可能仍在正常运行，它可以正常的连接到 BookKeeper 集群，于是就会出现两个客户端试图同时操作同一个 ledger，这种情况就属于脑裂。脑裂是指一个分布式系统由于网络波动分裂为多个独立的系统，在一定时间后网络恢复导致的数据不一致的情况。&lt;/p&gt;&lt;p&gt;BookKeeper 引入了 fence 这个概念来防止脑裂的发生。当第二个客户端 （例如另一个 Pulsar broker）试图开始 ledger 修复流程时，会先将 ledger 设置为 fence 状态，在这个状态下 ledger 会拒接所有新的写入请求。当足够多的 bookie 节点将这个 ledger 状态设置为 fence 时，就算第一个客户端仍然处于正常运行状态，它也不能再进行任何新的写入操作。然后第二个客户端就可以在没有其他客户端会继续写入数据或者试图修复同一个 ledger 的安全状态下开始 ledger 修复流程。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;455&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8106382978723404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPzjg5MZ5QM46UdU9wPEZTj680ecHg98zXia3E749u4D6yR0PiacGYWFsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9：一个新的 Topic owner 开始将 ledger 设置为 fence，原先的 owner 写入新数据时无法写入 Ack Quorum 设定的副本数，则无法完成写入&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;修复流程第一步 — 设置 fence 状态&lt;/h2&gt;&lt;p&gt;将 ledger 设为 fence 状态，并确认 LAC 的值。&lt;/p&gt;&lt;p&gt;Fence 请求实际上是一次 Ensemble Coverage 类型的读请求，获取 LAC 的值并带有 fencing 标识。每个 bookie 节点收到这个请求时会将这个 ledger 的状态设为 fence，并返回这个节点上对应 ledger 的 LAC 值。当客户端从足够多的 bookie 节点收到响应时，就表示请求成功可以进行下一步操作。那么从多少个 bookie 节点收到响应才算足够呢？&lt;/p&gt;&lt;p&gt;我们将 ledger 设置为 fence 状态是为了防止之前的客户端继续往 ledger 里写入数据。所以我们只要保证还没有将这个 ledger 设置为 fence 状态的 bookie 节点的数量小于设置的 Ack Quorum 值，那么之前的客户端因为无法收到足够多的写入确认而无法写入新数据。新的客户端发起的 fence 操作不需要等到所有的 bookie 节点都将这个 ledger 设置为 fence，只需要满足还没有设置为 fence 状态的 bookie 节点数小于设置的 Ack Quorum 就可确认 fence 操作完成。满足这个条件所需要收到的响应数量就是 Ensemble Coverage。&lt;/p&gt;&lt;h2&gt;修复流程第二步 — 修复 entry 数据&lt;/h2&gt;&lt;p&gt;接下来，客户端从 LAC + 1 的 entry ID 开始发送恢复性读取数据的请求，并将这些 entry 数据重新写到新的 bookie 池中。写操作属于幂等操作，也就是说如果这个 entry 已经写入到了某个 bookie 节点，再次向这个节点写入同样的 entry 不会造成数据重复写入。客户端会持续进行读和写的操作直到读完所有数据。确保在关闭 ledger 之前，这个 entry 的写入集合中的所有 bookie 节点都写入了该 entry 的副本。&lt;/p&gt;&lt;p&gt;正常的读操作只需要从一个 bookie 节点接收到响应。与之不同的是，Recovery读操作需要根据从这个 entry 的所有写入集合的 bookie 节点上收到的响应内容来明确这个 entry 是否已确认。具体来说有以下两种情况：&lt;/p&gt;&lt;p&gt;如果所有响应都已收到，但两个阈值都未达到，那就无法判断这个 entry 是否已确认，修复流程就会终止（可能存在收到其他错误类型响应的情况，如网络波动，这种情况无法判断 entry 是否已成功写入对应 bookie 节点）。修复流程可以重复执行直到可以明确每个 entry 最终的确认状态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;600&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0669781931464175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPz7zAaYiaVicAwe4sHtQWdW6OxYeHsV6oglAspjue9o7SuYwCIW19M9gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10：新的客户端在读取 entry 3 时收到了足够多的数据不存在请求，可以判断 entry 3 的状态为未确认。然后保证到 entry 2 为止的数据都复制到足够多的副本数&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;修复流程第三步 — 关闭 Ledger&lt;/h2&gt;&lt;p&gt;一旦明确了所有已确认的 entry ，且这些 entry 复制了足够多的副本数，客户端就会关闭 ledger。关闭 ledger 的操作主要是对 ZooKeeper 上 ledger 元数据的更新，将状态设置为 CLOSED，并将 Last Entry Id 设置为最新的已确认的 entry ID。这些操作和 bookie 本身不相关，bookie 也不会感知 ledger 是否被关闭，bookie 自身没有 open 或 closed 的概念。&lt;/p&gt;&lt;p&gt;ZooKeeper 上元数据的更新是一个基于版本控制的 CAS 操作。如果有另一个客户端同时在修复这个 ledger 并且已经将 ledger 关闭，那么这次 CAS 操作就会失败。通过这种方式可以防止多个客户端同时对同一个 ledger 进行修复操作。 &lt;/p&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;本篇博客介绍了 BookKeeper 多副本协议的大部分实现内容。需要记住的重点是，bookie 节点只是单纯用来存储和读取 entry 数据的存储节点，在 BookKeeper 客户端中包含了创建 ledger、选择存储 ledger 的 bookie 池、创建 ledger 数据段的操作，通过 Write Quorum 和 Ack Quorum 来保证多副本的机制，以及在发生故障时对 ledger 进行修复和关闭等一系列逻辑。&lt;/p&gt;&lt;h1&gt;相关阅读&lt;/h1&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247489945&amp;amp;idx=1&amp;amp;sn=a9dcb508a14eaa96052e783ef79f0e75&amp;amp;chksm=f9c503aeceb28ab8463c1149dd5a6a3c88b6d631d82621813f009bdc676619fb17511faf065d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;博文推荐｜深入解析Apache BookKeeper 系列：第一篇 — 架构原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;•&lt;/span&gt; &lt;span&gt;博文推荐｜深入解析Apache BookKeeper 系列：第一篇 — 架构原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;• &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247488980&amp;amp;idx=2&amp;amp;sn=7ab01fd746384dbcd934ae0d3c3f3e7b&amp;amp;chksm=f9c50fe3ceb286f57035082aeac2d407aded4f013c9e10a029fcadce179a49dd4aca984813c0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;博文干货｜5张图带你快速入门 Pulsar 的存储引擎 BookKeeper&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;博文干货｜5 张图带你快速入门 Pulsar 的存储引擎 BookKeeper&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;📣 Pulsar Storage 特别兴趣小组（SIG）已成立！&lt;span&gt;扫描下方&lt;/span&gt;&lt;span&gt;🤖️ &lt;/span&gt;&lt;span&gt;Pulsar Bot 二维码，&lt;/span&gt;回复 &lt;span&gt;BookKeeper&lt;/span&gt; 加入 Pulsar Storage 讨论群。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4ibRRsibIGr0ZSe03QyMcdYDoPThku7hjSJibg8nI1vtB8bde5jr1XSdz5iaPJDp7y1aOHupWAIQT1Qr3c1iafE5HXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫/码/加/入&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▼ 关注「Apache Pulsar」，获取更多技术干货 ▼&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMjkzMjA1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0Y7icPiahxgXFRw8a0xAIxOhPqYtRDr0IRNpGRl2oSfGHuvkG9VtahW9thH3btBGXJu9y2dZgb3oOuQ/0?wx_fmt=png&quot; data-nickname=&quot;ApachePulsar&quot; data-alias=&quot;ApachePulsar&quot; data-signature=&quot;Apache 软件基金会顶级项目，下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b1d9365085ce0ca5e0392b13484c820c</guid>
<title>收钱吧应用监控系统的演进</title>
<link>https://toutiao.io/k/wyuwvad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着分布式系统和微服务的日益发展，系统的开发和运维对于可观测性的需求越来越迫切。&lt;span&gt;可观测性&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;一词的来源最初是从控制理论中借鉴而来的。目前我们在谈论可观测性的时候，我们通常是指以下三个方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;链路 Tracing&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指标 Metrics&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志 Logging&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三者并不完全是三个独立的概念，而是相辅相成的。谈及这三个方面，我们总是不得不提及&lt;span&gt;Peter Bourgon的文章&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，以及其中最经典的Venn diagram：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6525285481239804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFYAOI7YaYNU2vAcElF4gJUiacOHPw2k3wURABeQ3aB2pSiah0Gsv0sHQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;613&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;收钱吧监控系统的历史发展&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收钱吧从在2017年开始逐步建设应用监控系统，系统建设主要的方向是提供链路追踪(Tracing)以及性能监控(Metrics)两方面的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在监控系统的选型方面，我们尽量使用开源的系统：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Tracing：我们选择的是twitter开源的&lt;span&gt;Zipkin&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，它为我们提供了链路追踪的后端系统，使用Elasticsearch作为Tracing的后端存储；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Metrics：我们在Tracing数据的基础上，通过从Kafka中消费Zipkin格式的数据聚合得到分钟级别的指标，时序数据简单地使用MySQL作为后端存储。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接入层，我们采用最原始的方式，为各个Java的模块、组件提供各种各样的instrumentation工具包来进行埋点，业务研发同学以pom依赖的形式引用到自己的业务服务中，比如&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过MySQL Driver提供的&lt;span&gt;拦截器机制&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;来对MySQL数据库的请求进行采样，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过封装一个新的JSON-RPC包来实现对RPC层的埋点，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过Spring的&lt;span&gt;HandlerInterceptor&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;来实现Rest风格接口的拦截，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过Spring AOP来进行Redis访问的链路采集，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套系统支撑我们走过了业务发展最迅猛的一段时间，为大量的问题排查和故障诊断提供了一些线索，然而业务开发逐渐开始对这套系统产生不满，主要集中在以下几个方面，&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于我们在初期采用MySQL作为底层时序数据的存储，这在当时看起来是&lt;span&gt;一个主流的方案&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;，但我们碰到了很大的性能问题，毕竟MySQL这类数据库提供的&lt;span&gt;存储引擎并没有对此类场景进行优化&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。同时，MySQL并没有提供丰富的针对时间序列的查询算子。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623242736644799&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFbzOGJStE51kEbOjYDVHPeiaBnnQQKEXnfmIsPm3QDvNSkzwRmJLqUVQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1067&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;PgSQL 9.6.2 数据插入的吞吐量随着表大小的变化关系&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;在链路追踪或者说应用监控的场景，我们需要的是&lt;span&gt;高吞吐量以及线性的性能&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;，同时我们也需要增加数据的生命周期管理的功能：因为随着新数据的写入，历史数据的价值会随着时间的流逝而价值降低。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于我们需要从Tracing数据反推得到指标数据Metrics，我们“魔改“了Zipkin传输部分的逻辑，对所有不采样数据（Unsampled）在客户端进行聚合以后批量上报，导致我们在Zipkin的升级方面产生了很大的困难。尤其是在https://github.com/openzipkin/zipkin/pull/1968，以后不再允许用户定制开发服务端。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;业务方升级依赖需要采集器组件升级支持，从而产生了额外的工作量。同时，也有大量的组件难以通过这种侵入性的方式进行支持，或者需要投入很大的人力成本来进行研发、适配。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;新一代应用监控系统 - Hera&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上原因，我们决定研发一套新的系统来同时满足几个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;低存储成本：能够以低成本存储较长周期的数据，对于指标能够存储至少四周，对于链路存储一周，这让我们排除了ElasticSearch这个选项，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高实时查询性能、高灵活度：不再使用MySQL这类关系型数据库作为时间序列的存储，使用Prometheus或Prometheus兼容的存储系统，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优化研发效率：使用字节码编织技术，无侵入地进行埋点，并更紧密地与DevOps流程结合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;链路追踪&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式链路追踪的概念和心智模型(Mental Model)大多是受到2010年发表的&lt;span&gt;Google’s Dapper论文&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;的影响。在Dapper论文中，作者明确地指出了&lt;code&gt;Trace&lt;/code&gt;的树形结构，&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;We tend to think of a Dapper trace as a tree of nested RPCs.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及提出了所谓&lt;code&gt;Span&lt;/code&gt;的概念，&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;In a Dapper trace tree, the tree nodes are basic units of work which we refer to as spans. The edges indicate a casual relationship between a span and its parent span.&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7358490566037735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFXAwEnHl7mqj2QYibtCXwjCbMFqGibGrDYIGL54SnZXA49iajtFNl9bWGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1166&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个Dapper链路树中，各个Span之间存在因果和时序关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在链路追踪的系统选型方面，我们对比了在当时比较活跃的几个开源项目，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Zipkin&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Apache/Skywalking v6.6.0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Jaeger v1.16&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jaeger是&lt;span&gt;Uber&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;在2016年开源的链路追踪平台，并捐献给了CNCF云原生基金会。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jF1ckUhS0t6vor6ZlUUaxxwIRswmWiahQIcibdUFLnCQPoLxO32neDhaRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jaeger的主要组件和控制流、数据流示意图，其中使用Kafka作为缓冲管道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jaeger受到了开源社区的广泛支持，比如&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Istio&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;原生支持使用Jaeger增强Service Mesh服务网格的可观测性，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务网格的数据面实现&lt;span&gt;Envoy&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;支持使用Jaeger作为链路追踪的服务提供方，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;链路追踪后端系统和存储的选型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们重点考虑的是他们对于存储系统方面的支持情况和扩展能力，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;各个开源链路追踪实现的存储能力&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Product&lt;/th&gt;&lt;th&gt;Storage provided officially&lt;/th&gt;&lt;th&gt;Community supported&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Zipkin&lt;/td&gt;&lt;td&gt;In-memory, MySQL, Cassandira, Elasticserach, AWS X-Ray, GCP Stackdirver&lt;/td&gt;&lt;td&gt;Logz.io, Scouter APM, Apache Kafka&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Jaeger&lt;/td&gt;&lt;td&gt;In-memory, Cassandira 3.4+, Elasticsearch 5.x 6.x, Kafka, gRPC Plugin&lt;/td&gt;&lt;td&gt;Additional storage backends, InfluxDB via grpc-plugin, Logz.io, ScyllaDB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Skywalking&lt;/td&gt;&lt;td&gt;H2(In-memory), Elasticsearch 6.X 7.X, MySQL, TiDB&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jaeger社区对于存储的扩展性极佳，提供了基于&lt;code&gt;gRPC&lt;/code&gt;的&lt;span&gt;插件机制&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;，方便定制扩展，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;+----------------------------------+                  +-----------------------------+&lt;br/&gt;|                                  |                  |                             |&lt;br/&gt;|                  +-------------+ |   unix-socket    | +-------------+             |&lt;br/&gt;|                  |             | |                  | |             |             |&lt;br/&gt;| jaeger-component | grpc-client +----------------------&amp;gt; grpc-server | plugin-impl |&lt;br/&gt;|                  |             | |                  | |             |             |&lt;br/&gt;|                  +-------------+ |                  | +-------------+             |&lt;br/&gt;|                                  |                  |                             |&lt;br/&gt;+----------------------------------+                  +-----------------------------+&lt;br/&gt;&lt;br/&gt;       parent process                                        child sub-process&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在存储的具体选择方面，我们在当时注意到了Aliyun SLS能够支持作为链路追踪的后端，并且官方提供了一个实现https://github.com/aliyun/aliyun-log-jaeger，我们内部基于这个思路实现了&lt;code&gt;gRPC&lt;/code&gt;插件版本的SLS后端实现，目前稳定运行在生产环境，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18213660245183888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFS6ZWiayEso6wUWGUJ4kzNxFbjO3f6sXQCndGGicfRrp27e3KICOwpPDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2284&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;存储周期：SLS能够提供长达30天的存储周期，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储量：一天存储的Span数量超过4亿，使用约6TB存储空间，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能：在SLS Query界面进行条件查询可以在3-5s以内返回结果，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成本：每天成本💰约为70元，一年约2万元左右（大约为2台8U32G的ECS的按年付费的价格）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jaeger operator在 https://github.com/jaegertracing/jaeger-operator/pull/1517 中引入了对&lt;code&gt;gRPC&lt;/code&gt;插件的原生支持，&lt;code&gt;gRPC&lt;/code&gt;插件可以作为&lt;span&gt;InitContainer&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;在启动时将插件的二进制文件复制到共享的EmptyDir存储卷中。同时，我们也积极向社区反馈，向社区提供了&lt;code&gt;gRPC&lt;/code&gt;插件的自观测功能(Self Observability)：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;aeger-grpc插件支持opentracing上下文传递：https://github.com/jaegertracing/jaeger/pull/2870&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go-plugin插件支持参数配置: https://github.com/hashicorp/go-plugin/pull/168&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务方接入优化&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;SkyWalking 的美妙不仅在于其强大的功能，还在于其&lt;span&gt;优秀的代码实现&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去我们使用侵入性的方式提供应用监控接入，监控服务的提供方需要为各个业务方提供的插件、模块，并且需要花费大量的精力来实现版本兼容性等工作，这种方式缺乏统一的切面和工作机制，需要对各个组件逐个”攻破”。Skywalking是华为的吴晟等人在2015年开源的一款APM产品，并成为Apache的顶级项目，Skywalking-Java使用了字节码增强技术，提供了无侵入性的链路埋点，大大降低了使用成本。在Java中，常用的字节码工具有以下几种，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.63125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFZcSOB20aucv2mutoTGFLJ7FDHB00iavveX9z8YkMvxKnOZLabFuazXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ASM，BCEL属于Low Level，而CGLib、Javassist和ByteBuddy更易用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于字节码技术的具体分析可以参考&lt;span&gt;StackOverflow上的回答&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中ByteBuddy的易用性和性能都达到一流的水准，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4183937823834197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFeCJaWk1pOaNXpv5rSYQLNUcycnjswLJCU41odw7BM2cLfZTt5zxbVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1544&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ByteBuddy官方提供的性能测试结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了充分利用Skywalking-Java提供的插件，我们在OpenTracing的接口上实现了整套Skywalking链路追踪的模型。具体来说，Skywalking的链路追踪语义包括三层，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Skywalking中的&lt;code&gt;Trace&lt;/code&gt;与OpenTracing语义中的&lt;code&gt;Trace&lt;/code&gt;类似，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Skywalking中的&lt;code&gt;Span&lt;/code&gt;与OpenTracing语义中的&lt;code&gt;Span&lt;/code&gt;类似，&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;EntrySpan: 等价于OpenTracing中Kind=Consumer或者Server的Span，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ExitSpan: 等价于OpenTracing中Kind=Producer或者Client的Span，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LocalSpan: 不属于上述两者的其他类型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Skywalking增加了一层&lt;code&gt;Segment&lt;/code&gt;的概念：一个&lt;code&gt;Segment&lt;/code&gt;被约束在一个线程上，其中包含的所有&lt;code&gt;AbstractTracingSpan&lt;/code&gt; 都在此线程上创建和销毁。这里&lt;code&gt;SegmentID&lt;/code&gt;对应于OT中的&lt;code&gt;SpanID&lt;/code&gt;，在Skywalking中的&lt;code&gt;Span&lt;/code&gt; 是按照创建的顺序从0开始编号的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然模型上也有不同之处，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;跨线程&lt;/strong&gt;：OpenTracing的标准要求实现者将&lt;code&gt;Span&lt;/code&gt; 设计成线程安全的，因为&lt;code&gt;Span&lt;/code&gt;允许被跨线程传递。而在Skywalking中，跨线程是通过对当前&lt;code&gt;Segment&lt;/code&gt;进行&lt;span&gt;快照&lt;/span&gt;&lt;sup&gt;[18]&lt;/sup&gt;实现的，而&lt;code&gt;Span&lt;/code&gt; 在绝大部分场景下不需要保证是线程安全的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步&lt;/strong&gt;：异步Span主要应用于记录异步操作真正的起始和结束时刻。以&lt;span&gt;Spring Reactive为例&lt;/span&gt;&lt;sup&gt;[19]&lt;/sup&gt;：用户编写的Controller返回的是一个可被执行任务（通常是&lt;code&gt;Mono&lt;/code&gt;类型），而不是最后的结果，Dispatcher会将任务通过线程池去执行，那么我们需要记录的是真正这个请求从&lt;strong&gt;任务创建&lt;/strong&gt;到&lt;strong&gt;被“计算“完成&lt;/strong&gt;的整个周期。在OpenTracing标准中没有提及这部分的实现。而Skywalking的多个插件中使用了这个机制，比如Redis客户端Lettuce，Spring Webflux，Apache AsyncHttpClient等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过在OpenTracing接口上实现与Skywalking一致的语义从而实现几乎零成本地移植并使用它所有的插件。我们在使用Skywalking-Java的过程中也发现了不少问题，也与社区积极地反馈，做出了一些贡献，主要包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;JSON日志格式的实现：https://github.com/apache/skywalking/pull/5357&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Kafka 1.x插件：https://github.com/apache/skywalking/pull/5879&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring DevTools支持和多类加载器优化：https://github.com/apache/skywalking/pull/6973&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Jedis Transaction支持：https://github.com/apache/skywalking-java/pull/57&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;服务依赖分析&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务的依赖分析在公司内部一直是业务开发迫切需要的功能，它在服务容量规划、问题诊断和服务强弱性依赖判断中都有比较实用的价值。在Jeager社区的实现中，推荐生产使用&lt;span&gt;Spark批处理&lt;/span&gt;&lt;sup&gt;[20]&lt;/sup&gt;的方式实现了全局的依赖分析，也有&lt;span&gt;基于Flink的实时处理&lt;/span&gt;&lt;sup&gt;[21]&lt;/sup&gt;，但已经没有在维护状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现这个功能，我们使用了Apache Flink，通过消费Kafka中的链路数据，实时计算出服务之间的依赖关系，将&lt;code&gt;Tuple&amp;lt;downsampled timestamp, caller, sub-caller, callee, sub-callee&amp;gt;&lt;/code&gt; 格式的数据通过OpenTSDB协议传输到我们的时序数据库&lt;code&gt;VictoriaMetrics&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端根据用户提供的时间窗口，通过Java服务暴露的API进行上游/下游的查询，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5755458515283843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFjEDNpKqSkrPe6Dmjarq2prYnAJ6S0oS2C92KdktQfY1BWN85xyn15g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2290&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续我们将在用户交互和调用量的分析展示方面进行进一步的优化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;指标监控&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在老版本的监控程序中，我们使用了关系型数据库作为时序数据的存储系统，使得我们在查询的灵活性和性能方面遭遇到了很大的瓶颈，我们有必要在新系统设计的时候去进行一定的反思。在过去几年中，云原生的概念逐渐深入人心，而Prometheus是云原生时代监控的事实标准，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.459375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFc5QYWYDubreBLib5nSlFMr9ic1l1Adwyzwy16PGD1hm2yM7E3EKjQXBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行了一些调研之后，我们认为单机版本的Prometheus并不能支撑超过百万级别活跃的指标和超过一周的数据存储。我们的目光主要聚焦到了Thanos、Cortex和VictoriaMetrics，在国内技术社区分享比较多的是Cortex和Thanos，但我们对比发现Cortex的架构非常复杂，对系统运维提出了新的挑战，而Thanos也有一定的运维复杂性，且由于使用对象存储（S3等）作为冷数据存储，查询可能存在一部分服务不可用导致返回部分数据。同时，我们也发现国内的&lt;span&gt;知乎在QCon 2020&lt;/span&gt;&lt;sup&gt;[22]&lt;/sup&gt;上分享了他们使用VictoriaMetrics的经验。我们基于以下原因最终选择了VictoriaMetrics，&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;VictoriaMetrics在&lt;span&gt;各项性能测试&lt;/span&gt;&lt;sup&gt;[23]&lt;/sup&gt;中都表现卓著，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作者Aliaksandr Valialkin精于Go语言的性能优化，是&lt;code&gt;fasthttp&lt;/code&gt;等高性能Go语言组件的作者，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最重要的是VM的集群架构简单，易于运维。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6763372620126926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFkiaLmC89g7icnT66RAiaZuZkr9pHxHHCpPksyIibzPynQppTJbIefDBlfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1103&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VM的各个组件都是独立的，可以水平扩展，只有核心的vmstorage是有状态的，其他组件均是无状态的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推还是拉 (push or pull)&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于指标类的数据，采用主动推还是被动拉的模式，一直以来都是存在&lt;span&gt;较大的争议&lt;/span&gt;&lt;sup&gt;[24]&lt;/sup&gt;。我们与Prometheus一样使用推的模式，基于以下原因，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务发现：一个诟病Pull模式的原因是认为Pull模式需要大规模的服务发现，但这一问题在Kubernetes上反而不存在任何问题，我们借助&lt;span&gt;CRD&lt;/span&gt;&lt;sup&gt;[25]&lt;/sup&gt;可以很轻易地实现服务抓取目标的定义。同时可以将Pod，Service上的标签附加到指标上，帮助查询的时候区分实例，服务所属的业务团队等。反而，这在Push模式中是不容易实现，或者需要业务研发去改造的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问题排查：当指标查询失败的时候，我们通常需要去判断到底是哪一步出了问题。在Push模式中，我们需要去检查业务的代码和日志来判断问题。然而在Pull模式，我们可以手动在浏览器中去请求指标暴露的接口（比如&lt;code&gt;/metrics&lt;/code&gt; ）就可以判断服务的健康状况，业务是否正常导出指标。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前我们使用VictoriaMetrics的一些统计信息，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;存储周期60天，共有6990亿个数据点，占用磁盘空间800GB，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;活跃时间序列约500万，数据点插入的QPS约13万每秒，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;范围查询的P99线平均值约为1.5s。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也自研了查询面板，以限定查询的时间范围（最长3天）和查询的模式（针对服务&lt;code&gt;job&lt;/code&gt;查询）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5073375262054507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFMhOOia1wjgiaoQN9ichPb63EaO5cLbAZun2c63axszbLeGZM9pZiaz0OdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2862&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们自研了一些重要的指标插件，其中在应用性能分析、故障定位中比较实用的维度有，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Servlet容器指标：Tomcat忙碌线程数，百分比，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库连接池指标：支持HikariCP和Alibaba/Druid连接池，等待连接池的线程数，数据库连接获取时间，数据库连接池使用占比，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存指标：支持Redis，Caffeine和EhCache。缓存命中率，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kubernetes监控：Pod CPU、内存使用量，我们也在系统中也集成了Kubernetes事件的查看和搜索。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于公司部分核心服务还使用Docker部署在ECS上，我们在VictoriaMetrics中&lt;span&gt;实现了基于Dockerd API的服务发现机制&lt;/span&gt;&lt;sup&gt;[26]&lt;/sup&gt;，也已经合并到社区版本。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;全面拥抱云原生&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在2020年，Kubernetes已然成为了分布式操作系统的事实标准，公司内部的绝大多数服务也已经全面迁移到自建的Kubernetes集群。为了更好的利用新特性，我们在2020年中启动Kubernetes的集群升级计划，将集群升级到1.16版本（目前已经升级到1.20），并迁移至阿里云的ACK托管集群。监控系统的落地将全面依赖于Kubernetes系统，&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我们提供Docker镜像版本的Java Agent，方便业务开发接入，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在生产环境，我们使用&lt;span&gt;InitContainer&lt;/span&gt;&lt;sup&gt;[27]&lt;/sup&gt;在容器启动阶段注入Java Agent，两者之间通过贡献的&lt;span&gt;EmptyDir&lt;/span&gt;&lt;sup&gt;[28]&lt;/sup&gt;来传递Agent Jar包。这便于我们在生产环境中静默升级Agent版本：即使Agent在生产出现问题，我们可以快速修复问题，然后升级初始化容器即可，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时序数据库VictoriaMetrics的运维和Jaeger组件的运维也是通过Kubernetes Operator实现的&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;我们对&lt;code&gt;jaeger-ingester&lt;/code&gt;和&lt;code&gt;jaeger-collector&lt;/code&gt;组件启用了HPA，即基于CPU和内存使用率的水平动态扩容，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VictoriaMetrics集群版本的各个组件也是通过&lt;span&gt;Kubernetes operator&lt;/span&gt;&lt;sup&gt;[29]&lt;/sup&gt;进行维护的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后采样的实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们目前采样的是头采样（Head-Based Sampling）方案，一旦在链路中间的服务发生抛出异常且这条链路没有被采样，那么就会出现有错误日志和报警，但链路追踪系统无法查询到这条链路的情况，这给开发排查问题带来很大的阻碍。目前，业界有几种典型的实现方案，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;OpenTelemetry方案&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/4958&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OT社区的&lt;span&gt;tailsampling方案&lt;/span&gt;&lt;sup&gt;[30]&lt;/sup&gt;主要来自于&lt;span&gt;Grafana公司的贡献&lt;/span&gt;&lt;sup&gt;[31]&lt;/sup&gt;，同时可以利用以下几个processor和exporter实现高伸缩性，&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;（第一层）loadbalancingexporter：把属于同一个TraceID的所有Trace和Log分发给一组固定的下游Collector，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;groupbytraceprocessor：等待足够长的一段时间，将属于一个TraceID的所有Span(s)打包传递到下游，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tailsamplingprocessor：通过预定义的组合策略进行采样&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字节跳动方案&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生错误的服务将采样决定强制进行翻转，如果这条链路没有进行采样的话。但这样的话会丢失采样决策改变之前的所有链路以及其他分支链路的数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jFw98MsGUQOu0EqvuS8jXTOarbM5MBHLQ8KF2JGHQlwibr20JzzAPoAjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;货拉拉方案&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于Kafka延迟消费+布隆过滤器实现，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3bQmSksPXj7ScUecHMPZ1jF4hWtBTKxhMzxkLoJBNDMtw50F0Y1eibqUZglOJfwVYcEeoBBhLvmyCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实时消费队列：根据采样规则写入Bloom过滤器，热数据全量写入热存储，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟消费队列：根据Bloom过滤器实现条件过滤逻辑，冷数据写入冷存储。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间序列的异常检测&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间序列的异常检测一直是一个比较火的话题，尤其是针对具有时间周期特征的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Gitlab方案&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gitlab在2019年分享了他们&lt;span&gt;基于Prometheus实现的简单的异常检测&lt;/span&gt;&lt;sup&gt;[32]&lt;/sup&gt;，比如我们想判断当前时间&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;t&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -626 361 637&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;对应的值&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;f(t)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 1689 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(550, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(939, 0)&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1300, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，我们可以根据前三周的数据的中位数通过最近一周的增量进行修正，得到当前时间的预测值&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;f\prime(t)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 1964 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(550, 0)&quot;&gt;&lt;path data-c=&quot;2032&quot; d=&quot;M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(825, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1214, 0)&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1575, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;f\prime(t) = \mathrm{median}(f(t-144h)+\Delta_{\mathrm{1w}},f(t-334h)+\Delta_{\mathrm{2w}},f(t-502h)+\Delta_{\mathrm{3w}})&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/hgXWbMaaqmCWnjbXJIwOfdJNdVrqibgRJhjibHzTQWUD61jJCbicicSr0GOp3QVkYuTLT6Nibosic33VicqqxRiaEHsWAJuaW0richO2x/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中增量&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;\Delta_{\mathrm{offset}}&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -716 2630.3 873.8&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;394&quot; d=&quot;M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(833, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(500, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(872, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1244, 0)&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M295 316Q295 356 268 385T190 414Q154 414 128 401Q98 382 98 349Q97 344 98 336T114 312T157 287Q175 282 201 278T245 269T277 256Q294 248 310 236T342 195T359 133Q359 71 321 31T198 -10H190Q138 -10 94 26L86 19L77 10Q71 4 65 -1L54 -11H46H42Q39 -11 33 -5V74V132Q33 153 35 157T45 162H54Q66 162 70 158T75 146T82 119T101 77Q136 26 198 26Q295 26 295 104Q295 133 277 151Q257 175 194 187T111 210Q75 227 54 256T33 318Q33 357 50 384T93 424T143 442T187 447H198Q238 447 268 432L283 424L292 431Q302 440 314 448H322H326Q329 448 335 442V310L329 304H301Q295 310 295 316Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1638, 0)&quot;&gt;&lt;path data-c=&quot;65&quot; d=&quot;M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2082, 0)&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;是指最近一周的指标的时间平均值与往前偏移&lt;code&gt;offset&lt;/code&gt; 以后的时间平均值，比如&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;\Delta_{\mathrm{1w}}&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -716 1747.1 873.8&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;394&quot; d=&quot;M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(833, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(500, 0)&quot;&gt;&lt;path data-c=&quot;77&quot; d=&quot;M90 368Q84 378 76 380T40 385H18V431H24L43 430Q62 430 84 429T116 428Q206 428 221 431H229V385H215Q177 383 177 368Q177 367 221 239L265 113L339 328L333 345Q323 374 316 379Q308 384 278 385H258V431H264Q270 428 348 428Q439 428 454 431H461V385H452Q404 385 404 369Q404 366 418 324T449 234T481 143L496 100L537 219Q579 341 579 347Q579 363 564 373T530 385H522V431H529Q541 428 624 428Q692 428 698 431H703V385H697Q696 385 691 385T682 384Q635 377 619 334L559 161Q546 124 528 71Q508 12 503 1T487 -11H479Q460 -11 456 -4Q455 -3 407 133L361 267Q359 263 266 -4Q261 -11 243 -11H238Q225 -11 220 -3L90 368Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;是指最近一周的平均值与上一个周期的平均值之差（用PromQL表示为&lt;code&gt;job:http_requests:rate5m:avg_over_time_1w - job:http_requests:rate5m:avg_over_time_1w offset 1w&lt;/code&gt;），用于补偿周期之间的平均值变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他的方案&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Prophet - 携程实时智能异常检测平台实践&lt;/span&gt;&lt;sup&gt;[33]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;外卖订单量预测异常报警模型实践&lt;/span&gt;&lt;sup&gt;[34]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从业界发展的大势来看，通过大数据、AI手段对系统异常进行检测也是大势所趋。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;作者介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;陆家靖，来自技术平台部。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Observability: &lt;em&gt;https://en.wikipedia.org/wiki/Observability&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Metrics, tracing, and logging: &lt;em&gt;https://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Zipkin: &lt;em&gt;https://zipkin.io/,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Using the Connector/J Interceptor Classes: &lt;em&gt;https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-interceptors.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;HandlerInterceptor: &lt;em&gt;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerInterceptor.html,&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;What Database Engine Are You Using to Store Time Series Data?: &lt;em&gt;https://www.percona.com/blog/2017/02/10/percona-blog-poll-database-engine-using-store-time-series-data/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Time-series data: Why (and how) to use a relational database instead of NoSQL: &lt;em&gt;https://www.timescale.com/blog/time-series-data-why-and-how-to-use-a-relational-database-instead-of-nosql-d0cd6975e87c/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Time-series data: Why (and how) to use a relational database instead of NoSQL: &lt;em&gt;https://www.timescale.com/blog/time-series-data-why-and-how-to-use-a-relational-database-instead-of-nosql-d0cd6975e87c/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;面向分布式追踪系统的存储方案: &lt;em&gt;https://mp.weixin.qq.com/s/wostd5_PdG9X-qpitPdA7A&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Dapper, a Large-Scale Distributed Systems Tracing Infrastructure: &lt;em&gt;https://research.google/pubs/pub36356/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Evolving Distributed Tracing at Uber Engineering: &lt;em&gt;https://eng.uber.com/distributed-tracing/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;Istio/Jaeger: &lt;em&gt;https://istio.io/latest/docs/tasks/observability/distributed-tracing/jaeger/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;Jaeger tracing: &lt;em&gt;https://www.envoyproxy.io/docs/envoy/latest/start/sandboxes/jaeger_tracing.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;Golang plugin system over RPC.: &lt;em&gt;https://github.com/hashicorp/go-plugin&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;Init Containers: &lt;em&gt;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;SkyWalking 8.7.0 源码分析: &lt;em&gt;https://skywalking.apache.org/zh/2022-03-25-skywalking-source-code-analyzation/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;p&gt;Dynamic Java Bytecode Manipulation Framework Comparison: &lt;em&gt;https://stackoverflow.com/questions/9167436/dynamic-java-bytecode-manipulation-framework-comparison&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[18]&lt;/span&gt;&lt;p&gt;ContextSnapshot: &lt;em&gt;https://github.com/apache/skywalking-java/blob/5607f87a54719baad002cb00248e250cbdaae69a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java#L42-L56&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[19]&lt;/span&gt;&lt;p&gt;Understanding Reactive types: &lt;em&gt;https://spring.io/blog/2016/04/19/understanding-reactive-types&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[20]&lt;/span&gt;&lt;p&gt;Spark job for dependency links: &lt;em&gt;https://github.com/jaegertracing/spark-dependencies&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[21]&lt;/span&gt;&lt;p&gt;Big data analytics for Jaeger using Apache Flink: &lt;em&gt;https://github.com/jaegertracing/jaeger-analytics-flink&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[22]&lt;/span&gt;&lt;p&gt;演讲：单机 20 亿指标，知乎 Graphite 极致优化！: &lt;em&gt;https://qcon.infoq.cn/2020/shenzhen/presentation/2881&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[23]&lt;/span&gt;&lt;p&gt;Prominent features: &lt;em&gt;https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#prominent-features&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[24]&lt;/span&gt;&lt;p&gt;Pull doesn&#x27;t scale - or does it?: &lt;em&gt;https://prometheus.io/blog/2016/07/23/pull-does-not-scale-or-does-it/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[25]&lt;/span&gt;&lt;p&gt;VMServiceScrape: &lt;em&gt;https://docs.victoriametrics.com/operator/api.html#vmservicescrape&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[26]&lt;/span&gt;&lt;p&gt;Support Docker ServiceDiscovery: &lt;em&gt;https://github.com/VictoriaMetrics/VictoriaMetrics/pull/1402&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[27]&lt;/span&gt;&lt;p&gt;InitContainer: &lt;em&gt;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[28]&lt;/span&gt;&lt;p&gt;EmptyDir: &lt;em&gt;https://kubernetes.io/docs/concepts/storage/volumes/#emptydir&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[29]&lt;/span&gt;&lt;p&gt;Kubernetes operator for Victoria Metrics: &lt;em&gt;https://github.com/VictoriaMetrics/operator&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[30]&lt;/span&gt;&lt;p&gt;Tail-Based Sampling - Scalability Issues: &lt;em&gt;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/4758&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[31]&lt;/span&gt;&lt;p&gt;Public - Composite Tail Sampling Policy: &lt;em&gt;https://docs.google.com/document/d/10wpIv3TtXgOik05smHm3nYeBX48Bj76TCMxPy8e1NZw/edit#heading=h.ecy5l2puwtp4&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[32]&lt;/span&gt;&lt;p&gt;How to use Prometheus for anomaly detection in GitLab: &lt;em&gt;https://about.gitlab.com/blog/2019/07/23/anomaly-detection-using-prometheus/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[33]&lt;/span&gt;&lt;p&gt;携程实时智能检测平台建设实践: &lt;em&gt;https://developer.aliyun.com/article/740900&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[34]&lt;/span&gt;&lt;p&gt;外卖订单量预测异常报警模型实践: &lt;em&gt;https://tech.meituan.com/2017/04/21/order-holtwinter.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1486aa973a0dba8e7c8770a5c7449946</guid>
<title>点击页面元素，这个Vite插件竟然帮我打开了Vue组件文件！超级好用！</title>
<link>https://toutiao.io/k/pmc5cbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650757158&amp;amp;idx=1&amp;amp;sn=1f1cad678916031fb0e77eefcfa1dddc&amp;amp;chksm=88665baabf11d2bc7dce837e90cbe0b755d4e082362363e1ebc8912a77367b79ba59ea43a32e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;若‍川&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;若川&lt;/a&gt;。&lt;span&gt;持续组织了8个月&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650761094&amp;amp;idx=2&amp;amp;sn=0d0e9de8fc6554b3074913697511c9a2&amp;amp;chksm=8866640abf11ed1c0bdf43f4758c3bb9a74c90c48ed76eed46dca1af6e9b63b992def9b3655c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;源码共读‍活动&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;strong&gt;源码共读活动&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，感兴趣的可以&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650761094&amp;amp;idx=2&amp;amp;sn=0d0e9de8fc6554b3074913697511c9a2&amp;amp;chksm=8866640abf11ed1c0bdf43f4758c3bb9a74c90c48ed76eed46dca1af6e9b63b992def9b3655c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点此加我微信 ruochuan‍12&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;点此加我微信 ruochuan12&lt;/a&gt;&lt;span&gt; 参与，每周大家一起学习200行左右的源码，共同进步。同时极力推荐订阅我写的&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1342211915371675650&amp;amp;scene=173&amp;amp;from_msgid=2650759428&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;《学习源码整体架构系列》&lt;/a&gt;&lt;span&gt; 包含20余篇源码文章。&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1932984266565484545#wechat_redirect&quot; textvalue=&quot;历史面试系列&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;历史面试系列&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两天肝了个Vite插件,本文主要跟大家分享一下它的功能和实现思路.如果你觉得它对你有帮助,请给一个star支持作者 💗.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vite-plugin-vue-inspector的功能是点击页面元素,自动打开本地IDE并跳转到对应的Vue组件.类似于&lt;code&gt;Vue DevTools&lt;/code&gt;的 &lt;code&gt;Open component in editor&lt;/code&gt;功能。（若川批注：关于原理可以看我写过的文章：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650751278&amp;amp;idx=1&amp;amp;sn=3ac07b110e84e3ded5fa4ec4407ce13b&amp;amp;chksm=886642a2bf11cbb4cea35f0d208815c39c9cd13a0522e7cdc4a466bc55cb5b3071143a38bb04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘&lt;/a&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5053680981595092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/Mpt86EGjlpvVXr0Fgyg2FKxvMMoxmgn3VgbOYAibY0OaiadYkwfBO38nQoLOuJpOicv05DE5Zx4vz2Auu2sWjTSMQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1304&quot;/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vite-plugin-vue-inspector支持Vue2 &amp;amp; Vue3,并且只需要进行简单的配置就可以使用.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vue2&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { defineConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { createVuePlugin } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue2&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Inspector &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineConfig({&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;    createVuePlugin(),&lt;br/&gt;    Inspector({&lt;br/&gt;      &lt;span&gt;vue&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    }),&lt;br/&gt;  ],&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vue3&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { defineConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@vitejs/plugin-vue&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Inspector &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineConfig({&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [Vue(), Inspector()],&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IDE也要进行配置,这里就不啰嗦了, 👉 传送门.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现思路&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里,如果你觉得这个插件索然无味的话先别跑,插件没意思,看看怎么写插件还是有点意思的嘛 ! 接下来跟大家介绍一下这个插件的实现思路.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来分析一下实现这个功能我们需要有哪些元素 :&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Open IDE&lt;/code&gt;: 打开编辑器功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Web&lt;/code&gt;层: 提供该功能所需的页面元素及交互功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Server&lt;/code&gt;层: 用户交互时传递数据到&lt;code&gt;Server&lt;/code&gt;层,由&lt;code&gt;Server&lt;/code&gt;层调用&lt;code&gt;Open IDE&lt;/code&gt;功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DOM&lt;/code&gt;=&amp;gt;&lt;code&gt;Vue SFC&lt;/code&gt;映射关系: 告诉&lt;code&gt;OPen IDE&lt;/code&gt;打开哪个文件并定位到对应的行列.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明确我们需要什么元素,我们就可以进一步来梳理它的实现方式,直接晒图:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5165343915343915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/C527icpHV4scIEXR8hD9fQ2401ac7wqYtVUfeYYjoNW50HDUBy9vCUVmyxUzkajVXjQlNGqqSjc2kIQsTs5UVQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot;/&gt;&lt;figcaption&gt;vite-plugin-step.drawio (2).png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现细节&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来,我们来看具体的实现细节.在这之前,我们先简单看下我们需要用到的几个Vite插件API:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 应用顺序&lt;/span&gt;&lt;br/&gt;    enforce: &lt;span&gt;&quot;pre&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 应用模式 (只在开发模式应用)&lt;/span&gt;&lt;br/&gt;    apply: &lt;span&gt;&quot;serve&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 含义: 转换钩子,接收每个传入请求模块的内容和文件路径&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子对SFC模版进行解析并注入自定义属性&lt;/span&gt;&lt;br/&gt;    transform(code, id) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 含义: 配置开发服务器钩子,可以添加自定义中间件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子实现Open Editor调用服务&lt;/span&gt;&lt;br/&gt;    configureServer(server) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 含义: 转换index.html的专用钩子,接收当前HTML字符串和转换上下文&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子注入交互功能&lt;/span&gt;&lt;br/&gt;    transformIndexHtml(html) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解析SFC模版 &amp;amp; 注入自定义属性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分的实现主要分为两步:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SFC Template&lt;/code&gt; =&amp;gt; &lt;code&gt;AST&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取元素所在组件的行和列的编号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取自定义属性插入的位置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;注入自定义属性&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;file (SFC路径,用于跳转到指定文件)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;line (元素所在行编号,用于跳转到指定行)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;column (元素所在列编号,用于跳转到指定列)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;title (SFC名称,用于展示)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    transform(code, id) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { filename, query } = parseVueRequest(id)&lt;br/&gt;      &lt;span&gt;// 只处理SFC文件&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (filename.endsWith(&lt;span&gt;&quot;.vue&quot;&lt;/span&gt;) &amp;amp;&amp;amp; query.type !== &lt;span&gt;&quot;style&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; compileSFCTemplate(code, filename)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; code&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// compiler.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; path &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;path&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; MagicString &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;magic-string&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { parse, transform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@vue/compiler-dom&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; EXCLUDE_TAG = [&lt;span&gt;&quot;template&quot;&lt;/span&gt;, &lt;span&gt;&quot;script&quot;&lt;/span&gt;, &lt;span&gt;&quot;style&quot;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;compileSFCTemplate&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  code: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  id: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// MagicString是一个非常好用的字符串操作库,也如它的名字一样,非常的神奇 !&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 有了它,我们可以直接操作字符串,避免操作AST,换来更好的性能. Vue3的实现也大量的用到了它.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt; MagicString(code)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// SFC =&amp;gt; AST&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ast = parse(code, { comments: &lt;span&gt;true&lt;/span&gt; })&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    transform(ast, {&lt;br/&gt;      &lt;span&gt;// ast node节点访问器&lt;/span&gt;&lt;br/&gt;      nodeTransforms: [&lt;br/&gt;        &lt;span&gt;(&lt;span&gt;node&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (node.type === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;           &lt;span&gt;// 只解析html标签 &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (node.tagType === &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !EXCLUDE_TAG.includes(node.tag)) {&lt;br/&gt;              &lt;span&gt;const&lt;/span&gt; { base } = path.parse(id)&lt;br/&gt;              &lt;span&gt;// 获取到相关信息,并进行自定义属性注入&lt;/span&gt;&lt;br/&gt;              !node.loc.source.includes(&lt;span&gt;&quot;data-v-inspecotr-file&quot;&lt;/span&gt;)&lt;br/&gt;                &amp;amp;&amp;amp; s.prependLeft(&lt;br/&gt;                  node.loc.start.offset + node.tag.length + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;` data-v-inspecotr-file=&quot;&lt;span&gt;${id}&lt;/span&gt;&quot; data-v-inspecotr-line=&lt;span&gt;${node.loc.start.line}&lt;/span&gt; data-v-inspecotr-column=&lt;span&gt;${node.loc.start.column}&lt;/span&gt; data-v-inspecotr-title=&quot;&lt;span&gt;${base}&lt;/span&gt;&quot;`&lt;/span&gt;,&lt;br/&gt;                )&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;      ],&lt;br/&gt;    })&lt;br/&gt;    resolve(s.toString())&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注入后的&lt;code&gt;DOM元素&lt;/code&gt;长这样 :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;h3&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-file&lt;/span&gt;=&lt;span&gt;&quot;/xxx/src/Hi.vue&quot;&lt;/span&gt;   &lt;br/&gt;    &lt;span&gt;data-v-inspector-line&lt;/span&gt;=&lt;span&gt;&quot;3&quot;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-column&lt;/span&gt;=&lt;span&gt;&quot;5&quot;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-title&lt;/span&gt;=&lt;span&gt;&quot;Hi.vue&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Open Editor Server服务&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到了创建Server服务的思路是在vite的&lt;code&gt;configureServer&lt;/code&gt;的钩子函数注入中间件:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    configureServer(server) {&lt;br/&gt;      &lt;span&gt;// 注册中间件&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;// 请求Query参数解析中间件 &lt;/span&gt;&lt;br/&gt;      server.middlewares.use(queryParserMiddleware)&lt;br/&gt;      &lt;span&gt;// Open Edito服务中间件&lt;/span&gt;&lt;br/&gt;      server.middlewares.use(launchEditorMiddleware)&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// middleware.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 请求Query参数解析中间件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; queryParserMiddleware: Connect.NextHandleFunction = (&lt;br/&gt;  req: RequestMessage &amp;amp; {query?: object},&lt;br/&gt;  _,&lt;br/&gt;  next,&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!req.query &amp;amp;&amp;amp; req.url?.startsWith(SERVER_URL)) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; url = &lt;span&gt;new&lt;/span&gt; URL(req.url, &lt;span&gt;&quot;http://domain.inspector&quot;&lt;/span&gt;)&lt;br/&gt;    req.query = &lt;span&gt;Object&lt;/span&gt;.fromEntries(url.searchParams.entries())&lt;br/&gt;  }&lt;br/&gt;  next()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Open Editor服务中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; launchEditorMiddleware: Connect.NextHandleFunction = (&lt;br/&gt;  req: RequestMessage &amp;amp; {&lt;br/&gt;    query?: { line: &lt;span&gt;number&lt;/span&gt;; column: &lt;span&gt;number&lt;/span&gt;; file: &lt;span&gt;string&lt;/span&gt; }&lt;br/&gt;  },&lt;br/&gt;  res,&lt;br/&gt;  next,&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 只处理Open Editor接口&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (req.url.startsWith(SERVER_URL)) {&lt;br/&gt;    &lt;span&gt;// 解析SFC路径,行号,列号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { file, line, column } = req.query&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!file) {&lt;br/&gt;      res.statusCode = &lt;span&gt;500&lt;/span&gt;&lt;br/&gt;      res.end(&lt;span&gt;&quot;launch-editor-middleware: required query param \&quot;file\&quot; is missing.&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; lineNumber = +line || &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; columnNumber = +column || &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 见下方链接&lt;/span&gt;&lt;br/&gt;    launchEditor(file, lineNumber, columnNumber)&lt;br/&gt;    res.end()&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    next()&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于&lt;code&gt;launchEditor&lt;/code&gt;的具体逻辑我直接fork了react-dev-utils的实现,它支持很多IDE (&lt;code&gt;vscode&lt;/code&gt;,&lt;code&gt;atom&lt;/code&gt;,&lt;code&gt;webstorm&lt;/code&gt;...),它的大致原理就是通过维护一些进程映射表和环境变量,然后通过调用&lt;code&gt;Node.js&lt;/code&gt;的子进程唤醒IDE:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;child_process.spawn(editor, args, { &lt;span&gt;stdio&lt;/span&gt;: &lt;span&gt;&#x27;inherit&#x27;&lt;/span&gt; });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;交互功能注入&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能的实现原理其实就在&lt;code&gt;transformIndexHtml&lt;/code&gt;注入功能所需要的&lt;code&gt;html,scripts,styles&lt;/code&gt;.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    transformIndexHtml(html) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;            html,&lt;br/&gt;            tags: [{&lt;br/&gt;              tag: &lt;span&gt;&quot;script&quot;&lt;/span&gt;,&lt;br/&gt;              children: ...,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;body&quot;&lt;/span&gt;,&lt;br/&gt;            }, {&lt;br/&gt;              tag: &lt;span&gt;&quot;script&quot;&lt;/span&gt;,&lt;br/&gt;              attrs: {&lt;br/&gt;                &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;module&quot;&lt;/span&gt;,&lt;br/&gt;              },&lt;br/&gt;              children: scripts,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;body&quot;&lt;/span&gt;,&lt;br/&gt;            }, {&lt;br/&gt;              tag: &lt;span&gt;&quot;style&quot;&lt;/span&gt;,&lt;br/&gt;              children: styles,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;head&quot;&lt;/span&gt;,&lt;br/&gt;            }],&lt;br/&gt;          }&lt;br/&gt;       }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于交互的页面实现有很多种,最简单的无非就是编写原生&lt;code&gt;js&lt;/code&gt;,这样我们无需任何编译就可以直接注入到&lt;code&gt;html&lt;/code&gt;中,但是用原生&lt;code&gt;js&lt;/code&gt;来写页面真的是慢又不好维护,于是我选择了&lt;code&gt;Vue&lt;/code&gt;进行开发,使用&lt;code&gt;Vue&lt;/code&gt;就意味着要进行编译才能在浏览器中跑起来.为了这个所谓的研发体验,又折腾了一波,大概过程就是通过&lt;code&gt;compile-sfc&lt;/code&gt;等包编译出&lt;code&gt;render函数,样式代码等&lt;/code&gt;,为了兼容&lt;code&gt;Vue2&lt;/code&gt;,我又引入了祖传的&lt;code&gt;vue-template-compiler&lt;/code&gt;...噼里啪啦噼里啪啦..感兴趣的童鞋可以点传送门详看. (u1s1,还是有点意思的!!) 当然了,这部分的编译都是在插件打包时完成的,用户在使用插件的时候并不会有这部分的运行时开销.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;致谢&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目的灵感来自于react-dev-inspector,使用&lt;code&gt;React&lt;/code&gt;的童鞋可以看看.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结语&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做这个插件的时候也踩了一些坑,通过查看&lt;code&gt;vue,vite&lt;/code&gt;等源码排查解决.这里给想看源码的童鞋一个建议,从实践和带着问题的角度出发,也许会有更好的效果和更深刻的印象 (&lt;span&gt;教训&lt;/span&gt;) :)&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>