<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5b5757ec885e4503627332fd4429e9f4</guid>
<title>携程的混合办公，到底行不行？12个Vue小技巧；2022年之Web开发新基准｜码农周刊VIP会员专属邮件周报 Vol.080</title>
<link>https://toutiao.io/k/lk15pdx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bd7939ae190ad84b93178027a966482e</guid>
<title>一款开源NFT市场</title>
<link>https://toutiao.io/k/xsynx5j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4226e6131bca017906c5e6a6530216b4</guid>
<title>求你别自己瞎写工具类了，Spring自带的这些他不香麽？</title>
<link>https://toutiao.io/k/jvzkrt6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;断言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象、数组、集合&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ObjectUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;StringUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CollectionUtils&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;文件、资源、IO 流&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FileCopyUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ResourceUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;StreamUtils&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;反射、AOP&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReflectionUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AopUtils&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AopContext&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6733333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfcyYmwVu8fTFJpc8qoH2QHF0wzM2xLLagVrK7eSUbLeVwtRU26RyVWNDFxpmIXAc1wMI9ogciajIbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近发现同事写了不少重复的工具类，发现其中很多功能，Spring 自带的都有。于是整理了本文，希望能够帮助到大家！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;断言&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;断言是一个逻辑判断，用于检查不应该发生的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数&lt;code&gt;-enableassertions&lt;/code&gt;开启&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 参数 message 参数用于定制异常信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;notNull&lt;/span&gt;&lt;span&gt;(Object object, String message)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 要求参数必须空（Null），否则抛出异常，不予『放行』。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 和 notNull() 方法断言规则相反&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;isNull&lt;/span&gt;&lt;span&gt;(Object object, String message)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 要求参数必须为真（True），否则抛出异常，不予『放行』。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;isTrue&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; expression, String message)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;notEmpty&lt;/span&gt;&lt;span&gt;(Collection collection, String message)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;hasLength&lt;/span&gt;&lt;span&gt;(String text, String message)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;hasText&lt;/span&gt;&lt;span&gt;(String text, String message)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 要求参数是指定类型的实例，否则抛出异常，不予放行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;isInstanceOf&lt;/span&gt;&lt;span&gt;(Class type, Object obj, String message)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;isAssignable&lt;/span&gt;&lt;span&gt;(Class superType, Class subType, String message)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对象、数组、集合&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ObjectUtils&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取对象的基本信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 获取对象的类名。参数为 null 时，返回字符串：&quot;null&quot; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;String &lt;span&gt;nullSafeClassName&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 参数为 null 时，返回 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;nullSafeHashCode&lt;/span&gt;&lt;span&gt;(Object object)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 参数为 null 时，返回字符串：&quot;null&quot;&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;nullSafeToString&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt;[] array)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 &lt;/span&gt;&lt;br/&gt;String &lt;span&gt;getIdentityHexString&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：&quot;&quot; &lt;/span&gt;&lt;br/&gt;String &lt;span&gt;identityToString&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 相当于 toString()方法，但参数为 null 时，返回字符串：&quot;&quot;&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;getDisplayString&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 判断数组是否为空&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isEmpty&lt;/span&gt;&lt;span&gt;(Object[] array)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断参数对象是否是数组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isArray&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断数组中是否包含指定元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;containsElement&lt;/span&gt;&lt;span&gt;(Object[] array, Object element)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 相等，或同为 null时，返回 true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;nullSafeEquals&lt;/span&gt;&lt;span&gt;(Object o1, Object o2)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt;判断参数对象是否为空，判断标准为：&lt;br/&gt;    Optional: Optional.empty()&lt;br/&gt;       Array: length == 0&lt;br/&gt;CharSequence: length == 0&lt;br/&gt;  Collection: Collection.isEmpty()&lt;br/&gt;         Map: Map.isEmpty()&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isEmpty&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;其他工具方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 向参数数组的末尾追加新元素，并返回一个新数组&lt;/span&gt;&lt;br/&gt;&amp;lt;A, O extends A&amp;gt; A[] addObjectToArray(A[] array, O obj)&lt;br/&gt;&lt;span&gt;// 原生基础类型数组 --&amp;gt; 包装类数组&lt;/span&gt;&lt;br/&gt;Object[] toObjectArray(Object source)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;StringUtils&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;字符串判断工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 判断字符串是否为 null，或 &quot;&quot;。注意，包含空白符的字符串为非空&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isEmpty&lt;/span&gt;&lt;span&gt;(Object str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断字符串是否是以指定内容结束。忽略大小写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;endsWithIgnoreCase&lt;/span&gt;&lt;span&gt;(String str, String suffix)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断字符串是否已指定内容开头。忽略大小写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;startsWithIgnoreCase&lt;/span&gt;&lt;span&gt;(String str, String prefix)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 是否包含空白符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;containsWhitespace&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断字符串非空且长度不为 0，即，Not Empty&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasLength&lt;/span&gt;&lt;span&gt;(CharSequence str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasText&lt;/span&gt;&lt;span&gt;(CharSequence str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断字符串指定索引处是否包含一个子串。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;substringMatch&lt;/span&gt;&lt;span&gt;(CharSequence str, &lt;span&gt;int&lt;/span&gt; index, CharSequence substring)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 计算一个字符串中指定子串的出现次数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;countOccurrencesOf&lt;/span&gt;&lt;span&gt;(String str, String sub)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;字符串操作工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 查找并替换指定子串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;String &lt;span&gt;replace&lt;/span&gt;&lt;span&gt;(String inString, String oldPattern, String newPattern)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 去除尾部的特定字符&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;trimTrailingCharacter&lt;/span&gt;&lt;span&gt;(String str, &lt;span&gt;char&lt;/span&gt; trailingCharacter)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 去除头部的特定字符&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;trimLeadingCharacter&lt;/span&gt;&lt;span&gt;(String str, &lt;span&gt;char&lt;/span&gt; leadingCharacter)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 去除头部的空白符&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;trimLeadingWhitespace&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 去除头部的空白符&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;trimTrailingWhitespace&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 去除头部和尾部的空白符&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;trimWhitespace&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 删除开头、结尾和中间的空白符&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;trimAllWhitespace&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 删除指定子串&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(String inString, String pattern)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 删除指定字符（可以是多个）&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;deleteAny&lt;/span&gt;&lt;span&gt;(String inString, String charsToDelete)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 对数组的每一项执行 trim() 方法&lt;/span&gt;&lt;br/&gt;String[] &lt;span&gt;trimArrayElements&lt;/span&gt;&lt;span&gt;(String[] array)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将 URL 字符串进行解码&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;uriDecode&lt;/span&gt;&lt;span&gt;(String source, Charset charset)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;路径相关工具方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 解析路径字符串，优化其中的 “..” &lt;/span&gt;&lt;br/&gt;&lt;span&gt;String &lt;span&gt;cleanPath&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 解析路径字符串，解析出文件名部分&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;getFilename&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 解析路径字符串，解析出文件后缀名&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;getFilenameExtension&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” &lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;pathEquals&lt;/span&gt;&lt;span&gt;(String path1, String path2)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 删除文件路径名中的后缀部分&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;stripFilenameExtension&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 以 “. 作为分隔符，获取其最后一部分&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;unqualify&lt;/span&gt;&lt;span&gt;(String qualifiedName)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 以指定字符作为分隔符，获取其最后一部分&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;unqualify&lt;/span&gt;&lt;span&gt;(String qualifiedName, &lt;span&gt;char&lt;/span&gt; separator)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;CollectionUtils&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;集合判断工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 判断 List/Set 是否为空&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isEmpty&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; collection)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断 Map 是否为空&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isEmpty&lt;/span&gt;&lt;span&gt;(Map&amp;lt;?,?&amp;gt; map)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断 List/Set 中是否包含某个对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;containsInstance&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; collection, Object element)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 以迭代器的方式，判断 List/Set 中是否包含某个对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;contains&lt;/span&gt;&lt;span&gt;(Iterator&amp;lt;?&amp;gt; iterator, Object element)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断 List/Set 是否包含某些对象中的任意一个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;containsAny&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; source, Collection&amp;lt;?&amp;gt; candidates)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasUniqueObject&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; collection)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;集合操作工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 将 Array 中的元素都添加到 List/Set 中&lt;/span&gt;&lt;br/&gt;&amp;lt;E&amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;mergeArrayIntoCollection&lt;/span&gt;&lt;span&gt;(Object array, Collection&amp;lt;E&amp;gt; collection)&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;// 将 Properties 中的键值对都添加到 Map 中&lt;/span&gt;&lt;br/&gt;&amp;lt;K,V&amp;gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;mergePropertiesIntoMap&lt;/span&gt;&lt;span&gt;(Properties props, Map&amp;lt;K,V&amp;gt; map)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 返回 List 中最后一个元素&lt;/span&gt;&lt;br/&gt;&amp;lt;T&amp;gt; T &lt;span&gt;lastElement&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; list)&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;// 返回 Set 中最后一个元素&lt;/span&gt;&lt;br/&gt;&amp;lt;T&amp;gt; T &lt;span&gt;lastElement&lt;/span&gt;&lt;span&gt;(Set&amp;lt;T&amp;gt; set)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 返回参数 candidates 中第一个存在于参数 source 中的元素&lt;/span&gt;&lt;br/&gt;&amp;lt;E&amp;gt; E &lt;span&gt;findFirstMatch&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; source, Collection&amp;lt;E&amp;gt; candidates)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 返回 List/Set 中指定类型的元素。&lt;/span&gt;&lt;br/&gt;&amp;lt;T&amp;gt; T &lt;span&gt;findValueOfType&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; collection, Class&amp;lt;T&amp;gt; type)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推&lt;/span&gt;&lt;br/&gt;Object &lt;span&gt;findValueOfType&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; collection, Class&amp;lt;?&amp;gt;[] types)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 返回 List/Set 中元素的类型&lt;/span&gt;&lt;br/&gt;Class&amp;lt;?&amp;gt; &lt;span&gt;findCommonElementType&lt;/span&gt;&lt;span&gt;(Collection&amp;lt;?&amp;gt; collection)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件、资源、IO 流&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FileCopyUtils&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;输入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 从文件中读入到字节数组中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] copyToByteArray(File in)&lt;br/&gt;&lt;span&gt;// 从输入流中读入到字节数组中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] copyToByteArray(InputStream in)&lt;br/&gt;&lt;span&gt;// 从输入流中读入到字符串中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;String &lt;span&gt;copyToString&lt;/span&gt;&lt;span&gt;(Reader in)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;输出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 从字节数组到文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] in, File out)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从文件到文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(File in, File out)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从字节数组到输出流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] in, OutputStream out)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 从输入流到输出流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(InputStream in, OutputStream out)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 从输入流到输出流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(Reader in, Writer out)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从字符串到输出流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(String in, Writer out)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ResourceUtils&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从资源路径获取文件&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 判断字符串是否是一个合法的 URL 字符串。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isUrl&lt;/span&gt;&lt;span&gt;(String resourceLocation)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取 URL&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; URL &lt;span&gt;getURL&lt;/span&gt;&lt;span&gt;(String resourceLocation)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; File &lt;span&gt;getFile&lt;/span&gt;&lt;span&gt;(String resourceLocation)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Resource&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 文件系统资源 D:\...&lt;/span&gt;&lt;br/&gt;FileSystemResource&lt;br/&gt;&lt;span&gt;// URL 资源，如 file://... http://...&lt;/span&gt;&lt;br/&gt;UrlResource&lt;br/&gt;&lt;span&gt;// 类路径下的资源，classpth:...&lt;/span&gt;&lt;br/&gt;ClassPathResource&lt;br/&gt;&lt;span&gt;// Web 容器上下文中的资源（jar 包、war 包）&lt;/span&gt;&lt;br/&gt;ServletContextResource&lt;br/&gt;&lt;span&gt;// 判断资源是否存在&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从资源中获得 File 对象&lt;/span&gt;&lt;br/&gt;File &lt;span&gt;getFile&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从资源中获得 URI 对象&lt;/span&gt;&lt;br/&gt;URI &lt;span&gt;getURI&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从资源中获得 URI 对象&lt;/span&gt;&lt;br/&gt;URL &lt;span&gt;getURL&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获得资源的 InputStream&lt;/span&gt;&lt;br/&gt;InputStream &lt;span&gt;getInputStream&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获得资源的描述信息&lt;/span&gt;&lt;br/&gt;String &lt;span&gt;getDescription&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;StreamUtils&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;输入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] in, OutputStream out)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(InputStream in, OutputStream out)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(String in, Charset charset, OutputStream out)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;copyRange&lt;/span&gt;&lt;span&gt;(InputStream in, OutputStream out, &lt;span&gt;long&lt;/span&gt; start, &lt;span&gt;long&lt;/span&gt; end)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;输出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;byte&lt;/span&gt;[] copyToByteArray(InputStream in)&lt;br/&gt;&lt;span&gt;String &lt;span&gt;copyToString&lt;/span&gt;&lt;span&gt;(InputStream in, Charset charset)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 舍弃输入流中的内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;drain&lt;/span&gt;&lt;span&gt;(InputStream in)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反射、AOP&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ReflectionUtils&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 在类中查找指定方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Method &lt;span&gt;findMethod&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz, String name)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 同上，额外提供方法参数类型作查找条件&lt;/span&gt;&lt;br/&gt;Method &lt;span&gt;findMethod&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz, String name, Class&amp;lt;?&amp;gt;... paramTypes)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 获得类中所有方法，包括继承而来的&lt;/span&gt;&lt;br/&gt;Method[] &lt;span&gt;getAllDeclaredMethods&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; leafClass)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 在类中查找指定构造方法&lt;/span&gt;&lt;br/&gt;Constructor&amp;lt;T&amp;gt; &lt;span&gt;accessibleConstructor&lt;/span&gt;&lt;span&gt;(Class&amp;lt;T&amp;gt; clazz, Class&amp;lt;?&amp;gt;... parameterTypes)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 是否是 equals() 方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isEqualsMethod&lt;/span&gt;&lt;span&gt;(Method method)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 是否是 hashCode() 方法 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isHashCodeMethod&lt;/span&gt;&lt;span&gt;(Method method)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 是否是 toString() 方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isToStringMethod&lt;/span&gt;&lt;span&gt;(Method method)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 是否是从 Object 类继承而来的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isObjectMethod&lt;/span&gt;&lt;span&gt;(Method method)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 检查一个方法是否声明抛出指定异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;declaresException&lt;/span&gt;&lt;span&gt;(Method method, Class&amp;lt;?&amp;gt; exceptionType)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 执行方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object &lt;span&gt;invokeMethod&lt;/span&gt;&lt;span&gt;(Method method, Object target)&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;// 同上，提供方法参数&lt;/span&gt;&lt;br/&gt;Object &lt;span&gt;invokeMethod&lt;/span&gt;&lt;span&gt;(Method method, Object target, Object... args)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 取消 Java 权限检查。以便后续执行该私有方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;makeAccessible&lt;/span&gt;&lt;span&gt;(Method method)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 取消 Java 权限检查。以便后续执行私有构造方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;makeAccessible&lt;/span&gt;&lt;span&gt;(Constructor&amp;lt;?&amp;gt; ctor)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取字段&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 在类中查找指定属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Field &lt;span&gt;findField&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz, String name)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 同上，多提供了属性的类型&lt;/span&gt;&lt;br/&gt;Field &lt;span&gt;findField&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz, String name, Class&amp;lt;?&amp;gt; type)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 是否为一个 &quot;public static final&quot; 属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isPublicStaticFinal&lt;/span&gt;&lt;span&gt;(Field field)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置字段&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 获取 target 对象的 field 属性值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Object &lt;span&gt;getField&lt;/span&gt;&lt;span&gt;(Field field, Object target)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 设置 target 对象的 field 属性值，值为 value&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setField&lt;/span&gt;&lt;span&gt;(Field field, Object target, Object value)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 同类对象属性对等赋值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;shallowCopyFieldState&lt;/span&gt;&lt;span&gt;(Object src, Object dest)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 取消 Java 的权限控制检查。以便后续读写该私有属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;makeAccessible&lt;/span&gt;&lt;span&gt;(Field field)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 对类的每个属性执行 callback&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;doWithFields&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz, ReflectionUtils.FieldCallback fc)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 同上，多了个属性过滤功能。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;doWithFields&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz, ReflectionUtils.FieldCallback fc, &lt;br/&gt;                  ReflectionUtils.FieldFilter ff)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 同上，但不包括继承而来的属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;doWithLocalFields&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; clazz, ReflectionUtils.FieldCallback fc)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AopUtils&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断代理类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 判断是不是 Spring 代理对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isAopProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断是不是 jdk 动态代理对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;isJdkDynamicProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 判断是不是 CGLIB 代理对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isCglibProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取被代理对象的 class&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 获取被代理的目标 class&lt;/span&gt;&lt;br/&gt;Class&amp;lt;?&amp;gt; getTargetClass()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AopContext&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前对象的代理对象&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Object &lt;span&gt;currentProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8c06cf843925534975c8f755b9f7b17</guid>
<title>Golang 语言 gRPC 服务怎么同时支持 gRPC 和 HTTP 客户端调用？</title>
<link>https://toutiao.io/k/emhzf5r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是 frank。&lt;br/&gt;欢迎大家点击标题下方&lt;span&gt;蓝色&lt;/span&gt;文字「Golang 语言开发栈」关注公众号。&lt;br/&gt;&lt;strong&gt;设为星标&lt;/strong&gt;，第一时间接收推送文章。&lt;br/&gt;&lt;strong&gt;文末扫码&lt;/strong&gt;，加群一起学 Golang 语言。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 gRPC 的文章，我们之前写过几篇，如果读者朋友还对 gRPC 不了解，我建议您可以翻阅一下公众号的历史文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要提供 gRPC 服务的 RESTful API 时，可以先创建一个 gRPC 客户端服务，在 gRPC 客户端服务编写 RESTful API，接收到 HTTP 请求时，通过 gRPC 客户端服务调用 gRPC 服务端服务的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信读者朋友们也意识到，仅仅为了提供 RESTful API 而编写一个 gRPC 客户端服务，显然有些小题大做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不借助 gRPC 客户端服务的前提下，gRPC 服务端服务怎么同时支持 gRPC 和 HTTP 客户端调用？今天我们介绍一个 protoc 插件 gRPC-Gateway。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 是 protoc 的一个插件。它读取 gRPC 服务定义并生成一个反向代理服务器，该服务器将 RESTful JSON API 转换为 gRPC。此服务器是根据 gRPC 定义中的自定义选项生成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 可帮助您同时以 gRPC 和 RESTful 风格提供 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们开始编码之前，需要一些先决条件。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，我们需要先搭建一个 Go 环境。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 go get 工具下载一些依赖包。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 go mod init 工具创建一个 go.mod 文件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖包列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go get google.golang.org/protobuf/cmd/protoc-gen-go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; go get google.golang.org/grpc/cmd/protoc-gen-go-grpc&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 实战&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成以上先决条件后，我们创建一个 gRPC 服务端服务，本文我们创建一个 ToDoList gRPC 服务。在创建 gRPC 服务之前，我们使用 protocol buffers 创建一个 proto 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建 proto 文件&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;service ToDoList {&lt;br/&gt;  rpc CreateToDoList (ToDoListDetail) returns (CreateToDoListResult) {}&lt;br/&gt;  rpc ReadToDoList (ToDoListPage) returns (ReadToDoListByPage) {}&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;生成 gRPC 服务端存根&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 protoc 命令工具生成存根&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;protoc -I proto \&lt;br/&gt;   --go_out &lt;span&gt;./pb/todoPb&lt;/span&gt; --go_opt paths=source_relative \&lt;br/&gt;   --go-grpc_out ./pb/todoPb --go-grpc_opt paths=source_relative \&lt;br/&gt;   proto/toDoList.proto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行上面 protoc 命令工具，生成一个 &lt;code&gt;*.pb.go&lt;/code&gt; 文件和一个 &lt;code&gt;*_grpc.pb.go&lt;/code&gt; 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编写剩余 Go 代码&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 main.go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; InitEngine()&lt;br/&gt; lis, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, address)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;failed to listen: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; server := grpc.NewServer()&lt;br/&gt; pb.RegisterToDoListServer(server, &lt;span&gt;new&lt;/span&gt;(service.ToDoList))&lt;br/&gt; log.Printf(&lt;span&gt;&quot;server listening at %v\n&quot;&lt;/span&gt;, lis.Addr())&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := server.Serve(lis); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;failed to serve: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;完整代码，请参阅 Github。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;添加 gRPC-Gateway 选项&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway 使用 google.api.http 选项定义 gRPC 服务如何映射到 JSON 请求和响应，使用 protoc 时，每个 RPC 必须使用 google.api.http 选项定义 HTTP 方法和路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们需要将 google/api/http.proto 导入添加到 proto 文件中。我们还需要添加我们想要的 HTTP -&amp;gt; gRPC 映射。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;syntax = &quot;proto3&quot;;&lt;br/&gt;&lt;br/&gt;import &quot;google/api/annotations.proto&quot;;&lt;br/&gt;&lt;br/&gt;service ToDoList {&lt;br/&gt;  rpc CreateToDoList (ToDoListDetail) returns (CreateToDoListResult) {&lt;br/&gt;    option (google.api.http) = {&lt;br/&gt;      post: &quot;/v1/todolist/add&quot;&lt;br/&gt;      body: &quot;*&quot;&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;  rpc ReadToDoList (ToDoListPage) returns (ReadToDoListByPage) {&lt;br/&gt;    option (google.api.http) = {&lt;br/&gt;      get: &quot;/v1/todolist/select&quot;&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 HTTP 和 gRPC 映射的更多内容，可以参阅 Google API 文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;生成 gRPC-Gateway 存根&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们已将 gRPC-Gateway 选项添加到 proto 文件中，我们需要使用 gRPC-Gateway 生成器来生成存根。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 protoc 生成存根之前，我们需要将一些依赖项复制到 proto 文件目录中。将 googleapis 的子集从官方存储库下载并复制到本地 proto 文件目录中。如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;.&lt;br/&gt;├── dao&lt;br/&gt;│   ├── mysql.go&lt;br/&gt;│   └── toDoList.go&lt;br/&gt;├── grpc-gateway&lt;br/&gt;│   └── main.go&lt;br/&gt;├── main.go&lt;br/&gt;├── pb&lt;br/&gt;│   └── todoPb&lt;br/&gt;│       ├── toDoList.pb.go&lt;br/&gt;│       ├── toDoList.pb.gw.go&lt;br/&gt;│       └── toDoList_grpc.pb.go&lt;br/&gt;├── proto&lt;br/&gt;│   ├── google&lt;br/&gt;│   │   └── api&lt;br/&gt;│   │       ├── annotations.proto&lt;br/&gt;│   │       └── http.proto&lt;br/&gt;│   └── toDoList.proto&lt;br/&gt;└── service&lt;br/&gt;    └── toDoList.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 protoc 生成存根&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;protoc -I proto \&lt;br/&gt;  --go_out ./pb/todoPb --go_opt paths=source_relative \&lt;br/&gt;  --go-grpc_out ./pb/todoPb --go-grpc_opt paths=source_relative \&lt;br/&gt;  --grpc-gateway_out ./pb/todoPb --grpc-gateway_opt paths=source_relative \&lt;br/&gt;  proto/toDoList.proto&lt;br/&gt;  &lt;br/&gt;protoc-go-inject-tag -XXX_skip=xorm -input=./pb/todoPb/toDoList.pb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以上 protoc 命令工具，生成一个 &lt;code&gt;*.gw.pb.go&lt;/code&gt; 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 grpc-gateway 目录，并创建 main.go 文件，创建 gRPC-Gateway 多路复用器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctx := context.Background()&lt;br/&gt; ctx, cancel := context.WithCancel(ctx)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt; mux := runtime.NewServeMux()&lt;br/&gt; opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}&lt;br/&gt; err := pb.RegisterToDoListHandlerFromEndpoint(ctx, mux, grpcServerEndpoint, opts)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;Fail to register gRPC gateway service endpoint: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = http.ListenAndServe(&lt;span&gt;&quot;:8080&quot;&lt;/span&gt;, mux); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;Could not setup HTTP endpoint: %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;完整代码，请参阅 Github。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;启动服务&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;grpc 服务&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gRPC-Gateway&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run grpc-gateway/main.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cURL 测试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl http://127.0.0.1:8080/v1/todolist/select?page=1&amp;amp;count=2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;todolist&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;&quot;1&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;content&quot;&lt;/span&gt;: &lt;span&gt;&quot;编程写代码&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;datetime&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632541505&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;created&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632541505&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;updated&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632541505&quot;&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;&quot;2&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;content&quot;&lt;/span&gt;: &lt;span&gt;&quot;编程写代码&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;datetime&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632543373&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;created&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632543373&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;updated&quot;&lt;/span&gt;: &lt;span&gt;&quot;1632543373&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍 gRPC-Gateway 如何实现同时支持 gRPC 和 RESTful 风格的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 HTTP 请求到达 gRPC-Gateway 时，它会将 JSON 数据解析为 protobuf 消息。然后，它使用解析的 protobuf 消息发出正常的 Go gRPC 客户端请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go gRPC 客户端将 protobuf 结构编码为 protobuf 二进制格式，并将其发送到 gRPC 服务器。gRPC 服务器处理请求并以 protobuf 二进制格式返回响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go gRPC 客户端将其解析为 protobuf 消息，并将其返回到 gRPC-Gateway，后者将 protobuf 消息编码为 JSON 并将其返回到原始客户端。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7057220708446866&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gf7zJ2NXUibGsSgtDw5dk9tGslAGJFHzho58JAia7HZxgLAjoIyL4dUrEkIaQtcA4GSfNf4iaMhMT2kRgqBXANNVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/p&gt;&lt;p&gt;图片来自 gRPC-Gateway 官方文档&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485838&amp;amp;idx=1&amp;amp;sn=d0614ea793a8407b943e6c66a1dedb58&amp;amp;chksm=9f81a3e0a8f62af6a0f1260ac4c40b2a76855606f874b67944057f1ee2d2495960cbc120205d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言怎么打印结构体指针类型字段的值？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言怎么打印结构体指针类型字段的值？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485227&amp;amp;idx=1&amp;amp;sn=057e69ee48a8ad55a759afc53bcdd349&amp;amp;chksm=9f81ad45a8f62453c8c3fcc258cae92ea061e490d229fe223cff2c3c2bf15c86c34026fea6b3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 gRPC 使用的接口设计语言 protobuf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 gRPC 使用的接口设计语言 protobuf&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485291&amp;amp;idx=1&amp;amp;sn=89626702df6d071c121b79a72d04d348&amp;amp;chksm=9f81ad05a8f62413a4c3e8aabbec696e53b3e62477e24855a43dd122f199347a03833f10b7c7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 gRPC 到底是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 gRPC 到底是什么？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485338&amp;amp;idx=1&amp;amp;sn=c5f3ae0f7a7d81621c8ecfcd745d386a&amp;amp;chksm=9f81adf4a8f624e280927dd758fbae212b4e1d8ae02d52a42bf0787aa411d4797943b7123543&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 gRPC 怎么使用？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 gRPC 怎么使用？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485405&amp;amp;idx=1&amp;amp;sn=909ee026535a88d632bfcd3c120c571f&amp;amp;chksm=9f81adb3a8f624a5a5bf2d2740024f94e700ac3bd01b589691c04df13fff646dbe9cc11ab3dc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言编写 gRPC 实战项目&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言编写 gRPC 实战项目&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;br/&gt;https://github.com/grpc-ecosystem/grpc-gateway &lt;br/&gt;https://github.com/googleapis/googleapis &lt;br/&gt;https://github.com/googleapis/googleapis.github.io/ &lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0d154af95dca3de8b9ed1b191632d541</guid>
<title>Golang 简洁架构实战</title>
<link>https://toutiao.io/k/vjw1dlc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：bearluo，腾讯 IEG 运营开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文中项目代码位置：https://github.com/devYun/go-clean-architecture&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 golang 不像 java 一样有一个统一的编码模式，所以我们和其他团队一样，采用了 &lt;a href=&quot;https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md&quot; data-linktype=&quot;2&quot;&gt;Go 面向包的设计和架构分层&lt;/a&gt;这篇文章介绍的一些理论，然后再结合以往的项目经验来进行分包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;├── cmd/&lt;br/&gt;│   └── main.go //启动函数&lt;br/&gt;├── etc&lt;br/&gt;│   └── dev_conf.yaml              // 配置文件&lt;br/&gt;├── global&lt;br/&gt;│   └── global.go //全局变量引用，如数据库、kafka等&lt;br/&gt;├── internal/&lt;br/&gt;│       └── service/&lt;br/&gt;│           └── xxx_service.go //业务逻辑处理类&lt;br/&gt;│           └── xxx_service_test.go&lt;br/&gt;│       └── model/&lt;br/&gt;│           └── xxx_info.go//结构体&lt;br/&gt;│       └── api/&lt;br/&gt;│           └── xxx_api.go//路由对应的接口实现&lt;br/&gt;│       └── router/&lt;br/&gt;│           └── router.go//路由&lt;br/&gt;│       └── pkg/&lt;br/&gt;│           └── datetool//时间工具类&lt;br/&gt;│           └── jsontool//json 工具类&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面的这个划分只是简单的将功能分了一下包，在项目实践的过程中还是有很多问题。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于功能实现我是通过 function 的参数传递还是通过结构体的变量传递？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用一个数据库的全局变量引用传递是否安全？是否存在过度耦合？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在代码实现过程中几乎全部都是依赖于实现，而不是依赖于接口，那么将 MySQL 切换为 MongDB 是不是要修改所有的实现？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在在我们工作中随着代码越来越多，代码中各种 init，function，struct，全局变量感觉也越来越乱。每个模块不独立，看似按逻辑分了模块，但没有明确的上下层关系，每个模块里可能都存在配置读取，外部服务调用，协议转换等。久而久之服务不同包函数之间的调用慢慢演变成网状结构，数据流的流向和逻辑的梳理变得越来越复杂，很难不看代码调用的情况下搞清楚数据流向。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.785472972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7Gvpia6zKNZNzgxtsJdUdmTDqERnYmTdUeDcicNZYL1Yu9V2nUhCZficRxo8yw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过就像《重构》中所说：先让代码工作起来-如果代码不能工作，就不能产生价值；然后再试图将它变好-通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我觉得是时候自我改变一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;The Clean Architecture&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在简洁架构里面对我们的项目提出了几点要求：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;独立于框架。该架构不依赖于某些功能丰富的软件库的存在。这允许你把这些框架作为工具来使用，而不是把你的系统塞进它们有限的约束中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可测试。业务规则可以在没有 UI、数据库、Web 服务器或任何其他外部元素的情况下被测试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于用户界面。UI 可以很容易地改变，而不用改变系统的其他部分。例如，一个 Web UI 可以被替换成一个控制台 UI，而不改变业务规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于数据库。你可以把 Oracle 或 SQL Server 换成 Mongo、BigTable、CouchDB 或其他东西。你的业务规则不受数据库的约束。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于任何外部机构。事实上，你的业务规则根本不知道外部世界的任何情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7344559585492227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7Gvpia1Mic3QVs9ohKJicsI0n0ia2x8EQTWxwwiaA3jrSKLEzox7Ak4iaDiaRkuVKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;772&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中同心圆代表各种不同领域的软件。一般来说，越深入代表你的软件层次越高。外圆是战术实现机制，内圆的是战略核心策略。对于我们的项目来说，代码依赖应该由外向内，单向单层依赖，这种依赖包含代码名称，或类的函数，变量或任何其他命名软件实体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于简洁架构来说分为了四层：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Entities：实体&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Usecase：表达应用业务规则，对应的是应用层，它封装和实现系统的所有用例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Interface Adapters：这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或 Web 使用的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Framework &amp;amp; Driver：最外面一圈通常是由一些框架和工具组成，如数据库 Database, Web 框架等；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于我的项目来说，也分为了四层：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5564516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas7ZJjbRFkHmYsjMFO7GvpiaOV1uicwcx1wjU7LWLQhAtf4Vlk2KOT9ktnHK2QQ8DwBsJIAwrSCQiaRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;代码分层&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;models&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装了各种实体类对象，与数据库交互的、与 UI 交互的等等，任何的实体类都应该放在这里。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Article &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; ID        &lt;span&gt;int64&lt;/span&gt;     &lt;span&gt;`json:&quot;id&quot;`&lt;/span&gt;&lt;br/&gt; Title     &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;`json:&quot;title&quot;`&lt;/span&gt;&lt;br/&gt; Content   &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;`json:&quot;content&quot;`&lt;/span&gt;&lt;br/&gt; UpdatedAt time.Time &lt;span&gt;`json:&quot;updated_at&quot;`&lt;/span&gt;&lt;br/&gt; CreatedAt time.Time &lt;span&gt;`json:&quot;created_at&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;repo&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里存放的是数据库操作类，数据库 CRUD 都在这里。需要注意的是，这里不包含任何的业务逻辑代码，很多同学喜欢将业务逻辑也放到这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 ORM，那么这里放入的 ORM 操作相关的代码；如果使用微服务，那么这里放的是其他服务请求的代码；&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;service&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是业务逻辑层，所有的业务过程处理代码都应该放在这里。这一层会决定是请求 repo 层的什么代码，是操作数据库还是调用其他服务；所有的业务数据计算也应该放在这里；这里接受的入参应该是 controller 传入的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;api&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是接收外部请求的代码，如：gin 对应的 handler、gRPC、其他 REST API 框架接入层等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面向接口编程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 models 层，层与层之间应该通过接口交互，而不是实现。如果要用 service 调用 repo 层，那么应该调用 repo 的接口。那么修改底层实现的时候我们上层的基类不需要变更，只需要更换一下底层实现即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们想要将所有文章查询出来，那么可以在 repo 提供这样的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; repo&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/models&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// IArticleRepo represent the article&#x27;s repository contract&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; IArticleRepo &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Fetch(ctx context.Context, createdDate time.Time, num &lt;span&gt;int&lt;/span&gt;) (res []models.Article, err error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口的实现类就可以根据需求变更，比如说当我们想要 mysql 来作为存储查询，那么只需要提供一个这样的基类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; mysqlArticleRepository &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; DB *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NewMysqlArticleRepository will create an object that represent the article.Repository interface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewMysqlArticleRepository&lt;/span&gt;&lt;span&gt;(DB *gorm.DB)&lt;/span&gt; &lt;span&gt;IArticleRepo&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;mysqlArticleRepository{DB}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(m *mysqlArticleRepository)&lt;/span&gt; &lt;span&gt;Fetch&lt;/span&gt;&lt;span&gt;(ctx context.Context, createdDate time.Time,&lt;br/&gt; num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(res []models.Article, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; err = m.DB.WithContext(ctx).Model(&amp;amp;models.Article{}).&lt;br/&gt;  Select(&lt;span&gt;&quot;id,title,content, updated_at, created_at&quot;&lt;/span&gt;).&lt;br/&gt;  Where(&lt;span&gt;&quot;created_at &amp;gt; ?&quot;&lt;/span&gt;, createdDate).Limit(num).Find(&amp;amp;res).Error&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果改天想要换成 MongoDB 来实现我们的存储，那么只需要定义一个结构体实现 IArticleRepo 接口即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在 service 层实现的时候就可以按照我们的需求来将对应的 repo 实现注入即可，从而不需要改动 service 层的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; articleService &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; articleRepo repo.IArticleRepo&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// NewArticleService will create new an articleUsecase object representation of domain.ArticleUsecase interface&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewArticleService&lt;/span&gt;&lt;span&gt;(a repo.IArticleRepo)&lt;/span&gt; &lt;span&gt;IArticleService&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;articleService{&lt;br/&gt;  articleRepo: a,&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Fetch&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(a *articleService)&lt;/span&gt; &lt;span&gt;Fetch&lt;/span&gt;&lt;span&gt;(ctx context.Context, createdDate time.Time, num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(res []models.Article, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; num == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  num = &lt;span&gt;10&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; res, err = a.articleRepo.Fetch(ctx, createdDate, num)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;依赖注入 DI&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖注入，英文名 dependency injection，简称 DI 。DI 以前在 java 工程里面经常遇到，但是在 go 里面很多人都说不需要，但是我觉得在大型软件开发过程中还是有必要的，否则只能通过全局变量或者方法参数来进行传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于具体什么是 DI，简单来说就是被依赖的模块，在创建模块时，被注入到（即当作参数传入）模块的里面。想要更加深入的了解什么是 DI 这里再推荐一下 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Dependency_injection&quot; data-linktype=&quot;2&quot;&gt;Dependency injection &lt;/a&gt;和 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//martinfowler.com/articles/injection.html&quot; data-linktype=&quot;2&quot;&gt;Inversion of Control Containers and the Dependency Injection pattern&lt;/a&gt; 这两篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不用 DI 主要有两大不方便的地方，一个是底层类的修改需要修改上层类，在大型软件开发过程中基类是很多的，一条链路改下来动辄要修改几十个文件；另一方面就是就是层与层之间单元测试不太方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的 new，比如我们的项目中需要这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 初始化db&lt;/span&gt;&lt;br/&gt; db := app.InitDB()&lt;br/&gt; &lt;span&gt;//初始化 repo&lt;/span&gt;&lt;br/&gt; repository := repo.NewMysqlArticleRepository(db)&lt;br/&gt; &lt;span&gt;//初始化service&lt;/span&gt;&lt;br/&gt; articleService := service.NewArticleService(repository)&lt;br/&gt; &lt;span&gt;//初始化api&lt;/span&gt;&lt;br/&gt; handler := handlers.NewArticleHandler(articleService)&lt;br/&gt; &lt;span&gt;//初始化router&lt;/span&gt;&lt;br/&gt; router := api.NewRouter(handler)&lt;br/&gt; &lt;span&gt;//初始化gin&lt;/span&gt;&lt;br/&gt; engine := app.NewGinEngine()&lt;br/&gt; &lt;span&gt;//初始化server&lt;/span&gt;&lt;br/&gt; server := app.NewServer(engine, router)&lt;br/&gt; &lt;span&gt;//启动&lt;/span&gt;&lt;br/&gt; server.Start()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于这么一段代码，我们有没有办法不用自己写呢？这里我们就可以借助框架的力量来生成我们的注入代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 go 里面 DI 的工具相对来说没有 java 这么方便，技术框架一般主要有：wire、dig、fx 等。由于 wire 是使用代码生成来进行注入，性能会比较高，并且它是 google 推出的 DI 框架，所以我们这里使用 wire 进行注入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wire 的要求很简单，新建一个 wire.go 文件（文件名可以随意），创建我们的初始化函数。比如，我们要创建并初始化一个 server 对象，我们就可以这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//+build wireinject&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;github.com/google/wire&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;InitServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;app&lt;/span&gt;.&lt;span&gt;Server&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; wire.Build(&lt;br/&gt;  app.InitDB,&lt;br/&gt;  repo.NewMysqlArticleRepository,&lt;br/&gt;  service.NewArticleService,&lt;br/&gt;  handlers.NewArticleHandler,&lt;br/&gt;  api.NewRouter,&lt;br/&gt;  app.NewServer,&lt;br/&gt;  app.NewGinEngine)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;app.Server{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，第一行的注解：+build wireinject，表示这是一个注入器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数中，我们调用&lt;code&gt;wire.Build()&lt;/code&gt;将创建 Server 所依赖的类型的构造器传进去。写完 wire.go 文件之后执行 wire 命令，就会自动生成一个 wire_gen.go 文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Code generated by Wire. DO NOT EDIT.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:generate go run github.com/google/wire/cmd/wire&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//+build !wireinject&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/api/handlers&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/app&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/repo&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;my-clean-rchitecture/service&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Injectors from wire.go:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;InitServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;app&lt;/span&gt;.&lt;span&gt;Server&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; engine := app.NewGinEngine()&lt;br/&gt; db := app.InitDB()&lt;br/&gt; iArticleRepo := repo.NewMysqlArticleRepository(db)&lt;br/&gt; iArticleService := service.NewArticleService(iArticleRepo)&lt;br/&gt; articleHandler := handlers.NewArticleHandler(iArticleService)&lt;br/&gt; router := api.NewRouter(articleHandler)&lt;br/&gt; server := app.NewServer(engine, router)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; server&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 wire 自动帮我们生成了 InitServer 方法，此方法中依次初始化了所有要初始化的基类。之后在我们的 main 函数中就只需调用这个 InitServer 即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; server := InitServer()&lt;br/&gt; server.Start()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们定义好了每一层应该做什么，那么对于每一层我们应该都是可单独测试的，即使另外一层不存在。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;models 层：这一层就很简单了，由于没有依赖任何其他代码，所以可以直接用 go 的单测框架直接测试即可；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;repo 层：对于这一层来说，由于我们使用了 mysql 数据库，那么我们需要 mock mysql，这样即使不用连 mysql 也可以正常测试，我这里使用 github.com/DATA-DOG/go-sqlmock 这个库来 mock 我们的数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;service 层：因为 service 层依赖了 repo 层，因为它们之间是通过接口来关联，所以我这里使用 github.com/golang/mock/gomock 来 mock repo 层；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;api 层：这一层依赖 service 层，并且它们之间是通过接口来关联，所以这里也可以使用 gomock 来 mock service 层。不过这里稍微麻烦了一点，因为我们接入层用的是 gin，所以还需要在单测的时候模拟发送请求；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们是通过 github.com/golang/mock/gomock 来进行 mock ，所以需要执行一下代码生成，生成的 mock 代码我们放入到 mock 包中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mockgen -destination .\mock\repo_mock.go -&lt;span&gt;source&lt;/span&gt; .\repo\repo.go -package mock&lt;br/&gt;&lt;br/&gt;mockgen -destination .\mock\service_mock.go -&lt;span&gt;source&lt;/span&gt; .\service\service.go -package mock&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两个命令会通过接口帮我自动生成 mock 函数。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;repo 层测试&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目中，由于我们用了 gorm 来作为我们的 orm 库，所以我们需要使用 github.com/DATA-DOG/go-sqlmock 结合 gorm 来进行 mock：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getSqlMock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(mock sqlmock.Sqlmock, gormDB *gorm.DB)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;//创建sqlmock&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; db *sql.DB&lt;br/&gt; db, mock, err = sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;//结合gorm、sqlmock&lt;/span&gt;&lt;br/&gt; gormDB, err = gorm.Open(mysql.New(mysql.Config{&lt;br/&gt;  SkipInitializeWithVersion: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  Conn:                      db,&lt;br/&gt; }), &amp;amp;gorm.Config{})&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;Init DB with sqlmock failed, err %v&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test_mysqlArticleRepository_Fetch&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; createAt := time.Now()&lt;br/&gt; updateAt := time.Now()&lt;br/&gt; &lt;span&gt;//id,title,content, updated_at, created_at&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; articles = []models.Article{&lt;br/&gt;  {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;test1&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;, updateAt, createAt},&lt;br/&gt;  {&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;test2&quot;&lt;/span&gt;, &lt;span&gt;&quot;content2&quot;&lt;/span&gt;, updateAt, createAt},&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; limit := &lt;span&gt;2&lt;/span&gt;&lt;br/&gt; mock, db := getSqlMock()&lt;br/&gt;&lt;br/&gt; mock.ExpectQuery(&lt;span&gt;&quot;SELECT id,title,content, updated_at, created_at FROM `articles` WHERE created_at &amp;gt; ? LIMIT 2&quot;&lt;/span&gt;).&lt;br/&gt;  WithArgs(createAt).&lt;br/&gt;  WillReturnRows(sqlmock.NewRows([]&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;&quot;title&quot;&lt;/span&gt;, &lt;span&gt;&quot;content&quot;&lt;/span&gt;, &lt;span&gt;&quot;updated_at&quot;&lt;/span&gt;, &lt;span&gt;&quot;created_at&quot;&lt;/span&gt;}).&lt;br/&gt;   AddRow(articles[&lt;span&gt;0&lt;/span&gt;].ID, articles[&lt;span&gt;0&lt;/span&gt;].Title, articles[&lt;span&gt;0&lt;/span&gt;].Content, articles[&lt;span&gt;0&lt;/span&gt;].UpdatedAt, articles[&lt;span&gt;0&lt;/span&gt;].CreatedAt).&lt;br/&gt;   AddRow(articles[&lt;span&gt;1&lt;/span&gt;].ID, articles[&lt;span&gt;1&lt;/span&gt;].Title, articles[&lt;span&gt;1&lt;/span&gt;].Content, articles[&lt;span&gt;1&lt;/span&gt;].UpdatedAt, articles[&lt;span&gt;1&lt;/span&gt;].CreatedAt))&lt;br/&gt;&lt;br/&gt; repository := NewMysqlArticleRepository(db)&lt;br/&gt; result, err := repository.Fetch(context.TODO(), createAt, limit)&lt;br/&gt;&lt;br/&gt; assert.Nil(t, err)&lt;br/&gt; assert.Equal(t, articles, result)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;service 层测试&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要就是用我们 gomock 生成的代码来 mock repo 层：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test_articleService_Fetch&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ctl := gomock.NewController(t)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; ctl.Finish()&lt;br/&gt; now := time.Now()&lt;br/&gt; mockRepo := mock.NewMockIArticleRepo(ctl)&lt;br/&gt;&lt;br/&gt; gomock.InOrder(&lt;br/&gt;  mockRepo.EXPECT().Fetch(context.TODO(), now, &lt;span&gt;10&lt;/span&gt;).Return(&lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; service := NewArticleService(mockRepo)&lt;br/&gt;&lt;br/&gt; fetch, _ := service.Fetch(context.TODO(), now, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt; fmt.Println(fetch)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;api 层测试&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这一层，我们不仅要 mock service 层，还需要发送 httptest 来模拟请求发送：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestArticleHandler_FetchArticle&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt; ctl := gomock.NewController(t)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; ctl.Finish()&lt;br/&gt; createAt, _ := time.Parse(&lt;span&gt;&quot;2006-01-02&quot;&lt;/span&gt;, &lt;span&gt;&quot;2021-12-26&quot;&lt;/span&gt;)&lt;br/&gt; mockService := mock.NewMockIArticleService(ctl)&lt;br/&gt;&lt;br/&gt; gomock.InOrder(&lt;br/&gt;  mockService.EXPECT().Fetch(gomock.Any(), createAt, &lt;span&gt;10&lt;/span&gt;).Return(&lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;),&lt;br/&gt; )&lt;br/&gt;&lt;br/&gt; article := NewArticleHandler(mockService)&lt;br/&gt;&lt;br/&gt; gin.SetMode(gin.TestMode)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Setup your router, just like you did in your main function, and&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// register your routes&lt;/span&gt;&lt;br/&gt; r := gin.Default()&lt;br/&gt; r.GET(&lt;span&gt;&quot;/articles&quot;&lt;/span&gt;, article.FetchArticle)&lt;br/&gt;&lt;br/&gt; req, err := http.NewRequest(http.MethodGet, &lt;span&gt;&quot;/articles?num=10&amp;amp;create_date=2021-12-26&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  t.Fatalf(&lt;span&gt;&quot;Couldn&#x27;t create request: %v\n&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; w := httptest.NewRecorder()&lt;br/&gt; &lt;span&gt;// Perform the request&lt;/span&gt;&lt;br/&gt; r.ServeHTTP(w, req)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Check to see if the response was what you expected&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; w.Code != http.StatusOK {&lt;br/&gt;  t.Fatalf(&lt;span&gt;&quot;Expected to get status %d but instead got %d\n&quot;&lt;/span&gt;, http.StatusOK, w.Code)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我对 golang 的项目中发现问题的一点点总结与思考，思考的先不管对不对，总归是解决了我们当下的一些问题。不过，项目总归是需要不断重构完善的，所以下次有问题的时候下次再改呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我上面的总结和描述感觉有不对的地方，请随时指出来一起讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目代码位置：https://github.com/devYun/go-clean-architecture&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Reference&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://github.com/bxcodec/go-clean-arch&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://medium.com/hackernoon/golang-clean-archithecture-efd6d7c43047&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://farer.org/2021/04/21/go-dependency-injection-wire/&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAA0_UNB6vpCAAAAAstQy6ubaLX4KHWvLEZgBPE0aI4ZQMdbqX8zNPgMItZQQz4rQdaRbVIBysIUiC8&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkialjqVumGh686o9cicHyYnbAb5R4UXceUUaUEurOc2IPUzKspc9alaHjby4Yx0oLv0wEgoFGgcGgWr1X06rsBywTA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdXHXUb10FCpaLrBro4SnibHBTMwCnlic495e1C5zumZNOPzZG0ydlmopuficFcAhfROkY&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;数学真的很美&amp;#10;&amp;#10;#代码 #codepen&amp;#10;&quot; data-nonceid=&quot;14800752956677343128&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>