<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2b043ad00bd1ea513b4df4009fe3696f</guid>
<title>让 API 并行调用变得如丝般顺滑的绝招</title>
<link>https://toutiao.io/k/itzxhci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数据量较大的时候，都会通过分库分表来拆分，分担读写的压力。分库分表后比较麻烦的就是查询的问题，如果不是直接根据分片键去查询的话，需要对多个表进行查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一些复杂的业务场景下，比如订单搜索，除了订单号，用户，商家 这些常用的搜索条件，可能还有时间，商品等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前常见的做法将数据同步到 ES 这类搜索框架中进行查询，然后通过搜出来的结果，一般是主键 ID, 再去具体的数据表中查询完整的数据，组装返回给调用方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面这段代码，首先查询出文章信息，然后根据文章中的用户 ID 去查询用户的昵称。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;ArticleBO&amp;gt; articleBos = articleDoPage.getRecords().stream().map(r -&amp;gt; {&lt;br/&gt;    String nickname = userManager.getNickname(r.getUserId());&lt;br/&gt;    return articleBoConvert.convertPlus(r, nickname);&lt;br/&gt;}).collect(Collectors.toList());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果文章有 10 条数据，那么就需要调用 10 次用户服务提供的接口，而且是同步调用操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们也可以用并行流来实现并发调用，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;ArticleBO&amp;gt; articleBos = articleDoPage.getRecords().parallelStream().map(r -&amp;gt; {&lt;br/&gt;    String nickname = userManager.getNickname(r.getUserId());&lt;br/&gt;    return articleBoConvert.convertPlus(r, nickname);&lt;br/&gt;}).collect(Collectors.toList());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并行流的优点很明显，代码不用做特别大的改动。需要注意如果用并行流，最好单独定义一个 ForkJoinPool。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了用并行流，还可以使用批量查询的方式来提高性能，降低 RPC 的调用次数，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Long&amp;gt; userIds = articleDoPage.getRecords().stream().map(article -&amp;gt; article.getUserId()).collect(Collectors.toList());&lt;br/&gt;Map&amp;lt;Long, String&amp;gt; nickNameMap = userManager.queryByIds(userIds).stream().collect(Collectors.toMap(UserResponse::getId, UserResponse::getNickname));&lt;br/&gt;List&amp;lt;ArticleBO&amp;gt; articleBos = articleDoPage.getRecords().stream().map(r -&amp;gt; {&lt;br/&gt;    String nickname = nickNameMap.containsKey(r.getUserId()) ? nickNameMap.get(r.getUserId()) : CommonConstant.DEFAULT_EMPTY_STR;&lt;br/&gt;    return articleBoConvert.convertPlus(r, nickname);&lt;br/&gt;}).collect(Collectors.toList());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但批量查询还是同步模式，下面介绍如果使用 CompletableFuture 来实现异步并发调用，直接用原生的 CompletableFuture 也可以，但是编排能力没有那么强，这里我们选择一款基于 CompletableFuture 封装的并行编排框来实现，详细介绍查看我之前的这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650321192&amp;amp;idx=1&amp;amp;sn=8ea8cf7c4a3402bd42e74c7dbef1d5b5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/3EE8ccydK16gC1oY4AWnoA&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微做了下封装，提供了更方便使用的工具类来实现并发调用多个接口的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式，适用于比如从 ES 查出了一批 ID, 然后根据 ID 去数据库中或者调用 RPC 查询真实数据，最后得到一个 Map，可以根据 Key 获取对应的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部是多线程并发调用，会等到结果全部返回。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public Object aggregationApi() {&lt;br/&gt;    long s = System.currentTimeMillis();&lt;br/&gt;    List&amp;lt;String&amp;gt; ids = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    ids.add(&quot;1&quot;);&lt;br/&gt;    ids.add(&quot;2&quot;);&lt;br/&gt;    ids.add(&quot;3&quot;);&lt;br/&gt;    Map&amp;lt;String, UserResponse&amp;gt; callResult = AsyncTemplate.call(ids, id -&amp;gt; {&lt;br/&gt;        return userService.getUser(id);&lt;br/&gt;    }, u -&amp;gt; u.getId(), COMMON_POOL);&lt;br/&gt;    long e = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&quot;耗时：&quot; + (e-s) + &quot;ms&quot;);&lt;br/&gt;    return &quot;&quot;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个场景就是 API 聚合的场景，需要并行调用多个接口，将结果进行组装。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;AsyncCall&amp;gt; params = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;AsyncCall&amp;lt;Integer, Integer&amp;gt; goodsQuery = new AsyncCall(&quot;goodsQuery&quot;, 1);&lt;br/&gt;params.add(goodsQuery);&lt;/code&gt;&lt;code&gt;AsyncCall&amp;lt;String, OrderResponse&amp;gt; orderQuery = new AsyncCall(&quot;orderQuery&quot;, &quot;100&quot;);&lt;br/&gt;params.add(orderQuery);&lt;/code&gt;&lt;code&gt;UserQuery q = new UserQuery();&lt;br/&gt;q.setAge(18);&lt;br/&gt;q.setName(&quot;yinjihuan&quot;);&lt;br/&gt;AsyncCall&amp;lt;UserQuery, UserResponse&amp;gt; userQuery = new AsyncCall(&quot;userQuery&quot;, q);&lt;br/&gt;params.add(userQuery);&lt;/code&gt;&lt;code&gt;AsyncTemplate.call(params, p -&amp;gt; {&lt;br/&gt;    if (p.getTaskId().equals(&quot;goodsQuery&quot;)) {&lt;br/&gt;        AsyncCall&amp;lt;Integer, Integer&amp;gt; query = p;&lt;br/&gt;        return goodsService.getGoodsName(query.getParam());&lt;br/&gt;    }&lt;br/&gt;    if (p.getTaskId().equals(&quot;orderQuery&quot;)) {&lt;br/&gt;        AsyncCall&amp;lt;String, OrderResponse&amp;gt; query = p;&lt;br/&gt;        return orderService.getOrder(query.getParam());&lt;br/&gt;    }&lt;br/&gt;    if (p.getTaskId().equals(&quot;userQuery&quot;)) {&lt;br/&gt;        AsyncCall&amp;lt;UserQuery, UserResponse&amp;gt; query = p;&lt;br/&gt;        return userService.getUser(query.getParam());&lt;br/&gt;    }&lt;br/&gt;    return null;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AsyncCall 中定义参数和响应的类型，响应结果会在执行完后会自动设置到 AsyncCall 中。在 call 方法中需要根据 taskId 去做对应的处理逻辑，不同的 taskId 调用的接口不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码参考：https://github.com/yinjihuan/kitty&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号 &lt;strong&gt;猿天地&lt;/strong&gt; 发起人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有收获，不要吝啬你的转发和在看。&lt;/strong&gt;&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>36162b5c83a5985edd1279f7d086b428</guid>
<title>Spring：我是如何解决循环依赖的？</title>
<link>https://toutiao.io/k/ib9ck31</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它&lt;br/&gt;&lt;/span&gt;&lt;span&gt;1.由同事抛的一个问题开始&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近项目组的一个同事遇到了一个问题，问我的意见，一下子引起的我的兴趣，因为这个问题我也是第一次遇到。平时自认为对spring循环依赖问题还是比较了解的，直到遇到这个和后面的几个问题后，重新刷新了我的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看看当时出问题的代码片段：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两段代码中定义了两个Service类：&lt;code&gt;TestService1&lt;/code&gt;和&lt;code&gt;TestService2&lt;/code&gt;，在TestService1中注入了TestService2的实例，同时在TestService2中注入了TestService1的实例，这里构成了&lt;code&gt;循环依赖&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只不过，这不是普通的循环依赖，因为TestService1的test1方法上加了一个&lt;code&gt;@Async&lt;/code&gt;注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家猜猜程序启动后运行结果会怎样？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt;: Bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt; has been injected into other beans [testService2] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans &lt;span&gt;do&lt;/span&gt; not use the &lt;span&gt;final&lt;/span&gt; version of the bean. This is often the result of over-eager type matching - consider using &lt;span&gt;&#x27;getBeanNamesOfType&#x27;&lt;/span&gt; with the &lt;span&gt;&#x27;allowEagerInit&#x27;&lt;/span&gt; flag turned off, &lt;span&gt;for&lt;/span&gt; example.&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;报错了。。。原因是出现了循环依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「不科学呀，spring不是号称能解决循环依赖问题吗，怎么还会出现？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把上面的代码稍微调整一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把TestService1的test1方法上的&lt;code&gt;@Async&lt;/code&gt;注解去掉，&lt;code&gt;TestService1&lt;/code&gt;和&lt;code&gt;TestService2&lt;/code&gt;都需要注入对方的实例，同样构成了循环依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是重新启动项目，发现它能够正常运行。这又是为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这两个问题，让我们一起开始spring循环依赖的探秘之旅。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.什么是循环依赖？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环依赖：说白是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成了构成一个环形调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种情况：自己依赖自己的直接依赖&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8129496402877698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdab1MiacqG8bWAgwVmgR2TxRdfGQ9rXpjebRPQMYp6TWpcCP2JSnYajnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;278&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种情况：两个对象之间的直接依赖&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7660377358490567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdavaxrhQ63SHniaq8GRh4fUiblCiacKWUbWMszd9lCozZboxasMpib4NbxzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三种情况：多个对象之间的间接依赖&lt;img data-ratio=&quot;0.7452830188679245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdalIzucywZiaD9H5zicryDoywZevxJxGA0JvsrwY7tFhF7HA1En7Y0CgWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面两种情况的直接循环依赖比较直观，非常好识别，但是第三种间接循环依赖的情况有时候因为业务代码调用层级很深，不容易识别出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.循环依赖的N种场景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring中出现循环依赖主要有以下场景：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4099462365591398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaPIJyvkk8b7l74lEUVB6b1TkffX2Jve9doJia61IXhY4yOfMxibXOic0AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1488&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单例的setter注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方式应该是spring用的最多的，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个经典的循环依赖，但是它能正常运行，得益于spring的内部机制，让我们根本无法感知它有问题，因为spring默默帮我们解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring内部有三级缓存：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;earlySingletonObjects 二级缓存，用于保存实例化完成的bean实例&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;singletonFactories 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图告诉你，spring是如何解决循环依赖的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42983565107458915&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdamsWdZQX6cI6JQPa3P7icoepibDXoFEhC71juibDArKblEMcoBTRLRPMCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/p&gt;                           图1&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的朋友可能会发现在这种场景中第二级缓存作用不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，为什么要用第二级缓存呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一下，如果出现以下这种情况，我们要如何处理？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService3 testService3;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TestService1依赖于TestService2和TestService3，而TestService2依赖于TestService1，同时TestService3也依赖于TestService1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上图的流程可以把TestService1注入到TestService2，并且TestService1的实例是从第三级缓存中获取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设不用第二级缓存，TestService1注入到TestService3的流程如图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8112745098039216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaiagr5yOmaJYnNrSrg3IIshKHsX7ftEplChSfcY1CJGYcaaHCJXVCQnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;                         图2&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TestService1注入到TestService3又需要从第三级缓存中获取实例，而第三级缓存里保存的并非真正的实例对象，而是&lt;code&gt;ObjectFactory&lt;/code&gt;对象。说白了，两次从三级缓存中获取都是&lt;code&gt;ObjectFactory&lt;/code&gt;对象，而通过它创建的实例对象每次可能都不一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样不是有问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，spring引入的第二级缓存。上面图1其实TestService1对象的实例已经被添加到第二级缓存中了，而在TestService1注入到TestService3时，只用从第二级缓存中获取该对象即可。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8606965174129353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdadMXFsagwicrE2kkH8jsyADzPWI2uzZckTlfWYKwOdC0EgDHC5ZENib4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;                         图3&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个问题，第三级缓存中为什么要添加&lt;code&gt;ObjectFactory&lt;/code&gt;对象，直接保存实例对象不行吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：不行，因为假如你想对添加到三级缓存中的实例对象进行增强，直接用实例对象是行不通的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种场景spring是怎么做的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案就在&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;类&lt;code&gt;doCreateBean&lt;/code&gt;方法的这段代码中：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20678513731825526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaT8TrEslDkSfIQcjSZKUFeeRBdz9OtNOzBNpfdK6YLZNlWuvoF0KaFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;它定义了一个匿名内部类，通过&lt;code&gt;getEarlyBeanReference&lt;/code&gt;方法获取代理对象，其实底层是通过&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;类的&lt;code&gt;getEarlyBeanReference&lt;/code&gt;生成代理对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多例的setter注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方法偶然会有，特别是在多线程的场景下，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Scope&lt;/span&gt;(ConfigurableBeanFactory.SCOPE_PROTOTYPE)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Scope&lt;/span&gt;(ConfigurableBeanFactory.SCOPE_PROTOTYPE)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人说这种情况spring容器启动会报错，其实是不对的，我非常负责任的告诉你程序能够正常启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在&lt;code&gt;AbstractApplicationContext&lt;/code&gt;类的&lt;code&gt;refresh&lt;/code&gt;方法中告诉了我们答案，它会调用&lt;code&gt;finishBeanFactoryInitialization&lt;/code&gt;方法，该方法的作用是为了spring容器启动的时候提前初始化一些bean。该方法的内部又调用了&lt;code&gt;preInstantiateSingletons&lt;/code&gt;方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2989949748743719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaTQBCg36QQXBibaO7X3kXKibCO9QOe28icI89qnyc0Szqp2PnIs5WC4y7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1592&quot;/&gt;标红的地方明显能够看出：非抽象、单例 并且非懒加载的类才能被提前初始bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而多例即&lt;code&gt;SCOPE_PROTOTYPE&lt;/code&gt;类型的类，非单例，不会被提前初始化bean，所以程序能够正常启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何让他提前初始化bean呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要再定义一个单例的类，在它里面注入TestService1&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动程序，执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Requested bean is currently in creation: Is there an unresolvable circular reference?&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然出现了循环依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：这种循环依赖问题是无法解决的，因为它没有用缓存，每次都会生成一个新对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构造器注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方式现在其实用的已经非常少了，但是我们还是有必要了解一下，看看如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt;&lt;span&gt;(TestService2 testService2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt;&lt;span&gt;(TestService1 testService1)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Requested bean is currently in creation: Is there an unresolvable circular reference?&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现了循环依赖，为什么呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.503125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdat0en0PHBL6WAqHKrbxU38nxZuZCDWxVTE9iazcKYA49FTseCYIlDxbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中的流程看出构造器注入没能添加到三级缓存，也没有使用缓存，所以也无法解决循环依赖问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单例的代理对象setter注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方式其实也比较常用，比如平时使用：&lt;code&gt;@Async&lt;/code&gt;注解的场景，会通过&lt;code&gt;AOP&lt;/code&gt;自动生成代理对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我那位同事的问题也是这种情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面得知程序启动会报错，出现了循环依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt;: Bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt; has been injected into other beans [testService2] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans &lt;span&gt;do&lt;/span&gt; not use the &lt;span&gt;final&lt;/span&gt; version of the bean. This is often the result of over-eager type matching - consider using &lt;span&gt;&#x27;getBeanNamesOfType&#x27;&lt;/span&gt; with the &lt;span&gt;&#x27;allowEagerInit&#x27;&lt;/span&gt; flag turned off, &lt;span&gt;for&lt;/span&gt; example.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么会循环依赖呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案就在下面这张图中：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4796437659033079&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFGL7IIEBJVKfAH6rmxY4x2fpBia7zqapW1Q8ZF601661Iq2NIwHYjrRv64TGnuQZy8yF3hB08RLMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1572&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，bean初始化完成之后，后面还有一步去检查：第二级缓存 和 原始对象 是否相等。由于它对前面流程来说无关紧要，所以前面的流程图中省略了，但是在这里是关键点，我们重点说说：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5504694835680751&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaljic3Aany2iagBQWRRkozUhz33XoJ7WrOyhQgdcqjcHEefic9Wcjne6FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1704&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那位同事的问题&lt;/span&gt;正好是走到这段代码，发现第二级缓存 和 原始对象不相等，所以抛出了循环依赖的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这时候把TestService1改个名字，改成：&lt;span&gt;TestService6，其他的都不变。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService6&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再重新启动一下程序，神奇般的好了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;what？ 这又是为什么？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就要从spring的bean加载顺序说起了，默认情况下，spring是按照文件完整路径递归查找的，按路径+文件名排序，排在前面的先加载。所以TestService1比&lt;span&gt;TestService2先加载，而改了文件名称之后，&lt;span&gt;TestService2比&lt;span&gt;TestService6先加载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么&lt;span&gt;TestService2比TestService6先加载就没问题呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在下面这张图中：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42710997442455245&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFGL7IIEBJVKfAH6rmxY4x2rJRtXBATowdxrBjNMWjQjoSicB8J62b4YmjvR0ySmB4TGCDUicdwjbFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种情况testService6中其实第二级缓存是空的，不需要跟原始对象判断，所以不会抛出循环依赖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DependsOn循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种有些特殊的场景，比如我们需要在实例化Bean A之前，先实例化Bean B，这个时候就可以使用&lt;code&gt;@DependsOn&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@DependsOn&lt;/span&gt;(value = &lt;span&gt;&quot;testService2&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@DependsOn&lt;/span&gt;(value = &lt;span&gt;&quot;testService1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序启动之后，执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Circular depends-on relationship between &lt;span&gt;&#x27;testService2&#x27;&lt;/span&gt; and &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中本来如果TestService1和TestService2都没有加&lt;code&gt;@DependsOn&lt;/code&gt;注解是没问题的，反而加了这个注解会出现循环依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这又是为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在&lt;code&gt;AbstractBeanFactory&lt;/code&gt;类的&lt;code&gt;doGetBean&lt;/code&gt;方法的这段代码中：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4193121693121693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdatjJjSxMkoh2RyVA8KFJRiaedv4hibjoicKmfySdiaEs74dApoBib7T4CdfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot;/&gt;它会检查dependsOn的实例有没有循环依赖，如果有循环依赖则抛异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.出现循环依赖如何解决？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目中如果出现循环依赖问题，说明是spring默认无法解决的循环依赖，要看项目的打印日志，属于哪种循环依赖。目前包含下面几种情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3230994152046784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdasczlqnRGRlE3q0wZzZTe2OYezTV26IMTJK8W7ddViceaKLLjMM0V98A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生成代理对象产生的循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题解决方法很多，主要有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;@Lazy&lt;/code&gt;注解，延迟加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;@DependsOn&lt;/code&gt;注解，指定加载先后关系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改文件名称，改变循环依赖类的加载顺序&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用@DependsOn产生的循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题要找到&lt;code&gt;@DependsOn&lt;/code&gt;注解循环依赖的地方，迫使它不循环依赖就可以解决问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多例循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题可以通过把bean改成单例的解决。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构造器循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题可以通过使用&lt;code&gt;@Lazy&lt;/code&gt;注解解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1b354f85026b15c9ac770f94d4c22458</guid>
<title>深入浅出 ZooKeeper</title>
<link>https://toutiao.io/k/8555w9e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 是一个分布式协调服务 ，由 Apache 进行维护。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 可以视为一个高可用的文件系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 可以用于发布/订阅、负载均衡、命令服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能 。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、ZooKeeper 简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 ZooKeeper 是什么&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 是 Apache 的顶级项目。&lt;strong&gt;ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。在解决分布式数据一致性方面，ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储。但是 ZooKeeper 并不是用来专门存储数据的，它的作用主要是用来&lt;strong&gt;维护和监控存储数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多大名鼎鼎的框架都基于 ZooKeeper 来实现分布式高可用，如：Dubbo、Kafka 等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 ZooKeeper 的特性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 具有以下特性：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;顺序一致性：&lt;/strong&gt;所有客户端看到的服务端数据模型都是一致的；从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 ZooKeeper 中。具体的实现可见下文：原子广播。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;原子性：&lt;/strong&gt;所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。实现方式可见下文：事务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;单一视图：&lt;/strong&gt;无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;高性能：&lt;/strong&gt;ZooKeeper 将数据全量存储在内存中，所以其性能很高。需要注意的是：由于 ZooKeeper 的所有更新和删除都是基于事务的，因此 ZooKeeper 在读多写少的应用场景中有性能表现较好，如果写操作频繁，性能会大大下滑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;高可用：&lt;/strong&gt;ZooKeeper 的高可用是基于副本机制实现的，此外 ZooKeeper 支持故障恢复，可见下文：选举 Leader。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 ZooKeeper 的设计目标&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、ZooKeeper 核心概念&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1  数据模型&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 的数据模型是一个树形结构的文件系统。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;树中的节点被称为 znode，其中根节点为 /，每个节点上都会保存自己的数据和节点信息。znode 可以用于存储数据，并且有一个与之相关联的 ACL（详情可见 ACL）。ZooKeeper 的设计目标是实现协调服务，而不是真的作为一个文件存储，因此 znode 存储数据的&lt;strong&gt;大小被限制在 1MB 以内。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1yzmxHa5ibd27YdR8OtnMcibcZHMzPKyoNYL2nRv6SstlZWrYF5M5bzaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 的数据访问具有原子性。&lt;/strong&gt;其读写操作都是要么全部成功，要么全部失败。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;znode 通过路径被引用。&lt;strong&gt;znode 节点路径必须是绝对路径。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;znode 有两种类型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2  节点信息&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;znode 上有一个&lt;strong&gt;顺序标志（ SEQUENTIAL ）&lt;/strong&gt;。如果在创建 znode 时，设置了&lt;strong&gt;顺序标志（ SEQUENTIAL ）&lt;/strong&gt;，那么 ZooKeeper 会使用计数器为 znode 添加一个单调递增的数值，即 zxid。ZooKeeper 正是利用 zxid 实现了严格的顺序访问控制能力。&lt;/p&gt;&lt;p&gt;每个 znode 节点在存储数据的同时，都会维护一个叫做 Stat 的数据结构，里面存储了关于该节点的全部状态信息。如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8061224489795918&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1wOtlOHSMVDFlOItYbYJyUNSwHnI3q7ibpf9rwrSBLdI7jgueCMiavlEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;588&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 集群角色&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Leader：&lt;/strong&gt;它负责 发起并维护与各 Follwer 及 Observer 间的心跳。所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Follower：&lt;/strong&gt;它会响应 Leader 的心跳。Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，并且负责在 Leader 处理写请求时对请求进行投票。一个 Zookeeper 集群可能同时存在多个 Follower。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Observer：&lt;/strong&gt;角色与 Follower 类似，但是无投票权。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.4 ACL&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 采用 ACL（Access Control Lists）策略来进行权限控制。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;每个 znode 创建时都会带有一个 ACL 列表，用于决定谁可以对它执行何种操作。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ACL 依赖于 ZooKeeper 的客户端认证机制。ZooKeeper 提供了以下几种认证方式：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;digest：&lt;/strong&gt; 用户名和密码 来识别客户端&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;sasl：&lt;/strong&gt;通过 kerberos 来识别客户端&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ip：&lt;/strong&gt;通过 IP 来识别客户端&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 定义了如下五种权限：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;CREATE：&lt;/strong&gt;允许创建子节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;READ：&lt;/strong&gt;允许从节点获取数据并列出其子节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;WRITE：&lt;/strong&gt; 允许为节点设置数据；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;DELETE：&lt;/strong&gt;允许删除子节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ADMIN：&lt;/strong&gt; 允许为节点设置权限。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、ZooKeeper 工作原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 读操作&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Leader/Follower/Observer 都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由于处理读请求不需要服务器之间的交互，&lt;strong&gt;Follower/Observer 越多，整体系统的读请求吞吐量越大&lt;/strong&gt;，也即读性能越好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.56484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1dhXnDydcAstc0A3pZ3f2oGpK5eNDolHVCwFEN47puwqzC5r0GoKiaNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 写操作&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;所有的写请求实际上都要交给 Leader 处理。Leader 将写请求以事务形式发给所有 Follower 并等待 ACK，一旦收到半数以上 Follower 的 ACK，即认为写操作成功。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 写 Leader&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7254138266796495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1tib4Vgvdz1YeqsNCmkV8cdMASqdQN1qACrC6gOq8UNRfKT31Dbf6ibBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1027&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由上图可见，通过 Leader 进行写操作，主要分为五步：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端向 Leader 发起写请求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 将写请求以事务 Proposal 的形式发给所有 Follower 并等待 ACK。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower 收到 Leader 的事务 Proposal 后返回 ACK。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 得到过半数的 ACK（Leader 对自己默认有一个 ACK）后向所有的 Follower 和 Observer 发送 Commmit。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 将处理结果返回给客户端。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader 不需要得到 Observer 的 ACK，即 Observer 无投票权。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 不需要得到所有 Follower 的 ACK，只要收到过半的 ACK 即可，同时 Leader 本身对自己有一个 ACK。上图中有 4 个 Follower，只需其中两个返回 ACK 即可，因为 $$(2+1) / (4+1) &amp;gt; 1/2$$ 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Observer 虽然无投票权，但仍须同步 Leader 的数据从而在处理读请求时可以返回尽可能新的数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 写 Follower/Observer&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.56484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1tHib7tFoGrCHszkPhbSaIkufRP1yHLZ6eKod1ppDictibjDqPhag9AO2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Follower/Observer 均可接受写请求，但不能直接处理，而需要将写请求转发给 Leader 处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了多了一步请求转发，其它流程与直接写 Leader 无任何区别。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 事务&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于来自客户端的每个更新请求，ZooKeeper 具备严格的顺序访问控制能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 id 号（zxid）来标识事务。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Leader 服务会为每一个 Follower 服务器分配一个单独的队列，然后将事务 Proposal 依次放入队列中，并根据 FIFO(先进先出) 的策略进行消息发送。&lt;/strong&gt;Follower 服务在接收到 Proposal 后，会将其以事务日志的形式写入本地磁盘中，并在写入成功后反馈给 Leader 一个 Ack 响应。&lt;strong&gt;当 Leader 接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 以通知其进行事务提交，&lt;/strong&gt;之后 Leader 自身也会完成对事务的提交。而每一个 Follower 则在接收到 Commit 消息后，完成事务的提交。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所有的提议（proposal）都在被提出的时候加上了 zxid。zxid 是一个 64 位的数字，它的高 32 位是 epoch 用来标识 Leader 关系是否改变，每次一个 Leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;详细过程如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader 等待 Server 连接；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower 连接 Leader，将最大的 zxid 发送给 Leader；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 根据 Follower 的 zxid 确定同步点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;完成同步后通知 follower 已经成为 uptodate 状态；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4 观察&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;客户端注册监听它关心的 znode，当 znode 状态发生变化（数据变化、子节点增减变化）时，ZooKeeper 服务会通知客户端。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端和服务端保持连接一般有两种形式：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 的选择是服务端主动推送状态，也就是观察机制（ Watch ）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 的观察机制允许用户在指定节点上针对感兴趣的事件注册监听，当事件发生时，监听器会被触发，并将事件信息推送到客户端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端使用 getData 等接口获取 znode 状态时传入了一个用于处理节点变更的回调，那么服务端就会主动向客户端推送节点的变更：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从这个方法中传入的 Watcher 对象实现了相应的 process 方法，每次对应节点出现了状态的改变，WatchManager 都会通过以下的方式调用传入 Watcher 的方法：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Set&lt;/span&gt;&amp;lt;Watcher&amp;gt; triggerWatch(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; path, EventType type, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Set&lt;/span&gt;&amp;lt;Watcher&amp;gt; supress) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    WatchedEvent e = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WatchedEvent(type, KeeperState.SyncConnected, path);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Set&lt;/span&gt;&amp;lt;Watcher&amp;gt; watchers;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    synchronized (&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        watchers = watchTable.remove(path);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Watcher w : watchers) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        w.process(e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 中的所有数据其实都是由一个名为 DataTree 的数据结构管理的，所有的读写数据的请求最终都会改变这颗树的内容，在发出读请求时可能会传入 Watcher 注册一个回调函数，而写请求就可能会触发相应的回调，由 WatchManager 通知客户端数据的变化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通知机制的实现其实还是比较简单的，通过读请求设置 Watcher 监听事件，写请求在触发事件时就能将通知发送给指定的客户端。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 会话&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 客户端通过 TCP 长连接连接到 ZooKeeper 服务集群。会话 (Session) 从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态&lt;/strong&gt;。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watch 事件的通知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个 ZooKeeper 客户端配置中都配置了 ZooKeeper 服务器集群列表。启动时，客户端会遍历列表去尝试建立连接。如果失败，它会尝试连接下一个服务器，依次类推。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一旦一台客户端与一台服务器建立连接，这台服务器会为这个客户端创建一个新的会话。&lt;strong&gt;每个会话都会有一个超时时间，若服务器在超时时间内没有收到任何请求，则相应会话被视为过期。&lt;/strong&gt;一旦会话过期，就无法再重新打开，且任何与该会话相关的临时 znode 都会被删除。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常来说，会话应该长期存在，而这需要由客户端来保证。客户端可以通过心跳方式（ping）来保持会话不过期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1909975669099757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1S7ZgGlaI90serCplVsbpaGxx2bFvrFoqtSJgay9FHF1iapbk5WjzFdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 的会话具有四个属性：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;sessionID：&lt;/strong&gt;会话 ID，唯一标识一个会话，每次客户端创建新的会话时，Zookeeper 都会为其分配一个全局唯一的 sessionID。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;TimeOut：&lt;/strong&gt;会话超时时间，客户端在构造 Zookeeper 实例时，会配置 sessionTimeout 参数用于指定会话的超时时间，Zookeeper 客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;TickTime：&lt;/strong&gt;下次会话超时时间点，为了便于 Zookeeper 对会话实行”分桶策略”管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper 会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上 TimeOut。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;isClosing：&lt;/strong&gt;标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的 isClosing 标记为”已关闭”，这样就能确保不再处理来自该会话的新请求了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 的会话管理主要是通过 SessionTracker 来负责，其采用了&lt;strong&gt;分桶策略&lt;/strong&gt;（将类似的会话放在同一区块中进行管理）进行管理，以便 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、ZAB 协议&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议。ZAB 协议不是 Paxos 算法，只是比较类似，二者在操作上并不相同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZAB 协议是 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZAB 协议是 ZooKeeper 的数据一致性和高可用解决方案。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZAB 协议定义了两个可以&lt;strong&gt;无限循环&lt;/strong&gt;的流程：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 选举 Leader&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 的故障恢复&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 集群采用一主（称为 Leader）多从（称为 Follower）模式，主从节点通过副本机制保证数据一致。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZAB 协议的选举 Leader 机制简单来说，就是：基于过半选举机制产生新的 Leader，之后其他机器将从新的 Leader 上同步状态，当有过半机器完成状态同步后，就退出选举 Leader 模式，进入原子广播模式。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.1 术语&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;myid：&lt;/strong&gt;每个 Zookeeper 服务器，都需要在数据文件夹下创建一个名为 myid 的文件，该文件包含整个 Zookeeper 集群唯一的 ID（整数）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;zxid：&lt;/strong&gt;类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal ID。为了保证顺序性，该 zkid 必须单调递增。因此 Zookeeper 使用一个 64 位的数来表示，高 32 位是 Leader 的 epoch，从 1 开始，每次选出新的 Leader，epoch 加一。低 32 位为该 epoch 内的序号，每次 epoch 变化，都将低 32 位的序号重置。这样保证了 zkid 的全局递增性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.2 服务器状态&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;LOOKING：&lt;/strong&gt;不确定 Leader 状态。该状态下的服务器认为当前集群中没有 Leader，会发起 Leader 选举。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;FOLLOWING：&lt;/strong&gt;跟随者状态。表明当前服务器角色是 Follower，并且它知道 Leader 是谁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;LEADING：&lt;/strong&gt;领导者状态。表明当前服务器角色是 Leader，它会维护与 Follower 间的心跳。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;OBSERVING：&lt;/strong&gt;观察者状态。表明当前服务器角色是 Observer，与 Folower 唯一的不同在于不参与选举，也不参与集群写操作时的投票。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.3 选票数据结构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;每个服务器在进行领导选举时，会发送如下关键信息：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;logicClock：&lt;/strong&gt;每个服务器会维护一个自增的整数，名为 logicClock，它表示这是该服务器发起的第多少轮投票。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;state：&lt;/strong&gt;当前服务器的状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;self_id：&lt;/strong&gt;当前服务器的 myid。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;self_zxid：&lt;/strong&gt;当前服务器上所保存的数据的最大 zxid。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;vote_id：&lt;/strong&gt;被推举的服务器的 myid。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;vote_zxid：&lt;/strong&gt;被推举的服务器上所保存的数据的最大 zxid。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.4 投票流程&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）自增选举轮次&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Zookeeper 规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的 logicClock 进行自增操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）初始化选票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器 2 投票给服务器 3，服务器 3 投票给服务器 1，则服务器 1 的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）发送初始化选票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每个服务器最开始都是通过广播把票投给自己。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（4）接收外部投票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（5）判断选举轮次&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到外部投票后，首先会根据投票信息中所包含的 logicClock 来进行不同处理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;外部投票的 logicClock &lt;strong&gt;大于&lt;/strong&gt;自己的 logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的 logicClock 更新为收到的 logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外部投票的 logicClock &lt;strong&gt;小于&lt;/strong&gt;自己的 logicClock。当前服务器直接忽略该投票，继续处理下一个投票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外部投票的 logickClock 与自己的&lt;strong&gt;相等&lt;/strong&gt;。当时进行选票 PK。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（6）选票 PK&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;选票 PK 是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;外部投票的 logicClock &lt;strong&gt;大于&lt;/strong&gt;自己的 logicClock，则将自己的 logicClock 及自己的选票的 logicClock 变更为收到的 logicClock。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若&lt;strong&gt; logicClock&lt;/strong&gt; &lt;strong&gt;一致&lt;/strong&gt;，则对比二者的 vote_zxid，若外部投票的 vote_zxid 比较大，则将自己的票中的 vote_zxid 与 vote_myid 更新为收到的票中的 vote_zxid 与 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若二者 &lt;strong&gt;vote_zxid &lt;/strong&gt;一致，则比较二者的 vote_myid，若外部投票的 vote_myid 比较大，则将自己的票中的 vote_myid 更新为收到的票中的 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（7）统计选票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（8）更新服务器状态&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为 LEADING，否则将自己的状态更新为 FOLLOWING。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过以上流程分析，我们不难看出：要使 Leader 获得多数 Server 的支持，则 &lt;strong&gt;ZooKeeper 集群节点数必须是奇数。且存活的节点数目不得少于 N + 1 &lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 原子广播（Atomic Broadcast）&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 通过副本机制来实现高可用。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么，ZooKeeper 是如何实现副本机制的呢？答案是：ZAB 协议的原子广播。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.56484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1dhXnDydcAstc0A3pZ3f2oGpK5eNDolHVCwFEN47puwqzC5r0GoKiaNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZAB 协议的原子广播要求：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;所有的写请求都会被转发给 Leader，Leader 会以原子广播的方式通知 Follow。当半数以上的 Follow 已经更新状态持久化后，Leader 才会提交这个更新，然后客户端才会收到一个更新成功的响应。&lt;/strong&gt;这有些类似数据库中的两阶段提交协议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在整个消息的广播过程中，Leader 服务器会每个事物请求生成对应的 Proposal，并为其分配一个全局唯一的递增的事务 ID(ZXID)，之后再对其进行广播。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、ZooKeeper 应用&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 可以用于发布/订阅、负载均衡、命令服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能 。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.1 命名服务&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在分布式系统中，通常需要一个全局唯一的名字，如生成全局唯一的订单号等，ZooKeeper 可以通过顺序节点的特性来生成全局唯一 ID，从而可以对分布式系统提供命名服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2413793103448276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1bwosa3gkiaz0rlKO7RP4LSdEXfs3aHx2kX3XQMvZASeql67ytic5GnvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.2 配置管理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;利用 ZooKeeper 的观察机制，可以将其作为一个高可用的配置存储器，允许分布式应用的参与者检索和更新配置文件。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.3 分布式锁&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以通过 ZooKeeper 的临时节点和 Watcher 机制来实现分布式锁。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举例来说，有一个分布式系统，有三个节点 A、B、C，试图通过 ZooKeeper 获取分布式锁。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）访问 /lock （这个目录路径由程序自己决定），创建 &lt;strong&gt;带序列号的临时节点（EPHEMERAL） 。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9362606232294618&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1Ms2gbZLs19ThRZXgngZPGrHMoGZ816icf3a8jNCia0MolMZtO08xusibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（2）每个节点尝试获取锁时，拿到 /locks节点下的所有子节点（id_0000,id_0001,id_0002），&lt;strong&gt;判断自己创建的节点是不是最小的。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果是，则拿到锁。&lt;/p&gt;&lt;p&gt;释放锁：执行完操作后，把创建的节点给删掉。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果不是，则监听比自己要小 1 的节点变化。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9514705882352941&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1q0ibnRQsb9ToAZKQkicuBSIK26kRPe3ETvQMibaccPQP3AEBcEoqnPPXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（3）释放锁，即删除自己创建的节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9741641337386018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY191iaCtYo2y5Eic2PYy1J8ic9OrfapicofMqPcZ9KLQKzAGo26FibekWIzUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图中，NodeA 删除自己创建的节点 id_0000，NodeB 监听到变化，发现自己的节点已经是最小节点，即可获取到锁。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.4 集群管理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 还能解决大多数分布式系统中的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.5 选举 Leader 节点&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;分布式系统一个重要的模式就是主从模式 (Master/Salves)，ZooKeeper 可以用于该模式下的 Matser 选举。可以让所有服务节点去竞争性地创建同一个 ZNode，由于 ZooKeeper 不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，这样该服务节点就可以成为 Master 节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;5.6 队列管理&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 可以处理两种类型的队列：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;同步队列用 ZooKeeper 实现的实现思路如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;官方&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;书籍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;文章&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d0af1fdf8cd33ab21da6e541786c22b0</guid>
<title>[译] LogDevice 与 Apache Pulsar 之间的对比</title>
<link>https://toutiao.io/k/6nlmc5w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;blockquote&gt;&lt;p&gt;本文为《Comparing LogDevice and Apache Pulsar》中文翻译版本。 &lt;br/&gt;原文链接: https://www.splunk.com/en_us/blog/it/comparing-logdevice-and-apache-pulsar.html &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;阅读本文需要大约 8 分钟。&lt;/p&gt;&lt;p&gt;Facebook 已经发布开源 &lt;span&gt;LogDevice&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;。考虑到 LogDevice 目标用例之间的相似性，自然会有人问到 LogDevice 与 Apache Pulsar 之间是否也有相似之处。本文将对这一问题进行解答。对比 LogDevice 和 Pulsar 并不简单，LogDevice 的操作级别要比 Pulsar 低。LogDevice 与 Twitter 的 DistributedLog 更相似。二者都只关注日志原语，而不关注 schema 管理、多租户、光标管理等高级功能。这些高级功能将留给用户基于 LogDevice 去实现。本文将讨论 LogDevice 和 Pulsar 中都有的基本元素：分布式日志。&lt;/p&gt;&lt;h1&gt;架构&lt;/h1&gt;&lt;p&gt;LogDevice 向用户显示一个日志原语。写入客户端将 entry 写入 sequencer 节点。该节点将日志序列号（LSN）分配给所有 entry，然后将 entry 写入已经分配给日志的较大节点集的一个子集（副本集）。LogDevice 的 sequencer 类似于 Pulsar 中的 broker，在 Pulsar 中，由 broker 分配消息 ID 并发送消息到 Apache BookKeeper 进行存储。&lt;/p&gt;&lt;p&gt;LogDevice 和 Pulsar 在架构方面有许多相同之处，比如它们都将计算与存储分离。与单片架构相比，这种架构具有以下优势：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;单个日志可以无限增长&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;出现节点故障时，可以进行无缝恢复&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;集群扩展简单&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;读写具有独立可扩展性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比较 Pulsar 和 Kafka：基于分片的架构如何提升整体性能、延展性与弹性&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;一文中详细说明了这种架构的优势。Pulsar 和 LogDevice 都具备这些优势。&lt;/p&gt;&lt;p&gt;LogDevice 和 Pulsar 读取数据的方式有所不同。在 Pulsar 中，读客户端在 broker 上订阅 topic，并从 broker 上接收消息；而在 LogDevice 中，读客户端直接与存储节点相连。&lt;/p&gt;&lt;p&gt;像 LogDevice 这样直接从存储节点读取数据，允许读操作有更大程度的扇出。也就是说，由于读取器不需要访问同一节点，系统可以在单个 topic 上支持更多读取器。&lt;/p&gt;&lt;p&gt;但是，在需要保证日志的一致性时，直接从存储节点读取数据会加长延迟。如果写入器没有确认写入的 entry，读取器无法读取该 entry。从存储节点读取数据时，需要以某种方式通知存储节点 entry 已经被复制到足够多的节点上，并将 ack 发送到写入器，在此之前 entry 不可读。&lt;/p&gt;&lt;p&gt;在 Pulsar 中，客户端通过 broker 进行读写。这种读写方式在延迟和性能上都有优势。由于在同一个节点上进行读写，所以在将 entry ack 发送到写入器时，该 entry 立即可读。Pulsar 通过在 broker 上控制读写，得以支持更复杂的订阅模型，如&lt;span&gt;共享订阅、Failover 订阅&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;等。&lt;/p&gt;&lt;h1&gt;一致性、多副本、Failover&lt;/h1&gt;&lt;p&gt;LogDevice 和 Pulsar 采用相似的技术实现&lt;span&gt;全局顺序广播协议（TOAB）&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;。将日志分为不同 epoch，每个节点（leader）可以决定该 epoch 中 entry 的序列号，并且相应机制保证不会写入以前的 epoch。&lt;/p&gt;&lt;p&gt;LogDevice 和 Pulsar 都使用 ZooKeeper 决定 leader。&lt;/p&gt;&lt;p&gt;在 LogDevice 中，leader 也称作 sequencer。每个日志都有一个 sequencer，每个 sequencer 都被（从 ZookKeeper）分配了一个“epoch”号。LSN 由 epoch 和一个局部单调递增组件组成，sequencer 决定每个 entry 的 LSN，并将 epoch 中的 entry 转发到一组存储节点上。当足够多的存储节点 ack entry 时，sequencer 将 ack 发送到发起写请求的客户端。在 sequencer 出现故障时，就会有新的 sequencer 获取新的 epoch，并可以立即服务于写入操作。在后台启动一个“封闭”前一个 epoch 的操作，则会禁止从新 epoch 进行读取的操作，直到前一个 epoch 被封。“封闭”操作涉及从节点集向足够多的存储节点通知新 epoch 的存在，因此写入操作就不会有足够多的 ack 来向客户端 ack 写入操作。&lt;/p&gt;&lt;p&gt;对于 Pulsar 来说，epoch 就是 BookKeeper ledger。每个 topic 都有 BookKeeper ledger 列表，这些列表组成了 topic 的全部日志。当一个 Pulsar broker 崩溃时，另一个 broker 会接管这一 topic，由此保证封闭前一个 broker 中的 ledger，创建自己的 ledger，并将其添加至 topic 的 ledger 列表中。最后三个操作涉及到了 ZooKeeper。一旦更新了 topic 的 ledger 列表，broker 就可以开始为 topic 上的读写提供支持。所有向 topic 写入的数据在被 ack 并且对读取器可见之前都会持久化到 BookKeeper ledger 上，存储在一组存储节点中。&lt;/p&gt;&lt;p&gt;对于 LogDevice 和 Pulsar（采用 BookKeeper）来说，entry 持久化只需要一个 entry 命中一个节点子集，因此在有缓慢的或故障的存储节点时，可以保持低延迟的写入。&lt;/p&gt;&lt;p&gt;在检测到 leader 出现故障时，LogDevice 可以在发现故障后很快地提供写服务，只需要两次往返 ZooKeeper 来选择一个 sequencer。在 Pulsar 中，再次写入前，需要先恢复之前的 ledger，恢复操作包括与一些存储节点对话、向 ZooKeeper 进行新的写入等。另外，在 Pulsar 中，可以同时恢复读写，而在 LogDevice 中，读取之前，必须进行“封闭”操作，类似于 ledger 的恢复操作。&lt;/p&gt;&lt;p&gt;我们猜测 LogDevice 不允许在上一个 epoch “封闭”之前写入，因其读操作不协调，与性能无关。不管是否封闭前一个 epoch，检测到 sequencer 发生故障会占用恢复时间。允许写入前的封闭操作需要 sequencer 与读取器进行协调，这样收效甚微，但却会增加复杂性。在 Pulsar 中，由于是在 broker 上进行读取，在写入前恢复之前的 ledger 就很容易。&lt;/p&gt;&lt;h1&gt;存储&lt;/h1&gt;&lt;p&gt;LogDevice 存储节点将 entry 存储在 RocksDB 中。Entry 存储在按时间顺序排列的列族集合中，entry 由日志 ID 和 entry 的 LSN 组合进行键控。简单来说，每个存储节点都有许多按时间顺序排列的 RocksDB 实例，只向最新的 RocksDB 实例写入。这些 RocksDB 实例尽量确保只进行少量压缩，以避免写入放大。&lt;/p&gt;&lt;p&gt;Pulsar 存储节点（BookKeeper）上有一个日志、一个 entry 日志和一个索引。日志有专用磁盘。当向 bookie 写入 entry 时，其实是在向日志磁盘写入，并向写入器 ack。然后，将 entry 放入一个暂存区域，当此区域内有足够多的 entry 时，就通过 ledger ID 和 entry ID 进行存储，flush 到 entry 日志。此时，entry 日志中的每条 entry 都已写入索引，索引正是一个 RocksDB 实例。&lt;/p&gt;&lt;p&gt;在有许多并发活跃日志时，LogDevice 和 Pulsar 存储层都可以实现低延迟写入。将多个日志的 entry 交叉放在几个文件中，可以最小化随机写入。这样对旋转磁盘的影响较大，在旋转磁盘上写入多个文件意味着磁头必须物理移动多次，但即使在固态磁盘上，优先顺序写入比随机写入在性能上有更多优势。&lt;/p&gt;&lt;p&gt;但是，交错写入也意味着要进行更多读取。&lt;/p&gt;&lt;p&gt;日志系统中的读取通常分为两类，追尾读和追赶读。对于追尾读，LogDevice 和 Pulsar 都不太可能命中磁盘，因为所需数据在某种程度上仍然应该存储在内存缓存中；而追赶读最终都会命中磁盘。吞吐量通常比追赶读延迟更重要，LogDevice 和 Pulsar 的设计都与此相符。&lt;/p&gt;&lt;p&gt;虽然大多数读取应该是连续的，但是 LogDevice 需要读取许多 SST 文件来进行追赶读。因为 RocksDB 在将 entry flush 到磁盘前会按键排序。这样就会分不清楚是否在同一磁盘读写。如果是，追赶读可能会影响系统的写入性能。&lt;/p&gt;&lt;p&gt;RocksDB 允许配置多个路径，将旧 SST 文件与新 SST 文件分开存储。&lt;/p&gt;&lt;p&gt;由于 Pulsar 将写入的关键路径保存在单独的磁盘上，读取操作完全独立。读取通常也是有序的，因为 entry 日志中的数据在 flush 到磁盘前按照 ledger 和 entry ID 排序。&lt;/p&gt;&lt;p&gt;LogDevice 尽量避免压缩，因此会放大写入。这对于日志系统说得通，因为不需要读取写入的大部分数据，但会影响数据保留。不能删除单个日志，因此系统中所有日志的保存时间都必须由保留时间决定。集群内的所有日志都不能永久保存，有些甚至只能保存几个小时。&lt;/p&gt;&lt;p&gt;在 Pulsar 中，要从存储节点删除日志，就需要先从索引中删除。因此，索引会经常压缩，但是由于 entry 数据本身不在索引中，这也影响不大。存储节点监听索引引用每个 entry 日志的百分比。一旦一个 entry 日志低于某个阈值，则复制活跃数据到新的“压缩” entry 日志中，更新索引，并删除原 entry 日志。&lt;/p&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;LogDevice 是对分布式日志空间的有趣补充。Pulsar 不仅是分布式日志系统，更是一个完整的消息平台，因此不能将 LogDevice 直接与 Pulsar 进行比较，但很高兴看到 LogDevice 团队决定采用与 Pulsar 类似的架构。现在 LogDevice 已经开源，十分期待它的使用。&lt;/p&gt;&lt;h1&gt;相关阅读&lt;/h1&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247485681&amp;amp;idx=1&amp;amp;sn=f6caa8b891153844d4625e0a7cdc4e4d&amp;amp;chksm=f9c512c6ceb29bd0c78043e8642046eecb5c07898557b4541b5ab3c41cb6d98f652704da316e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; • 《Pulsar 与 Kafka 全方位对比（上篇）：功能、性能、用例》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt; • &lt;span&gt;《Pulsar 与 Kafka 全方位对比（上篇）：功能、性能、用例》&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; •&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247486093&amp;amp;idx=1&amp;amp;sn=4cf2d9eea653bff3d6d08593af9bf51a&amp;amp;chksm=f9c510baceb299acf77d82b3014961986ca5d915ce4f07fb47378880d790433496cd3060af7c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Pulsar 与 Kafka 全方位对比（下篇）：案例、特性、社区》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Pulsar 与 Kafka 全方位对比（下篇）：案例、特性、社区》&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; LogDevice: &lt;em&gt;https://code.fb.com/core-data/open-sourcing-logdevice-a-distributed-data-store-for-sequential-data/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 比较 Pulsar 和 Kafka：基于分片的架构如何提升整体性能、延展性与弹性: &lt;em&gt;https://www.splunk.com/en_us/blog/it/comparing-pulsar-and-kafka-how-a-segment-based-architecture-delivers-better-performance-scalability-and-resilience.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 共享订阅、Failover 订阅: &lt;em&gt;https://pulsar.apache.org/docs/en/concepts-messaging/#subscription-modes&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 全局顺序广播协议（TOAB）: &lt;em&gt;https://streaml.io/blog/bookkeeper-toab/&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2bdUbSuMLZHLSZPUWibqXUxUqA0ib1OQvXALw5s09XbOhbS81Tuicd6ubg12Ir0ZOXZZKcRySXXmicicsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;544&quot; data-backh=&quot;419&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;点击「阅读原文」进入 Pulsar 世界！&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>02704f09c2dfd4cceb98f7b244698104</guid>
<title>进程：程序是如何启动的</title>
<link>https://toutiao.io/k/5viayyn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;代码编译出来后得到可执行文件，也就是我们常说的程序。都说进程是运行起来的程序，那&lt;span&gt;&lt;strong&gt;程序是如何启动的呢？程序和进程究竟有哪些区别呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;早期的计算机只运行一个程序，所以可以想到的是 CPU 的利用率是多么的低，为了让 CPU 利用率得到有效的提高，工程师们设计了一个方案：加载多个程序到内存中，让它们并发运行，而操作系统控制着这些程序运行状态，这些运行的程序就是我们所谓的进程。虽然有多个程序并发执行任务，但&lt;span&gt;&lt;strong&gt;每个进程在运行过程中都会认为自己独占 CPU  资源、内存资源等，以为整个计算机的硬件资源都是它的&lt;/strong&gt;&lt;/span&gt;。这是操作系统的设计哲学：进程你尽管大胆的往前跑，你要什么我都给你准备好了，你跑起来就对了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还记得之前有篇是专门计算机是如何启动的吗？没有看过的同学可以看这里 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTM0NDEzNw==&amp;amp;mid=2247483756&amp;amp;idx=1&amp;amp;sn=067ae863c4a3fe247e2606e34cf2b104&amp;amp;chksm=fbd4890acca3001c841915c5256779127642517e31148d419a8b58d1afd5df2024b93a838ee3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;3.你知道计算机是如何启动的吗？&lt;/a&gt;。当 BIOS 固件将操作系统内核装载进内存执行后产生了第一个进程，一般来说将这个进程称为进程 0，它的作用是对所有内核核心数据结构进行预先赋值。紧接着创建出一个 init 进程。进程 0 是所有进程的祖先，其他进程要么是它的子进程，要么是它的子孙进程。既然内核进程有 BIOS 固件帮它启动，普通进程是如何启动的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 linux 系统中提供了两个重要的系统调用（系统函数）：&lt;span&gt;&lt;strong&gt;fork()、exec()&lt;/strong&gt;&lt;/span&gt;，利用好这两个函数就可以启动一个进程。步骤是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;先用 fork() 函数创建一个新的进程&lt;/strong&gt;&lt;/span&gt;。注意：这个新的进程比较特殊！它会&lt;span&gt;&lt;strong&gt;将父进程的资源内存地址都复制到自己的内存空间&lt;/strong&gt;&lt;/span&gt;，也就是说，它会和父进程共享父进程的资源。有人就问了：哪来的父进程？为什么要共享父进程的资源？第一个问题：谁来创建出这个新进程就是父进程，比如进程 1 是进程 0 创建出来，那进程 0 就是进程 1 的父进程，有没有进程是没有父进程的？有，且只有一个，就是进程 0，其他都是有父进程的，它们的关系就如同一棵树一样。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1698513800424628&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pMAe7v8MucibAUnLWrHLMWicUpKQE2ezWD2P2EzpuWt5NzWPJmT3aLKR0kQyFyZXDHvX6HQLicUtiaRfENSquLC9LQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;p&gt;第二个问题：在早期的 linux 系统实现中，创建新的进程是会复制父进程的资源的，因为创建出来的子进程需要分配各种资源，比如进程描述符、地址空间等，如果不从父进程复制过来，那应该如何初始化这个新的进程呢？总不能给它一个空的结构吧，所以&lt;span&gt;&lt;strong&gt;最方便省事的方式就是把父进程的东西给复制过来&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;&lt;strong&gt;注意，复制父进程的资源与复制父进程资源内存地址是不一样的&lt;/strong&gt;&lt;/span&gt;。前者是所有的资源再次创建，后者是直接利用指针进行赋值，前者会在系统中增加一份与父进程一模一样的资源，后者不会增加资源。现在的操作系统都是后者，这也是现代操作系统的一个优化点，采用的是一个叫&lt;span&gt;&lt;strong&gt;写时复制&lt;/strong&gt;&lt;/span&gt;（COW，Copy On Write）的技术。为什么要这么做呢？你想，每次创建新进程都要把父进程的资源复制一遍，这得多&lt;span&gt;&lt;strong&gt;耗费 CPU 和内存资源&lt;/strong&gt;&lt;/span&gt;，而且新进程还不一定用的到父进程的资源，而且根据统计大部分情况下都是用不到的。所以如果只用指针去进行复制资源是一个很好的方式，&lt;span&gt;&lt;strong&gt;减少了很多不必要的资源损耗&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当子进程通过 fork 创建出来后，下一步需要进行 exec。&lt;span&gt;&lt;strong&gt;这步会将你指定的子进程程序加载到这个新的进程内存空间中并执行。&lt;/strong&gt;&lt;/span&gt;这两步都完成后才算完成了子进程的启动和运行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面是一个关于利用 fork 和 execve 创建一个新进场的示例。fork 会先创建出一个新的进程，然后利用 execve 装载另外一个程序，这里用的 echo 程序向控制台打印 hello。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *arg[] = {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;echo&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(fork() == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;child process\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(execve(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/usr/bin/echo&quot;&lt;/span&gt;, arg, &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parent process exit\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; EXIT_SUCCESS;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;fork() 的返回值有三种：&lt;/p&gt;&lt;p&gt;所以你们会发现在示例代码里会有一个 fork() == 0 的判断，利用这个可以是否当前是否是在新的子进程内。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们都知道进程是运行起来的程序，但其实进程包括很多东西，比如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程的运行状态&lt;/strong&gt;&lt;/span&gt;：包括就绪、运行、等待/阻塞、僵尸等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/span&gt;：记录当前进程运行到哪条指令了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CPU 寄存器&lt;/strong&gt;&lt;/span&gt;：保存进程运行的上下文信息，以便当前进程调度出去后还能调度回来接着运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CPU 调度信息&lt;/strong&gt;&lt;/span&gt;：包括进程优先级、调度队列、调度等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存信息&lt;/strong&gt;&lt;/span&gt;：进程使用的内存信息，如页表等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;文件信息&lt;/strong&gt;&lt;/span&gt;：进程打开的文件信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源限制信息&lt;/strong&gt;&lt;/span&gt;：CPU、内存、带宽等限制的信息，如：可以限制进程运行所能使用的 CPU 核数。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以把程序看做是一个人，人活着就相当于一个进程。&lt;span&gt;&lt;strong&gt;比如：进程需要 CPU，人活着需要食物；进程需要内存，人活着要房子；进程要与其他进程交流的话，需要管道、socket 等，人与人交流需要手机等；进程竞争 CPU，人竞争食物。&lt;/strong&gt;&lt;/span&gt;很多时候操作系统中的很多东西都可以类比人类社会中的某些方面，可能是工程师们在设计操作系统时参照了人类社会吧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎关注公众号：哈扣。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pMAe7v8MucibMUgXM4Y8G0fRDBtp10qAAW1v0nQpZrjZZAs8LphiabRwv6V40RGbqJQ0ib9Tx2mMveZSibwia0mHK1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>