<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2db5c7c629cc996e3a584b829df0054d</guid>
<title>字节一面：Redis 主节点的 Key 已过期，但从节点依然读到过期数据</title>
<link>https://toutiao.io/k/ptbzpm7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，大部分的业务场景都是读多写少，为了利用好这个特性，提升Redis集群系统的吞吐能力，通常会采用&lt;code&gt;主从架构&lt;/code&gt;、&lt;code&gt;读写分离&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7384615384615385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbXoY9GPAgniaaS8ddrtgH3oUUohEyfRTzbalMAtuhuAc4iaIIPEd4MfsdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;455&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示：其中&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Master节点：负责业务的写操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Slave节点：实时同步Master节点的数据，提供读能力&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了提高吞吐量，采用一主多从的架构，将业务的读压力分摊到多台服务器上&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述方案，看似合理，但其实可能存在一定隐患！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbXHvTcicoe2mV5C4fABvOibTSSiav4ib3bvic4xBkwBxP11c5CzicUwic5p37ww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;一、拉取过期数据&lt;/strong&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis性能高主要得益于纯内存操作，但内存存储介质的成本过高，所以数据的存储有一定的约束。&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常会设置&lt;code&gt;过期时间&lt;/code&gt;，对于一些使用不是很频繁的数据，会定期删除，提高资源的利用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;删除过期数据，Redis提供了两种策略：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、惰性删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也称被动删除，当数据过期后，并不会马上删除。而是等到有请求访问时，对数据检查，如果数据过期，则删除数据。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;优点：不需要单独启动额外的扫描线程，减少了CPU资源的损耗。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缺点：大量的过期数据滞留内存中，需要主动触发、检查、删除，否则会一直占用内存资源。&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、定期删除。每隔一段时间，&lt;code&gt;默认100ms&lt;/code&gt;，Redis会随机挑选一定数量的Key，检查是否过期，并将过期的数据删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你可能会为问了，既然Redis有过期数据删除策略，那为什么还会拉取到已经过期的数据呢？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.040909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbX4CdibSED5Ovs4tWFv0ASLvkoVKnSsv16vTtnHMetMo7OwE4t2iaRT7Yw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;220&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这要从&lt;code&gt;主从同步&lt;/code&gt;讲起了，我们先来看张流程图&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.745417515274949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbXkNcHXuGkGfbWicxZcOMOyY6oV1v8AcdlGuMaEowxwiaU0Yk5oKh8cXKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;982&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当客户端往主库写入数据后，并设置了过期时间，数据会以异步方式同步给从库。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、如果此时读主库，数据已经过期，主库的&lt;code&gt;惰性删除&lt;/code&gt;会发挥作用，主动触发删除操作，客户端不会拿到已过期数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、但是如果读从库，则有可能拿到过期数据。原因有两个&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原因一：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟 Redis 的版本有关系，Redis 3.2 之前版本，读从库并不会判断数据是否过期，所以有可能返回过期数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;升级Redis的版本，至少要3.2 以上版本，读从库，如果数据已经过期，则会过滤并返回空值。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;特别注意：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;此时同步过来的数据，虽然已经过期，但本着谁生产谁维护的原则，从库并不会主动删除同步的数据，需要依赖于主节点同步过来的key删除命令。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原因二：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟过期时间的设置方式有关系，我们一般采用 &lt;code&gt;EXPIRE 和 PEXPIRE&lt;/code&gt;，表示从执行命令那个时刻开始，往后延长 ttl 时间。严重依赖于 &lt;code&gt;开始时间&lt;/code&gt; 从什么时候算起。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.63984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbXjRudlLG4uMBUISLFsC20zcaJ2DVH0FhABpX001xpticlI8iahfgq8gvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，简单描述下过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主库在 t1 时刻写入一个带过期时间的数据，数据的有效期一直到 t3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于网络原因、或者缓存服务器的执行效率，从库的命令并没有立即执行。一直等到了 t2 才开始执行，
数据的有效期则会延后到 t5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果，此时客户端访问从库，发现数据依然处于有效期内，可以正常使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以采用Redis的另外两个命令，&lt;code&gt;EXPIREAT 和 PEXPIREAT&lt;/code&gt;，相对简单，表示过期时间为一个具体的时间点。避免了对&lt;code&gt;开始时间&lt;/code&gt;从什么时候算起的依赖。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;EXPIREAT：单位为秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PEXPIREAT：单位为毫秒&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;特别注意：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;EXPIREAT 和 PEXPIREAT 设置的是时间点，所以要求主从节点的时钟保持一致，需要与NTP 时间服务器保持时钟同步。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7014925373134329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbXwC727N72ogX6tXyUpAurkuurBdrRQFsNe8v32nGLjSjnASqtet5gpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;268&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从同步，除了&lt;code&gt;读从库&lt;/code&gt;可能拉取到过期数据，还可能遇到数据一致性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续往下看&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;二、主从数据不一致&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释下，什么是主从数据不一致？指客户端从库中读取到的值与主库中读取的值不一致！&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5945017182130584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbXhicx7jjBwxP3yQeYiapMIHnuhVgN0csbJLZVYJibScTMQicZfDhuWNPNlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1164&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端写入主库，值为100&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，主库将值100 同步给 从库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着，客户端又访问主库，将值更新为 200&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于主从同步是异步进行的，有一定延迟，假如最新数据还没有同步到从库，那么从库读取的就不是最新值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从库同步落后的原因主要有两个：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、主从服务器间的网络传输可能有延迟&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、从库已经收到主库的命令，由于是单线程执行，前面正在处理一些耗时的命令（如：pipeline批处理），无法及时同步执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、主从服务器尽量部署在同一个机房，并保持服务器间的网络良好通畅&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、监控主从库间的同步进度，通过&lt;code&gt;info replication&lt;/code&gt;命令 ，查看主库接收写命令的进度信息（master_repl_offset），从库的复制写命令的进度信息（slave_repl_offset）&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.415625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfzDic3iauEiaaW9ett6QtZqbXId8Ro71pYrT9CkEuEHXReyGsQxfzbFY6vdd0PIgEHtsx3icjbpBBACw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;master_repl_offset - slave_repl_offset&lt;/p&gt;&lt;p&gt;得到从库与主库间的复制进度差&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以开发一个监控程序，定时拉取主从服务器的进度信息，计算进度差值。如果超过我们设置的阈值，则通知客户端断开从库的连接，全部访问主库，一定程度上减少数据不一致情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待同步进度跟上后，我们再恢复客户端与从节点的读操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，多年大厂实战经验。欢迎关注，我会持续输出更多经典原创文章，为你大厂助力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎小伙伴找Tom哥唠嗑聊天， 技术交流，围观朋友圈，打怪人生不再寂寞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100003916&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.069090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcdJhGaQRdAk0VWLIAIU548z3Izf6mwqwwUX9X86hvNHZq158VYMEaxegjfRg8ic02O0HeWD4xIsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原创不易，看到这里，还请点个&lt;/span&gt;&lt;span&gt;「赞」&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;span&gt;，谢谢大家支持&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9b7815927b83c3673d6f528b2126788f</guid>
<title>最详细的 Go+ 快速入门体验教程</title>
<link>https://toutiao.io/k/rk2w5jr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-fileid=&quot;100000976&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeA0KflzC88CqGU0f7fUncIeOXXFbqgdLRxh3VESicgzTTLlQkgIDTnCRA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go+ 1.0 的发布会过去有几天了，想着要不直接干一个 Demo 到本地玩玩，于是就有了这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以根据这篇文章一步一步的搭建你的 Go+ 开发环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你只是想体验下，可以直接到 play 页面体验，地址如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://play.goplus.org/&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000965&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45294855708908405&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeAtxx7ghOMS1dTRia2TMdGuia7RBH9NhVv2YlvfBNBqENuq7WzzRTaPcCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境安装&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们去到 Go+ 的官网：goplus.org&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000966&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5026223776223776&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeAFRibbm6O8ia0EXhc1eyF8uOxMuD0PpogrxFnXLdm4Xb6iabbpDF4onY2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一头可爱的小牛牛，非常具有七牛的辨别度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据官网可以看出 Go+ 的定位更多的是往工程、STEM教育和数据科学这几个方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 Download Go+ 按钮，就会直达他们的 Github Release 页面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000967&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5829846582984658&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeArvBfc4dV1WprI7aQ27xibSSmuW8815gWVo5jjPfIROsJ2lbuBQopCtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1434&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我现在看到的是 1.0.16 版，或许你看到时版本会更高些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里根据你的系统下载对应的包即可，我使用的 Mac 电脑，所以选择 Darwin 的包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载解压后，应该能看到有 2 个可执行的二进制文件：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000968&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.29549902152641877&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeAIWQ6lh7514jIMO2QkAYicjaUVjicPB1G2T02LiaVF9qsETiba1hlGAcw2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们就需要把这两个二进制文件放到，已经添加到你的环境变量的目录下面，方便我们可以在任意文件夹下执行 gop xxx 命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里选择放到 GOPATH 下面的 bin 目录下面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此就安装完毕了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发工具和插件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人问有官方的开发工具没，我好像没在官网找到有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我这里使用的 VScode 作为开发工具，因为方便安装插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要在插件中心找到一个名叫 goplus 的插件：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000969&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeAicvwqUFKoyUsT8iaDfyLiclg7EUaWDK1ibF7dvN5Yf7iclObvbfbGobFEfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完毕，我们就可以开始编写代码了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编写 Demo 代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在我的桌面上新建了一个名为 gop 的目录，并用 vscode 打开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Go+ 其实是对 Go 进行了一些扩展，其开发环境还是需要依赖 Go 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你没在 GOPATH 下新建工程，就需要使用 Go Model 来处理依赖，所以我们这里在工程目录下面执行下 Go Model 的初始化命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go mod init gop&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 gop 是你的工程名字，你可以随意。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000970&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeAQic7xVibRyXkfqYNWnshYhgia00ucdVscWmJ1nPmOicJcufR6mKW8XB1HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时文件夹下面会多一个 go.mod 文件，这里不做过多解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后开始编写我们的 gop 文件，新建一个 main.gop 文件，写入如下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 Go 的代码很相似，但是 Go 的输出需要使用 fmt 包，在 Go+ 里面则不需要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在编译执行下这个文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;gop run main.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现少依赖：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000971&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34615384615384615&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeADC3xSz2Zp0yh8XdC9PrSt9YD9PAicRX4icvQ6QV2gbHYnftAnKKNia7Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1300&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在命令行执行他提示的安装命令即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; get github.com/goplus/gop/builtin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完毕后，再次执行就可以了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000972&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeA44Rmw6jfxHXgYJzcQmolMibAiaEvQo8Z8jYFBGGCxaHkBy2tCoLsGcBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现他把 gop 文件翻译成了 autogen.go 文件，这个直接用 go 执行那个文件也是一样的效果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Mac环境特有的问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是 Mac 环境，你在第一次执行时，你应该会遇到下面这个提示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000973&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0076923076923077&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeA8uNqT4aFk86Q0qVaxFlVvFzXgZP68ODtsicDfTL6KC8vf0ps9t6WV1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;520&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时你大可不必【移到废纸篓】里面，点击取消到【安全性与隐私】的【通用】里面点击【仍然允许】即可。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000974&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8787425149700598&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF88XZfFX8iaYHGIYjGpFicYeAF5htcWlaQpN2stBvzxth8pjReUaoZdLlBHBTTiaiaEOaF0l6oBU8ibCAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后 gop 的提示也是一样的处理方式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一些 Go+ 的特性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go+ 给我们提供了很多语法糖的东西给我们，让我们的代码看起来更加的人性化，写起代码来更加丝滑，当然不止语法糖这一个好处，后期可能还会有科学计算方面的支持等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这篇文章接下来就给大家挑一些语法糖给大家说说：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;混合切片&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我给他取的名字哈，在 Go 里面除了 interface 类型的以外，一个切片只能存放一种类型，所以在创建时就得定义好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 Go+ 里面你大可不必关心数据类型，你可以任意地放类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;abc&quot;&lt;/span&gt;, &lt;span&gt;2.3&lt;/span&gt;]&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;(a)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;---&lt;br/&gt;$ gop run main.gop &lt;br/&gt;[&lt;span&gt;1&lt;/span&gt; abc &lt;span&gt;2.3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后你去看 autogen.go 文件，你会发现，他进行了自动类型推导。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;切片的遍历&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2.3&lt;/span&gt;, &lt;span&gt;45&lt;/span&gt;]&lt;br/&gt; &lt;span&gt;println&lt;/span&gt;([item*&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; item &amp;lt;- a])&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;---&lt;br/&gt;$ gop run main.gop &lt;br/&gt;[&lt;span&gt;2&lt;/span&gt; &lt;span&gt;4.6&lt;/span&gt; &lt;span&gt;90&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法其他语言好像也是支持的，类似高阶函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;更加人性化的错误处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 里面的错误处理机制是最让人烦恼的，所以 Go+ 里面给出了他的处理方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;expr! &lt;span&gt;// panic if err&lt;/span&gt;&lt;br/&gt;expr? &lt;span&gt;// return if err&lt;/span&gt;&lt;br/&gt;expr?:defval &lt;span&gt;// use defval if err&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们需要写一个方法，把 string 类型的转换成 int 类型，如果转换成功返回 int 数据，如果转换异常就返回 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 Go 的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ToInt&lt;/span&gt;&lt;span&gt;(in &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; res, err := strconv.Atoi(in)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 Go+ 的写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ToInt&lt;/span&gt;&lt;span&gt;(in &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; strconv.Atoi(in)?:&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是简洁了很多，这种写法和 swift 很类似。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在最后的&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 之所以很多人用，有很多原因，但是有一点是少不了的，那就是他的库多，所以 Python 又称为胶水语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果后期 Go+ 里面能纳入更多的库，相信将会是 Go 的重磅炸弹，当然这个还是主要看 Go+ 的社群了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一起期待 Go+ 未来的进一步动作吧！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f7008bc43467cb7bcfb23bfc6986938</guid>
<title>一个反直觉的 SQL</title>
<link>https://toutiao.io/k/mfl969k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485779&amp;amp;idx=1&amp;amp;sn=95a8b630d96dc0e76436f7b1c3d5bd51&amp;amp;chksm=fafde3fdcd8a6aebaf8128b65255d8d38bdd695a02c2c218e5435e29073726b1c2e5525a9355&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《容易引起雪崩的两个处理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《容易引起雪崩的两个处理》&lt;/a&gt;里，我提到一个慢查询的问题。本文先从整洁架构的角度讲讲慢查询sql完成的功能以及设计，再介绍对sql进行的实施测试现象以及思考。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设计讲解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一见杨过误终身，有多少萌妹子败给了一个痴字。金庸笔下的痴儿怨女数量之多就需要单独申请服务器，用独立存储单元进行存储。&lt;/p&gt;&lt;p&gt;先说神雕侠侣的杨过，陆无双和程英两姐妹苦等他16年最终等来了他和小龙女撒了一波狗粮而去；郭芙含怨20多年；完颜萍一生为杨过梦绕魂牵；郭襄做了尼姑；最惨&lt;span&gt;公孙绿萼，&lt;/span&gt;&lt;span&gt;为救&lt;/span&gt;&lt;span&gt;他而死，用生命换来的解药杨过转身扔进绝情谷底，&lt;span&gt;公孙绿萼&lt;/span&gt;在天上看到此情此景也会气的骂娘吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;再说雪山飞狐的胡斐，出家的袁紫衣；为救他惨死的程灵素……&lt;/p&gt;&lt;p&gt;从领域驱动设计的角度讲，上面都是值对象。今天不讲值对象，讲实体。所以先拉回来。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3658787255909558&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwyMoVfkKaltdY7gIqsowozHAw31RhAjVHPyiaaFEXdgP29rwQAmFcbHCict6ZFsgLgI5WBLUpZuWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/p&gt;&lt;p&gt;功能简单来说如上图，就是从页面发起查询，查询入口有多个。有个页面是查询角色的仇人，比如杨过的仇人有金轮法王、公孙止、赵志敬……；有个页面是查询角色撩过的妹子，比如杨过撩过的妹子有凌洪波、&lt;span&gt;陆无双、程英……；有些人在几个查询页面都能查到，比如李莫愁既是杨过撩过的妹子，又是杨过的仇人。这里我们把一种页面叫一个请求方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;请求方发起更新查询请求，比如请求方要查询杨过的所有仇人。请求经过转接系统将请求落库后转发到MQ。MQ异步返回包含杨过、胡斐在内的所有仇人的结果。转接系统根据结果反查请求信息，将结果存储。请求方3s后再发起结果查询，这时就会根据请求条件直接返回杨过的所有仇人。这里值得注意的是一次请求返回的结果有的100多条，有的200多条。就是说杨过、胡斐等这些金庸笔下的人物目前仇人列表总数是100多条；杨过、胡斐等这些金庸笔下的人物目前撩过的妹子列表总数是200多条。编辑还在不断录入数据，过一段时间，数据会变化。&lt;/p&gt;&lt;p&gt;功能的设计整体采用整洁架构中的&lt;strong&gt;&lt;span&gt;事件溯源&lt;/span&gt;&lt;/strong&gt;的变通方法。对于发起请求，只有增加和查询操作；对于回执结果，因为查询只会查询最新回执。所以一个请求方结果返回后会将所有之前的老数据更新为is_new=N，新插入记录is_new=Y。&lt;/p&gt;&lt;p&gt;回执结果记录数据表设计如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5706521739130435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwyMoVfkKaltdY7gIqsowo3oFibpXfn6OaSLcXCe0LQQsGK5cecMc20Qic3ibmtOpt7lBvmGsNEZmHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;368&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个查询系统受到不少人的喜爱，不知不觉间，查询次数过多，事件溯源的设计导致回执结果记录数据表积累了358万条数据。之前没有索引，结果出现一次请求查询20多秒，更新处理直接把数据库拖挂了。&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485779&amp;amp;idx=1&amp;amp;sn=95a8b630d96dc0e76436f7b1c3d5bd51&amp;amp;chksm=fafde3fdcd8a6aebaf8128b65255d8d38bdd695a02c2c218e5435e29073726b1c2e5525a9355&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《容易引起雪崩的两个处理》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《容易引起雪崩的两个处理》&lt;/a&gt;里，我讲解过给is_new加上索引，虽然is_new只有N和Y两个值，总体数据区分度不高，但是对于这种N和Y的值占比是万比一比例，只会查其中少的那部分，却是比普通索引有更高的效率。&lt;/p&gt;&lt;p&gt;问题来了，请求方的查询条件是where is_new=Y and 角色名=杨过 and 查询来源=仇人。我是该建立三个字段联合索引还是两个字段联合索引还是单个索引？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;反直觉！&lt;/span&gt;&lt;/strong&gt;经过试验：&lt;br/&gt;1&amp;gt;is_new、角色名、查询来源 三个字段加索引&lt;br/&gt;2&amp;gt;is_new、查询来源两个字段加索引&lt;/p&gt;&lt;p&gt;3&amp;gt;is_new、角色名两个字段加索引&lt;br/&gt;4&amp;gt;is_new单个字段加索引&lt;br/&gt;四种情况sql执行速度在ms级别没有任何差别！几次测试都是6ms返回！而更新时间虽然增加了建索引的时间，反而耗时大大减少！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;原理分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查询时间分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上面所列的索引添加方式都是索引全中，假设is_new的数据共400多条，某查询来源的数据是一二百条，某角色名大概十几条。B+树底层：&lt;br/&gt;1&amp;gt; is_new、角色名、查询来源 三个字段加索引时索引命中十几条，然后通过主键查到数据返回&lt;/p&gt;&lt;p&gt;2&amp;gt; is_new、查询来源  两个字段加索引时索引命中一二百条，然后扫描这一二百条数据，查到需要的十几条数据返回&lt;/p&gt;&lt;p&gt;3&amp;gt;is_new、角色名  两个字段加索引时索引命中二十几条，然后扫描这二十几条数据，查到需要的十几条数据返回&lt;/p&gt;&lt;p&gt;4&amp;gt;is_new单个字段加索引时索引命中400多条，然后扫描这400多条数据，查到需要的十几条数据返回&lt;/p&gt;&lt;p&gt;之所以单个索引和联合索引查询结果区别不大呢，是因为扫描的数据共400多条，按照数据库的处理能力来说不算什么，这6ms时间主要花在了组装数据和传输数据上。如果查询条件不命中(返回数据条数为0)，查询时间几乎为0！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;更新时间分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上面提到每次查询都会把上次结果的is_new更新为N，新数据插入时is_new=Y。所以读写比例为1:1。更新性能就是不能不考虑的问题。当然最重要的是更新操作是数据库被拖挂的罪魁祸首。&lt;/p&gt;&lt;p&gt;update 回执结果记录数据表 set is_new=N where is_new=Y and 查询来源=仇人。&lt;/p&gt;&lt;p&gt;我测试了一下：&lt;/p&gt;&lt;p&gt;1&amp;gt; is_new、角色名、查询来源 三个字段加索引时更新时间90ms。&lt;/p&gt;&lt;p&gt;2&amp;gt; is_new、查询来源  两个字段加索引时更新时间60ms。&lt;/p&gt;&lt;p&gt;3&amp;gt;is_new、角色名 两个字段加索引时更新时间60ms。&lt;/p&gt;&lt;p&gt;4&amp;gt;is_new单个字段加索引时更新时间30ms。&lt;/p&gt;&lt;p&gt;这个更新操作，涉及索引重建。层数越多越慢不难理解。但是为什么时间是几十毫秒级别呢？没建索引之前查询都要20s。原因是B+树是树形结构。示意图如下所示，声明：下面的解释只是针对这个问题一个脑补过程，实际上有很多不严谨的地方。比如B+树还有最底层的叶子节点来存放数据。叶子节点之间有双向链表，与主题无关，没画那么细。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41782407407407407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicwyMoVfkKaltdY7gIqsowojpT1XyyWUhWGg649HfA2fL7ApnFOibrWqczwlfibbdXiaqfgMFxmlkR1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;更新操作会首先进行一个查询，is_new=Y，然后会在is_new=Y这个范围内将is_new=Y涉及的一二百条数据，再到is_new=N下面自己的位置进行插入。如果是三层，每层的数据都需要先找自己的位置，最慢。这里面没有画的叶子节点是从左到右按id顺序排序的。如果只有一层is_new=Y的整个直接放到is_new=N下面的最后就可以了，最快。这就解释了四种更新方式的更新时间差异。&lt;/p&gt;&lt;p&gt;但是为什么加了索引和完全不加索引之间有有多于千倍的性能差异呢？更新操作的时间也主要是花在查询上。如果完全不加索引，一二百条数据每条插入前先进行查找，查找要全表扫描，358万条数据，16K为一个内存换页。我就不具体算了，但是要进行很多次内存换页才能查出来。还要乘以数据条数。而加了索引，因为有is_new=Y条件，进行一次内存换页就可以了。因为is_new=Y数据总共就400多条，1个内存页是可以存下的。所以一二百条数据中下一条就不需要内存换页了，查询总共就需要1次内存换页，基本不花什么时间。剩下的就是一条条插入具体位置了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最终结论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过上面比较，自然是只加单索引is_new最高效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e2b6a98e00ef9f39193a950153b21b9</guid>
<title>教你一个快速掌握知识的学习方法</title>
<link>https://toutiao.io/k/rd17z33</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA3MDg5MDkzOA==&amp;amp;action=getalbum&amp;amp;album_id=1536569434063077381#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1536569434063077381&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#认知升级迭代&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;27个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作平台签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;编者按：面对技术的不断升级迭代，&lt;span&gt;作为技术同学&lt;/span&gt;需要不断的自我学习和迭代。费曼是一个有趣且博学的科学家，他的学习技术是可以复制的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;费曼学习技巧是掌握大量知识的极佳方式，希望对您有所启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQaTL4ZYJgeO6tibM96Q73MU1jjDxwl21RzoNGED9aYSx5Unj7ZqKMKkziaw9byia953WDenLq0HTOfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;Feynman illustration by Sunny Labh inspired by ZenPencils&lt;/p&gt;&lt;p&gt;理查德·费曼（Richard Feynman）被认为是科学史上最不可思议的人物之一。费曼博士是1965年量子电动力学诺贝尔奖得主(与J. Schwinger和Tomonaga一起)，他是一位非常了不起的教育家和伟大的物理学家。&lt;/p&gt;&lt;p&gt; &lt;em&gt;坦诚地讲，费曼既是天才又是小丑。“深刻的思考”和“快乐的扮小丑”并不是分裂人格的两个独立部分。——Freeman Dyson, 1988年对费曼的评论。&lt;/em&gt;&lt;em/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7171428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgQaTL4ZYJgeO6tibM96Q73MUhmrg6JaskjHUUKTmiaxia0lCT3xIgmL7c1samNLFDBdSa3ES5VvbTzsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;Feynman at Caltech&lt;/p&gt;&lt;p&gt;理查德·费曼的天才之处在于他的三卷本物理学著作《费曼物理学讲义》（The Feynman Lectures on Physics），这是根据他1961-1963年在加州理工学院的演讲改编的。&lt;/p&gt;&lt;p&gt;理查德·费曼(Richard Feynman)十几岁时就读的高中没有开设任何微积分课程。在他上高中的时候，他决定自学微积分，并阅读了《实用微积分》。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgQaTL4ZYJgeO6tibM96Q73MUHEjHW8Jv81hKToxEvxAXzVZ7wJog6d7e9nyl8Ke5uzuTfO4e1NEwfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;Credits: Melinda Baldwin&lt;/p&gt;&lt;p&gt;费曼始终认为，如果一个人不能用简单的语言解释一件事，那他就没有理解它。阿尔伯特·爱因斯坦也曾说过类似的话。不管这个观点是否来自费曼，这个想法都是正确的，事实上，这也是费曼学习方法的基础。费曼经常被认为是“伟大的解释者”，因为他能够以一种非科学背景的人也能理解的方式，用极其简单易懂的方式解释科学中复杂的概念，尤其是物理学。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;190&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;他打开一本新的笔记本，在书的扉页上写道：“记录我不知道的事”（NOTEBOOK OF THINGS I DON’T KNOW ABOUT）。这是他第一次(但不是最后一次)重新整理他的知识。他花了几个星期的时间拆解物理学的每个分支，给零件上油，然后再把它们组装起来，同时一直在寻找原始边界和不一致之处。他试图找出每门学科的核心。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;——詹姆斯·格莱克（James Gleick）评价理查德·费曼的传记&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h3 label=&quot;二级标题&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 label=&quot;二级标题&quot;&gt;&lt;strong&gt;&lt;span&gt;那费曼技术是什么？&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;费曼的学习技巧主要包括四个简单的步骤：&lt;/p&gt;&lt;h3 label=&quot;二级标题&quot;&gt;&lt;span&gt;步骤1：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;费曼技术几乎适用于任何学科和概念，而并不局限于数学或物理，它可以应用到更广泛的领域。使用这种技巧的第一步是选择主题，并开始研究它。&lt;/p&gt;&lt;p&gt;现在，&lt;span&gt;学习并不意味着仅仅记住知识&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;事实上，费曼本人一直反对死记硬背的文化，他一直认为一个人应该学习和理解原则，而不是死记硬背事实或公式。另一个学习的好方法是写。在纸上写东西会刺激大脑的海马体，这部分大脑主要负责记忆和学习。&lt;/p&gt;&lt;h3 label=&quot;二级标题&quot;&gt;&lt;span&gt;步骤2：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果你想掌握某件事，那就把这件事教给别人。&lt;span&gt;教学是学习的有力工具&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;用你自己的话解释某个概念，并试着向孩子或完全不熟悉这个话题的人解释。你也可以假装向桌子上的一只橡皮鸭解释。&lt;/p&gt;&lt;p&gt;这个想法是，试图用尽可能简单明了的语言把事情分解。尽量使用简单的术语和词汇，不要只局限于你所学的领域。你也可以列举一个或两个例子，使事情更容易理解。如果你这样做，你会更容易理解更深层次的东西，并帮助你建立知识的联系。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;120&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;所有的东西都是由原子组成的，原子是一种永无休止运动的小粒子，当它们相距不远时，就会相互吸引，但一旦相互挤压，它们就会相互排斥。在这句话里，有大量关于这个世界的信息。——他认为，科学知识中最有价值的信息，是用最少的词在一句话里陈述了原子假说。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h3 label=&quot;二级标题&quot;&gt;&lt;span&gt;步骤3：&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;这是一个非常关键的步骤，可以让你发现自己的不足之处。&lt;/p&gt;&lt;p&gt;当你用简单的语言来解释或写东西时，你总是会遇到一些难以解释或建立联系或表述例子的地方。这时候，你就要回归到资源材料，书籍或期刊或互联网，无论你的主要参考资料是什么，回去看看，并填补你的知识空白。你可以通过几个例子来寻找自己的差距，比如无法解释或简化某事，忘记了一些重要的要点，等等。我们的想法是回到过去，再次修改。这有助于你更好地理解事物。&lt;/p&gt;&lt;p&gt;在这一步中，你知道你需要努力和关注的领域，这是学习过程的重要部分。了解自己的局限性，然后努力去更好地理解它们是这一步的重点，它就像魔法一样有效。&lt;/p&gt;&lt;h3 label=&quot;二级标题&quot;&gt;&lt;span&gt;步骤4：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;现在检验成果的时候来了。一旦你纠正了自己的错误，就能简化自己的解释，使它变得更好。&lt;/p&gt;&lt;p&gt;无论何时遇到问题，你总是可以回到第二步和第三步，直到你对主题有一个清晰的理解。你的笔记和例子现在是尽可能最简单的形式，你对学习的主题有了更深的理解。你可以一遍又一遍地遵循这个方法，直到你觉得你已经掌握了这个概念。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8142857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgQaTL4ZYJgeO6tibM96Q73MULrw5sTvCESJAfiakOBFicTL3duhjWYAIP3sdWADDlrlEWZyGy2iaYx37Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;Dr. Feynman teaching at Caltech&lt;/p&gt;&lt;p&gt;当你的最终解释准备好后，你可以把它传达给你的同事、朋友或熟悉你的领域的专业人士，并反思你对事物的理解。这种&lt;span&gt;“边测试边学习”（Test-and-Learn）&lt;/span&gt;的方法非常有效。&lt;/p&gt;&lt;p&gt;费曼始终认为，真理存在于简单之中，当事物简单而优雅时，人们可以更好地理解它们。如果一个人倾向于把事情弄得过于复杂，这往往表明他缺乏深刻的理解。这个想法是，让事情简单到任何人都能理解，然后使用这个工具来让自己更深入地理解知识。&lt;/p&gt;&lt;p&gt;费曼学习技巧可以帮助你从不同的角度学习和理解事物。它不仅可以用于学术目的，还可以用于建立企业，建立心智模型等等。&lt;/p&gt;&lt;p&gt;费曼技术是掌握大量信&lt;span&gt;息的好方法，大家不妨可以试一下，&lt;/span&gt;&lt;span&gt;相比学习的输入，学习之后的内化和吸收更加重要&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作平台签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5163398692810458&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqsCPbyzicCBx6Zm9sNJCWibo6VzGRYbxrSfjJaaGibSRuyZFQmr3KcX07sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a936bab3079d3a30eb7fb23401f17db</guid>
<title>面向对象编程之丑？</title>
<link>https://toutiao.io/k/rz6jfo8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“我是旧时代的残党，新时代没有承载我的船。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果面向对象编程是一个人，我猜他自己在不断被非议的今天，一定会这样感慨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，我用面向对象方式编程已经十几年了，我做架构设计离不开它，做系统分析离不开它，编码的时候更是严重依赖它，我对面向对象无论是思想上还是写代码上都对它是有很深的感情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚学 Java 的时候，我觉得面向对象编程（OOP）真牛逼，用面向对象方式写出来的代码是最好的代码。但是随着项目越做越多，代码越写越多，我发现 OOP 不是万能的，盲目的迷信追求 OOP 会有代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章我不是说面向对象不好，只是希望大家不要过度神话它，更不要人云亦云。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都听说过&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;面向对象的三大特性：继承、封装、多态&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实这个说法有问题。面向对象的思想里没有任何继承和多态的概念，正确的说法是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这三大特性是面向对象语言的特性，而不是面向对象理念本身的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向对象语言是面向对象设计思想的一种实现，面向对象语言为了能在真实世界使用，其必须经过一些拓展和妥协，而问题也就随着这些拓展和妥协而来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1. 继承带来的也可能是无以复加的痛苦&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际开发中，我们无论谁写代码，都要考虑代码的复用性。面向对象的编程语言作为给开发人员使用的工具，它也必须考虑到复用性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在面向对象编程语言里，对面向对象的基础思想做了拓展，搞出了继承这个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继承就具体实现来说，就是子类拥有父类的所有非 private 的属性和方法。继承的出现能够最大化的代码复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当项目里一个类已经有了我们需要的属性和方法，而我们现在的需求只是在这个已有类的基础上有些许的不同，我们只需要继承这个类，仅把这少许的不同在子类中实现即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果你用了继承，你就引入了问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继承的出现天然会使得子类和父类紧耦合。也就是说，父类和子类是紧密关联的，牵一发动全身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果现实世界里，所有业务模型都是有层次的，而且层次井然有序，是一颗天然的树，那这种紧耦合没有什么问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是现实的需求可不是吃干饭的！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们看看这样一种情况。假设现在我们一家只有两口人，即只有父亲和孩子，那么类继承模型很容易模拟这种情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4939759036144578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KScnmpOK4icmxr0cu9bJzLSfBxzGLV3rqmeWXuibSh2VVhDYcRTb8Woasmf6SLSfUyvxbW1Jq5Ga3qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在现实生活里，往往是三口之家：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7323232323232324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KScnmpOK4icmxr0cu9bJzLSfM0gO4uIiccZOSibR2BEoFlSCOotBuIRpiazA3iathJ8gg2oYNb9J1dfqUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这就有问题了。就像小时候经常有人会问孩子，你觉得你是爸爸的孩子，还是妈妈的孩子啊？如果你要用 Java 的规矩回答，只能从是爸爸或者妈妈里选一个，那么完蛋了。回答爸爸的孩子，妈妈不高兴；回答妈妈的孩子，问题更严重，隔壁老王？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果像 C++ 那样，你说我既是爸爸的孩子也是妈妈的孩子，也有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设爸爸类里有个方法叫说话，妈妈类也有个方法叫说话，你作为继承了他们的孩子类，自然也会拥有说话这个方法。问题来了，你所拥有的的说话这个方法到底来源于谁？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外咱们说了，继承会把子类和父类紧耦合，一旦业务模型失配，就会造成问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给出一个维基百科举的经典例子，来说明一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;inc1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    counter++;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;inc2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    counter++;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Sub&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;inc2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    inc1();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，子类覆盖了父类的 inc2 方法，但是这个 inc2 方法依赖于父类 inc1 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果父类的 inc1 逻辑发生变化了，变成下面这样&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;inc1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    inc2();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;inc2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    counter++;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就会出现 stack overflow 的异常，因为出现了无限递归。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，当我们在子类里，依赖了父类方法作为子类业务逻辑的一个关键步骤的时候，当父类的逻辑修改的时候，必须联动修改所有依赖父类相关逻辑的子类，否则就可能引发严重的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用继承，本来是想少写点代码少加点班，结果……用网上看到的一句话说就是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一日为父，终生是祖宗。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像这种情况该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在只要是个正经的介绍面向对象的技术文章或者书籍里，只要是涉及到继承的，都会加这么句话：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;尽量选择对象组合的设计方式。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《阿里巴巴Java开发手册》中就有一条：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1283471837488458&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KScnmpOK4icmxr0cu9bJzLSfFtyC4ZaP6XbFaNCNqV87y9ZeK9NdvnB0jZ0ic4icW5js4ibe9aVDrMyQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1083&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组合和继承的区别如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3841166936790924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KScnmpOK4icmxr0cu9bJzLSfE0JMRAPCjBibwRGgBSvp1Ux6YG3iadlZ20xR8t0hzsFojxfTPZ3ibuYxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我认为继承和组合各有优缺点，如果两个类确实非常紧密，就是存在层次关系，用继承没问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以有“组合优于继承”这个说法，我个人感觉是组合更灵活，而且能防止被人滥用，用不好的话轻则类的层次失控，重则很可能就把整个项目的代码质量给腐蚀了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2. 封装如同带有漏洞的封印，可能会逃逸出魔王&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装，说白了就是把属性、方法，封到一个对象里，这是面向对象的核心理念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嘴上叫封装，却开了个缝儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，项目是既要兼顾代码质量，还要兼顾运行性能的。不可能说为了提升什么松耦合、高内聚，就不管不顾性能了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情就坏在了这个兼顾性能这里。面向对象里，以上帝角度看，系统就是对象和对象之间的关系构造成的网络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就拿咱们上面谈到的组合关系来说，组合关系的实现就是通过把一个对象当成另一个对象的属性来实现的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11140583554376658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KScnmpOK4icmxr0cu9bJzLSfSeEoB4CITE9EicECgq42ZAFt1Y1rjdp3WW7AfpXvjtmq8kOicNHPE2Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这图就叫做 A 和 B 之间是组合关系。想用 A 对象里的 B 对象，代码这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;A a = &lt;span&gt;new&lt;/span&gt; A();&lt;br/&gt;B b = a.getB();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，我们要问了，这个从 A 中获取的 B，是 B 对象的实例还是实例的一个引用指针呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;必然是引用指针吧，这是最基础的知识。诺，问题来了，引用指针是可以修改的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;b.getS(); &lt;span&gt;//原来是Hello World&lt;/span&gt;&lt;br/&gt;b.setS(&lt;span&gt;&quot;World&quot;&lt;/span&gt;);&lt;span&gt;//直接改成World&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来 B 中有个字段 s，值是个 “Hello World”，我直接可以用代码改成“World”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这次修改随意在个犄角旮旯里，A 能知道吗？A 蒙在鼓里，还以为一切尽在把控当中呢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，封装的缝儿出来了吧。说句实话，就这种鬼操作，是非常难以排查的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像这种封装了，但是又没封装的问题，我只想说“封装的挺好的，下次别封装了”。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3. 多态好，但可能是面向对象的贪天之功&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再说说多态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，面向对象中的多态使用，才是面向对象语言最被认可的地方。因为有了多态，代码才能保证在业务需求多变的情况下，保证了项目的相对稳定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，多态不是面向对象独有的啊。面向过程，函数式编程也可以：面向过程里，C 语言可以靠虚函数去在运行时加载对应的函数实现去实现多态。函数式编程也可以通过组合函数去实现多态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，面向对象连多态这种优势都不独特了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4. 服务端业务变了，人们的观点发生变化了&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说服务端业务的变化之前，我想先普及两个概念，即有状态的服务和无状态的服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有状态的服务就是说，服务需要暂时存一些和客户端相关的数据，以便客户端后续发来的请求可以和客户端前面发的请求通过服务器端关联起来，从而共同完成一项业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无状态服务是说，服务端不存储任何和客户端相关的数据，客户端每次请求，服务端都认为这是个新客户端，和以前的请求无任何关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用现实生活举例的话，有状态服务就是你去一家健身房，第一次去的时候花了一笔钱办了一张健身卡，你以后每次去健身，有卡就不用再掏钱了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无状态服务就是，你没办卡，每次去都和第一次去一样现掏钱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，无状态服务和有状态服务和面向对象的衰落又有什么关系呢？在如今的年代，分布式、微服务大行其道。一个有状态的服务是不容易做分布式和做弹性伸缩的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当年，大家做有多个步骤的业务的时候，为了保证业务数据不会因为用户偶然的关闭浏览器或者浏览器崩溃等问题而丢失，往往会把上一个步骤的信息存在服务端的 session 里，而现在则会倾向考虑把信息放在客户端的本地存储上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我举个例子，假设现在有个需求，要在后台系统新增加一个功能：用户信息管理。其中有个需求要求这样操作，录入用户信息分成两步。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一步，录入用户的基本信息：姓名、手机号、年龄……&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二步，录入额外信息：家庭成员、教育经历、工作经历……&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出于信息完整度的考虑，业务要求这两步应该是一个完整的事务。要么都成功，要么都失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从技术实现上讲，如果是多年以前，我们会在第一步的时候，把商户的基本信息做成表单提交，然后为了保证不会因为用户误关闭浏览器等意外问题丢失中间的数据，保存在对应的 session 中后，在第二步信息提交后，合并起来一起存入到数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，现在的技术趋势是，做任何事情，尽量让服务器端无状态，也就是不存储客户端相关数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，这个需求的解决方案就是，当第一步填写商户信息完成后，直接把数据存储在客户端的本地存储里又或者直接就存在 cookie 里，在第二步填写内容完毕后，联合存在客户端的信息一起提交到服务器端，然后存入数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你看到了，现在大家的趋势就是服务器端都在转向无状态服务，哪怕以前是有状态的服务，也会通过一些增加客户端参数等手段，去改造为无状态服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，那这种技术趋势的变化对我们的面向对象有什么影响呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;影响在于，服务端现在越来越变得往单纯的处理数据这个方向发展。当仅处理数据的时候，服务器端真正的需求其实就是计算，然后就是为了大幅度提升计算速度，而带来的并行化需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而面向对象这种方式和我们当今的技术趋势是有一些冲突的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先就是确定性的冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的首要需求从以前重度处理业务状态加业务数据变成了业务数据的计算，而计算是需要确定性的：即给定相同的输入，经过服务器端相同的逻辑处理后，应该给定相同的输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而面向对象这种方式，出身在有状态服务大行其道的年代，它会优先考虑业务逻辑的调度，其次才是计算，所以，面向对象是拥有状态的。面向对象的状态就是它的字段值。这些字段值，如果单纯的从计算数据角度看，他们不仅无意义了，反而还引入了风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们不小心把一个对象的状态给共享出去了，那当我们用同样的输入计算的时候，很可能由于状态的变化，导致了不同的输出结果，最后就是项目出了问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，由于计算我们对性能更加看重了，又由于无状态服务的大量使用，所以，并行的重要性也远远超出了以前。而并行，要求的是结构的开放，和更加严格的无状态化，而面向对象，恰恰严重依赖于状态，并且，他还把这种状态依赖封装在了复杂的对象关系里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A 状态依赖于 B 的状态，B 的状态又依赖于 C，而这些依赖，全部被封装在了 D 对象的实现细节里，这种严重的反并行也是现在越来越多人开始反感面向对象的重要原因。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;结尾&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多面向对象的坏话，其实真的是面向对象自身的问题吗？并不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，面向对象其实就是我们程序员试图简化这个世界，提高对这个世界的认知的一种美好愿望而已。愿望来自于人自身认知的局限性，所以本身就不可能完美。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，面向对象编程语言只是一种工具，工具的使用的好坏还是要靠人的，不可能每个人能把一套工具用的完美无缺。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所说，面向对象的问题本质还是人的问题，而人可能永远都需要通过组合使用越来越多的类似面向对象的这种并不完美的工具去解决自己的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们不能一味的依靠面向对象，认为面向对象就是最棒的，也不能发现面向对象可能应付不了某些业务场景了，就开始极端地摒弃它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要灵活地，合理地使用任何我们可以使用的编程思想、编程工具，积极地去拥抱变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要忘了我们写代码的初衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完觉得有收获，可以点个&lt;strong&gt;在看&lt;/strong&gt;，让更多的人看到。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。想了解我如何管理团队——&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485282&amp;amp;idx=1&amp;amp;sn=f368ffae1845809ccf06859f988a88a8&amp;amp;chksm=fcd8cb23cbaf4235db644759c3d8099045d10fc952b950d429e4a5e07ed9a806fddf85c451d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;我，管理100多人团队的二三事&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>