<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0eac70291b356c94de28d2bbceef8664</guid>
<title>B站取数服务演进之路</title>
<link>https://toutiao.io/k/yx71pwe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;上一篇我们介绍了B站基于Iceberg的湖仓一体架构实践，本篇我们将继续介绍B站在取数服务方向的演进之路，这也是湖仓一体架构的实践的重要表现方式。&lt;/p&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;引言&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.909090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VKL4sQiapMh3aMfiaIsOd0xCAAcnrFtpKzEK9BM7mfIMJDTzDVA3EDjm1sYdKRTysAibprJlUkJvy9tyXJtjXRBSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;数据平台部作为B站的基础部门，为B站各业务方提供多种数据服务，如BI分析平台，ABTest平台，画像服务，流量分析平台等等，这些服务、平台背后都有海量数据的取数查询需求。伴随着业务的发展，取数服务也面临越来越多的挑战：&lt;span&gt;  &lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需求多、人力紧张，越来越多业务基于数据驱动来做运营，相关的取数需求如：指标查询、UP主、稿件等明细数据的个性化查询需求越来越多，导致在需求响应上，有限的人力跟不上业务发展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;系统架构重复建设：&lt;/span&gt;&lt;span&gt;基于Lambda，Kappa的大数据应用架构在B站有一些应用积累，但非平台化，导致在新场景支持上，出现重复建设，增加了维护成本。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;性能优化成本高：&lt;/span&gt;&lt;span&gt;在满足多种取数场景需求上，数据服务引入多种引擎，比如Elasticsearch、ClickHouse、HBase、MongoDB，这些引擎都需要查询定制优化，增加了研发成本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;基于这些问题的思考，我们在取数服务上经过了2次大的架构升级，不断探索服务化，平台化之路，下面介绍我们在这方面的工作，欢迎大家一起学习交流。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;演进之路&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;2.909090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VKL4sQiapMh3aMfiaIsOd0xCAAcnrFtpKzEK9BM7mfIMJDTzDVA3EDjm1sYdKRTysAibprJlUkJvy9tyXJtjXRBSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;22&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我们在取数服务的升级道路上，大概分为三个时期：最开始是&lt;strong&gt;石器时代&lt;/strong&gt;，这个时期主要以响应业务需求，技术可复用为主；第二时期是&lt;strong&gt;铁器时代&lt;/strong&gt;，我们开始尝试做一些通用服务来支持基础需求，比如统一出仓，统一查询，降低研发成本；第三时期是&lt;strong&gt;工业时代&lt;/strong&gt;，为了更快的响应业务需求，我们尝试引入湖仓技术来进一步提升取数研发的效率。下面分别介绍。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.1 石器时代 - 烟囱式开发&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;取数服务在早期建设时，按照常规方式，我们将过程分为4个阶段：数据模型（数仓建模）、数据存储，查询接口（取数接口），数据产品（业务定制），如下图所示：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1408730158730158&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIwgVgu7icE4bm1h174IOxqvUcwwRIwApc6d5rCpzIgTP6vTKjIln9M3x4fopAFKoibvJ7SX9uMxR7JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;数据模型：&lt;span&gt;数仓建模阶段，按照标准方式，ODS层，DWD层，DWA层来对数据进行分层，分主题建模，通过Hive，Spark对离线数据进行建模，通过Flink进行实时数据建模。&lt;/span&gt;&lt;span&gt;最终对业务上透出的以DWD、DWA层数据。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据存储：&lt;/span&gt;&lt;span&gt;根据不同业务场景的数据查询需求，选型不同引擎来支持业务取数，比如指标数据查询，我们会将数据存储到TiDB中；&lt;/span&gt;&lt;span&gt;对于明细数据的批量查询，我们会将数据存储到ClickHouse，对于点查数据我们会将数据存储到TaiShan DB（内部的 KV 存储）等等。&lt;/span&gt;&lt;span&gt;这些个性化使用，早期基于工程师设计方案选型判断做出决策。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询接口：&lt;/span&gt;&lt;span&gt;基于业务产品的取数需求，定制化研发各种取数HTTP接口。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据产品：&lt;/span&gt;&lt;span&gt;主要支持2大类产品，一类是通用类平台产品，如BI平台，DMP用户画像，ABTest平台，另一类是业务垂类产品，比如B站UP主洞察分析，用户增长指标查询等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.1.1 早期面临的挑战&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这个模式我们有2个角色来支持业务需求，一个是数仓同学，另一个是应用开发同学，整体研发流程如下&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3125904486251809&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIyz7LwbZ6iaEicqvUAqS1o4aSzSLwiaXJYS6x84icyUqZNwsxy7eHq6I3YWyHOaEbSsegs3zgk9krVpAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在早期业务量不大的情况下，上述架构和流程能支持业务需求，分工较为明确，但随着业务规模增大，取数需求增多，其带来的问题也逐渐凸显：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;重数据模型，数据工作量大，研发周期长，出现人力短板，研发跟不上需求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术架构重复建设，比如相同数据不同业务需求会出现重复出仓，相同取数逻辑分业务重复开发，导致维护成本上升。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重复建设也带来了数据口径一致性的问题，排查成本高。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;基于上述问题的思考，我们开始将一些标准化的能力升级为统一服务。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.2 铁器时代 - 统一化服务&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;这个时期我们重点考虑存储和计算统一。通过将数据的出仓过程标准化，引入数据构建流程，将数据进行统一存储。然后在上面搭建了一个基于SQL DSL的取数引擎，内部代号叫Akuya SQL Engine（ASE）。整体架构如下图所示：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.427536231884058&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIyz7LwbZ6iaEicqvUAqS1o4aSlOf5Qlnp41aCWWqfwYGYXTkDmhSvefHphh3otcb2a5QCQ6Xuaiaczbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.1 数据构建&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据构建任务是基于Flink实现的流批一体作业，内部代号为Ark。Source对接了kafka和hive hcatalog，分别支持实时数据和离线数据，Sink主要兼容4种引擎来做统一存储：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Elasticsearch：存储指标数据，利用动态列来存储维度信息，支持预计算指标查询。查询响应在毫秒级。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ClickHouse：存储大宽表明细数据，利用ClickHouse的列式存储特性，支持百亿级明细数据查询，查询响应在秒级。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TiDB：存储明细数据，支持亿级数据点查，查询响应在毫秒级。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InfluxDB：存储实时指标数据，查询响应在毫秒级。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4043478260869565&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIyz7LwbZ6iaEicqvUAqS1o4aSs5psMOpqr7N8JfDdJ3icZia7ibzsY7wJ8bVbHaiaNpfgCp6liciaJXcurL6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;&lt;/section&gt;&lt;section&gt;上图为数据构建系统的架构，用户通过数据构建平台可视化配置数据出仓任务，平台会根据不同离线、实时数据类型触发相应的Ark任务，并托管在内部的AiFlow（内部自研的机器学习平台）调度平台上。&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.2 数据查询&lt;/span&gt;&lt;/section&gt;&lt;section&gt;ASE为了兼容不同存储引擎的标准化数据查询，我们引入了SQL语法，参考了Apache Calcite，Tidb Parser项目，考虑到内部服务Go语言为主，我们最终基于TiDB Parser扩展实现了SQL DSL解析，并独立成Service，同时基于Calcite实现自定义JDBC Driver，兼容其他大数据平台。下面以指标数据查询为例，介绍下主要实现思路：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过Parser解析SQL为AST语法树后，首先会对接AMS（内部元数据服务）进行元数据校验，以及元信息查询；然后进行优化策略，如多指标同时查询，会自动并行化；最后结合元数据信息转化为物理计划查询底层引擎，如存储在ES中预计算指标，会转化为ES DSL API查询，存储在TiDB中指标查询会转化为JDBC协议访问数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4312590448625181&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIyz7LwbZ6iaEicqvUAqS1o4aSo1sicWCg9Y1cefaxsiasLR3wYmAVdCYn6I2ibfxhC4N9UgzoADKsMKt2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6213872832369942&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIyz7LwbZ6iaEicqvUAqS1o4aSH096m9SuVHnM6Gtfx6B1CiaVRBwvdhWkDlTOPEZjv1mvJFlmvwqWYhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过上述SQL DSL，我们可以支持如下一些场景查询&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;根据维度查询多指标&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; dim1, dim2, pv, uv &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; business.metric &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; log_date = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20210310&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;根据维度分组统计&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; dim1, &lt;span class=&quot;code-snippet__keyword&quot;&gt;sum&lt;/span&gt;(pv) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; business.metric &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; dim1 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; dim2 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20210310&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; dim1&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;根据年月汇总指标&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;month&lt;/span&gt;(), &lt;span class=&quot;code-snippet__keyword&quot;&gt;sum&lt;/span&gt;(pv) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; business.metric &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; dim1 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date&amp;gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20200101&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date&amp;lt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20201231&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;month&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;单指标年月环比计算&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; log_date, pv, year_to_year(pv) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; business.metric &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; dim1 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; dim2 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date &amp;gt;= &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;20210301&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date &amp;lt;= &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;20210310&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; log_date, uv, month_to_month(uv) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; business.metric &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; dim1 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; dim2 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date &amp;gt;= &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;20210301&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date &amp;lt;= &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;20210310&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;month(), year\_to\_year(), month\_to\_month() 为系统UDF，标准函数&lt;/span&gt;&lt;/section&gt;&lt;section&gt;派生指标计算&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; CTR(点击pv, 展现pv) &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; business.metric &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; dim1 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; dim2 &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date&amp;gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20200101&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; log_date&amp;lt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20201231&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;CTR是UDF，支持业务自定义实现&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.2.3 中期面临的挑战&lt;/span&gt;&lt;/section&gt;&lt;section&gt;有了数据统一存储和查询之后，我们对应的研发模式上也随之改变如下：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26406926406926406&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIyz7LwbZ6iaEicqvUAqS1o4aSniaSOXBl4Vx2icibc1cBBTqrWLSKymicictesyTV1oltg4Wibb3SRBZtengA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1386&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据同学：聚焦数据模型建设，引入统一数据构建能力后，这部分工作可以由应用开发同学方便的自助操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用开发同学：不用再重复开发取数接口，通过统一取数接口可以直查数据，更聚焦产品功能建设。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;进一步的实践发现，我们依然面临几个突出问题：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据重复建设：&lt;/span&gt;&lt;span&gt;由于存在数据出仓过程，那么离线数据和存储引擎上必然存在重复数据，导致数据管理成本上升。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能优化成本高：需要考虑为不同的存储引擎做查询优化，定制优化成本高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开放的工具、服务较少：随着数据应用场景增多，对取数流程引入的功能需求越来越多，如数据安全，数据DQC，数据抽样等等，业务方（需求方）希望能更多的参与其中，但在这方面平台能力建设不足。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;为了能更好的解决这些问题，我们在21年开始尝试引入湖仓一体架构来优化。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.3 工业时代 - 湖仓一体架构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前我们在B站探索搭建湖仓架构上的取数服务，主要思路是降低数据出仓成本，在低成本存储架构上，完善数据处理和管理功能。并形成PaaS能力。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6933570581257414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIwgVgu7icE4bm1h174IOxqvUFiaFRriaekhialEGFibhJuqkpa3zHyXe7D5OveA5XaWxMhcFDkMqZmQeicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot;/&gt;&lt;/p&gt;&lt;section&gt;我们兼容历史架构，新的湖仓一体平台有几个核心能力：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;（1）基于HDFS的数据湖仓，数据无需出仓：&lt;/section&gt;&lt;section&gt;我们为DB，服务器，消息队列等数据源提供统一的数据接入层，可以快捷将生产环境中的结构化离线数据，实时数据抽取到数据仓库中。实现标准存储。&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;（2）打通元数据，湖仓元数据共享：&lt;/section&gt;&lt;section&gt;湖仓基于Iceberg统一建设，通过HCatalog实现湖仓元数据的统一化管理，Hive表和Iceberg表可以无缝切换。&lt;/section&gt;&lt;section&gt;（3）支持数据索引，提升查询性能，支持数据事务，保障一致性：&lt;/section&gt;&lt;section&gt;直接基于Hive表查询数据较慢，无法直接对接业务取数，但在Iceberg中引入数据索引机制，能大幅度提升取数性能，平均在秒级响应，经过定制调优甚至能到毫秒级，可以满足大部分的取数需求。同时有了大数据上的事务ACID能力，对于一些敏感型业务，可确保并发访问的一致性。感兴趣的同学，可以参考另外一篇文章《B站基于Iceberg的湖仓一体架构实践》。&lt;/section&gt;&lt;section&gt;&lt;span&gt;（4）开放更多数据处理服务能力，加速数据应用：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;有了Iceberg强大的数据查询性能作为后盾，同时数据无须出仓，我们在湖仓上逐步完善数据服务能力，并使之平台化，直接开放给用户使用。比如：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据索引：&lt;/span&gt;&lt;span&gt;我们支持先建表后加索引，所以在取数使用时，可以按需来性能调优，我们将能力平台化，方便用户根据自己需求来优化索引，提升取数体验。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Ad-Hoc：数据探查分析是很高频的一个需求，我们通过对接Trino服务（自研的Iceberg查询服务），可以支持交互式分析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据ETL：并支持SQL语法读写Hive表和Iceberg表，如：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;insert&lt;/span&gt; overwrite &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; iceberg_rta.dm_growth_dwd_rta_action_search_click_deeplink_l_1d_d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  search_time&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , click_time&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , request_id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , click_id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , remote_ip&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , platform&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , app_id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , account_id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , rta_device&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , click_device&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , start_device&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    , source_id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; b_dwm.dm_growth_dwd_rta_action_search_click_deeplink_l_1d_d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; log_date=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20220210&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;distribute&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; source_id &lt;span class=&quot;code-snippet__keyword&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; source_id&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据元信息：整合了湖仓元数据信息管理，可以统一查询。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据API：通过Akuya SQL Engine（ASE），对接Trino服务，可以指定Iceberg表自动生成数据API。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;2.3.1&lt;/span&gt;&lt;span&gt; 现阶段&lt;/span&gt;&lt;span&gt;的挑战&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在湖仓一体架构上，我们通过完善平台能力，支持多人协同参与研发，提升效率，变成如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.315028901734104&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIyz7LwbZ6iaEicqvUAqS1o4aSXD9Qjwu56O0YO7E0SnoEsjaT0sAwRaffuiaCWx4j8DXDl4K0xLAC36w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数仓同学：负责数据接入湖仓，轻度模型建设，降低数据复杂度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BI同学：通过更多的平台化功能，BI同学也可以介入，根据数据产品需求进行数据探查，并能直接作用在数据产品上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用开发同学：通过索引、事务能力，更灵活的实现取数需求，支持更多的应用场景开发。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;当前我们在湖仓架构上的应用工具还在完善中，后续会开放更多的数据处理服务方便用户取数。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;总结展望&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.909090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VKL4sQiapMh3aMfiaIsOd0xCAAcnrFtpKzEK9BM7mfIMJDTzDVA3EDjm1sYdKRTysAibprJlUkJvy9tyXJtjXRBSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;湖仓一体架构的引入，让数据处理变的更加高效。我们围绕湖仓架构大胆探索，小心求证。在新老架构上做了较多的融合工作，比如元信息管理，查询服务等工作。通过实践经验来看，湖仓一体能促进更多研发协同，降低用户生成数据、使用数据的门槛。未来，我们将继续提升平台化能力，进一步提升取数体验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关联阅读&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzNzMxOTI1NQ==&amp;amp;mid=2247483734&amp;amp;idx=1&amp;amp;sn=d97d71939e488d8fe637247b2c81446c&amp;amp;chksm=c2900f6ef5e786783e6b93f8d5c67e59a42626f82fa7f059d2bfe0f2cdbb67f13af6ae92478e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站基于Iceberg的湖仓一体架构实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;B站基于Iceberg的湖仓一体架构实践&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkzNzMxOTI1NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Zp5qolPqxIw0oWTJn2gOIPqxXPLTrg9aTmqRRpaG6F1VSejQkTVcrzX3tvibgwZ6dEqgwjS3ia9tOribshUxtIKsA/0?wx_fmt=png&quot; data-nickname=&quot;哔哩哔哩技术&quot; data-alias=&quot;bilibili-SYS&quot; data-signature=&quot;哔哩哔哩技术分享&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNTE4OTc0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EVKwaZXNTl9OCCo7pxLHz2e2I3kV3rTPao5LlIickfJS79DNd2yjqjfYEtwtMOyVuKhJoDIq6UU4U9TQbjvOLaQ/0?wx_fmt=png&quot; data-nickname=&quot;哔哩哔哩招聘&quot; data-alias=&quot;&quot; data-signature=&quot;生产快乐的地方&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f32fca3b337745bcf9471266273bfed</guid>
<title>如果老板要求你的系统接入春晚大流量活动，你会心慌慌吗？</title>
<link>https://toutiao.io/k/0ps3624</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article tabindex=&quot;0&quot;&gt;&lt;p&gt;&lt;span&gt;今天给大家分享一个话题，就是如果要是你老板突然要求你把你负责的系统，要接入到春晚中去抗下春晚带来的超大流量，你会感到心里特别慌，然后特别没底吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我估计大部分兄弟应该都会感到很慌很没底，不过没事，今天我们就来给大家讲讲，如果咱们系统要接入春晚活动抗下超大并发流量，应该怎么来优化设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;回头看看：原始系统技术架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然说到系统接入春晚大并发流量，那么就得先谈谈没接入之前，你的系统大概长什么样子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实也挺简单，大家一般日常负责开发的系统，通常都是用 SpringBoot+SSM 框架技术栈来写代码，对外基于 SpringBoot 的内嵌 Tomcat 提供 Http 接口，然后用 Nacos+Dubbo 来 RPC 调用别的系统，接着就是连接 MySQL 数据库执行 CRUD 操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5671957671957671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZnABF2GlsRMKWxibKQG4RiaCOBicU66icZOpgFM9Jkia7zQZo3Q2fQp97viaAqAZDE58KUYsJhk4k00jHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;基于 CDN 的活动静态页面缓存方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好，那么接着我们来分析一下，一旦要是这个系统接入了春晚大流量活动以后，超高的流量，可能在平时百倍以上要打到我们的系统来，此时应该如何来优化这个系统架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先第一个问题，就是对于一些静态化的资源，比如说图片/视频一类的资源，要是用户手里拿个 APP 看我们提供的图片和视频的时候，这些东西要是都走到我们后台系统来获取，大家觉得靠谱吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那明显不靠谱啊，因为这种图片和视频一般都比较大，如果大量的人同时请求我们写的 Java 系统来请求下载获取图片和视频，那绝对会把系统搞崩溃的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以一般来说，这个时候都应该上一个东西，叫做 CDN。这个 CDN 呢，大概意思就是说，在全国各地都搞一批服务器，然后呢，让 CDN 提前请求我们的后端系统，把一些图片、视频一类的静态资源都加载到 全国各地的 CDN 服务器上去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着呢，全国各地的用户打卡手机 APP，想要加载图片和视频的时候，就近找一个距离自己最近的 CDN 服务器加载图片和视频就可以了，这样就可以让超高流量分散到全国各地的很多 CDN 服务器上去了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家看下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5781683626271971&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZnABF2GlsRMKWxibKQG4RiaCQMUkOQDLiaaNU7xp2hjUo9rmicWiammlBhXAC1qVazeehBsa6gy4FMxnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2162&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;好，那么现在咱们全国各地用户打开手机 APP 查看我们的各种活动的时候，活动的图片和视频是可以从全国各地就近找一个 CDN 服务器获取了，等于这块大流量是分散到全国各地 CDN 服务器去了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么但是活动页面里可能除了图片和视频以外，还有很多别的数据是得动态查询获取的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;基于 Nginx+Tomcat+Redis 的多级缓存方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是说全国各地用户还是得发送大量的请求到我们后台系统来加载一些数据，那么对于这种高并发的数据读取该怎么来抗呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单，上一套多级缓存架构，我们可以在 Tomcat 前面加一层 Nginx 反向代理服务器，在 Nginx 里可以基于 Lua 脚本自己写代码，然后在 Nginx 的内存里可以基于 LRU 策略缓存一些热门数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后如果是 Nginx 里没有缓存到的数据，可以在我们的业务系统 Tomcat 里用本地 Cache，比如说 Guava 就可以提供本地缓存 Ccache，同样基于 LRU 策略缓存一些数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是如果 Tomcat 本地缓存里也没有，就可以去 Redis 分布式缓存集群里加载缓存数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本上通过 Ngxin+Tomcat+Redis 三级缓存架构，就可以把高并发读取的流量全部抗下来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5406162464985994&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZnABF2GlsRMKWxibKQG4RiaCnkyR0FKiazW3LMNmRic7K4RxKX3TIY24GYmMM6JXAHdbLIE8tGcxLLAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2142&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;超高并发写请求 RocketMQ 削峰填谷方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下一个问题来了，那么参与春晚活动的时候，除了这种超高并发的大流量读取以外，还可能会因为参与活动发起超高流量的数据写入请求呢？此时应该怎么抗下来呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为这个时候，妥妥的是不可能靠什么 CDN 全国各地服务器、Nginx 本地缓存给你抗了，那必须你自己扛下来啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个时候往往是这样，首先第一个是机器扩容，因为如果有大流量的数据写入，那确实咱们平时的业务系统部署的机器数量可能是不够多的，所以往往再抗这种大活动的时候，得临时扩容一批机器出来，这是第一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，一般来说这种大流量数据写入，往往会采取让我们业务系统收到请求后，先写入到 Redis 缓存里去，然后写一个消息到 RocketMQ 里去，接着再从 RocketMQ 里消费消息后异步落入 DB 里去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为数据库能抗的写入压力是有限的，大并发流量写入是不适合他的，所以往往会用这种方式来做一个处理，同样的机器配置，Redis 和 RocketMQ 可以抗几万并发，MySQL 只能抗几千并发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所以此时，架构如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5434198746642793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZnABF2GlsRMKWxibKQG4RiaCVef3QooArHjzKal6uray0IIzGu98icJwCSmkKFGOxT7z2zGcmYcfqBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2234&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;系统限流防雪崩体系架构方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后呢，其实还应该再加一个机制，那就是限流，因为在上述这套架构上线以前，应该对这套架构通过三级缓存可以抗多大读流量压力，以及基于写入 Redis+RocketMQ 异步写 DB，可以抗多大写流量压力，包括临时扩容一批机器后，整体全链路大致可以抗多大的读写 TPS，这些都得通过全链路压测去测试出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后应该根据这个系统能整体抗的最大读写压力，在 Nginx 那一层加入限流机制，一旦要是每秒流量超过了最大值，此时直接限流，不允许继续放行，避免系统被压垮。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5498652291105122&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZnABF2GlsRMKWxibKQG4RiaCQMjumGaYwJw5HD61QdxgxNTmWricic1Aayfnb5IlIyu0VY5cpkIOxpxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2226&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;好了，今天的分享就到这里了，希望大家对于这种普通系统接入大活动超高流量下的架构设计能有一定的了解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若有收获，就点个赞吧！！&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAYU4EDiCi8QAAAAstQy6ubaLX4KHWvLEZgBPE86IoQgVLPeiDzNPgMIsyk32aWkO7IMzOclqOsU-2&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzvoa3ZwBjuRS9LDWurYNnvkMTdJQtxV1sZVfZGXtWlRHK9q5NWbF0CYFtLu4kpy8MB0sfFkBWrOGV5b2SycguPA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdXDtln0TeKQPsFtAvj5nxwfXwmv5z9PBVJia3aDgEL70PPFaZAhkpMLFibzeH7E3ASxU&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;很多兄弟可能平时经常搞的都是一些CRUD的业务系统开发，从来没接触过API网关。那么API网关是啥，到底能对我们起到什么作用呢？#API #API网关 #CRUD @微信时刻 &amp;#10;&amp;#10;&quot; data-nonceid=&quot;2527740014003838467&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b46d438178f00facf0ea20ec3d2c4e51</guid>
<title>面渣逆袭：Spring三十五问，四万字+五十图详解！建议收藏！</title>
<link>https://toutiao.io/k/8ab20e9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三啊，&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247489004&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭&lt;/a&gt; 继续，这节我们来搞定另一个面试必问知识点——Spring。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人说，“Java程序员都是Spring程序员”，老三不太赞成这个观点，但是这也可以看出Spring在Java世界里举足轻重的作用。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;CSDN博客专家、优质创作者，华为云云享专家；肝过外包、混过国企，目前在一家跨境电商搬砖；写过诗，打过拳，佛系小码农。认真讲技术，随性侃人生，关注我，我们一起走的更远。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.Spring是什么？特性？有哪些模块？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs1kVPQW98hUE4lPjKTOwuNlObyK8s9jrlYpY2Kz2cGoiaYuXlNPr7IZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;Spring Logo&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话概括：&lt;strong&gt;Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2003年，一个音乐家Rod Johnson决定发展一个轻量级的Java开发框架，&lt;code&gt;Spring&lt;/code&gt;作为Java战场的龙骑兵渐渐崛起，并淘汰了&lt;code&gt;EJB&lt;/code&gt;这个传统的重装骑兵。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.270996640537514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsVBQbXvrAtHDXCXiagAPNW4h56vZbMCIUleEjrQDToDLruWx6ib9U1Dsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;&lt;figcaption&gt;Spring重要版本&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了现在，企业级开发的标配基本就是 &lt;strong&gt;Spring5&lt;/strong&gt; + &lt;strong&gt;Spring Boot 2&lt;/strong&gt; + &lt;strong&gt;JDK 8&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring有哪些特性呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring有很多优点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8233618233618234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsELLaSC9V9hibcK4MjSYOlh5oeFJL4sIAAfsPRibibJXeKc890M8IZUJrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;Spring特性&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;IOC&lt;/strong&gt; 和 &lt;strong&gt;DI&lt;/strong&gt; 的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现&lt;strong&gt;高内聚低耦合&lt;/strong&gt;的设计理念。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AOP 编程的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 提供了&lt;strong&gt;面向切面编程&lt;/strong&gt;，可以方便的实现对程序进行权限拦截、运行监控等切面功能。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;声明式事务的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的JDBC代码，都可以不用自己写了。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;快捷测试的支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 对 Junit 提供支持，可以通过&lt;strong&gt;注解&lt;/strong&gt;快捷地测试 Spring 程序。&lt;/p&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;快速集成功能&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。&lt;/p&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;复杂API模板封装&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.Spring有哪些模块呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 框架是分模块存在，除了最核心的&lt;code&gt;Spring Core Container&lt;/code&gt;是必要模块之外，其他模块都是&lt;code&gt;可选&lt;/code&gt;，大约有 20 多个模块。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7319884726224783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsiciclyX016BVfa7g8edRug9sz4yyNVOX9Hc1iaheT0ZkP9qNAOdESjsXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;694&quot;/&gt;&lt;figcaption&gt;Spring模块划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最主要的七大模块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring Core&lt;/strong&gt;：Spring 核心，它是框架最基础的部分，提供 IOC 和依赖注入 DI 特性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring Context&lt;/strong&gt;：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring Web&lt;/strong&gt;：它提供 Web 应用开发的支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring MVC&lt;/strong&gt;：它针对 Web 应用中 MVC 思想的实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring DAO&lt;/strong&gt;：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring ORM&lt;/strong&gt;：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.Spring有哪些常用注解呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring有很多模块，甚至广义的SpringBoot、SpringCloud也算是Spring的一部分，我们来分模块，按功能来看一下一些常用的注解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3128654970760234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs9aR2elJWUJvp6ibockInIrcNj1jPTW4NamvGZl4InuG0O6cffuNMtFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;figcaption&gt;Spring常用注解&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Web&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Controller：组合注解（组合了@Component注解），应用在MVC层（控制层）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RequestMapping：用于映射Web请求，包括访问路径和参数。如果是Restful风格接口，还可以根据请求类型使用不同的注解：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@GetMapping&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PostMapping&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PutMapping&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@DeleteMapping&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;@ResponseBody：支持将返回值放在response内，而不是一个页面，通常用户返回json数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RequestBody：允许request的参数在request体中，而不是在直接连接在地址后面。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PathVariable：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;容器&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Component：表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Service：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Repository：组合注解（组合了@Component注解），应用在dao层（数据访问层）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Autowired：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Configuration：声明当前类是一个配置类（相当于一个Spring配置的xml文件）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 ${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Bean：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Scope:定义我们采用什么模式去创建Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AOP&lt;/strong&gt;:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Aspect:声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@After&lt;/code&gt; ：在方法执行之后执行（方法上）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Before&lt;/code&gt;：在方法执行之前执行（方法上）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Around&lt;/code&gt;：在方法执行之前与之后执行（方法上）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@PointCut&lt;/code&gt;：声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;事务：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Transactional：在要开启事务的方法上使用@Transactional注解，即可声明式开启事务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Spring 中应用了哪些设计模式呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8389937106918239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfst3iaqUkGoCUJf1a13Ub5reb0wfPxqHLkHPQricAj6PfbJic5ia3ZmdS6Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;figcaption&gt;Spring中用到的设计模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;工厂模式&lt;/strong&gt; : Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;代理模式&lt;/strong&gt; : Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;单例模式&lt;/strong&gt; : Spring 中的 Bean 默认都是单例的，这样有利于容器对Bean的管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;模板模式&lt;/strong&gt; : Spring 中 JdbcTemplate、RestTemplate 等以 Template结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;观察者模式&lt;/strong&gt;: Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;适配器模式&lt;/strong&gt; :Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;策略模式&lt;/strong&gt;：Spring中有一个Resource接口，它的不同实现类，会根据不同的策略去访问资源。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IOC&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.说一说什么是IOC？什么是DI?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 是面向对象的编程语言，一个个实例对象相互合作组成了业务逻辑，原来，我们都是在代码里创建对象和对象的依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的&lt;strong&gt;IOC&lt;/strong&gt;（控制反转）：就是由容器来负责控制对象的生命周期和对象间的关系。以前是我们想要什么，就自己创建什么，现在是我们需要什么，容器就给我们送来什么。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42781954887218043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs3fibs5nDW3O6lSb3n7SYzOjDMLfarxS1kzONGIa7Ye1jia1jtOFx9xRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;figcaption&gt;引入IOC之前和引入IOC之后&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，控制对象生命周期的不再是引用它的对象，而是容器。对具体对象，以前是它控制其它对象，现在所有对象都被容器控制，所以这就叫&lt;strong&gt;控制反转&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5450381679389313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs3M8HjpONB2Bs6LlXkQO4bibuvVctMyq0zsOondP4FrvSpS9yTSt5JiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;figcaption&gt;控制反转示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DI（依赖注入）&lt;/strong&gt;：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法IOC和DI是一回事，有的说法是IOC是思想，DI是IOC的实现。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么要使用IOC呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最主要的是两个字&lt;strong&gt;解耦&lt;/strong&gt;，硬编码会造成对象间的过度耦合，使用IOC之后，我们可以不用关心对象间的依赖，专心开发应用就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.能简单说一下Spring IOC的实现机制吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:这道题老三在面试中被问到过，问法是“&lt;strong&gt;你有自己实现过简单的Spring吗？&lt;/strong&gt;”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的IOC本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7169014084507043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsIpMzbVObGKSDoZsXOEqJkibkuqsDbOsibh02EUBY9dXK5BVE5gusfZ9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;710&quot;/&gt;&lt;figcaption&gt;工厂运行&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;生产产品&lt;/strong&gt;：一个工厂最核心的功能就是生产产品。在Spring里，不用Bean自己来实例化，而是交给Spring，应该怎么实现呢？——答案毫无疑问，&lt;strong&gt;反射&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;那么这个厂子的生产管理是怎么做的？你应该也知道——&lt;strong&gt;工厂模式&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;库存产品&lt;/strong&gt;：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;订单处理&lt;/strong&gt;：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。&lt;/p&gt;&lt;p&gt;在Spring里，也有这样的订单，它就是我们bean的定义和依赖关系，可以是xml形式，也可以是我们最熟悉的注解形式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们简单地实现一个mini版的Spring IOC：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28180961357210177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsWX9An2rYbJ3CF2e1icus4xdOw6LMDaBpHxGj8rkLKXicO6T5tN5GVHhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1061&quot;/&gt;&lt;figcaption&gt;mini版本Spring IOC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Bean定义：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bean通过一个配置文件定义，把它解析成一个类型。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;beans.properties&lt;/p&gt;&lt;p&gt;偷懒，这里直接用了最方便解析的properties，这里直接用一个&amp;lt;key,value&amp;gt;类型的配置来代表Bean的定义，其中key是beanName，value是class&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;userDao:cn.fighter3.bean.UserDao&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BeanDefinition.java&lt;/p&gt;&lt;p&gt;bean定义类，配置文件中bean定义对应的实体&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanDefinition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String beanName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Class beanClass;&lt;br/&gt;     &lt;span&gt;//省略getter、setter  &lt;/span&gt;&lt;br/&gt; }   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ResourceLoader.java&lt;/p&gt;&lt;p&gt;资源加载器，用来完成配置文件中配置的加载&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResourceLoader&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, BeanDefinition&amp;gt; &lt;span&gt;getResource&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;        Properties properties = &lt;span&gt;new&lt;/span&gt; Properties();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            InputStream inputStream = ResourceLoader&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getResourceAsStream&lt;/span&gt;(&quot;/&lt;span&gt;beans&lt;/span&gt;.&lt;span&gt;properties&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;            properties.load(inputStream);&lt;br/&gt;            Iterator&amp;lt;String&amp;gt; it = properties.stringPropertyNames().iterator();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (it.hasNext()) {&lt;br/&gt;                String key = it.next();&lt;br/&gt;                String className = properties.getProperty(key);&lt;br/&gt;                BeanDefinition beanDefinition = &lt;span&gt;new&lt;/span&gt; BeanDefinition();&lt;br/&gt;                beanDefinition.setBeanName(key);&lt;br/&gt;                Class clazz = Class.forName(className);&lt;br/&gt;                beanDefinition.setBeanClass(clazz);&lt;br/&gt;                beanDefinitionMap.put(key, beanDefinition);&lt;br/&gt;            }&lt;br/&gt;            inputStream.close();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException | ClassNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; beanDefinitionMap;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;BeanRegister.java&lt;/p&gt;&lt;p&gt;对象注册器，这里用于单例bean的缓存，我们大幅简化，默认所有bean都是单例的。可以看到所谓单例注册，也很简单，不过是往HashMap里存对象。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanRegister&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//单例Bean缓存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; singletonMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取单例Bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanName bean名称&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getSingletonBean&lt;/span&gt;&lt;span&gt;(String beanName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; singletonMap.get(beanName);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 注册单例bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanName&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; bean&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerSingletonBean&lt;/span&gt;&lt;span&gt;(String beanName, Object bean)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (singletonMap.containsKey(beanName)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        singletonMap.put(beanName, bean);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;BeanFactory.java&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsQ6zdoYjicRs7HYjLGaQol4UMiaib7PSHPvGp7iaSlDIyYbQia2qIemRfic3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;432&quot;/&gt;&lt;figcaption&gt;BeanFactory&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对象工厂，我们最&lt;strong&gt;核心&lt;/strong&gt;的一个类，在它初始化的时候，创建了bean注册器，完成了资源的加载。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取bean的时候，先从单例缓存中取，如果没有取到，就创建并注册一个bean&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BeanFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BeanRegister beanRegister;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;BeanFactory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//创建bean注册器&lt;/span&gt;&lt;br/&gt;        beanRegister = &lt;span&gt;new&lt;/span&gt; BeanRegister();&lt;br/&gt;        &lt;span&gt;//加载资源&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; ResourceLoader().getResource();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanName bean名称&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getBean&lt;/span&gt;&lt;span&gt;(String beanName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//从bean缓存中取&lt;/span&gt;&lt;br/&gt;        Object bean = beanRegister.getSingletonBean(beanName);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (bean != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//根据bean定义，创建bean&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; createBean(beanDefinitionMap.get(beanName));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 创建Bean&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; beanDefinition bean定义&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Object &lt;span&gt;createBean&lt;/span&gt;&lt;span&gt;(BeanDefinition beanDefinition)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Object bean = beanDefinition.getBeanClass().newInstance();&lt;br/&gt;            &lt;span&gt;//缓存bean&lt;/span&gt;&lt;br/&gt;            beanRegister.registerSingletonBean(beanDefinition.getBeanName(), bean);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InstantiationException | IllegalAccessException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;UserDao.java&lt;/p&gt;&lt;p&gt;我们的Bean类，很简单&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserDao&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;queryUserInfo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;A good man.&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单元测试&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ApiTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test_BeanFactory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//1.创建bean工厂(同时完成了加载资源、创建注册单例bean注册器的操作)&lt;/span&gt;&lt;br/&gt;        BeanFactory beanFactory = &lt;span&gt;new&lt;/span&gt; BeanFactory();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//2.第一次获取bean（通过反射创建bean，缓存bean）&lt;/span&gt;&lt;br/&gt;        UserDao userDao1 = (UserDao) beanFactory.getBean(&lt;span&gt;&quot;userDao&quot;&lt;/span&gt;);&lt;br/&gt;        userDao1.queryUserInfo();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//3.第二次获取bean（从缓存中获取bean）&lt;/span&gt;&lt;br/&gt;        UserDao userDao2 = (UserDao) beanFactory.getBean(&lt;span&gt;&quot;userDao&quot;&lt;/span&gt;);&lt;br/&gt;        userDao2.queryUserInfo();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行结果&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;A good man.&lt;br/&gt;A good man.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们一个乞丐+破船版的Spring就完成了，代码也比较完整，有条件的可以跑一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:因为时间+篇幅的限制，这个demo比较简陋，没有面向接口、没有解耦、边界检查、异常处理……健壮性、扩展性都有很大的不足，感兴趣可以学习参考[15]。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.说说BeanFactory和ApplicantContext?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么形容，BeanFactory是Spring的“心脏”，ApplicantContext是完整的“身躯”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3757575757575757&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs6RO2C872PoFjMmECiceLjvNvts8QVoyiazaRRZcqbt6tVa67SRogc2FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;330&quot;/&gt;&lt;figcaption&gt;BeanFactory和ApplicantContext的比喻&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;BeanFactory（Bean工厂）是Spring框架的基础设施，面向Spring本身。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ApplicantContext（应用上下文）建立在BeanFactoty基础上，面向使用Spring框架的开发者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanFactory 接口&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory是类的通用工厂，可以创建并管理各种类的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring为BeanFactory提供了很多种实现，最常用的是XmlBeanFactory，但在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6650366748166259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsoHzkeuWnGIe4I7AhcJyhA6Ee9mj85ol8gOHibcmhAdQZGUb1LoS5orA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1227&quot;/&gt;&lt;figcaption&gt;Spring5 BeanFactory继承体系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory接口位于类结构树的顶端，它最主要的方法就是getBean(String var1)，这个方法从容器中返回特定名称的Bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory的功能通过其它的接口得到了不断的扩展，比如AbstractAutowireCapableBeanFactory定义了将容器中的Bean按照某种规则（比如按名字匹配、按类型匹配等）进行自动装配的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里看一个 XMLBeanFactory（已过期）  获取bean 的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloWorldApp&lt;/span&gt;&lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;      BeanFactory factory = &lt;span&gt;new&lt;/span&gt; XmlBeanFactory (&lt;span&gt;new&lt;/span&gt; ClassPathResource(&lt;span&gt;&quot;beans.xml&quot;&lt;/span&gt;)); &lt;br/&gt;      HelloWorld obj = (HelloWorld) factory.getBean(&lt;span&gt;&quot;helloWorld&quot;&lt;/span&gt;);    &lt;br/&gt;      obj.getMessage();    &lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ApplicationContext 接口&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。可以这么说，使用BeanFactory就是手动档，使用ApplicationContext就是自动档。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6947368421052632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsyEOGK2axU622EHjuQ7Rsa583NM01OqbBIy46angN3EWGgUOPJ5YhfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;figcaption&gt;Spring5 ApplicationContext部分体系类图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext 继承了HierachicalBeanFactory和ListableBeanFactory接口，在此基础上，还通过其他的接口扩展了BeanFactory的功能，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Bean instantiation/wiring&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Bean 的实例化/串联&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自动的 BeanPostProcessor 注册&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自动的 BeanFactoryPostProcessor 注册&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方便的 MessageSource 访问（i18n）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ApplicationEvent 的发布与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 ApplicationContext 的使用例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloWorldApp&lt;/span&gt;&lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;      ApplicationContext context=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;&quot;beans.xml&quot;&lt;/span&gt;); &lt;br/&gt;      HelloWorld obj = (HelloWorld) context.getBean(&lt;span&gt;&quot;helloWorld&quot;&lt;/span&gt;);    &lt;br/&gt;      obj.getMessage();    &lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.你知道Spring容器启动阶段会干什么吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：这道题老三面试被问到过&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的IOC容器工作的过程，其实可以划分为两个阶段：&lt;strong&gt;容器启动阶段&lt;/strong&gt;和&lt;strong&gt;Bean实例化阶段&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的Bean定义中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48741721854304637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs4Lo0JSJ7RkIcFSCKI7FAasJY7KicrWoQmia5DdWC5uHO9Z7zzH1NfgIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;figcaption&gt;容器启动和Bean实例化阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器启动开始，首先会通过某种途径加载Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Congiguration MetaData进行解析和分析，并将分析后的信息组为相应的BeanDefinition。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5280898876404494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsPe92jRl95ly92lq6BJCzaCGj1NCef4tT97vcXFu0J6h9XkkKRPKvMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot;/&gt;&lt;figcaption&gt;xml配置信息映射注册过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后把这些保存了Bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器启动就完成了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.能说一下Spring Bean生命周期吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看看：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247490715&amp;amp;idx=1&amp;amp;sn=2bb7a7d6d37321289222e28bf47db77a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Spring Bean生命周期，好像人的一生。。&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spring中，基本容器BeanFactory和扩展容器ApplicationContext的实例化时机不太一样，BeanFactory采用的是延迟初始化的方式，也就是只有在第一次getBean()的时候，才会实例化Bean；ApplicationContext启动之后会实例化所有的Bean定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IOC 中Bean的生命周期大致分为四个阶段：&lt;strong&gt;实例化&lt;/strong&gt;（Instantiation）、&lt;strong&gt;属性赋值&lt;/strong&gt;（Populate）、&lt;strong&gt;初始化&lt;/strong&gt;（Initialization）、&lt;strong&gt;销毁&lt;/strong&gt;（Destruction）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsmuTuIpm8FYbv4bwcDOA40hMyd1m4PmTpAfb0WwMBmeIicgQr3EUGe8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;Bean生命周期四个阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一个稍微详细一些的过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实例化&lt;/strong&gt;：第 1 步，实例化一个 Bean 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;属性赋值&lt;/strong&gt;：第 2 步，为 Bean 设置相关属性和依赖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始化&lt;/strong&gt;：初始化的阶段的步骤比较多，5、6步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean就可以被使用了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;销毁&lt;/strong&gt;：第 8~10步，第8步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 Bean 时再执行相应的方法&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7785923753665689&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs7hicasRVtianibpy3g0Jy1mgOnucAywCIdgmQaQQEKqjsuMc5tWg39hJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下，Bean生命周期里初始化的过程相对步骤会多一些，比如前置、后置的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后通过一个实例来看一下具体的细节：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.561797752808989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsfMEEhDEfsMtMDKrMUucYGsg5EMzDUmlWeic3PDQSia3nPjtZGicqFj6pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义一个&lt;code&gt;PersonBean&lt;/code&gt;类，实现&lt;code&gt;DisposableBean&lt;/code&gt;,&lt;code&gt; InitializingBean&lt;/code&gt;, &lt;code&gt;BeanFactoryAware&lt;/code&gt;, &lt;code&gt;BeanNameAware&lt;/code&gt;这4个接口，同时还有自定义的&lt;code&gt;init-method&lt;/code&gt;和&lt;code&gt;destroy-method&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonBean&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt;, &lt;span&gt;BeanFactoryAware&lt;/span&gt;, &lt;span&gt;BeanNameAware&lt;/span&gt;, &lt;span&gt;DisposableBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 身份证号&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer no;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 姓名&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;PersonBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;1.调用构造方法：我出生了！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;getNo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; no;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setNo&lt;/span&gt;&lt;span&gt;(Integer no)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.no = no;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;2.设置属性：我的名字叫&quot;&lt;/span&gt;+name);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanName&lt;/span&gt;&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;3.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;4.调用BeanFactoryAware#setBeanFactory方法：选好学校了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;6.InitializingBean#afterPropertiesSet方法：入学登记&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;7.自定义init方法：努力上学ing&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;9.DisposableBean#destroy方法：平淡的一生落幕了&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroyMethod&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;10.自定义destroy方法:睡了，别想叫醒我&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;work&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Bean使用中：工作，只有对社会没有用的人才放假。。&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义一个&lt;code&gt;MyBeanPostProcessor&lt;/code&gt;实现&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;5.BeanPostProcessor.postProcessBeforeInitialization方法：到学校报名啦&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;8.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件，指定&lt;code&gt;init-method&lt;/code&gt;和&lt;code&gt;destroy-method&lt;/code&gt;属性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;?xml version=&lt;span&gt;&quot;1.0&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;?&amp;gt;&lt;br/&gt;&amp;lt;beans xmlns=&lt;span&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;br/&gt;       xmlns:xsi=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;br/&gt;       xsi:schemaLocation=&lt;span&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;br/&gt;    &amp;lt;bean name=&lt;span&gt;&quot;myBeanPostProcessor&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;cn.fighter3.spring.life.MyBeanPostProcessor&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;bean name=&lt;span&gt;&quot;personBean&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;cn.fighter3.spring.life.PersonBean&quot;&lt;/span&gt;&lt;br/&gt;          init-method=&lt;span&gt;&quot;init&quot;&lt;/span&gt; destroy-method=&lt;span&gt;&quot;destroyMethod&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;        &amp;lt;property name=&lt;span&gt;&quot;idNo&quot;&lt;/span&gt; value= &lt;span&gt;&quot;80669865&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;        &amp;lt;property name=&lt;span&gt;&quot;name&quot;&lt;/span&gt; value=&lt;span&gt;&quot;张铁钢&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;    &amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/beans&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;&quot;spring-config.xml&quot;&lt;/span&gt;);&lt;br/&gt;        PersonBean personBean = (PersonBean) context.getBean(&lt;span&gt;&quot;personBean&quot;&lt;/span&gt;);&lt;br/&gt;        personBean.work();&lt;br/&gt;        ((ClassPathXmlApplicationContext) context).destroy();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;.调用构造方法：我出生了！&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.设置属性：我的名字叫张铁钢&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;.调用BeanFactoryAware#setBeanFactory方法：选好学校了&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;.BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;.InitializingBean#afterPropertiesSet方法：入学登记&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.自定义init方法：努力上学ing&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！&lt;br/&gt;Bean使用中：工作，只有对社会没有用的人才放假。。&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;.DisposableBean#destroy方法：平淡的一生落幕了&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;.自定义destroy方法:睡了，别想叫醒我&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于源码，Bean创建过程可以查看&lt;code&gt;AbstractBeanFactory#doGetBean&lt;/code&gt;方法，在这个方法里可以看到Bean的实例化，赋值、初始化的过程，至于最终的销毁，可以看看&lt;code&gt;ConfigurableApplicationContext#close()&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6083707025411061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsaCSEgw2DGiaNcicHouBSYiciazbUaK9DW5qzxm1JxWLBG0LEDtHdibYwPVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1338&quot;/&gt;&lt;figcaption&gt;Bean生命周期源码追踪&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.Bean定义和依赖定义有哪些方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三种方式：&lt;strong&gt;直接编码方式&lt;/strong&gt;、&lt;strong&gt;配置文件方式&lt;/strong&gt;、&lt;strong&gt;注解方式&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4791666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsaI0tmficqM9yzG4eQxKTbOH4AVArn9a1Q61EqfTPaqZfmVKQonANLxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;Bean依赖配置方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件方式：通过xml、propreties类型的配置文件，配置相应的依赖关系，Spring读取配置文件，完成依赖关系的注入。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring会扫描注解，完成依赖关系的注入。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.有哪些依赖注入的方法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring支持&lt;strong&gt;构造方法注入&lt;/strong&gt;、&lt;strong&gt;属性注入&lt;/strong&gt;、&lt;strong&gt;工厂方法注入&lt;/strong&gt;,其中工厂方法注入，又可以分为&lt;strong&gt;静态工厂方法注入&lt;/strong&gt;和&lt;strong&gt;非静态工厂方法注入&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3721227621483376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsicOqscVZBksWgz8aa2eCnKlj6DU21p0rk2ahhIzKSvQ7JuL05iaUIwPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;figcaption&gt;Spring依赖注入方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;构造方法注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过调用类的构造方法，将接口实现类通过构造方法变量传入&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CatDaoImpl&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;. message = message;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;CatDaoImpl&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.CatDaoImpl&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;  &amp;lt;constructor-arg value=&lt;span&gt;&quot; message &quot;&lt;/span&gt;&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;属性注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过Setter方法完成调用类所需依赖的注入&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Id&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; id; }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setId&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;this&lt;/span&gt;.id = id; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;id&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.id &quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;  &amp;lt;property name=&lt;span&gt;&quot;id&quot;&lt;/span&gt; value=&lt;span&gt;&quot;123&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt; &lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;工厂方法注入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;静态工厂注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 Spring 管理所有对象，我们不能直接通过&quot;工程类.静态方法()&quot;来获取对象，而是依然通过 Spring 注入的形式获取：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DaoFactory&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;//静态工厂&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FactoryDao &lt;span&gt;getStaticFactoryDaoImpl&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StaticFacotryDaoImpl();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpringAction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//注入对象&lt;/span&gt;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; FactoryDao staticFactoryDao; &lt;br/&gt; &lt;br/&gt; &lt;span&gt;//注入对象的 set 方法&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setStaticFactoryDao&lt;/span&gt;&lt;span&gt;(FactoryDao staticFactoryDao)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;.staticFactoryDao = staticFactoryDao;&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法&lt;/span&gt;&lt;br/&gt; &amp;lt;bean name=&lt;span&gt;&quot;springAction&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot; SpringAction&quot;&lt;/span&gt; &amp;gt;&lt;br/&gt;   &amp;lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;staticFactoryDao&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;staticFactoryDao&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt; &amp;lt;/bean&amp;gt;&lt;br/&gt; &lt;br/&gt; &amp;lt;!--此处获取对象的方式是从工厂类中获取静态方法--&amp;gt;&lt;br/&gt;&amp;lt;bean name=&lt;span&gt;&quot;staticFactoryDao&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;DaoFactory&quot;&lt;/span&gt;&lt;br/&gt;  factory-method=&lt;span&gt;&quot;getStaticFactoryDaoImpl&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;非静态工厂注入&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//非静态工厂 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DaoFactory&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FactoryDao &lt;span&gt;getFactoryDaoImpl&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FactoryDaoImpl();&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpringAction&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//注入对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; FactoryDao factoryDao; &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setFactoryDao&lt;/span&gt;&lt;span&gt;(FactoryDao factoryDao)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.factoryDao = factoryDao;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &amp;lt;bean name=&lt;span&gt;&quot;springAction&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;SpringAction&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--&amp;gt;&lt;br/&gt;   &amp;lt;property name=&lt;span&gt;&quot;factoryDao&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;factoryDao&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt; &amp;lt;/bean&amp;gt;&lt;br/&gt; &lt;br/&gt; &amp;lt;!--此处获取对象的方式是从工厂类中获取实例方法--&amp;gt;&lt;br/&gt; &amp;lt;bean name=&lt;span&gt;&quot;daoFactory&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.DaoFactory&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;br/&gt; &lt;br/&gt;&amp;lt;bean name=&lt;span&gt;&quot;factoryDao&quot;&lt;/span&gt; factory-bean=&lt;span&gt;&quot;daoFactory&quot;&lt;/span&gt; factory-method=&lt;span&gt;&quot;getFactoryDaoImpl&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.Spring有哪些自动装配的方式？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是自动装配？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IOC容器知道所有Bean的配置信息，此外，通过Java反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有Bean的这些信息后，Spring IOC容器就可以按照某种规则对容器中的Bean进行自动装配，而无须通过显式的方式进行依赖配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring提供的这种方式，可以按照某些规则进行Bean的自动装配，&lt;bean&gt;元素提供了一个指定自动装配类型的属性：autowire=&quot;&amp;lt;自动装配类型&amp;gt;&quot;&lt;/bean&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Spring提供了哪几种自动装配类型？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring提供了4种自动装配类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5915750915750916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsoLM6zGTOj5Uk0bpEuSL7F6JGbxPxibnBkK8Zs8nIBeGDgAXwiaZNlNYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;figcaption&gt;Spring四种自动装配类型&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;byName&lt;/strong&gt;：根据名称进行自动匹配，假设Boss又一个名为car的属性，如果容器中刚好有一个名为car的bean，Spring就会自动将其装配给Boss的car属性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;byType&lt;/strong&gt;：根据类型进行自动匹配，假设Boss有一个Car类型的属性，如果容器中刚好有一个Car类型的Bean，Spring就会自动将其装配给Boss这个属性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;constructor&lt;/strong&gt;：与 byType类似， 只不过它是针对构造函数注入而言的。如果Boss有一个构造函数，构造函数包含一个Car类型的入参，如果容器中有一个Car类型的Bean，则Spring将自动把这个Bean作为Boss构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的Bean，则Spring将抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;autodetect&lt;/strong&gt;：根据Bean的自省机制决定采用byType还是constructor进行自动装配，如果Bean提供了默认的构造函数，则采用byType，否则采用constructor。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.Spring 中的 Bean 的作用域有哪些?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的Bean主要支持五种作用域：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6557161629434954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsu25uo4JtZQjxSlskGibYMCVDicK83RZeDvUxDZUXs5uCoYaOPEIdc2Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;figcaption&gt;Spring Bean支持作用域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;singleton&lt;/strong&gt; : 在Spring容器仅存在一个Bean实例，Bean以单实例的方式存在，是Bean默认的作用域。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;prototype&lt;/strong&gt; : 每次从容器重调用Bean时，都会返回一个新的实例。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下三个作用域于只在Web应用中适用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;request&lt;/strong&gt; : 每一次HTTP请求都会产生一个新的Bean，该Bean仅在当前HTTP Request内有效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;session&lt;/strong&gt; : 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;globalSession&lt;/strong&gt;：同一个全局Session共享一个Bean，只用于基于Protlet的Web应用，Spring5中已经不存在了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.Spring 中的单例 Bean 会存在线程安全问题吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先结论在这：Spring中的单例Bean&lt;strong&gt;不是线程安全的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为单例Bean，是全局只有一个Bean，所有线程共享。如果说单例Bean，是一个无状态的，也就是线程中的操作不会对Bean中的成员变量执行&lt;strong&gt;查询&lt;/strong&gt;以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如这个Bean是有状态的，也就是会对Bean中的成员变量进行写操作，那么可能就存在线程安全的问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6637010676156584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsBvXcYShOmyiau3y6LQ1tMfichrhmck0cUT9ribicr0wOaw9liaTS97qRbqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;figcaption&gt;Spring单例Bean线程安全问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;单例Bean线程安全问题怎么解决呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有这么些解决办法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将Bean定义为多例&lt;/p&gt;&lt;p&gt;这样每一个线程请求过来都会创建一个新的Bean，但是这样容器就不好管理Bean，不能这么办。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在Bean对象中尽量避免定义可变的成员变量&lt;/p&gt;&lt;p&gt;削足适履了属于是，也不能这么干。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将Bean中的成员变量保存在ThreadLocal中⭐&lt;/p&gt;&lt;p&gt;我们知道ThredLoca能保证多线程下变量的隔离，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal里，这是推荐的一种方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.说说循环依赖?&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是循环依赖？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0250737463126844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsK5L2JNYzPmtic5EVZtUiajj081NGMWyNtOBrFvno7dLEibXtJQFgudeaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;figcaption&gt;Spring循环依赖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 循环依赖：简单说就是自己依赖自己，或者和别的Bean相互依赖。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34321223709369025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsNDia2b8xiajZiaiaEFJqgCvMoxnT9RyImkGialNw55ucw5bnCKddNFBhbTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;figcaption&gt;鸡和蛋&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有单例的Bean才存在循环依赖的情况，&lt;strong&gt;原型&lt;/strong&gt;(Prototype)情况下，Spring会直接抛出异常。原因很简单，AB循环依赖，A实例化的时候，发现依赖B，创建B实例，创建B的时候发现需要A，创建A1实例……无限套娃，直接把系统干垮。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Spring可以解决哪些情况的循环依赖？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring不支持基于构造器注入的循环依赖，但是假如AB循环依赖，如果一个是构造器注入，一个是setter注入呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看几种情形：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5976878612716763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfshvcI9vicaoPdDZurSwlhec94y5eE8Ide192baOE1oZXDBzb7fyXYgjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;figcaption&gt;循环依赖的几种情形&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以简单总结，当循环依赖的实例都采用setter方法注入的时候，Spring可以支持，都采用构造器注入的时候，不支持，构造器注入和setter注入同时存在的时候，看天。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.那Spring怎么解决循环依赖的呢？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS：其实正确答案是开发人员做好设计，别让Bean循环依赖，但是没办法，面试官不想听这个。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，单例Bean初始化完成，要经历三步：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36396396396396397&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsE8ibXU3hUFXJ9gsRXRqpIyiaOrP52kSYmI4iaAIUpepRqpQGaMRiciczia9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;555&quot;/&gt;&lt;figcaption&gt;Bean初始化步骤&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注入就发生在第二步，&lt;strong&gt;属性赋值&lt;/strong&gt;，结合这个过程，Spring 通过&lt;strong&gt;三级缓存&lt;/strong&gt;解决了循环依赖：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一级缓存 : Map&amp;lt;String,Object&amp;gt; &lt;strong&gt;singletonObjects&lt;/strong&gt;，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二级缓存 : Map&amp;lt;String,Object&amp;gt; &lt;strong&gt;earlySingletonObjects&lt;/strong&gt;，早期曝光对象，用于保存实例化完成的 bean 实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三级缓存 : Map&amp;lt;String,ObjectFactory&amp;lt;?&amp;gt;&amp;gt; &lt;strong&gt;singletonFactories&lt;/strong&gt;，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35868625756266204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsm8aj6AGPTmicoPADSyviaicaqokJbpiauEQCIfic9DlsCNiaTWChY8YlOMXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1157&quot;/&gt;&lt;figcaption&gt;三级缓存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下三级缓存解决循环依赖的过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 A、B 两个类发生循环依赖时：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5218390804597701&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsasplZicQAgicW5mWwKoULYhfVt7hzBIL72ZfBAzcqW6vDGggtRC4oibCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;435&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A实例的初始化过程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建A实例，实例化的时候把A对象⼯⼚放⼊三级缓存，表示A开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46645367412140576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs1PISSzSmpHnibCN8qgl6DVkZp3PYAE6C8hrYdJADAXfO7ID2ceWvaiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot;/&gt;&lt;figcaption&gt;1&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;A注⼊属性时，发现依赖B，此时B还没有被创建出来，所以去实例化B&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同样，B注⼊属性时发现依赖A，它就会从缓存里找A对象。依次从⼀级到三级缓存查询A，从三级缓存通过对象⼯⼚拿到A，发现A虽然不太完善，但是存在，把A放⼊⼆级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入⼀级缓存。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48004561003420754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsbFuVs73DZPywohpmPfpiaxavdqE4uW1bs6MD5Pn9EXzibdF1JBKG6wiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;figcaption&gt;2&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接着A继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除⼆级缓存中的A，同时把A放⼊⼀级缓存&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后，⼀级缓存中保存着实例化、初始化都完成的A、B对象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5777233782129743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs2OuRLxRJvRTibiaWpNdrxWdhQ6J0hmDFzVRqDwNAIP2s6ZKTSLZcz3xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;figcaption&gt;5&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们就知道为什么Spring能解决setter注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.为什么要三级缓存？⼆级不⾏吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不行，主要是为了&lt;strong&gt;⽣成代理对象&lt;/strong&gt;。如果是没有代理的情况下，使用二级缓存解决循环依赖也是OK的。但是如果存在代理，三级没有问题，二级就不行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为三级缓存中放的是⽣成具体对象的匿名内部类，获取Object的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的Bean对象，Bean初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通Bean对象，那么可能就导致取到的Bean对象不一致了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1278493557978196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs6OroRfH6jrJQbm0DT3QibXQ1Fhb4WWcqbKNSUztet3YnetCHJglwglw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot;/&gt;&lt;figcaption&gt;二级缓存不行的原因&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.@Autowired的实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现@Autowired的关键是：&lt;strong&gt;AutowiredAnnotationBeanPostProcessor&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Bean的初始化阶段，会通过Bean后置处理器来进行一些前置和后置的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现@Autowired的功能，也是通过后置处理器来完成的。这个后置处理器就是AutowiredAnnotationBeanPostProcessor。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Spring在创建bean的过程中，最终会调用到doCreateBean()方法，在doCreateBean()方法中会调用populateBean()方法，来为bean进行属性填充，完成自动装配等工作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到AutowiredAnnotationBeanPostProcessor的postProcessPropertyValues()方法，在该方法中就会进行@Autowired注解的解析，然后实现自动装配。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;* 属性赋值&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;populateBean&lt;/span&gt;&lt;span&gt;(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//………… &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (hasInstAwareBpps) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (pvs == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    pvs = mbd.getPropertyValues();&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                PropertyValues pvsToUse;&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt;(Iterator var9 = &lt;span&gt;this&lt;/span&gt;.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {&lt;br/&gt;                    InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();&lt;br/&gt;                    pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (pvsToUse == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (filteredPds == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                            filteredPds = &lt;span&gt;this&lt;/span&gt;.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//执行后处理器，填充属性，完成自动装配&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;//调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法&lt;/span&gt;&lt;br/&gt;                        pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (pvsToUse == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;           &lt;span&gt;//…………&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用findAutowiringMetadata()方法解析出bean中带有@Autowired注解、@Inject和@Value注解的属性和方法。然后调用metadata.inject()方法，进行属性填充。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; PropertyValues &lt;span&gt;postProcessProperties&lt;/span&gt;&lt;span&gt;(PropertyValues pvs, Object bean, String beanName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//@Autowired注解、@Inject和@Value注解的属性和方法&lt;/span&gt;&lt;br/&gt;        InjectionMetadata metadata = &lt;span&gt;this&lt;/span&gt;.findAutowiringMetadata(beanName, bean.getClass(), pvs);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//属性填充&lt;/span&gt;&lt;br/&gt;            metadata.inject(bean, beanName, pvs);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; pvs;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (BeanCreationException var6) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var6;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var7) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanCreationException(beanName, &lt;span&gt;&quot;Injection of autowired dependencies failed&quot;&lt;/span&gt;, var7);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;AOP&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.说说什么是AOP？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6296296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsuXjJCWZhjSuG0T8NN57gMQK9wZNWJu8hn99OGDla9YM0rro59bjqKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;figcaption&gt;横向抽取&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说，假如我现在要crud写一堆业务，可是如何业务代码前后前后进行打印日志和参数的校验呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以把&lt;code&gt;日志记录&lt;/code&gt;和&lt;code&gt;数据校验&lt;/code&gt;可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0784313725490196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfswgehrFlAZc0PnBwa0HPL0GXgu04vXhlSebBEwWrkaGSn9Dlich0w8PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;AOP应用示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.428380187416332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsnQJH3O4yWX5NPJxMerqL1JvKcgJblkqyyw3KZCyuhW4QIgS5rPkIbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;figcaption&gt;Java语言执行过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP 的核心其实就是&lt;strong&gt;动态代理&lt;/strong&gt;，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;AOP有哪些核心概念？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;切面&lt;/strong&gt;（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;连接点&lt;/strong&gt;（Joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;切点&lt;/strong&gt;（Pointcut）：对连接点进行拦截的定位&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;通知&lt;/strong&gt;（Advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作&lt;strong&gt;增强&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;目标对象&lt;/strong&gt; （Target）：代理的目标对象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;织入&lt;/strong&gt;（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编译期织入：切面在目标类编译时被织入&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类加载期织入：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。&lt;/p&gt;&lt;p&gt;Spring采用运行期织入，而AspectJ采用编译期织入和类加载器织入。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;引介&lt;/strong&gt;（introduction）：引介是一种特殊的增强，可以动态地为类添加一些属性和方法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;AOP有哪些环绕方式？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOP 一般有 &lt;strong&gt;5 种&lt;/strong&gt;环绕方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前置通知 (@Before)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回通知 (@AfterReturning)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常通知 (@AfterThrowing)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后置通知 (@After)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环绕通知 (@Around)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5792276964047937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs1QW9rzicPN5sXG0fC330NYBtPIGkIwrRUEO5PTQ3o4IOb7zV1pSmR2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;751&quot;/&gt;&lt;figcaption&gt;环绕方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.说说你平时有用到AOP吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：这道题老三的同事面试候选人的时候问到了，候选人说了一堆AOP原理，同事就势来一句，你能现场写一下AOP的应用吗？结果——场面一度很尴尬。虽然我对面试写这种百度就能出来的东西持保留意见，但是还是加上了这一问，毕竟招人最后都是要撸代码的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给出一个小例子，SpringBoot项目中，利用AOP打印接口的入参和出参日志，以及执行时间，还是比较快捷的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引入依赖：引入AOP依赖&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自定义注解：自定义一个注解作为切点&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.METHOD})&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; WebLog {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置AOP切面：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Aspect&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebLogAspect&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger         = LoggerFactory.getLogger(WebLogAspect&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 以自定义 &lt;span&gt;@WebLog&lt;/span&gt; 注解为切点&lt;br/&gt;     **/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Pointcut&lt;/span&gt;(&lt;span&gt;&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;webLog&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 在切点之前织入&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Before&lt;/span&gt;(&lt;span&gt;&quot;webLog()&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doBefore&lt;/span&gt;&lt;span&gt;(JoinPoint joinPoint)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 开始打印请求日志&lt;/span&gt;&lt;br/&gt;        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();&lt;br/&gt;        HttpServletRequest request = attributes.getRequest();&lt;br/&gt;        &lt;span&gt;// 打印请求相关参数&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;========================================== Start ==========================================&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 打印请求 url&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;URL            : {}&quot;&lt;/span&gt;, request.getRequestURL().toString());&lt;br/&gt;        &lt;span&gt;// 打印 Http method&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;HTTP Method    : {}&quot;&lt;/span&gt;, request.getMethod());&lt;br/&gt;        &lt;span&gt;// 打印调用 controller 的全路径以及执行方法&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Class Method   : {}.{}&quot;&lt;/span&gt;, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());&lt;br/&gt;        &lt;span&gt;// 打印请求的 IP&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;IP             : {}&quot;&lt;/span&gt;, request.getRemoteAddr());&lt;br/&gt;        &lt;span&gt;// 打印请求入参&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Request Args   : {}&quot;&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; ObjectMapper().writeValueAsString(joinPoint.getArgs()));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 在切点之后织入&lt;br/&gt;     * &lt;span&gt;@throws&lt;/span&gt; Throwable&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@After&lt;/span&gt;(&lt;span&gt;&quot;webLog()&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doAfter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 结束后打个分隔线，方便查看&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;=========================================== End ===========================================&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 环绕&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Around&lt;/span&gt;(&lt;span&gt;&quot;webLog()&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;doAround&lt;/span&gt;&lt;span&gt;(ProceedingJoinPoint proceedingJoinPoint)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//开始时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();&lt;br/&gt;        Object result = proceedingJoinPoint.proceed();&lt;br/&gt;        &lt;span&gt;// 打印出参&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Response Args  : {}&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ObjectMapper().writeValueAsString(result));&lt;br/&gt;        &lt;span&gt;// 执行耗时&lt;/span&gt;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;Time-Consuming : {} ms&quot;&lt;/span&gt;, System.currentTimeMillis() - startTime);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Aspect：标识切面&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Pointcut：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定义注解是比较常用的一种。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Before：在切点之前织入，打印了一些入参信息&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Around：环绕切点，打印返回参数和接口执行时间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用：只需要在接口上加上自定义注解&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@WebLog&lt;/span&gt;(desc = &lt;span&gt;&quot;这是一个欢迎接口&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello &quot;&lt;/span&gt;+name;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行结果：可以看到日志打印了入参、出参和执行时间&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14179531160663236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsMHlOHRoXTH5tpLr8v26ESgaLvkKQT6W7oInMOaicLvhqwTtulYsnVeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1749&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.说说JDK 动态代理和 CGLIB 代理 ？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的AOP是通过&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247490507&amp;amp;idx=1&amp;amp;sn=003af1086e53877662621632fa96284d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;动态代理&lt;/a&gt;来实现的，动态代理主要有两种方式JDK动态代理和Cglib动态代理，这两种动态代理的使用和原理有些不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JDK 动态代理&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Interface&lt;/strong&gt;：对于 JDK 动态代理，目标类需要实现一个Interface。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;InvocationHandler&lt;/strong&gt;：InvocationHandler是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Proxy&lt;/strong&gt;：Proxy利用InvocationHandler动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CgLib 动态代理&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用JDK创建代理有一大限制，它只能为接口创建代理实例，而CgLib 动态代理就没有这个限制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CgLib 动态代理是使用字节码处理框架 &lt;strong&gt;ASM&lt;/strong&gt;，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CgLib&lt;/strong&gt; 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一个常见的小场景，客服中转，解决用户问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5535483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsf9pf7w7ba4tibU3EL9uxDNMo31l4XIZKWPJmbvoLiaZvs1Id1ZXY1ibpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1550&quot;/&gt;&lt;figcaption&gt;用户向客服提问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JDK动态代理实现：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5364120781527532&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs2YicZZHAib5bxa0no2WlC6EDkNm98Pz6cjsZ386p6b0gyBxmk8kj0HIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;figcaption&gt;JDK动态代理类图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接口&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ISolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;solve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;目标类:需要实现对应接口&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ISolver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;solve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;疯狂掉头发解决问题……&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写InvocationHandler方法，实现接口重写也差不多&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 维护一个目标对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object target;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 为目标对象生成代理对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getProxyInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; InvocationHandler() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;请问有什么可以帮到您？&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;// 调用目标对象方法&lt;/span&gt;&lt;br/&gt;                        Object returnValue = method.invoke(target, args);&lt;br/&gt;&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;问题已经解决啦！&quot;&lt;/span&gt;);&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//目标对象:程序员&lt;/span&gt;&lt;br/&gt;        ISolver developer = &lt;span&gt;new&lt;/span&gt; Solver();&lt;br/&gt;        &lt;span&gt;//代理：客服小姐姐&lt;/span&gt;&lt;br/&gt;        ISolver csProxy = (ISolver) &lt;span&gt;new&lt;/span&gt; ProxyFactory(developer).getProxyInstance();&lt;br/&gt;        &lt;span&gt;//目标方法：解决问题&lt;/span&gt;&lt;br/&gt;        csProxy.solve();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Cglib动态代理实现：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4627659574468085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsAQpUo83WicZaIuiaS5DK0cIqdia0W834EtjHAxLnSw2m2TS2Kz5FsCUibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;figcaption&gt;Cglib动态代理类图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;目标类：Solver，这里目标类不用再实现接口。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solver&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;solve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;疯狂掉头发解决问题……&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;动态代理工厂：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;MethodInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//维护一个目标对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object target;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ProxyFactory&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//为目标对象生成代理对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getProxyInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//工具类&lt;/span&gt;&lt;br/&gt;        Enhancer en = &lt;span&gt;new&lt;/span&gt; Enhancer();&lt;br/&gt;        &lt;span&gt;//设置父类&lt;/span&gt;&lt;br/&gt;        en.setSuperclass(target.getClass());&lt;br/&gt;        &lt;span&gt;//设置回调函数&lt;/span&gt;&lt;br/&gt;        en.setCallback(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//创建子类对象代理&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; en.create();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;intercept&lt;/span&gt;&lt;span&gt;(Object obj, Method method, Object[] args, MethodProxy proxy)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;请问有什么可以帮到您？&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 执行目标对象的方法&lt;/span&gt;&lt;br/&gt;        Object returnValue = method.invoke(target, args);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;问题已经解决啦！&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端：Client&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//目标对象:程序员&lt;/span&gt;&lt;br/&gt;        Solver developer = &lt;span&gt;new&lt;/span&gt; Solver();&lt;br/&gt;        &lt;span&gt;//代理：客服小姐姐&lt;/span&gt;&lt;br/&gt;        Solver csProxy = (Solver) &lt;span&gt;new&lt;/span&gt; ProxyFactory(developer).getProxyInstance();&lt;br/&gt;        &lt;span&gt;//目标方法：解决问题&lt;/span&gt;&lt;br/&gt;        csProxy.solve();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.说说Spring AOP 和 AspectJ AOP 区别?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring AOP&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring AOP 属于&lt;code&gt;运行时增强&lt;/code&gt;，主要具有如下特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在性能上，由于 Spring AOP 是基于&lt;strong&gt;动态代理&lt;/strong&gt;来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AspectJ&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AspectJ 是一个易用的功能强大的 AOP 框架，属于&lt;code&gt;编译时增强&lt;/code&gt;，  可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AspectJ 属于&lt;strong&gt;静态织入&lt;/strong&gt;，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体对比如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6075268817204301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsNCb3fIk5JLLrJmKSk2etMg9lnMyCicDMgBaviaxddNrcFURQ27zYmCiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot;/&gt;&lt;figcaption&gt;Spring AOP和AspectJ对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.Spring 事务的种类？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 支持&lt;code&gt;编程式事务&lt;/code&gt;管理和&lt;code&gt;声明式&lt;/code&gt;事务管理两种方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4038800705467372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs6L8669GNxSicicfyZdNKdywT4Pf1EfNmWgva9OY0TPj8Cz8iaVkzibGROA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;567&quot;/&gt;&lt;figcaption&gt;Spring事务分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;编程式事务&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编程式事务管理使用 TransactionTemplate，需要显式执行事务。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;声明式事务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 @Transactional 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.Spring 的事务隔离级别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的接口TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_READ_UNCOMMITTED：读未提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_READ_COMMITTED：读已提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_REPEATABLE_READ：可重复读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ISOLATION_SERIALIZABLE：串行化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.Spring 的事务传播机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5790816326530612&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsqCWbHaxM0E8fLa9zvnOz9KN03C6v0s9X1LHwdx31V8G3vYMJxVIuyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1568&quot;/&gt;&lt;figcaption&gt;7种事务传播机制&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring默认的事务传播行为是PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个ServiceX#methodX()都工作在事务环境下（均被Spring事务增强），且程序中存在调用链Service1#method1()-&amp;gt;Service2#method2()-&amp;gt;Service3#method3()，那么这3个服务类的三个方法通过Spring的事务传播机制都工作在同一个事务中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.声明式事务实现原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是通过AOP/动态代理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;在Bean初始化阶段创建代理对象&lt;/strong&gt;：Spring容器在初始化每个单例bean的时候，会遍历容器中的所有BeanPostProcessor实现类，并执行其postProcessAfterInitialization方法，在执行AbstractAutoProxyCreator类的postProcessAfterInitialization方法时会遍历容器中所有的切面，查找与当前实例化bean匹配的切面，这里会获取事务属性切面，查找@Transactional注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;在执行目标方法时进行事务增强操作&lt;/strong&gt;：当通过代理对象调用Bean方法的时候，会触发对应的AOP增强拦截器，声明式事务是一种环绕增强，对应接口为&lt;code&gt;MethodInterceptor&lt;/code&gt;，事务增强对该接口的实现为&lt;code&gt;TransactionInterceptor&lt;/code&gt;，类图如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39305555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsDjQ6ufM87pfa1Hq5zXh9Qj6WdjEBvaz2hdDO2VkD1rXf5ib0LDAIn8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;图片来源网易技术专栏&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;事务拦截器&lt;code&gt;TransactionInterceptor&lt;/code&gt;在&lt;code&gt;invoke&lt;/code&gt;方法中，通过调用父类&lt;code&gt;TransactionAspectSupport&lt;/code&gt;的&lt;code&gt;invokeWithinTransaction&lt;/code&gt;方法进行事务处理，包括开启事务、事务提交、异常回滚。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.声明式事务在哪些情况下会失效？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47074122236671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsVz3mFErqqibicgIH8liaMuTiaSO9EDBGbMYRsiahoPOk2JJvF7GQRicThpGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;figcaption&gt;声明式事务的几种失效的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、@Transactional 应用在非 public 修饰的方法上&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果Transactional注解应用在非 public 修饰的方法上，Transactional将会失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是因为在Spring AOP 代理时，TransactionInterceptor  （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy  的内部类）的intercept方法 或  JdkDynamicAopProxy的invoke方法会间接调用AbstractFallbackTransactionAttributeSource的 &lt;strong&gt;computeTransactionAttribute&lt;/strong&gt;方法，获取Transactional 注解的事务配置信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; TransactionAttribute &lt;span&gt;computeTransactionAttribute&lt;/span&gt;&lt;span&gt;(Method method,&lt;br/&gt;    Class&amp;lt;?&amp;gt; targetClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Don&#x27;t allow no-public methods as required.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、@Transactional 注解属性 propagation 设置错误&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、@Transactional 注解属性 rollbackFor 设置错误&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5563549160671463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs8WQBqZdLzCT7LZZjHuTDNKvll9oRqAubpjqd5cwY3fp6Hk1BxZibg0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot;/&gt;&lt;figcaption&gt;Spring默认支持的异常回滚&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 希望自定义的异常可以进行回滚&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Transactional&lt;/span&gt;(propagation= Propagation.REQUIRED,rollbackFor= MyException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、同一个类中方法调用，导致@Transactional失效&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;//@Transactional&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Integer &lt;span&gt;A&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;         CityInfoDict cityInfoDict = &lt;span&gt;new&lt;/span&gt; CityInfoDict();&lt;br/&gt;         cityInfoDict.setCityName(&lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;         &lt;span&gt;/**&lt;br/&gt;          * B 插入字段为 3的数据&lt;br/&gt;          */&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.insertB();&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * A 插入字段为 2的数据&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; insert = cityInfoDictMapper.insert(cityInfoDict);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; insert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;()&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;insertB&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        CityInfoDict cityInfoDict = &lt;span&gt;new&lt;/span&gt; CityInfoDict();&lt;br/&gt;        cityInfoDict.setCityName(&lt;span&gt;&quot;3&quot;&lt;/span&gt;);&lt;br/&gt;        cityInfoDict.setParentCityId(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; cityInfoDictMapper.insert(cityInfoDict);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况是最常见的一种@Transactional注解失效场景&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Integer &lt;span&gt;A&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; insert = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        CityInfoDict cityInfoDict = &lt;span&gt;new&lt;/span&gt; CityInfoDict();&lt;br/&gt;        cityInfoDict.setCityName(&lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;        cityInfoDict.setParentCityId(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * A 插入字段为 2的数据&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        insert = cityInfoDictMapper.insert(cityInfoDict);&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * B 插入字段为 3的数据&lt;br/&gt;        */&lt;/span&gt;&lt;br/&gt;        b.insertB();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务就不能正常回滚了，会抛出异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MVC&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.Spring MVC 的核心组件？&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;：前置控制器，是整个流程控制的&lt;strong&gt;核心&lt;/strong&gt;，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Handler&lt;/strong&gt;：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerInterceptor&lt;/strong&gt;：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerExecutionChain&lt;/strong&gt;：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HandlerAdapter&lt;/strong&gt;：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ModelAndView&lt;/strong&gt;：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.Spring MVC 的工作流程？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsic3JSxb51bkchaNiadMkibxxyfPF36JmiavzlLAWVA8PRIjYsZ0vwy9DHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot;/&gt;&lt;figcaption&gt;Spring MVC的工作流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet将模型数据填充到视图中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DispatcherServlet将结果响应给客户端&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring MVC&lt;/strong&gt; 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有 &lt;strong&gt;Handler（Controller）&lt;/strong&gt; 、&lt;strong&gt;View&lt;/strong&gt; 、&lt;strong&gt;Model&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们现在大部分的开发都是前后端分离，Restful风格接口，后端只需要返回Json数据就行了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.SpringMVC Restful风格的接口的流程是什么样的呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:这是一道全新的八股，毕竟ModelAndView这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道Restful接口，响应格式是json，这就用到了一个常用注解：**@ResponseBody**&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@ResponseBody&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; User &lt;span&gt;user&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;张三&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加入了这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.418796992481203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsHssxjGNp9S8WFjHnIU93OSL9JK4rvbIS718UtBz3B1BOZ6xriamz8ug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3990&quot;/&gt;&lt;figcaption&gt;Spring MVC Restful请求响应示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HandlerAdapter执行完对Controller的请求，会调用HandlerMethodReturnValueHandler去处理返回值，主要的过程：&lt;/p&gt;&lt;p&gt;5.1. 调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例&lt;/p&gt;&lt;p&gt;5.2.使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中&lt;/p&gt;&lt;p&gt;5.3.在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Boot&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.介绍一下SpringBoot，有哪些优点？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring  框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfswYric8SicA4DiaUJz68glEwKeokMLia61w50kjkeQ9B8ia04OvjYwKoBU7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;280&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;SpringBoot图标&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 以&lt;code&gt;约定大于配置&lt;/code&gt;核心思想开展工作，相比Spring具有如下优势：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Spring Boot 可以快速创建独立的Spring应用程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 无需再像Spring一样使用一堆繁琐的xml文件配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot  可以自动配置(核心)Spring。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个appliaction.yml配置文件中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Boot 可以快速整合常用依赖（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自引入其他依赖。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.SpringBoot自动配置原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringBoot开启自动配置的注解是&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; ，启动类上的注解&lt;code&gt;@SpringBootApplication&lt;/code&gt;是一个复合注解，包含了@EnableAutoConfiguration：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33617021276595743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsuUuQoo5yqy1bv1ojgBJxNQcLIDsickCf53rZCibbNFibgUcQOmcX2UWxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1175&quot;/&gt;&lt;figcaption&gt;SpringBoot自动配置原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;EnableAutoConfiguration&lt;/code&gt; 只是一个简单的注解，自动装配核心功能的实现实际是通过 &lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;类&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@AutoConfigurationPackage&lt;/span&gt; &lt;span&gt;//将main同级的包下的所有组件注册到容器中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({AutoConfigurationImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;}) //加载自动装配类 &lt;span&gt;xxxAutoconfiguration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EnableAutoConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String ENABLED_OVERRIDE_PROPERTY = &lt;span&gt;&quot;spring.boot.enableautoconfiguration&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt;[] exclude() &lt;span&gt;default&lt;/span&gt; {};&lt;br/&gt;&lt;br/&gt;    String[] excludeName() &lt;span&gt;default&lt;/span&gt; {};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;实现了&lt;code&gt;ImportSelector&lt;/code&gt;接口，这个接口的作用就是收集需要导入的配置类，配合&lt;code&gt;@Import(）&lt;/code&gt;就可以将相应的类导入到Spring容器中&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取注入类的方法是selectImports()，它实际调用的是&lt;code&gt;getAutoConfigurationEntry&lt;/code&gt;，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取注解的属性，用于后面的排除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;获取所有需要自动装配的配置类的路径&lt;/strong&gt;：这一步是最关键的，从META-INF/spring.factories获取自动配置类的路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;protected&lt;/span&gt; AutoConfigurationImportSelector.&lt;span&gt;AutoConfigurationEntry &lt;span&gt;getAutoConfigurationEntry&lt;/span&gt;&lt;span&gt;(AnnotationMetadata annotationMetadata)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.isEnabled(annotationMetadata)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; EMPTY_ENTRY;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//1.获取到注解的属性&lt;/span&gt;&lt;br/&gt;            AnnotationAttributes attributes = &lt;span&gt;this&lt;/span&gt;.getAttributes(annotationMetadata);&lt;br/&gt;            &lt;span&gt;//2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径&lt;/span&gt;&lt;br/&gt;            List&amp;lt;String&amp;gt; configurations = &lt;span&gt;this&lt;/span&gt;.getCandidateConfigurations(annotationMetadata, attributes);&lt;br/&gt;            &lt;span&gt;//3.1.移除重复的配置&lt;/span&gt;&lt;br/&gt;            configurations = &lt;span&gt;this&lt;/span&gt;.removeDuplicates(configurations);&lt;br/&gt;            &lt;span&gt;//3.2.处理需要排除的配置&lt;/span&gt;&lt;br/&gt;            Set&amp;lt;String&amp;gt; exclusions = &lt;span&gt;this&lt;/span&gt;.getExclusions(annotationMetadata, attributes);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.checkExcludedClasses(configurations, exclusions);&lt;br/&gt;            configurations.removeAll(exclusions);&lt;br/&gt;            configurations = &lt;span&gt;this&lt;/span&gt;.getConfigurationClassFilter().filter(configurations);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.fireAutoConfigurationImportEvents(configurations, exclusions);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.如何自定义一个SpringBoot Srarter?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了自动配置原理，创建一个自定义SpringBoot Starter也很简单。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个项目，命名为demo-spring-boot-starter，引入SpringBoot相关依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;optional&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/optional&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编写配置文件&lt;/p&gt;&lt;p&gt;这里定义了属性配置的前缀&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloProperties&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//省略getter、setter&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自动装配&lt;/p&gt;&lt;p&gt;创建自动配置类HelloPropertiesConfigure&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableConfigurationProperties&lt;/span&gt;(HelloProperties&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloPropertiesConfigure&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置自动类&lt;/p&gt;&lt;p&gt;在&lt;code&gt;/resources/META-INF/spring.factories&lt;/code&gt;文件中添加自动配置类路径&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\&lt;br/&gt;  cn.fighter3.demo.starter.configure.HelloPropertiesConfigure&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试&lt;/p&gt;&lt;p&gt;至此，随手写的一个自定义SpringBoot-Starter就完成了，虽然比较简单，但是完成了主要的自动装配的能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建一个工程，引入自定义starter依赖&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;cn.fighter3&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;demo-spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;-SNAPSHOT&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在配置文件里添加配置&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;hello.name=张三&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;测试类&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RunWith&lt;/span&gt;(SpringRunner&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;SpringBootTest&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    HelloProperties helloProperties;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;你好，&quot;&lt;/span&gt;+helloProperties.getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行结果&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36829268292682926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsf6A7jpicyw4CWg4mOwQb5WH0cdgN9SZ6PTF847MYEErIJZvKLwBqLOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;运行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.Springboot 启动原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringApplication 这个类主要做了以下四件事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;推断应用的类型是普通的项目还是 Web 项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查找并加载所有可用初始化器 ， 设置到 initializers 属性中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找出所有的应用程序监听器，设置到 listeners 属性中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推断并设置 main 方法的定义类，找到运行的主类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringBoot 启动大致流程如下 ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0148148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsf8eISEyE4LBTJnUIvMg6rrplw76QWZYlcgHMQbFpibAeCSfjCdP8zYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;SpringBoot 启动大致流程-图片来源网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spring Cloud&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;35.对SpringCloud了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud是Spring官方推出的微服务治理框架。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfs5mloaNL0ZKOFuG0h7qV6tkmfT4ZCK5VE8QzVLAxczBvq2doXGvLn6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;Spring Cloud Netfilx核心组件-来源参考[2]&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是微服务？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;2014 年 &lt;strong&gt;Martin Fowler&lt;/strong&gt; 提出的一种新的架构形式。微服务架构是一种&lt;strong&gt;架构模式&lt;/strong&gt;，提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制(如HTTP或Dubbo)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)对其进行构建。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;微服务架构主要要解决哪些问题？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务很多，客户端怎么访问，如何提供对外网关?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这么多服务，服务之间如何通信? HTTP还是RPC?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这么多服务，如何治理? 服务的注册和发现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务挂了怎么办？熔断机制。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;有哪些主流微服务框架？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Netflix&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Alibaba&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SpringBoot +  Dubbo  +  ZooKeeper&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;SpringCloud有哪些核心组件？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2132564841498559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsseGgsbodK21icLPjC0XDm8GCP9VuVVYuQepLSbpvDib4JeCFKNsLtOpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2776&quot;/&gt;&lt;figcaption&gt;SpringCloud&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:微服务后面有机会再扩展，其实面试一般都是结合项目去问。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;big data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[1]. 《Spring揭秘》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[2]. 面试官：关于Spring就问这13个：https://mp.weixin.qq.com/s/-gLXHd_mylv_86sTMOgCBg&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[3]. 15个经典的Spring面试常见问题    ：https://mp.weixin.qq.com/s/OMlwHHnGcN7iZ8lerUvW7w&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[4].面试还不知道BeanFactory和ApplicationContext的区别？：https://juejin.cn/post/6844903877574131726&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[5]. Java面试中常问的Spring方面问题（涵盖七大方向共55道题，含答案：https://juejin.cn/post/6844903654659473416#heading-8&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[6] .Spring Bean 生命周期 （实例结合源码彻底讲透：https://segmentfault.com/a/1190000020747302&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[7]. @Autowired注解的实现原理 ：https://juejin.cn/post/6844903957135884295&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[8].万字长文，带你从源码认识Spring事务原理，让Spring事务不再是面试噩梦https://segmentfault.com/a/1190000022754620&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[9].【技术干货】Spring事务原理一探https://zhuanlan.zhihu.com/p/54067384&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[10]. Spring的声明式事务@Transactional注解的6种失效场景：https://blog.csdn.net/j1231230/article/details/105534599&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[11].Spring官网&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[12].Spring使用了哪些设计模式？：https://zhuanlan.zhihu.com/p/336671458&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[13].《精通Spring4.X企业应用开发实战》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;[14].Spring 中的bean 是线程安全的吗？：https://www.cnblogs.com/myseries/p/11729800.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;outline: 0px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; color: rgb(63, 63, 63); background-color: rgb(255, 255, 255); letter-spacing: 0.408px; font-size: 15px;&quot; class=&quot;js_darkmode__1118&quot;&gt;建了一个技术交流群，金三银四，面试聊的飞起！更有几十本群聊专属计算机图书！添加微信&lt;/span&gt;&lt;span data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(0, 128, 255)&quot; data-style=&quot;outline: 0px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255); letter-spacing: 0.408px; color: rgb(0, 128, 255);&quot; class=&quot;js_darkmode__1119&quot;&gt;&lt;strong data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(0, 128, 255)&quot;&gt;ThirdFighter&lt;/strong&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16471809271751=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16471809271751=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16471809271751=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16471809271751=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;outline: 0px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; color: rgb(63, 63, 63); background-color: rgb(255, 255, 255); letter-spacing: 0.408px; font-size: 15px;&quot; class=&quot;js_darkmode__1120&quot;&gt;，拉你入群。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;512&quot; data-backw=&quot;512&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeNacvtL2JaV9oyHhSVP7CAOVRdvOo9pRk4Js4kVtJblIcP4fBSf7Za5Nw0dwq2QHSYRJXvxxN6bw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;⭐&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;面渣逆袭系列&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9546cedde377c95b088208ff8da90ac2</guid>
<title>他，45岁，“华人首富”，无房无车——深度起底赵长鹏和他的数字货币</title>
<link>https://toutiao.io/k/qaeetcv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;本文内容节选自&lt;strong&gt;「码农周刊VIP会员专属邮件周报 Vol.088」&lt;/strong&gt;，感谢阅读。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;想邮件订阅周报？点此即刻订阅！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;想邮件订阅周报？点此即刻订阅！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibxN2ZVP72EwkSLibibWpkyHxCahAbvgsJEUBDOucdoMibBUer6RNpTOWYvricOllyKzjFTsBF7SnqK1A/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本期，首先分享的是&lt;strong&gt;如何记住所学的东西？&lt;/strong&gt;，摘录几条，供参考。&lt;br/&gt;1）学习要以时间为基础，定期休息，了解你好奇的是什么；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 2）学习的时候要清理工作记忆，应用元认知，用问题去“围攻”学习对象，改善理解； &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）课后要写高度概括的总结，细化，交叉学习，转化，并选出永远不能忘记的东西；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 4）课余跟朋友讨论自己学了什么，应用间隔重复来防止遗忘，并养成每天回忆的习惯；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 5）应用综合练习，通过对复杂环境的模式匹配来掌握知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;中国云市场的新逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/qSNURmWMfep20o-AwOoEFg&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;市场环境和政策环境都在变化，云公司的商业模型、技术模型、政策法规模型，以及自身定位均需重构。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;深度起底赵长鹏和他的数字货币&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/m71kjgIy3m4hKTgRXqzOqQ&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全球流浪的“华人首富”无房无车&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从 VSCode 看大型 IDE 技术架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/acuovgh&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;VSCode 开发团队从 10 来个人开始，早期成员大多有 Eclipse 开发团队的背景。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;知乎的用户画像与实时数据的架构与实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/0up430p&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实践经验和心得体会&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阿里巴巴开源的，帮助你快速搭建本地和云端 IDE 的框架&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/opensumi/core/blob/main/README-zh_CN.md&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;旨在解决阿里经济体内部 IDE 产品研发的重复建设问题，满足 IDE 在更多垂直场景的定制能力。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;一个开箱即用的，全周期的数据环境解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/macacajs/macaca-datahub/blob/master/README.zh.md&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持从本地开发阶段，到集成测试阶段，以及上线前验证阶段的一系列数据环境需求。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;成为一名优秀Java开发人员的7个步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/6kwaapq&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;供参考&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;万字长文教你用Go开发区块链应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/3f3i7ey&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一步步教你&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《非常时期囤货手册》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/toutiaoio/A-Guide-To-Stockpiling&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个可供选择的居家封闭情况下的商品列表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《区块链黑暗森林自救手册》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/slowmist/Blockchain-dark-forest-selfguard-handbook&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;供参考&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;想邮件订阅周报？点此即刻订阅！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078432&amp;amp;idx=2&amp;amp;sn=f1ba1fa5fbfbcf98a3e6f610b258cf05&amp;amp;chksm=bd2918178a5e9101b993d9e84d783562c995577cec855adf32ccb5946ff4da21fd6e89ba078e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibxN2ZVP72EwkSLibibWpkyHxyJ9h3jlN45cDia9gELfqK5QibDhPb4YXaryX2SQkhlwnwKlyHTuEc6Ag/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4f0f264b0bb756d67157b8b9baab1fdd</guid>
<title>2022年MySQL最新面试题 - MySQL存储引擎</title>
<link>https://toutiao.io/k/fud8xqa</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
    &lt;p id=&quot;app&quot;/&gt;
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
</channel></rss>