<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>36162b5c83a5985edd1279f7d086b428</guid>
<title>Spring：我是如何解决循环依赖的？</title>
<link>https://toutiao.io/k/ib9ck31</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它&lt;br/&gt;&lt;/span&gt;&lt;span&gt;1.由同事抛的一个问题开始&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近项目组的一个同事遇到了一个问题，问我的意见，一下子引起的我的兴趣，因为这个问题我也是第一次遇到。平时自认为对spring循环依赖问题还是比较了解的，直到遇到这个和后面的几个问题后，重新刷新了我的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看看当时出问题的代码片段：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两段代码中定义了两个Service类：&lt;code&gt;TestService1&lt;/code&gt;和&lt;code&gt;TestService2&lt;/code&gt;，在TestService1中注入了TestService2的实例，同时在TestService2中注入了TestService1的实例，这里构成了&lt;code&gt;循环依赖&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只不过，这不是普通的循环依赖，因为TestService1的test1方法上加了一个&lt;code&gt;@Async&lt;/code&gt;注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家猜猜程序启动后运行结果会怎样？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt;: Bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt; has been injected into other beans [testService2] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans &lt;span&gt;do&lt;/span&gt; not use the &lt;span&gt;final&lt;/span&gt; version of the bean. This is often the result of over-eager type matching - consider using &lt;span&gt;&#x27;getBeanNamesOfType&#x27;&lt;/span&gt; with the &lt;span&gt;&#x27;allowEagerInit&#x27;&lt;/span&gt; flag turned off, &lt;span&gt;for&lt;/span&gt; example.&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;报错了。。。原因是出现了循环依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「不科学呀，spring不是号称能解决循环依赖问题吗，怎么还会出现？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把上面的代码稍微调整一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把TestService1的test1方法上的&lt;code&gt;@Async&lt;/code&gt;注解去掉，&lt;code&gt;TestService1&lt;/code&gt;和&lt;code&gt;TestService2&lt;/code&gt;都需要注入对方的实例，同样构成了循环依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是重新启动项目，发现它能够正常运行。这又是为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这两个问题，让我们一起开始spring循环依赖的探秘之旅。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.什么是循环依赖？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环依赖：说白是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成了构成一个环形调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种情况：自己依赖自己的直接依赖&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8129496402877698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdab1MiacqG8bWAgwVmgR2TxRdfGQ9rXpjebRPQMYp6TWpcCP2JSnYajnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;278&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种情况：两个对象之间的直接依赖&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7660377358490567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdavaxrhQ63SHniaq8GRh4fUiblCiacKWUbWMszd9lCozZboxasMpib4NbxzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三种情况：多个对象之间的间接依赖&lt;img data-ratio=&quot;0.7452830188679245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdalIzucywZiaD9H5zicryDoywZevxJxGA0JvsrwY7tFhF7HA1En7Y0CgWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面两种情况的直接循环依赖比较直观，非常好识别，但是第三种间接循环依赖的情况有时候因为业务代码调用层级很深，不容易识别出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.循环依赖的N种场景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring中出现循环依赖主要有以下场景：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4099462365591398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaPIJyvkk8b7l74lEUVB6b1TkffX2Jve9doJia61IXhY4yOfMxibXOic0AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1488&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单例的setter注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方式应该是spring用的最多的，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个经典的循环依赖，但是它能正常运行，得益于spring的内部机制，让我们根本无法感知它有问题，因为spring默默帮我们解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring内部有三级缓存：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;earlySingletonObjects 二级缓存，用于保存实例化完成的bean实例&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;singletonFactories 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图告诉你，spring是如何解决循环依赖的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42983565107458915&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdamsWdZQX6cI6JQPa3P7icoepibDXoFEhC71juibDArKblEMcoBTRLRPMCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/p&gt;                           图1&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的朋友可能会发现在这种场景中第二级缓存作用不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，为什么要用第二级缓存呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一下，如果出现以下这种情况，我们要如何处理？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService3 testService3;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TestService1依赖于TestService2和TestService3，而TestService2依赖于TestService1，同时TestService3也依赖于TestService1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上图的流程可以把TestService1注入到TestService2，并且TestService1的实例是从第三级缓存中获取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设不用第二级缓存，TestService1注入到TestService3的流程如图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8112745098039216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaiagr5yOmaJYnNrSrg3IIshKHsX7ftEplChSfcY1CJGYcaaHCJXVCQnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;                         图2&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TestService1注入到TestService3又需要从第三级缓存中获取实例，而第三级缓存里保存的并非真正的实例对象，而是&lt;code&gt;ObjectFactory&lt;/code&gt;对象。说白了，两次从三级缓存中获取都是&lt;code&gt;ObjectFactory&lt;/code&gt;对象，而通过它创建的实例对象每次可能都不一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样不是有问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，spring引入的第二级缓存。上面图1其实TestService1对象的实例已经被添加到第二级缓存中了，而在TestService1注入到TestService3时，只用从第二级缓存中获取该对象即可。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8606965174129353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdadMXFsagwicrE2kkH8jsyADzPWI2uzZckTlfWYKwOdC0EgDHC5ZENib4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;                         图3&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个问题，第三级缓存中为什么要添加&lt;code&gt;ObjectFactory&lt;/code&gt;对象，直接保存实例对象不行吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：不行，因为假如你想对添加到三级缓存中的实例对象进行增强，直接用实例对象是行不通的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种场景spring是怎么做的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案就在&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;类&lt;code&gt;doCreateBean&lt;/code&gt;方法的这段代码中：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20678513731825526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaT8TrEslDkSfIQcjSZKUFeeRBdz9OtNOzBNpfdK6YLZNlWuvoF0KaFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;它定义了一个匿名内部类，通过&lt;code&gt;getEarlyBeanReference&lt;/code&gt;方法获取代理对象，其实底层是通过&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;类的&lt;code&gt;getEarlyBeanReference&lt;/code&gt;生成代理对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多例的setter注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方法偶然会有，特别是在多线程的场景下，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Scope&lt;/span&gt;(ConfigurableBeanFactory.SCOPE_PROTOTYPE)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Scope&lt;/span&gt;(ConfigurableBeanFactory.SCOPE_PROTOTYPE)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人说这种情况spring容器启动会报错，其实是不对的，我非常负责任的告诉你程序能够正常启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在&lt;code&gt;AbstractApplicationContext&lt;/code&gt;类的&lt;code&gt;refresh&lt;/code&gt;方法中告诉了我们答案，它会调用&lt;code&gt;finishBeanFactoryInitialization&lt;/code&gt;方法，该方法的作用是为了spring容器启动的时候提前初始化一些bean。该方法的内部又调用了&lt;code&gt;preInstantiateSingletons&lt;/code&gt;方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2989949748743719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaTQBCg36QQXBibaO7X3kXKibCO9QOe28icI89qnyc0Szqp2PnIs5WC4y7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1592&quot;/&gt;标红的地方明显能够看出：非抽象、单例 并且非懒加载的类才能被提前初始bean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而多例即&lt;code&gt;SCOPE_PROTOTYPE&lt;/code&gt;类型的类，非单例，不会被提前初始化bean，所以程序能够正常启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何让他提前初始化bean呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要再定义一个单例的类，在它里面注入TestService1&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新启动程序，执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Requested bean is currently in creation: Is there an unresolvable circular reference?&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然出现了循环依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：这种循环依赖问题是无法解决的，因为它没有用缓存，每次都会生成一个新对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构造器注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方式现在其实用的已经非常少了，但是我们还是有必要了解一下，看看如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt;&lt;span&gt;(TestService2 testService2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt;&lt;span&gt;(TestService1 testService1)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Requested bean is currently in creation: Is there an unresolvable circular reference?&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现了循环依赖，为什么呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.503125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdat0en0PHBL6WAqHKrbxU38nxZuZCDWxVTE9iazcKYA49FTseCYIlDxbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中的流程看出构造器注入没能添加到三级缓存，也没有使用缓存，所以也无法解决循环依赖问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单例的代理对象setter注入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入方式其实也比较常用，比如平时使用：&lt;code&gt;@Async&lt;/code&gt;注解的场景，会通过&lt;code&gt;AOP&lt;/code&gt;自动生成代理对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我那位同事的问题也是这种情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面得知程序启动会报错，出现了循环依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt;: Bean with name &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt; has been injected into other beans [testService2] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans &lt;span&gt;do&lt;/span&gt; not use the &lt;span&gt;final&lt;/span&gt; version of the bean. This is often the result of over-eager type matching - consider using &lt;span&gt;&#x27;getBeanNamesOfType&#x27;&lt;/span&gt; with the &lt;span&gt;&#x27;allowEagerInit&#x27;&lt;/span&gt; flag turned off, &lt;span&gt;for&lt;/span&gt; example.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么会循环依赖呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案就在下面这张图中：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4796437659033079&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFGL7IIEBJVKfAH6rmxY4x2fpBia7zqapW1Q8ZF601661Iq2NIwHYjrRv64TGnuQZy8yF3hB08RLMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1572&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，bean初始化完成之后，后面还有一步去检查：第二级缓存 和 原始对象 是否相等。由于它对前面流程来说无关紧要，所以前面的流程图中省略了，但是在这里是关键点，我们重点说说：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5504694835680751&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdaljic3Aany2iagBQWRRkozUhz33XoJ7WrOyhQgdcqjcHEefic9Wcjne6FA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1704&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那位同事的问题&lt;/span&gt;正好是走到这段代码，发现第二级缓存 和 原始对象不相等，所以抛出了循环依赖的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这时候把TestService1改个名字，改成：&lt;span&gt;TestService6，其他的都不变。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService6&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再重新启动一下程序，神奇般的好了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;what？ 这又是为什么？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就要从spring的bean加载顺序说起了，默认情况下，spring是按照文件完整路径递归查找的，按路径+文件名排序，排在前面的先加载。所以TestService1比&lt;span&gt;TestService2先加载，而改了文件名称之后，&lt;span&gt;TestService2比&lt;span&gt;TestService6先加载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么&lt;span&gt;TestService2比TestService6先加载就没问题呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在下面这张图中：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42710997442455245&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDFGL7IIEBJVKfAH6rmxY4x2rJRtXBATowdxrBjNMWjQjoSicB8J62b4YmjvR0ySmB4TGCDUicdwjbFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种情况testService6中其实第二级缓存是空的，不需要跟原始对象判断，所以不会抛出循环依赖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DependsOn循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种有些特殊的场景，比如我们需要在实例化Bean A之前，先实例化Bean B，这个时候就可以使用&lt;code&gt;@DependsOn&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@DependsOn&lt;/span&gt;(value = &lt;span&gt;&quot;testService2&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService2 testService2;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@DependsOn&lt;/span&gt;(value = &lt;span&gt;&quot;testService1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TestService1 testService1;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序启动之后，执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Circular depends-on relationship between &lt;span&gt;&#x27;testService2&#x27;&lt;/span&gt; and &lt;span&gt;&#x27;testService1&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中本来如果TestService1和TestService2都没有加&lt;code&gt;@DependsOn&lt;/code&gt;注解是没问题的，反而加了这个注解会出现循环依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这又是为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在&lt;code&gt;AbstractBeanFactory&lt;/code&gt;类的&lt;code&gt;doGetBean&lt;/code&gt;方法的这段代码中：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4193121693121693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdatjJjSxMkoh2RyVA8KFJRiaedv4hibjoicKmfySdiaEs74dApoBib7T4CdfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot;/&gt;它会检查dependsOn的实例有没有循环依赖，如果有循环依赖则抛异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.出现循环依赖如何解决？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目中如果出现循环依赖问题，说明是spring默认无法解决的循环依赖，要看项目的打印日志，属于哪种循环依赖。目前包含下面几种情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3230994152046784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDF24t3FjrB8Xebx7WgkAxdasczlqnRGRlE3q0wZzZTe2OYezTV26IMTJK8W7ddViceaKLLjMM0V98A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生成代理对象产生的循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题解决方法很多，主要有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;@Lazy&lt;/code&gt;注解，延迟加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;@DependsOn&lt;/code&gt;注解，指定加载先后关系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改文件名称，改变循环依赖类的加载顺序&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用@DependsOn产生的循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题要找到&lt;code&gt;@DependsOn&lt;/code&gt;注解循环依赖的地方，迫使它不循环依赖就可以解决问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多例循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题可以通过把bean改成单例的解决。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构造器循环依赖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类循环依赖问题可以通过使用&lt;code&gt;@Lazy&lt;/code&gt;注解解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2b043ad00bd1ea513b4df4009fe3696f</guid>
<title>让 API 并行调用变得如丝般顺滑的绝招</title>
<link>https://toutiao.io/k/itzxhci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数据量较大的时候，都会通过分库分表来拆分，分担读写的压力。分库分表后比较麻烦的就是查询的问题，如果不是直接根据分片键去查询的话，需要对多个表进行查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一些复杂的业务场景下，比如订单搜索，除了订单号，用户，商家 这些常用的搜索条件，可能还有时间，商品等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前常见的做法将数据同步到 ES 这类搜索框架中进行查询，然后通过搜出来的结果，一般是主键 ID, 再去具体的数据表中查询完整的数据，组装返回给调用方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面这段代码，首先查询出文章信息，然后根据文章中的用户 ID 去查询用户的昵称。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;ArticleBO&amp;gt; articleBos = articleDoPage.getRecords().stream().map(r -&amp;gt; {&lt;br/&gt;    String nickname = userManager.getNickname(r.getUserId());&lt;br/&gt;    return articleBoConvert.convertPlus(r, nickname);&lt;br/&gt;}).collect(Collectors.toList());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果文章有 10 条数据，那么就需要调用 10 次用户服务提供的接口，而且是同步调用操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们也可以用并行流来实现并发调用，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;ArticleBO&amp;gt; articleBos = articleDoPage.getRecords().parallelStream().map(r -&amp;gt; {&lt;br/&gt;    String nickname = userManager.getNickname(r.getUserId());&lt;br/&gt;    return articleBoConvert.convertPlus(r, nickname);&lt;br/&gt;}).collect(Collectors.toList());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并行流的优点很明显，代码不用做特别大的改动。需要注意如果用并行流，最好单独定义一个 ForkJoinPool。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了用并行流，还可以使用批量查询的方式来提高性能，降低 RPC 的调用次数，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Long&amp;gt; userIds = articleDoPage.getRecords().stream().map(article -&amp;gt; article.getUserId()).collect(Collectors.toList());&lt;br/&gt;Map&amp;lt;Long, String&amp;gt; nickNameMap = userManager.queryByIds(userIds).stream().collect(Collectors.toMap(UserResponse::getId, UserResponse::getNickname));&lt;br/&gt;List&amp;lt;ArticleBO&amp;gt; articleBos = articleDoPage.getRecords().stream().map(r -&amp;gt; {&lt;br/&gt;    String nickname = nickNameMap.containsKey(r.getUserId()) ? nickNameMap.get(r.getUserId()) : CommonConstant.DEFAULT_EMPTY_STR;&lt;br/&gt;    return articleBoConvert.convertPlus(r, nickname);&lt;br/&gt;}).collect(Collectors.toList());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但批量查询还是同步模式，下面介绍如果使用 CompletableFuture 来实现异步并发调用，直接用原生的 CompletableFuture 也可以，但是编排能力没有那么强，这里我们选择一款基于 CompletableFuture 封装的并行编排框来实现，详细介绍查看我之前的这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;amp;mid=2650321192&amp;amp;idx=1&amp;amp;sn=8ea8cf7c4a3402bd42e74c7dbef1d5b5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/3EE8ccydK16gC1oY4AWnoA&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微做了下封装，提供了更方便使用的工具类来实现并发调用多个接口的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式，适用于比如从 ES 查出了一批 ID, 然后根据 ID 去数据库中或者调用 RPC 查询真实数据，最后得到一个 Map，可以根据 Key 获取对应的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部是多线程并发调用，会等到结果全部返回。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public Object aggregationApi() {&lt;br/&gt;    long s = System.currentTimeMillis();&lt;br/&gt;    List&amp;lt;String&amp;gt; ids = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    ids.add(&quot;1&quot;);&lt;br/&gt;    ids.add(&quot;2&quot;);&lt;br/&gt;    ids.add(&quot;3&quot;);&lt;br/&gt;    Map&amp;lt;String, UserResponse&amp;gt; callResult = AsyncTemplate.call(ids, id -&amp;gt; {&lt;br/&gt;        return userService.getUser(id);&lt;br/&gt;    }, u -&amp;gt; u.getId(), COMMON_POOL);&lt;br/&gt;    long e = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&quot;耗时：&quot; + (e-s) + &quot;ms&quot;);&lt;br/&gt;    return &quot;&quot;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个场景就是 API 聚合的场景，需要并行调用多个接口，将结果进行组装。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;AsyncCall&amp;gt; params = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;AsyncCall&amp;lt;Integer, Integer&amp;gt; goodsQuery = new AsyncCall(&quot;goodsQuery&quot;, 1);&lt;br/&gt;params.add(goodsQuery);&lt;/code&gt;&lt;code&gt;AsyncCall&amp;lt;String, OrderResponse&amp;gt; orderQuery = new AsyncCall(&quot;orderQuery&quot;, &quot;100&quot;);&lt;br/&gt;params.add(orderQuery);&lt;/code&gt;&lt;code&gt;UserQuery q = new UserQuery();&lt;br/&gt;q.setAge(18);&lt;br/&gt;q.setName(&quot;yinjihuan&quot;);&lt;br/&gt;AsyncCall&amp;lt;UserQuery, UserResponse&amp;gt; userQuery = new AsyncCall(&quot;userQuery&quot;, q);&lt;br/&gt;params.add(userQuery);&lt;/code&gt;&lt;code&gt;AsyncTemplate.call(params, p -&amp;gt; {&lt;br/&gt;    if (p.getTaskId().equals(&quot;goodsQuery&quot;)) {&lt;br/&gt;        AsyncCall&amp;lt;Integer, Integer&amp;gt; query = p;&lt;br/&gt;        return goodsService.getGoodsName(query.getParam());&lt;br/&gt;    }&lt;br/&gt;    if (p.getTaskId().equals(&quot;orderQuery&quot;)) {&lt;br/&gt;        AsyncCall&amp;lt;String, OrderResponse&amp;gt; query = p;&lt;br/&gt;        return orderService.getOrder(query.getParam());&lt;br/&gt;    }&lt;br/&gt;    if (p.getTaskId().equals(&quot;userQuery&quot;)) {&lt;br/&gt;        AsyncCall&amp;lt;UserQuery, UserResponse&amp;gt; query = p;&lt;br/&gt;        return userService.getUser(query.getParam());&lt;br/&gt;    }&lt;br/&gt;    return null;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AsyncCall 中定义参数和响应的类型，响应结果会在执行完后会自动设置到 AsyncCall 中。在 call 方法中需要根据 taskId 去做对应的处理逻辑，不同的 taskId 调用的接口不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码参考：https://github.com/yinjihuan/kitty&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号 &lt;strong&gt;猿天地&lt;/strong&gt; 发起人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有收获，不要吝啬你的转发和在看。&lt;/strong&gt;&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1b354f85026b15c9ac770f94d4c22458</guid>
<title>深入浅出 ZooKeeper</title>
<link>https://toutiao.io/k/8555w9e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 是一个分布式协调服务 ，由 Apache 进行维护。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 可以视为一个高可用的文件系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 可以用于发布/订阅、负载均衡、命令服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能 。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、ZooKeeper 简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 ZooKeeper 是什么&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 是 Apache 的顶级项目。&lt;strong&gt;ZooKeeper 为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名服务、配置管理和分布式锁等分布式的基础服务。在解决分布式数据一致性方面，ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储。但是 ZooKeeper 并不是用来专门存储数据的，它的作用主要是用来&lt;strong&gt;维护和监控存储数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多大名鼎鼎的框架都基于 ZooKeeper 来实现分布式高可用，如：Dubbo、Kafka 等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 ZooKeeper 的特性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 具有以下特性：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;顺序一致性：&lt;/strong&gt;所有客户端看到的服务端数据模型都是一致的；从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 ZooKeeper 中。具体的实现可见下文：原子广播。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;原子性：&lt;/strong&gt;所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。实现方式可见下文：事务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;单一视图：&lt;/strong&gt;无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;高性能：&lt;/strong&gt;ZooKeeper 将数据全量存储在内存中，所以其性能很高。需要注意的是：由于 ZooKeeper 的所有更新和删除都是基于事务的，因此 ZooKeeper 在读多写少的应用场景中有性能表现较好，如果写操作频繁，性能会大大下滑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;高可用：&lt;/strong&gt;ZooKeeper 的高可用是基于副本机制实现的，此外 ZooKeeper 支持故障恢复，可见下文：选举 Leader。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 ZooKeeper 的设计目标&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、ZooKeeper 核心概念&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1  数据模型&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 的数据模型是一个树形结构的文件系统。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;树中的节点被称为 znode，其中根节点为 /，每个节点上都会保存自己的数据和节点信息。znode 可以用于存储数据，并且有一个与之相关联的 ACL（详情可见 ACL）。ZooKeeper 的设计目标是实现协调服务，而不是真的作为一个文件存储，因此 znode 存储数据的&lt;strong&gt;大小被限制在 1MB 以内。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1yzmxHa5ibd27YdR8OtnMcibcZHMzPKyoNYL2nRv6SstlZWrYF5M5bzaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 的数据访问具有原子性。&lt;/strong&gt;其读写操作都是要么全部成功，要么全部失败。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;znode 通过路径被引用。&lt;strong&gt;znode 节点路径必须是绝对路径。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;znode 有两种类型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2  节点信息&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;znode 上有一个&lt;strong&gt;顺序标志（ SEQUENTIAL ）&lt;/strong&gt;。如果在创建 znode 时，设置了&lt;strong&gt;顺序标志（ SEQUENTIAL ）&lt;/strong&gt;，那么 ZooKeeper 会使用计数器为 znode 添加一个单调递增的数值，即 zxid。ZooKeeper 正是利用 zxid 实现了严格的顺序访问控制能力。&lt;/p&gt;&lt;p&gt;每个 znode 节点在存储数据的同时，都会维护一个叫做 Stat 的数据结构，里面存储了关于该节点的全部状态信息。如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8061224489795918&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1wOtlOHSMVDFlOItYbYJyUNSwHnI3q7ibpf9rwrSBLdI7jgueCMiavlEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;588&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 集群角色&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Leader：&lt;/strong&gt;它负责 发起并维护与各 Follwer 及 Observer 间的心跳。所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Follower：&lt;/strong&gt;它会响应 Leader 的心跳。Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，并且负责在 Leader 处理写请求时对请求进行投票。一个 Zookeeper 集群可能同时存在多个 Follower。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Observer：&lt;/strong&gt;角色与 Follower 类似，但是无投票权。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.4 ACL&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 采用 ACL（Access Control Lists）策略来进行权限控制。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;每个 znode 创建时都会带有一个 ACL 列表，用于决定谁可以对它执行何种操作。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ACL 依赖于 ZooKeeper 的客户端认证机制。ZooKeeper 提供了以下几种认证方式：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;digest：&lt;/strong&gt; 用户名和密码 来识别客户端&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;sasl：&lt;/strong&gt;通过 kerberos 来识别客户端&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ip：&lt;/strong&gt;通过 IP 来识别客户端&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 定义了如下五种权限：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;CREATE：&lt;/strong&gt;允许创建子节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;READ：&lt;/strong&gt;允许从节点获取数据并列出其子节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;WRITE：&lt;/strong&gt; 允许为节点设置数据；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;DELETE：&lt;/strong&gt;允许删除子节点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ADMIN：&lt;/strong&gt; 允许为节点设置权限。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、ZooKeeper 工作原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 读操作&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Leader/Follower/Observer 都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由于处理读请求不需要服务器之间的交互，&lt;strong&gt;Follower/Observer 越多，整体系统的读请求吞吐量越大&lt;/strong&gt;，也即读性能越好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.56484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1dhXnDydcAstc0A3pZ3f2oGpK5eNDolHVCwFEN47puwqzC5r0GoKiaNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 写操作&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;所有的写请求实际上都要交给 Leader 处理。Leader 将写请求以事务形式发给所有 Follower 并等待 ACK，一旦收到半数以上 Follower 的 ACK，即认为写操作成功。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 写 Leader&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7254138266796495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1tib4Vgvdz1YeqsNCmkV8cdMASqdQN1qACrC6gOq8UNRfKT31Dbf6ibBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1027&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由上图可见，通过 Leader 进行写操作，主要分为五步：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端向 Leader 发起写请求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 将写请求以事务 Proposal 的形式发给所有 Follower 并等待 ACK。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower 收到 Leader 的事务 Proposal 后返回 ACK。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 得到过半数的 ACK（Leader 对自己默认有一个 ACK）后向所有的 Follower 和 Observer 发送 Commmit。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 将处理结果返回给客户端。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader 不需要得到 Observer 的 ACK，即 Observer 无投票权。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 不需要得到所有 Follower 的 ACK，只要收到过半的 ACK 即可，同时 Leader 本身对自己有一个 ACK。上图中有 4 个 Follower，只需其中两个返回 ACK 即可，因为 $$(2+1) / (4+1) &amp;gt; 1/2$$ 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Observer 虽然无投票权，但仍须同步 Leader 的数据从而在处理读请求时可以返回尽可能新的数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 写 Follower/Observer&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.56484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1tHib7tFoGrCHszkPhbSaIkufRP1yHLZ6eKod1ppDictibjDqPhag9AO2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Follower/Observer 均可接受写请求，但不能直接处理，而需要将写请求转发给 Leader 处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了多了一步请求转发，其它流程与直接写 Leader 无任何区别。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 事务&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于来自客户端的每个更新请求，ZooKeeper 具备严格的顺序访问控制能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 id 号（zxid）来标识事务。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Leader 服务会为每一个 Follower 服务器分配一个单独的队列，然后将事务 Proposal 依次放入队列中，并根据 FIFO(先进先出) 的策略进行消息发送。&lt;/strong&gt;Follower 服务在接收到 Proposal 后，会将其以事务日志的形式写入本地磁盘中，并在写入成功后反馈给 Leader 一个 Ack 响应。&lt;strong&gt;当 Leader 接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 以通知其进行事务提交，&lt;/strong&gt;之后 Leader 自身也会完成对事务的提交。而每一个 Follower 则在接收到 Commit 消息后，完成事务的提交。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所有的提议（proposal）都在被提出的时候加上了 zxid。zxid 是一个 64 位的数字，它的高 32 位是 epoch 用来标识 Leader 关系是否改变，每次一个 Leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;详细过程如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader 等待 Server 连接；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower 连接 Leader，将最大的 zxid 发送给 Leader；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 根据 Follower 的 zxid 确定同步点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;完成同步后通知 follower 已经成为 uptodate 状态；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4 观察&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;客户端注册监听它关心的 znode，当 znode 状态发生变化（数据变化、子节点增减变化）时，ZooKeeper 服务会通知客户端。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端和服务端保持连接一般有两种形式：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 的选择是服务端主动推送状态，也就是观察机制（ Watch ）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZooKeeper 的观察机制允许用户在指定节点上针对感兴趣的事件注册监听，当事件发生时，监听器会被触发，并将事件信息推送到客户端。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端使用 getData 等接口获取 znode 状态时传入了一个用于处理节点变更的回调，那么服务端就会主动向客户端推送节点的变更：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从这个方法中传入的 Watcher 对象实现了相应的 process 方法，每次对应节点出现了状态的改变，WatchManager 都会通过以下的方式调用传入 Watcher 的方法：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Set&lt;/span&gt;&amp;lt;Watcher&amp;gt; triggerWatch(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; path, EventType type, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Set&lt;/span&gt;&amp;lt;Watcher&amp;gt; supress) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    WatchedEvent e = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; WatchedEvent(type, KeeperState.SyncConnected, path);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Set&lt;/span&gt;&amp;lt;Watcher&amp;gt; watchers;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    synchronized (&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        watchers = watchTable.remove(path);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Watcher w : watchers) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        w.process(e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 中的所有数据其实都是由一个名为 DataTree 的数据结构管理的，所有的读写数据的请求最终都会改变这颗树的内容，在发出读请求时可能会传入 Watcher 注册一个回调函数，而写请求就可能会触发相应的回调，由 WatchManager 通知客户端数据的变化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通知机制的实现其实还是比较简单的，通过读请求设置 Watcher 监听事件，写请求在触发事件时就能将通知发送给指定的客户端。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 会话&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 客户端通过 TCP 长连接连接到 ZooKeeper 服务集群。会话 (Session) 从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态&lt;/strong&gt;。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watch 事件的通知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个 ZooKeeper 客户端配置中都配置了 ZooKeeper 服务器集群列表。启动时，客户端会遍历列表去尝试建立连接。如果失败，它会尝试连接下一个服务器，依次类推。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一旦一台客户端与一台服务器建立连接，这台服务器会为这个客户端创建一个新的会话。&lt;strong&gt;每个会话都会有一个超时时间，若服务器在超时时间内没有收到任何请求，则相应会话被视为过期。&lt;/strong&gt;一旦会话过期，就无法再重新打开，且任何与该会话相关的临时 znode 都会被删除。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常来说，会话应该长期存在，而这需要由客户端来保证。客户端可以通过心跳方式（ping）来保持会话不过期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1909975669099757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1S7ZgGlaI90serCplVsbpaGxx2bFvrFoqtSJgay9FHF1iapbk5WjzFdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 的会话具有四个属性：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;sessionID：&lt;/strong&gt;会话 ID，唯一标识一个会话，每次客户端创建新的会话时，Zookeeper 都会为其分配一个全局唯一的 sessionID。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;TimeOut：&lt;/strong&gt;会话超时时间，客户端在构造 Zookeeper 实例时，会配置 sessionTimeout 参数用于指定会话的超时时间，Zookeeper 客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;TickTime：&lt;/strong&gt;下次会话超时时间点，为了便于 Zookeeper 对会话实行”分桶策略”管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper 会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上 TimeOut。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;isClosing：&lt;/strong&gt;标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的 isClosing 标记为”已关闭”，这样就能确保不再处理来自该会话的新请求了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Zookeeper 的会话管理主要是通过 SessionTracker 来负责，其采用了&lt;strong&gt;分桶策略&lt;/strong&gt;（将类似的会话放在同一区块中进行管理）进行管理，以便 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、ZAB 协议&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 并没有直接采用 Paxos 算法，而是采用了名为 ZAB 的一致性协议。ZAB 协议不是 Paxos 算法，只是比较类似，二者在操作上并不相同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZAB 协议是 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZAB 协议是 ZooKeeper 的数据一致性和高可用解决方案。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZAB 协议定义了两个可以&lt;strong&gt;无限循环&lt;/strong&gt;的流程：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 选举 Leader&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 的故障恢复&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 集群采用一主（称为 Leader）多从（称为 Follower）模式，主从节点通过副本机制保证数据一致。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZAB 协议的选举 Leader 机制简单来说，就是：基于过半选举机制产生新的 Leader，之后其他机器将从新的 Leader 上同步状态，当有过半机器完成状态同步后，就退出选举 Leader 模式，进入原子广播模式。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.1 术语&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;myid：&lt;/strong&gt;每个 Zookeeper 服务器，都需要在数据文件夹下创建一个名为 myid 的文件，该文件包含整个 Zookeeper 集群唯一的 ID（整数）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;zxid：&lt;/strong&gt;类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal ID。为了保证顺序性，该 zkid 必须单调递增。因此 Zookeeper 使用一个 64 位的数来表示，高 32 位是 Leader 的 epoch，从 1 开始，每次选出新的 Leader，epoch 加一。低 32 位为该 epoch 内的序号，每次 epoch 变化，都将低 32 位的序号重置。这样保证了 zkid 的全局递增性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.2 服务器状态&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;LOOKING：&lt;/strong&gt;不确定 Leader 状态。该状态下的服务器认为当前集群中没有 Leader，会发起 Leader 选举。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;FOLLOWING：&lt;/strong&gt;跟随者状态。表明当前服务器角色是 Follower，并且它知道 Leader 是谁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;LEADING：&lt;/strong&gt;领导者状态。表明当前服务器角色是 Leader，它会维护与 Follower 间的心跳。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;OBSERVING：&lt;/strong&gt;观察者状态。表明当前服务器角色是 Observer，与 Folower 唯一的不同在于不参与选举，也不参与集群写操作时的投票。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.3 选票数据结构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;每个服务器在进行领导选举时，会发送如下关键信息：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;logicClock：&lt;/strong&gt;每个服务器会维护一个自增的整数，名为 logicClock，它表示这是该服务器发起的第多少轮投票。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;state：&lt;/strong&gt;当前服务器的状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;self_id：&lt;/strong&gt;当前服务器的 myid。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;self_zxid：&lt;/strong&gt;当前服务器上所保存的数据的最大 zxid。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;vote_id：&lt;/strong&gt;被推举的服务器的 myid。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;vote_zxid：&lt;/strong&gt;被推举的服务器上所保存的数据的最大 zxid。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.4 投票流程&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）自增选举轮次&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Zookeeper 规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的 logicClock 进行自增操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）初始化选票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器 2 投票给服务器 3，服务器 3 投票给服务器 1，则服务器 1 的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）发送初始化选票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每个服务器最开始都是通过广播把票投给自己。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（4）接收外部投票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（5）判断选举轮次&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到外部投票后，首先会根据投票信息中所包含的 logicClock 来进行不同处理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;外部投票的 logicClock &lt;strong&gt;大于&lt;/strong&gt;自己的 logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的 logicClock 更新为收到的 logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外部投票的 logicClock &lt;strong&gt;小于&lt;/strong&gt;自己的 logicClock。当前服务器直接忽略该投票，继续处理下一个投票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外部投票的 logickClock 与自己的&lt;strong&gt;相等&lt;/strong&gt;。当时进行选票 PK。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（6）选票 PK&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;选票 PK 是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;外部投票的 logicClock &lt;strong&gt;大于&lt;/strong&gt;自己的 logicClock，则将自己的 logicClock 及自己的选票的 logicClock 变更为收到的 logicClock。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若&lt;strong&gt; logicClock&lt;/strong&gt; &lt;strong&gt;一致&lt;/strong&gt;，则对比二者的 vote_zxid，若外部投票的 vote_zxid 比较大，则将自己的票中的 vote_zxid 与 vote_myid 更新为收到的票中的 vote_zxid 与 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若二者 &lt;strong&gt;vote_zxid &lt;/strong&gt;一致，则比较二者的 vote_myid，若外部投票的 vote_myid 比较大，则将自己的票中的 vote_myid 更新为收到的票中的 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（7）统计选票&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（8）更新服务器状态&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为 LEADING，否则将自己的状态更新为 FOLLOWING。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过以上流程分析，我们不难看出：要使 Leader 获得多数 Server 的支持，则 &lt;strong&gt;ZooKeeper 集群节点数必须是奇数。且存活的节点数目不得少于 N + 1 &lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 原子广播（Atomic Broadcast）&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;ZooKeeper 通过副本机制来实现高可用。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么，ZooKeeper 是如何实现副本机制的呢？答案是：ZAB 协议的原子广播。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.56484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1dhXnDydcAstc0A3pZ3f2oGpK5eNDolHVCwFEN47puwqzC5r0GoKiaNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZAB 协议的原子广播要求：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;所有的写请求都会被转发给 Leader，Leader 会以原子广播的方式通知 Follow。当半数以上的 Follow 已经更新状态持久化后，Leader 才会提交这个更新，然后客户端才会收到一个更新成功的响应。&lt;/strong&gt;这有些类似数据库中的两阶段提交协议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在整个消息的广播过程中，Leader 服务器会每个事物请求生成对应的 Proposal，并为其分配一个全局唯一的递增的事务 ID(ZXID)，之后再对其进行广播。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、ZooKeeper 应用&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 可以用于发布/订阅、负载均衡、命令服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能 。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.1 命名服务&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在分布式系统中，通常需要一个全局唯一的名字，如生成全局唯一的订单号等，ZooKeeper 可以通过顺序节点的特性来生成全局唯一 ID，从而可以对分布式系统提供命名服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2413793103448276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1bwosa3gkiaz0rlKO7RP4LSdEXfs3aHx2kX3XQMvZASeql67ytic5GnvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.2 配置管理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;利用 ZooKeeper 的观察机制，可以将其作为一个高可用的配置存储器，允许分布式应用的参与者检索和更新配置文件。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.3 分布式锁&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以通过 ZooKeeper 的临时节点和 Watcher 机制来实现分布式锁。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举例来说，有一个分布式系统，有三个节点 A、B、C，试图通过 ZooKeeper 获取分布式锁。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）访问 /lock （这个目录路径由程序自己决定），创建 &lt;strong&gt;带序列号的临时节点（EPHEMERAL） 。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9362606232294618&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1Ms2gbZLs19ThRZXgngZPGrHMoGZ816icf3a8jNCia0MolMZtO08xusibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（2）每个节点尝试获取锁时，拿到 /locks节点下的所有子节点（id_0000,id_0001,id_0002），&lt;strong&gt;判断自己创建的节点是不是最小的。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果是，则拿到锁。&lt;/p&gt;&lt;p&gt;释放锁：执行完操作后，把创建的节点给删掉。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果不是，则监听比自己要小 1 的节点变化。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9514705882352941&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1q0ibnRQsb9ToAZKQkicuBSIK26kRPe3ETvQMibaccPQP3AEBcEoqnPPXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（3）释放锁，即删除自己创建的节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9741641337386018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY191iaCtYo2y5Eic2PYy1J8ic9OrfapicofMqPcZ9KLQKzAGo26FibekWIzUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图中，NodeA 删除自己创建的节点 id_0000，NodeB 监听到变化，发现自己的节点已经是最小节点，即可获取到锁。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.4 集群管理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 还能解决大多数分布式系统中的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.5 选举 Leader 节点&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;分布式系统一个重要的模式就是主从模式 (Master/Salves)，ZooKeeper 可以用于该模式下的 Matser 选举。可以让所有服务节点去竞争性地创建同一个 ZNode，由于 ZooKeeper 不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，这样该服务节点就可以成为 Master 节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;5.6 队列管理&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ZooKeeper 可以处理两种类型的队列：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;同步队列用 ZooKeeper 实现的实现思路如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;官方&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;书籍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;文章&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>02704f09c2dfd4cceb98f7b244698104</guid>
<title>进程：程序是如何启动的</title>
<link>https://toutiao.io/k/5viayyn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;代码编译出来后得到可执行文件，也就是我们常说的程序。都说进程是运行起来的程序，那&lt;span&gt;&lt;strong&gt;程序是如何启动的呢？程序和进程究竟有哪些区别呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;早期的计算机只运行一个程序，所以可以想到的是 CPU 的利用率是多么的低，为了让 CPU 利用率得到有效的提高，工程师们设计了一个方案：加载多个程序到内存中，让它们并发运行，而操作系统控制着这些程序运行状态，这些运行的程序就是我们所谓的进程。虽然有多个程序并发执行任务，但&lt;span&gt;&lt;strong&gt;每个进程在运行过程中都会认为自己独占 CPU  资源、内存资源等，以为整个计算机的硬件资源都是它的&lt;/strong&gt;&lt;/span&gt;。这是操作系统的设计哲学：进程你尽管大胆的往前跑，你要什么我都给你准备好了，你跑起来就对了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还记得之前有篇是专门计算机是如何启动的吗？没有看过的同学可以看这里 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTM0NDEzNw==&amp;amp;mid=2247483756&amp;amp;idx=1&amp;amp;sn=067ae863c4a3fe247e2606e34cf2b104&amp;amp;chksm=fbd4890acca3001c841915c5256779127642517e31148d419a8b58d1afd5df2024b93a838ee3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;3.你知道计算机是如何启动的吗？&lt;/a&gt;。当 BIOS 固件将操作系统内核装载进内存执行后产生了第一个进程，一般来说将这个进程称为进程 0，它的作用是对所有内核核心数据结构进行预先赋值。紧接着创建出一个 init 进程。进程 0 是所有进程的祖先，其他进程要么是它的子进程，要么是它的子孙进程。既然内核进程有 BIOS 固件帮它启动，普通进程是如何启动的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 linux 系统中提供了两个重要的系统调用（系统函数）：&lt;span&gt;&lt;strong&gt;fork()、exec()&lt;/strong&gt;&lt;/span&gt;，利用好这两个函数就可以启动一个进程。步骤是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;先用 fork() 函数创建一个新的进程&lt;/strong&gt;&lt;/span&gt;。注意：这个新的进程比较特殊！它会&lt;span&gt;&lt;strong&gt;将父进程的资源内存地址都复制到自己的内存空间&lt;/strong&gt;&lt;/span&gt;，也就是说，它会和父进程共享父进程的资源。有人就问了：哪来的父进程？为什么要共享父进程的资源？第一个问题：谁来创建出这个新进程就是父进程，比如进程 1 是进程 0 创建出来，那进程 0 就是进程 1 的父进程，有没有进程是没有父进程的？有，且只有一个，就是进程 0，其他都是有父进程的，它们的关系就如同一棵树一样。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1698513800424628&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/pMAe7v8MucibAUnLWrHLMWicUpKQE2ezWD2P2EzpuWt5NzWPJmT3aLKR0kQyFyZXDHvX6HQLicUtiaRfENSquLC9LQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;p&gt;第二个问题：在早期的 linux 系统实现中，创建新的进程是会复制父进程的资源的，因为创建出来的子进程需要分配各种资源，比如进程描述符、地址空间等，如果不从父进程复制过来，那应该如何初始化这个新的进程呢？总不能给它一个空的结构吧，所以&lt;span&gt;&lt;strong&gt;最方便省事的方式就是把父进程的东西给复制过来&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;&lt;strong&gt;注意，复制父进程的资源与复制父进程资源内存地址是不一样的&lt;/strong&gt;&lt;/span&gt;。前者是所有的资源再次创建，后者是直接利用指针进行赋值，前者会在系统中增加一份与父进程一模一样的资源，后者不会增加资源。现在的操作系统都是后者，这也是现代操作系统的一个优化点，采用的是一个叫&lt;span&gt;&lt;strong&gt;写时复制&lt;/strong&gt;&lt;/span&gt;（COW，Copy On Write）的技术。为什么要这么做呢？你想，每次创建新进程都要把父进程的资源复制一遍，这得多&lt;span&gt;&lt;strong&gt;耗费 CPU 和内存资源&lt;/strong&gt;&lt;/span&gt;，而且新进程还不一定用的到父进程的资源，而且根据统计大部分情况下都是用不到的。所以如果只用指针去进行复制资源是一个很好的方式，&lt;span&gt;&lt;strong&gt;减少了很多不必要的资源损耗&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当子进程通过 fork 创建出来后，下一步需要进行 exec。&lt;span&gt;&lt;strong&gt;这步会将你指定的子进程程序加载到这个新的进程内存空间中并执行。&lt;/strong&gt;&lt;/span&gt;这两步都完成后才算完成了子进程的启动和运行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面是一个关于利用 fork 和 execve 创建一个新进场的示例。fork 会先创建出一个新的进程，然后利用 execve 装载另外一个程序，这里用的 echo 程序向控制台打印 hello。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *arg[] = {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;echo&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(fork() == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;child process\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(execve(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/usr/bin/echo&quot;&lt;/span&gt;, arg, &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parent process exit\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; EXIT_SUCCESS;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;fork() 的返回值有三种：&lt;/p&gt;&lt;p&gt;所以你们会发现在示例代码里会有一个 fork() == 0 的判断，利用这个可以是否当前是否是在新的子进程内。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们都知道进程是运行起来的程序，但其实进程包括很多东西，比如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程的运行状态&lt;/strong&gt;&lt;/span&gt;：包括就绪、运行、等待/阻塞、僵尸等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/span&gt;：记录当前进程运行到哪条指令了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CPU 寄存器&lt;/strong&gt;&lt;/span&gt;：保存进程运行的上下文信息，以便当前进程调度出去后还能调度回来接着运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CPU 调度信息&lt;/strong&gt;&lt;/span&gt;：包括进程优先级、调度队列、调度等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存信息&lt;/strong&gt;&lt;/span&gt;：进程使用的内存信息，如页表等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;文件信息&lt;/strong&gt;&lt;/span&gt;：进程打开的文件信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源限制信息&lt;/strong&gt;&lt;/span&gt;：CPU、内存、带宽等限制的信息，如：可以限制进程运行所能使用的 CPU 核数。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以把程序看做是一个人，人活着就相当于一个进程。&lt;span&gt;&lt;strong&gt;比如：进程需要 CPU，人活着需要食物；进程需要内存，人活着要房子；进程要与其他进程交流的话，需要管道、socket 等，人与人交流需要手机等；进程竞争 CPU，人竞争食物。&lt;/strong&gt;&lt;/span&gt;很多时候操作系统中的很多东西都可以类比人类社会中的某些方面，可能是工程师们在设计操作系统时参照了人类社会吧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎关注公众号：哈扣。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pMAe7v8MucibMUgXM4Y8G0fRDBtp10qAAW1v0nQpZrjZZAs8LphiabRwv6V40RGbqJQ0ib9Tx2mMveZSibwia0mHK1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>667a4ebb60a811cb7022156569c2f29e</guid>
<title>第三方 cookie 马上就不让用了，互联网广告还怎么玩？</title>
<link>https://toutiao.io/k/dhgg2q8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-lake-id=&quot;bce22131c432b975cafeac0919902500&quot;&gt;Chrome Developer Summit 2020的一些话题挺有意思的，其中A more private way to measure ad conversions是关于互联网广告的，值得关注，这是互联网广告的未来方向。在第三方Cookie限制越来越多且很快就会被禁用的情况下，广告作为互联网最核心的商业模式之一，还怎么玩下去？&lt;/p&gt;&lt;p data-lake-id=&quot;9adee408dcc635c4be21615f1f7ac85a&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;f3d1c6247effb60e2f0cc5b6d8e482c2&quot;&gt;背景&lt;/h1&gt;&lt;p data-lake-id=&quot;27d90230dd3a0496a0f09d7789056d88&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f466d7945cd0411a08532965acfdc0db&quot;&gt;雅虎早就不存在，这个靠手动建立互联网索引的“落后”公司，现在大家应该都瞧不上了。不过，《浪潮之巅》的作者吴军老师对雅虎的评价还是很高的：&lt;/p&gt;&lt;p data-lake-id=&quot;e5111146674d3b74dd57ed796362796b&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p data-lake-id=&quot;05c46e4b4d7622520e445855ca226e80&quot;&gt;一百年后，如果人们只记得两个对互联网贡献最大的人，那么这两个人很可能是杨志远（Jerry Yang）和戴维•费罗（Davide Filo），而不是今天名气更大的互联网企业家佩奇、布林或者扎克伯格。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-lake-id=&quot;f48df2098e823a86285383506d10d1a7&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ba90024e7e790267ecb9c218ef2a0c36&quot;&gt;为什么？因为雅虎制定了互联网行业的游戏规则：开放、免费和盈利。虽然这个规则现在有点被玩坏了，大体还没有变化。绝大部分互联网产品本身都是对用户免费的，获取足够流量之后，再通过广告变现，本质上，Google、Facebook、阿里巴巴、百度、美团、字节跳动、拼多多这些互联网巨头都是广告公司，只是卖的广告类型不一样而已。&lt;/p&gt;&lt;p data-lake-id=&quot;1b2bff8feb9801e30444f28d53ba8322&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7174de9e50ebe78811abd1fe7334691c&quot;&gt;不过，随着各国对于用户数据隐私的保护越来越严格，互联网广告这个商业模式当前遇到了非常大的挑战。&lt;/p&gt;&lt;p data-lake-id=&quot;b39755624351f6923bd6a135d412ebe9&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;87a346e99b9720a2f53eb03a1b9db96c&quot;&gt;因为Apple调整了隐私政策，Facebook在纽约时报、华盛顿邮报、华尔街日报上刊发整版广告反对，不难感受到，&lt;strong&gt;&lt;span&gt;小&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;扎同学已经出离的愤怒了:(&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;dd39237ba453939c04bd52a785b3b5e8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8c0db7de5a1793c945376006b1598cb2&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F928098%2F1608990208282-b23d1db2-e999-4400-907b-f9da517c59c0.png%22%2C%22originWidth%22%3A1155%2C%22originHeight%22%3A2100%2C%22name%22%3A%22AD-Standing-up-to-Apple-for-small-business.png%22%2C%22size%22%3A754439%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A96.76597%2C%22y%22%3A321.878%2C%22width%22%3A638.50478%2C%22height%22%3A79.6087%2C%22text%22%3A%22Werestanding%22%7D%2C%7B%22x%22%3A92.185844%2C%22y%22%3A410.21176%2C%22width%22%3A635.2433560000001%2C%22height%22%3A91.03493999999995%2C%22text%22%3A%22uptoApplefor%22%7D%2C%7B%22x%22%3A96.90407%2C%22y%22%3A508.04288%2C%22width%22%3A704.57373%2C%22height%22%3A74.79111999999992%2C%22text%22%3A%22smallbusinesses%22%7D%2C%7B%22x%22%3A98.39567%2C%22y%22%3A608.51276%2C%22width%22%3A490.58516%2C%22height%22%3A78.37624000000005%2C%22text%22%3A%22everywhere%22%7D%2C%7B%22x%22%3A99.01163%2C%22y%22%3A752.14716%2C%22width%22%3A662.67597%2C%22height%22%3A27.807140000000004%2C%22text%22%3A%22AtFacebook%2Cmallbusinessisathecoreofour%22%7D%2C%7B%22x%22%3A96.86401%2C%22y%22%3A797.32117%2C%22width%22%3A684.23149%2C%22height%22%3A26.725229999999897%2C%22text%22%3A%22business.Morethan10milionbusinessesuseour%22%7D%2C%7B%22x%22%3A97.53739%2C%22y%22%3A836.347%2C%22width%22%3A728.7188100000001%2C%22height%22%3A29.27690000000007%2C%22text%22%3A%22advertisingtoolseachonthidw%22%7D%2C%7B%22x%22%3A96.96072%2C%22y%22%3A877.73834%2C%22width%22%3A706.9674799999999%2C%22height%22%3A29.313560000000052%2C%22text%22%3A%22hireemployeesandengagewiththeircommunities%22%7D%2C%7B%22x%22%3A97.226555%2C%22y%22%3A939.6122%2C%22width%22%3A707.734505%2C%22height%22%3A30.820799999999963%2C%22text%22%3A%22Manyinthesmallbusinesscommunityhaveshared%22%7D%2C%7B%22x%22%3A98.86648%2C%22y%22%3A982.45685%2C%22width%22%3A659.78446%2C%22height%22%3A28.30120999999997%2C%22text%22%3A%22concernsaboutApple&#x27;sforcedsoftwreuda%22%7D%2C%7B%22x%22%3A97.86004%2C%22y%22%3A1025.6931%2C%22width%22%3A743.40082%2C%22height%22%3A29.405300000000125%2C%22text%22%3A%22whichwilliitbusinesses&#x27;abilityorupsonlize%22%7D%2C%7B%22x%22%3A97.476326%2C%22y%22%3A1067.3682%2C%22width%22%3A588.0579740000001%2C%22height%22%3A28.497400000000198%2C%22text%22%3A%22adsandreachtheircustomerseffectively.%22%7D%2C%7B%22x%22%3A97.37121%2C%22y%22%3A1132.8887%2C%22width%22%3A691.04023%2C%22height%22%3A28.57030000000009%2C%22text%22%3A%22Forty-fourpercentofsmalltomediumbusinesses%22%7D%2C%7B%22x%22%3A97.91506%2C%22y%22%3A1173.9692%2C%22width%22%3A711.2559%2C%22height%22%3A26.886299999999892%2C%22text%22%3A%22startedorincreasedtheirusageofpersonalizedads%22%7D%2C%7B%22x%22%3A98.6604%2C%22y%22%3A1219.5256%2C%22width%22%3A712.0432000000001%2C%22height%22%3A24.183899999999994%2C%22text%22%3A%22onSoCialmediaduringthepandemiccodig%22%7D%2C%7B%22x%22%3A98.23592%2C%22y%22%3A1256.8875%2C%22width%22%3A630.9120800000001%2C%22height%22%3A26.797900000000027%2C%22text%22%3A%22newDeloittestudy.Withoutolizdd%22%7D%2C%7B%22x%22%3A99.332466%2C%22y%22%3A1298.2666%2C%22width%22%3A741.491834%2C%22height%22%3A26.558099999999968%2C%22text%22%3A%22Facebookdatashowthattheeragesmalbuines%22%7D%2C%7B%22x%22%3A96.54904%2C%22y%22%3A1340.2021%2C%22width%22%3A696.35436%2C%22height%22%3A28.676600000000008%2C%22text%22%3A%22advertiserstandstoseeacutofover60%25intheir%22%7D%2C%7B%22x%22%3A96.01981%2C%22y%22%3A1381.7189%2C%22width%22%3A458.92385%2C%22height%22%3A27.094699999999875%2C%22text%22%3A%22salesforeverydollartheyspend.%22%7D%2C%7B%22x%22%3A97.99627%2C%22y%22%3A1445.0077%2C%22width%22%3A735.06273%2C%22height%22%3A29.62209999999982%2C%22text%22%3A%22Whilelimitinghowpersonalizedadscanbeuseddoes%22%7D%2C%7B%22x%22%3A95.89517%2C%22y%22%3A1488.3721%2C%22width%22%3A741.9462599999999%2C%22height%22%3A25.851200000000063%2C%22text%22%3A%22impactlargercompanieslikeuthechngewille%22%7D%2C%7B%22x%22%3A97.266655%2C%22y%22%3A1530.4344%2C%22width%22%3A721.322945%2C%22height%22%3A28.79449999999997%2C%22text%22%3A%22devastatingtosmallbusinessesdigh%22%7D%2C%7B%22x%22%3A99.33822%2C%22y%22%3A1570.696%2C%22width%22%3A424.95408%2C%22height%22%3A28.82990000000018%2C%22text%22%3A%22challengestheyfacerightnow.%22%7D%2C%7B%22x%22%3A97.83285%2C%22y%22%3A1635.1951%2C%22width%22%3A524.14255%2C%22height%22%3A25.81540000000018%2C%22text%22%3A%22Smallbusinessesdeservetobeheard.%22%7D%2C%7B%22x%22%3A99.72399%2C%22y%22%3A1677.8618%2C%22width%22%3A643.5314400000001%2C%22height%22%3A26.560400000000072%2C%22text%22%3A%22Wehearyourconcerns%2Candwestandwithyou%22%7D%2C%7B%22x%22%3A99.99742%2C%22y%22%3A1737.2522%2C%22width%22%3A504.62483%2C%22height%22%3A28.879500000000007%2C%22text%22%3A%22Joinusatfb.com%2FspeakUpForSmall%22%7D%2C%7B%22x%22%3A827.8073%2C%22y%22%3A1928.7971%2C%22width%22%3A229.38389999999993%2C%22height%22%3A30.704500000000053%2C%22text%22%3A%22FACEBOOK%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22Werestanding%20uptoApplefor%20smallbusinesses%20everywhere%20AtFacebook%2Cmallbusinessisathecoreofour%20business.Morethan10milionbusinessesuseour%20advertisingtoolseachonthidw%20hireemployeesandengagewiththeircommunities%20Manyinthesmallbusinesscommunityhaveshared%20concernsaboutApple&#x27;sforcedsoftwreuda%20whichwilliitbusinesses&#x27;abilityorupsonlize%20adsandreachtheircustomerseffectively.%20Forty-fourpercentofsmalltomediumbusinesses%20startedorincreasedtheirusageofpersonalizedads%20onSoCialmediaduringthepandemiccodig%20newDeloittestudy.Withoutolizdd%20Facebookdatashowthattheeragesmalbuines%20advertiserstandstoseeacutofover60%25intheir%20salesforeverydollartheyspend.%20Whilelimitinghowpersonalizedadscanbeuseddoes%20impactlargercompanieslikeuthechngewille%20devastatingtosmallbusinessesdigh%20challengestheyfacerightnow.%20Smallbusinessesdeservetobeheard.%20Wehearyourconcerns%2Candwestandwithyou%20Joinusatfb.com%2FspeakUpForSmall%20FACEBOOK%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A289%2C%22height%22%3A525%7D&quot;&gt;&lt;img data-height=&quot;525px&quot; data-ratio=&quot;1.8181818181818181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hcfU3x1Bh2Kmefia08PJgwib28rAary2ooEsl59BCzryuNqZ5zLNCL0qibcNbRpyzeW3wnqicicliaa6yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1155&quot; title=&quot;AD-Standing-up-to-Apple-for-small-business.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3ce87019f39df920a9289f2a7852aff5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;69dd91df5cf31ce71f1d9ced37ffc563&quot;&gt;互联网广告现在越来越精准了，我们在A站点看的东西，怎么就跑到B站点的广告里面去了？其中关键之一就是第三方cookie，广告巨头比如Google可以通过第三方cookie把我们在很多不同网站的行为给串联起来，你说它的广告能不准吗？想要理解这一点，不妨看一下基于cookie的广告是怎么做的。&lt;/p&gt;&lt;p data-lake-id=&quot;51bc2397b1f1a57b0a34d60b229aff15&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;99eaf3b354140b20cb3fb178f8f7c346&quot;&gt;基于cookie的广告是怎么做&lt;/h1&gt;&lt;p data-lake-id=&quot;59d5da9a306e47dc48bf68c8ca92fdc9&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b77fbc55c64ea650f07207cb5c905d45&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fjpeg%2F928098%2F1608990674137-cbba8488-becf-4ee2-a18c-bcd2066458f8.jpeg%22%2C%22originWidth%22%3A886%2C%22originHeight%22%3A953%2C%22name%22%3A%22with-cookies.jpg%22%2C%22size%22%3A72307%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A59.332253%2C%22y%22%3A24.019806%2C%22width%22%3A301.095577%2C%22height%22%3A29.433407%2C%22text%22%3A%22Withthird-partycookies%22%7D%2C%7B%22x%22%3A53.77229%2C%22y%22%3A121.73191%2C%22width%22%3A136.21654%2C%22height%22%3A14.612310000000008%2C%22text%22%3A%22Theuserseesad%22%7D%2C%7B%22x%22%3A52.914597%2C%22y%22%3A140.89595%2C%22width%22%3A140.617003%2C%22height%22%3A15.680509999999998%2C%22text%22%3A%22onnews.example%22%7D%2C%7B%22x%22%3A51.73819%2C%22y%22%3A160.76697%2C%22width%22%3A81.07132999999999%2C%22height%22%3A13.700210000000027%2C%22text%22%3A%22(PUBLISHER)%22%7D%2C%7B%22x%22%3A15.536807%2C%22y%22%3A183.8588%2C%22width%22%3A223.625393%2C%22height%22%3A14.953550000000007%2C%22text%22%3A%22click-timeorview-timedata%22%7D%2C%7B%22x%22%3A32.69634%2C%22y%22%3A233.39407%2C%22width%22%3A127.47811000000002%2C%22height%22%3A15.893910000000005%2C%22text%22%3A%22AdtechUserID%22%7D%2C%7B%22x%22%3A142.92123%2C%22y%22%3A235.19176%2C%22width%22%3A108.72709999999998%2C%22height%22%3A14.157319999999999%2C%22text%22%3A%22ID123444445%22%7D%2C%7B%22x%22%3A365.67184%2C%22y%22%3A236.00935%2C%22width%22%3A46.53403000000003%2C%22height%22%3A16.378929999999997%2C%22text%22%3A%22ADID%22%7D%2C%7B%22x%22%3A424.2317%2C%22y%22%3A236.73242%2C%22width%22%3A82.3725%2C%22height%22%3A15.726349999999996%2C%22text%22%3A%22298499698%22%7D%2C%7B%22x%22%3A531.0852%2C%22y%22%3A243.7181%2C%22width%22%3A145.65949999999998%2C%22height%22%3A15.04743000000002%2C%22text%22%3A%22Becausethisisan%22%7D%2C%7B%22x%22%3A73.66232%2C%22y%22%3A258.79276%2C%22width%22%3A74.11234999999999%2C%22height%22%3A16.54946000000001%2C%22text%22%3A%223Pcookie%22%7D%2C%7B%22x%22%3A530.9611%2C%22y%22%3A258.95386%2C%22width%22%3A142.81185000000005%2C%22height%22%3A16.672879999999964%2C%22text%22%3A%22ID(unigue).itcan%22%7D%2C%7B%22x%22%3A341.20258%2C%22y%22%3A265.6344%2C%22width%22%3A69.63603999999998%2C%22height%22%3A15.993869999999959%2C%22text%22%3A%22Viewed%3F%22%7D%2C%7B%22x%22%3A423.66913%2C%22y%22%3A267.24545%2C%22width%22%3A28.31817000000001%2C%22height%22%3A13.271180000000015%2C%22text%22%3A%22yes%22%7D%2C%7B%22x%22%3A530.9988%2C%22y%22%3A276.5813%2C%22width%22%3A128.8710000000001%2C%22height%22%3A16.572630000000004%2C%22text%22%3A%22bemappdto...%22%7D%2C%7B%22x%22%3A340.95447%2C%22y%22%3A293.4698%2C%22width%22%3A112.57747999999998%2C%22height%22%3A16.508929999999964%2C%22text%22%3A%22clicked%3Fyes%22%7D%2C%7B%22x%22%3A216.48651%2C%22y%22%3A345.65915%2C%22width%22%3A275.69209%2C%22height%22%3A16.50930999999997%2C%22text%22%3A%22adtech.example(ADTECHPLATFORM)%22%7D%2C%7B%22x%22%3A545.8549%2C%22y%22%3A351.6379%2C%22width%22%3A105.48289999999997%2C%22height%22%3A15.987700000000018%2C%22text%22%3A%22Detaileddata%22%7D%2C%7B%22x%22%3A214.34058%2C%22y%22%3A364.51743%2C%22width%22%3A240.22592000000003%2C%22height%22%3A13.809970000000021%2C%22text%22%3A%22canrecognizetheuseracross%22%7D%2C%7B%22x%22%3A563.4218%2C%22y%22%3A371.91357%2C%22width%22%3A234.87610000000006%2C%22height%22%3A15.31241%2C%22text%22%3A%22Adservedonnews.example%22%7D%2C%7B%22x%22%3A213.9777%2C%22y%22%3A379.78778%2C%22width%22%3A195.874%2C%22height%22%3A17.33141999999998%2C%22text%22%3A%22sites(andaccesshighly%22%7D%2C%7B%22x%22%3A564.04474%2C%22y%22%3A387.1911%2C%22width%22%3A151.66509999999994%2C%22height%22%3A16.223270000000014%2C%22text%22%3A%22Campaign1091733%22%7D%2C%7B%22x%22%3A213.91576%2C%22y%22%3A396.16855%2C%22width%22%3A240.41279%2C%22height%22%3A19.42288000000002%2C%22text%22%3A%22detaileddatafrombothsites).%22%7D%2C%7B%22x%22%3A564.3566%2C%22y%22%3A404.29916%2C%22width%22%3A178.6690000000001%2C%22height%22%3A14.510290000000055%2C%22text%22%3A%22Creativeversion24%22%7D%2C%7B%22x%22%3A244.5865%2C%22y%22%3A418.39346%2C%22width%22%3A184.41725000000002%2C%22height%22%3A16.664800000000014%2C%22text%22%3A%22Adspendoptimization%22%7D%2C%7B%22x%22%3A557.959%2C%22y%22%3A418.68845%2C%22width%22%3A303.5124400000001%2C%22height%22%3A15.830989999999986%2C%22text%22%3A%22%2BUseRIocatedinNewJersey87038%22%7D%2C%7B%22x%22%3A549.8456%2C%22y%22%3A434.7465%2C%22width%22%3A76.14530000000002%2C%22height%22%3A15.132249999999999%2C%22text%22%3A%22(Hoboken)%22%7D%2C%7B%22x%22%3A247.20947%2C%22y%22%3A436.66565%2C%22width%22%3A153.26709%2C%22height%22%3A17.98888999999997%2C%22text%22%3A%22Cross-sitetracking%22%7D%2C%7B%22x%22%3A561.062%2C%22y%22%3A449.09616%2C%22width%22%3A292.60749999999996%2C%22height%22%3A16.645969999999977%2C%22text%22%3A%22ViewEDTHEADonSundaY10%3A92AM%22%7D%2C%7B%22x%22%3A53.590275%2C%22y%22%3A458.79633%2C%22width%22%3A141.14937500000002%2C%22height%22%3A16.456019999999967%2C%22text%22%3A%22Theuserbuyson%22%7D%2C%7B%22x%22%3A562.654%2C%22y%22%3A465.53918%2C%22width%22%3A282.2134%2C%22height%22%3A15.979160000000036%2C%22text%22%3A%22UseRIDonnews.example%3A32555%22%7D%2C%7B%22x%22%3A53.225094%2C%22y%22%3A478.45215%2C%22width%22%3A122.970006%2C%22height%22%3A16.14855%2C%22text%22%3A%22shoes.example%22%7D%2C%7B%22x%22%3A561.54895%2C%22y%22%3A480.68457%2C%22width%22%3A262.97895000000005%2C%22height%22%3A19.314269999999965%2C%22text%22%3A%22Useremailfornews.example%3A%22%7D%2C%7B%22x%22%3A546.2632%2C%22y%22%3A497.4087%2C%22width%22%3A124.93860000000006%2C%22height%22%3A16.82480000000004%2C%22text%22%3A%22alice%40doe.com%22%7D%2C%7B%22x%22%3A53.787445%2C%22y%22%3A500.37805%2C%22width%22%3A87.30809500000001%2C%22height%22%3A13.027449999999988%2C%22text%22%3A%22ADVERTISER)%22%7D%2C%7B%22x%22%3A15.94943%2C%22y%22%3A521.8549%2C%22width%22%3A172.59224%2C%22height%22%3A15.610399999999913%2C%22text%22%3A%22Conversion-timedata%22%7D%2C%7B%22x%22%3A698.4433%2C%22y%22%3A525.6306%2C%22width%22%3A146.65639999999996%2C%22height%22%3A15.700300000000084%2C%22text%22%3A%22news.exampledata%22%7D%2C%7B%22x%22%3A301.48474%2C%22y%22%3A567.50366%2C%22width%22%3A209.88918999999999%2C%22height%22%3A15.27649000000008%2C%22text%22%3A%22ConversionID819999999%22%7D%2C%7B%22x%22%3A31.970417%2C%22y%22%3A566.8687%2C%22width%22%3A121.85494299999999%2C%22height%22%3A17.30970000000002%2C%22text%22%3A%22AdtechUserID%22%7D%2C%7B%22x%22%3A167.38016%2C%22y%22%3A568.23376%2C%22width%22%3A85.63109%2C%22height%22%3A14.87324000000001%2C%22text%22%3A%22123444445%22%7D%2C%7B%22x%22%3A535.5336%2C%22y%22%3A574.7931%2C%22width%22%3A148.57724000000007%2C%22height%22%3A14.04690000000005%2C%22text%22%3A%22Becausethisisan%22%7D%2C%7B%22x%22%3A536.2959%2C%22y%22%3A589.9688%2C%22width%22%3A143.53235000000006%2C%22height%22%3A17.830640000000017%2C%22text%22%3A%22ID(unique)%2Citcan%22%7D%2C%7B%22x%22%3A69.79144%2C%22y%22%3A591.2338%2C%22width%22%3A77.16899000000001%2C%22height%22%3A16.497799999999984%2C%22text%22%3A%223Pcookie%22%7D%2C%7B%22x%22%3A539.4863%2C%22y%22%3A608.21%2C%22width%22%3A123.96349999999995%2C%22height%22%3A14.72804999999994%2C%22text%22%3A%22bemappedto...%22%7D%2C%7B%22x%22%3A551.2191%2C%22y%22%3A687.8386%2C%22width%22%3A109.90909999999997%2C%22height%22%3A15.969099999999912%2C%22text%22%3A%22Detaileddata%22%7D%2C%7B%22x%22%3A565.01324%2C%22y%22%3A708.8659%2C%22width%22%3A241.64995999999996%2C%22height%22%3A16.225000000000023%2C%22text%22%3A%22Convertedonshoesexampe%22%7D%2C%7B%22x%22%3A562.0043%2C%22y%22%3A720.8999%2C%22width%22%3A272.7659000000001%2C%22height%22%3A20.984699999999975%2C%22text%22%3A%22useriocatedinNewYorkCity%22%7D%2C%7B%22x%22%3A546.4825%2C%22y%22%3A740.6906%2C%22width%22%3A163.78480000000002%2C%22height%22%3A15.50649999999996%2C%22text%22%3A%2218813(Manhattan)%22%7D%2C%7B%22x%22%3A563.6122%2C%22y%22%3A754.6641%2C%22width%22%3A289.6491%2C%22height%22%3A18.15975000000003%2C%22text%22%3A%22ConvertedonWednesday2%3A15pm%22%7D%2C%7B%22x%22%3A560.8311%2C%22y%22%3A770.52527%2C%22width%22%3A271.8519%2C%22height%22%3A19.229490000000055%2C%22text%22%3A%22CustomerIDonshoes.example%22%7D%2C%7B%22x%22%3A547.511%2C%22y%22%3A788.5524%2C%22width%22%3A53.50162999999998%2C%22height%22%3A14.330839999999966%2C%22text%22%3A%22118688%22%7D%2C%7B%22x%22%3A561.6942%2C%22y%22%3A803.4508%2C%22width%22%3A182.31134999999995%2C%22height%22%3A15.545900000000074%2C%22text%22%3A%22shippingaddreon%22%7D%2C%7B%22x%22%3A546.23303%2C%22y%22%3A818.91046%2C%22width%22%3A297.31232%2C%22height%22%3A16.849540000000047%2C%22text%22%3A%22shoes.example%3ANicestr3%2C87938%22%7D%2C%7B%22x%22%3A559.6205%2C%22y%22%3A836.8161%2C%22width%22%3A228.17093999999997%2C%22height%22%3A14.235540000000015%2C%22text%22%3A%22CreditcarD09011112222%22%7D%2C%7B%22x%22%3A560.8673%2C%22y%22%3A852.22516%2C%22width%22%3A254.97505%2C%22height%22%3A13.907410000000027%2C%22text%22%3A%22OrdeID93662(1xshoes1x%22%7D%2C%7B%22x%22%3A546.4308%2C%22y%22%3A868.7725%2C%22width%22%3A50.6028%2C%22height%22%3A13.12074999999993%2C%22text%22%3A%22socks%22%7D%2C%7B%22x%22%3A564.62524%2C%22y%22%3A883.2217%2C%22width%22%3A177.76146000000006%2C%22height%22%3A16.036659999999983%2C%22text%22%3A%22PURchasevalueS138%22%7D%2C%7B%22x%22%3A694.1361%2C%22y%22%3A909.1387%2C%22width%22%3A151.3823299999999%2C%22height%22%3A13.869050000000016%2C%22text%22%3A%22shoes.exampledata%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22Withthird-partycookies%20Theuserseesad%20onnews.example%20(PUBLISHER)%20click-timeorview-timedata%20AdtechUserID%20ID123444445%20ADID%20298499698%20Becausethisisan%203Pcookie%20ID(unigue).itcan%20Viewed%3F%20yes%20bemappdto...%20clicked%3Fyes%20adtech.example(ADTECHPLATFORM)%20Detaileddata%20canrecognizetheuseracross%20Adservedonnews.example%20sites(andaccesshighly%20Campaign1091733%20detaileddatafrombothsites).%20Creativeversion24%20Adspendoptimization%20%2BUseRIocatedinNewJersey87038%20(Hoboken)%20Cross-sitetracking%20ViewEDTHEADonSundaY10%3A92AM%20Theuserbuyson%20UseRIDonnews.example%3A32555%20shoes.example%20Useremailfornews.example%3A%20alice%40doe.com%20ADVERTISER)%20Conversion-timedata%20news.exampledata%20ConversionID819999999%20AdtechUserID%20123444445%20Becausethisisan%20ID(unique)%2Citcan%203Pcookie%20bemappedto...%20Detaileddata%20Convertedonshoesexampe%20useriocatedinNewYorkCity%2018813(Manhattan)%20ConvertedonWednesday2%3A15pm%20CustomerIDonshoes.example%20118688%20shippingaddreon%20shoes.example%3ANicestr3%2C87938%20CreditcarD09011112222%20OrdeID93662(1xshoes1x%20socks%20PURchasevalueS138%20shoes.exampledata%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A665%2C%22height%22%3A715%7D&quot;&gt;&lt;img data-height=&quot;715px&quot; data-ratio=&quot;1.0756207674943568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UnKibSlmUib8hcfU3x1Bh2Kmefia08PJgwibYrMUHBQwuurZsGpF2U7k5db96XickaCoDNa3enyticPXEVEJNZt0Aswg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;886&quot; title=&quot;with-cookies.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f1cadfb14e8a7ef893664a50be8afb2f&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;9f9419662e3beb9f2818f8be00858b5d&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;news.example是新闻站点，流量很高，靠互联网广告赚钱&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;shoes.example是卖鞋的购物网站，需要通过投放广告获取用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;adtech.example是广告服务商，shoes.example可以通过adtech.example在news.example投放广告&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户在news.example站点看新闻，会加载adtech.example的广告JS脚本（用于展现广告、记录广告浏览和点击数据），点击广告就可以跳转到了shoes.example站点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户访问shoes.example的时候，也会加载adtech.example的JS脚本（用于记录下单数据）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;adtech.example的JS脚本可以为每一个用户生成唯一的用户ID，保存到cookie中，并发送到adtech.example的服务器，通过唯一ID将用户在news.example的广告浏览、点击数据与用户在shoes.example下单数据合并分析，计算广告的转化率&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;f7b83729312fb923a4b2df8ba76142b1&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0ab05d6c89d32d26b84a0c587d89bc32&quot;&gt;广告服务商adtech.example之所以可以计算广告转化率，原因在于它为每一个用户生成了唯一ID，并保存在cookie中。adtech.example的cookie对于news.example和shoes.example来说，都是第三方cookie（third party cookie，图中缩写为3P cookie）。&lt;/p&gt;&lt;p data-lake-id=&quot;384a6272e57b2e8c4bd5c46fec22d639&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;bafa6ff37cb0c67e38e0b2e8ba2c1f98&quot;&gt;在Chrome中，第三方cookie现在还是可以用的，只要cookie的SameSite属性设为None，同时设置Secure属性即可。&lt;/p&gt;&lt;p data-lake-id=&quot;279cd8ad49f230c92bf59cc764afa6cd&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;04d25a556f9a4929fa2e8b7b22907e99&quot;&gt;但是，Chrome计划在2022年停止支持第三方Cookie，这就意味着广告服务商adtech.example无法再通过Cookie来追踪用户了。其他主流的浏览器，比如Safari 13.1已经禁止使用第三方cookie了，Firefox和Edge也在做类似的事情。所以，禁用第三方Cookie是迟早的事情，会比我们想象中快很多。&lt;/p&gt;&lt;p data-lake-id=&quot;b2d226dfa7b688f4ed174b14f2f2ba65&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8da3d0e32f584cfe576ba6666ab621f1&quot;&gt;那时候，就算你把SameSite设为None，也不管用了，所以说，&lt;strong&gt;&lt;span&gt;这是一个价值数千亿美金的None，价值数十亿美元的空指针还要贵很多。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;43f98b2a4f95072e3bbe006a0dd63838&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9321f5b33adee9e07a7d331223d6d208&quot;&gt;Google既然敢说2年内不再支持第三方Cookie，肯定有其他办法继续卖广告，毕竟它是互联网最大的广告商之一啊。&lt;/p&gt;&lt;p data-lake-id=&quot;c09d58cd546b25aa89423da186d47d79&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;424bf8685562a2376f303d5cabea3440&quot;&gt;没有cookie的广告是怎么做&lt;/h1&gt;&lt;p data-lake-id=&quot;7357df0431526c3c2f74eb047ad578e0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9c56f60e743aaac047a29f68d20c4216&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fjpeg%2F928098%2F1609038656399-818bd5f6-b9ef-4bca-aebc-0a8e522094b4.jpeg%22%2C%22originWidth%22%3A1341%2C%22originHeight%22%3A831%2C%22name%22%3A%22diagram-overview.jpg%22%2C%22size%22%3A55824%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A28.49714%2C%22y%22%3A33.399635%2C%22width%22%3A237.08956%2C%22height%22%3A23.485062%2C%22text%22%3A%22ADTECHPLATFORM%22%7D%2C%7B%22x%22%3A39.704144%2C%22y%22%3A73.48833%2C%22width%22%3A197.24379599999997%2C%22height%22%3A26.359005999999994%2C%22text%22%3A%22adtech.example%22%7D%2C%7B%22x%22%3A782.6091%2C%22y%22%3A117.24206%2C%22width%22%3A170.84590000000003%2C%22height%22%3A24.83451000000001%2C%22text%22%3A%223.Converted!%22%7D%2C%7B%22x%22%3A235.86363%2C%22y%22%3A218.76054%2C%22width%22%3A167.22037%2C%22height%22%3A25.861530000000016%2C%22text%22%3A%221.Theadtech%22%7D%2C%7B%22x%22%3A237.27844%2C%22y%22%3A244.6973%2C%22width%22%3A197.35959000000003%2C%22height%22%3A26.89869999999999%2C%22text%22%3A%22scriptisloaded.%22%7D%2C%7B%22x%22%3A26.99633%2C%22y%22%3A275.5502%2C%22width%22%3A133.55105%2C%22height%22%3A21.30707000000001%2C%22text%22%3A%22PUBLISHER%22%7D%2C%7B%22x%22%3A456.37814%2C%22y%22%3A276.7646%2C%22width%22%3A148.01176000000004%2C%22height%22%3A20.472770000000025%2C%22text%22%3A%22ADVERTISER%22%7D%2C%7B%22x%22%3A454.93936%2C%22y%22%3A303.20642%2C%22width%22%3A188.34764%2C%22height%22%3A24.76958000000002%2C%22text%22%3A%22shoes.example%22%7D%2C%7B%22x%22%3A27.68371%2C%22y%22%3A305.28027%2C%22width%22%3A177.98142%2C%22height%22%3A21.97950000000003%2C%22text%22%3A%22news.example%22%7D%2C%7B%22x%22%3A461.7034%2C%22y%22%3A344.57794%2C%22width%22%3A121.64530000000002%2C%22height%22%3A23.008579999999995%2C%22text%22%3A%22Checkout%22%7D%2C%7B%22x%22%3A886.7098%2C%22y%22%3A369.40292%2C%22width%22%3A126.53556000000003%2C%22height%22%3A26.16122999999999%2C%22text%22%3A%224.Askthe%22%7D%2C%7B%22x%22%3A1083.4607%2C%22y%22%3A369.66614%2C%22width%22%3A148.25049999999987%2C%22height%22%3A23.423519999999996%2C%22text%22%3A%225.Later%3Athe%22%7D%2C%7B%22x%22%3A669.3989%2C%22y%22%3A386.38333%2C%22width%22%3A64.16476%2C%22height%22%3A21.48239000000001%2C%22text%22%3A%22pixel%22%7D%2C%7B%22x%22%3A1083.5656%2C%22y%22%3A397.70364%2C%22width%22%3A102.88460000000009%2C%22height%22%3A18.284119999999973%2C%22text%22%3A%22browser%22%7D%2C%7B%22x%22%3A887.31903%2C%22y%22%3A399.20856%2C%22width%22%3A135.14342999999997%2C%22height%22%3A19.745480000000043%2C%22text%22%3A%22browserto%22%7D%2C%7B%22x%22%3A1083.5386%2C%22y%22%3A421.9537%2C%22width%22%3A123.24969999999985%2C%22height%22%3A21.644049999999993%2C%22text%22%3A%22sendsthe%22%7D%2C%7B%22x%22%3A888.60913%2C%22y%22%3A426.33215%2C%22width%22%3A105.33344%2C%22height%22%3A21.47645%2C%22text%22%3A%22record_a%22%7D%2C%7B%22x%22%3A1083.6244%2C%22y%22%3A441.72906%2C%22width%22%3A228.98500000000013%2C%22height%22%3A23.358040000000017%2C%22text%22%3A%22conversionreport.%22%7D%2C%7B%22x%22%3A890.72%2C%22y%22%3A453.5275%2C%22width%22%3A137.9891%2C%22height%22%3A19.920800000000042%2C%22text%22%3A%22conversion%22%7D%2C%7B%22x%22%3A888.2231%2C%22y%22%3A476.7118%2C%22width%22%3A167.03740000000005%2C%22height%22%3A22.41735%2C%22text%22%3A%22withacertain%22%7D%2C%7B%22x%22%3A887.4352%2C%22y%22%3A505.61658%2C%22width%22%3A72.30399999999997%2C%22height%22%3A18.08001999999999%2C%22text%22%3A%22value.%22%7D%2C%7B%22x%22%3A277.0972%2C%22y%22%3A573.08105%2C%22width%22%3A167.72897%2C%22height%22%3A23.436709999999948%2C%22text%22%3A%222.Adclicked!%22%7D%2C%7B%22x%22%3A277.0213%2C%22y%22%3A600.0779%2C%22width%22%3A257.36347%2C%22height%22%3A27.633460000000014%2C%22text%22%3A%22Storetheassociated%22%7D%2C%7B%22x%22%3A275.68378%2C%22y%22%3A629.7937%2C%22width%22%3A197.01909999999998%2C%22height%22%3A21.236400000000003%2C%22text%22%3A%22datainbrowser%22%7D%2C%7B%22x%22%3A276.08875%2C%22y%22%3A655.53644%2C%22width%22%3A102.7817%2C%22height%22%3A22.634210000000053%2C%22text%22%3A%22storage.%22%7D%2C%7B%22x%22%3A27.001944%2C%22y%22%3A677.83154%2C%22width%22%3A121.465036%2C%22height%22%3A22.694560000000024%2C%22text%22%3A%22BROWSER%22%7D%2C%7B%22x%22%3A334.10333%2C%22y%22%3A723.9948%2C%22width%22%3A86.64386999999999%2C%22height%22%3A22.28895%2C%22text%22%3A%22ClickID%22%7D%2C%7B%22x%22%3A623.4695%2C%22y%22%3A725.30225%2C%22width%22%3A183.23199999999997%2C%22height%22%3A23.454450000000065%2C%22text%22%3A%22Conversiondata%22%7D%2C%7B%22x%22%3A334.04822%2C%22y%22%3A762.81885%2C%22width%22%3A114.10591999999997%2C%22height%22%3A17.22429999999997%2C%22text%22%3A%22200409698%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22ADTECHPLATFORM%20adtech.example%203.Converted!%201.Theadtech%20scriptisloaded.%20PUBLISHER%20ADVERTISER%20shoes.example%20news.example%20Checkout%204.Askthe%205.Later%3Athe%20pixel%20browser%20browserto%20sendsthe%20record_a%20conversionreport.%20conversion%20withacertain%20value.%202.Adclicked!%20Storetheassociated%20datainbrowser%20storage.%20BROWSER%20ClickID%20Conversiondata%20200409698%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A671%2C%22height%22%3A416%7D&quot;&gt;&lt;img data-height=&quot;416px&quot; data-ratio=&quot;0.6196868008948546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UnKibSlmUib8hcfU3x1Bh2Kmefia08PJgwib9X3qb8A2N0GbeakPdpetWLVrLuxscUnQeUlZX6MHOB4MYylSrImODA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1341&quot; title=&quot;diagram-overview.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7178d75347e6b5de6b1c24c4044aaf8c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cc3aa19ff3bb7437614d0699177f8f3c&quot;&gt;故事的主角没变：&lt;/p&gt;&lt;p data-lake-id=&quot;08293e629ddcc3751be684df902b0cca&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;b4659791c9d7b1667729d0cc1cf0d259&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;news.example是新闻站点，流量很高，靠互联网广告赚钱&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;shoes.example是卖鞋的购物网站，需要通过投放广告获取用户&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;adtech.example是广告服务商，shoes.example可以通过adtech.example在news.example投放广告&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;bd0d7e43a82fb9311876534af7da3c62&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cefb9a8a4de3014c87e16359c94f329b&quot;&gt;区别在于，广告商不再使用cookie保存用户的唯一ID，没法通过cookie来把用户在news.example点击广告的行为与用户在adtech.example的下单行为关联起来了，那这广告转化率还怎么算？&lt;/p&gt;&lt;p data-lake-id=&quot;f0786d2a232ed4ece6dfa0c72819124b&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0f9b99bb86dc7624bd3431e149c90a8b&quot;&gt;这时候Chrome就出来说了，你们别想什么数据都拿走了，我来决定给你什么数据，提出了Event Conversion Measurement API。&lt;/p&gt;&lt;p data-lake-id=&quot;eee2e51ce5bfbd4fd5d9818459ba09ce&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;84b6ecd035b210504de431f3274085dd&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户在news.example站点看新闻，会加载adtech.example的广告JS脚本，因此可以看到shoes.example的广告，点击广告就可以跳转到了shoes.example站点，用户的点击行为会记录到浏览器，存在本地&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户访问shoes.example的时候，用户的下单行为也会记录到浏览器&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根据adtech.example接入广告时配置的信息，浏览器可以把在news.example点击广告的行为与用户在adtech.example的下单行为关联起来，上报给广告服务商，这样广告服务商就可以计算转化率了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;浏览器在上报数据给广告服务商时，会进行一定的数据混淆，并且会有延时，这样可以进一步保护用户隐私。因为如果实时上报数据的话，广告服务商知道用户下单的准确时间，就能和广告主&quot;串通&quot;起来分析用户到底是谁。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;6fbcacf3788c086482c39f722b3df5a0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;44f7251dd780c777af0b9542b546608c&quot;&gt;由于跨站点的用户行为的关联是浏览器做的，因此广告服务商所能获取的用户数据将局限于浏览器所做的限制，Chrome可以决定给哪些数据、是否给完全精准的数据、什么时候给数据。Chrome的代码是开源的，Event Conversion Measurement API也是一个开放的标准，我们也不用担心Chrome会故意给自己留什么后门。&lt;/p&gt;&lt;p data-lake-id=&quot;3938258877e60af9e67f604cc48e7bb1&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5826b00f6eadec111bbdde4933cc3265&quot;&gt;看起来一切都很完美，用户隐私得到了保护，news.example、shoes.example、adtech.example也都赚到了钱。&lt;/p&gt;&lt;p data-lake-id=&quot;31051a4fdc9100006cce4135c2e14da8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;aa610c9c38e8bb7edbf46d1ac1364923&quot;&gt;但是，这事对adtech.example来说，还是有点难受，因为它没法获取全面的用户数据，也没法实时分析广告转化率了，也没法把用户在各个站点的用户行为串联起来了。用户隐私的保护确实增强了，但是互联网广告商的日子不太好过了，这也是合理并且也是趋势吧，现在的广告商们确实玩得有点过火了，搜集了太多用户数据。&lt;/p&gt;&lt;p data-lake-id=&quot;74ef2ee0294c75f2198c21a065a14bc7&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b076d97d9b8cfe5501446c2899f4cb3f&quot;&gt;还有一个问题，Event Conversion Measurement API其实有点复杂的，只是我没有讲得特别细（大家估计也没兴趣），如果每一个浏览器都自己搞一套类似于Chrome的Event Conversion Measurement API，复杂度差不多，然后还不太一样，那也是一件很头疼的事情:(&lt;/p&gt;&lt;p data-lake-id=&quot;755f39288463318c709c3740de677846&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;34e280ad20a98f0152247709c32cf844&quot;&gt;思考&lt;/h1&gt;&lt;p data-lake-id=&quot;0fdf18b898adb1352f063ca69601a109&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8f82b70f61b0893ef9832cdf61806af3&quot;&gt;Chrome解决互联网广告问题的技术方案确实还有点意思，也值得关注。不过，我最大的感慨倒不是这个问题本身。说白了这只是Chrome改变互联网行业的一件比较小的事情，与其他事相比也没什么。&lt;/p&gt;&lt;p data-lake-id=&quot;73d92f176870eaa7ec5d9482a496360c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;031db600a6713161b7cb58ce0cb3aa08&quot;&gt;正如我在1年前的博客&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5MDc5NTk2NQ==&amp;amp;mid=2247485311&amp;amp;idx=1&amp;amp;sn=6a0a50bd0f77daf3cb3357ff39c9d26f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JavaScript深入浅出第5课：Chrome是如何成功的？&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JavaScript深入浅出第5课：Chrome是如何成功的？&lt;/a&gt;中所写的，Chrome在诞生之初，就致力于推动Web技术向前发展：&lt;/p&gt;&lt;p data-lake-id=&quot;29b92b80a2ad137a6d1ce0d37ed6c1a9&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p data-lake-id=&quot;5f00dcaa804a3eb135293d50904f484a&quot;&gt;We hope to collaborate with the entire community to help drive the web forward.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-lake-id=&quot;9ce4ecb925451a8ced399cb893edd189&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;dddcb9baccfe83056e80ce5cb1fdbacc&quot;&gt;&lt;span data-mce-style=&quot;font-size: 11px&quot;&gt;这样的话在2008年大概没人相信，但是这不重要，重要的是Google真的做到了，Chrome确实推动了Web技术的发展。没有Chrome的话，就没有V8引擎，就没有Node.js，就没有NPM，就没有Babel，就没有ESLint，就没有VS Code，就没有Vue/React，就没有现在异常繁荣的前端生态系统，也没有&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 11px&quot;&gt;ECMAScript、HTTPS、HTTP/2、&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 11px&quot;&gt;HTTP/3、&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 11px&quot;&gt;WebAssemblys等Web相关技术标准的快速进步。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;eb3aa5e78e48331b127151265128ee3d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;6dbb95eded711200a02b18e9493f11ea&quot;&gt;功利一点，如果没有Chrome，Google这个互联网最大的广告商，它要怎么解决第三方Cookie被限制的问题，恐怕会非常被动。Facebook没有浏览器和操作系统的控制权，面对Apple，也是束手无策，沦落到在报纸上发广告自救，而这又有什么用呢？&lt;/p&gt;&lt;p data-lake-id=&quot;4e96afaf1cd673858893a98b5ac9b025&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3527bc90672f97899405918ab468a795&quot;&gt;所以，如果巨头们如果还没有危机感，还不去深入研究计算机的底层技术，搭建自己的技术生态系统，以后遇到同样的挑战的时候，大概也只能去发发报纸广告了。&lt;/p&gt;&lt;p data-lake-id=&quot;b2cf78cad4ceb024fe20510a0def87b7&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;b1961468cabea5be5e0427ece9bce9bb&quot;&gt;参考&lt;/h1&gt;&lt;ul data-lake-id=&quot;c97804cd9728857e61b1efe3f13a1e4a&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;A more private way to measure ad conversions, the Event Conversion Measurement API&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A more private way to measure ad conversions&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Using HTTP cookies&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;What are Third Party Cookies, How do they work?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SameSite Cookie Attribute Explained by Example (Strict, Lax, None &amp;amp; No SameSite)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Building a more private web: A path towards making third party cookies obsolete&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5MDc5NTk2NQ==&amp;amp;mid=2247485311&amp;amp;idx=1&amp;amp;sn=6a0a50bd0f77daf3cb3357ff39c9d26f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JavaScript深入浅出第5课：Chrome是如何成功的？&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JavaScript深入浅出第5课：Chrome是如何成功的？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;7467942e7b003185e405ad2344325e45&quot;&gt;&lt;span&gt;招聘&lt;/span&gt;&lt;/h1&gt;&lt;p data-lake-id=&quot;de4835ddf7e7a214a5403d922704bfe4&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;51f066d09a71deb3b7c38119d4f34e3d&quot;&gt;&lt;span&gt;&lt;span&gt;阿里巴巴业务平台事业部长期招聘P6及以上前端大佬，参与建设最前沿的阿里前端生态系统，推动行业技术发展，内推地址：&lt;/span&gt;&lt;span&gt;hanyan.lk@alibaba-inc.com&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;欢迎大家关注我的微信公众号&lt;/span&gt;&lt;strong&gt;寒雁Talk&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hQxPlpiaFxBs15sjiaeBQicnBdZU9zDvK2siaAPK2I0Eib1m6XthEG4EDEN4AibicibyibJwtNVTRdrZib33Bw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>