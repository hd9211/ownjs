<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>11ad6585985f065e64a61f4466164e40</guid>
<title>首个确保缓存与数据库一致性的方案</title>
<link>https://toutiao.io/k/imjqbp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2 tabindex=&quot;-1&quot;&gt;概述&lt;/h2&gt;&lt;p&gt;大量的实际的项目中，都会引入 Redis 缓存来缓解数据库的查询压力，此时由于一个数据在 Redis 和数据库两处进行了存储，就会有数据一致性的问题。目前业界尚未见到成熟的能够确保最终一致性的方案，特别是当如下场景发生时，会直接导致缓存数据与数据库数据不一致。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7247579529737206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/VNDQtnw16icLecJiaHcUyhQMmfTjtEA2RTUnhHD4uV0F3rd64YmWyhKB09sl2FdPHyUibdMpSV5xkXf60s4vcticDDKniaHqCc284/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;723&quot;/&gt;&lt;/p&gt;&lt;p&gt;在上述场景下，缓冲中的数据最终版本为v1，而数据库的最终版本为v2，可能给应用带来较大问题。&lt;/p&gt;&lt;p&gt;dtm-labs 致力于解决数据一致性问题，在分析了行业的现有做法后，提出了新解决方案dtm + rockscache，彻底解决了上述问题。另外作为一个成熟方案，该方案还可以防缓存穿透，防缓存击穿，防缓存雪崩，同时也可应用于要求数据强一致的场景。&lt;/p&gt;&lt;p&gt;关于管理缓存的现有方案，本文不再赘述，不太了解的同学可以参考下面这两篇文章&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;乱序产生的不一致&lt;/h2&gt;&lt;p&gt;在上述这个时序图中，由于服务1发生了进程暂停（例如由于GC导致），因此当它往缓存当中写入v1时，覆盖了缓存中的v2，导致了最终的不一致（DB中为v2，缓存中为v1）。&lt;/p&gt;&lt;p&gt;对于上述这类问题应当如何解决？目前现存的方案，全都没有彻底解决该问题，一般都是通过设定稍短的过期时间兜底。我们实现的缓存延迟删除方案，能够彻底解决这个问题，确保缓存与数据库之间的数据保持一致。解决原理如下：&lt;/p&gt;&lt;p&gt;缓存中的数据是一个hash，里面有以下几个字段：&lt;/p&gt;&lt;p&gt;查询缓存时：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;如果数据为空，且被锁定，则睡眠1s后，重新查询&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果数据为空，且未被锁定，同步执行&quot;取数据&quot;，返回结果&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果数据不为空，那么立即返回结果，并异步执行&quot;取数据&quot;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中&quot;取数据&quot;的操作定义为：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;判断是否需要更新缓存，下面两个条件满足其一，则需要更新缓存&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;如果需要更新，则锁定缓存，查询DB，校验锁持有者无变化，写入缓存，解锁缓存&lt;/p&gt;&lt;/li&gt;&lt;p&gt;当DB数据更新时，通过dtm确保数据更新成功时，将缓存延迟删除（将在后面一节展开详细讲解）&lt;/p&gt;&lt;p&gt;在上述的策略下：假如最后写入数据库的版本为Vi，最后写入到缓存的版本为V，写入V的uuid为uuidv，那么一定存在以下事件序列：&lt;/p&gt;&lt;p&gt;数据库写入Vi -&amp;gt; 缓存数据被标记为删除 -&amp;gt; 某个查询锁定数据并写入uuidv -&amp;gt; 查询数据库结果V -&amp;gt; 缓存中的锁定者为uuidv，写入结果V&lt;/p&gt;&lt;p&gt;在这个序列中，V的读取发生在写入Vi之后，所以V等于Vi，保证了缓存的数据的最终一致性。&lt;/p&gt;&lt;p&gt;dtm-labs/rockscache已经实现了上述方法，能够确保缓存数据的最终一致性。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Fetch&lt;/code&gt;函数实现了前面的查询缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;DelayDelete&lt;/code&gt;函数实现了延迟删除逻辑&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;感兴趣的同学，可以参考dtm-cases/cache，里面有详细的例子&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;DB与缓存操作的原子性&lt;/h2&gt;&lt;p&gt;对于缓存的管理，一般业界会采用写完数据库后，删除/更新缓存数据的策略。由于保存到缓存和保存到数据库两个操作之间不是原子的，一定会有时间差，因此这两个数据之间会有一个不一致的时间窗口，通常这个窗口不大，影响较小。但是两个中间可能发生宕机，也可能发生各种网络错误，因此就有可能发生完成了其中一个，但是未完成另一个，导致数据会出现长时间不一致。&lt;/p&gt;&lt;p&gt;举一个场景来说明上述不一致的情况，数据用户将数据 A 修改为 B ，应用修改完数据库之后，再去删除/更新缓存，如果未发生异常，那么数据库和缓存的数据是一致的，没有问题。但是分布式系统中，可能会发生进程crash、宕机等事件，因此如果更新完数据库，尚未删除/更新缓存时，出现进程crash，那么数据库和缓存的数据就可能出现长时间的不一致。&lt;/p&gt;&lt;p&gt;面对这里的长时间不一致的情况，想要彻底解决，并不是一件容易的事，我们下面分各种应用情况来介绍解决方案。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案一：较短的缓存时间&lt;/h4&gt;&lt;p&gt;这个方案，是最简单的方案，适合并发量不大应用。如果应用的并发不高，那么整个缓存系统，只需要设置了一个较短的缓存时间，例如一分钟。这种情况下数据库需要承担的负载是：大约每一分钟，需要将访问到的缓存数据全部生成一遍，在并发量不大的情况下，这种策略是可行的。&lt;/p&gt;&lt;p&gt;上述这种策略非常简单，易于理解和实现，缓存系统提供的语义是，大多数情况下，缓存和数据库之间不一致的时间窗口是很短的，在较低概率发生进程crash的情况下，不一致的时间窗口会达到一分钟。&lt;/p&gt;&lt;p&gt;应用在上述约束下，需要将一致性要求不高的数据读取，从缓存读取；而将一致性要求较高的读，不走缓存，直接从数据库查询。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案二：消息队列保证一致&lt;/h4&gt;&lt;p&gt;假如应用的并发量很高，缓存过期时间需要比一分钟更长，而且应用中的大量请求不能够容忍较长时间的不一致，那么这个时候，可以通过使用消息队列的方式，来更新缓存。具体的做法是：&lt;/p&gt;&lt;p&gt;这种做法可以保证数据库更新之后，缓存一定会被更新。但这种这种架构方案很重，这几个部分开发维护成本都不低：消息队列的维护；高效轮询任务的开发与维护。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案三：订阅 binlog&lt;/h4&gt;&lt;p&gt;这个方案适用场景与方案二非常类似，原理又与数据库的主从同步类似，数据库的主从同步是通过订阅binlog，将主库的更新应用到从库上，而这个方案则是通过订阅binlog，将数据库的更新应用到缓存上。具体做法是：&lt;/p&gt;&lt;p&gt;这种方案也可以保证数据库更新之后，缓存一定会被更新，但是这种架构方案跟前面的消息队列方案一样，也非常重。一方面 canal 的学习维护成本不低，另一方面，开发者可能只需要少量数据更新缓存，通过订阅所有的 binlog 来做这个事情，浪费了很多资源。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案四：dtm 二阶段消息方案&lt;/h4&gt;&lt;p&gt;dtm 里的二阶段消息模式，非常适合这里的修改数据库之后更新/删除缓存，主要代码如下：&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20534458509142053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VstsDlZWn1DicInYoJUPQe5tXCbBk3NHJaZDVfiatcHOJZMQPDlkcU4y3byGmP3z8Uk9eGxThodsvLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1422&quot;/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这段代码，DoAndSubmitDB会进行本地数据库操作，进行数据库的数据修改，修改完成后，会提交一个二阶段消息事务，消息事务将会异步调用 UpdateRedis。假如本地事务执行之后，就立刻发生了进程 crash 事件，那么 dtm 会进行回查调用 QueryPrepared ，保证本地事务提交成功的情况下，UpdateRedis 会被最少成功执行一次。&lt;/p&gt;&lt;p&gt;回查的逻辑非常简单，只需要copy类似下面这样的代码即可：&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10909090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VstsDlZWn1DicInYoJUPQe5tMiawYOaDlQpCM03XQRekicRL3Xds9hMSYuolZqA9wVPm2aSaib6uCKoIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种方案的优点：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;从库延时&lt;/h4&gt;&lt;p&gt;上述的方案中，假定缓存删除后，服务进行数据查询，总是能够查到最新的数据。但是实际的生产环境中，可能会出现主从分离的架构，而主从延时并不是一个可控的变量，那么这时候又要怎么处理？&lt;/p&gt;&lt;p&gt;处理方案两种：一是区分最终一致性很高和不高的缓存数据，查询数据时，将要求很高的数据必须从主库读取，而把要求不高的数据从从库读取。对于使用了rockscache的应用来说，高并发的请求都会在Redis这一层被拦截，对于一个数据，最多只会有一个请求到达数据库，因此数据库的负载已大幅降低，采用主库读取是一个实际可行的方案。&lt;/p&gt;&lt;p&gt;另一种方案是，主从分离需要采用不分叉的单链架构，那么链条末尾的从库必定是延迟最长的从库，此时采用监听binlog的方案，需要监听链条做末端的从库binlog，当收到数据变更通知时，按照上述方案将缓存标记为延迟删除。&lt;/p&gt;&lt;p&gt;这两个方案各有优缺点，业务可以根据自己的特点采用。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;防缓存击穿&lt;/h2&gt;&lt;p&gt;rockscache还可以防缓存击穿。当数据变更时，业界现有做法既可以选择更新缓存，也可以选择删除缓存，各有优劣。而延迟删除综合了两种方法的优势，并克服了两种方法的劣势：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;更新缓存&lt;/h4&gt;&lt;p&gt;采取更新缓存策略，那么会为所有的DB数据更新生成缓存，不区分冷热数据，那么会存在以下问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;内存上，即使一个数据没有被读取，也会保存在缓存里，浪费了宝贵的内存资源；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在计算上，即使一个数据没有被读取，也可能因为多次更新，被多次计算，浪费了宝贵的计算资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上述的乱序不一致发生的概率会较高，当两个临近的更新中出现延迟，就可能触发。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;删除缓存&lt;/h4&gt;&lt;p&gt;因为前面的更新缓存做法问题较多，因此大多数的实践采用的是删除缓存策略，查询时再按需生成缓存。这种做法解决了更新缓存中的问题，但是又带来新问题：&lt;/p&gt;&lt;p&gt;为了防止缓存击穿，通用的做法是使用分布式 Redis 锁保证只有一个请求到数据库，等缓存生成之后，其他请求进行共享。这种方案能够适合很多的场景，但有些场景却不适合。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;例如有一个重要的热点数据，计算代价比较高，需要3s才能够获得结果，那么上述方案在删除一个这种热点数据之后，就会在这个时刻，有大量请求3s才返回结果，一方面可能造成大量请求超时，另一方面3s没有释放链接，会导致并发连接数量突然升高，可能造成系统不稳定。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;另外使用 Redis 锁时，未获得锁的这部分用户，通常会定时轮询，而这个睡眠时间不好设定。如果设定比较大的睡眠时间1s，那么对于10ms就计算出结果的缓存数据，返回太慢了；如果设定的睡眠时间太短，那么很消耗 CPU 和 Redis 性能&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;延迟删除法的应对策略&lt;/h4&gt;&lt;p&gt;前面介绍的dtm-labs/rockscache实现的延时删除法也属于删除法，但它彻底解决了删除缓存中的击穿问题，以及击穿带来的附带问题。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存击穿问题：延迟删除法中，如果缓存中的数据不存在，那么会锁定缓存中的这条数据，因此避免了多个请求打到后端数据库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上述大量请求3s才返回数据，以及定时轮询的问题，在延时删除中也不存在，因为热点数据被延时删除时，旧版本的数据还在缓存中，会被立即返回，无需等待。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们来看看不同的数据访问频率下，延迟删除法的表现如何：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;热点数据，每秒1K qps，计算缓存时间5ms，此时延迟删除法，大约5~8ms左右的时间里，会返回过期数据，而先更新DB，再更新缓存，因为更新缓存需要时间，也会有大约0~3ms返回过期数据，因此两者差别不大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;热点数据，每秒1K qps，计算缓存时间3s，此时延迟删除法，大约3s的时间里，会返回过期数据。对比于等待3s后再返回数据，那么返回旧数据，通常是更好的行为。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;普通数据，每秒50 qps，计算缓存时间1s，此时延迟删除法的行为分析，类似2，没有问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;低频数据，5秒访问一次，计算缓存时间3s，此时延迟删除法的行为与删除缓存策略基本一样，没有问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;冷数据，10分钟访问一次，此时延迟删除法，与删除缓存策略基本一样，只是数据比删除缓存的方式多保存10s，占用空间不大，没有问题&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;有一种极端情况是，那就是原先缓存中没有数据，突然大量请求到来，这种场景对，更新缓存法删除缓存法，延迟删除法，都是不友好的。这种的场景是开发人员需要避免的，需要通过预热来解决，而不应当直接扔给缓存系统。当然，由于延迟删除法已经把打到数据库的请求量降到最低，因此表现也不弱于任何其他方案。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;防缓存穿透与缓存雪崩&lt;/h2&gt;&lt;p&gt;dtm-labs/rockscache还实现了防缓存穿透与缓存雪崩。&lt;/p&gt;&lt;p&gt;缓存穿透是指，缓存和数据库都没有的数据，被大量请求。由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。rockscache中可以设定&lt;code&gt;EmptyExipire&lt;/code&gt;设定对空结果的缓存时间，如果设定为0，那么不缓存空数据，关闭防缓存穿透&lt;/p&gt;&lt;p&gt;缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。rockscache可以设定&lt;code&gt;RandomExpireAdjustment&lt;/code&gt;，对过期时间加上随机值，避免同时过期。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;应用能否做到强一致？&lt;/h2&gt;&lt;p&gt;上面已经介绍了缓存一致性的各种场景，以及相关的解决方案，那么是否可以保证使用缓存的同时，还提供强一致的数据读写呢？强一致的读写需求比前面的最终一致的需求场景少，但是在金融领域，也是有不少场景的。&lt;/p&gt;&lt;p&gt;当我们在这里讨论强一致时，我们需要先把一致性的含义做一下明确。&lt;/p&gt;&lt;p&gt;开发者最直观的强一致性很可能理解为，数据库和缓存保持完全一致，写数据的过程中以及写完之后，无论从数据库直接读，或者从缓存直接读，都能够获得最新写入的结果。对于这种两个独立系统之间的“强一致性”，可以非常明确的说，理论上是不可能的，因为更新数据库和更新缓存在不同的机器上，无法做到同时更新，无论如何都会有时间间隔，在这个时间间隔里，一定是不一致的。&lt;/p&gt;&lt;p&gt;但是应用层的强一致性，则是可以做到的。可以简单考虑我们熟悉的场景：CPU的缓存作为内存的缓存，内存作为磁盘的缓存，这些都是缓存的场景，从来没有发生过一致性问题。为什么？其实很简单，要求所有的数据使用方，只能够从缓存读取数据，而不能同时从缓存和底层存储同时读取数据。&lt;/p&gt;&lt;p&gt;对于DB和Redis，如果所有的数据读取，只能够由缓存提供，就可以很容易的做到强一致，不会出现不一致的情况。下面我们来根据DB和Redis的特点，来分析其中的设计：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;先更新缓存还是DB&lt;/h4&gt;&lt;p&gt;类比CPU缓存与内存，内存缓存与磁盘，这两个系统都是先修改缓存，再修改底层存储，那么到了现在的DB缓存场景是否也先修改缓存再修改DB？&lt;/p&gt;&lt;p&gt;在绝大多数的应用场景下，开发者会认为Redis作为缓存，当Redis出现故障时，那么应用需要支持降级处理，依旧能够访问数据库，提供一定的服务能力。考虑这种场景，一旦出现降级，先写缓存再写DB方案就有问题，一方面会丢失数据，另一方面会发生先读取到缓存中的新版本v2，再读取到旧版本v1。因此在Redis作为缓存的场景下，绝大部分系统会采取先写入DB，再写入缓存的这种设计&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;写入DB成功缓存失败情况&lt;/h4&gt;&lt;p&gt;假如因为进程crash，导致写入DB成功，但是标记延迟删除第一次失败怎么办？虽然间隔几秒之后，会重试成功，但这几秒钟的时间里，用户去读取缓存，依旧还是旧版本的数据。例如用户发起了一笔充值，资金已经进入到DB，只是更新缓存失败，导致从缓存看到的余额还是旧值。这种情况的处理很简单，用户充值时，写入DB成功时，应用不要给用户返回成功，而是等缓存更新也成功了，再给用户返回成功；用户查询充值交易时，要查询DB和缓存是否都成功了（可以查询二阶段消息全局事务是否已成功），只有两者都成功了，才返回成功。&lt;/p&gt;&lt;p&gt;在上述的处理策略下，当用户发起充值后，在缓存更新完成之前，用户看到的是，这笔交易还在处理中，结果未知，此时是符合强一致要求的；当用户看到交易已经处理成功，也就是缓存已更新成功，那么所有从缓存中拿到的数据都是更新后的数据，那么也符合强一致的要求。&lt;/p&gt;&lt;p&gt;dtm-labs/rockscache也实现了强一致的读取需求。当打开&lt;code&gt;StrongConsistency&lt;/code&gt;选项，那么rockscache里&lt;code&gt;Fetch&lt;/code&gt;函数就提供了强一致的缓存读取。其原理与延迟删除差别不大，仅做了很小的改变，就是不再返回旧版本的数据，而是同步等待“取数据”的最新结果&lt;/p&gt;&lt;p&gt;当然这个改变会带来性能上的下降，对比与最终一致的数据读取，强一致的读取一方面要等待当前“取数据”的最新结果，增加了返回延迟，另一方面要等待其他进程的结果，会产生sleep等待，耗费资源。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;缓存降级升级中的强一致&lt;/h2&gt;&lt;p&gt;上述的强一致方案中，说明了其强一致的前提是：“所有的数据读取，只能够由缓存”。不过如果Redis如果发生故障，需要进行降级，那么降级的过程可能很短只有几秒，但是这个几秒内如果不能接受不可访问，还严苛的要求提供访问的话，就会出现读取缓存和读取DB混用情况，就不满足这个前提。不过因为Redis故障的频率不高，要求强一致性的应用通常配备专有Redis，因此遇见故障降级的概率很低，很多应用不会在这个地方提出苛刻的要求。&lt;/p&gt;&lt;p&gt;不过dtm-labs作为数据一致性领域的领导者，也深入研究了这个问题，并给出这种苛刻条件下的解决方案。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;升降级的过程&lt;/h4&gt;&lt;p&gt;现在我们来考虑应用在Redis缓存出现问题的升降级处理。一般情况下这个升降级的开关在配置中心，当修改配置后，各个应用进程会陆续收到降级配置变更通知，然后在行为上降级。在降级的过程中，会出现缓存与DB混合访问的情况，这时我们上面的方案就有可能出现不一致。那么如何处理才能够保证在这种混合访问的情况下，依旧能够让应用获取到强一致的结果呢？&lt;/p&gt;&lt;p&gt;混合访问的过程中，我们可以采取下面这个策略，来保证DB和缓存混合访问时的数据一致性。&lt;/p&gt;&lt;p&gt;这个策略跟前面不考虑降级场景的强一致方案，差别不大，读数据部分完全不变，需要变的是更新数据。rockscache假定更新DB是一个业务上可能失败的操作，于是采用一个SAGA事务来保证原子操作，详情参见例子dtm-cases/cache&lt;/p&gt;&lt;p&gt;升降级的开启关闭有顺序要求，不能够同时开启缓存读和写，而是需要在开启缓存读的时候，所有的写操作都已经确保会更新缓存。&lt;/p&gt;&lt;p&gt;降级的详细过程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最初状态：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;读降级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：关闭缓存读。混合读 =&amp;gt; 全部DB读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;写降级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：全部DB读；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：关闭缓存写。DB+缓存 =&amp;gt; 只写DB&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;升级的过程与此相反，如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最初状态：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;写升级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：全部读DB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：打开写缓存。只写DB =&amp;gt; 写DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;读升级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：部分读缓存。全部读DB =&amp;gt; 混合读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：写DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;dtm-labs/rockscache已实现了上述强一致的缓存管理方法。&lt;/p&gt;&lt;p&gt;感兴趣的同学，可以参考dtm-cases/cache，里面有详尽的例子&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;&lt;p&gt;这篇文章很长，许多的分析比较晦涩，最后将Redis缓存的使用方式做个总结：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最简单的方式为：较短的缓存时间，允许少量数据库修改，未同步删除缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;保证最终一致，并且可防缓存击穿的方式为：二阶段消息+延迟删除(rockscache)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;强一致：二阶段消息+强一致(rockscache)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一致性要求最严苛的方式为：二阶段消息+强一致(rockscache)+升降级兼容&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于后两种方式，我们都推荐使用dtm-labs/rockscache来作为您的缓存方案&lt;/p&gt;&lt;h2&gt;联系我们&lt;/h2&gt;&lt;p&gt;欢迎访问我们的项目，并star支持我们：&lt;/p&gt;&lt;p&gt;https://github.com/dtm-labs/dtm&lt;/p&gt;&lt;p&gt;https://github.com/dtm-labs/rockscache&lt;/p&gt;&lt;p&gt;关注【分布式事务】公众号，获得更多分布式事务相关知识&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNzQ2NzMyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94Vv04GUcaMFCzcfHeGnTECibTEibP26ByiaHcdD7qYLNFAyQcDvbVBerQs55hXppwia3XpPjIYF3MKGzVQ/0?wx_fmt=png&quot; data-nickname=&quot;分布式事务&quot; data-alias=&quot;wangxiyan0901&quot; data-signature=&quot;介绍分布式事务相关理论与实践知识。 开源项目dtm-labs/dtm的相关信息发布。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f70e478aa28c929443feb4e9808417b3</guid>
<title>为什么人们都讨厌HR？</title>
<link>https://toutiao.io/k/vlnwz8s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创不易，求分享、求一键三连&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天粉丝群有个同学在抱怨HR，原因是开始说工资是30k，进来后发现是25K基本工资+5K的绩效工资，但人已经入职了，由于害怕报复，只能默默接受，还不敢表达不满！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此他大力吐槽，群里马上就开始了群情激奋，另一个同学也开始抱怨：他人在深圳，拿了一个北京的offer，于是辞掉了自己的工作，但北京HR却以&lt;strong&gt;HC没有了&lt;/strong&gt;为由拒绝他入职，这可把他气坏了，但最后考虑仲裁成本也只能默默咽下这口气！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此起彼伏，另一个同学开始接龙：他嫌自己工资低，于是就跟一个关系很好的HR小姐姐抱怨，并表达了少许离职倾向，但第二天Leader就知道了...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，HR做的事真的有点讨人厌呢，那他为什么要做那些事呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HR的角色&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天文章一段话引起了很多粉丝的不满：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我经常看到几个同学&lt;strong&gt;18.00后在园区打羽毛球&lt;/strong&gt;，&lt;strong&gt;那个惬意啊&lt;/strong&gt;，看着工资低但是时薪高啊！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一些吐槽：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;恶心人的高级打工仔，关注叶大很久了，这篇文章充满了小人得志的味道，18点打球怎么了，是你叶老板在发工资还是园区被你买下来了?说话做事带点脑子吧&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;18点后，下班了，打个羽毛球叫惬意，你咋想的哦？要24小时上班？&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;你家开工资是24小时的时薪？18.00后不是下班时间？关你屁事？&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;可能是因为前面铺垫太多，OKR出现时已是文章末尾，导致大家关注点就是打球、惬意、工资低、内卷。叶总一句无心之举，捅了马蜂窝了。这就是立场不同，感受不同吧&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的上下文是：今年行情不好，加薪的事情一直没被提起，我作为技术负责人身份跟公司谈判&lt;strong&gt;加薪方案&lt;/strong&gt;，其中重要说辞是首先同学们&lt;strong&gt;加班太辛苦&lt;/strong&gt;，如果毫无激励，肯定不能持久；其次前段时间裁员问题引发的&lt;strong&gt;不稳定性&lt;/strong&gt;，也需要一些激励，于是我天天去烦老板：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7002457002457002&quot; data-type=&quot;png&quot; data-w=&quot;814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBZE00AdsP6iciavXsIDN8njZozk5cdLLnD6ZfshpEh8sjvdtEcO7mjY4YsUibiaqYcUNaFTsEW9lgxCg/640?wx_fmt=png&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5406091370558376&quot; data-type=&quot;png&quot; data-w=&quot;788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBZE00AdsP6iciavXsIDN8njZaVkvC8XdJHVtOhCVaydlmLbibEeiciaw58UPFulJPqCnFEhSLEnEWUpicw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但汇报方案时候，HR一顿怼就搞得我很被动了：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;你们研发同学天天18.00就走了，很多还在楼下打羽毛球，加班好像不是很厉害嘛...&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间、地点、人物、事情，还有每天的频率，我内心马上就开始MMP了：干嘛非要在楼下打羽毛球啊！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这个故事中就出现了四个角色，每个角色的责任是不一样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老板，买单方；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HR体系，监督方；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术Leader，代表技术利益；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一线研发，代表自己；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老板追求的是全局最优，加不加工资，加多少工资他其实都无所谓，他看重全局ROI，所以他需要一个客观的数字；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;技术负责人追求的是团队最优，能加工资，能加更多的工资，这个对他后续的管理会有莫大的帮助，所以他甚至会刻意夸大困难，夸大贡献，夸大危机，就是为了多要一分钱；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HR体系事实上是&lt;strong&gt;监督者&lt;/strong&gt;，他代表是老板利益，会尽量的降低这个数字，所以在这个场景上，HR和技术负责人是绝对对立的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于工作变化原因，除了技术负责人，还兼任了公司OC，这涉及了部分HR的角色，所以我一方面要站在技术角色思考问题，为他们谋福利；另一方面又要站在HR角度思考问题，帮公司做&lt;strong&gt;监控&lt;/strong&gt;，于是很多问题就有了答案：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HR代表的是绝大部分股东的利益，多数时候代表的是CEO的利益，所以他服务的不是员工而是CEO，员工满意度对HR来说可以不那么重要。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HR与员工的关系是&lt;strong&gt;监护与被监护的关系&lt;/strong&gt;，多数时候是监督，少数时候是保护，保护的动作是提醒员工，哪些地方是红线，不能触碰。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HR的职责是追求&lt;strong&gt;人效最高&lt;/strong&gt;，所以压低工资，拒绝加薪升职，推动裁员是他们的常见工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，HR体系服务的是公司，是员工们的监护人，追求的是人效最高，所以评价他们的工作也要从这几点出发，跟这没关系的当然也不重要了...&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了以上逻辑，我们再看一些&lt;strong&gt;HR讨厌&lt;/strong&gt;的一些案例，其实就开始正常了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为HR想要的是成本更低，所以使用谈判技巧，比如谈工资时的语焉不详，不讲清楚绩效工资就很正常了；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有高端一点的，只聊正常工资，但会在年终奖一块稍有修饰，毕竟年终跟考核关系巨大，这块你拿低了也说不着谁；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有更高端的会在期权做文章，因为期权对应的转换比例、行权价等对于一般员工比较遥远，员工多数时候搞不懂，有专业性就有门槛，有门槛的就不透明，不透明就可操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;吃拿卡要是不少部门会采取的策略，可能销售团队喜欢吃，研发团队喜欢要，HR团队一般喜欢卡，所谓卡就是&lt;strong&gt;设定规则&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你作为研发负责人想要提拔下面同学，那是必须经过HR的，那么HR就会给你设定一个规则，比如总监级以上职位，必须什么级别的人联合评审，必须通过HR，更有甚者必须通过CEO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CEO和其他部门负责人才懒得参与晋升评审，他们其实是HR的工具人，制度必须表面公平嘛，因为HR多半情况有一票否决权，他可以不用但不能没有，一旦他有一票否的权限，那么大家平时是不是要更尊重他呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但HR有一定权威性并不完全是什么坏事，因为有大量的机制流程需要他们推动，所以老板们还是要给他站台的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;招聘任务&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客观规律&lt;strong&gt;谁痛谁解决&lt;/strong&gt;，很多人错误的认为招聘是HR的工作，其实招聘从来就是部门负责人的工作，你的工作忙又不是HR的工作忙，HR又不对你今年的指标负责...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以找简历、筛选简历重来不是HR会着急的，当然也有级别低一点的HR会埋头苦干，但可能质量不会咋地，毕竟我给了，质量不行我也没发，是个很好的说辞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;候选人进入HR面才是他的工作：压级别、卡工资，偶尔招人单位就得不停的求着HR放放水，至于放不放取决于他们的红线和你的关系，只要不触碰红线那么都可以聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为使招聘加速，偶尔用人单位会在部门级会上夸大下招人进度引起的问题，但一般来说聊胜于无...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HR当然也有不得不充当替罪羊的时候，比如公司效益不好需要控制成本，这个锅一般就是HR站出来背，大家都会吐槽HR给出来的策略没人性，但却也无可奈何。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别是部门负责人会尽可能的将仇恨往他们身上引，其实这背后是有管理层意志的，有时候群情激奋也可能导致HR负责人离职，但HR体系多半不产生生产力，所以可替换性还挺高的...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有更进一步的体系提出了政委制，讲究业务发展&lt;strong&gt;匹配组织建设&lt;/strong&gt;，HR扮演的政委就是要完成组织匹配的工作，构想其实是好的，但是还是要看HR体系整个人才质量，如果只是&lt;strong&gt;换汤不换药&lt;/strong&gt;其实意义不大...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司里的人才法体系代表的都是公司利益，认准这一点就不会错误的把HR小姐姐当做知心好友了，所以在一些事件发生的时候也站在他们的角度思考下问题，毕竟那可能是他的职责所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后总结一下，HR代表的是公司，跟员工之间的关系是监护（多数监督加少许保护），目标是提升人效。这个群体门槛较低，多数不了解业务不代表生产力所以看上去无所事事，群众看不到HR的价值，群众以为HR的价值和他实际的价值不符，这是很多人讨厌HR的原因。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以嘛，你讨厌一个事物，可能仅仅是因为你不了解他罢了...&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的分享就到这，喜欢的同学可以四连支持：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11333333333333333&quot; data-type=&quot;png&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBZE00AdsP6iciavXsIDN8njZ9ppgsriaKLW819RqbStdCLoRx91S006jDYFFSibqcohYwhklmXqGGUww/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要更多交流可以加我微信：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5549076773566569&quot; data-type=&quot;png&quot; data-w=&quot;2058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTBZE00AdsP6iciavXsIDN8njZcwuFY8M5R8ibO3ydwMPK65enI10UxAMibPBRHq0S0niccSibAVy31kSnEA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9ec25e525d0b6a46e4c4507eab70359</guid>
<title>eBPF编程指北</title>
<link>https://toutiao.io/k/fn0j0ty</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;开发环境&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里以 Ubuntu 20.04 为例构建 eBPF 开发环境：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ uname -a&lt;br/&gt;Linux VM-1-3-ubuntu 5.4.0-42-generic &lt;span&gt;#46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux&lt;/span&gt;&lt;br/&gt;$ sudo apt install build-essential git make libelf-dev clang llvm strace tar bpfcc-tools linux-headers-$(uname -r) gcc-multilib  flex  bison libssl-dev -y&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;主流的发行版在对 LLVM 打包的时候就默认启用了 BPF 后端，因此，在大部分发行版上安 装 clang 和 llvm 就可以将 C 代码编译为 BPF 对象文件了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;典型的工作流是：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 C 编写 BPF 程序&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 LLVM 将 C 程序编译成对象文件（ELF）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用户空间 BPF ELF 加载器（例如 iproute2）解析对象文件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加载器通过 bpf() 系统调用将解析后的对象文件注入内核&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核验证 BPF 指令，然后对其执行即时编译（JIT），返回程序的一个新文件描述符&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;利用文件描述符 attach 到内核子系统（例如网络子系统）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;某些子系统还支持将 BPF 程序 offload 到硬件（例如网卡）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看 LLVM 支持的 BPF target：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ llc --version&lt;br/&gt;LLVM (http://llvm.org/):&lt;br/&gt;  LLVM version 10.0.0&lt;br/&gt;&lt;br/&gt;  Optimized build.&lt;br/&gt;  Default target: x86_64-pc-linux-gnu&lt;br/&gt;  Host CPU: skylake&lt;br/&gt;&lt;br/&gt;  Registered Targets:&lt;br/&gt;    &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;    bpf        - BPF (host endian)&lt;br/&gt;    bpfeb      - BPF (big endian)&lt;br/&gt;    bpfel      - BPF (little endian)&lt;br/&gt;    &lt;span&gt;# ...&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;默认情况下，bpf target 使用编译时所在的 CPU 的大小端格式，即，如果 CPU 是小端，BPF 程序就会用小端表示；如果 CPU 是大端，BPF 程序就是大端。这也和 BPF 的运行时行为相匹配，这样的行为比较通用，而且大小端格式一致&lt;/span&gt;&lt;span&gt;可以避免一些因为格式导致的架构劣势&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序可以在大端节点上编译，在小端节点上运行，或者相反，因此对于交叉编译， 引入了两个新目标 bpfeb 和 bpfel。注意前端也需要以相应的大小端方式运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在不存在大小端混用的场景下，建议使用 bpf target。例如，在 x86_64 平台上（小端 ），指定 bpf 和 bpfel 会产生相同的结果，因此触发编译的脚本不需要感知到大小端 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;下面是一个最小的完整 XDP 程序，实现丢弃包的功能（xdp-example.c）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int xdp_drop(struct xdp_md *ctx)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; XDP_DROP;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用下面的命令编译并加载到内核：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ clang -O2 -Wall -target bpf -c xdp-example.c -o xdp-example.o&lt;br/&gt;$ ip link &lt;span&gt;set&lt;/span&gt; dev em1 xdp obj xdp-example.o&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;编程限制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 C 语言编写 BPF 程序不同于用 C 语言做应用开发，有一些陷阱需要注意。本节列出了 二者的一些不同之处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;所有函数都需要内联（inlined）、没有函数调用（对于老版本 LLVM）或共享库调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 不支持共享库（Shared libraries）。但是，可以将常规的库代码（library code）放到头文件中，然后在主程序中 include 这些头文件，例如 Cilium 就大量使用了这种方式 （可以查看 bpf/lib/ 文件夹）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，也可以 include 其他的一些头文件，例如内核或其他库中的头文件，复用其中的静态内联函数（static inline functions）或宏/定义（ macros / definitions）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核 4.16+ 和 LLVM 6.0+ 之后已经支持 BPF-to-BPF 函数调用。对于任意给定的程序片段 ，在此之前的版本只能将全部代码编译和内联成一个扁平的 BPF 指令序列（a flat sequence of BPF instructions）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在这种情况下，最佳实践就是为每个库函数都使用一个 像 __inline 一样的注解（annotation ），下面的例子中会看到。推荐使用 always_inline，因为编译器可能会对只注解为 inline 的长函数仍然做 uninline 操 作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果是后者，LLVM 会在 ELF 文件中生成一个重定位项（relocation entry），BPF ELF 加载器（例如 iproute2）无法解析这个重定位项，因此会产生一条错误，因为对加载器 来说只有 BPF maps 是合法的、能够处理的重定位项。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __inline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __inline                         \&lt;/span&gt;&lt;br/&gt;   inline __attribute__((always_inline))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;static __inline int foo(void)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; XDP_DROP;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int xdp_drop(struct xdp_md *ctx)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; foo();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;多个程序可以放在同一 C 文件中的不同 section&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF C 程序大量使用 section annotations。一个 C 文件典型情况下会分为 3 个或更 多个 section。BPF ELF 加载器利用这些名字来提取和准备相关的信息，以通过 bpf() 系统调用加载程序和 maps。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，查找创建 map 所需的元数据和 BPF 程序的 license 信息 时，iproute2 会分别使用 maps 和 license 作为默认的 section 名字。注意在程序创建时 license section 也会加载到内核，如果程序使用的是兼容 GPL 的协议，这些信息就可以启用那些 GPL-only 的辅助函数，例如 bpf_ktime_get_ns() 和 bpf_probe_read() 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其余的 section 名字都是和特定的 BPF 程序代码相关的，例如，下面经过修改之后的代码包含两个程序 section：&lt;/span&gt;&lt;span&gt;ingress&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt; 和 &lt;/span&gt;&lt;span&gt;egress&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。这个非常简单的示例展示了不同 section （这里是 ingress 和 egress）之间可以共享 BPF map 和常规的静态内联辅助函数（例如 account_data()）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例程序：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里将原来的 xdp-example.c 修改为 tc-example.c，然后用 tc 命令加载，attach 到 一个 netdevice 的 ingress 或 egress hook。该程序对传输的字节进行计数，存储在一 个名为 acc_map 的 BPF map 中，这个 map 有两个槽（slot），分别用于 ingress hook 和 egress hook 的流量统计。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;linux/pkt_cls.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;iproute2/bpf_elf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __inline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __inline                         \&lt;/span&gt;&lt;br/&gt;   inline __attribute__((always_inline))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef lock_xadd&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define lock_xadd(ptr, val)              \&lt;/span&gt;&lt;br/&gt;   ((void)__sync_fetch_and_add(ptr, val))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef BPF_FUNC&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define BPF_FUNC(NAME, ...)              \&lt;/span&gt;&lt;br/&gt;   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_&lt;span&gt;##NAME&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);&lt;br/&gt;&lt;br/&gt;struct bpf_elf_map acc_map __section(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;) = {&lt;br/&gt;    .&lt;span&gt;type&lt;/span&gt;           = BPF_MAP_TYPE_ARRAY,&lt;br/&gt;    .size_key       = sizeof(uint32_t),&lt;br/&gt;    .size_value     = sizeof(uint32_t),&lt;br/&gt;    .pinning        = PIN_GLOBAL_NS,&lt;br/&gt;    .max_elem       = 2,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;static __inline int account_data(struct __sk_buff *skb, uint32_t dir)&lt;br/&gt;{&lt;br/&gt;    uint32_t *bytes;&lt;br/&gt;&lt;br/&gt;    bytes = map_lookup_elem(&amp;amp;acc_map, &amp;amp;dir);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (bytes)&lt;br/&gt;            lock_xadd(bytes, skb-&amp;gt;len);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;ingress&quot;&lt;/span&gt;)&lt;br/&gt;int tc_ingress(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; account_data(skb, 0);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;egress&quot;&lt;/span&gt;)&lt;br/&gt;int tc_egress(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; account_data(skb, 1);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其他程序说明：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个例子还展示了其他一些很有用的东西，在开发过程中要注意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，include 了内核头文件、标准 C 头文件和一个特定的 iproute2 头文件 iproute2/bpf_elf.h&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，后者定义了struct bpf_elf_map。iproute2 有一个通用的 BPF ELF 加载器，因此 struct bpf_elf_map的定义对于 XDP 和 tc 类型的程序是完全一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，程序中每条 struct bpf_elf_map 记录（entry）定义一个 map&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，这个记录包含了生成一 个（ingress 和 egress 程序需要用到的）map 所需的全部信息（例如 key/value 大 小）。这个结构体的定义必须放在 maps section，这样加载器才能找到它。可以用这个 结构体声明很多名字不同的变量，但这些声明前面必须加上 __section(&quot;maps&quot;) 注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;结构体 struct bpf_elf_map 是特定于 iproute2 的。不同的 BPF ELF 加载器有不同的格式，例如，内核源码树中的 libbpf（主要是 perf 在用）就有一个不同的规范 （结构体定义）。iproute2 保证 struct bpf_elf_map 的后向兼容性。Cilium 采用的 是 iproute2 模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，这个例子还展示了 BPF 辅助函数是如何映射到 C 代码以及如何被使用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里首先定义了一个宏 BPF_FUNC，接受一个函数名 NAME 以及其他的任意参数。然后用这个宏声明了一 个 NAME 为 map_lookup_elem 的函数，经过宏展开后会变成 BPF_FUNC_map_lookup_elem 枚举值，后者以辅助函数的形式定义在 uapi/linux/bpf.h。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;当随后这个程序被加载到内核时，校验器会检查传入的参数是否是期望的类型，如果是，就将辅助函数调用重新指向（re-points）某个真正的函数调用。另外，map_lookup_elem() 还展示了 map 是如何传递给 BPF 辅助函数的。这里，maps section 中的 &amp;amp;acc_map 作为第一个参数传递给 map_lookup_elem()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于程序中定义的数组 map （array map）是全局的，因此&lt;/span&gt;&lt;span&gt;计数时需要使用原子操作&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，这里 是使用了 lock_xadd()。LLVM 将 __sync_fetch_and_add() 作为一个内置函数映射到 BPF 原子加指令，即 BPF_STX | BPF_XADD | BPF_W（for word sizes）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，struct bpf_elf_map 中的 .pinning 字段初始化为 PIN_GLOBAL_NS，这意味 着 tc 会将这个 map 作为一个节点（node）钉（pin）到 BPF 伪文件系统。默认情况下， 这个变量 acc_map 将被钉到 /sys/fs/bpf/tc/globals/acc_map。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果指定的是 PIN_GLOBAL_NS，那 map 会被放到 /sys/fs/bpf/tc/globals/。globals 是一个跨对象文件的全局命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果指定的是 PIN_OBJECT_NS，tc 将会为对象文件创建一个它的本地目录（local to the object file）。例如，只要指定了 PIN_OBJECT_NS，不同的 C 文件都可以像上 面一样定义各自的 acc_map。在这种情况下，这个 map 会在不同 BPF 程序之间共享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;PIN_NONE 表示 map 不会作为节点（node）钉（pin）到 BPF 文件系统，因此当 tc 退 出时这个 map 就无法从用户空间访问了。同时，这还意味着&lt;/span&gt;&lt;span&gt;独立的 tc 命令会创建出独 立的 map 实例&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，因此后执行的 tc 命令无法用这个 map 名字找到之前被钉住的 map。在路径 /sys/fs/bpf/tc/globals/acc_map 中，map 名是 acc_map。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，在加载 ingress 程序时，&lt;/span&gt;&lt;span&gt;tc 会先查找这个 map 在 BPF 文件系统中是否存在，不存在就创建一个&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。创建成功后，map 会被钉（pin）到 BPF 文件系统，因此当 egress 程 序通过 tc 加载之后，它就会发现这个 map 存在了，接下来会复用这个 map 而不是再创建 一个新的。在 map 存在的情况下，加载器还会确保 map 的属性（properties）是匹配的， 例如 key/value 大小等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;就像 tc 可以从同一 map 获取数据一样，第三方应用也可以用 bpf 系统调用中的 BPF_OBJ_GET 命令创建一个指向某个 map 实例的新文件描述符，然后用这个描述 符来查看/更新/删除 map 中的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通过 clang 编译和 iproute2 加载：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ clang -O2 -Wall -target bpf -c tc-example.c -o tc-example.o&lt;br/&gt;&lt;br/&gt;$ tc qdisc add dev em1 clsact&lt;br/&gt;$ tc filter add dev em1 ingress bpf da obj tc-example.o sec ingress&lt;br/&gt;$ tc filter add dev em1 egress bpf da obj tc-example.o sec egress&lt;br/&gt;&lt;br/&gt;$ tc filter show dev em1 ingress&lt;br/&gt;filter protocol all pref 49152 bpf&lt;br/&gt;filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action id 1 tag c5f7825e5dac396f&lt;br/&gt;&lt;br/&gt;$ tc filter show dev em1 egress&lt;br/&gt;filter protocol all pref 49152 bpf&lt;br/&gt;filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action id 2 tag b2fd5adc0f262714&lt;br/&gt;&lt;br/&gt;$ mount | grep bpf&lt;br/&gt;sysfs on /sys/fs/bpf &lt;span&gt;type&lt;/span&gt; sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)&lt;br/&gt;bpf on /sys/fs/bpf &lt;span&gt;type&lt;/span&gt; bpf (rw,relatime,mode=0700)&lt;br/&gt;&lt;br/&gt;$ tree /sys/fs/bpf/&lt;br/&gt;/sys/fs/bpf/&lt;br/&gt;+-- ip -&amp;gt; /sys/fs/bpf/tc/&lt;br/&gt;+-- tc&lt;br/&gt;|   +-- globals&lt;br/&gt;|       +-- acc_map&lt;br/&gt;+-- xdp -&amp;gt; /sys/fs/bpf/tc/&lt;br/&gt;&lt;br/&gt;4 directories, 1 file&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;以上步骤指向完成后，当包经过 em 设备时，BPF map 中的计数器就会递增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不允许全局变量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;出于第 1 条中提到的原因（只支持 BPF maps 重定位，译者注），BPF 不能使用全局变量 ，而常规 C 程序中是可以的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但是，我们有间接的方式实现全局变量的效果：BPF 程序可以使用一个 BPF_MAP_TYPE_PERCPU_ARRAY 类型的、只有一个槽（slot）的、可以存放任意类型数据（ arbitrary value size）的 BPF map。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这可以实现全局变量的效果原因是，&lt;/span&gt;&lt;span&gt;BPF 程序在执行期间不会被内核抢占&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，因此可以用单个 map entry 作为一个 scratch buffer 使用，存储临时数据，例如扩展 BPF 栈的限制（512 字节）。这种方式在尾调用中也是可 以工作的，因为尾调用执行期间也不会被抢占。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，如果要在不同次 BPF 程序执行之间保持状态，使用常规的 BPF map 就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不支持常量字符串或数组（const strings or arrays）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF C 程序中不允许定义 const 字符串或其他数组，原因和第 1 点及第 3 点一样，即 ，ELF 文件中生成的 重定位项（relocation entries）会被加载器拒绝，因为不符合加载器的 ABI（加载器也无法修复这些重定位项，因为这需要对已经编译好的 BPF 序列进行大范围的重写）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;将来 LLVM 可能会检测这种情况，提前将错误抛给用户。现在可以用下面的辅助函数来作为短期解决方式（work around）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef printk&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define printk(fmt, ...)                                      \&lt;/span&gt;&lt;br/&gt;    ({                                                         \&lt;br/&gt;        char ____fmt[] = fmt;                                  \&lt;br/&gt;        trace_printk(____fmt, sizeof(____fmt), &lt;span&gt;##__VA_ARGS__); \&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;有了上面的定义，程序就可以自然地使用这个宏，例如 printk(&quot;skb len:%u\n&quot;, skb-&amp;gt;len);。 输出会写到 trace pipe，用 tc exec bpf dbg 命令可以获取这些打印的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不过，使用 trace_printk() 辅助函数也有一些不足，&lt;/span&gt;&lt;span&gt;因此不建议在生产环境使用&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。每次调用这个辅助函数时，常量字符串（例如 &quot;skb len:%u\n&quot;）都需要加载到 BPF 栈，但这个辅助函数最多只能接受 5 个参数，因此使用这个函数输出信息时只能传递三个参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，虽然这个辅助函数对快速调试很有用，但（对于网络程序）还是推荐使用 skb_event_output() 或 xdp_event_output() 辅助函数。这两个函数接受从 BPF 程序传递自定义的结构体类型参数，然后将参数以及可选的包数据（packet sample）放到 perf event ring buffer。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，Cilium monitor 利用这些辅助函数实现了一个调试框架，以及在发现违反网络策略时发出通知等功能。这些函数通过一个无锁的、内存映射的、 per-CPU 的 perf ring buffer 传递数据，因此要远快于 trace_printk()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用 LLVM 内置的函数做内存操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因为 BPF 程序除了调用 BPF 辅助函数之外无法执行任何函数调用，因此常规的库代码必须 实现为内联函数。另外，LLVM 也提供了一些可以用于特定大小（这里是 n）的内置函数 ，这些函数永远都会被内联：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;#ifndef memset&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define memset(dest, chr, n)   __builtin_memset((dest), (chr), (n))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef memcpy&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define memcpy(dest, src, n)   __builtin_memcpy((dest), (src), (n))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef memmove&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define memmove(dest, src, n)  __builtin_memmove((dest), (src), (n))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;LLVM 后端中的某个问题会导致内置的 memcmp() 有某些边界场景下无法内联，因此在这个问题解决之前不推荐使用这个函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;（目前还）不支持循环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核中的 BPF 校验器除了对其他的控制流进行图验证（graph validation）之外，还会对所有程序路径执行深度优先搜索（depth first search），确保其中&lt;/span&gt;&lt;span&gt;不存在循环&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。这样做的目的是确保程序永远会结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但可以使用 #pragma unroll 指令实现常量的、不超过一定上限的循环。下面是一个例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#pragma unroll&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; IPV6_MAX_HEADERS; i++) {&lt;br/&gt;        switch (nh) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_NONE:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; DROP_INVALID_EXTHDR;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_FRAGMENT:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; DROP_FRAG_NOSUPPORT;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_HOP:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_ROUTING:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_AUTH:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_DEST:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (skb_load_bytes(skb, l3_off + len, &amp;amp;opthdr, sizeof(opthdr)) &amp;lt; 0)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; DROP_INVALID;&lt;br/&gt;&lt;br/&gt;            nh = opthdr.nexthdr;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nh == NEXTHDR_AUTH)&lt;br/&gt;                len += ipv6_authlen(&amp;amp;opthdr);&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                len += ipv6_optlen(&amp;amp;opthdr);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        default:&lt;br/&gt;            *nexthdr = nh;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; len;&lt;br/&gt;        }&lt;br/&gt;    }&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外一种实现循环的方式是：用一个 BPF_MAP_TYPE_PERCPU_ARRAY map 作为本地 scratch space（存储空间），然后用尾调用的方式调用函数自身。虽然这种方式更加动态，但目前最大只支持 32 层嵌套调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;将来 BPF 可能会提供一些更加原生、但有一定限制的循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尾调用的用途&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尾调用能够从一个程序调到另一个程序，提供了在运行时（runtime）原子地改变程序行为的灵活性。为了选择要跳转到哪个程序，尾调用使用了程序数组 map（ BPF_MAP_TYPE_PROG_ARRAY），将 map 及其索引（index）传递给将要跳转到的程序。跳转动作一旦完成，就没有办法返回到原来的程序；但如果给定的 map 索引中没有程序（无法跳转），执行会继续在原来的程序中执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，可以用尾调用实现解析器的不同阶段，可以在运行时（runtime）更新这些阶段的新解析特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尾调用的另一个用处是事件通知，例如，Cilium 可以在运行时（runtime）开启或关闭丢弃包的通知（packet drop notifications），其中对 skb_event_output() 的调用就是发 生在被尾调用的程序中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，在常规情况下，&lt;/span&gt;&lt;span&gt;执行的永远是从上到下的路径&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;（ fall-through path），当某个程序被加入到相关的 map 索引之后，程序就会解析元数据， 触发向用户空间守护进程（user space daemon）发送事件通知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;程序数组 map 非常灵活， map 中每个索引对应的程序可以实现各自的动作（actions）。例如，attach 到 tc 或 XDP 的 root 程序执行初始的、跳转到程序数组 map 中索引为 0 的程序，然后执行流量抽样（traffic sampling），然后跳转到索引为 1 的程序，在那个程序中应用防火墙策略，然后就可以决定是丢地包还是将其送到索引为 2 的程序中继续处理，在后者中，可能可能会被 mangle 然后再次通过某个接口发送出去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在程序数据 map 之中是可以随意跳转的。当达到尾调用的最大调用深度时，内核最终会执行 fall-through path。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一个使用尾调用的最小程序示例：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;[...]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __stringify&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __stringify(X)   #X&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section_tail&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section_tail(ID, KEY)          \&lt;/span&gt;&lt;br/&gt;   __section(__stringify(ID) &lt;span&gt;&quot;/&quot;&lt;/span&gt; __stringify(KEY))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef BPF_FUNC&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define BPF_FUNC(NAME, ...)              \&lt;/span&gt;&lt;br/&gt;   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_&lt;span&gt;##NAME&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#define BPF_JMP_MAP_ID   1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;static void BPF_FUNC(tail_call, struct __sk_buff *skb, void *map,&lt;br/&gt;                     uint32_t index);&lt;br/&gt;&lt;br/&gt;struct bpf_elf_map jmp_map __section(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;) = {&lt;br/&gt;    .&lt;span&gt;type&lt;/span&gt;           = BPF_MAP_TYPE_PROG_ARRAY,&lt;br/&gt;    .id             = BPF_JMP_MAP_ID,&lt;br/&gt;    .size_key       = sizeof(uint32_t),&lt;br/&gt;    .size_value     = sizeof(uint32_t),&lt;br/&gt;    .pinning        = PIN_GLOBAL_NS,&lt;br/&gt;    .max_elem       = 1,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;__section_tail(JMP_MAP_ID, 0)&lt;br/&gt;int looper(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    printk(&lt;span&gt;&quot;skb cb: %u\n&quot;&lt;/span&gt;, skb-&amp;gt;cb[0]++);&lt;br/&gt;    tail_call(skb, &amp;amp;jmp_map, 0);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int entry(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    skb-&amp;gt;cb[0] = 0;&lt;br/&gt;    tail_call(skb, &amp;amp;jmp_map, 0);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加载这个示例程序时，tc 会创建其中的程序数组（jmp_map 变量），并将其钉（pin）到 BPF 文件系统中全局命名空间下名为的 jump_map 位置。而且，iproute2 中的 BPF ELF 加载器也会识别出标记为 __section_tail() 的 section。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;jmp_map 的 id 字段会 跟__section_tail() 中的 id 字段（这里初始化为常量 JMP_MAP_ID）做匹配，因此程 序能加载到用户指定的索引（位置），在上面的例子中这个索引是 0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;然后，所有的尾调用 section 将会被 iproute2 加载器处理，关联到 map 中。这个机制并不是 tc 特有的， iproute2 支持的其他 BPF 程序类型（例如 XDP、lwt）也适用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;生成的 elf 包含 section headers，描述 map id 和 map 内的条目：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ llvm-objdump -S --no-show-raw-insn prog_array.o | less&lt;br/&gt;prog_array.o:   file format ELF64-BPF&lt;br/&gt;&lt;br/&gt;Disassembly of section 1/0:&lt;br/&gt;looper:&lt;br/&gt;       0:       r6 = r1&lt;br/&gt;       1:       r2 = *(u32 *)(r6 + 48)&lt;br/&gt;       2:       r1 = r2&lt;br/&gt;       3:       r1 += 1&lt;br/&gt;       4:       *(u32 *)(r6 + 48) = r1&lt;br/&gt;       5:       r1 = 0 ll&lt;br/&gt;       7:       call -1&lt;br/&gt;       8:       r1 = r6&lt;br/&gt;       9:       r2 = 0 ll&lt;br/&gt;      11:       r3 = 0&lt;br/&gt;      12:       call 12&lt;br/&gt;      13:       r0 = 0&lt;br/&gt;      14:       &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;Disassembly of section prog:&lt;br/&gt;entry:&lt;br/&gt;       0:       r2 = 0&lt;br/&gt;       1:       *(u32 *)(r1 + 48) = r2&lt;br/&gt;       2:       r2 = 0 ll&lt;br/&gt;       4:       r3 = 0&lt;br/&gt;       5:       call 12&lt;br/&gt;       6:       r0 = 0&lt;br/&gt;       7:       exi&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在这个例子中，section 1/0 表示 looper() 函数位于 map 1 中，在 map 1 内的 位置是 0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;被钉住（pinned）map 可以被用户空间应用（例如 Cilium daemon）读取，也可以被 tc 本 身读取，因为 tc 可能会用新的程序替换原来的程序，此时可能需要读取 map 内容。更新是原子的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;tc 执行尾调用 map 更新（tail call map updates）的例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ tc &lt;span&gt;exec&lt;/span&gt; bpf graft m:globals/jmp_map key 0 obj new.o sec foo&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果 iproute2 需要更新被钉住（pinned）的程序数组，可以使用 graft 命令。上面的 例子中指向的是 globals/jmp_map，那 tc 将会用一个新程序更新位于 index/key 为 0 的 map， 这个新程序位于对象文件 new.o 中的 foo section。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 最大栈空间 512 字节&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序的最大栈空间是 512 字节，在使用 C 语言实现 BPF 程序时需要考虑到这一点。但正如在第 3 点中提到的，可以通过一个只有一条记录（single entry）的 BPF_MAP_TYPE_PERCPU_ARRAY map 来绕过这限制，增大 scratch buffer 空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尝试使用 BPF 内联汇编&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;LLVM 6.0 以后支持 BPF 内联汇编，在某些场景下可能会用到。下面这个玩具示例程序（ 没有实际意义）展示了一个 64 位原子加操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于文档不足，要获取更多信息和例子，目前可能只能参考 LLVM 源码中的 lib/Target/BPF/BPFInstrInfo.td 以及 test/CodeGen/BPF/。测试代码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int xdp_test(struct xdp_md *ctx)&lt;br/&gt;{&lt;br/&gt;    __u64 a = 2, b = 3, *c = &amp;amp;a;&lt;br/&gt;    /* just a toy xadd example to show the syntax */&lt;br/&gt;    asm volatile(&lt;span&gt;&quot;lock *(u64 *)(%0+0) += %1&quot;&lt;/span&gt; : &lt;span&gt;&quot;=r&quot;&lt;/span&gt;(c) : &lt;span&gt;&quot;r&quot;&lt;/span&gt;(b), &lt;span&gt;&quot;0&quot;&lt;/span&gt;(c));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;上面的程序会被编译成下面的 BPF 指令序列：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;Verifier analysis:&lt;br/&gt;&lt;br/&gt;0: (b7) r1 = 2&lt;br/&gt;1: (7b) *(u64 *)(r10 -8) = r1&lt;br/&gt;2: (b7) r1 = 3&lt;br/&gt;3: (bf) r2 = r10&lt;br/&gt;4: (07) r2 += -8&lt;br/&gt;5: (db) lock *(u64 *)(r2 +0) += r1&lt;br/&gt;6: (79) r0 = *(u64 *)(r10 -8)&lt;br/&gt;7: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;processed 8 insns (&lt;span&gt;limit&lt;/span&gt; 131072), stack depth 8&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 #pragma pack 禁止结构体填充（struct padding）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;现代编译器默认会对数据结构进行内存对齐（align），以实现更加高效的访问。结构体成员会被对齐到数倍于其自身大小的内存位置，不足的部分会进行填充（padding），因此结构体最终的大小可能会比预想中大。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct called_info {&lt;br/&gt;    u64 start;  // 8-byte&lt;br/&gt;    u64 end;    // 8-byte&lt;br/&gt;    u32 sector; // 4-byte&lt;br/&gt;}; // size of 20-byte ?&lt;br/&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;size of %d-byte\n&quot;&lt;/span&gt;, sizeof(struct called_info)); // size of 24-byte&lt;br/&gt;&lt;br/&gt;// Actual compiled composition of struct called_info&lt;br/&gt;// 0x0(0)                   0x8(8)&lt;br/&gt;//  ↓________________________↓&lt;br/&gt;//  |        start (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |         end  (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |  sector(4) |  PADDING  | &amp;lt;= address aligned to 8&lt;br/&gt;//  |____________|___________|     with 4-byte PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核中的 BPF 校验器会检查栈边界（stack boundary），BPF 程序不会访问栈边界外的空间，或者是未初始化的栈空间。如果将结构体中填充出来的内存区域作为一个 map 值进行 访问，那调用 bpf_prog_load() 时就会报 invalid indirect read from stack 错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例代码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct called_info {&lt;br/&gt;    u64 start;&lt;br/&gt;    u64 end;&lt;br/&gt;    u32 sector;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;struct bpf_map_def SEC(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;) called_info_map = {&lt;br/&gt;    .&lt;span&gt;type&lt;/span&gt; = BPF_MAP_TYPE_HASH,&lt;br/&gt;    .key_size = sizeof(long),&lt;br/&gt;    .value_size = sizeof(struct called_info),&lt;br/&gt;    .max_entries = 4096,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;SEC(&lt;span&gt;&quot;kprobe/submit_bio&quot;&lt;/span&gt;)&lt;br/&gt;int submit_bio_entry(struct pt_regs *ctx)&lt;br/&gt;{&lt;br/&gt;    char fmt[] = &lt;span&gt;&quot;submit_bio(bio=0x%lx) called: %llu\n&quot;&lt;/span&gt;;&lt;br/&gt;    u64 start_time = bpf_ktime_get_ns();&lt;br/&gt;    long bio_ptr = PT_REGS_PARM1(ctx);&lt;br/&gt;    struct called_info called_info = {&lt;br/&gt;            .start = start_time,&lt;br/&gt;            .end = 0,&lt;br/&gt;            .bi_sector = 0&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    bpf_map_update_elem(&amp;amp;called_info_map, &amp;amp;bio_ptr, &amp;amp;called_info, BPF_ANY);&lt;br/&gt;    bpf_trace_printk(fmt, sizeof(fmt), bio_ptr, start_time);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// On bpf_load_program&lt;br/&gt;bpf_load_program() err=13&lt;br/&gt;0: (bf) r6 = r1&lt;br/&gt;...&lt;br/&gt;19: (b7) r1 = 0&lt;br/&gt;20: (7b) *(u64 *)(r10 -72) = r1&lt;br/&gt;21: (7b) *(u64 *)(r10 -80) = r7&lt;br/&gt;22: (63) *(u32 *)(r10 -64) = r1&lt;br/&gt;...&lt;br/&gt;30: (85) call bpf_map_update_elem&lt;span&gt;#2&lt;/span&gt;&lt;br/&gt;invalid indirect &lt;span&gt;read&lt;/span&gt; from stack off -80+20 size 24&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在 bpf_prog_load() 中会调用 BPF 校验器的 bpf_check() 函数，后者会调用 check_func_arg() -&amp;gt; check_stack_boundary() 来检查栈边界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;从上面的错误可以看出 ，struct called_info 被编译成 24 字节，错误信息提示从 +20 位置读取数据是“非法的间接读取”（invalid indirect read）。从我们更前面给出的内存布局图中可以看到， 地址 0x14(20) 是填充（PADDING）开始的地方。这里再次画出内存布局图以方便对比：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// Actual compiled composition of struct called_info&lt;br/&gt;// 0x10(16)    0x14(20)    0x18(24)&lt;br/&gt;//  ↓____________↓___________↓&lt;br/&gt;//  |  sector(4) |  PADDING  | &amp;lt;= address aligned to 8&lt;br/&gt;//  |____________|___________|     with 4-byte PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;check_stack_boundary() 会遍历每一个从开始指针出发的 access_size (24) 字节，确保它们位于栈边界内部，并且栈内的所有元素都初始化了。因此填充的部分是不允许使用的，所以报了 “invalid indirect read from stack” 错误。要避免这种错误，需要将结构体中的填充去掉。这是通过 #pragma pack(n) 原语实现的：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#pragma pack(4)&lt;/span&gt;&lt;br/&gt;struct called_info {&lt;br/&gt;    u64 start;  // 8-byte&lt;br/&gt;    u64 end;    // 8-byte&lt;br/&gt;    u32 sector; // 4-byte&lt;br/&gt;}; // size of 20-byte ?&lt;br/&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;size of %d-byte\n&quot;&lt;/span&gt;, sizeof(struct called_info)); // size of 20-byte&lt;br/&gt;&lt;br/&gt;// Actual compiled composition of packed struct called_info&lt;br/&gt;// 0x0(0)                   0x8(8)&lt;br/&gt;//  ↓________________________↓&lt;br/&gt;//  |        start (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |         end  (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |  sector(4) |             &amp;lt;= address aligned to 4&lt;br/&gt;//  |____________|                 with no PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在 struct called_info 前面加上 #pragma pack(4) 之后，编译器会以 4 字节为单位进行对齐。上面的图可以看到，这个结构体现在已经变成 20 字节大小，没有填充了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但是，&lt;/span&gt;&lt;span&gt;去掉填充也是有弊端的&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。例如，编译器产生的代码没有原来优化的好。去掉填充之后 ，处理器访问结构体时触发的是非对齐访问（unaligned access），可能会导致性能下降。并且，某些架构上的校验器可能会直接拒绝非对齐访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不过，我们也有一种方式可以避免产生自动填充：手动填充。我们简单地在结构体中加入一 个 u32 pad 成员来显式填充，这样既避免了自动填充的问题，又解决了非对齐访问的问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct called_info {&lt;br/&gt;    u64 start;  // 8-byte&lt;br/&gt;    u64 end;    // 8-byte&lt;br/&gt;    u32 sector; // 4-byte&lt;br/&gt;    u32 pad;    // 4-byte&lt;br/&gt;}; // size of 24-byte ?&lt;br/&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;size of %d-byte\n&quot;&lt;/span&gt;, sizeof(struct called_info)); // size of 24-byte&lt;br/&gt;&lt;br/&gt;// Actual compiled composition of struct called_info with explicit padding&lt;br/&gt;// 0x0(0)                   0x8(8)&lt;br/&gt;//  ↓________________________↓&lt;br/&gt;//  |        start (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |         end  (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |  sector(4) |  pad (4)  | &amp;lt;= address aligned to 8&lt;br/&gt;//  |____________|___________|     with explicit PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通过未验证的引用（invalidated references）访问包数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;某些网络相关的 BPF 辅助函数，例如 bpf_skb_store_bytes，可能会修改包的大小。校验器无法跟踪这类改动，因此它会将所有之前对包数据的引用都视为过期的（未验证的） 。因此，为避免程序被校验器拒绝，在访问数据之外需要先更新相应的引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;来看下面的例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct iphdr *ip4 = (struct iphdr *) skb-&amp;gt;data + ETH_HLEN;&lt;br/&gt;&lt;br/&gt;skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &amp;amp;new_saddr, 4, 0);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ip4-&amp;gt;protocol == IPPROTO_TCP) {&lt;br/&gt;    // &lt;span&gt;do&lt;/span&gt; something&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;校验器会拒绝这段代码，因为它认为在 skb_store_bytes 执行之后，引用 ip4-&amp;gt;protocol 是未验证的（invalidated）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;R1=pkt_end(id=0,off=0,imm=0) R2=pkt(id=0,off=34,r=34,imm=0) R3=inv0&lt;br/&gt;R6=ctx(id=0,off=0,imm=0) R7=inv(id=0,umax_value=4294967295,var_off=(0x0; 0xffffffff))&lt;br/&gt;R8=inv4294967162 R9=pkt(id=0,off=0,r=34,imm=0) R10=fp0,call_-1&lt;br/&gt;...&lt;br/&gt;18: (85) call bpf_skb_store_bytes&lt;span&gt;#9&lt;/span&gt;&lt;br/&gt;19: (7b) *(u64 *)(r10 -56) = r7&lt;br/&gt;R0=inv(id=0) R6=ctx(id=0,off=0,imm=0) R7=inv(id=0,umax_value=2,var_off=(0x0; 0x3))&lt;br/&gt;R8=inv4294967162 R9=inv(id=0) R10=fp0,call_-1 fp-48=mmmm???? fp-56=mmmmmmmm&lt;br/&gt;21: (61) r1 = *(u32 *)(r9 +23)&lt;br/&gt;R9 invalid mem access &lt;span&gt;&#x27;inv&#x27;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要解决这个问题，必须更新（重新计算） ip4 的地址：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct iphdr *ip4 = (struct iphdr *) skb-&amp;gt;data + ETH_HLEN;&lt;br/&gt;&lt;br/&gt;skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &amp;amp;new_saddr, 4, 0);&lt;br/&gt;&lt;br/&gt;ip4 = (struct iphdr *) skb-&amp;gt;data + ETH_HLEN;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ip4-&amp;gt;protocol == IPPROTO_TCP) {&lt;br/&gt;    // &lt;span&gt;do&lt;/span&gt; something&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;开发工具链&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;libbpf&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool &lt;/span&gt;&lt;span&gt;是查看和调试 BPF 程序的主要工具。它随内核一起开发，在内核中的路径是 tools/bpf/bpftool/。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个工具可以完成：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;dump 当前已经加载到系统中的所有 BPF 程序和 map&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;列出和指定程序相关的所有 BPF map&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;dump 整个 map 中的 key/value 对&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看、更新、删除特定 key&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看给定 key 的相邻 key（neighbor key）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要执行这些操作可以指定 BPF 程序、map ID，或者指定 BPF 文件系统中程序或 map 的位 置。另外，这个工具还提供了将 map 或程序钉（pin）到 BPF 文件系统的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看系统当前已经加载的 BPF 程序：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog&lt;br/&gt;398: sched_cls  tag 56207908be8ad877&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 8800B  jited 6184B  memlock 12288B  map_ids 18,5,17,14&lt;br/&gt;399: sched_cls  tag abc95fb4835a6ec9&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 344B  jited 223B  memlock 4096B  map_ids 18&lt;br/&gt;400: sched_cls  tag afd2e542b30ff3ec&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 1720B  jited 1001B  memlock 4096B  map_ids 17&lt;br/&gt;401: sched_cls  tag 2dbbd74ee5d51cc8&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 3728B  jited 2099B  memlock 4096B  map_ids 17&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类似地，查看所有的 active maps：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool map&lt;br/&gt;5: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 20B  value 112B  max_entries 65535  memlock 13111296B&lt;br/&gt;6: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 20B  value 20B  max_entries 65536  memlock 7344128B&lt;br/&gt;7: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 10B  value 16B  max_entries 8192  memlock 790528B&lt;br/&gt;8: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 22B  value 28B  max_entries 8192  memlock 987136B&lt;br/&gt;9: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 20B  value 8B  max_entries 512000  memlock 49352704B&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool 的每个命令都提供了以 json 格式打印的功能，在命令末尾指定 --json 就行了。另外，--pretty 会使得打印更加美观，看起来更清楚。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog --json --pretty&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要 dump 特定 BPF 程序的 post-verifier BPF 指令镜像（instruction image），可以先 从查看一个具体程序开始，例如，查看 attach 到 tc ingress hook 上的程序：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ tc filter show dev cilium_host egress&lt;br/&gt;filter protocol all pref 1 bpf chain 0&lt;br/&gt;filter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] \&lt;br/&gt;                    direct-action not_in_hw id 406 tag e0362f5bd9163a0a jited&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个程序是从对象文件 bpf_host.o 加载来的，程序位于对象文件的 from-netdev section，程序 ID 为 406。基于以上信息 bpftool 可以提供一些关于这个程序的上层元数据：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog show id 406&lt;br/&gt;406: sched_cls  tag e0362f5bd9163a0a&lt;br/&gt;     loaded_at Apr 09/16:24  uid 0&lt;br/&gt;     xlated 11144B  jited 7721B  memlock 12288B  map_ids 18,20,8,5,6,14&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;从上面的输出可以看到：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;程序 ID 为 406，类型是 sched_cls（BPF_PROG_TYPE_SCHED_CLS），有一个 tag 为 e0362f5bd9163a0a（指令序列的 SHA sum）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个程序被 root uid 0 在 Apr 09/16:24 加载&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 指令序列有 11,144 bytes 长，JIT 之后的镜像有 7,721 bytes&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;程序自身（不包括 maps）占用了 12,288 bytes，这部分空间使用的是 uid 0 用户 的配额&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序使用了 ID 为 18、20 8 5 6 和 14 的 BPF map。可以用这些 ID 进一步 dump map 自身或相关信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，bpftool 可以 dump 出运行中程序的 BPF 指令：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 406&lt;br/&gt; 0: (b7) r7 = 0&lt;br/&gt; 1: (63) *(u32 *)(r1 +60) = r7&lt;br/&gt; 2: (63) *(u32 *)(r1 +56) = r7&lt;br/&gt; 3: (63) *(u32 *)(r1 +52) = r7&lt;br/&gt;[...]&lt;br/&gt;47: (bf) r4 = r10&lt;br/&gt;48: (07) r4 += -40&lt;br/&gt;49: (79) r6 = *(u64 *)(r10 -104)&lt;br/&gt;50: (bf) r1 = r6&lt;br/&gt;51: (18) r2 = map[id:18]                    &amp;lt;-- BPF map id 18&lt;br/&gt;53: (b7) r5 = 32&lt;br/&gt;54: (85) call bpf_skb_event_output&lt;span&gt;#5656112  &amp;lt;-- BPF helper call&lt;/span&gt;&lt;br/&gt;55: (69) r1 = *(u16 *)(r6 +192)&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如上面的输出所示，bpftool 将指令流中的 BPF map ID、BPF 辅助函数或其他 BPF 程序都 做了关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;和内核的 BPF 校验器一样，bpftool dump 指令流时复用了同一个使输出更美观的打印程序 （pretty-printer）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于程序被 JIT，因此真正执行的是生成的 JIT 镜像（从上面 xlated 中的指令生成的 ），这些指令也可以通过 bpftool 查看：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump jited id 406&lt;br/&gt; 0:        push   %rbp&lt;br/&gt; 1:        mov    %rsp,%rbp&lt;br/&gt; 4:        sub    &lt;span&gt;$0x228&lt;/span&gt;,%rsp&lt;br/&gt; b:        sub    &lt;span&gt;$0x28&lt;/span&gt;,%rbp&lt;br/&gt; f:        mov    %rbx,0x0(%rbp)&lt;br/&gt;13:        mov    %r13,0x8(%rbp)&lt;br/&gt;17:        mov    %r14,0x10(%rbp)&lt;br/&gt;1b:        mov    %r15,0x18(%rbp)&lt;br/&gt;1f:        xor    %eax,%eax&lt;br/&gt;21:        mov    %rax,0x20(%rbp)&lt;br/&gt;25:        mov    0x80(%rdi),%r9d&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，还可以指定在输出中将反汇编之后的指令关联到 opcodes，这个功能主要对 BPF JIT 开发者比较有用：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump jited id 406 opcodes&lt;br/&gt; 0:        push   %rbp&lt;br/&gt;           55&lt;br/&gt; 1:        mov    %rsp,%rbp&lt;br/&gt;           48 89 e5&lt;br/&gt; 4:        sub    &lt;span&gt;$0x228&lt;/span&gt;,%rsp&lt;br/&gt;           48 81 ec 28 02 00 00&lt;br/&gt; b:        sub    &lt;span&gt;$0x28&lt;/span&gt;,%rbp&lt;br/&gt;           48 83 ed 28&lt;br/&gt; f:        mov    %rbx,0x0(%rbp)&lt;br/&gt;           48 89 5d 00&lt;br/&gt;13:        mov    %r13,0x8(%rbp)&lt;br/&gt;           4c 89 6d 08&lt;br/&gt;17:        mov    %r14,0x10(%rbp)&lt;br/&gt;           4c 89 75 10&lt;br/&gt;1b:        mov    %r15,0x18(%rbp)&lt;br/&gt;           4c 89 7d 18&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;同样，也可以将常规的 BPF 指令关联到 opcodes，有时在内核中进行调试时会比较有用：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 406 opcodes&lt;br/&gt; 0: (b7) r7 = 0&lt;br/&gt;    b7 07 00 00 00 00 00 00&lt;br/&gt; 1: (63) *(u32 *)(r1 +60) = r7&lt;br/&gt;    63 71 3c 00 00 00 00 00&lt;br/&gt; 2: (63) *(u32 *)(r1 +56) = r7&lt;br/&gt;    63 71 38 00 00 00 00 00&lt;br/&gt; 3: (63) *(u32 *)(r1 +52) = r7&lt;br/&gt;    63 71 34 00 00 00 00 00&lt;br/&gt; 4: (63) *(u32 *)(r1 +48) = r7&lt;br/&gt;    63 71 30 00 00 00 00 00&lt;br/&gt; 5: (63) *(u32 *)(r1 +64) = r7&lt;br/&gt;    63 71 40 00 00 00 00 00&lt;br/&gt; [...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;此外，还可以用 graphviz 以可视化的方式展示程序的基本组成部分。bpftool 提供了一 个 visual dump 模式，这种模式下输出的不是 BPF xlated 指令文本，而是一张点图（ dot graph），后者可以转换成 png 格式的图片：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 406 visual &amp;amp;&amp;gt; output.dot&lt;br/&gt;&lt;br/&gt;$ dot -Tpng output.dot -o output.png&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;也可以用 dotty 打开生成的点图文件：dotty output.dot，bpf_host.o 程序的效果如 下图所示（一部分）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9019607843137254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDp8dEicxVWG7Zzv3hKlzKexIOoPKHSuYm1CYVOR5Tt3nJ3Ge4c4FcQTJ0zSQzWQPyzp9rEVRsGbGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;408&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;注意，xlated 中 dump 出来的指令是经过校验器之后（post-verifier）的 BPF 指令镜 像，即和 BPF 解释器中执行的版本是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在内核中，校验器会对 BPF 加载器提供的原始指令执行各种重新（rewrite）。一个例子就 是对辅助函数进行内联化（inlining）以提高运行时性能，下面是对一个哈希表查找的优化：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 3&lt;br/&gt; 0: (b7) r1 = 2&lt;br/&gt; 1: (63) *(u32 *)(r10 -4) = r1&lt;br/&gt; 2: (bf) r2 = r10&lt;br/&gt; 3: (07) r2 += -4&lt;br/&gt; 4: (18) r1 = map[id:2]                      &amp;lt;-- BPF map id 2&lt;br/&gt; 6: (85) call __htab_map_lookup_elem&lt;span&gt;#77408   &amp;lt;-+ BPF helper inlined rewrite&lt;/span&gt;&lt;br/&gt; 7: (15) &lt;span&gt;if&lt;/span&gt; r0 == 0x0 goto pc+2                |&lt;br/&gt; 8: (07) r0 += 56                              |&lt;br/&gt; 9: (79) r0 = *(u64 *)(r0 +0)                &amp;lt;-+&lt;br/&gt;10: (15) &lt;span&gt;if&lt;/span&gt; r0 == 0x0 goto pc+24&lt;br/&gt;11: (bf) r2 = r10&lt;br/&gt;12: (07) r2 += -4&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool 通过 kallsyms 来对辅助函数或 BPF-to-BPF 调用进行关联。因此，确保 JIT 之 后的 BPF 程序暴露到了 kallsyms（bpf_jit_kallsyms），并且 kallsyms 地址是明确的 （否则调用显示的就是 call bpf_unspec#0）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;echo&lt;/span&gt; 0 &amp;gt; /proc/sys/kernel/kptr_restrict&lt;br/&gt;$ &lt;span&gt;echo&lt;/span&gt; 1 &amp;gt; /proc/sys/net/core/bpf_jit_kallsyms&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF-to-BPF 调用在解释器和 JIT 镜像中也做了关联。对于后者，子程序的 tag 会显示为 调用目标（call target）。在两种情况下，pc+2 都是调用目标的程序计数器偏置（ pc-relative offset），表示就是子程序的地址。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 1&lt;br/&gt;0: (85) call pc+2&lt;span&gt;#__bpf_prog_run_args32&lt;/span&gt;&lt;br/&gt;1: (b7) r0 = 1&lt;br/&gt;2: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;3: (b7) r0 = 2&lt;br/&gt;4: (95) &lt;span&gt;exit&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对应的 JIT 版本：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 1&lt;br/&gt;0: (85) call pc+2&lt;span&gt;#bpf_prog_3b185187f1855c4c_F&lt;/span&gt;&lt;br/&gt;1: (b7) r0 = 1&lt;br/&gt;2: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;3: (b7) r0 = 2&lt;br/&gt;4: (95) &lt;span&gt;exit&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在尾调用中，内核会将它们映射为同一个指令，但 bpftool 还是会将它们作为辅助函数进 行关联，以方便调试：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 2&lt;br/&gt;[...]&lt;br/&gt;10: (b7) r2 = 8&lt;br/&gt;11: (85) call bpf_trace_printk&lt;span&gt;#-41312&lt;/span&gt;&lt;br/&gt;12: (bf) r1 = r6&lt;br/&gt;13: (18) r2 = map[id:1]&lt;br/&gt;15: (b7) r3 = 0&lt;br/&gt;16: (85) call bpf_tail_call&lt;span&gt;#12&lt;/span&gt;&lt;br/&gt;17: (b7) r1 = 42&lt;br/&gt;18: (6b) *(u16 *)(r6 +46) = r1&lt;br/&gt;19: (b7) r0 = 0&lt;br/&gt;20: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;$ bpftool map show id 1&lt;br/&gt;1: prog_array  flags 0x0&lt;br/&gt;      key 4B  value 4B  max_entries 1  memlock 4096B&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;map dump 子命令可以 dump 整个 map，它会遍历所有的 map 元素，输出 key/value。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果 map 中没有可用的 BTF 数据，那 key/value 会以十六进制格式输出：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool map dump id 5&lt;br/&gt;key:&lt;br/&gt;f0 0d 00 00 00 00 00 00  0a 66 00 00 00 00 8a d6&lt;br/&gt;02 00 00 00&lt;br/&gt;value:&lt;br/&gt;00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;key:&lt;br/&gt;0a 66 1c ee 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;01 00 00 00&lt;br/&gt;value:&lt;br/&gt;00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;[...]&lt;br/&gt;Found 6 elements&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果有 BTF 数据，map 就有了关于 key/value 结构体的调试信息。例如，BTF 信息加上 BPF map 以及 iproute2 中的 BPF_ANNOTATE_KV_PAIR() 会产生下面的输出（内核 selftests 中的 test_xdp_noinline.o）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ cat tools/testing/selftests/bpf/test_xdp_noinline.c&lt;br/&gt;  []&lt;br/&gt;   struct ctl_value {&lt;br/&gt;         union {&lt;br/&gt;                 __u64 value;&lt;br/&gt;                 __u32 ifindex;&lt;br/&gt;                 __u8 mac[6];&lt;br/&gt;         };&lt;br/&gt;   };&lt;br/&gt;&lt;br/&gt;   struct bpf_map_def __attribute__ ((section(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;), used)) ctl_array = {&lt;br/&gt;          .&lt;span&gt;type&lt;/span&gt;  = BPF_MAP_TYPE_ARRAY,&lt;br/&gt;          .key_size = sizeof(__u32),&lt;br/&gt;          .value_size = sizeof(struct ctl_value),&lt;br/&gt;          .max_entries = 16,&lt;br/&gt;          .map_flags = 0,&lt;br/&gt;   };&lt;br/&gt;   BPF_ANNOTATE_KV_PAIR(ctl_array, __u32, struct ctl_value);&lt;br/&gt;&lt;br/&gt;   []&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF_ANNOTATE_KV_PAIR() 宏强制每个 map-specific ELF section 包含一个空的 key/value，这样 iproute2 BPF 加载器可以将 BTF 数据关联到这个 section，因此在加载 map 时可用从 BTF 中选择响应的类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用 LLVM 编译，并使用 pahole 基于调试信息产生 BTF：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ clang [...] -O2 -target bpf -g -emit-llvm -c test_xdp_noinline.c -o - |&lt;br/&gt;  llc -march=bpf -mcpu=probe -mattr=dwarfris -filetype=obj -o test_xdp_noinline.o&lt;br/&gt;&lt;br/&gt;$ pahole -J test_xdp_noinline.o&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加载到内核，然后使用 bpftool dump 这个 map：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ ip -force link &lt;span&gt;set&lt;/span&gt; dev lo xdp obj test_xdp_noinline.o sec xdp-test&lt;br/&gt;$ ip a&lt;br/&gt;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 xdpgeneric/id:227 qdisc noqueue state UNKNOWN group default qlen 1000&lt;br/&gt;    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&lt;br/&gt;    inet 127.0.0.1/8 scope host lo&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;    inet6 ::1/128 scope host&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;[...]&lt;br/&gt;&lt;br/&gt;$ bpftool prog show id 227&lt;br/&gt;227: xdp  tag a85e060c275c5616  gpl&lt;br/&gt;    loaded_at 2018-07-17T14:41:29+0000  uid 0&lt;br/&gt;    xlated 8152B  not jited  memlock 12288B  map_ids 381,385,386,382,384,383&lt;br/&gt;&lt;br/&gt;$ bpftool map dump id 386&lt;br/&gt; [{&lt;br/&gt;      &lt;span&gt;&quot;key&quot;&lt;/span&gt;: 0,&lt;br/&gt;      &lt;span&gt;&quot;value&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;ifindex&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;mac&quot;&lt;/span&gt;: []&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;  },{&lt;br/&gt;      &lt;span&gt;&quot;key&quot;&lt;/span&gt;: 1,&lt;br/&gt;      &lt;span&gt;&quot;value&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;ifindex&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;mac&quot;&lt;/span&gt;: []&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;  },{&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;针对 map 的某个 key，也可用通过 bpftool 查看、更新、删除和获取下一个 key（’get next key’）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF sysctls&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Linux 内核提供了一些 BPF 相关的 sysctl 配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/net/core/bpf_jit_enable：启用或禁用 BPF JIT 编译器。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Disable the JIT and use only interpreter (kernel&lt;span&gt;&#x27;s default value) |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Enable the JIT compiler                                           |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 2     | Enable the JIT and emit debugging traces to the kernel log        |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;后面会介绍到，当 JIT 编译设置为调试模式（option 2）时，bpf_jit_disasm 工 具能够处理调试跟踪信息（debugging traces）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/net/core/bpf_jit_harden：启用会禁用 BPF JIT 加固。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;注意，启用加固会降低性能，但能够降低 JIT spraying（喷射）攻击，因为它会禁止 （blind）BPF 程序使用立即值（immediate values）。对于通过解释器处理的程序， 禁用（blind）立即值是没有必要的（也是没有去做的）。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Disable JIT hardening (kernel&lt;span&gt;&#x27;s default value)                    |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Enable JIT hardening for unprivileged users only                  |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 2     | Enable JIT hardening for all users                                |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/net/core/bpf_jit_kallsyms：是否允许 JIT 后的程序作为内核符号暴露到 /proc/kallsyms。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;启用后，这些符号可以被 perf 这样的工具识别，使内核在做 stack unwinding 时 能感知到这些地址，例如，在 dump stack trace 的时候，符合名中会包含 BPF 程序 tag（bpf_prog_&amp;lt;tag&amp;gt;）。如果启用了 bpf_jit_harden，这个特性就会自动被禁用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Disable JIT kallsyms &lt;span&gt;export&lt;/span&gt; (kernel&lt;span&gt;&#x27;s default value)              |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Enable JIT kallsyms export for privileged users only              |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/kernel/unprivileged_bpf_disabled：是否允许非特权用户使用 bpf(2) 系统调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核默认允许非特权用户使用 bpf(2) 系统调用，但一旦将这个开关关闭，必须重启 内核才能再次将其打开。因此这是一个一次性开关（one-time switch），一旦关闭， 不管是应用还是管理员都无法再次修改。这个开关不影响 cBPF 程序（例如 seccomp） 或 传统的没有使用 bpf(2) 系统调用的 socket 过滤器 加载程序到内核。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Unprivileged use of bpf syscall enabled (kernel&lt;span&gt;&#x27;s default value)  |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Unprivileged use of bpf syscall disabled                          |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Linux 内核自带了一个 selftest 套件，在内核源码树中的路径是 tools/testing/selftests/bpf/。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;cd&lt;/span&gt; tools/testing/selftests/bpf/&lt;br/&gt;$ make&lt;br/&gt;$ make run_tests&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;测试用例包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 校验器、程序 tags、BPF map 接口和 map 类型的很多测试用例&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用于 LLVM 后端的运行时测试，用 C 代码实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用于解释器和 JIT 的测试，运行在内核，用 eBPF 和 cBPF 汇编实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;JIT Debugging&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于执行审计或编写扩展的 JIT 开发人员，每次编译运行都可以通过以下方式将生成的 JIT 镜像输出到内核日志中：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;echo&lt;/span&gt; 2 &amp;gt; /proc/sys/net/core/bpf_jit_enable&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;每当加载新的 BPF 程序时，JIT 编译器都会转储输出，然后可以使用 dmesg 检查，例如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;[ 3389.935842] flen=6 proglen=70 pass=3 image=ffffffffa0069c8f from=tcpdump pid=20583&lt;br/&gt;[ 3389.935847] JIT code: 00000000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 68&lt;br/&gt;[ 3389.935849] JIT code: 00000010: 44 2b 4f 6c 4c 8b 87 d8 00 00 00 be 0c 00 00 00&lt;br/&gt;[ 3389.935850] JIT code: 00000020: e8 1d 94 ff e0 3d 00 08 00 00 75 16 be 17 00 00&lt;br/&gt;[ 3389.935851] JIT code: 00000030: 00 e8 28 94 ff e0 83 f8 01 75 07 b8 ff ff 00 00&lt;br/&gt;[ 3389.935852] JIT code: 00000040: eb 02 31 c0 c9 c3&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;flen 是 BPF 程序的长度（这里是 6 个 BPF 指令），proglen 告诉 JIT 为操作码图像生成的字节数（这里是 70 字节大小）。pass 意味着图像是在 3 次编译器 pass 中生成的，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，x86_64 可以有各种优化 pass 以在可能的情况下进一步减小图像大小。image 包含生成的 JIT 镜像的地址，from 和 pid 分别是用户空间应用程序名称和 PID，它们触发了编译过程。eBPF 和 cBPF JIT 的转储输出格式相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在 tools/bpf/ 下的内核树中，有一个名为 bpf_jit_disasm 的工具。它读出最新的转储并打印反汇编以供进一步检查：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ ./bpf_jit_disasm&lt;br/&gt;70 bytes emitted from JIT compiler (pass:3, flen:6)&lt;br/&gt;ffffffffa0069c8f + &amp;lt;x&amp;gt;:&lt;br/&gt;   0:       push   %rbp&lt;br/&gt;   1:       mov    %rsp,%rbp&lt;br/&gt;   4:       sub    &lt;span&gt;$0x60&lt;/span&gt;,%rsp&lt;br/&gt;   8:       mov    %rbx,-0x8(%rbp)&lt;br/&gt;   c:       mov    0x68(%rdi),%r9d&lt;br/&gt;  10:       sub    0x6c(%rdi),%r9d&lt;br/&gt;  14:       mov    0xd8(%rdi),%r8&lt;br/&gt;  1b:       mov    &lt;span&gt;$0xc&lt;/span&gt;,%esi&lt;br/&gt;  20:       callq  0xffffffffe0ff9442&lt;br/&gt;  25:       cmp    &lt;span&gt;$0x800&lt;/span&gt;,%eax&lt;br/&gt;  2a:       jne    0x0000000000000042&lt;br/&gt;  2c:       mov    &lt;span&gt;$0x17&lt;/span&gt;,%esi&lt;br/&gt;  31:       callq  0xffffffffe0ff945e&lt;br/&gt;  36:       cmp    &lt;span&gt;$0x1&lt;/span&gt;,%eax&lt;br/&gt;  39:       jne    0x0000000000000042&lt;br/&gt;  3b:       mov    &lt;span&gt;$0xffff&lt;/span&gt;,%eax&lt;br/&gt;  40:       jmp    0x0000000000000044&lt;br/&gt;  42:       xor    %eax,%eax&lt;br/&gt;  44:       leaveq&lt;br/&gt;  45:       retq&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;或者，该工具还可以将相关操作码与反汇编一起转储。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ ./bpf_jit_disasm -o&lt;br/&gt;70 bytes emitted from JIT compiler (pass:3, flen:6)&lt;br/&gt;ffffffffa0069c8f + &amp;lt;x&amp;gt;:&lt;br/&gt;   0:       push   %rbp&lt;br/&gt;    55&lt;br/&gt;   1:       mov    %rsp,%rbp&lt;br/&gt;    48 89 e5&lt;br/&gt;   4:       sub    &lt;span&gt;$0x60&lt;/span&gt;,%rsp&lt;br/&gt;    48 83 ec 60&lt;br/&gt;   8:       mov    %rbx,-0x8(%rbp)&lt;br/&gt;    48 89 5d f8&lt;br/&gt;   c:       mov    0x68(%rdi),%r9d&lt;br/&gt;    44 8b 4f 68&lt;br/&gt;  10:       sub    0x6c(%rdi),%r9d&lt;br/&gt;    44 2b 4f 6c&lt;br/&gt;  14:       mov    0xd8(%rdi),%r8&lt;br/&gt;    4c 8b 87 d8 00 00 00&lt;br/&gt;  1b:       mov    &lt;span&gt;$0xc&lt;/span&gt;,%esi&lt;br/&gt;    be 0c 00 00 00&lt;br/&gt;  20:       callq  0xffffffffe0ff9442&lt;br/&gt;    e8 1d 94 ff e0&lt;br/&gt;  25:       cmp    &lt;span&gt;$0x800&lt;/span&gt;,%eax&lt;br/&gt;    3d 00 08 00 00&lt;br/&gt;  2a:       jne    0x0000000000000042&lt;br/&gt;    75 16&lt;br/&gt;  2c:       mov    &lt;span&gt;$0x17&lt;/span&gt;,%esi&lt;br/&gt;    be 17 00 00 00&lt;br/&gt;  31:       callq  0xffffffffe0ff945e&lt;br/&gt;    e8 28 94 ff e0&lt;br/&gt;  36:       cmp    &lt;span&gt;$0x1&lt;/span&gt;,%eax&lt;br/&gt;    83 f8 01&lt;br/&gt;  39:       jne    0x0000000000000042&lt;br/&gt;    75 07&lt;br/&gt;  3b:       mov    &lt;span&gt;$0xffff&lt;/span&gt;,%eax&lt;br/&gt;    b8 ff ff 00 00&lt;br/&gt;  40:       jmp    0x0000000000000044&lt;br/&gt;    eb 02&lt;br/&gt;  42:       xor    %eax,%eax&lt;br/&gt;    31 c0&lt;br/&gt;  44:       leaveq&lt;br/&gt;    c9&lt;br/&gt;  45:       retq&lt;br/&gt;    c3&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;最近，bpftool 采用了相同的功能，即根据系统中已加载的给定 BPF 程序 ID 转储 BPF JIT 镜像。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于 JITed BPF 程序的性能分析，perf 可以照常使用。作为先决条件，需要通过 kallsyms 基础设施导出 JIT 程序。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;echo&lt;/span&gt; 1 &amp;gt; /proc/sys/net/core/bpf_jit_enable&lt;br/&gt;$ &lt;span&gt;echo&lt;/span&gt; 1 &amp;gt; /proc/sys/net/core/bpf_jit_kallsyms&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;启用或禁用 bpf_jit_kallsyms 不需要重新加载相关的 BPF 程序。接下来，提供了一个小型工作流示例来分析 BPF 程序。一个精心制作的 tc BPF 程序用于演示目的，其中 perf 在 bpf_clone_redirect() 帮助程序中记录了失败的分配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于使用直接写入，bpf_try_make_head_writable() 失败，然后会再次释放克隆的 skb 并返回错误消息。因此 perf 记录了所有 kfree_skb 事件。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ tc qdisc add dev em1 clsact&lt;br/&gt;$ tc filter add dev em1 ingress bpf da obj prog.o sec main&lt;br/&gt;$ tc filter show dev em1 ingress&lt;br/&gt;filter protocol all pref 49152 bpf&lt;br/&gt;filter protocol all pref 49152 bpf handle 0x1 prog.o:[main] direct-action id 1 tag 8227addf251b7543&lt;br/&gt;&lt;br/&gt;$ cat /proc/kallsyms&lt;br/&gt;[...]&lt;br/&gt;ffffffffc00349e0 t fjes_hw_init_command_registers    [fjes]&lt;br/&gt;ffffffffc003e2e0 d __tracepoint_fjes_hw_stop_debug_err    [fjes]&lt;br/&gt;ffffffffc0036190 t fjes_hw_epbuf_tx_pkt_send    [fjes]&lt;br/&gt;ffffffffc004b000 t bpf_prog_8227addf251b7543&lt;br/&gt;&lt;br/&gt;$ perf record -a -g -e skb:kfree_skb sleep 60&lt;br/&gt;$ perf script --kallsyms=/proc/kallsyms&lt;br/&gt;[...]&lt;br/&gt;ksoftirqd/0     6 [000]  1004.578402:    skb:kfree_skb: skbaddr=0xffff9d4161f20a00 protocol=2048 location=0xffffffffc004b52c&lt;br/&gt;   7fffb8745961 bpf_clone_redirect (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffc004e52c bpf_prog_8227addf251b7543 (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffc05b6283 cls_bpf_classify (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb875957a tc_classify (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb8729840 __netif_receive_skb_core (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb8729e38 __netif_receive_skb (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb872ae05 process_backlog (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb872a43e net_rx_action (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb886176c __do_softirq (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb80ac5b9 run_ksoftirqd (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb80ca7fa smpboot_thread_fn (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb80c6831 kthread (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb885e09c ret_from_fork (/lib/modules/4.10.0+/build/vmlinux)&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;perf 记录的堆栈跟踪将显示 bpf_prog_8227addf251b7543() 符号作为调用跟踪的一部分，这意味着带有标签 8227addf251b7543 的 BPF 程序与 kfree_skb 事件相关，并且该程序在入口挂钩上附加到 netdevice em1 为 由 tc 显示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内省&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Linux 内核围绕 BPF 和 XDP 提供了多种 tracepoints，这些 tracepoints 可以用于进一 步查看系统内部行为，例如，跟踪用户空间程序和 bpf 系统调用的交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 相关的 tracepoints：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ perf list | grep bpf:&lt;br/&gt;bpf:bpf_map_create                                 [Tracepoint event]&lt;br/&gt;bpf:bpf_map_delete_elem                            [Tracepoint event]&lt;br/&gt;bpf:bpf_map_lookup_elem                            [Tracepoint event]&lt;br/&gt;bpf:bpf_map_next_key                               [Tracepoint event]&lt;br/&gt;bpf:bpf_map_update_elem                            [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_get_map                                [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_get_prog                               [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_pin_map                                [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_pin_prog                               [Tracepoint event]&lt;br/&gt;bpf:bpf_prog_get_type                              [Tracepoint event]&lt;br/&gt;bpf:bpf_prog_load                                  [Tracepoint event]&lt;br/&gt;bpf:bpf_prog_put_rcu                               [Tracepoint event]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用 perf 跟踪 BPF 系统调用（这里用 sleep 只是展示用法，实际场景中应该 执行 tc 等命令）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ perf record -a -e bpf:* sleep 10&lt;br/&gt;$ perf script&lt;br/&gt;sock_example  6197 [005]   283.980322: bpf:bpf_map_create: map &lt;span&gt;type&lt;/span&gt;=ARRAY ufd=4 key=4 val=8 max=256 flags=0&lt;br/&gt;sock_example  6197 [005]   283.980721: bpf:bpf_prog_load: prog=a5ea8fa30ea6849c &lt;span&gt;type&lt;/span&gt;=SOCKET_FILTER ufd=5&lt;br/&gt;sock_example  6197 [005]   283.988423: bpf:bpf_prog_get_type: prog=a5ea8fa30ea6849c &lt;span&gt;type&lt;/span&gt;=SOCKET_FILTER&lt;br/&gt;sock_example  6197 [005]   283.988443: bpf:bpf_map_lookup_elem: map &lt;span&gt;type&lt;/span&gt;=ARRAY ufd=4 key=[06 00 00 00] val=[00 00 00 00 00 00 00 00]&lt;br/&gt;[...]&lt;br/&gt;sock_example  6197 [005]   288.990868: bpf:bpf_map_lookup_elem: map &lt;span&gt;type&lt;/span&gt;=ARRAY ufd=4 key=[01 00 00 00] val=[14 00 00 00 00 00 00 00]&lt;br/&gt;     swapper     0 [005]   289.338243: bpf:bpf_prog_put_rcu: prog=a5ea8fa30ea6849c &lt;span&gt;type&lt;/span&gt;=SOCKET_FILTER&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于 BPF 程序，以上命令会打印出每个程序的 tag。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于调试，XDP 还有一个 xdp:xdp_exception tracepoint，在抛异常的时候触发：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ perf list | grep xdp:&lt;br/&gt;xdp:xdp_exception                                  [Tracepoint event]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;异常在下面情况下会触发：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序返回一个非法/未知的 XDP action code&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序返回 XDP_ABORTED，这表示非优雅的退出（non-graceful exit）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序返回 XDP_TX，但发送时发生错误，例如，由于端口没有启用、发送缓冲区已 满、分配内存失败等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这两类 tracepoint 也都可以通过 attach BPF 程序，用这个 BPF 程序本身来收集进一步 信息，将结果放到一个 BPF map 或以事件的方式发送到用户空间收集器，例如利用 bpf_perf_event_output() 辅助函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其他&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;和 perf 类似，BPF 程序和 map 占用的内存是算在 RLIMIT_MEMLOCK 中的。可以用 ulimit -l 查看当前锁定到内存中的页面大小。setrlimit() 系统调用的 man page 提 供了进一步的细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;默认的限制通常导致无法加载复杂的程序或很大的 BPF map，此时 BPF 系统调用会返回 EPERM 错误码。这种情况就需要将限制调大，或者用 ulimit -l unlimited 来临时解 决。RLIMIT_MEMLOCK 主要是针对非特权用户施加限制。根据实际场景不同，为特权 用户设置一个较高的阈值通常是可以接受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;END&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;想要了解更多相关的内容，欢迎扫描下方👇 关注 公众号，回复关键词 [实战群]  ,就有机会进群和我们进行交流~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5763688760806917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDrrBk1KBPqY1QNI320ZK2IIycDa77FcDQAeAFJRVb240xr8biceh23auy7ZpPibEYXPNOnmfsEewkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分享、在看与点赞，至少我要拥有一个叭~&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.2106667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEic0qXJ8QAeF6XRTLwTCEgUxxiamV13wPv9kMtaqrOtsrVibdHzvYiaxCwgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.696&quot; data-type=&quot;gif&quot; data-w=&quot;500&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEicOoCY9eHaUhZY0vkZibusOg9ibjGibicfyjHiaWfkN9QOiclK2DnfLh4KYTLA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c1f12bf25861d6cde07925cb91a89d97</guid>
<title>.Net 在容器中操作宿主机</title>
<link>https://toutiao.io/k/yx9jw00</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;方案描述&lt;/span&gt;&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 &lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt; 容器中想操作宿主机，一般会使用 &lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt; 的方式，然后 &lt;/span&gt;&lt;span&gt;.Net&lt;/span&gt;&lt;span&gt; 通过执行远程 &lt;span&gt;ssh&lt;/span&gt;&lt;span&gt; &lt;/span&gt;指令来操作宿主机。本文将使用 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5NDMwOTc5OA==&amp;amp;mid=2247483899&amp;amp;idx=1&amp;amp;sn=87a8023beded6a4800527913c898239c&amp;amp;chksm=ec659b32db121224393a436599746418c1396e7c1845ab0948fef49e155d4bcd0f2467a41471&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;交互式 .Net 容器版&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;交互式 .Net 容器版&lt;/a&gt; 中提供的镜像演示 &lt;span&gt;.&lt;/span&gt;&lt;span&gt;Net&lt;/span&gt; 在容器中如何操作宿主机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;前期准备&lt;/span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;宿主机上生成 ssh key&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;生成 &lt;/span&gt;&lt;span&gt;ssh key&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ssh-keygen -t rsa -b 4096&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3109919571045576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJ3NBKeVQ8OMFkQlqDIUaJVfDYUpCXSAGa90uJicNwe6WAbt2NUVSBslg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把 &lt;/span&gt;&lt;span&gt;public key&lt;/span&gt;&lt;span&gt; 加入到 &lt;/span&gt;&lt;span&gt;authorized_keys&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat /root/.ssh/id_rsa.pub &amp;gt; &lt;span class=&quot;code-snippet__regexp&quot;&gt;/root/&lt;/span&gt;.ssh/authorized_keys&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.041108132260947276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJSQuDrZ2272fAicUibjxWaPn2K34vfzXWO9qDussoOuF81IjvBzPWvpVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 启动容器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动容器，并把 &lt;/span&gt;&lt;span&gt;private key&lt;/span&gt;&lt;span&gt; 挂载到容器中：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;docker&lt;/span&gt; run --name dotnet-interactive -d -v /root/.ssh/id_rsa:/root/.ssh/id_rsa -p &lt;span class=&quot;code-snippet__number&quot;&gt;80&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;8888&lt;/span&gt; dotnet-interactive:&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker ps&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1224307417336908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJxZGeXv1lMO7xdQwZ2BbvvObYUw2AHERZDDcMBhtdAW6JCibHA5KIsTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安装 ssh client&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;打开网页并进入 &lt;/span&gt;&lt;span&gt;Terminal&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5388888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJFsyeGBsjtRcicw85G23fic4hp7YxmP98hdoy95pBxMx7p5Wx7wC8rPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安装 &lt;/span&gt;&lt;span&gt;ssh client&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;apt-get &lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; -y&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;apt-&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;install&lt;/span&gt; openssh-&lt;span class=&quot;code-snippet__keyword&quot;&gt;client&lt;/span&gt; -y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48055555555555557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJPF2kp4icDbQy6TqZoLU4wibibkibZ2ibMpficfd29wQaoia4OzayFvRyjzMww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;检查 &lt;/span&gt;&lt;span&gt;ssh client &lt;/span&gt;&lt;span&gt;安装情况：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ssh --&lt;span class=&quot;code-snippet__built_in&quot;&gt;help&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14128843338213762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJfYPALicVUrfMNRNzzfA9K76h3MLthibEGv3vrz2fibuicn18qicPjJFZ1rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;操作演示&lt;/span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;指令获取容器主机名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hostname&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1720351390922401&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJZejy1zhLKOwC6qxJZdwcewIjk3DSS8ABjSqc4760CuZolkboyaCl8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 指令&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;获取宿主机主机名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ssh -&lt;span class=&quot;code-snippet__keyword&quot;&gt;q&lt;/span&gt; -o StrictHostKeyChecking=&lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt; -o UserKnownHostsFile=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/dev/null&lt;/span&gt; -o PasswordAuthentication=&lt;span class=&quot;code-snippet__keyword&quot;&gt;no&lt;/span&gt; -i /root/.ssh/id_rsa &lt;span class=&quot;code-snippet__string&quot;&gt;{user}&lt;/span&gt;@{nodeIp} &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hostname&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1698389458272328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJeGpCKNyScrGuyxT66HjKNY2ibFL8IPMsR2lYhyRNDngH7MFI9sxIicxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;.Net 获取容器主机名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; System.Diagnostics;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ExecuteCommand&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; command&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; escapedArgs = command.Replace(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\\\&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; process = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Process&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        StartInfo = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ProcessStartInfo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            FileName = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/bin/bash&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Arguments = &lt;span class=&quot;code-snippet__string&quot;&gt;$&quot;-c \&quot;&lt;span class=&quot;code-snippet__subst&quot;&gt;{escapedArgs}&lt;/span&gt;\&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            RedirectStandardOutput = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            RedirectStandardError = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            UseShellExecute = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            CreateNoWindow = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    process.Start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    process.WaitForExit();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; message = process.StandardOutput.ReadToEnd();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    message += process.StandardOutput.ReadToEnd();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; message;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; hostname = ExecuteCommand(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hostname&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hostname&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48055555555555557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJDMGXibsGlO7YMeFHjlz4jT96IuG2POcGSskSbJckic2dSiaEsOoicRYBKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;.Net 获取宿主机主机名&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ExecuteCommandSSH&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; ip, &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; rootUser, &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt; command&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; script = &lt;span class=&quot;code-snippet__string&quot;&gt;$&quot;ssh -q -o \&quot;StrictHostKeyChecking no\&quot; -o \&quot;UserKnownHostsFile=/dev/null\&quot; -i /keys/&lt;span class=&quot;code-snippet__subst&quot;&gt;{ip}&lt;/span&gt;/sshkey/id_rsa \&quot;&lt;span class=&quot;code-snippet__subst&quot;&gt;{rootUser}&lt;/span&gt;@&lt;span class=&quot;code-snippet__subst&quot;&gt;{ip}&lt;/span&gt;\&quot; \&quot;&lt;span class=&quot;code-snippet__subst&quot;&gt;{command}&lt;/span&gt;\&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ExecuteCommand(script);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; hostname2 = ExecuteCommandSSH(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;10.0.0.2&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;root&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hostname&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;hostname2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48055555555555557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/blWxTUibJXH3tTaUlfEVOkCvDjIsSvKVJdKyV5m1iadIdV6Aa8k1ib62QEbhgV4pk2tEEby7oN2IJE3Qg3yn3Insw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;参考总结&lt;/span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是本文希望分享的内容，&lt;/span&gt;&lt;span&gt;如果大家有什么问题，欢迎在公众号 - 跬步之巅留言交流。&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d4ea1c8442a2603b530df86f3cac807</guid>
<title>解决微服务架构下流量有损问题的实践和探索</title>
<link>https://toutiao.io/k/f8xxqp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;ali_tech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>