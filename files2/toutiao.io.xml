<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6da516fae7465adace861f0d1f853646</guid>
<title>越是不确定性的时代，你越需要这份确定！</title>
<link>https://toutiao.io/k/uy0frh6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>adfc131b7ca050fd0791f4f6a39f4b78</guid>
<title>全栈工程师修炼手册</title>
<link>https://toutiao.io/k/9z9qrw5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4Njk2NDAzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ5p4x0RLv7ZmauGJfcichQt3zPj5VRgP8EPt6fC2siaonvQPEwQBCSGicvz84j80wse9l297PtLEd8Bg/0?wx_fmt=png&quot; data-nickname=&quot;开发者头条&quot; data-alias=&quot;kaifazhetoutiao&quot; data-signature=&quot;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;第一次接触编程是在小学三年级，至今有二十多年了，虽然现在的主要职责是管理公司的工程师与数据团队，但仍时不时会手痒写点程序。这么多年来，从游戏到网站到移动应用，从前端到后端到系统架构，自动化运维，大数据平台，所有这些领域我都有所接触。以前像我这样乱点技能树的，只能叫作万精油，但如今这就叫全栈工程师。&lt;/p&gt;&lt;p&gt;回想起来，我觉得自己还是挺幸运的，比起某某某领域专家，我更喜欢自己现在的状态。如果你也想尝试这条路，今天我可以给你一些建议。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;全栈适合你吗？&lt;/h2&gt;&lt;p&gt;在开始之前，这是你该问自己的第一个问题。因为全栈只是一种选择，你也可以选择朝垂直领域专家的方向努力。如果你已经有自己的答案，那就跟随你的意愿去做。如果你在犹豫，那么让我来问你几个问题&lt;/p&gt;&lt;p&gt;第一个问题，你现在在大公司还是创业公司？将来又想去哪儿呢？虽然没有绝对，但在创业公司，你可以迅速锻炼全栈的能力。而大公司有更多的机会深入研究某个领域的问题。特别是对于运维和大数据方面，大公司有得天独厚的优势，许多挑战与经验是创业公司无法提供的。&lt;/p&gt;&lt;p&gt;第二个问题，你将来是否想成为一个管理者？现在很多公司提供了 dual-stack，就是说管理线与技术线是并行的，要走哪条路你自己选。我的建议是，如果你希望将来转管理，在做技术的时候，广度比深度更重要，也就是说你更应该往全栈方向发展。管理者到一定层次都需要对项目负责，而任何一个典型的互联网项目，前后端开发、线上部署、数据分析，这些部分都缺一不可。拥有全栈的知识，你就可以对项目与团队有更好的把控力。&lt;/p&gt;&lt;p&gt;第三个问题，首席科学家与首席架构师，哪个更吸引你？如果你不走管理线，继续走技术线，那前面两个选择基本就是你发展的目标。如果你选架构师，那你就更适合往全栈发展。其实架构师也是一个管理者，只是他管的不是人，而是一个个技术模块。架构师的功力体现在如何选取最适合的模块，并让它们之间无缝连接。所以你的技术知识面越宽广，你可设计的版图就越大。&lt;/p&gt;&lt;p&gt;最后一个问题，你在学生时代是否偏科？开半个玩笑，我想说的是人要学会从自己的过去总结经验。偏科可能预示着你更适合钻研一项技术而不适合全面发展，或许有一天你就能成为某个领域的大牛，不也是好事一桩？&lt;/p&gt;&lt;p&gt;除去个人的偏好外，你也要关注时代的趋势。这是个开了变速齿轮的时代，短短几年间，技术的热点一直在变化，从移动开发，到大数据，VR，再到深度学习，区块链。身上不多背几项技能，可能没几天就被淘汰了。但到最后“能否快速掌握一项新技术”或许才是唯一不会被淘汰的技能。而在成为全栈工程师的道路上，你可以很好地锻炼这项终极技能。&lt;/p&gt;&lt;h2&gt;全栈工程师修炼手册&lt;/h2&gt;&lt;p&gt;全栈并不是毫无章法的遍地开花，好的学习计划与方法可以事半功倍，以下是我总结的几点经验&lt;/p&gt;&lt;h4&gt;一到多再到一&lt;/h4&gt;&lt;p&gt;从编程入门开始，先花一至两年时间熟练掌握一门主流的编程语言。这个阶段的目标就是一个扎实的基本功，包括程序中的基本概念，例如值与引用，变量的作用域，对象与类，常用数据结构与算法等等。一旦基础扎实了，接下去的三年左右时间就要从一到多，迅速扩冲你的技能池。要做到快速学习，第一项要领就是读技术资料时要学会跳读。因为很多的技术有相通之处，学习一项新技术，只需学习它与你已掌握的技术之间的 diff 就行了。当你有了一定的技术储备之后，一到两天内学会一门新的语言与框架其实并不难。这个阶段的另一个要领是 20/80 原则，也就是用 20% 的时间来了解一项技术中 80% 的基础内容，将剩下最难啃的 20% 留在将来需要深挖时再研究。&lt;/p&gt;&lt;p&gt;那为什么最后还要再回到一呢？当你有了足够的技术广度之后，你对技术的洞察力与理解力都会提升一个层次，这使你能更准确地发现适合自己且有前途的技术领域。与初入行时的随大流不同，你此时的选择是经过深思熟虑，为自己量身定制的。在接下去的时间里重点深挖一个或少数几个领域，这样在俱备了技术广度的同时，你也拥有了自己的杀手锏，个人价值会再次大幅提升。&lt;/p&gt;&lt;h4&gt;任务导向&lt;/h4&gt;&lt;p&gt;所谓任务导向就是一切学习都应该以输出为目的。仅凭兴趣学习，往往是低效的。比如你的公司要做一款移动应用，初期的流程是开发 -&amp;gt; 上线 -&amp;gt; 运营，对应的技术能力就是前后端开发，自动化运维，数据平台与用户分析。当用户数到达一定体量以后，就需要高可用架构，推荐算法等技术。你技术学习的脉络应该顺应业务的发展，这样才有机会学以致用。&lt;/p&gt;&lt;p&gt;那如果你身在大公司，又该怎么做呢？有些大公司提供轮岗的机会，比如我之前在 Google，公司每 18 个月提供一次换岗机会。可以借此扩展你的技能池，要好好利用。在选择下一个岗位时，应保持一种连续性，比如从前端开发转后端开发，从开发部门转运维或是数据部门等。&lt;/p&gt;&lt;p&gt;不过总体来说，全栈工程师与创业公司或是发展期公司才是最佳组合。&lt;/p&gt;&lt;h4&gt;移花接木&lt;/h4&gt;&lt;p&gt;学技术要了解其思想，而不要留于表面形式。优秀的技术思想会从它的发源地流向其他领域。例如，&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;前端的 MVC 结构在后端一样适用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当你理解了 Java 的 Annotation 以后，再看 Python 的 Decorator 就会觉得非常熟悉（尽管两者的实现方式完全不同）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当编译语言用类型推断（Type Inference）去除类型声明的同时，脚本语言却在用类型提示（Type Hint）添加类型声明。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不可变（Immutable）的思想始于函数式编程，但可以用于运维（Immutable Infrastructure)，也可以用于大数据管理（Functional Data Engineering)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运维的核心是对各类服务器数据的监控与报警，同样的理念也可以用于产品与运营数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;技术之间的联系，有些是显而易见的，有些需要你沉淀思考。真正的全栈工程师可以用一个技术领域的思想，去解决另一个技术领域的问题。再举一个我公司的例子，在学习用 Ansible 做运维时，发现它的 Playbook 不是用脚本语言而是用 YAML 来写的，这让我意识到原来 YAML 不仅可以用来描述数据，也可以用来描述逻辑关系。这个思想后来被用在我们很多的项目中，比如在设计数据产品的报表时，各种指标的计算，包括指标之间的依赖与派生关系都是直接在 YAML 中定义的，主体程序不涉及任何业务逻辑，仅仅是解析与执行这些 YAML 文件。&lt;/p&gt;&lt;p&gt;所以我建议在学习技术时，多做一些交叉领域的思考，这会使你在提升技术广度的同时，加强你的技术思维。&lt;/p&gt;&lt;h4&gt;层次切换&lt;/h4&gt;&lt;p&gt;记得以前刚进 Google 时，听的第一个内部讲座就是 Life of a Search Request，讲从用户输入一个搜索关键词到得到结果的整个过程，这个过程涉及浏览器，TCP/IP的网络传输，后台的 Web 服务集群，索引数据库群等等。对于你公司的业务，你是否能清楚地描述从用户输入到产生结果的整个周期？对于每一个环节，你又能深入细节到什么程度？&lt;/p&gt;&lt;p&gt;有次和公司的 CEO 聊天，他说他衡量一个产品经理的能力时，会看这个人能否从产品细节到长期战略之间的各个层次来回切换。我觉得衡量一个全栈工程师能力也是类似的，看他是否在了解系统的全貌的同时，又能深入到单个模块的细节。当系统遇到真正棘手的难题时，就非常考验技术人员在各层次之间切换的能力。就如同玩竞技类游戏，只有同时拥有良好大局观与精湛微操作的选手，才能成为顶尖高手。&lt;/p&gt;&lt;p&gt;在学习全栈的路上，不但要试着横向地切换层次（前台，后台，运维），也要尝纵向地切换层次，除了写业务代码之外，向下了解一些框架的底层运行机制，读一读它们的源码。向上学习一下系统设计与分布式架构。你可能会觉得什么都学会不会精力太分散？我觉得并不会，只要你顺着一条合理的脉络去学（任务导向），花三到五年的时间迅速延展你的技术广度是非常值得的。这会使你比同龄人更具竞争优势。目标要定得高，实践时量力而为。&lt;/p&gt;&lt;h2&gt;全栈修炼入门级套餐&lt;/h2&gt;&lt;p&gt;每个人的技术学习路线可能都不太一样，这也是为什么这篇文章着重讲的是方法而不是具体的学习内容。不过对于刚进入移动互职网开发的新人，我可以推荐一个全栈学习的新手包。编程语言方面，可以优先去学习以下语言&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;JavaScript&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SQL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Swift (如果不做 iOS 开发,可以不学)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Java 不但可以写 Android 应用，也是目前大部分国内公司的后端主力语言，在分布式系统与大数据平台方面的生态圈非常完整，所以即使你公司不用 Java 也应该学。&lt;/p&gt;&lt;p&gt;写前端，JavaScript 是必备技能，要掌握一个主流前端框架，建议学 React。这是一个非常出色的框架，生态圈成熟，适用性广，在有了 ReactNative 加持之后还可以做移动应用开发。另外，在熟悉了 JS 之后，也可以用 NodeJS 来写后端。&lt;/p&gt;&lt;p&gt;Python 也是个全能型语言，如果之后要做自动化运维，大数据分析与机器学习，Python 在这些方面优势明显。国外有很多公司用 Python 写后端，国内相对少些，但对创业公司而言，用 Python 做大后端的主力语言（业务后端 + 运维 + 数据分析）其实是个不错的选择。&lt;/p&gt;&lt;p&gt;学 SQL 前期是为了研发与上线时的数据库查询与管理，后期是为了数据分析与商业智能。即使目前各数 NoSQL 百花齐放，但传统的关系型数据库，如 MySQL 或是 PostgreSQL，势头依然强劲 。而在大数据端，各类的数据仓库与数据计算框架都会提供类 SQL 的接口。在较小的公司里，开发人员还经常兼做数据分析师。所以我认为熟练掌握 SQL 是对全栈工程师一项基本要求。&lt;/p&gt;&lt;p&gt;除了这些编程语言外，另一部分就是了解运维的基础知识，包括 Linux 命令行，Docker，以及各类常用的基础服务与数据库，如 Nginx，MySQL，Redis，MongoDB 等。&lt;/p&gt;&lt;p&gt;有了这些技术基础之后，你对于一个移动应用的系统全貌，就有了大致的了解。可以再根据公司实际的业务情况，选择进一步学习的内容。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;全栈的路很慢长，也很有趣，祝大家成功！今天的分享就到这里，欢迎留言。&lt;/p&gt;&lt;p&gt;（完）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入「码农周刊VIP会员」，成为更好的开发者！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7c8889c6b806bdd185e8322a56287bf</guid>
<title>博文推荐｜深入解析 BookKeeper 多副本协议（一）</title>
<link>https://toutiao.io/k/8vk008d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;本文翻译自《A Guide to the BookKeeper Replication Protocol (TLA+ Series Part 2)》，作者 Jack Vanlightly。原文链接：https://medium.com/splunk-maas/a-guide-to-the-bookkeeper-replication-protocol-tla-series-part-2-29f3371fe395。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;h1&gt;译者简介&lt;/h1&gt;&lt;p&gt;王嘉凌@中国移动云能力中心，移动云Pulsar产品负责人，Apache Pulsar Contributor，活跃于 Apache Pulsar 等开源项目和社区&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们知道关系型数据库中的数据是按表结构来存储，客户端可以将数据存储到表中以及从表中读取数据。Apache BookKeeper 中的数据是按日志结构来存储，客户端以日志的形式读写数据。日志结构是一种只支持数据追加操作的简单数据结构，支持多个客户端同时读取，以及非破坏性读取。&lt;/p&gt;&lt;p&gt;作为数据结构，日志和队列的功能非常相似，区别在于日志支持多个客户端同时独立地从不同位置读取完整的数据。因此，日志必须支持非破坏性读取。而队列则是破坏性读取， 队列的头部元素被读取后会被删除。这意味着队列中的每个元素只会被一个客户端读取到。&lt;/p&gt;&lt;p&gt;作为 Apache Pulsar 数据存储层的 Apache BookKeeper，本身也是一个复杂的分布式系统。BookKeeper 利用多副本机制来实现数据的安全和高可用。多副本指的是每一份 entry 数据都会被复制到多个节点保存，以便在发生部分节点故障时仍然可以提供读写服务，并且保证已保存的数据不会丢失。BookKeeper 使用一套独有的多副本协议，这个协议规定了多个服务节点之间如何协同来实现服务的高可用以及保证数据的安全。&lt;/p&gt;&lt;h1&gt;基于分片的日志数据结构&lt;/h1&gt;&lt;p&gt;诸如 Apache Kafka 和 RabbitMQ 这样使用基于队列和日志的消息队列，都是将每个队列或分区的数据视为一个整体来存储，这样一来整个数据必须全部存储在同一个存储节点。BookKeeper 使用了一套基于分片的日志数据结构，每个日志数据由一系列的分片数据（Segment）串联组成。Pulsar 的一个 Topic 分区 数据实际上是分为多个数据分片来保存。&lt;/p&gt;&lt;p&gt;我们知道每个 Pulsar Topic 都有一个唯一的 Pulsar broker 作为 owner，这个 broker 负责给所属的 Topic 创建数据分片，并将这些数据分片进行串联以便在逻辑上组成一个完整的日志数据。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;80&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPlQseAkmjic5zfNFy3lTtex1xMzaltbNkj8cV9DT5xArkkWmFamk9mEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1：Pulsar Topic 的数据由一组数据分片串联组成&lt;/span&gt;&lt;/p&gt;&lt;p&gt;BookKeeper 将这些数据分片称为 Ledger，并将它们保存在 BookKeeper server 节点（称为 bookie 节点）。&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;412&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7320837927232635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPDysaXNr1wmic17ZQbeOoibYlmF86zdpJ3KOmUttRrRaV7QTXl9QBh3CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2：Pulsar broker 将 topic 数据存储到多个 Bookie 节点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;BookKeeper 多副本协议和每个 ledger 的生命周期息息相关。多副本协议本身的实现封装在 BookKeeper 客户端类库中， 每个 Pulsar broker 通过调用BookKeeper 客户端类库中的接口来和 BookKeeper 进行交互，如创建 ledger，关闭 ledger，以及读写 entry。这些接口背后包含了非常复杂的协议逻辑，在本篇博客中我们会逐层分析并展示协议的实现细节。&lt;/p&gt;&lt;p&gt;首先，创建 ledger 的客户端即为这个 ledger 的唯一owner，只有 owner 可以往 ledger 里写数据。对于 Pulsar 来说，这个客户端就是作为分区 Topic owner 的 broker，Broker 负责创建 ledger 来组成这个 Topic 的数据段。当这个客户端由于某些原因发生故障时，另一个客户端（对于 Pulsar 来说就是另一个 broker）会介入并接管这个 Topic，这个时候需要修复之前的 ledger 中处于正在复制（under-replicated ）状态的 entry 数据（即 recovery 操作）并将 ledger 关闭。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;220&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWP0XCURyDexdFbeMX70zrZ0uiaAeM8CQeCoVBwNcuazwzicdSKOhOAEEyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3: Ledger 的生命周期&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个 Pulsar topic 仅包含一个 open 状态的 ledger 和多个 close 状态的 ledger。所有的写操作都会写入到 open 状态的 ledger，而读操作则可以从任何 ledger 中读取数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;108&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1925925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPricxEhy8kACQA3Ev4G8B9o0NialRDAGXsvwO3Bd5K4X1TbTicDyNZiaibjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4: 写操作只会写入到 open 状态的 ledger&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个 ledger 都会保存到多个 bookie 节点上，每个 ledger 和存有这个 ledger 的 bookie 池（称为 ensemble）的对应关系保存在 ZooKeeper。当 open 状态的 ledger 大小达到了阈值，或者这个 ledger 的 owner 发生了故障，就会关闭这个 ledger 并重新创建一个新的 ledger。根据配置的多副本参数，新创建的 ledger 可能会被保存到另一组 bookie 池上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;346&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6153846153846154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPCSZ4g5p2t85WwYBFTM4MjmNA8e8FibutqrwBTldGRbUhkdBU5Qjl0Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5：Ledger 数据的多个副本保存在多个 bookie 节点，每个 Ledger 的元数据以及一个 Topic 包含的 ledger 信息保存在 ZooKeeper&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;数据写入 ledger 的过程&lt;/h1&gt;&lt;p&gt;BookKeeper 包含以下 ledger 多副本配置相关的参数：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• Write quorum (每份 entry 数据需要写入多少个 bookie 节点), 简称 WQ。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Ack Quorum (需要从多少个 bookie 节点收到写入成功的响应后可以确认这份 entry 写入成功 ), 简称 AQ。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Ensemble size (用于存储 ledger 数据的 bookie 池的节点数量), 简称 E。当 E &amp;gt; WQ 时，entry 数据会交错地写入到不同的 bookie 节点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一条 entry 数据实际写入的 bookie 节点的集合成为写入集合。当 E &amp;gt; WQ 时，相邻的 entry 的写入集合可能会不一样。&lt;/p&gt;&lt;p&gt;Pulsar 为每个 Topic 暴露了设置 AQ、WQ、E 参数的 API 来自定义副本设置。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;596&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0612855007473843&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPs7UXQFJrDP5NLQgdLXKAmhbF5QCOzdLZsVzb80xicbFyevAOU3x16vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6：WQ=3，AQ=2 时的消息写入和确认&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;最后添加确认 (Last Add Confirmed, LAC)&lt;/h1&gt;&lt;p&gt;BookKeeper 客户端会持续更新已确认写入的 entry 中连续且最高的 entry ID，我们称之为 Last Add Confirmed (LAC)。这是一条水位线，高于这个 entry ID 的 entry 都还没有被确认写入，而低于和等于这个 entry ID 的 entry 都已经被确认写入。每一条发往 bookie 的 entry 数据中包含了当前最新的 LAC，这样每个 bookie 都可以知道当前 LAC 的值，尽管有一些延迟存在。我们还会在下文看到 LAC 除了作为已提交 entry 的水位线，还发挥着其他作用。&lt;/p&gt;&lt;h1&gt;Ledger 数据段&lt;/h1&gt;&lt;p&gt;Ledger 本身也可以分成一个或多个数据段（fragment）。当 Ledger 创建时，包含了一个数据段，分配了一个 bookie 池用于存储这个 Ledger 的数据。当发生某个 bookie 写入失败时，客户端会用一个新的 bookie 来替代。这个时候会创建一个新的数据段，并重新发送未确认的 entry 数据和之后的 entry 数据到新的 bookie 上。当 bookie 再次写入失败时，又会再次创建一个新的数据段，以此类推。Bookie 写入失败并不意味着这个 bookie 节点不可用，网络波动等其他情况也会造成单次的写入失败。不同数据段的数据存储在不同的 bookie 池上。数据段也通常被认为是写入集合（Ensemble）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;572&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0170261066969353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPc9bg9MyP91X3hicQAjibKibfuTUK3bjibGq3HYdbwkghKDeqNhYdcjoeicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7：第二个数据段的创建过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Ledger 数据段可以看作是告诉 BookKeeper 客户端去哪里找到某个 ledger 中的 entry 数据的元数据。Bookie 节点自身是不知道这些元数据信息的，它们只负责存储接收到的 entry 数据并创建基于 ledger ID 和 entry ID 的索引。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8425324675324676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPwkSc2zTo1MVXllhmB7YiaDRMkTHwYZyYfwmX7XR2nKLGUoAibA29r97g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8：往 B3 bookie 节点写入 entry 1000 失败并导致 ledger 创建第二个数据段 &lt;/span&gt;&lt;/p&gt;&lt;h1&gt;从 ledger 读取数据的过程&lt;/h1&gt;&lt;p&gt;从 ledger 中读取数据的操作分为以下几种情况：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 正常读取 entry 数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 长轮询读取 LAC 数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Quorum LAC 机制下的读取数据 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 恢复性读取数据&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;和写数据不一样的是，我们只需要读取一个存有数据的 bookie 节点就可以得到想要的数据。如果这次读取失败了，也只需要从存有这个数据其他副本的 bookie 节点上重新读取数据即可。&lt;/p&gt;&lt;p&gt;客户端通常只希望读取到已确认的数据，所以只会读取到 LAC 值标识的位置。在读取历史数据时，bookie 节点会依据当前的 LAC 值来通知客户端何时停止读取。当客户端读取到 LAC 值并停止读取时，可以发起长轮询读取 LAC 数据。这个请求会先被 bookie 挂起，直到有新的 entry 数据被确认时才响应并返回新的 entry 数据。&lt;/p&gt;&lt;p&gt;另外两种读取数据的情况主要发生在数据修复时，我们稍后再介绍。&lt;/p&gt;&lt;h1&gt;完成不同的操作需要不同的响应数量&lt;/h1&gt;&lt;p&gt;完成不同的操作需要从 bookie 节点接收到的成功响应的数量不一样。比如，对于正常读数据的操作，只需要从一个 bookie 节点成功收到响应即可完成。而有些操作则需要从多个 bookie 节点（quorum）收到成功的响应才可完成。&lt;/p&gt;&lt;p&gt;这些操作根据需要收到响应数量的不同，可以分为以下几种类型：&lt;/p&gt;&lt;p&gt;Quorum Coverage (QC) 和 Ensemble Coverage (EC) 都满足于以下定义（以下两种定义本质上相同，只是说法不同），QC 和 EC 的区别仅在于“集合”的范围 ：&lt;/p&gt;&lt;p&gt;对于 Quorum Coverage (QC) 来说，这个集合是指某个 entry 的写入集合。QC 主要用于保证单个 entry 数据一致性的场景，如校验单个 entry 写入操作是否已被客户端确认。对于Ensemble Coverage (EC) 来说，这个集合是指存储当前 ledger 数据段对应的 bookie 池，EC 主要用于保证 ledger 数据段一致性的场景，如设置 ledger 的 fence 状态。&lt;/p&gt;&lt;p&gt;WQ 和 AQ 主要用于写数据，而 QC 和 EC 主要用于 ledger 修复过程。&lt;/p&gt;&lt;h1&gt;Ledger 修复的过程&lt;/h1&gt;&lt;p&gt;前面我们讲到每个 ledger 只有一个客户端作为 owner，当这个客户端不可用时，另一个客户端就会介入并触发 ledger 修复过程然后关闭这个 ledger。对于 Pulsar 来说就相当于作为一个 Topic owner 的 broker 变得不可用，然后这个 Topic 的所有权转移到另一个 broker 上。 &lt;/p&gt;&lt;p&gt;Ledger 修复过程包括找到最高的已被 bookie 确认的 entry ID，保证在这之前的每个 entry 都已复制了足够多的副本数量。之后将这个 ledger 关闭，此时会将这个 ledger 的状态设置为 CLOSED，并将最新的 entry ID 设置为最后被确认的 entry ID。&lt;/p&gt;&lt;h2&gt;如何防止脑裂&lt;/h2&gt;&lt;p&gt;BookKeeper 是一个分布式系统，这意味着网络波动可能会导致集群被分隔成两个或者更多的区块。我们设想如果一个客户端和 ZooKeeper 断开连接，那么这个客户端就被认为已不可用，另一个客户端会接管这个客户端负责的 ledger 并开始 ledger 修复流程。但这个客户端可能仍在正常运行，它可以正常的连接到 BookKeeper 集群，于是就会出现两个客户端试图同时操作同一个 ledger，这种情况就属于脑裂。脑裂是指一个分布式系统由于网络波动分裂为多个独立的系统，在一定时间后网络恢复导致的数据不一致的情况。&lt;/p&gt;&lt;p&gt;BookKeeper 引入了 fence 这个概念来防止脑裂的发生。当第二个客户端 （例如另一个 Pulsar broker）试图开始 ledger 修复流程时，会先将 ledger 设置为 fence 状态，在这个状态下 ledger 会拒接所有新的写入请求。当足够多的 bookie 节点将这个 ledger 状态设置为 fence 时，就算第一个客户端仍然处于正常运行状态，它也不能再进行任何新的写入操作。然后第二个客户端就可以在没有其他客户端会继续写入数据或者试图修复同一个 ledger 的安全状态下开始 ledger 修复流程。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;455&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8106382978723404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPzjg5MZ5QM46UdU9wPEZTj680ecHg98zXia3E749u4D6yR0PiacGYWFsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9：一个新的 Topic owner 开始将 ledger 设置为 fence，原先的 owner 写入新数据时无法写入 Ack Quorum 设定的副本数，则无法完成写入&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;修复流程第一步 — 设置 fence 状态&lt;/h2&gt;&lt;p&gt;将 ledger 设为 fence 状态，并确认 LAC 的值。&lt;/p&gt;&lt;p&gt;Fence 请求实际上是一次 Ensemble Coverage 类型的读请求，获取 LAC 的值并带有 fencing 标识。每个 bookie 节点收到这个请求时会将这个 ledger 的状态设为 fence，并返回这个节点上对应 ledger 的 LAC 值。当客户端从足够多的 bookie 节点收到响应时，就表示请求成功可以进行下一步操作。那么从多少个 bookie 节点收到响应才算足够呢？&lt;/p&gt;&lt;p&gt;我们将 ledger 设置为 fence 状态是为了防止之前的客户端继续往 ledger 里写入数据。所以我们只要保证还没有将这个 ledger 设置为 fence 状态的 bookie 节点的数量小于设置的 Ack Quorum 值，那么之前的客户端因为无法收到足够多的写入确认而无法写入新数据。新的客户端发起的 fence 操作不需要等到所有的 bookie 节点都将这个 ledger 设置为 fence，只需要满足还没有设置为 fence 状态的 bookie 节点数小于设置的 Ack Quorum 就可确认 fence 操作完成。满足这个条件所需要收到的响应数量就是 Ensemble Coverage。&lt;/p&gt;&lt;h2&gt;修复流程第二步 — 修复 entry 数据&lt;/h2&gt;&lt;p&gt;接下来，客户端从 LAC + 1 的 entry ID 开始发送恢复性读取数据的请求，并将这些 entry 数据重新写到新的 bookie 池中。写操作属于幂等操作，也就是说如果这个 entry 已经写入到了某个 bookie 节点，再次向这个节点写入同样的 entry 不会造成数据重复写入。客户端会持续进行读和写的操作直到读完所有数据。确保在关闭 ledger 之前，这个 entry 的写入集合中的所有 bookie 节点都写入了该 entry 的副本。&lt;/p&gt;&lt;p&gt;正常的读操作只需要从一个 bookie 节点接收到响应。与之不同的是，Recovery读操作需要根据从这个 entry 的所有写入集合的 bookie 节点上收到的响应内容来明确这个 entry 是否已确认。具体来说有以下两种情况：&lt;/p&gt;&lt;p&gt;如果所有响应都已收到，但两个阈值都未达到，那就无法判断这个 entry 是否已确认，修复流程就会终止（可能存在收到其他错误类型响应的情况，如网络波动，这种情况无法判断 entry 是否已成功写入对应 bookie 节点）。修复流程可以重复执行直到可以明确每个 entry 最终的确认状态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;600&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0669781931464175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPz7zAaYiaVicAwe4sHtQWdW6OxYeHsV6oglAspjue9o7SuYwCIW19M9gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10：新的客户端在读取 entry 3 时收到了足够多的数据不存在请求，可以判断 entry 3 的状态为未确认。然后保证到 entry 2 为止的数据都复制到足够多的副本数&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;修复流程第三步 — 关闭 Ledger&lt;/h2&gt;&lt;p&gt;一旦明确了所有已确认的 entry ，且这些 entry 复制了足够多的副本数，客户端就会关闭 ledger。关闭 ledger 的操作主要是对 ZooKeeper 上 ledger 元数据的更新，将状态设置为 CLOSED，并将 Last Entry Id 设置为最新的已确认的 entry ID。这些操作和 bookie 本身不相关，bookie 也不会感知 ledger 是否被关闭，bookie 自身没有 open 或 closed 的概念。&lt;/p&gt;&lt;p&gt;ZooKeeper 上元数据的更新是一个基于版本控制的 CAS 操作。如果有另一个客户端同时在修复这个 ledger 并且已经将 ledger 关闭，那么这次 CAS 操作就会失败。通过这种方式可以防止多个客户端同时对同一个 ledger 进行修复操作。 &lt;/p&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;本篇博客介绍了 BookKeeper 多副本协议的大部分实现内容。需要记住的重点是，bookie 节点只是单纯用来存储和读取 entry 数据的存储节点，在 BookKeeper 客户端中包含了创建 ledger、选择存储 ledger 的 bookie 池、创建 ledger 数据段的操作，通过 Write Quorum 和 Ack Quorum 来保证多副本的机制，以及在发生故障时对 ledger 进行修复和关闭等一系列逻辑。&lt;/p&gt;&lt;h1&gt;相关阅读&lt;/h1&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247489945&amp;amp;idx=1&amp;amp;sn=a9dcb508a14eaa96052e783ef79f0e75&amp;amp;chksm=f9c503aeceb28ab8463c1149dd5a6a3c88b6d631d82621813f009bdc676619fb17511faf065d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;博文推荐｜深入解析Apache BookKeeper 系列：第一篇 — 架构原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;•&lt;/span&gt; &lt;span&gt;博文推荐｜深入解析Apache BookKeeper 系列：第一篇 — 架构原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;• &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247488980&amp;amp;idx=2&amp;amp;sn=7ab01fd746384dbcd934ae0d3c3f3e7b&amp;amp;chksm=f9c50fe3ceb286f57035082aeac2d407aded4f013c9e10a029fcadce179a49dd4aca984813c0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;博文干货｜5张图带你快速入门 Pulsar 的存储引擎 BookKeeper&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;博文干货｜5 张图带你快速入门 Pulsar 的存储引擎 BookKeeper&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;📣 Pulsar Storage 特别兴趣小组（SIG）已成立！&lt;span&gt;扫描下方&lt;/span&gt;&lt;span&gt;🤖️ &lt;/span&gt;&lt;span&gt;Pulsar Bot 二维码，&lt;/span&gt;回复 &lt;span&gt;BookKeeper&lt;/span&gt; 加入 Pulsar Storage 讨论群。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4ibRRsibIGr0ZSe03QyMcdYDoPThku7hjSJibg8nI1vtB8bde5jr1XSdz5iaPJDp7y1aOHupWAIQT1Qr3c1iafE5HXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫/码/加/入&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▼ 关注「Apache Pulsar」，获取更多技术干货 ▼&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMjkzMjA1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0Y7icPiahxgXFRw8a0xAIxOhPqYtRDr0IRNpGRl2oSfGHuvkG9VtahW9thH3btBGXJu9y2dZgb3oOuQ/0?wx_fmt=png&quot; data-nickname=&quot;ApachePulsar&quot; data-alias=&quot;ApachePulsar&quot; data-signature=&quot;Apache 软件基金会顶级项目，下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1486aa973a0dba8e7c8770a5c7449946</guid>
<title>点击页面元素，这个Vite插件竟然帮我打开了Vue组件文件！超级好用！</title>
<link>https://toutiao.io/k/pmc5cbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650757158&amp;amp;idx=1&amp;amp;sn=1f1cad678916031fb0e77eefcfa1dddc&amp;amp;chksm=88665baabf11d2bc7dce837e90cbe0b755d4e082362363e1ebc8912a77367b79ba59ea43a32e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;若‍川&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;若川&lt;/a&gt;。&lt;span&gt;持续组织了8个月&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650761094&amp;amp;idx=2&amp;amp;sn=0d0e9de8fc6554b3074913697511c9a2&amp;amp;chksm=8866640abf11ed1c0bdf43f4758c3bb9a74c90c48ed76eed46dca1af6e9b63b992def9b3655c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;源码共读‍活动&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;strong&gt;源码共读活动&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，感兴趣的可以&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650761094&amp;amp;idx=2&amp;amp;sn=0d0e9de8fc6554b3074913697511c9a2&amp;amp;chksm=8866640abf11ed1c0bdf43f4758c3bb9a74c90c48ed76eed46dca1af6e9b63b992def9b3655c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点此加我微信 ruochuan‍12&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;点此加我微信 ruochuan12&lt;/a&gt;&lt;span&gt; 参与，每周大家一起学习200行左右的源码，共同进步。同时极力推荐订阅我写的&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1342211915371675650&amp;amp;scene=173&amp;amp;from_msgid=2650759428&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;《学习源码整体架构系列》&lt;/a&gt;&lt;span&gt; 包含20余篇源码文章。&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1932984266565484545#wechat_redirect&quot; textvalue=&quot;历史面试系列&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;历史面试系列&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两天肝了个Vite插件,本文主要跟大家分享一下它的功能和实现思路.如果你觉得它对你有帮助,请给一个star支持作者 💗.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vite-plugin-vue-inspector的功能是点击页面元素,自动打开本地IDE并跳转到对应的Vue组件.类似于&lt;code&gt;Vue DevTools&lt;/code&gt;的 &lt;code&gt;Open component in editor&lt;/code&gt;功能。（若川批注：关于原理可以看我写过的文章：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650751278&amp;amp;idx=1&amp;amp;sn=3ac07b110e84e3ded5fa4ec4407ce13b&amp;amp;chksm=886642a2bf11cbb4cea35f0d208815c39c9cd13a0522e7cdc4a466bc55cb5b3071143a38bb04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘&lt;/a&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5053680981595092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/Mpt86EGjlpvVXr0Fgyg2FKxvMMoxmgn3VgbOYAibY0OaiadYkwfBO38nQoLOuJpOicv05DE5Zx4vz2Auu2sWjTSMQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1304&quot;/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vite-plugin-vue-inspector支持Vue2 &amp;amp; Vue3,并且只需要进行简单的配置就可以使用.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vue2&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { defineConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { createVuePlugin } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue2&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Inspector &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineConfig({&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;    createVuePlugin(),&lt;br/&gt;    Inspector({&lt;br/&gt;      &lt;span&gt;vue&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    }),&lt;br/&gt;  ],&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vue3&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { defineConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@vitejs/plugin-vue&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Inspector &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineConfig({&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [Vue(), Inspector()],&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IDE也要进行配置,这里就不啰嗦了, 👉 传送门.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现思路&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里,如果你觉得这个插件索然无味的话先别跑,插件没意思,看看怎么写插件还是有点意思的嘛 ! 接下来跟大家介绍一下这个插件的实现思路.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来分析一下实现这个功能我们需要有哪些元素 :&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Open IDE&lt;/code&gt;: 打开编辑器功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Web&lt;/code&gt;层: 提供该功能所需的页面元素及交互功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Server&lt;/code&gt;层: 用户交互时传递数据到&lt;code&gt;Server&lt;/code&gt;层,由&lt;code&gt;Server&lt;/code&gt;层调用&lt;code&gt;Open IDE&lt;/code&gt;功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DOM&lt;/code&gt;=&amp;gt;&lt;code&gt;Vue SFC&lt;/code&gt;映射关系: 告诉&lt;code&gt;OPen IDE&lt;/code&gt;打开哪个文件并定位到对应的行列.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明确我们需要什么元素,我们就可以进一步来梳理它的实现方式,直接晒图:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5165343915343915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/C527icpHV4scIEXR8hD9fQ2401ac7wqYtVUfeYYjoNW50HDUBy9vCUVmyxUzkajVXjQlNGqqSjc2kIQsTs5UVQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot;/&gt;&lt;figcaption&gt;vite-plugin-step.drawio (2).png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现细节&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来,我们来看具体的实现细节.在这之前,我们先简单看下我们需要用到的几个Vite插件API:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 应用顺序&lt;/span&gt;&lt;br/&gt;    enforce: &lt;span&gt;&quot;pre&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 应用模式 (只在开发模式应用)&lt;/span&gt;&lt;br/&gt;    apply: &lt;span&gt;&quot;serve&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 含义: 转换钩子,接收每个传入请求模块的内容和文件路径&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子对SFC模版进行解析并注入自定义属性&lt;/span&gt;&lt;br/&gt;    transform(code, id) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 含义: 配置开发服务器钩子,可以添加自定义中间件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子实现Open Editor调用服务&lt;/span&gt;&lt;br/&gt;    configureServer(server) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 含义: 转换index.html的专用钩子,接收当前HTML字符串和转换上下文&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子注入交互功能&lt;/span&gt;&lt;br/&gt;    transformIndexHtml(html) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解析SFC模版 &amp;amp; 注入自定义属性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分的实现主要分为两步:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SFC Template&lt;/code&gt; =&amp;gt; &lt;code&gt;AST&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取元素所在组件的行和列的编号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取自定义属性插入的位置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;注入自定义属性&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;file (SFC路径,用于跳转到指定文件)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;line (元素所在行编号,用于跳转到指定行)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;column (元素所在列编号,用于跳转到指定列)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;title (SFC名称,用于展示)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    transform(code, id) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { filename, query } = parseVueRequest(id)&lt;br/&gt;      &lt;span&gt;// 只处理SFC文件&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (filename.endsWith(&lt;span&gt;&quot;.vue&quot;&lt;/span&gt;) &amp;amp;&amp;amp; query.type !== &lt;span&gt;&quot;style&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; compileSFCTemplate(code, filename)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; code&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// compiler.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; path &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;path&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; MagicString &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;magic-string&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { parse, transform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@vue/compiler-dom&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; EXCLUDE_TAG = [&lt;span&gt;&quot;template&quot;&lt;/span&gt;, &lt;span&gt;&quot;script&quot;&lt;/span&gt;, &lt;span&gt;&quot;style&quot;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;compileSFCTemplate&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  code: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  id: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// MagicString是一个非常好用的字符串操作库,也如它的名字一样,非常的神奇 !&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 有了它,我们可以直接操作字符串,避免操作AST,换来更好的性能. Vue3的实现也大量的用到了它.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt; MagicString(code)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// SFC =&amp;gt; AST&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ast = parse(code, { comments: &lt;span&gt;true&lt;/span&gt; })&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    transform(ast, {&lt;br/&gt;      &lt;span&gt;// ast node节点访问器&lt;/span&gt;&lt;br/&gt;      nodeTransforms: [&lt;br/&gt;        &lt;span&gt;(&lt;span&gt;node&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (node.type === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;           &lt;span&gt;// 只解析html标签 &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (node.tagType === &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !EXCLUDE_TAG.includes(node.tag)) {&lt;br/&gt;              &lt;span&gt;const&lt;/span&gt; { base } = path.parse(id)&lt;br/&gt;              &lt;span&gt;// 获取到相关信息,并进行自定义属性注入&lt;/span&gt;&lt;br/&gt;              !node.loc.source.includes(&lt;span&gt;&quot;data-v-inspecotr-file&quot;&lt;/span&gt;)&lt;br/&gt;                &amp;amp;&amp;amp; s.prependLeft(&lt;br/&gt;                  node.loc.start.offset + node.tag.length + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;` data-v-inspecotr-file=&quot;&lt;span&gt;${id}&lt;/span&gt;&quot; data-v-inspecotr-line=&lt;span&gt;${node.loc.start.line}&lt;/span&gt; data-v-inspecotr-column=&lt;span&gt;${node.loc.start.column}&lt;/span&gt; data-v-inspecotr-title=&quot;&lt;span&gt;${base}&lt;/span&gt;&quot;`&lt;/span&gt;,&lt;br/&gt;                )&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;      ],&lt;br/&gt;    })&lt;br/&gt;    resolve(s.toString())&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注入后的&lt;code&gt;DOM元素&lt;/code&gt;长这样 :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;h3&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-file&lt;/span&gt;=&lt;span&gt;&quot;/xxx/src/Hi.vue&quot;&lt;/span&gt;   &lt;br/&gt;    &lt;span&gt;data-v-inspector-line&lt;/span&gt;=&lt;span&gt;&quot;3&quot;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-column&lt;/span&gt;=&lt;span&gt;&quot;5&quot;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-title&lt;/span&gt;=&lt;span&gt;&quot;Hi.vue&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Open Editor Server服务&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到了创建Server服务的思路是在vite的&lt;code&gt;configureServer&lt;/code&gt;的钩子函数注入中间件:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    configureServer(server) {&lt;br/&gt;      &lt;span&gt;// 注册中间件&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;// 请求Query参数解析中间件 &lt;/span&gt;&lt;br/&gt;      server.middlewares.use(queryParserMiddleware)&lt;br/&gt;      &lt;span&gt;// Open Edito服务中间件&lt;/span&gt;&lt;br/&gt;      server.middlewares.use(launchEditorMiddleware)&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// middleware.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 请求Query参数解析中间件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; queryParserMiddleware: Connect.NextHandleFunction = (&lt;br/&gt;  req: RequestMessage &amp;amp; {query?: object},&lt;br/&gt;  _,&lt;br/&gt;  next,&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!req.query &amp;amp;&amp;amp; req.url?.startsWith(SERVER_URL)) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; url = &lt;span&gt;new&lt;/span&gt; URL(req.url, &lt;span&gt;&quot;http://domain.inspector&quot;&lt;/span&gt;)&lt;br/&gt;    req.query = &lt;span&gt;Object&lt;/span&gt;.fromEntries(url.searchParams.entries())&lt;br/&gt;  }&lt;br/&gt;  next()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Open Editor服务中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; launchEditorMiddleware: Connect.NextHandleFunction = (&lt;br/&gt;  req: RequestMessage &amp;amp; {&lt;br/&gt;    query?: { line: &lt;span&gt;number&lt;/span&gt;; column: &lt;span&gt;number&lt;/span&gt;; file: &lt;span&gt;string&lt;/span&gt; }&lt;br/&gt;  },&lt;br/&gt;  res,&lt;br/&gt;  next,&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 只处理Open Editor接口&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (req.url.startsWith(SERVER_URL)) {&lt;br/&gt;    &lt;span&gt;// 解析SFC路径,行号,列号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { file, line, column } = req.query&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!file) {&lt;br/&gt;      res.statusCode = &lt;span&gt;500&lt;/span&gt;&lt;br/&gt;      res.end(&lt;span&gt;&quot;launch-editor-middleware: required query param \&quot;file\&quot; is missing.&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; lineNumber = +line || &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; columnNumber = +column || &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 见下方链接&lt;/span&gt;&lt;br/&gt;    launchEditor(file, lineNumber, columnNumber)&lt;br/&gt;    res.end()&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    next()&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于&lt;code&gt;launchEditor&lt;/code&gt;的具体逻辑我直接fork了react-dev-utils的实现,它支持很多IDE (&lt;code&gt;vscode&lt;/code&gt;,&lt;code&gt;atom&lt;/code&gt;,&lt;code&gt;webstorm&lt;/code&gt;...),它的大致原理就是通过维护一些进程映射表和环境变量,然后通过调用&lt;code&gt;Node.js&lt;/code&gt;的子进程唤醒IDE:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;child_process.spawn(editor, args, { &lt;span&gt;stdio&lt;/span&gt;: &lt;span&gt;&#x27;inherit&#x27;&lt;/span&gt; });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;交互功能注入&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能的实现原理其实就在&lt;code&gt;transformIndexHtml&lt;/code&gt;注入功能所需要的&lt;code&gt;html,scripts,styles&lt;/code&gt;.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    transformIndexHtml(html) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;            html,&lt;br/&gt;            tags: [{&lt;br/&gt;              tag: &lt;span&gt;&quot;script&quot;&lt;/span&gt;,&lt;br/&gt;              children: ...,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;body&quot;&lt;/span&gt;,&lt;br/&gt;            }, {&lt;br/&gt;              tag: &lt;span&gt;&quot;script&quot;&lt;/span&gt;,&lt;br/&gt;              attrs: {&lt;br/&gt;                &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;module&quot;&lt;/span&gt;,&lt;br/&gt;              },&lt;br/&gt;              children: scripts,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;body&quot;&lt;/span&gt;,&lt;br/&gt;            }, {&lt;br/&gt;              tag: &lt;span&gt;&quot;style&quot;&lt;/span&gt;,&lt;br/&gt;              children: styles,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;head&quot;&lt;/span&gt;,&lt;br/&gt;            }],&lt;br/&gt;          }&lt;br/&gt;       }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于交互的页面实现有很多种,最简单的无非就是编写原生&lt;code&gt;js&lt;/code&gt;,这样我们无需任何编译就可以直接注入到&lt;code&gt;html&lt;/code&gt;中,但是用原生&lt;code&gt;js&lt;/code&gt;来写页面真的是慢又不好维护,于是我选择了&lt;code&gt;Vue&lt;/code&gt;进行开发,使用&lt;code&gt;Vue&lt;/code&gt;就意味着要进行编译才能在浏览器中跑起来.为了这个所谓的研发体验,又折腾了一波,大概过程就是通过&lt;code&gt;compile-sfc&lt;/code&gt;等包编译出&lt;code&gt;render函数,样式代码等&lt;/code&gt;,为了兼容&lt;code&gt;Vue2&lt;/code&gt;,我又引入了祖传的&lt;code&gt;vue-template-compiler&lt;/code&gt;...噼里啪啦噼里啪啦..感兴趣的童鞋可以点传送门详看. (u1s1,还是有点意思的!!) 当然了,这部分的编译都是在插件打包时完成的,用户在使用插件的时候并不会有这部分的运行时开销.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;致谢&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目的灵感来自于react-dev-inspector,使用&lt;code&gt;React&lt;/code&gt;的童鞋可以看看.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结语&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做这个插件的时候也踩了一些坑,通过查看&lt;code&gt;vue,vite&lt;/code&gt;等源码排查解决.这里给想看源码的童鞋一个建议,从实践和带着问题的角度出发,也许会有更好的效果和更深刻的印象 (&lt;span&gt;教训&lt;/span&gt;) :)&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e801f88e879bb9a638e676ac8f47056</guid>
<title>闲鱼互动玩法标准化建设</title>
<link>https://toutiao.io/k/6e2ba5q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;现在大家对互动玩法应该已经司空见惯，很多APP或多或少都会在业务场景中采用各式各样的互动玩法来吸引用户，让用户在参与互动的同时，得到平台权益，进而提升平台心智，达到促活拉新目的。随着闲鱼规模变大，平台权益扩展，基于任务+抽奖的互动玩法在日常以及大型营销活动中应用越来越多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;痛点分析&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;263&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4547738693467337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPB98gwSFHc0xwMMf6avz059Pm3rpf8DM5ZKvhs0gkKeYHnichCKchibnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1592&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于活动中的互动玩法，从设计到研发再到验收上线的流程大致如上，在具体实践过程中，我们经常会遇到以下问题：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;底层能力抽象不够：业务开发同学需要关注玩法底层交互逻辑，不同活动需重复开发，开发成本高；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题难排查：互动玩法的配置包含抽奖、任务、积分等多个平台，链路复杂涉及数据交互多，其中一个环节配置错误，都有可能出现任务完成不了、抽奖次数不增加、抽奖不成功等问题，链路复杂无疑给排查问题增加了不少困难；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置问题后知后觉：抽奖、任务、积分等配置问题运营无法自助排查，往往需要在测试过程中由测试或者技术同学介入排查，占用开发时间，严重影响活动上线效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;技术方案&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;针对上面的痛点，对问题进行抽象，我们期望建设互动玩法标准化，当前阶段关键解法主要是以下三点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抽象互动能力：实现互动玩法标准化交互，沉淀面向开发者的互动玩法SDK，提高开发效率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;建设自助排查能力：在实现玩法在互动配置平台自测环节中，提供问题调试排查能力，引导运营自助解决配置问题，只有自测通过后才能提测，从而降低测试成本；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;统一互动配置平台：通过统一的闲鱼互动配置平台串联抽奖、任务、积分配置，建立标准流程，校验关键配置的准确性，让运营在提测前保证玩法整个流程顺畅。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;434&quot; data-backw=&quot;524&quot; data-ratio=&quot;0.8275862068965517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPPuqnYMs5V3NGLw5g3clicatEQz2fKtq28l1TfDa7oBwUS40SIwxs86g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;互动任务标准化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;大多数情况下，抽奖活动中都会有任务玩法，用户需要通过完成任务来增加抽奖次数。闲鱼的任务体系是使用淘系任务中心进行搭建的。任务与抽奖的链路如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;109&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.1882793017456359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPNX4GMGzCcIE1iccUlvOttAO82AyVHtxMzXlBuLViaIu6R8msYgEf41UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1604&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲鱼的互动任务有以下几种类型：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;仅跳转：点击任务按钮，进行页面跳转，并将任务参数以url参数形式带到后链路，后链路在特定操作后进行任务上报；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完成并跳转：点击任务按钮，在页面跳转同时进行任务上报；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;浏览任务：浏览任务与仅跳转任务类似，除了可以在后链路进行任务上报之外，也可以在当前页面进行任务上报。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;关于任务上报，目前闲鱼主要有两种方案：前端上报、事件采集上报。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;前端上报：当用户领取任务后，在定制场景下请求任务中心上报服务，完成任务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事件采集上报：闲鱼通用事件采集系统对用户特定行为进行采集，采集到行为信息后请求任务中心上报服务，完成任务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面以两个典型的任务来介绍任务上报链路，分别是会场浏览任务和关注闲鱼号任务，前者是前端进行任务上报，后者是事件采集进行上报。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;217&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3762575452716298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPtmzxeYdy6RC2RUH1ZIo4ic4n8IianptHosu6v4ZXxRu7mUO7JXKic9muQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在互动任务标准化建设过程中，前端在淘系任务中心的列表组件基础上，进行二次封装，简化组件配置，并且加一些闲鱼的定制能力，最终形成闲鱼通用的任务列表组件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;332&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5747549019607843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPjyQAMnicExhkDnPfAhtNTxJ55icPQVEgtDk4pdyNZHlCIbDrck7I7JPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;互动抽奖标准化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;前端在实现抽奖标准化中，主要是抽象抽奖能力，将抽奖通用逻辑封装成SDK，提高业务开发效率。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在进行抽奖之前，先初始化活动数据，获取用户在当前活动中的状态以及活动本身的相关数据；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持登录状态校验，允许用户未登录时访问页面，当用户进行抽奖时，执行登录逻辑，并且登录返回活动后重新进行活动初始化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持页面聚焦后，自动刷新活动数据，重新初始化活动；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抽奖之后，在展示当前抽奖结果的同时，支持自动更新中奖纪录，并且刷新活动数据；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试过程中，当抽奖出现异常时，可以及时排查出问题，提供解决问题方法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; Oliver &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;@ali/pcom-fin-oliversdk&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; oliverSdk = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Oliver({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  activityId: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;544&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  options: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    oliverParams: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      needBenefits: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      needDetails: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      needHadWin: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      extend: {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    autoUpdate: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    checkLogin: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  dataWatcher: &lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;data&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;oliverSdk.draw(params: { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  extend?: PlainObject;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  idleOliverBenefitCode?: &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}).then(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;oliverSdk.getLogs(params: {pageSize: &lt;span class=&quot;code-snippet__built_in&quot;&gt;number&lt;/span&gt;; curPage: &lt;span class=&quot;code-snippet__built_in&quot;&gt;number&lt;/span&gt;}).then(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;oliverSdk&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.update&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了降低业务上层开发同学对SDK的使用成本，考虑提供基于集团Rax方案的Hook能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4297385620915033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPFaX3GxoJw0AFplZOWU3kyAQ6aJpiappVoOwCIefLI8ZZbgLVoWFP1TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务层开发只需在调用方法时，依据数据变化来进行交互展示。这样既减少了上层代码量，同时降低开发成本。下面是Hook的使用代码示例：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; useOliver &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;@ali/pcom-fin-oliver-raxhook&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; { oliverData, drawResultData, draw } = useOliver({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;activityId&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;544&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;useEffect(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; availableTimes = oliverData?.availableTimes || &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, [oliverData]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;useEffect(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, [drawResultData]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;draw();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以往在抽奖活动测试验收过程中，服务端返回的异常code对于运营和测试同学来说非常不友好，没有直接展示异常原因，每次都需要技术同学介入来排查问题。为了快速定位问题解决问题，我们考虑提供问题调试能力，让运营和测试同学可以自助排查问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;抽奖SDK中有一个日志存储功能，在测试环境中将用户操作记录和服务端返回的数据存储在本地，另外提供一个日志列表页面，在页面中对日志进行解析，提供异常code的具体原因并提供解决方法，展示给运营和测试同学。自助排查功能使用流程如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31425091352009743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPiazhXFZldU1ibg6oJ1bicJFmZIBtvqKCVx9gtIUKOvzLs9KF7pQ79Lw5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;互动配置标准化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;互动玩法配置链路复杂，为了降低配置成本，减少配置错误，我们提出配置标准化方案。标准化配置主要解决以下三个问题：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;标准流程配置：引导运营一步一步进行配置，将复杂的配置链路流程化，避免有所遗漏；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置校验：在配置过程中，会拉取当前步骤中对应的配置进行校验，提示错误配置；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完整链路测试：在活动提测之前，需要运营自测活动配置，在通用测试页面中，完成做任务增加抽奖机会到抽取奖励减少抽奖机会这一完整链路，只有自测通过后才能提测。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;目前建设的抽奖标准化配置流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3650485436893204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPy9ibOSJXLzHHbooNUBBABnaicuicGHGt0BWVo3yiaK8TrROGJhdQiaXSJSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选择投放计划：拉取当前运营同学在抽奖配置平台中配置的投放计划列表，选择投放计划后展示投放计划中的权益配置；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;权益确定：选择投放计划中的权益，并进行限制规则配置；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选择兜底投放计划：支持选择当前投放计划的兜底计划；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高级配置：确定权益发放安全码配置以及抽奖后扣减的积分配置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5106666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1Fdm5cdKVpe8qGib9XXKKHJPCcHsqweDQqy7LspY4QIicORGia06UYmdp0HKtq6ibVvBOuLo3ic6xzNFaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;互动玩法的标准化实现在闲鱼内多个互动场景中落地，如双11的节后鱼生活动、五福主题的鱼生有福活动、闲鱼币狂欢日、天天赚钱等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;前端对互动逻辑的封装抽象，互动模块开发效率有显著提升，开发工时相对减少50%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运营和测试同学使用SDK调试能力，实现了快速定位问题，开发零成本介入问题排查；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运营按照标准流程对互动活动进行配置，在配置过程中，提前检验配置的正确性，降低了后续活动测试成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;互动玩法已然成为一种常用的运营手段，在玩法落地过程中，我们分析痛点，不断探索，以技术手段降低互动玩法上线成本，并且取得了显著效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实现互动玩法标准化后，我们会继续抽象基础互动玩法，搭建一个玩法模块化的互动玩法平台，抽象基础玩法，如抽奖、签到、抽签、投票等。在互动玩法平台上，运营同学可以自助配置玩法，无需开发和测试同学高成本投入，活动上线效率与质量也可以得到有效保障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;2390&quot; data-backw=&quot;578&quot; data-ratio=&quot;4.13570487483531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GLZDqvPfwuIUEJjtdPx4lYwPx0p9E4T3D1f164CCr18n4ms26HtWsUVrsLf8Szwb4Us8MuhOCe3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>