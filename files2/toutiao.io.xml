<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dc52ff6193068e322852cb2a240d703a</guid>
<title>程序员应该掌握的常用网络问题定位工具</title>
<link>https://toutiao.io/k/upefap5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;项目日常运维的过程中，经常会遇到各种奇奇怪怪的网络问题。那么排查网络问题，就成为一个合格的程序员必备技能。这里列举出一些常用的指令，用于日常工作中快速定位网络问题。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;ping&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这个是大家经常用到的一个小工具，用于检查两台服务器之间是否能够成功交换数据包。&lt;code&gt;ping&lt;/code&gt;指令向对方主机发送&lt;code&gt;ICMP&lt;/code&gt;报文。当能成功&lt;code&gt;ping&lt;/code&gt;通时表示两台主机之间的网络链路是畅通的。如果&lt;code&gt;ping&lt;/code&gt;不通，首先需要确认对方是否关停了&lt;code&gt;ping&lt;/code&gt;服务，如果没有关停，就需要检查双方的网络链接问题了。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;telnet&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;该指令主要用于检查到对方端口的网络联通性，如果&lt;code&gt;telnet&lt;/code&gt;能通，一般证明&lt;code&gt;TCP&lt;/code&gt;三次握手已经建立成功，也就是网络层是畅通的。如果&lt;code&gt;telnet&lt;/code&gt;不通，需要确认对方是否已经启动相应服务端口，如果已启动，那么就要检查双方的防火墙策略等问题。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;ifconfig&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt; 指令除了可以查看网卡信息外，还可以修改网络配置。比如查看网卡信息 &lt;code&gt;ifconfig -a&lt;/code&gt; ；启动网卡 &lt;code&gt;ifconfig eth0 up&lt;/code&gt; ；关停网卡 &lt;code&gt;ifconfig eth0 down&lt;/code&gt;等操作。&lt;/p&gt;&lt;p&gt;除了使用&lt;code&gt;ifconfig&lt;/code&gt; 查看及配置网卡信息外，还可以通过 &lt;code&gt;ip link show&lt;/code&gt; 查看网卡信息，启动网卡信息 &lt;code&gt;ip link set down eth0&lt;/code&gt;; 关停网卡 &lt;code&gt;ip link set up eth1&lt;/code&gt; 等操作。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意：启动关停网卡在&lt;code&gt;SSH&lt;/code&gt;链接的情况下，尽量不要操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5&gt;&lt;span&gt;route&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;route&lt;/code&gt; 指令一般用于查看和配置服务器路由信息。比如查看路由信息 &lt;code&gt;route -n&lt;/code&gt; 或者 &lt;code&gt;route -nee&lt;/code&gt; 添加或者删除路由信息 &lt;code&gt;route {add | del } -net {NETWORK-ADDRESS} netmask {NETMASK} dev {INTERFACE-NAME}&lt;/code&gt; 等等。&lt;/p&gt;&lt;p&gt;同样，除了使用&lt;code&gt;route&lt;/code&gt;指令外也可以使用 &lt;code&gt;ip route show&lt;/code&gt; 查看路由信息；和 &lt;code&gt;route -n&lt;/code&gt; 是等效的。这里更推荐使用&lt;code&gt;ip route&lt;/code&gt; 命令。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;traceroute&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;该指令用于查看从源地址到目的地址的路由路径。比如 &lt;code&gt;traceroute www.baidu.com&lt;/code&gt; 用于判断你和目标地址之间经过了哪些网络设备。&lt;code&gt;windows&lt;/code&gt;下是&lt;code&gt;tracert&lt;/code&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;netstat&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这个指令比较强大，也是程序员日常用的比较多的一个指令。该指令可以显示服务器的网络状态，比如，显示服务器当前所有&lt;code&gt;socket&lt;/code&gt;链接 &lt;code&gt;netstat -a&lt;/code&gt;; 显示&lt;code&gt;UDP/TCP&lt;/code&gt;端口的使用情况 &lt;code&gt;netstat -apu/netstat -apt&lt;/code&gt;; 显示网络统计信息 &lt;code&gt;netstat -s&lt;/code&gt;; 查看&lt;code&gt;8080&lt;/code&gt;端口的状态 &lt;code&gt;netstat -anp|grep 8080&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;和&lt;code&gt;netstat&lt;/code&gt;等价的指令是&lt;code&gt;ss&lt;/code&gt;指令。&lt;code&gt;ss -l&lt;/code&gt; 列出所有本机已经打开的端口。&lt;code&gt;ss -t/u -a&lt;/code&gt; 显示所有&lt;code&gt;tcp/udp&lt;/code&gt;链接。查看某个链接属于哪个进程 &lt;code&gt;ss -tp&lt;/code&gt;。查看本地的端口状态 &lt;code&gt;ss -t src ip:8080&lt;/code&gt;。这里更推荐使用&lt;code&gt;ss&lt;/code&gt;指令。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;tcpdump&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;网络抓包工具，当遇到奇怪的网络问题时，通过&lt;code&gt;tcpdump&lt;/code&gt;进行网络抓包，然后进行分析定位问题。根据源IP进行抓包 &lt;code&gt;tcpdump -i eth2 src 192.168.199.100&lt;/code&gt; 即只抓取通过&lt;code&gt;eth2&lt;/code&gt;这块网卡的且源地址为&lt;code&gt;192.168.199.100&lt;/code&gt;的网络包。当然也可以指定端口抓包，比如 &lt;code&gt;tcpdump src port 8088&lt;/code&gt;。总之该命令非常强大，这里不做更多的详细介绍，感兴趣的可以自行了解。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;nmap&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这是一个网络嗅探和扫描工具，做网络安全的小伙伴会比较熟悉。经常用来检查对方主机开放了哪些端口。比如查看对方主机开放了哪些端口&lt;code&gt;nmap -PS 192.168.199.100&lt;/code&gt;，还可以探测目标IP的操作系统 &lt;code&gt;nmap -O 192.168.199.100&lt;/code&gt;。总之该命令做网络安全的会用的比较多，程序员使用的会比较少一些，感兴趣的可以深入研究，该指令及其强大。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;上面提到的小工具，对于有些问题的定位，可以通过两个不同的指令达到同样的效果。比如 &lt;code&gt;ifconfig -a&lt;/code&gt; 和 &lt;code&gt;ip link show&lt;/code&gt; ； &lt;code&gt;route -n&lt;/code&gt; 和 &lt;code&gt;ip route show&lt;/code&gt;；以及&lt;code&gt;netstat&lt;/code&gt;和&lt;code&gt;ss&lt;/code&gt;。出现这样的情况是因为，&lt;code&gt;ifconfig&lt;/code&gt; 和 &lt;code&gt;netstat&lt;/code&gt;等命令来自于&lt;code&gt;net-tools&lt;/code&gt;工具包，而&lt;code&gt;ip link&lt;/code&gt; 和 &lt;code&gt;ss&lt;/code&gt; 等指令来自&lt;code&gt;iproute2&lt;/code&gt;工具包。&lt;code&gt;net-tools&lt;/code&gt;已经停止开发了，在很多新版的操作系统里面已经不是默认自带的工具包了，如果想使用需要单独安装。&lt;code&gt;iproute2&lt;/code&gt;是用来替换&lt;code&gt;net-tools&lt;/code&gt;的，很多新版&lt;code&gt;linux&lt;/code&gt;都是默认安装的。而且&lt;code&gt;iproute2&lt;/code&gt;包中的很多指令在功能和性能上都要比&lt;code&gt;net-tools&lt;/code&gt;包中提供的指令更强大。我这里从网上找了一张图片用来说明俩个工具包的指令对比。&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.33359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9QjxFvicyicu6nvFpW3mEZYFWf1Sz3zER2tlEsegCJRElFYLGBePNjz9j9rYrFvDoBnEKHwxKPRlsTug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484121&amp;amp;idx=1&amp;amp;sn=ae0182c28b5fcfe4008d116cb283c683&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 当我们设置IP地址为0.0.0.0时，是在表达什么&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8d818df771401447a50b28d02b7b4f4</guid>
<title>不看源码，怎么卷的过小年轻</title>
<link>https://toutiao.io/k/ez9hkgb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工作中，我相信很多人都有下面这样的感受：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这谁的代码呀，看不下去了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这破代码，一行注释也没有&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这代码，还没我写的好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这代码，有 bug 吧&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这代码，。。。。。。。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很真实，我们往往在看别人代码的时候就会有上面这些想法。我认为主要的原因还是大部分看的都是业务代码，而且很多是多年积累下来的，也没有重构，然后一年年的堆逻辑，最后就变成 shi 山了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也有不少的人代码写的确实很好，简洁易懂，我们在看别人代码的时候要抱着学习的态度去看，同样的逻辑，看看别人是怎么写的，为什么这样写，如果是自己会怎么写，对比下，这样的话你就有收获了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天想跟大家聊的话题主要是看开源项目的源码，因为业务代码大家每天都能看。所以往往只会去用某些框架，而忽略了它的内在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多看开源项目的源码是很好的学习机会，特别是当你遇到问题的时候，或者想要做一个什么功能的时候，如果有其他框架中也有类似功能，那么你就知道怎么做了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;案例一&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我在做一个功能，需要集成多种配置中心，如果依赖了 Nacos 那就用 Nacos，如果依赖了 Apollo，那就用 Apollo。在自动装配的类中就要处理这种没有依赖的情况，最开始想的就是这样处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@ConditionalOnClass(value = com.alibaba.nacos.api.config.ConfigService.class)&lt;br/&gt;@ConditionalOnMissingClass(value = { &quot;com.alibaba.cloud.nacos.NacosConfigProperties&quot; })&lt;br/&gt;@Bean&lt;br/&gt;public NacosConfigUpdateListener nacosConfigUpdateListener() {&lt;br/&gt;    return new NacosConfigUpdateListener();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后测试发现，如果在项目没有依赖 Nacos 的情况下，这里就会报错，虽然加了判断也不行。这个时候我就再想，其他的一些框架中是如何实现的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候我就想到之前看 Zuul 的源码，里面也有类似的需求。会使用不同的 Client 来进行调用，比如 ApacheHttpClient, OkHttpClient。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现 Zuul 里面是加了静态类进行判断的，这就不会报错了。如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Configuration&lt;br/&gt;@ConditionalOnClass(value = com.alibaba.nacos.api.config.ConfigService.class)&lt;br/&gt;@ConditionalOnMissingClass(value = { &quot;com.alibaba.cloud.nacos.NacosConfigProperties&quot; })&lt;br/&gt;protected static class NacosConfiguration {&lt;br/&gt;    @Bean&lt;br/&gt;    public NacosConfigUpdateListener nacosConfigUpdateListener() {&lt;br/&gt;        return new NacosConfigUpdateListener();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;案例二&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我需要控制 Feign 的调用逻辑，替换调用的 URL 时我就想到之前看过 Sleuth 的源码，Sleuth 做为一款链路跟踪框架，内部对很多框架进行了集成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 Feign 这种远程调用的，需要对它进行扩展，然后透传链路跟踪的数据。所以当我也有类似需求的时候，就可以参考 Sleuth 的实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43802083333333336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WRLYshvT39ywiasPoRDuE3lyuc5tlVhkBHOzib8kx9Y7zSLEx9rp9b99pvsSLM2evJNiamlXWNKSGXeL9yefrbZ1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面贴了 Sleuth 中的 TracingFeignClient 源码，TracingFeignClient 就是 Sleuth 中对 Feign Client 的扩展，增加了 Sleuth 自己的一些逻辑。然后这个 TracingFeignClient 最终会在启动的时候替换掉 Feign 默认的 Client。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;案例三&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我需要对 Redis 做埋点监控的时候，又想起了之前看过 opentracing 中对 Redis 的监控代码，就可以借鉴里面的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/opentracing-contrib/java-spring-cloud/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面就是用了 AOP 对 RedisConnectionFactory 和 RedisConnection 进行了替换，也不用动框架底层的代码，扩展就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写本文的目的就是为了告诉大家，在平时无事的时候除了学习一些框架的使用，也要去翻翻源码。虽然当时不一定用的到，但是在你以后遇到类似问题的时候，你会有映象说，当时我在某某框架中看到过类似的解决方案，这就是你的知识积累。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个点就是这些框架中都会用到一些好的设计，也是我们可以学习参考的案例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是在面试中也有遇到说：有没有看过框架的源码啊之类的问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的看过，并且记住了，这个时候你就可以和面试官侃侃而谈，称兄道弟了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于作者&lt;/strong&gt;：尹吉欢，简单的技术爱好者，《Spring Cloud 微服务-全栈技术与案例解析》, 《Spring Cloud 微服务 入门 实战与进阶》作者, 公众号&lt;strong&gt;猿天地&lt;/strong&gt;发起人。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b430282660808151fa13349d232b4e76</guid>
<title>图解 Kafka</title>
<link>https://toutiao.io/k/lvyzxo8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 是主流的消息流系统，其中的概念还是比较多的，下面通过图示的方式来梳理一下 Kafka 的核心概念，以便在我们的头脑中有一个清晰的认识。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgH2BGwmm6icyRmvH3xYEsfPMYPviaOCybBE110heSzY2ALOQj0Xch1zLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;704&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生产者消费者&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。&lt;/p&gt;&lt;img data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgNLqhVgvrvZZ2VumojX2DrVRsP57vYUzTNHGSFG6pHeeYX8VQDiaLdJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;660&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个服务可以同时为生产者和消费者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgkWQcJ7vmeTI6gStehRDRwCicxRBcoDRof0xusb90PLHicSLxfG6dTrYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;248&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Topics 主题&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic 是生产者发送消息的目标地址，是消费者的监听目标。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tg4qNUFF2kjsATdXuvjibmdlSLDEetCnC2BC0sibvhkKArGLzDKkSta5og/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;660&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个服务可以监听、发送多个 Topics。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8522727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgXTq6egibticaGibsHklvMAJ4uMX5Wxx4U5U6h6TjBB9hNK57CyVjMtmJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;704&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 中有一个【consumer-group（消费者组）】的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一组服务，扮演一个消费者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5568487018800358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgHDwibGwVt3fJpE6fnKicm62WqPJwy8e95vwxodbopQ7TaF8VwVicAgIRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1117&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是消费者组接收消息，Kafka 会把一条消息路由到组中的某一个服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5568487018800358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgDE5zc0lIwdVj4jWngM0R5zvFJL8MQaI2xmiblpYM3ZJswgbMzmhiaYkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1117&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样有助于消息的负载均衡，也方便扩展消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic 扮演一个消息的队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，一条消息发送了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1575757575757575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgpDh9FLrciaUeibchibLeLOynyibHKkxHUcgibAxGUNegqkoricM3hb1zpdlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;495&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，这条消息被记录和存储在这个队列中，不允许被修改。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1575757575757575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgCUeOOltsYVZDj4icapBBDicStIznibusiaNbZcQ4dyehPkU7P50X1fXoiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;495&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，消息会被发送给此 Topic 的消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这条消息并不会被删除，会继续保留在队列中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8981191222570533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tgj553KaO3jd5u4N1tlfUngcHavoTypBRiahde4UNRQWfcUw9buTPA48g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续发送消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8981191222570533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tg9iafmKBkd2zAJlqgUdTkibAiaxvNmHvq47iariclWZLVSPCKvHNnjMHk0Wg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像之前一样，这条消息会发送给消费者、不允许被改动、一直呆在队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（消息在队列中能呆多久，可以修改 Kafka 的配置）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8981191222570533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgNIoNibTwe7YArePibmtsyic7fpgbKqytgOswaAhC3fApicqNbhyXZXtDew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7188995215311005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tgjq74jFPgBAbnibjkpTPT1HL58emZ6upKricrBaewdEaQkgnsoayR7vzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;836&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Partitions 分区&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面 Topic 的描述中，把 Topic 看做了一个队列，实际上，一个 Topic 是由多个队列组成的，被称为【Partition（分区）】。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可以便于 Topic 的扩展。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8947368421052632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TggGbzLnO30Lia5URJARiaIiccUlxiaUKwpusZJIZ5ev8kI3WEnfvs4q6aIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;418&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者发送消息的时候，这条消息会被路由到此 Topic 中的某一个 Partition。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9742710120068611&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgCEic2Ol33Gt7r2Zv6KibEUr9iaNkydaJxhaQ0q8mjwS2hQw0164hWBb2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;583&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者监听的是所有分区。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7593582887700535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TggEwbEGwaKFO9yOYhOMtp2VyticZIMsbuwA3vw38w0ZE4iaUI8WsEE8fA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者发送消息时，默认是面向 Topic 的，由 Topic 决定放在哪个 Partition，默认使用轮询策略。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7593582887700535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgVdicxah0Ib9TUHoDnhhobSvrZJPyPHQ9VXZDhzPS2SIXwzN2HrTmgGg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以配置 Topic，让同类型的消息都在同一个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，处理用户消息，可以让某一个用户所有消息都在一个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，用户1发送了3条消息：A、B、C，默认情况下，这3条消息是在不同的 Partition 中（如 P1、P2、P3）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置之后，可以确保用户1的所有消息都发到同一个分区中（如 P1）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7593582887700535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgQVmLZASjO2JQ6PK9TtdVkJ9FA7dKIx7JKOdGcbiaazLVaeY6Rib6EVww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能有什么用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为了提供消息的【有序性】。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息在不同的 Partition 是不能保证有序的，只有一个 Partition 内的消息是有序的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7593582887700535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgRmrXsFYMnaFXm7wkQZBiaVZVTdXEcnK9ph0cxic7cYduibZasVRxvXUjg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6221248630887185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tg7B7hiakAIOMibjreQtexYOdzBicEa5JpxrxlpUQhfdqB3OmFBpugTbkcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;913&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 是集群架构的，ZooKeeper是重要组件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6896551724137931&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgvnegzHkrGYLfREhzfqhge969uib5bUoIGJRtddVPiaRbyF3fHQN3wjicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZooKeeper 管理者所有的 Topic 和 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic 和 Partition 存储在 Node 物理节点中，ZooKeeper负责维护这些 Node。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgJl2ZPf3LGtFaiaFIpMddGUViaCNWSKQ2hY4xMAD8E4V3HSibicOURCVxIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，有2个 Topic，各自有2个 Partition。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7117224880382775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgvNZCfmfDHH5EW2ADWhdTmEpCMqHICL0UWcMX3jSicfp24Fm5wbBlVBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;836&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是逻辑上的形式，但在 Kafka 集群中的实际存储可能是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgxAzyaT64HTpIeELs12THj8NsI6naicyribxnDGwZK5dNWbiczUBTaTUvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic A 的 Partition #1 有3份，分布在各个 Node 上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可以增加 Kafka 的可靠性和系统弹性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3个 Partition #1 中，ZooKeeper 会指定一个 Leader，负责接收生产者发来的消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6097560975609756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tgtib24AG1DcLyuc3CRXz1mkXIoK2fohvE2ZAEsXpFiaKPLialwQ52Wib1rg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他2个 Partition #1 会作为 Follower，Leader 接收到的消息会复制给 Follower。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6097560975609756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tg39ebhKe3e4OFHw6RZJqiblXPkH68oyCEwOJkBibtRAyWUdAJ6BrVA0cA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，每个 Partition 都含有了全量消息数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6097560975609756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2TgSLAXuia2tMEaE2tG1oB6th1ic4Gib1kj9VmILEvv0qkWiaFnoNrwBn1ibbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使某个 Node 节点出现了故障，也不用担心消息的损坏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic A 和 Topic B 的所有 Partition 分布可能就是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6097560975609756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl93rzIoFNXJekOmRoIT7J2Tgbl1mYqw2lHp6sP8X4sNGibFrBcrcrJBnbrkB99aZWxLuxicN77IZcDrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢阅读，希望对你有所帮助 :)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译整理自：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://timothystepro.medium.com/visualizing-kafka-20bc384803e7&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bec4ae0bb1696d006d9ff26046f2a434</guid>
<title>升级 Vue 3 大幅提升开发运行效率</title>
<link>https://toutiao.io/k/rhbhde7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：louiszhai，腾讯 IEG 前端开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vue3 性能提升了 1.3~2 倍，SSR 性能提升了 2~3 倍，升级 Vue3 正是当下。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原计划 2019 年发布的 Vue3，又经过一年的再次打磨，终于于去年 9 月正式发布。随后，不少 UI 组件库都积极参与适配，去年 12 月，Element-plus（Element-ui 官方升级版）也发布了 beta 版。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于项目中用到了 Element-ui 组件，组件库未适配的情况下，不敢贸然升级 Vue3。Element-plus 发布后，又经过 1 个月的观察、测试和调研，发现 Element-plus 相对成熟（还有少量 bug，后续会讲），便开始尝试升级 Vue3。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何升级 Vue3&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种方案可以快速升级 Vue3：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是使用微前端轮子，我基于 qiankun2，搭建了 Vue3 项目基座，为了保证平稳升级，子项目继续使用 Vue2，然后不断的把子项目的页面迁移到基座项目。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种是，直接升级 Vue3，将项目中的 Vue2 依赖库升级到 Vue3 的最新版（当前最新版是&lt;a href=&quot;https://github.com/vuejs/vue-next/tree/v3.0.11&quot; data-linktype=&quot;2&quot;&gt;v3.0.11&lt;/a&gt;），并且稍微改造 webpack 编译脚本，使之适配 Vue3。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以会有方案一，主要还是担心 Element-plus 不够稳定，如果有天坑，又无法绕过去，除了向饿了么团队提交 PR，微前端兜个底也是不错的应急措施。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样微前端方案又运行了 1 个月，部分页面已完成升级，运行良好，实践证明 Element-plus 比想象中稳定，这增加了我对于方案二的信心。考虑到还有少量业务复杂的页面，在微前端模式下，子项目的各种数据多经过一层 qiankun 的 proxy 代理，性能有损耗，影响了页面更新，于是一次性将剩余的页面全部迁移到 Vue3 项目中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实践证明，除非比较复杂的项目，或者依赖组件库没升级等原因不适合升级外，常规情况下，升级 Vue3 都是一个不错的选择。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么要升级 Vue3&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要升级 Vue3，这是一个几乎不需要回答的问题。升级 Vue3 后，代码结构更加清晰内聚，响应式数据流更加可控，节省了很多心智成本，从而使得开发效率大幅提升。Vue3 还带来了很多新特性，框架层面运行性能更高（性能提升了 1.3 至 2 倍，SSR 性能提升了 2 至 3 倍），Composition API 使得代码拆分，函数封装更容易，复杂项目也随之更容易管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue2 中，相关的逻辑经常分散在 option 的 data、watch、computed、created、mounted 等钩子中，阅读一段代码，经常需要上下反复横跳，带来了部分阅读障碍。钩子又依赖 Vue 实例，代码封装基于天生携带钩子的 Mixin 去做，更加容易和相对方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但正因为如此，Mixin 的钩子容易不自觉的越界，插手到页面或组件的内部变量和方法管理过程中；甚至，多个不同的 Mixin，相互之间就很容易冲突，项目开发者，在引入 Mixin 和避免冲突之间需要保持微妙的平衡，不但增加心智负担，还带来了副产品：本身扑朔迷离的 this 变得更加不确定。因此，大型项目 Mixin 几乎都是一种反模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在这些框架问题，都由 Vue3 的 Composition API 解决了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue3 带来了哪些新特性&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看一些立马能感受到变化的特性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6068222621184919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYMU13t26LPOUrjoEy3kFW0yBEicBsTa07NqPz30Q5TC7BORklicqpm4EQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1114&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Proxy 代理&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个一上手 Vue3 就能感知的变化。即使你在 Vue3 中编写 Vue2 风格的基于 option 的代码，Proxy 也是默默提供着数据响应式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; observe = &lt;span&gt;(&lt;span&gt;data&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;Object&lt;/span&gt;.keys(data).forEach(&lt;span&gt;(&lt;span&gt;key&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; initValue = data[key];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; value = initValue;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; initValue === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;) {&lt;br/&gt;      observe(initValue);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;Object&lt;/span&gt;.defineProperty(data, key, {&lt;br/&gt;      &lt;span&gt;enumerable&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;configurable&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;get&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;visit key value =&#x27;&lt;/span&gt;, key, value);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;set&lt;/span&gt;(val) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`[&lt;span&gt;${key}&lt;/span&gt;]changed，old value=&lt;span&gt;${value}&lt;/span&gt;, new value = &lt;span&gt;${val}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(value !== val) {&lt;br/&gt;          value = val;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  });&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = {};&lt;br/&gt;&lt;span&gt;Array&lt;/span&gt;.from(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;), () =&amp;gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;).forEach(&lt;span&gt;(&lt;span&gt;item, i&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  data[i] = { &lt;span&gt;value&lt;/span&gt;: i * &lt;span&gt;2&lt;/span&gt; };&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.time();&lt;br/&gt;observe(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.timeEnd(); &lt;span&gt;// default: 0.225ms&lt;/span&gt;&lt;br/&gt;data.a = { &lt;span&gt;b&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; };&lt;br/&gt;data.a.b = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所示，Vue2 的数据响应式是通过 Object.defineProperty 实现，这是一个深度遍历的过程，无论 data 中包含多少层数据，都需要全部遍历一遍。深度遍历，给对象的每个自身属性添加 defineProperty，需要不小的性能开销，同时后面新增到 this 中的属性不提供响应式监听，因此我们需要使用诸如&lt;code&gt;this.$set&lt;/code&gt;这种方式去添加新属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Proxy 就没有这个问题，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; observe = &lt;span&gt;(&lt;span&gt;data&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(data, {&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;   &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;visit&#x27;&lt;/span&gt;, key);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, key, receiver);&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;   &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`[&lt;span&gt;${key}&lt;/span&gt;]changed, value = &lt;span&gt;${value}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;   &lt;span&gt;Reflect&lt;/span&gt;.set(target, key, &lt;span&gt;typeof&lt;/span&gt; value === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; ? observe(value) : value, receiver);&lt;br/&gt;  }&lt;br/&gt; });&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; data = {};&lt;br/&gt;&lt;span&gt;Array&lt;/span&gt;.from(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;), () =&amp;gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;).forEach(&lt;span&gt;(&lt;span&gt;item, i&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  data[i] = { &lt;span&gt;value&lt;/span&gt;: i * &lt;span&gt;2&lt;/span&gt; };&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.time();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proxy = observe(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.timeEnd(); &lt;span&gt;// default: 0.041ms&lt;/span&gt;&lt;br/&gt;proxy.a = { &lt;span&gt;b&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; }; &lt;span&gt;// [a]changed, value = [object Object]&lt;/span&gt;&lt;br/&gt;proxy.a.b = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;// visit a \n [b]changed, value = 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Proxy 不但使得 data 获得了新属性的响应性，整个响应式处理过程的效率还提升了数倍，由此带来了 Vue3 的大部分性能提升。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Composition API&lt;/span&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5408970976253298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYImjFMr6t7hNqONXyh39ajkFveyzXwU8UukaP51v0KaHJo1wb9sX1AQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;758&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保持对 Vue2 的向下兼容，Vue3 中仍然支持纯 Option 配置的书写方式，这为升级提供了便利，平移 Vue2 的代码，只需少量改动，便可正常运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时考虑到上手难度，Vue3 的顶层代码风格与 Vue2 保持一致，依然是 export 一个对象，对象包含了一系列的配置，其中便有 setup 入口函数。我们先来看一段代码，然后逐个解读。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { defineComponent, ref, reactive, toRefs, watch, watchEffect, computed, onMounted } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineComponent({&lt;br/&gt; setup(props, context) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; selectRef = ref(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;// 作为下拉框的ref引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; state = reactive({ &lt;span&gt;// 响应式数据，类似于Vue2的this&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;num&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { init } = toRefs(props);&lt;br/&gt;    watch(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; state.num, (newVal, oldVal) =&amp;gt; {&lt;br/&gt;     &lt;span&gt;console&lt;/span&gt;.log(newVal, oldVal);&lt;br/&gt;    });&lt;br/&gt;    watchEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     &lt;span&gt;console&lt;/span&gt;.log(state.num);&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; num2 = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; state.num + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    onMounted(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;     state.loaded = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { selectRef, state, num2, init, context };&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;setup 作为入口函数，包含两个参数，分别是响应式的 props 外部参数，以及 context 对象，context 包含 attrs、emit、expose、props、slots 五个参数，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7543859649122807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzY3aiajmod8oOZDAn7v9Q4bGfNRqptrU9c8nYybGpPiayJqswZynIhPo4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;342&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Vue3 的设计里，setup，以及从 vue 对象中解构出来的各种生命周期函数，执行优先级高于 Vue2 中的各种生命周期钩子，因此&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;beforeCreate() {&lt;br/&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;beforeCreate&#x27;&lt;/span&gt;);&lt;br/&gt;},&lt;br/&gt;created() {&lt;br/&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;create&#x27;&lt;/span&gt;);&lt;br/&gt;},&lt;br/&gt;setup() {&lt;br/&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;setup&#x27;&lt;/span&gt;);&lt;br/&gt;},&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的输出依次是 setup、beforeCreate、created。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ref、reactive&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;setup 中，第一句&lt;code&gt;const selectRef = ref(null);&lt;/code&gt;，这里定义的是一个响应式的数据，可传递给 template 或 render，用于下拉框组件或下拉框 dom 绑定引用。为什么使用 ref，不使用 reactive 呢？ref 和 reactive 都可以给数据添加响应性，ref 一般用于给 js 基本数据类型添加响应性（当然也支持非基本类型的 object），reactive 只能用于代理非基本数据类型。null 是基本数据类型，只能使用 ref，那既然如此，为什么不在所有情况都使用 ref 呢？我们来看一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; num = ref(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;num.value = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = { &lt;span&gt;a&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; refObj = ref(obj);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reactiveObj = reactive(obj);&lt;br/&gt;refObj.value.a = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;reactiveObj.a = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(num, refObj, reactiveObj);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们注意到，使用 ref api 时，数据变成了对象，值就是 value 属性的值，如果数据本身就是对象，依然会多一层 value 结构，而 reactive 没有这些副作用。同时，还有一个有意思的现象是，所有的源数据，都需要经过响应式 api 包裹，然后才能使用，这跟前面提到的 Proxy 原理有关，Proxy 代理数据时，需要基于返回的代理进行数据更新。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;toRefs&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 ref、reactive 外，还有一个常用的响应式 api——toRefs。为什么需要它，这是因为响应式对象，经过解构出来的属性不再具有响应性，toRefs 就是为了快速获得响应性的属性，因此这段代码&lt;code&gt;const { init } = toRefs(props);&lt;/code&gt;，就是为了获得响应式属性 init，想要保留 props 参数的响应性，建议这么做。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;watch、watchEffect&lt;/span&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; num = ref(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; state = reactive({&lt;br/&gt; &lt;span&gt;num&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = { &lt;span&gt;num&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;watch(num, (newVal, oldVal) =&amp;gt; {&lt;br/&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;num&quot;&lt;/span&gt;, newVal, oldVal);&lt;br/&gt;});&lt;br/&gt;watch(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; state.num, (newVal, oldVal) =&amp;gt; {&lt;br/&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;num&quot;&lt;/span&gt;, newVal, oldVal);&lt;br/&gt;});&lt;br/&gt;watch(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; obj.num, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;这里不会执行&quot;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;num++;&lt;br/&gt;state.num++;&lt;br/&gt;obj.num++;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上，watch api，它需要接受一个具有返回值的 getter 函数或者 ref（如() =&amp;gt; state.num，ref）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要监听多个值，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; num1 = ref(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; num2 = ref(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;watch([num1, num2], ([newNum1, newNum2], [prevNum1, prevNum2]) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log([newNum1, newNum2], [prevNum1, prevNum2]);&lt;br/&gt;});&lt;br/&gt;num1.value = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// [1, 0], [0, 0]&lt;/span&gt;&lt;br/&gt;num2.value = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;// [1, 2], [1, 0]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见多个数据的每次更新都会触发 watch。想要监听一个嵌套的对象，跟 Vue2 一样，依旧需要使用 deep 选项，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; state = reactive({&lt;br/&gt;  &lt;span&gt;attr&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;watch(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; state, (currState, prevState) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(currState.attr.id, prevState.attr.id, currState === prevState, currState === state); &lt;span&gt;// 2, 2, true, true&lt;/span&gt;&lt;br/&gt;}, { &lt;span&gt;deep&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });&lt;br/&gt;watch(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; state.attr.id, (currId, prevId) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(currId, prevId); &lt;span&gt;// 2, 1&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;state.attr.id = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到差别了吗？监听响应式对象时，返回的是对象的引用，因此 currState，prevState 指向是同一个最新的 state，如果需要获取变化前的值，建议返回监听的属性，如&lt;code&gt;watch(() =&amp;gt; state.attr.id)&lt;/code&gt;，刚好 state.attr.id 是一个基本类型的值，那么 deep 也不需要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;watchEffect 是 Vue3 新增的 api，watchEffect 会自动运行一次，用于自动收集依赖，但不支持获取变化前的值，除此之外，与 watch 用法一致。那么 watchEffect 适用什么场景呢？这也是我刚上手 Vue3 的困惑之一。我们来看一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; rights = {&lt;br/&gt;  &lt;span&gt;admin&lt;/span&gt;: [&lt;span&gt;&quot;read&quot;&lt;/span&gt;, &lt;span&gt;&quot;write&quot;&lt;/span&gt;],&lt;br/&gt;  &lt;span&gt;user&lt;/span&gt;: [&lt;span&gt;&quot;read&quot;&lt;/span&gt;],&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; state = reactive({&lt;br/&gt;  &lt;span&gt;rights&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; userInfo = reactive({ &lt;span&gt;role&lt;/span&gt;: &lt;span&gt;&quot;user&quot;&lt;/span&gt; });&lt;br/&gt;userInfo.name = &lt;span&gt;&quot;Tom&quot;&lt;/span&gt;;&lt;br/&gt;userInfo.role = &lt;span&gt;&quot;admin&quot;&lt;/span&gt;;&lt;br/&gt;watch(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; userInfo.role, (newVal, oldVal) =&amp;gt; {&lt;br/&gt; state.rights = rights[newVal];&lt;br/&gt;});&lt;br/&gt;watchEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; state.rights = rights[userInfo.role];&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码中，watch 中的逻辑只能在 userInfo 变化后执行，因此 state.rights 不会提供初始值，相反，watchEffect 中 state.rights 由于自动依赖收集，获得了一次赋值的机会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处是什么呢？在实际项目中，userInfo.role 可能是一个全局 store 中的数据，用户登录进来后，就会通过接口获取初始值，我们并不能确认，用户进到其中一个页面时，userInfo.role 的值是否已经被接口更新，且 userInfo 变化前的值我们也不关心，watchEffect 就非常适合这种场景，它会自动进行一次初始化，并且在变化后，及时更新值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;watch 和 watchEffect 的监听会在组件销毁时自动取消，除此之外，可以通过它们返回的函数手动取消监听，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; stopWatch = watch(selectRef, (newVal, oldVal){});&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; stopWatchEffect = watchEffect(selectRef, (newVal, oldVal){});&lt;br/&gt;setTimeout(stopWatch, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;setTimeout(stopWatchEffect, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;watchEffect 更多的用法，请参考&lt;a href=&quot;https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#watcheffect&quot; data-linktype=&quot;2&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;computed&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;computed 的使用如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; num = ref(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; num2 = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; num * &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;num2.value++; &lt;span&gt;// error&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;num2 是一个不可变的 ref 对象，不能直接对它的 value 属性赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;computed 还可以接收一个带有 get 和 set 函数的对象，来创建一个可读写的 ref 对象，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; num3 = computed({&lt;br/&gt; &lt;span&gt;get&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; num.value * &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt; &lt;span&gt;set&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;val&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  num.value = val;&lt;br/&gt; },&lt;br/&gt;});&lt;br/&gt;num3.value = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(num.value, num3.value); &lt;span&gt;// 100 200&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自定义 Hooks&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 的 Composition 之所以这样实现，主要原因就是为了便于代码拆分，降低耦合，我们不妨来实现一个自定义的 hooks。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// page.vue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useCount &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./useCount&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  setup() {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { num, double, plus } = useCount(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { num, double, plus };&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;// useCount.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ref, computed } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; (value) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; num = ref(value);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; double = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; num.value * &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; plus = &lt;span&gt;(&lt;span&gt;val&lt;/span&gt;) =&amp;gt;&lt;/span&gt; num.value + val;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; { num, double, plus };&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;useCount.js 就是一个自定义的 hooks，得益于 Vue3 的全局 API，我们可以轻松做到代码拆分。Vue3 的 setup 聚合了所有的逻辑，容易产生面条代码，合理使用自定义 hooks，可以有效的减少面条代码，提升代码可维护性。并且 Vue3 的 hooks 比 react 更加简单高效，不会多次执行，不受调用顺序影响，不存在闭包陷阱等等，几乎可以没有任何心智负担的使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;新的生命周期钩子&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，相信你对 Vue3 的生命周期已经有一些了解了，我们不妨来做个梳理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.8555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYd6UZwqLYibhHEgWwUKOwaWHHEnnAlRSJkQ8HOALPMGBJiaaDF7rRyyJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 几乎内置了所有的 Vue2 生命周期钩子，也就是说，刚开始升级项目至 Vue3 时，可以直接使用 Vue2 的钩子，方便平滑升级，如上图左下角所示，有两个钩子发生了替换，beforeDestory 被替换成了 beforeUnmount，destoryed 被替换成了 unmounted。完整的钩子对比如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.413533834586466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYDB8JZ8E9Ouc0afFG7jgOVRncMjGFDnUTRNk2iaFWibAicuHIC9M0WggRQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;399&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 setup 外，Vue3 的其他生命周期钩子都添加了 on 前缀，更加规范统一。新的钩子需要在 setup 中使用，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { onMounted } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  setup() {&lt;br/&gt;    onMounted(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;onMounted&quot;&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Tree-Shaking&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 一共开放了 113 个 API，我们可以通过如下方式引用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { ref, reactive, h, onMounted } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 ES6 modules 的引入方式，能够被 AST 静态语法分析感知，从而可以只提取用到的代码片段，最终达到 Tree-Shaking 的效果，这样就使得 Vue3 最终打包出来的包更小，加载更快。据尤大去年 4 月在 B 站的直播：基本的 hello world 项目大小为 13.5kb，Composition API 仅有 11.75kb，包含所有的运行态仅 22.5kb。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Fragment&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 中，Fragment 的引入，解决了组件需要被一个唯一根节点包裹的难题，带来的是 dom 层级的减少，以及渲染性能的提升，某些时候，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- child.vue --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;{{ title }}&lt;span&gt;&amp;lt;/&lt;span&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;{{ subtitle }}&lt;span&gt;&amp;lt;/&lt;span&gt;td&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!-- Vue2中template出现了多个根节点，无法编译通过 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- parent.vue --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;child&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;tr&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;table&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Vue2 中，这意味着我们没办法在 child.vue 的 template 中加入多个 td 节点，多个 td 可以被 tr 包裹，如果 child.vue 根节点替换为 tr，那么就会跟 parent.vue 的 tr 冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的代码，在 Vue3 中就能正确编译通过，这是因为 Vue3 中，组件的 template 被一层不可见的 Fragment 包裹，组件天生支持多个根节点的布局。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Teleport&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Teleport 是 Vue3 新增的组件，即传送门，Teleport 能够在不改变组件内部元素父子关系的情况下，将子元素”传送“到其他节点下加载，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;&quot;width: 100px; height: 100px; overflow: hidden&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;dialog&quot;&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;&quot;width: 500px; height: 400px;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      ...&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dialog 直接挂载在 container 下，超出部分将不可见。加一层 Teleport，我们可以轻松将 dialog 展示出来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;&quot;width: 100px; height: 100px; overflow: hidden&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;teleport&lt;/span&gt; &lt;span&gt;to&lt;/span&gt;=&lt;span&gt;&quot;body&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;dialog&quot;&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;&quot;width: 500px; height: 400px;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        ...&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;teleport&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dialog 依然处于 container 内部，仅仅只是被挂载到 body 上，逻辑关系不变，展示也不会遮挡。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Suspense&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue2 中，我们经常写这样的 loading 效果，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;v-if&lt;/span&gt;=&lt;span&gt;&quot;init&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;list&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;v-else&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      loading~~&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 中，我们可以通过 Suspense 的两个插槽实现以上功能，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;  &amp;lt;div class=&quot;container&quot;&amp;gt;&lt;br/&gt;    &amp;lt;Suspense&amp;gt;&lt;br/&gt;      &amp;lt;template #default&amp;gt;&lt;br/&gt;        &amp;lt;list /&amp;gt;&lt;br/&gt;      &amp;lt;/template&amp;gt;&lt;br/&gt;      &amp;lt;template #fallback&amp;gt;&lt;br/&gt;        loading~&lt;br/&gt;      &amp;lt;/template&amp;gt;&lt;br/&gt;    &amp;lt;/Suspense&amp;gt;&lt;br/&gt;  &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;  import { defineAsyncComponent } &quot;vue&quot;;&lt;br/&gt;  export default {&lt;br/&gt;  components: {&lt;br/&gt;      list: defineAsyncComponent(() =&amp;gt; import(&quot;@/components/list.vue&quot;)),&lt;br/&gt;    },&lt;br/&gt;  };&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue3 知识图谱&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 还包括了一些其他常用更新，限于篇幅，这里先列出来，下篇再讲。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28483920367534454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYcHh11vR2fAaGjFIffwmPz9VruXYqFUGEfaIRlyp6TZ7Dd2tFY5cEoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1306&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，Vue3 带来的更新，远不止这些，为此我梳理了一个 Vue3 的知识图谱，尽可能囊括一些本文未提到的特性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6976744186046512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYUsicEUzz1AibvCfC7utD9mcXewl7gLGI3nx3dibknTM6MXoqa1JXAcH4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1548&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，Vue 不但重写了 diff 算法，还在编译阶段做了很多优化，编译时优化可以通过这个网站看出来：https://vue-next-template-explorer.netlify.app/。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3159163987138264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYS8FYjV7UAhlsbeLgI56GyFEhKshMV4MBCHyicWibTEJ3Y6tna0hIBRVw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2488&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;Vue3 的开放生态&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Monterail 2 月份发布的&lt;a href=&quot;https://www.monterail.com/hubfs/state_of_vue_2021/State_of_vue.js_2021_report_by_Monterail.pdf&quot; data-linktype=&quot;2&quot;&gt;第三版 Vue 生态报告&lt;/a&gt;，Vue 的流行度逐年上升，很多非 web 的可视化领域也可以基于 Vue 开发，特别是 Vue3 的渲染 API 的开放，使得基于 Vue 构建 Canvas、WebGL、小程序等应用更加方便，如下图所示，60 行代码实现一个简单的 Canvas 柱状图：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { createRenderer, h } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; renderer = createRenderer({&lt;br/&gt;  &lt;span&gt;createElement&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;tag&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({ tag }),&lt;br/&gt;  &lt;span&gt;patchProp&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;el, key, prev, next&lt;/span&gt;) =&amp;gt;&lt;/span&gt; { el[key] = next; },&lt;br/&gt;  &lt;span&gt;insert&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;child, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; { parent.nodeType === &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; draw(child) },&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; canvas&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ctx;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; draw = &lt;span&gt;(&lt;span&gt;el, noClear&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!noClear) {&lt;br/&gt;    ctx.clearRect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, canvas.width, canvas.height);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 柱状图绘制逻辑&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (el.tag == &lt;span&gt;&#x27;chart&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { data } = el;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; barWidth = canvas.width / &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; gap = &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; paddingLeft = (data.length * barWidth + (data.length - &lt;span&gt;1&lt;/span&gt;) * gap) / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; paddingBottom = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// x轴&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 柱状图&lt;/span&gt;&lt;br/&gt;    data.forEach(&lt;span&gt;(&lt;span&gt;{ title, count, color }, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; x = paddingLeft + index * (barWidth + gap);&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; y = canvas.height - paddingBottom - count;&lt;br/&gt;      ctx.fillStyle = color;&lt;br/&gt;      ctx.fillRect(x, y, barWidth, count);&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 递归绘制⼦节点&lt;/span&gt;&lt;br/&gt;  el.childs &amp;amp;&amp;amp; el.childs.forEach(&lt;span&gt;&lt;span&gt;child&lt;/span&gt; =&amp;gt;&lt;/span&gt; draw(child, &lt;span&gt;true&lt;/span&gt;));&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; createCanvasApp = &lt;span&gt;(&lt;span&gt;App&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; app = renderer.createApp(App);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { mount } = app;&lt;br/&gt;  app.config.isCustomElement = &lt;span&gt;(&lt;span&gt;tag&lt;/span&gt;) =&amp;gt;&lt;/span&gt; tag === &lt;span&gt;&#x27;chart&#x27;&lt;/span&gt;;&lt;br/&gt;  app.mount = &lt;span&gt;(&lt;span&gt;selector&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    canvas = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;canvas&#x27;&lt;/span&gt;);&lt;br/&gt;    ctx = canvas.getContext(&lt;span&gt;&#x27;2d&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.querySelector(selector).appendChild(canvas);&lt;br/&gt;    mount(canvas);&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; app;&lt;br/&gt;};&lt;br/&gt;createCanvasApp({&lt;br/&gt;  setup() {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; data = [&lt;br/&gt;      { &lt;span&gt;title&lt;/span&gt;: &lt;span&gt;&#x27;数据A&#x27;&lt;/span&gt;, &lt;span&gt;count&lt;/span&gt;: &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;&#x27;brown&#x27;&lt;/span&gt; },&lt;br/&gt;      { &lt;span&gt;title&lt;/span&gt;: &lt;span&gt;&#x27;数据B&#x27;&lt;/span&gt;, &lt;span&gt;count&lt;/span&gt;: &lt;span&gt;300&lt;/span&gt;, &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;&#x27;skyblue&#x27;&lt;/span&gt; },&lt;br/&gt;      { &lt;span&gt;title&lt;/span&gt;: &lt;span&gt;&#x27;数据C&#x27;&lt;/span&gt;, &lt;span&gt;count&lt;/span&gt;: &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;&#x27;gold&#x27;&lt;/span&gt; },&lt;br/&gt;    ];&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; h(&lt;span&gt;&quot;chart&quot;&lt;/span&gt;, { data });&lt;br/&gt;  },&lt;br/&gt;}).mount(&lt;span&gt;&#x27;#app&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4425806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYA97SibHMwAict0Xg0tpLFdWbmVrjpKrVCq0X7autQSoqCL9Tmh59xPTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1550&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vue3 相关资料&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;视频号最新视频&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAfHIIaulGzAAAAAstQy6ubaLX4KHWvLEZgBPE4KMcEFpcQdv_zNPgMItlx2dyHmW-RXxsIw4FOqkf&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=RBfjicXSHKCOONJnTbRmmlD8cOQPXE48ibPICxFGXst1IjibzlOibCa6oFLyuhl6qwwSemWicHSoFFb1Uoc3mEnic6KYJaCAxJWDP7QibS7XDpHU61mkWw1zLFoHmlnaxjZaQXFvYUXibX8KPHibvcG31njrRWyfuumWSDzkvtXDYuOpDsTc&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=90456e328e0cbd5d8835352dbe9ddf8a&amp;amp;token=x5Y29zUxcibBfSvBFHRvY6iasmvTibvp8lc324UC4n0icUIyibadicnmIfH3qANS3Q5Od0&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;你有多久没有好好读书了？世界读书日，用数据分析告诉你豆瓣TOP250值得读的书 #来视频号阅世界 #世界读书日 #读书 #程序员  @微信时刻 @微信创作者&quot; data-nonceid=&quot;2837744770326417995&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5月28-29日&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;QECon全球软件质量&amp;amp;效能大会&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;欢迎关注&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.89375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatibbakfqIMjTiazIKUavqvzYjng1CkxGLZgiaXxltofEXN7L5icYfiaMQ9ykia9SZKtDqmv5riaibUOotdAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3dad64b2daba3f925e2dccb3cb3f25f</guid>
<title>遇到的加密算法</title>
<link>https://toutiao.io/k/ifrjp9y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;post&quot;&gt;
&lt;p&gt;最近开发项目，遇到了各种见过没见过的算法。总结整理一下。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;aes-算法&quot;&gt;AES 算法&lt;/h2&gt;

&lt;p&gt;AES 是对称加密算法，也就是用相同的秘钥加密和解密。它有这些特点：&lt;/p&gt;

&lt;p&gt;1、是分组加密，每个加密块大小为 128 位，即 16 个字节。&lt;/p&gt;

&lt;p&gt;2、秘钥是 128/192/256 位。秘钥一般写为十六进制的 hex 格式，128 位秘钥就是 32 位的 hexcode。进行运算时需要将 hexcode（string 类型） 变为二进制字节流（char[16]类型）。&lt;/p&gt;

&lt;p&gt;3、AES 有四种加密方式，常用的有 ECB 模式和 CBC 模式。&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;ecb-模式&quot;&gt;ECB 模式&lt;/h3&gt;

&lt;p&gt;ECB 指电子密码本模式 Electronic codebook。&lt;/p&gt;

&lt;p&gt;AES 是分组加密，以 16 个字节为一组，如果加密数据最后一个组不够 16 个字节，就需要填充为 16 个字节。这个填充方式就叫 padding。padding 方式有 zeropadding/pkcs5padding/pkcs7padding。&lt;/p&gt;

&lt;p&gt;ECB 是最简单的 AES 算法，用秘钥分别对填充后的分组数据进行加密得到密文。所以密文和明文的长度成正比。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/encrpt-algorithm-1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用 OpenSSL 库的 API 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#define COMM_AES_BLOCK_SIZE 16

int AES_ECBEncrypt(const char * sSource, const int iSize,
const char * sKey, int iKeySize, std::string * poResult)
{
poResult-&amp;gt;clear();
int padding = COMM_AES_BLOCK_SIZE - iSize % COMM_AES_BLOCK_SIZE;

char * tmp = (char*)malloc(iSize + padding);
memcpy(tmp, sSource, iSize);
memset(tmp + iSize, padding, padding);
poResult-&amp;gt;reserve( iSize + padding);
unsigned char key[COMM_AES_BLOCK_SIZE] = {0};
memcpy(key, sKey, iKeySize &amp;gt; COMM_AES_BLOCK_SIZE 
? COMM_AES_BLOCK_SIZE : iKeySize );

AES_KEY aesKey;
AES_set_encrypt_key(key, 8 * COMM_AES_BLOCK_SIZE, &amp;amp;aesKey);
unsigned char out[ COMM_AES_BLOCK_SIZE ] = { 0 };
for (int i = 0; i &amp;lt; iSize + padding; i += COMM_AES_BLOCK_SIZE) {
AES_ecb_encrypt((unsigned char*)tmp + i, out, &amp;amp;aesKey,
AES_ENCRYPT);
poResult-&amp;gt;append((char*)out, COMM_AES_BLOCK_SIZE);
}
free(tmp);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;cbc-模式&quot;&gt;CBC 模式&lt;/h3&gt;

&lt;p&gt;CBC 指密码分组链接模式 Cipher-block chaining。&lt;/p&gt;

&lt;p&gt;CBC 相比 ECB 会复杂一些，它将上一次加密得到的结果与本次的数据块异或之后再进行加密。这样还需要一个初始的异或数据，叫做初始化向量 IV。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/encrpt-algorithm-2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用 OpenSSL 库的 API 如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static const int COMM_AES_BLOCK_SIZE = 16;
static const int COMM_AES_IV_SIZE = 16;
static const int COMM_AES_KEY_SIZE = 16;
static const int COMM_AES_PADDING_SIZE = 16;

int AES_CBCEncrypt( const char * sSource, const int iSize,
const char * sKey, int iKeySize, std::string * poResult )
{

poResult-&amp;gt;clear();
int padding = COMM_AES_PADDING_SIZE - iSize % COMM_AES_PADDING_SIZE;

char * tmp = (char*)malloc( iSize + padding );
memcpy( tmp, sSource, iSize );
memset( tmp + iSize, padding, padding );

unsigned char * out = (unsigned char*)malloc( iSize + padding );

unsigned char key[ COMM_AES_KEY_SIZE ] = { 0 };
unsigned char iv[ COMM_AES_IV_SIZE ] = { 0 };
memcpy(key, sKey, COMM_AES_KEY_SIZE);
memcpy(iv,&quot;\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30\x30 /
\x30\x30\x30\x30\x30&quot;, 16); // 这里按照约定设置 

AES_KEY aesKey;
AES_set_encrypt_key( key, 8 * COMM_AES_BLOCK_SIZE, &amp;amp;aesKey );
AES_cbc_encrypt((unsigned char *)tmp, out, iSize + padding, 
&amp;amp;aesKey, iv, AES_ENCRYPT);

poResult-&amp;gt;append((char*)out, iSize + padding);
free( tmp );
free( out );
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Java 的示例代码见 &lt;a href=&quot;https://github.com/Huangtuzhi/code-gist/tree/master/Java/aes-encoder&quot;&gt;aes-encoder&lt;/a&gt;。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;银行通用-mac-加密算法&quot;&gt;银行通用 MAC 加密算法&lt;/h2&gt;

&lt;p&gt;银行 ATM 通信经常使用 MAC 加密算法来当签名，它们会使用加密机来生成这个签名。这次遇到的机构使用卫士通 SJL05 型金融数据加密机。而我们使用软加密的方式来模拟加密机进行加密。&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;加密机原理&quot;&gt;加密机原理&lt;/h3&gt;

&lt;p&gt;加密机有两个秘钥：主秘钥和工作秘钥。我理解的加密机工作流程是这样的：用户任意输入一个工作秘钥 A，加密机对 A 使用主秘钥 B 进行 ECB 加密得到 C（PMAK），然后对 C 进行 3DES 加密得到 D。D 会作为和加密机通信的秘钥 MAK，作为通信报文字段。&lt;/p&gt;

&lt;p&gt;因此，软加密需要用加密机主秘钥 ECB 加密工作秘钥，得到明文加密秘钥（PMAK）。即软加密 MAC 算法中输入的秘钥。&lt;/p&gt;

&lt;hr/&gt;

&lt;h3 id=&quot;mac-算法&quot;&gt;MAC 算法&lt;/h3&gt;

&lt;p&gt;1、将需要加密的数据按照 8 个字节分组（不满 8 个字节则进行填充），然后两两异或，最终得到 8 字节的数据&lt;/p&gt;

&lt;p&gt;2、将 8 字节的数据转换为 16 长度的 hex 十六进制数据&lt;/p&gt;

&lt;p&gt;3、对十六进制数据进行 CBC 加密得到最终 MAC&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.poxiao.me/p/advanced-encryption-standard-and-block-cipher-mode/&quot;&gt;AES 的工作模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wenku.baidu.com/view/5260ad7602768e9951e73876.html&quot;&gt;SJL05金融数据加密机程序员手册&lt;/a&gt;&lt;/p&gt;
                          
&lt;/section&gt;



&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>