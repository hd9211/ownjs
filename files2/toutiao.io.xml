<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bb73838b8993b5616875182294f4d7d7</guid>
<title>新生代农民工，必读！</title>
<link>https://toutiao.io/k/wswq9zl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;昨天，人社部发布了《2020 年北京市外来新生代农民工监测报告》，引发网民热议。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6028084252758275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MjrqyjUCqickLUYno7Qn1LicPXNe9ZV3HFUYEGptZq1a6rmYx5Ynj9vGvk8II5NSRn8sqsAuF9vPoddKl8BGCGTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;span&gt;之所以引发网民热议，是在于软件和信息技术服务业一直是个备受青睐的行业，和传统认知中的农民工似乎完全不搭边。&lt;span&gt;但该报告似乎让 “码农” 这一称呼从软件和信息技术服务业从业者的自我调侃变为官方认证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报告指出，北京新生代农民工占比达到 50.1%，男性占比高于女性。其中，就业集中于劳动密集型行业，从事信息传输、软件和信息技术服务业的新生代农民工占比大幅提高。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然官宣了，那&lt;span&gt;属于咱 “新生代农民工” 的《码农周刊》&lt;/span&gt;，自然要推荐下哦～&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8Byw4xNoV6O2YGutfKmQLKuMZEIhBJF6MrQvoShfIAT6u3dXs6VZRzwSa2eT9jcekfaYuaOD6Hhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e37f00dd3226f95d1aceed8cc96c77b</guid>
<title>超详细 Java 15 新功能介绍</title>
<link>https://toutiao.io/k/k6zujsr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4lfok2icUkibTKFUljxMwu3Z5GaOxz5yzbBjWdBJiaudPIvOYdChyHnje5kAwy8MGp6vWvXJSVqYesEeLZYPEnQfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 在 2020 年 9 月发布，虽然不是长久支持版本，但是也带来了 14 个新功能，这些新功能中有不少是十分实用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 官方下载：https://jdk.java.net/archive/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 官方文档：https://openjdk.java.net/projects/jdk/15/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 新功能：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;JEP&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;JEP 339&lt;/td&gt;&lt;td&gt;爱德华曲线算法（EdDSA）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 360&lt;/td&gt;&lt;td&gt;Sealed Classes（密封类）预览&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 371&lt;/td&gt;&lt;td&gt;Hidden Classes（隐藏类）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 372&lt;/td&gt;&lt;td&gt;移除 Nashorn JavaScript 引擎&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 373&lt;/td&gt;&lt;td&gt;重新实现 DatagramSocket APII&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 374&lt;/td&gt;&lt;td&gt;禁用和废弃偏向锁（Biased Locking）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 375&lt;/td&gt;&lt;td&gt;instanceof 类型匹配  (二次预览)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 377&lt;/td&gt;&lt;td&gt;ZGC: 可扩展低延迟垃圾收集器（正式发布）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 378&lt;/td&gt;&lt;td&gt;文本块&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 379&lt;/td&gt;&lt;td&gt;Shenandoah: 低停顿时间的垃圾收集器&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 381&lt;/td&gt;&lt;td&gt;删除 Solaris 和 SPARC 端口&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 383&lt;/td&gt;&lt;td&gt;外部内存访问 API（第二个孵化器）)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 384&lt;/td&gt;&lt;td&gt;Records (二次预览)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JEP 385&lt;/td&gt;&lt;td&gt;废弃 RMI 激活机制&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP339 爱德华曲线算法（EdDSA）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 15 中增加了一个新的密码学算法，爱德华曲线算法（EdDSA）签名算法。它是由 Schnorr 算法发展而来，在 RFC8032 中被定义实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.nio.charset.StandardCharsets;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.InvalidKeyException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.KeyPair;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.KeyPairGenerator;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.NoSuchAlgorithmException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.Signature;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.security.SignatureException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Base64;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JEP339&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NoSuchAlgorithmException, InvalidKeyException, SignatureException &lt;/span&gt;{&lt;br/&gt;        KeyPairGenerator kpg = KeyPairGenerator.getInstance(&lt;span&gt;&quot;Ed25519&quot;&lt;/span&gt;);&lt;br/&gt;        KeyPair kp = kpg.generateKeyPair();&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] msg = &lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;.getBytes(StandardCharsets.UTF_8);&lt;br/&gt;        Signature sig = Signature.getInstance(&lt;span&gt;&quot;Ed25519&quot;&lt;/span&gt;);&lt;br/&gt;        sig.initSign(kp.getPrivate());&lt;br/&gt;        sig.update(msg);&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] s = sig.sign();&lt;br/&gt;        System.out.println(Base64.getEncoder().encodeToString(s));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;VXlpxapU+LSWjVQ0QNJvdpUh6VI6PjSwOQ2pHu65bCfnLR13OyWKunlc9rc+7SMxCh2Mnqf7TmC/iOG8oimbAw==&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP360：Sealed Classes（密封类）预览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 &lt;code&gt;final&lt;/code&gt; 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 &lt;code&gt;sealed&lt;/code&gt; 类，被 &lt;code&gt;sealed&lt;/code&gt; 修饰的类可以指定子类。这样这个类就只能被指定的类继承。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且 &lt;code&gt;sealed&lt;/code&gt; 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 &lt;code&gt;final&lt;/code&gt;、&lt;code&gt;sealed&lt;/code&gt;、&lt;code&gt;non-sealed&lt;/code&gt;  三者之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例：犬类（Dog）只能被牧羊犬（Collie）和田园犬（TuGou）继承，使用 &lt;code&gt;sealed&lt;/code&gt; 关键字。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;  sealed &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;Collie&lt;/span&gt;, &lt;span&gt;TuGou&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;牧羊犬（Collie）只能被边境牧羊犬（BorderCollie）继承。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 牧羊犬&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; sealed &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Collie&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;BorderCollie&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;边境牧羊犬（BorderCollie）不能被继承，使用 &lt;code&gt;final&lt;/code&gt; 关键字。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BorderCollie&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Collie&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;田园犬（ToGou）可以被任意继承，使用 &lt;code&gt;non-sealed&lt;/code&gt; 关键字。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; niulang&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; non-sealed &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TuGou&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP371：Hidden Classes（隐藏类）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性让开发者可以引入一个无法被其他地方发现使用，且类的生命周期有限的类。这对运行时动态生成类的使用方式十分有利，可以减少内存占用，下面是一个使用示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JEP371Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;lookup&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把类 &lt;code&gt;JEP371Test&lt;/code&gt; 编译后的 Class 转换成 &lt;code&gt;Base64&lt;/code&gt;，然后使用 Java 15 新特性加载调用类中的 &lt;code&gt;lookup&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.invoke.MethodHandle;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.invoke.MethodHandles;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.invoke.MethodType;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Base64;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JEP371&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String CLASS_INFO = &lt;span&gt;&quot;yv66vgAAADQAFAoAAgADBwAEDAAFAAYBABBqYXZhL2xhbmcvT2JqZWN0AQAGPGluaXQ+AQADKClWCAAIAQAOd3d3LndkYnl0ZS5jb20HAAoBABVjb20vd2RieXRlL0pFUDM3MVRlc3QBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAF0xjb20vd2RieXRlL0pFUDM3MVRlc3Q7AQAGbG9va3VwAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAApTb3VyY2VGaWxlAQAPSkVQMzcxVGVzdC5qYXZhACEACQACAAAAAAACAAEABQAGAAEACwAAAC8AAQABAAAABSq3AAGxAAAAAgAMAAAABgABAAAAAwANAAAADAABAAAABQAOAA8AAAAJABAAEQABAAsAAAAbAAEAAAAAAAMSB7AAAAABAAwAAAAGAAEAAAAEAAEAEgAAAAIAEw==&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] classInBytes = Base64.getDecoder().decode(CLASS_INFO);&lt;br/&gt;        Class&amp;lt;?&amp;gt; proxy = MethodHandles.lookup()&lt;br/&gt;            .defineHiddenClass(classInBytes, &lt;span&gt;true&lt;/span&gt;, MethodHandles.Lookup.ClassOption.NESTMATE)&lt;br/&gt;            .lookupClass();&lt;br/&gt;&lt;br/&gt;        System.out.println(proxy.getName());&lt;br/&gt;        MethodHandle mh = MethodHandles.lookup().findStatic(proxy, &lt;span&gt;&quot;lookup&quot;&lt;/span&gt;, MethodType.methodType(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;        String result = (String) mh.invokeExact();&lt;br/&gt;        System.out.println(result);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;com.wdbyte.JEP371Test/0x0000000800c01800&lt;br/&gt;www.wdbyte.com&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP372：移除 Nashorn JavaScript 引擎&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nashorn JavaScript 引擎在 Java 8 中被引入，在 Java 11 中被标记为废弃。由于 ECMAScript 语言发展很快，维护  Nashorn JavaScript 的成本过于高昂，在 Java 15 中被彻底删除。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Nashorn JavaScript Engine，Deprecate the Nashorn JavaScript Engine&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP373：重新实现 DatagramSocket API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 13 中重新实现了旧的 Socket API，在介绍 Java 13 时还有一部分做了这方面的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，Java 15 重新实现了遗留的 &lt;code&gt;DatagramSocket&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Java 13 新功能介绍&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP374：禁用和废弃偏向锁（Biased Locking）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前，JVM 在处理同步操作，如使用 &lt;code&gt;synchronized&lt;/code&gt; 同步时，有一套锁的升级机制，其中有一个锁机制就是偏向锁。然而通过目前的 Java 开发环境来看，使用这些被 &lt;code&gt;synchronized&lt;/code&gt; 同步的类的机会并不多，如开发者更喜欢使用 &lt;code&gt;HashMap&lt;/code&gt; 或者 &lt;code&gt;ArrayList&lt;/code&gt; 而非 &lt;code&gt;HashTable&lt;/code&gt; 和 &lt;code&gt;Vector&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使换个角度，当初使用偏向锁是为了提高性能，如今看来性能提升的程度和使用次数都不太有用。而偏向锁的引入增加了 JVM 的复杂性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以现在偏向锁被默认禁用，在不久的将来将会彻底删除，对于 Java 15，我们仍然可以使用&lt;code&gt;-XX:+UseBiasedLocking&lt;/code&gt;  启用偏向锁定，但它会提示 这是一个已弃用的 API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP375：instanceof 类型匹配  (二次预览)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;instanceof&lt;/code&gt; 类型匹配在 Java 14 中已经改进，这次仅仅再次预览，没有任何改动，用于接受更多的使用反馈。这个特性在 Java 16 中成为正式特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前，使用 &lt;code&gt;instanceof&lt;/code&gt; 进行类型判断之后，需要进行对象类型转换后才能使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Java14BeaforInstanceof&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt; ArrayList) {&lt;br/&gt;            ArrayList list = (ArrayList)obj;&lt;br/&gt;            list.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(obj);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 Java 14 中，可以在判断类型时指定变量名称进行类型转换，方便了使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Java14Instanceof&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt; ArrayList list) {&lt;br/&gt;            list.add(&lt;span&gt;&quot;www.wdbyte.com&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(obj);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在使用 &lt;code&gt;instanceof&lt;/code&gt; 判断类型成立后，会自动强制转换类型为指定类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[www.wdbyte.com]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Java 14 新功能介绍&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP377：ZGC: 可扩展低延迟垃圾收集器（正式发布）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZGC 垃圾收集器在 Java 11 中被引入，但是因为收集器的复杂性，当初决定逐渐引入。然后不断的听取用户的反馈建议修复问题。而现在，已经很久没有收到用户的问题反馈了，ZGC 是时候投入正式使用阶段了。所以在 Java 15 中 ZGC 正式发布，可以使用下面的参数启用 ZGC。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; java -XX:+UseZGC className&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP378：文本块&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文本块在 Java 12 JEP 326 原始字符串文字 中引入，在 Java 13 JEP 355：文本块（预览） 中开始预览，在 Java 14 JEP 368：文本块（第二次预览），而现在，在 Java 15 ，文本块是正式的功能特性了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String content = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;        {&lt;br/&gt;            &quot;&lt;/span&gt;upperSummary&lt;span&gt;&quot;: null,\&lt;br/&gt;            &quot;&lt;/span&gt;sensitiveTypeList&lt;span&gt;&quot;: null,&lt;br/&gt;            &quot;&lt;/span&gt;gmtModified&lt;span&gt;&quot;: &quot;&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;\s10:&lt;span&gt;50&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt;&lt;span&gt;&quot;,&lt;br/&gt;        }&lt;br/&gt;         &quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(content);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;扩展阅读：Java 14 新功能介绍- JEP368 文本块&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP379：Shenandoah: 低停顿时间的垃圾收集器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Shenandoah 垃圾收集器在 Java 12 中开始引入，Java 15 中成为了正式功能的一部分，可以使用下面的参数启用 Shenandoah 垃圾收集器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -XX:+UseShenandoahGC&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 openJDK 15 中默认是没有 Shenandoah 收集器，想要使用此功能可以下载 AdoptOpenJDK。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么 openJDK 中没有 Shenandoah 垃圾收集器？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Shenandoah 是一个高性能、低暂停时间的垃圾收集器，它是 Red Hat 主导的项目。当 Red Hat 第一次提议将 Shenandoah 贡献给 OpenJDK 时，Oracle 明确表示不想支持它，OpenJDK 作为一个免费软件，不想支持 Red Hat 的 Shenandoah 完全没有问题。&lt;/p&gt;&lt;p&gt;最后 Red Hat 选择和 Oracle 合作设计一个真正干净的可插拔垃圾收集器接口，允许任何人轻松选择垃圾收集器以包含在他们的构建中。最终 Shenandoah 进入了 JDK 12，但是没有构建进 OpenJDK。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JEP384：Records（二次预览）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 14 中引入了 Record 类，Java 15 中对 Record 进行了增强。使它可以支持密封类型、Record 注解以及相关的反射 API 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例：Record 支持密封（sealed）类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.wdbyte;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; www.wdbyte.com&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; sealed &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;DataBase&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;DataBaseSelect&lt;/span&gt;, &lt;span&gt;DataBaseUpdate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; record &lt;span&gt;DataBaseSelect&lt;/span&gt;&lt;span&gt;(@Deprecated String table, String sql)&lt;/span&gt; implements DataBase &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; record &lt;span&gt;DataBaseUpdate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; implements DataBase &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;java.lang.Class&lt;/code&gt; 增加了两个公共方法用于获取 Record 类信息：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;RecordComponent[] getRecordComponents()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;boolean isRecord()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他更新&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JEP 381：删除 Solaris 和 SPARC 端口&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 14 JEP 362弃用了 Solaris/SPARC、Solaris/x64 和 Linux/SPARC 端口，现在它在 Java 15 中被正式删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JEP 383：外部内存访问 API（第二个孵化器）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JEP 385：废弃 RMI 激活机制&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只是废弃 RMI 激活机制，不影响 RMI 其他功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://openjdk.java.net/projects/jdk/15/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://docs.oracle.com/en/java/javase/14/docs/specs/rmi/activation.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://mkyong.com/java/what-is-new-in-java-15/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75243f0bec6344a0dc025214a0931220</guid>
<title>分布式事务之最终一致性实现方案</title>
<link>https://toutiao.io/k/1gsejz4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文章目录：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;什么是最终一致性？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实现方案&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;小结&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;推荐阅读&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这篇文章是&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448836321&amp;amp;idx=1&amp;amp;sn=7c4993c3b499625d14fe9449ff91529c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《关于分布式事务的理解》&lt;/a&gt;&lt;span&gt;的后续篇：&lt;/span&gt;&lt;span&gt;分布式事务之最终一致性实现方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是那个电商需求，一个订单支付完成后的业务场景，有如下操作：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;415&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7435897435897436&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhSicnpicn59dDtibyCkEYjl8kFGibfrKlju6bASkjocu56fhYqiaHDib2jTH99b1NyeQia0XT8mthaib3lEMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;更改订单的状态为 “已支付”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扣减商品库存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给会员增加积分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建出库单通知仓库发货&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们使用 &lt;strong&gt;最终一致性方案&lt;/strong&gt; 去实现它。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是最终一致性？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字面上看就是 &lt;strong&gt;保证数据最后的一致性&lt;/strong&gt; 就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了减少系统代价，如果中间节点处理失败，其他节点一般不会自动回滚，而是通过重试机制和人工参与的方式对失败数据进行处理，从而来保证数据最后的一致性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现方案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 本地消息表 + 后台任务 + 消息队列 + 接口幂等性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本地消息表&lt;/strong&gt;：在对应业务数据库中增加的本地消息表，这张表存储业务产生的消息，通过 &lt;strong&gt;本地事务&lt;/strong&gt; 保证业务数据和消息数据的一致性，比如：&lt;code&gt;msg_published&lt;/code&gt; 和 &lt;code&gt;msg_received&lt;/code&gt; 表示发布消息表和接收消息表，在消息表中会有一个状态来标识业务是否执行成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;后台任务&lt;/strong&gt;：当消息表中有执行失败的业务信息时，后台任务就会按照配置的重试策略进行重试，例如重试策略为当发送和消费消息的过程中失败会立即重试 3 次，在 3 次以后将进入重试轮询；重试将在发送和消费消息失败的 4分钟后 开始，这是为了避免设置消息状态延迟导致可能出现的问题；后续就会每隔 1 分钟之后重试一次，默认的最高重试次数为 50 次，当达到 50 次时，就不会重试了，通过发邮件/微信/钉钉/短信的方式通知人工去处理，通知时需要考虑消息降噪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：跨服务之间的调用使用消息队列，来实现服务解耦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口幂等性&lt;/strong&gt;：接口需要保证同一操作发起的一次请求或者多次请求的结果必须是一致的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐一个 &lt;code&gt;C#&lt;/code&gt; 开源项目 &lt;span&gt;CAP&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，大家可以参考一下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;213&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.3929219600725953&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhQ9NSDpYsicicjlMwJWiaSmNxxjTNb4TCTHggibrf32wDRecNCUoItibm6cvw2zUOEK8nLJh4XpibYfte8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目只支持 &lt;code&gt;C#&lt;/code&gt; 代码去集成，如果是其他语言可以参考其设计思路，然后进行一个简单的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文纯属抛砖引玉，有问题，欢迎批评指正。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你有更好的实现方案吗？欢迎留言~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;CAP: &lt;em&gt;https://github.com/dotnetcore/CAP&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NDM4MDIwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/go9jpG3BuhQHrM0sshKxdaibyDNjXooZvnwwy0yRjdhlXrtVUkJSvQib4Ppwib1v5HucaRc8WPtgvhPBicMeiadAv9Q/0?wx_fmt=png&quot; data-nickname=&quot;新亮笔记&quot; data-alias=&quot;XinLiangTalk&quot; data-signature=&quot;程序猿的打怪升级之路。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;184&quot; data-backw=&quot;334&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/go9jpG3BuhSP7wibS4BHtlu4hduFYq8VbSAgRic8ib6hdd6qTRGxYSic7UFF9yPyGd4pGUw1XicibFRlGHBe9RJ09Smw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c42db020c8936200a2d0e4c9e269e16b</guid>
<title>3 种堆内缓存算法，赠源码和设计思路</title>
<link>https://toutiao.io/k/x1rr1o7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说计算机系统里，什么技术把&lt;code&gt;tradeoff&lt;/code&gt;体现的淋漓尽致，那肯定是缓存无疑。为了协调高速部件和低速部件的速度差异，加入一个中间缓存层，是解决这种冲突最有效的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，JVM堆内缓存是缓存体系中重要的一环，最常用的有&lt;code&gt;FIFO&lt;/code&gt;/&lt;code&gt;LRU&lt;/code&gt;/&lt;code&gt;LFU&lt;/code&gt;三种算法。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;FIFO&lt;/code&gt;是简单的队列，先进先出。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LRU&lt;/code&gt;是最近最少使用，优先移除最久未使用的数据。是&lt;code&gt;时间维度&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LFU&lt;/code&gt;是最近最不常用，优先移除访问次数最少的数据。是&lt;code&gt;统计维度&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于过期也是缓存的一个重要特点。所有在设计这三种缓存算法时，需要额外的存储空间去存储这个过期时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下将讨论这三种缓存算法的操作和设计要点，但&lt;strong&gt;暂未考虑高并发环境&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FIFO&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;先进先出，如果缓存容量满，则优先移出最早加入缓存的数据；其内部可以使用队列实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLpVTwWpcibcLyIic2XCmUCepvs4FzhOkKmickcsnnAuj6ibuUCib6IrtVp3WmZ5uvbrTuPq099wncPtOEw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;fifo&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;操作&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Object get(key)&lt;/strong&gt; ：获取保存的数据，如果数据不存在或者已经过期，则返回null。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;void put(key,value,expireTime)&lt;/strong&gt;：加入缓存。 无论此key是否已存在，均作为新key处理（移除旧key）；如果空间不足，则移除已过期的key，如果没有，则移除最早加入缓存的key。过期时间未指定，则表示永不自动过期。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;注意&lt;/strong&gt; ，我们允许key是有过期时间的，这一点与普通的FIFO有所区别，所以在设计此题时需要注意。（也是面试考察点，偏设计而非算法）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通的FIFO或许大家都能很简单的写出，增加了过期时间的考虑之后，在设计时需要多考虑。如下示例，为暂未考虑并发环境的FIFO设计。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设计思路&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）用普通的hashMap保存缓存数据。&lt;br/&gt;2）需要额外的map用来保存key的过期特性，例子中使用了TreeMap，将“剩余存活时间”作为key，利用TreeMap的排序特性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FIFOCache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//按照访问时间排序,保存所有key-value&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String,Value&amp;gt; CACHE = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//过期数据，只保存有过期时间的key&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//暂不考虑并发，我们认为同一个时间内没有重复的key，如果改造的话，可以将value换成set&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; TreeMap&amp;lt;Long, String&amp;gt; EXPIRED = &lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; capacity;&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;FIFOCache&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.capacity = capacity;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;br/&gt;        Value value = CACHE.get(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;//如果不包含过期时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; expired = value.expired;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; now = System.nanoTime();&lt;br/&gt;        &lt;span&gt;//已过期&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (expired &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; expired &amp;lt;= now) {&lt;br/&gt;            CACHE.remove(key);&lt;br/&gt;            EXPIRED.remove(expired);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value.value;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(String key,Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        put(key,value,-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(String key,Object value,&lt;span&gt;int&lt;/span&gt; seconds)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//如果容量不足，移除过期数据&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (capacity &amp;lt; CACHE.size()) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; now = System.nanoTime();&lt;br/&gt;            &lt;span&gt;//有过期的,全部移除&lt;/span&gt;&lt;br/&gt;            Iterator&amp;lt;Long&amp;gt; iterator = EXPIRED.keySet().iterator();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (iterator.hasNext()) {&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; _key = iterator.next();&lt;br/&gt;                &lt;span&gt;//如果已过期，或者容量仍然溢出，则删除&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (_key &amp;gt; now) {&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//一次移除所有过期key&lt;/span&gt;&lt;br/&gt;                String _value = EXPIRED.get(_key);&lt;br/&gt;                CACHE.remove(_value);&lt;br/&gt;                iterator.remove();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;//如果仍然容量不足，则移除最早访问的数据&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (capacity &amp;lt; CACHE.size()) {&lt;br/&gt;            Iterator&amp;lt;String&amp;gt; iterator = CACHE.keySet().iterator();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (iterator.hasNext() &amp;amp;&amp;amp; capacity &amp;lt; CACHE.size()) {&lt;br/&gt;                String _key = iterator.next();&lt;br/&gt;                Value _value = CACHE.get(_key);&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; expired = _value.expired;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (expired &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    EXPIRED.remove(expired);&lt;br/&gt;                }&lt;br/&gt;                iterator.remove();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;//如果此key已存在,移除旧数据&lt;/span&gt;&lt;br/&gt;        Value current = CACHE.remove(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (current != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; current.expired &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            EXPIRED.remove(current.expired);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//如果指定了过期时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(seconds &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; expireTime = expiredTime(seconds);&lt;br/&gt;            EXPIRED.put(expireTime,key);&lt;br/&gt;            CACHE.put(key,&lt;span&gt;new&lt;/span&gt; Value(expireTime,value));&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            CACHE.put(key,&lt;span&gt;new&lt;/span&gt; Value(-&lt;span&gt;1&lt;/span&gt;,value));&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;expiredTime&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; expired)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; System.nanoTime() + TimeUnit.SECONDS.toNanos(expired);&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Value value = CACHE.remove(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(value == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; expired = value.expired;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (expired &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            EXPIRED.remove(expired);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Value&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; expired; &lt;span&gt;//过期时间,纳秒&lt;/span&gt;&lt;br/&gt;        Object value;&lt;br/&gt;        Value(&lt;span&gt;long&lt;/span&gt; expired,Object value) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.expired = expired;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.value = value;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LRU&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;least recently used，最近最少使用，是目前最常用的缓存算法和设计方案之一，其移除策略为“当缓存（页）满时，优先移除最近最久未使用的数据”，优点是易于设计和使用，适用场景广泛。算法可以参考leetcode 146 （LRU Cache）。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;操作&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Object get(key)&lt;/strong&gt;：从cache中获取key对应的数据，如果此key已过期，移除此key，并则返回null。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;void put(key,value,expired)&lt;/strong&gt;：设置k-v，如果容量不足，则根据LRU置换算法移除“最久未被使用的key”。 需要注意，根据LRU优先移除已过期的keys，如果没有，则根据LRU移除未过期的key。如果未设定过期时间，则认为永不自动过期。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里的设计关键是过期时间特性，这与常规的LRU有所不同。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设计思路&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LRU的基础算法，需要了解；每次put、get时需要更新key对应的访问时间，我们需要一个数据结构能够保存key最近的访问时间且能够排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;既然包含过期时间特性，那么带有过期时间的key需要额外的数据结构保存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暂时不考虑并发操作；尽量兼顾空间复杂度和时间复杂度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此题仍然偏向于设计题，而非纯粹的算法题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此题代码与FIFO基本相同，唯一不同点为get()方法，对于LRU而言，get方法需要重设访问时间（即调整所在cache中顺序）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt;&lt;br/&gt;    Value value = CACHE.get(key);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//如果不包含过期时间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; expired = value.expired;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; now = System.nanoTime();&lt;br/&gt;    &lt;span&gt;//已过期&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (expired &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; expired &amp;lt;= now) {&lt;br/&gt;        CACHE.remove(key);&lt;br/&gt;        EXPIRED.remove(expired);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//相对于FIFO，增加顺序重置&lt;/span&gt;&lt;br/&gt;    CACHE.remove(key);&lt;br/&gt;    CACHE.put(key,value);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; value.value;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;LFU&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近最不常用，当缓存容量满时，移除 &lt;strong&gt;访问次数&lt;/strong&gt; 最少的元素，如果访问次数相同的元素有多个，则移除最久访问的那个。设计要求参见leetcode 460（ LFU Cache）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LFUCache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//主要容器，用于保存k-v&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; keyToValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//记录每个k被访问的次数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; keyToCount = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//访问相同次数的key列表，按照访问次数排序，value为相同访问次数到key列表。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; TreeMap&amp;lt;Integer, LinkedHashSet&amp;lt;String&amp;gt;&amp;gt; countToLRUKeys = &lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; capacity;&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LFUCache&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.capacity = capacity;&lt;br/&gt;        &lt;span&gt;//初始化，默认访问1次，主要是解决下文&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!keyToValue.containsKey(key)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        touch(key);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; keyToValue.get(key);&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 如果一个key被访问，应该将其访问次数调整。&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key&lt;br/&gt;     */&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;touch&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = keyToCount.get(key);&lt;br/&gt;        keyToCount.put(key, count + &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//访问次数增加&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//从原有访问次数统计列表中移除&lt;/span&gt;&lt;br/&gt;        countToLRUKeys.get(count).remove(key);&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;//如果符合最少调用次数到key统计列表为空，则移除此调用次数到统计&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (countToLRUKeys.get(count).size() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            countToLRUKeys.remove(count);&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;//然后将此key的统计信息加入到管理列表中&lt;/span&gt;&lt;br/&gt;        LinkedHashSet&amp;lt;String&amp;gt; countKeys = countToLRUKeys.get(count + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (countKeys == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            countKeys = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;();&lt;br/&gt;            countToLRUKeys.put(count + &lt;span&gt;1&lt;/span&gt;,countKeys);&lt;br/&gt;        }&lt;br/&gt;        countKeys.add(key);&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(String key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (capacity &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (keyToValue.containsKey(key)) {&lt;br/&gt;            keyToValue.put(key, value);&lt;br/&gt;            touch(key);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//容量超额之后，移除访问次数最少的元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (keyToValue.size() &amp;gt;= capacity) {&lt;br/&gt;            Map.Entry&amp;lt;Integer,LinkedHashSet&amp;lt;String&amp;gt;&amp;gt; entry = countToLRUKeys.firstEntry();&lt;br/&gt;            Iterator&amp;lt;String&amp;gt; it = entry.getValue().iterator();&lt;br/&gt;            String evictKey = it.next();&lt;br/&gt;            it.remove();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!it.hasNext()) {&lt;br/&gt;                countToLRUKeys.remove(entry.getKey());&lt;br/&gt;            }&lt;br/&gt;            keyToCount.remove(evictKey);&lt;br/&gt;            keyToValue.remove(evictKey);&lt;br/&gt;  &lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        keyToValue.put(key, value);&lt;br/&gt;        keyToCount.put(key, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        LinkedHashSet&amp;lt;String&amp;gt; keys = countToLRUKeys.get(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (keys == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            keys = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;();&lt;br/&gt;            countToLRUKeys.put(&lt;span&gt;1&lt;/span&gt;,keys);&lt;br/&gt;        }&lt;br/&gt;        keys.add(key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;End&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文力求比较三个基本的缓存算法，以便对缓存建设之路有一个比较笼统的感觉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更加易用的cache，可以参考guava的实现。谨希望这三个代码模版，能够对你有所帮助。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bfce744668f80a48f4f7aefed0178cab</guid>
<title>阿里二面：什么是 mmap？</title>
<link>https://toutiao.io/k/qsuypsu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时在面试中你肯定会经常碰见的问题就是：RocketMQ为什么快？Kafka为什么快？什么是mmap？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一类的问题都逃不过的一个点就是&lt;strong&gt;零拷贝&lt;/strong&gt;，虽然还有一些其他的原因，但是今天我们的话题主要就是零拷贝。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传统IO&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始谈零拷贝之前，首先要对传统的IO方式有一个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于传统的IO方式，底层实际上通过调用&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;read()&lt;/code&gt;把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过&lt;code&gt;write()&lt;/code&gt;写入到&lt;code&gt;socket缓冲区&lt;/code&gt;，最后写入网卡设备。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3918918918918919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZxMVCAtvqB7vjPIJneciauiaqibxcMblRMQoDmgMWB1dEVuNI4URSIbKUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;4次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;4次拷贝&lt;/strong&gt;，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;read()&lt;/code&gt;方法向操作系统发起调用，此时上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，&lt;code&gt;read()&lt;/code&gt;返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;write()&lt;/code&gt;方法发起调用，上下文从用户态转为内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU将应用缓冲区中数据拷贝到socket缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，&lt;code&gt;write()&lt;/code&gt;返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5401785714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZxcm1fbqD965WCQRm9yiayVyMheVyRFHXo19M0pfeomCaH8O2OBicpicgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;672&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这里指的&lt;strong&gt;用户态&lt;/strong&gt;、&lt;strong&gt;内核态&lt;/strong&gt;指的是什么？上下文切换又是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，用户空间指的就是用户进程的运行空间，内核空间就是内核的运行空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果进程运行在内核空间就是内核态，运行在用户空间就是用户态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了安全起见，他们之间是互相隔离的，而在用户态和内核态之间的上下文切换也是比较耗时的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面我们可以看到，一次简单的IO过程产生了4次上下文切换，这个无疑在高并发场景下会对性能产生较大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么又是&lt;strong&gt;DMA&lt;/strong&gt;拷贝呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为对于一个IO操作而言，都是通过CPU发出对应的指令来完成，但是相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此就产生了DMA（Direct Memory Access）直接内存访问技术，本质上来说他就是一块主板上独立的芯片，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;零拷贝&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;零拷贝技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于零拷贝而言，并非真的是完全没有数据拷贝的过程，只不过是减少用户态和内核态的切换次数以及CPU拷贝的次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，仅仅有针对性的来谈谈几种常见的零拷贝技术。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mmap+write&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mmap+write简单来说就是使用&lt;code&gt;mmap&lt;/code&gt;替换了read+write中的read操作，减少了一次CPU的拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5401785714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZ9veTtLOR5gXvOpfiaf5P2SS40KOOm3rKvAsdzRSnHOKVpia2iaeNdO8KA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;672&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;4次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;3次拷贝&lt;/strong&gt;，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;mmap()&lt;/code&gt;方法向操作系统发起调用，上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;上下文从内核态转为用户态，mmap调用返回&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;write()&lt;/code&gt;方法发起调用，上下文从用户态转为内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CPU将读缓冲区中数据拷贝到socket缓冲区&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，&lt;code&gt;write()&lt;/code&gt;返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sendfile&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比&lt;code&gt;mmap&lt;/code&gt;来说，&lt;code&gt;sendfile&lt;/code&gt;同样减少了一次CPU拷贝，而且还减少了2次上下文切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21642969984202212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZ35y5xMiciby5MnjNGlic8OTDphZOvHsiaGcFH7SQhjB2Afy5AgcuoHolrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1266&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile&lt;/code&gt;是Linux2.1内核版本后引入的一个系统调用函数，通过使用&lt;code&gt;sendfile&lt;/code&gt;数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝，同时由于使用&lt;code&gt;sendfile&lt;/code&gt;替代了&lt;code&gt;read+write&lt;/code&gt;从而节省了一次系统调用，也就是2次上下文切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5338235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZibzJ5E3HGYYh1MYJp2Qog7fyXwYjXkqNKkDWO94rZMbAp2MOSPpUj1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;2次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;3次拷贝&lt;/strong&gt;，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;sendfile()&lt;/code&gt;方法向操作系统发起调用，上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从硬盘中拷贝到读缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU将读缓冲区中数据拷贝到socket缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，&lt;code&gt;sendfile&lt;/code&gt;调用返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile&lt;/code&gt;方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sendfile+DMA Scatter/Gather&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux2.4内核版本之后对&lt;code&gt;sendfile&lt;/code&gt;做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter/Gather 分散/收集功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它将读缓冲区中的数据描述信息--内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5338235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnVmOVDTlSicmTLLZ82HtKeZmMb5P3kcAF4oa244rgSpks8tSLKicDE5U0v7Kice2aLxQUUm1dCyCvxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程发生了&lt;strong&gt;2次用户态和内核态的上下文切换&lt;/strong&gt;和&lt;strong&gt;2次拷贝&lt;/strong&gt;，其中更重要的是完全没有CPU拷贝，具体流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户进程通过&lt;code&gt;sendfile()&lt;/code&gt;方法向操作系统发起调用，上下文从用户态转向内核态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;sendfile()&lt;/code&gt;调用返回，上下文从内核态切换回用户态&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DMA gather&lt;/code&gt;和&lt;code&gt;sendfile&lt;/code&gt;一样数据对用户空间不可见，而且需要硬件支持，同时输入文件描述符只能是文件，但是过程中完全没有CPU拷贝过程，极大提升了性能。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用场景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于文章开头说的两个场景：RocketMQ和Kafka都使用到了零拷贝的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于MQ而言，无非就是生产者发送数据到MQ然后持久化到磁盘，之后消费者从MQ读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于RocketMQ来说这两个步骤使用的是&lt;code&gt;mmap+write&lt;/code&gt;，而Kafka则是使用&lt;code&gt;mmap+write&lt;/code&gt;持久化数据，发送数据使用&lt;code&gt;sendfile&lt;/code&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于CPU和IO速度的差异问题，产生了DMA技术，通过DMA搬运来减少CPU的等待时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的IO&lt;code&gt;read+write&lt;/code&gt;方式会产生2次DMA拷贝+2次CPU拷贝，同时有4次上下文切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而通过&lt;code&gt;mmap+write&lt;/code&gt;方式则产生2次DMA拷贝+1次CPU拷贝，4次上下文切换，通过内存映射减少了一次CPU拷贝，可以减少内存使用，适合大文件的传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile&lt;/code&gt;方式是新增的一个系统调用函数，产生2次DMA拷贝+1次CPU拷贝，但是只有2次上下文切换。因为只有一次调用，减少了上下文的切换，但是用户空间对IO数据不可见，适用于静态文件服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sendfile+DMA gather&lt;/code&gt;方式产生2次DMA拷贝，没有CPU拷贝，而且也只有2次上下文切换。虽然极大地提升了性能，但是需要依赖新的硬件设备支持。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/6844903949359644680#heading-19&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/xiaolincoding/p/13719610.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://time.geekbang.org/column/article/118657&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.toutiao.com/i6898240850917114380/&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>