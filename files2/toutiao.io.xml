<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ddfc15b4113722828355889e15074ed2</guid>
<title>Spring Boot 开发秘籍：集成参数校验及高阶技巧</title>
<link>https://toutiao.io/k/bzx7ri7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMTk4NjM1MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gcBzLSUNh2cgXUsuLIsvQYJE1lzZd74qpC3iciaM6gcYIfOVV0KjDDkeN4CTLTn4ETPtaHOAuTWSWA/0?wx_fmt=png&quot; data-nickname=&quot;JAVA日知录&quot; data-alias=&quot;javadaily&quot; data-signature=&quot;写代码的架构师，做架构的程序员！  实战、源码、数据库、架构...只要你来，你想了解的这里都有！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 &lt;code&gt;web&lt;/code&gt;服务来说，为防止非法参数对业务造成影响，在 &lt;code&gt;Controller&lt;/code&gt;层一定要对参数进行校验！本章我们以SpringBoot项目为例，介绍参数校验的基本用法以及一些高级技巧，希望能对你有所帮助。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;简单使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;要在Springboot项目中加入参数校验功能首先得加入&lt;code&gt;spring-boot-starter-validation&lt;/code&gt;依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-validation&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;然后给需要校验的字段添加上约束性注解，如我们对实体类参数进行校验&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidEntity&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String appId;&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;@Email&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String email;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见约束注解如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;注解&lt;/th&gt;&lt;th&gt;功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@AssertFalse&lt;/td&gt;&lt;td&gt;可以为null,如果不为null的话必须为false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@AssertTrue&lt;/td&gt;&lt;td&gt;可以为null,如果不为null的话必须为true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@DecimalMax&lt;/td&gt;&lt;td&gt;设置不能超过最大值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@DecimalMin&lt;/td&gt;&lt;td&gt;设置不能超过最小值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Digits&lt;/td&gt;&lt;td&gt;设置必须是数字且数字整数的位数和小数的位数必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Future&lt;/td&gt;&lt;td&gt;日期必须在当前日期的未来&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Past&lt;/td&gt;&lt;td&gt;日期必须在当前日期的过去&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Max&lt;/td&gt;&lt;td&gt;最大不得超过此最大值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Min&lt;/td&gt;&lt;td&gt;最大不得小于此最小值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@NotNull&lt;/td&gt;&lt;td&gt;不能为null，可以是空&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Null&lt;/td&gt;&lt;td&gt;必须为null&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Pattern&lt;/td&gt;&lt;td&gt;必须满足指定的正则表达式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Size&lt;/td&gt;&lt;td&gt;集合、数组、map等的size()值必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Email&lt;/td&gt;&lt;td&gt;必须是email格式&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Length&lt;/td&gt;&lt;td&gt;长度必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@NotBlank&lt;/td&gt;&lt;td&gt;字符串不能为null,字符串trim()后也不能等于“”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@NotEmpty&lt;/td&gt;&lt;td&gt;不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Range&lt;/td&gt;&lt;td&gt;值必须在指定范围内&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@URL&lt;/td&gt;&lt;td&gt;必须是一个URL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：此表格只是简单的对注解功能的说明，并没有对每一个注解的属性进行说明；可详见源码。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在Controller层对需要参数校验的方法加上@Validated注解&lt;/p&gt;&lt;p&gt;参数校验一般分为两类：在Controller使用模型接收数据时， @Validated注解直接放在该模型参数前即可。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(value = &lt;span&gt;&quot;test1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;(@Validated @RequestBody ValidEntity validEntity)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test1 valid success&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(value = &lt;span&gt;&quot;test3&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;(@Validated ValidEntity validEntity)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test3 valid success&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;  当我们是直接在Controller层中的参数前，使用约束注解时，@Validated要直接放在类上&lt;br/&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(value = &lt;span&gt;&quot;test2&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;(@Email String email)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test2 valid success&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;  此时需要在主类上增加@Validated注解&lt;br/&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Validated&lt;br/&gt;@RestController&lt;br/&gt;@RequestMapping(&lt;span&gt;&quot;/demo/valid&quot;&lt;/span&gt;)&lt;br/&gt;public class ValidController {&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在参数校验时我们既可以使用@Validated也可以使用@Valid注解，两者功能大部分类似；&lt;/span&gt;&lt;p&gt;主要区别在于：&lt;/p&gt;&lt;p&gt;@Valid属于javax下的，而@Validated属于spring下；&lt;/p&gt;&lt;p&gt;@Valid支持嵌套校验、而@Validated不支持，@Validated支持分组，而@Valid不支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;统一异常处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果参数校验未通过Spring会抛出三种类型的异常&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当对@RequestBody需要的参数进行校验时会出现&lt;code&gt;org.springframework.web.bind.MethodArgumentNotValidException&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17070063694267515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJP3tquhVkpb3czUu0PGuViamtdZHP16AkO8w8522CRxzrnkNrFmib8wUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当直接校验具体参数时会出现&lt;code&gt;javax.validation.ConstraintViolationException&lt;/code&gt;，也属于&lt;code&gt;ValidationException&lt;/code&gt;异常&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1836441893830703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJ94ia9cAeibac545p1iaG6rxzreSAQE6ZQw5RiaPj6wBI1KAzvq6EvibBbdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当直接校验对象时会出现&lt;code&gt;org.springframework.validation.BindException&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15384615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJ6cSMyhZSCicHoVdpJwsu6ibPNlWiajQicVjL2tDE3e6k49HPlDESlOAFGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在SpringBoot中统一拦截处理只需要在配置类上添加 &lt;code&gt;@RestControllerAdvice&lt;/code&gt;注解，然后在具体方法中通过 &lt;code&gt;@ExceptionHandler&lt;/code&gt;指定需要处理的异常，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ERROR_MSG = &lt;span&gt;&quot;系统异常，请联系管理员。&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(value = {BindException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;ValidationException&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;MethodArgumentNotValidException&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ResponseEntity&lt;/span&gt;&amp;lt;&lt;span&gt;Result&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;handleValidatedException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        Result&amp;lt;String&amp;gt; resp = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; MethodArgumentNotValidException) {&lt;br/&gt;            &lt;span&gt;// BeanValidation exception&lt;/span&gt;&lt;br/&gt;            MethodArgumentNotValidException ex = (MethodArgumentNotValidException) e;&lt;br/&gt;            resp = &lt;span&gt;new&lt;/span&gt; Result&amp;lt;&amp;gt;(Integer.toString(HttpStatus.BAD_REQUEST.value()),&lt;br/&gt;                    ex.getBindingResult().getAllErrors().stream().map(ObjectError::getDefaultMessage).collect(Collectors.joining(&lt;span&gt;&quot;, &quot;&lt;/span&gt;))&lt;br/&gt;                    , getStackTrace(ex));&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ConstraintViolationException) {&lt;br/&gt;            &lt;span&gt;// BeanValidation GET simple param&lt;/span&gt;&lt;br/&gt;            ConstraintViolationException ex = (ConstraintViolationException) e;&lt;br/&gt;            resp = &lt;span&gt;new&lt;/span&gt; Result&amp;lt;&amp;gt;(Integer.toString(HttpStatus.BAD_REQUEST.value()),&lt;br/&gt;                    ex.getConstraintViolations().stream().map(ConstraintViolation::getMessage).collect(Collectors.joining(&lt;span&gt;&quot;, &quot;&lt;/span&gt;))&lt;br/&gt;                    , getStackTrace(ex));&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; BindException) {&lt;br/&gt;            &lt;span&gt;// BeanValidation GET object param&lt;/span&gt;&lt;br/&gt;            BindException ex = (BindException) e;&lt;br/&gt;            resp = &lt;span&gt;new&lt;/span&gt; Result&amp;lt;&amp;gt;(Integer.toString(HttpStatus.BAD_REQUEST.value()),&lt;br/&gt;                    ex.getAllErrors().stream().map(ObjectError::getDefaultMessage).collect(Collectors.joining(&lt;span&gt;&quot;, &quot;&lt;/span&gt;))&lt;br/&gt;                    , getStackTrace(ex));&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResponseEntity&amp;lt;&amp;gt;(resp,HttpStatus.BAD_REQUEST);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getStackTrace&lt;/span&gt;&lt;span&gt;(Exception e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//打印日志开关，可通过配置读取&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; printStrackTrace = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(printStrackTrace){&lt;br/&gt;            StringWriter sw = &lt;span&gt;new&lt;/span&gt; StringWriter();&lt;br/&gt;            e.printStackTrace(&lt;span&gt;new&lt;/span&gt; PrintWriter(sw));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sw.toString();&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ERROR_MSG;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终实现效果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2850765306122449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJTlia1OPPUhfSlTic2RKuOC5s6VTrXqDekAZXvJT9uM8icgXVUe0nLPXIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1568&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;参数分组&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有下面一个实体类，我们需要对其进行参数校验。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidEntity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String appId;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Email&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String email;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是实际业务是在编辑的时候 &lt;code&gt;appId&lt;/code&gt;才是必填，在新增的时候 &lt;code&gt;name&lt;/code&gt;必填，这时候可以用groups分组功能来实现：同一个模型在不同场景下，动态区分校验模型中的不同字段。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用方式&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先我们定义一个分组接口ValidGroup，再在分组接口总定义出多个不同的操作类型，Create，Update，Query，Delete&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ValidGroup&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Default&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ValidGroup&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;      &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Create&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Update&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;      &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Query&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Crud&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 &lt;code&gt;ValidGroup&lt;/code&gt;继承了Default，当然也可以不继承，具体区别我们后面再说。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在模型中给校验参数分配分组&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@ApiModel&lt;/span&gt;(value=&lt;span&gt;&quot;ValidEntity&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidEntity&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;(groups = ValidGroup.Crud.Update&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;appId&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotBlank&lt;/span&gt;(groups = ValidGroup.Crud.Create&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Email&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String email;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;tips：这里@Email注解未指定分组，默认会属于Default分组，appId和name指定了分组就不会再属于Default分组了。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在参数校验时通过value属性指定分组&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2874524714828897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4j5Mwbh7ibj84r5ia9LgUAqEJJjXfGL1NdebZNLDEPF6iaaapLkD8TneC8bEUxKPiajKkiaickWMiaOCrib8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1315&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里通过 &lt;code&gt;@Validated(value = ValidGroup.Crud.Update.class)&lt;/code&gt;指定了具体的分组，上面提到的是否继承Default的区别在于：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果继承了Default，@Validated标注的注解也会校验未指定分组或者Default分组的参数，比如email&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不继承Default则不会校验未指定分组的参数，需要加上&lt;code&gt;@Validated(value = {ValidGroup.Crud.Update.class, Default.class}&lt;/code&gt;才会校验&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;快速失败（Fali Fast）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下在对参数进行校验时Spring Validation会校验完所有字段然后才抛出异常，可以通过配置开启 &lt;code&gt;Fali Fast&lt;/code&gt;模式，一旦校验失败就立即返回。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ValidatedConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Validator &lt;span&gt;validator&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;                .&lt;span&gt;configure&lt;/span&gt;()&lt;br/&gt;                // 快速失败模式&lt;br/&gt;                .&lt;span&gt;failFast&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                .&lt;span&gt;buildValidatorFactory&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; validatorFactory.getValidator();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6bf317f7b899066d2375f2497ca314fc</guid>
<title>什么是跨域？如何解决？</title>
<link>https://toutiao.io/k/eonszqf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;h3&gt;&lt;span&gt;跨域&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在了解跨域之前，我们先了解下一个域名地址的组成，就拿腾讯云+社区的 loader.js 说吧。这个一个 js 资源文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//cloud.tencent.com:443/qccomponent/loader.js&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们拆分下，这个地址包含 https（请求协议）、cloud.tencent.com（域名）、443（端口号，https 默认 443，不加也可以）及资源地址（qccomponent/loader.js）。这样一拆分就很好了解什么是跨域了。&lt;/p&gt;&lt;p&gt;跨域就是协议、域名、端口号中任意一个不相同时，都算作不同域。不同域之间请求资源，都算是跨域。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5627090301003345&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ldv96ZtlFHSHZYAZcQKhgibt5OJV3kYXAugOibXC6jg2WZIlnRBwEKAbSeI6WCDdLlXLIe2HiczU7htUOTN4XoEJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里我们说明一下，为什么会出现跨域。出于浏览器的同源策略限制。同源策略会阻止一个域的 javascript 脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port），因此只要其中一个不相同，就是跨域。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;说明：同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;同源策略&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。如果没有同源策略的限制，用户的信息将不再是安全的，因为任何一个人都可以通过资源注入，恶意获取用户信息。&lt;/p&gt;&lt;p&gt;同源策略限制了哪些？&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cookie、LocalStorage、sessionStorag、IndexedDB 等存储性内容&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DOM 节点&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;AJAX 请求&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;但是有三个标签是可以跨域访问资源的&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&amp;lt;img&amp;gt;标签&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&amp;lt;link&amp;gt;标签&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;标签&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;解决跨域&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;JSONP&lt;br/&gt;上面我们说道有三个标签是可以跨域访问资源，JSONP 利用&amp;lt;script&amp;gt;元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&#x27;text/javascript&#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;    &lt;span&gt;window&lt;/span&gt;.jsonpCallback = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;res&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(res)&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&#x27;http://localhost:8080/api/jsonp?id=1&amp;amp;cb=jsonpCallback&#x27;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&#x27;text/javascript&#x27;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CORS&lt;br/&gt;整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。&lt;/p&gt;&lt;p&gt;只需要在服务器端做一些小小的改造即可：&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&quot;Access-Control-Allow-Headers&quot;&lt;/span&gt;:&lt;span&gt;&quot;*&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;nginx 反向代理&lt;br/&gt;这个我们之前公司项目使用的是这种方式，具体配置我也不太了解。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;我坚信，赞赏是不耍流氓的鼓励!&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>daeaa61815a699af5d4f496acab69720</guid>
<title>读者：西法，记忆化递归究竟怎么改成动态规划啊？</title>
<link>https://toutiao.io/k/146am4j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4MzUxNjI3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/liaT5dytkaTemW9Fpf8y5Cez0KhBtoEU6jfSorN0N12SMnc3AkGkLoFcY9HNl2hRK3gIYyZ7g42wk5nXvSUq0Tg/0?wx_fmt=png&quot; data-nickname=&quot;力扣加加&quot; data-alias=&quot;leetcode-pp&quot; data-signature=&quot;力求用清晰直白的方式还原解题的过程，努力做西湖区最好的算法题解。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;我在&lt;span&gt;动态规划专题&lt;/span&gt;反复强调了&lt;strong&gt;先学习递归，再学习记忆化，最后再学动态规划&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MzUxNjI3OA==&amp;amp;mid=2247488433&amp;amp;idx=1&amp;amp;sn=86bb57247b56b493af2aef0954c9eb62&amp;amp;chksm=eb88dfa8dcff56be1034750b2bb9d87240a197de4f4ea574b3ae26242d226bc1581ca4e88bfc&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;动态规划到底有多难？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中原因已经讲得很透了，相信大家已经明白了。如果不明白，强烈建议先看看那篇文章。&lt;/p&gt;&lt;p&gt;尽管很多看了我文章的小伙伴知道了先去学记忆化递归，但是还是有一些粉丝问我：&lt;strong&gt;“记忆化递归转化为动态规划老是出错，不得要领怎么办？有没有什么要领呀？”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;今天我就来回答一下粉丝的这个问题。&lt;/p&gt;&lt;p&gt;实际上我的动态规划那篇文章已经讲了将记忆化递归转化为动态规划的大概的思路，只是可能不是特别细，今天我们就尝试&lt;strong&gt;细化一波&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我们仍然先以经典的爬楼梯为例，给大家讲一点基础知识。接下来，我会带大家解决一个更加复杂的题目。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;爬楼梯&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;题目描述&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？&lt;/p&gt;&lt;h3&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;由于&lt;strong&gt;第 n 级台阶一定是从 n - 1 级台阶或者 n - 2 级台阶来的&lt;/strong&gt;，因此到第 n 级台阶的数目就是 &lt;code&gt;到第 n - 1 级台阶的数目加上到第 n - 1 级台阶的数目&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;记忆化递归代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; memo = {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n &lt;span&gt;in&lt;/span&gt; memo) &lt;span&gt;return&lt;/span&gt; memo[n];&lt;br/&gt;  ans = climbStairs(n - &lt;span&gt;1&lt;/span&gt;) + climbStairs(n - &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  memo[n] = ans;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ans;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;climbStairs(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先为了方便看出关系，我们先将 memo 的名字改一下，将 memo 换成 dp：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;const&lt;/span&gt; dp = {};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n === &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;if&lt;/span&gt; (n &lt;span&gt;in&lt;/span&gt; dp) &lt;span&gt;return&lt;/span&gt; dp[n];&lt;/span&gt;&lt;br/&gt;  ans = climbStairs(n - &lt;span&gt;1&lt;/span&gt;) + climbStairs(n - &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;  dp[n] = ans;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ans;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;climbStairs(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他地方一点没动，就是名字改了下。&lt;/p&gt;&lt;p&gt;那么这个记忆化递归代码如何改造成动态规划呢？这里我总结了三个步骤，根据这三个步骤就可以将&lt;strong&gt;很多&lt;/strong&gt;记忆化递归轻松地转化为动态规划。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;1. 根据记忆化递归的入参建立 dp 数组&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在动态规划专题中，西法还提过&lt;strong&gt;动态规划的核心就是状态。动态规划问题时间复杂度打底就是状态数，空间复杂度如果不考虑滚动数组优化打底也是状态数&lt;/strong&gt;，而状态数是什么？不就是各个状态的取值范围的笛卡尔积么？而&lt;strong&gt;状态正好对应的就是记忆化递归的入参&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;对应这道题，显然状态是当前位于第几级台阶。那么状态数就有 n 个。因此开辟一个长度为 n 的一维数组就好了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我用 from 表示改造前的记忆化递归代码， to 表示改造后的动态规划代码。（下同，不再赘述）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;from:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp = {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(n);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;2. 用记忆化递归的叶子节点返回值填充 dp 数组初始值&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;如果你模拟上面 dp 函数的执行过程会发现: &lt;code&gt;if n == 1 return 1&lt;/code&gt; 和 &lt;code&gt;if n == 2 return 2&lt;/code&gt;，对应递归树的叶子节点，这两行代码&lt;strong&gt;深入到叶子节点才会执行&lt;/strong&gt;。接下来再根据子 dp 函数的返回值合并结果，是一个典型的&lt;strong&gt;后序遍历&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9132492113564669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdNsKsynR4rCWsceiagu9af02NJiaWic48bQTpZL2oCv9FE9g7YFr1Msicib5Kd7u6Vt5dVAUVLriag3kEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;634&quot;/&gt;&lt;figcaption&gt;蓝色表示叶子节点&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果改造成迭代，如何做呢？一个朴素的想法就是从叶子节点开始模拟递归栈返回的过程，没错&lt;strong&gt;动态规划本质就是如此&lt;/strong&gt;。从叶子节点开始，到根节点结束，&lt;strong&gt;这也是为什么记忆化递归通常被称为自顶向下，而动态规划被称为自底向上的原因&lt;/strong&gt;。这里的底和顶可以看做是递归树的叶子和根。&lt;/p&gt;&lt;p&gt;知道了记忆化递归和动态规划的本质区别。 接下来，我们填充初始化，填充的逻辑就是记忆化递归的叶子节点 return 部分。&lt;/p&gt;&lt;p&gt;from:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; dp = {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(n);&lt;br/&gt;  dp[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  dp[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;dp 长度为 n，索引范围是 [0,n-1]，因此 dp[n-1] 对应记忆化递归的 dp(n)。因此 dp[0] = 1 等价于上面的 if n == 1: return 1。 如果你想让二者完全对应也是可以的，数组长度开辟为 n + 1，并且数组索引 0 不用即可。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;span&gt;3. 枚举笛卡尔积，并复制主逻辑&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;if (xxx in dp) return dp[xxx] 这种代码删掉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将递归函数 f(xxx, yyy, ...) 改成 dp[xxx][yyy][....] ，对应这道题就是 climbStairs(n) 改成 dp[n]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将递归改成迭代。比如这道题每次 climbStairs(n) 递归调用了 climbStairs(n-1) 和 climbStairs(n-2)，一共调用 n 次，我们要做的就是迭代模拟。比如这里调用了 n 次，我们就用一层循环来模拟执行 n 次。如果有两个参数就两层循环，三个参数就三层循环，以此类推。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;from:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; dp = {};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n &lt;span&gt;in&lt;/span&gt; dp) &lt;span&gt;return&lt;/span&gt; dp[n];&lt;br/&gt;  ans = climbStairs(n - &lt;span&gt;1&lt;/span&gt;) + climbStairs(n - &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  dp[n] = ans;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ans;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这个循环其实就是咱上面提到的状态的笛卡尔积。由于这道题就一个状态，枚举一层就好了。如果状态有两个，那么笛卡尔积就可以用两层循环搞定。至于谁在外层循环谁在内层循环，请看我的动态规划专题。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; n; i++) {&lt;br/&gt;    dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; dp[dp.length - &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将上面几个步骤的成果合并起来就可以将原有的记忆化递归改造为动态规划了。&lt;/p&gt;&lt;p&gt;完整代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;climbStairs&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(n);&lt;br/&gt;  dp[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  dp[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; n; i++) {&lt;br/&gt;    dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; dp[dp.length - &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有的人可能觉得这道题太简单了。实际上确实有点简单了。 而且我也承认&lt;strong&gt;有的记忆化递归比较难以改写&lt;/strong&gt;，什么情况记忆化递归比较好写，改成动态规划就比较麻烦我也在动态规划专题给大家讲过了，不清楚的同学翻翻。&lt;/p&gt;&lt;p&gt;据我所知，如果动态规划可以过，&lt;strong&gt;大多数&lt;/strong&gt;记忆化递归都可以过。有一些极端情况记忆化递归过不了：那就是力扣测试用例偏多，并且数据量大的测试用例比较多。这是由于力扣的超时判断是多个测试用例的用时总和，而不是单独计算时间。&lt;/p&gt;&lt;p&gt;接下来，我再举一个稍微难一点的例子（这个例子就必须使用动态规划才能过，记忆化递归会超时）。带大家熟悉我上面给大家的套路。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;1824. 最少侧跳次数&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;题目描述&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;给你一个长度为  n  的  3 跑道道路  ，它总共包含  n + 1  个   点  ，编号为  0  到  n 。一只青蛙从  0  号点第二条跑道   出发  ，它想要跳到点  n  处。然而道路上可能有一些障碍。&lt;br/&gt;&lt;br/&gt;给你一个长度为 n + 1  的数组  obstacles ，其中  obstacles[i] （取值范围从 0 到 3）表示在点 i  处的  obstacles[i]  跑道上有一个障碍。如果  obstacles[i] == 0 ，那么点  i  处没有障碍。任何一个点的三条跑道中   最多有一个   障碍。&lt;br/&gt;&lt;br/&gt;比方说，如果  obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。&lt;br/&gt;这只青蛙从点 i  跳到点 i + 1  且跑道不变的前提是点 i + 1  的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在   同一个   点处   侧跳   到 另外一条   跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。&lt;br/&gt;&lt;br/&gt;比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。&lt;br/&gt;这只青蛙从点 0 处跑道 2  出发，并想到达点 n  处的 任一跑道 ，请你返回 最少侧跳次数  。&lt;br/&gt;&lt;br/&gt;注意：点 0  处和点 n  处的任一跑道都不会有障碍。&lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.48760330578512395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdNsKsynR4rCWsceiagu9af0zIrOJ6cGB7fuia8lBSybFKfYpG9DQeEyFvQYLrxBJ7vhy976oUQAU9A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;605&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;输入：obstacles = [0,1,2,3,0]&lt;br/&gt;输出：2&lt;br/&gt;解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。&lt;br/&gt;注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3917112299465241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdNsKsynR4rCWsceiagu9af0Q4gdLpbG2OkE4qT9ZP8BchR6TOVC3OoJ7bNPhUSNYOibcSu6KibLTq4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;输入：obstacles = [0,1,1,3,3,0]&lt;br/&gt;输出：0&lt;br/&gt;解释：跑道 2 没有任何障碍，所以不需要任何侧跳。&lt;br/&gt;示例 3：&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3917112299465241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdNsKsynR4rCWsceiagu9af0ed9zwbSm4cqiaW6drs2OhhonufRkBMt5AY2Zz5ejqwH8y3ffLIeCg0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;输入：obstacles = [0,2,1,0,3,0]&lt;br/&gt;输出：2&lt;br/&gt;解释：最优方案如上图所示。总共有 2 次侧跳。&lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;obstacles.length == n + 1&lt;br/&gt;1 &amp;lt;= n &amp;lt;= 5 \* 105&lt;br/&gt;0 &amp;lt;= obstacles[i] &amp;lt;= 3&lt;br/&gt;obstacles[0] == obstacles[n] == 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;这个青蛙在反复横跳？？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;稍微解释一下这个题目。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果当前跑道后面一个位置没有障碍物，这种情况左右横跳一定不会比直接平跳更优，我们应该贪心地直接平跳（不是横跳）过去。这是因为最坏情况我们可以&lt;strong&gt;先平跳过去再横跳，这和先横跳再平跳是一样的。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果当前跑道后面一个位置有障碍物，我们需要横跳到一个没有障碍物的通道，同时横跳计数器 + 1。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后选取所有到达终点的横跳次数最少的即可，对应递归树中就是到达叶子节点时计数器最小的。&lt;/p&gt;&lt;p&gt;使用 dp(pos, line) 表示当前在通道 line， 从 pos &lt;strong&gt;跳到终点&lt;/strong&gt;需要的最少的横跳数。不难写出如下记忆化递归代码。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;由于本篇文章主要讲的是记忆化递归改造动态规划，因此这道题的细节就不多介绍了，大家看代码就好。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们来看下代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = {}&lt;br/&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(pos, line)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (pos, line) &lt;span&gt;in&lt;/span&gt; dp: &lt;span&gt;return&lt;/span&gt; dp[(pos, line)]&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; pos == len(obstacles) - &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 贪心地平跳&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; obstacles[pos + &lt;span&gt;1&lt;/span&gt;] != line:&lt;br/&gt;                ans = f(pos + &lt;span&gt;1&lt;/span&gt;, line)&lt;br/&gt;                dp[(pos, line)] = ans&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;            ans = float(&lt;span&gt;&quot;inf&quot;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; nxt &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]:&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; nxt != line &lt;span&gt;and&lt;/span&gt; obstacles[pos] != nxt:&lt;br/&gt;                    ans = min(ans, &lt;span&gt;1&lt;/span&gt; +f(pos, nxt))&lt;br/&gt;            dp[(pos, line)] = ans&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; f(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这道题记忆化递归会超时，需要使用动态规划才行。 那么如何将 ta 改造成动态规划呢？&lt;/p&gt;&lt;p&gt;还是用上面的口诀。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;1. 根据记忆化递归的入参建立 dp 数组&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;上面递归函数的是 dp(pos, line)，状态就是形参，因此需要建立一个 m * n 的二维数组，其中 m 和 n 分别是 pos 和 line 的取值范围集合的大小。而 line 取值范围其实就是 [1,3]，为了方便索引对应，这次西法决定浪费一个空间。由于这道题是求最小，因此初始化为无穷大没毛病。&lt;/p&gt;&lt;p&gt;from:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = {}&lt;br/&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(pos, line)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; f(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = [[float(&lt;span&gt;&quot;inf&quot;&lt;/span&gt;)] * &lt;span&gt;4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(obstacles))]&lt;br/&gt;        &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; min(dp[&lt;span&gt;-1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;2. 用记忆化递归的叶子节点返回值填充 dp 数组初始值&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;不多说了，直接上代码。&lt;/p&gt;&lt;p&gt;from:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = {}&lt;br/&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(pos, line)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; pos == len(obstacles) - &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; f(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = [[float(&lt;span&gt;&quot;inf&quot;&lt;/span&gt;)] * &lt;span&gt;4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(obstacles))]&lt;br/&gt;        dp[&lt;span&gt;0&lt;/span&gt;] = [&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;        &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; min(dp[&lt;span&gt;-1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;3. 枚举笛卡尔积，并复制主逻辑&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;这道题如何枚举状态？当然是枚举状态的笛卡尔积了。简单，几个状态就几层循环呗。&lt;/p&gt;&lt;p&gt;上代码。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = [[float(&lt;span&gt;&quot;inf&quot;&lt;/span&gt;)] * &lt;span&gt;4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(obstacles))]&lt;br/&gt;        dp[&lt;span&gt;0&lt;/span&gt;] = [&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; pos &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, len(obstacles)):&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;):&lt;br/&gt;                &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; min(dp[&lt;span&gt;-1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来就是把记忆化递归的主逻辑复制一下粘贴过来就行。&lt;/p&gt;&lt;p&gt;from:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = {}&lt;br/&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(pos, line)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 贪心地平跳&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; obstacles[pos + &lt;span&gt;1&lt;/span&gt;] != line:&lt;br/&gt;                ans = f(pos + &lt;span&gt;1&lt;/span&gt;, line)&lt;br/&gt;                dp[(pos, line)] = ans&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;            ans = float(&lt;span&gt;&quot;inf&quot;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; nxt &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]:&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; nxt != line &lt;span&gt;and&lt;/span&gt; obstacles[pos] != nxt:&lt;br/&gt;                    ans = min(ans, &lt;span&gt;1&lt;/span&gt; +f(pos, nxt))&lt;br/&gt;            dp[(pos, line)] = ans&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; f(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = [[float(&lt;span&gt;&quot;inf&quot;&lt;/span&gt;)] * &lt;span&gt;4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(obstacles))]&lt;br/&gt;        dp[&lt;span&gt;0&lt;/span&gt;] = [&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; pos &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, len(obstacles)):&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;):&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; obstacles[pos - &lt;span&gt;1&lt;/span&gt;] != line: &lt;span&gt;# 由于自底向上，因此是和 pos - 1 建立联系，而不是 pos + 1&lt;/span&gt;&lt;br/&gt;                    dp[pos][line] = min(dp[pos][line], dp[pos - &lt;span&gt;1&lt;/span&gt;][line])&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; nxt &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;):&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; nxt != line &lt;span&gt;and&lt;/span&gt; obstacles[pos] != nxt:&lt;br/&gt;                            dp[pos][line] = min(dp[pos][line], &lt;span&gt;1&lt;/span&gt; + dp[pos][nxt])&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; min(dp[&lt;span&gt;-1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出我基本就是把主逻辑复制过来，稍微改改。 改的基本就是因为：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;之前是递归函数，因此 return 需要去掉，比如改成 continue 啥的，不能让函数直接返回，而是继续枚举下一个状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之前是 dp[(pos, line)] = ans 现在则改成填充咱上面初始好的二维 dp 数组。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;你以为这就结束了么？&lt;/p&gt;&lt;p&gt;那你就错了。之所以选这道题是有原因的。这道题直接提交会报错，是答案错误（WA）。&lt;/p&gt;&lt;p&gt;这里我要告诉大家的是：&lt;strong&gt;由于我们使用迭代模拟递归过程，使用多层循环枚举状态的笛卡尔积&lt;/strong&gt;，而主逻辑部分则是状态转移方程，而转移方程的书写和枚举的顺序息息相关。&lt;/p&gt;&lt;p&gt;从代码不难看出：对这道题来说我们采用的是从小到大枚举，而 dp[pos][line] 也仅仅依赖 dp[pos-1][line] 和 dp[pos][nxt]。&lt;/p&gt;&lt;p&gt;而问题的关键是 nxt，比如处理到了 dp[2][1]，d[2][1] 依赖了 dp[2][3] 的值，而实际上 dp[2][3] 是没有处理到的。&lt;/p&gt;&lt;p&gt;因此上面动态规划的的这一行代码有问题：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[pos][line] = min(dp[pos][line], &lt;span&gt;1&lt;/span&gt; + dp[pos][nxt])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为&lt;strong&gt;遍历到 dp[pos][line] 的时候，有可能 dp[pos][nxt] 还没计算好(没有枚举到)，这就是产生了 bug。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;那为什么记忆化递归就没问题呢？&lt;/p&gt;&lt;p&gt;其实很简单。递归函数里面的子问题&lt;strong&gt;都是没有计算好的&lt;/strong&gt;，到叶子节点后再开始计算，计算好后往上返回，而&lt;strong&gt;返回的过程其实和迭代是类似的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如这道题的 f(0,2) 的递归树大概是这样的，其中虚线标识可能无法到达。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5284090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdNsKsynR4rCWsceiagu9af0iaXicLaoSicfzLmfaSZjOCqxPMcTO8wuicMcA3U3Iiam040340h9vadKLzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1408&quot;/&gt;&lt;figcaption&gt;递归树&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当从 f(0, 2) 递归到 f(0, 1) 或者 f(0, 3) 的的时候，都是没计算好的，因此都无所谓，代码会&lt;strong&gt;继续往叶子节点方向扩展，到达叶子节点返回后，所有的子节点肯定都已经计算好了，接下来的过程和普通的迭代就很像了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;比如 f(0,2) 递归到 f(0,3) ，f(0,3) 会继续向下递归知道叶子节点，然后向上返回，当再次回到 f(0,2) 的时候，f(0,3) 一定是已经计算好的。&lt;/p&gt;&lt;p&gt;形象点来说就是：f(0,2) 是一个 leader，告诉他的下属 f(0,3)，我想要 xxxx，怎么实现我不管，你有的话直接给我（记忆化），没有的话想办法获取（递归）。不管怎么样，反正你给我弄出来送到我手上。&lt;/p&gt;&lt;p&gt;而如果使用迭代的动态规划，你有的话直接给我（记忆化）很容易做到。关键是没有的话想办法获取（递归）不容易做到啊，至少需要一个类似的循环去完成吧？&lt;/p&gt;&lt;p&gt;那如何解决这个问题呢？&lt;/p&gt;&lt;p&gt;很简单，每次&lt;strong&gt;只依赖已经计算好的状态&lt;/strong&gt;就好了。&lt;/p&gt;&lt;p&gt;对于这道题来说，虽然 dp[pos][nxt] 可能没计算好了，那么 dp[pos-1][nxt] 一定是计算好的，因为 dp[pos-1][nxt] 已经在上一次主循环计算好了。&lt;/p&gt;&lt;p&gt;但是直接改成 dp[pos-1][nxt] 逻辑还对么？这就要具体问题具体分析了，对于这道题来说，这么写是可以的。&lt;/p&gt;&lt;p&gt;这是因为这里的逻辑是&lt;strong&gt;如果当前赛道的前面一个位置有障碍物，那么我们不能从当前赛道的前一个位置过来，而只能选择从其他两个赛道横跳过来。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我画了一个简图。其中 X 表示障碍物，O 表示当前的位置，数字表示时间上的先后循序，先跳 1 再跳 2 。。。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-XO&lt;br/&gt;---&lt;br/&gt;---&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，而以下两种情况其实是等价的：&lt;/p&gt;&lt;p&gt;情况 1（也就是上面 dp[pos][nxt] 的情况）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-X2&lt;br/&gt;--1&lt;br/&gt;---&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;情况 2（也就是上面 dp[pos-1][nxt] 的情况）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-X3&lt;br/&gt;-12&lt;br/&gt;---&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出二者是一样的。没懂？多看看，多想想。&lt;/p&gt;&lt;p&gt;综上，我们将 dp[pos][nxt] 改成 dp[pos-1][nxt] 不会有问题。大家遇到其他问题也采取类似思路分析一波即可。&lt;/p&gt;&lt;p&gt;完整代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minSideJumps&lt;/span&gt;&lt;span&gt;(self, obstacles: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = [[float(&lt;span&gt;&quot;inf&quot;&lt;/span&gt;)] * &lt;span&gt;4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(obstacles))]&lt;br/&gt;        dp[&lt;span&gt;0&lt;/span&gt;] = [&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; pos &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, len(obstacles)):&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;):&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; obstacles[pos - &lt;span&gt;1&lt;/span&gt;] != line: &lt;span&gt;# 由于自底向上，因此是和 pos - 1 建立联系，而不是 pos + 1&lt;/span&gt;&lt;br/&gt;                    dp[pos][line] = min(dp[pos][line], dp[pos - &lt;span&gt;1&lt;/span&gt;][line])&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; nxt &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;):&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; nxt != line &lt;span&gt;and&lt;/span&gt; obstacles[pos] != nxt:&lt;br/&gt;                            dp[pos][line] = min(dp[pos][line], &lt;span&gt;1&lt;/span&gt; + dp[pos&lt;span&gt;-1&lt;/span&gt;][nxt])&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; min(dp[&lt;span&gt;-1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;趁热打铁再来一个&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;再来一个例子，1866. 恰有 K 根木棍可以看到的排列数目。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;直接上记忆化递归代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;rearrangeSticks&lt;/span&gt;&lt;span&gt;(self, n: int, k: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        @lru_cache(None)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dp&lt;/span&gt;&lt;span&gt;(i, j)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;0&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; j != &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;0&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; j == &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (dp(i - &lt;span&gt;1&lt;/span&gt;, j - &lt;span&gt;1&lt;/span&gt;) + dp(i - &lt;span&gt;1&lt;/span&gt;, j) * (i - &lt;span&gt;1&lt;/span&gt;)) % (&lt;span&gt;10&lt;/span&gt;**&lt;span&gt;9&lt;/span&gt; + &lt;span&gt;7&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dp(n, k) % (&lt;span&gt;10&lt;/span&gt;**&lt;span&gt;9&lt;/span&gt; + &lt;span&gt;7&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;咱不管这个题是啥，代码怎么来的。假设这个代码咱已经写出来了。那么如何改造成动态规划呢？继续套用三部曲。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;1. 根据记忆化递归的入参建立 dp 数组&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;由于 i 的取值 [0-n] 一共 n + 1 个， j 的取值是 [0-k] 一共 k + 1 个。因此初始化一个二维数组即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp = [[&lt;span&gt;0&lt;/span&gt;] * (k+&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(n+&lt;span&gt;1&lt;/span&gt;)]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;2. 用记忆化递归的叶子节点返回值填充 dp 数组初始值&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;由于 i == 0 and j == 0 是 1，因此直接写 dp[0][0] = 1 就好了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp = [[&lt;span&gt;0&lt;/span&gt;] * (k+&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(n+&lt;span&gt;1&lt;/span&gt;)]&lt;br/&gt;&lt;span&gt;dp[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;3. 枚举笛卡尔积，并复制主逻辑&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;就是两层循环枚举 i 和 j 的所有组合就好了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp = [[&lt;span&gt;0&lt;/span&gt;] * (k+&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(n+&lt;span&gt;1&lt;/span&gt;)]&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, n + &lt;span&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, min(k, i) + &lt;span&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;# ...&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; dp[&lt;span&gt;-1&lt;/span&gt;][&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后把主逻辑复制过来完工了。&lt;/p&gt;&lt;p&gt;比如： return xxx 改成 dp[形参一][形参二] = xxx 等小细节。&lt;/p&gt;&lt;p&gt;最终的一个代码就是：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;rearrangeSticks&lt;/span&gt;&lt;span&gt;(self, n: int, k: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        dp = [[&lt;span&gt;0&lt;/span&gt;] * (k+&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(n+&lt;span&gt;1&lt;/span&gt;)]&lt;br/&gt;        dp[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, n + &lt;span&gt;1&lt;/span&gt;):&lt;br/&gt;&lt;span&gt;            &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, min(k, i) + &lt;span&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                dp[i][j] = dp[i&lt;span&gt;-1&lt;/span&gt;][j&lt;span&gt;-1&lt;/span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                &lt;span&gt;if&lt;/span&gt; i - &lt;span&gt;1&lt;/span&gt; &amp;gt;= j:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    dp[i][j] += dp[i&lt;span&gt;-1&lt;/span&gt;][j] * (i - &lt;span&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                dp[i][j] %= &lt;span&gt;10&lt;/span&gt;**&lt;span&gt;9&lt;/span&gt; + &lt;span&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dp[&lt;span&gt;-1&lt;/span&gt;][&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;有的记忆化递归比较难以改写，什么情况记忆化递归比较好写，改成动态规划就比较麻烦我也在动态规划专题给大家讲过了，不清楚的同学翻翻。&lt;/p&gt;&lt;p&gt;我之所以推荐大家从记忆化递归入手，正是因为很多情况下记忆化写起来简单，而且容错高（想想上面的青蛙跳的例子）。这是因为记忆化递归总是后序遍历，会在到达叶子节点只会往上计算。而往上计算的过程和迭代的动态规划是类似的。或者你也可以认为迭代的动态规划是在模拟记忆化递归的&lt;strong&gt;归的过程&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我们要做的就是把一些容易改造的方法学会，接下来面对难的尽量用记忆化递归。据我所知，如果动态规划可以过，大多数记忆化递归都可以过。有一个极端情况记忆化递归过不了：那就是力扣测试用例偏多，并且数据量大的测试用例比较多。这是由于力扣的超时判断是多个测试用例的用时总和，而不是单独计算时间。&lt;/p&gt;&lt;p&gt;将记忆化递归改造成动态规划可以参考我的这三个步骤：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据记忆化递归的入参建立 dp 数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用记忆化递归的叶子节点返回值填充 dp 数组初始值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;枚举笛卡尔积，并复制主逻辑&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;另外有一点需要注意的是：状态转移方程的确定和枚举的方向息息相关，虽然不同题目细节差异很大。 但是我们只要牢牢把握一个原则就行了，那就是：&lt;strong&gt;永远不要用没有计算好的状态，而是仅适用已经计算好的状态&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wx2edeec3cd45f0d24&quot; data-miniprogram-path=&quot;pages/detail?id=65b0b46225e7a1df&quot; data-miniprogram-nickname=&quot;快言留言板&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;留言在这里&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;爱心三连击&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;1.看到这里了就点个在看支持下吧，你的&lt;strong&gt;在看&lt;/strong&gt;是我创作的动力。&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.关注公众号&lt;/span&gt;&lt;span&gt;&lt;strong&gt;力扣加加&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，获取更多前端硬核文章！&lt;/span&gt;&lt;strong&gt;加个星标&lt;/strong&gt;&lt;span&gt;，不错过每一条成长的机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3.如果你觉得本文的内容对你有帮助，就帮我&lt;strong&gt;转发&lt;/strong&gt;一下吧。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4MzUxNjI3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/liaT5dytkaTemW9Fpf8y5Cez0KhBtoEU6jfSorN0N12SMnc3AkGkLoFcY9HNl2hRK3gIYyZ7g42wk5nXvSUq0Tg/0?wx_fmt=png&quot; data-nickname=&quot;力扣加加&quot; data-alias=&quot;leetcode-pp&quot; data-signature=&quot;力求用清晰直白的方式还原解题的过程，努力做西湖区最好的算法题解。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果喜欢我的文章，点个”&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;“吧 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;20&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j4elhCicRBPe4X8ia8chJCibkIj3EXr6pdmqp0FBQmh4IJn3VITg12ybYXtvEJpcx6wgctqNBOPQtrB9Bt9VI4NDA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>05e49c014f08080f96565117fa040499</guid>
<title>验证是否存在写文件漏洞小技巧</title>
<link>https://toutiao.io/k/wb7n2nl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题背景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在安全黑盒测试时遇到一个疑似能写任意文件的漏洞点，想要验证漏洞是否存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就猜测后端代码可能如下：存在可能的任意写文件漏洞，可写的内容部分可控、服务权限未知&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;content = &lt;span&gt;&quot;something start&quot;&lt;/span&gt; + &lt;span&gt;&quot;用户可控的内容&quot;&lt;/span&gt; + &lt;span&gt;&quot;something end&quot;&lt;/span&gt;&lt;br/&gt;f = open(&lt;span&gt;&quot;用户指定的文件路径&quot;&lt;/span&gt;, &lt;span&gt;&quot;w&quot;&lt;/span&gt;)&lt;br/&gt;f.write(content)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始用&quot;写入ping dnslog命令到crontab&quot;来验证写文件漏洞是否存在，不过验证失败了，可能因为下面两个原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;目标机器没启动cron服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务身份可能不是root，没有权限写 /var/spool/cron目录和/etc/crontab&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以写内容到 .bashrc、web路径、常用文件（比如bash、ping等），但这些方式都有一点限制：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;/root/.bashrc因为服务身份不一定是root，所以可能写入失败&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;.bashrc需要登陆到机器才能触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;web路径位置未知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写常用文件(比如bash、ping等)可能影响目标系统的稳定性，并且需要等待目标操作才能触发&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里只想要快速验证&quot;写文件漏洞&quot;是否存在，确认存在后，再来尝试上述或者别的方法来做漏洞利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了验证&quot;写文件漏洞&quot;是否存在，我的思路是 能不能找到一个特殊文件，写内容到此文件会造成延时或者产生dnslog。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我能想到的特殊文件包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;管道文件  是否能造成延时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;/dev/tcp/{host}/{ip} 是否能造成dnslog&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;socket文件  是否能造成延时或者dnslog&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就是验证这些文件，哪个符合需求&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分析过程&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;管道文件&lt;/p&gt;&lt;p&gt;思路：找到系统上默认的管道文件，并且验证写入文件是否阻塞&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;找出系统默认的管道文件&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;find / -&lt;span&gt;type&lt;/span&gt; p&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到CentOS 7.9系统默认存在一些管道文件&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;/run/dmeventd-client&lt;br/&gt;/run/dmeventd-server&lt;br/&gt;/run/systemd/ask-password-block/136:4&lt;br/&gt;/run/systemd/sessions/1.ref&lt;br/&gt;/run/systemd/initctl/fifo&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;验证上面的管道文件，有一个可以利用&lt;/p&gt;&lt;p&gt;&lt;code&gt;echo 1 &amp;gt; /run/systemd/ask-password-block/136:4&lt;/code&gt;  会阻塞&lt;/p&gt;&lt;p&gt;这个文件在其他系统文件名略微有点不同，并且只有root用户可以读写&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;另一个CentOS7.9: /run/systemd/ask-password-block/136:0&lt;br/&gt;ubuntu：/run/systemd/ask-password-block/136:2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;小结：可以用 /run/systemd/ask-password-block/136:{id} 文件来探测是否存在文件写漏洞，前提是服务有root权限&lt;/p&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;/dev/tcp/{host}/{ip}&lt;/p&gt;&lt;p&gt;在bash反弹shell中会用到这个。&lt;/p&gt;&lt;p&gt;它不是文件，只是bash解释器会对/dev/tcp对特殊处理，代表了一个tcp socket。&lt;/p&gt;&lt;p&gt;所以它不满足需求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;socket文件&lt;/p&gt;&lt;p&gt;操作socket文件不是open、write、close这一套流程，所以肯定不行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以用 /run/systemd/ask-password-block/136:{id} 文件来探测是否存在文件写漏洞，如果存在延时就可能存在写文件漏洞。前提是服务有root权限。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，感谢和我讨论这个小问题的朋友。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef525fadaeac5c2e35acd5e3b78dec9c</guid>
<title>Java 并发：线程池篇（附场景分析）</title>
<link>https://toutiao.io/k/0nsf6pk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：汤圆&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人博客：javalover.cc&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们在创建线程时，都是直接new Thread()；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样短期来看是没有问题的，但是一旦业务量增长，线程数过多，就有可能导致内存异常OOM，CPU爆满等问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，Java里面有线程池的概念，而线程池的核心框架，就是我们今天的主题，Executor&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，就让我们一起畅游在Java线程池的海洋中吧&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本节会用银行办业务的场景来对比介绍线程池的核心概念，这样理解起来会很轻松&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor是线程池的核心框架；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和它相对应的有一个辅助工厂类Executors，这个类提供了许多工厂方法，用来创建各种各样的线程池，下面我们先看下几种常见的线程池&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 容量固定的线程池&lt;/span&gt;&lt;br/&gt;Executor fixedThreadPool = Executors.newFixedThreadPool(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 容量动态增减的线程池&lt;/span&gt;&lt;br/&gt;Executor cachedThreadPool = Executors.newCachedThreadPool();&lt;br/&gt;&lt;span&gt;// 单个线程的线程池&lt;/span&gt;&lt;br/&gt;Executor singleThreadExecutor = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;span&gt;// 基于调度机制的线程池（不同于上面的线程池，这个池创建的任务不会立马执行，而是定期或者延时执行）&lt;/span&gt;&lt;br/&gt;Executor scheduledThreadPool = Executors.newScheduledThreadPool(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这些线程池的区别主要就是线程数量的不同以及任务执行的时机&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们开始吧&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;文章如果有问题，欢迎大家批评指正，在此谢过啦&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;目录&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池的底层类&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为啥阿里不建议使用 Executors来创建线程池？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池的生命周期 &lt;code&gt;ExecutorService&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 线程池的底层类 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章开头创建的几个线程池，内部都是有调用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;这个类的，如下所示&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br/&gt;                                  &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                  &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个类是Exexutor的一个实现类，关系图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47479674796747967&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v77AUzf8ElsfJhQVH0bJ7lI2z0garn26N0gMDZFzriaVAR10VmzeaIeHCq9PTLDoAPXXjCLHLfKQk3NKvfe30hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;615&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其中Executors就是上面介绍的辅助工厂类，用来创建各种线程池&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接口ExecutorService是Executor的一个子接口，它对Executor进行了扩展，原有的Executor只能执行任务，而ExecutorService还可以管理线程池的生命周期（下面会介绍）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们先来介绍下这个底层类，它的完整构造参数如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize,&lt;br/&gt;                          &lt;span&gt;int&lt;/span&gt; maximumPoolSize,&lt;br/&gt;                          &lt;span&gt;long&lt;/span&gt; keepAliveTime,&lt;br/&gt;                          TimeUnit unit,&lt;br/&gt;                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;br/&gt;                          ThreadFactory threadFactory,&lt;br/&gt;                          RejectedExecutionHandler handler)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍这些参数之前，我们可以先举个生活中的例子-去银行办业务；然后对比着来理解，会比较清晰&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v77AUzf8ElsfJhQVH0bJ7lI2z0garn26Oq1qxZRZ95ACDzaK9u22PRHrnPGM5aVTp0WuicaTTMQGgELbgQbyzsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图中绿色的窗口表示一直开着）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize：&lt;strong&gt;核心线程数&lt;/strong&gt;，就是一直存在的线程（不管用不用）；=》&lt;strong&gt;窗口的1号窗和2号窗&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize：&lt;strong&gt;最大线程数&lt;/strong&gt;，就是最多可以创建多少个线程；=》&lt;strong&gt;窗口的1，2，3，4号窗&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime：&lt;strong&gt;多余的线程&lt;/strong&gt;（最大线程数 减去 核心线程数）&lt;strong&gt;空闲时存活的时间&lt;/strong&gt;；=》&lt;strong&gt;窗口的3号窗和4号窗空闲的时间&lt;/strong&gt;,如果超过keepAliveTime，还没有人来办业务，那么就会暂时关闭3号窗和4号窗&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue: &lt;strong&gt;工作队列&lt;/strong&gt;，当核心线程数都在执行任务时，再进来的任务就会添加到工作队列中；=》&lt;strong&gt;椅子&lt;/strong&gt;，客户等待区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadFactory：&lt;strong&gt;线程工厂&lt;/strong&gt;，用来创建初始的核心线程，下面会有介绍；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;handler：&lt;strong&gt;拒绝策略&lt;/strong&gt;，当所有线程都在执行任务，且工作队列也满时，再进来的任务就会被执行拒绝策略（比如丢弃）；=》&lt;strong&gt;左下角的那个小人&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本的工作流程如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.12008978675645342&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v77AUzf8ElsfJhQVH0bJ7lI2z0garn26jdvqxqZZBvxbEYUFdJj5HBF3K9XSsFBBicAPJaTBFCnVUvrpuYicHLcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的参数我们着重介绍下工作队列和拒绝策略，线程工厂下面再介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作队列：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数组阻塞队列，这个队列是一个&lt;strong&gt;有界队列&lt;/strong&gt;，遵循FIFO，尾部插入，头部获取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始化时需指定队列的容量 capacity&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类比到上面的场景，就是&lt;strong&gt;椅子的数量为初始容量capacity&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;链表阻塞队列，这是一个&lt;strong&gt;无界队列&lt;/strong&gt;，遵循FIFO，尾部插入，头部获取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始化时可不指定容量&lt;/strong&gt;，此时默认的容量为Integer.MAX_VALUE，基本上相当于无界了，此时队列可一直插入（如果处理任务的速度小于插入的速度，时间长了就有可能导致OOM)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类比到上面的场景，就是&lt;strong&gt;椅子的数量为Integer.MAX_VALUE&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同步队列，阻塞队列的特殊版，即没有容量的阻塞队列，随进随出，不做停留&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类比到上面的场景，就是&lt;strong&gt;椅子的数量为0&lt;/strong&gt;，来一个人就去柜台办理，如果柜台满了，就拒绝&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;PriorityBlockingQueue&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优先级阻塞队列，这是一个无界队列，不遵循FIFO，而是根据任务自身的优先级顺序来执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化可不指定容量，默认11（既然有容量，怎么还是无界的呢？因为它添加元素时会进行扩容）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类比到上面的场景，就是新来的可以插队办理业务，好比各种会员&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拒绝策略：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AbortPolicy（默认）：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;中断策略，抛出异常 RejectedExecutionException；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数达到最大，且工作队列也满，此时再进来任务，则抛出 RejectedExecutionException（系统会停止运行，但是不会退出）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;DiscardPolicy：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;丢弃策略，丢掉新来的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数达到最大，且工作队列也满，此时再进来任务，则直接丢掉（看任务的重要程度，不重要的任务可以用这个策略）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;DiscardOldestPolicy：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;丢弃最旧策略，丢掉最先进入队列的任务（有点残忍了），然后再次执行插入操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数达到最大，且工作队列也满，此时再进来任务，则直接丢掉队列头部的任务，并再次插入任务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;CallerRunsPolicy：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;回去执行策略，让新来的任务返回到调用它的线程中去执行（比如main线程调用了executors.execute(task)，那么就会将task返回到main线程中去执行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数达到最大，且工作队列也满，此时再进来任务，则直接返回该任务，到调用它的线程中去执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 为啥阿里不建议使用 Executors来创建线程池？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原话如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3033292231812577&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v77AUzf8ElsfJhQVH0bJ7lI2z0garn26AuKZ2fH679pO8QjJLOADCHNHHCdJ3s9gHr8rjF2xeabUZHUxqT0tkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;811&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以写几个代码来测试一下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先测试FixedThreadPool，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FixedThreadPoolDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 创建一个固定容量为10的线程池，核心线程数和最大线程数都为10&lt;/span&gt;&lt;br/&gt;        ExecutorService executorService = Executors.newFixedThreadPool(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1_000_000&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;                executorService.execute(()-&amp;gt;{&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            }&lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们需对VM参数做一点修改，让问题比较容易复现&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示，我们添加&lt;code&gt;-Xmx8m -Xms8m&lt;/code&gt;到VM option中(-Xmx8m：JVM堆的最大内存为8M， -Xms8m，JVM堆的初始化内存为8M)：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6318681318681318&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/v77AUzf8ElsfJhQVH0bJ7lI2z0garn26NoC1ibLp4OSv3CrJOGAOia8JkG4stFGXwhXnEFTrhhmbIbkbibUHo9IVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时点击运行，就会发现报错如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.OutOfMemoryError: Java heap space&lt;br/&gt; at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:&lt;span&gt;416&lt;/span&gt;)&lt;br/&gt; at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:&lt;span&gt;1371&lt;/span&gt;)&lt;br/&gt; at com.jalon.concurrent.chapter6.FixedThreadPoolDemo.main(FixedThreadPoolDemo.java:&lt;span&gt;21&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来分析下原因&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，newFixedThreadPool内部用的工作队列为LinkedBlockingQueue，这是一个无界队列（容量最大为Integer.MAX_VALUE，基本上可一直添加任务）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果任务插入的速度，超过了任务执行的速度，那么队列肯定会越来越长，最终导致OOM&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CachedThreadPool也是类似的原因，只不过它是因为最大线程数为Integer.MAX_VALUE；&lt;/p&gt;&lt;p&gt;所以当任务插入的速度，超过了任务执行的速度，那么线程的数量会越来越多，最终导致OOM&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们要怎么创建线程池呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用ThreadPoolExecutor来自定义创建，通过为最大线程数和工作队列都设置一个边界，来限制相关的数量，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadPoolExecutorDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ExecutorService service = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;br/&gt;                &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;// 核心线程数&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;// 最大线程数&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;60L&lt;/span&gt;, &lt;span&gt;// 空闲时间&lt;/span&gt;&lt;br/&gt;                TimeUnit.MILLISECONDS,&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;// 数组工作队列，长度1&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardPolicy()); &lt;span&gt;// 拒绝策略：丢弃&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1_000_000&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;// 通过这里的打印信息，我们可以知道循环了3次&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 原因就是第一次的任务在核心线程中执行，第二次的任务放到了工作队列，第三次的任务被拒绝执行&lt;/span&gt;&lt;br/&gt;            System.out.println(i);&lt;br/&gt;            service.execute(()-&amp;gt;{&lt;br/&gt;                &lt;span&gt;// 这里会报异常，是因为执行了拒绝策略（达到了最大线程数，队列也满了，此时新进来的任务就会执行拒绝策略）&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 这里需要注意的是，抛出异常后，代码并不会退出，而是卡在异常这里，包括主线程也会被卡住(这个是默认的拒绝策略）&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 我们可以用其他的拒绝策略，比如DiscardPolicy,此时代码就会继续往下执行&lt;/span&gt;&lt;br/&gt;                System.out.println(Thread.currentThread().getName());&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;主线程 sleep &quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 线程池的生命周期 &lt;code&gt;ExecutorService&lt;/code&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Executor接口默认只有一个方法&lt;code&gt;void execute(Runnable command);&lt;/code&gt;，用来执行任务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务一旦开启，我们就无法再去插手了，比如停止、监控等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就需要ExecutorService登场了，它是Executor的一个子接口，对其进行了扩展，方法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ExecutorService&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Executor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 优雅地关闭，这个关闭会持续一段时间，以等待已经提交的任务去执行完成（但是在shutdown之后提交的任务会被拒绝）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;List&amp;lt;Runnable&amp;gt; &lt;span&gt;shutdownNow&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span&gt;// 粗暴地关闭，这个关闭会立即关闭所有正在执行的任务，并返回工作队列中等待的任务&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isShutdown&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isTerminated&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 用来等待线程的执行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果在timeout之内，线程都执行完了，则返回true；&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果等了timeout，还没执行完，则返回false；&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果timeout之内，线程被中断，则抛出中断异常&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;awaitTermination&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &amp;lt;T&amp;gt; &lt;span&gt;Future&amp;lt;T&amp;gt; &lt;span&gt;submit&lt;/span&gt;&lt;span&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;   &lt;br/&gt;    &amp;lt;T&amp;gt; &lt;span&gt;Future&amp;lt;T&amp;gt; &lt;span&gt;submit&lt;/span&gt;&lt;span&gt;(Runnable task, T result)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看到，线程池的生命周期分三步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;运行：创建后就开始运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭：调用shutdown进入关闭状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;已终止：所有线程执行完毕&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程池的底层类 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;：核心概念就是核心线程数、最大线程数、工作队列、拒绝策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为啥阿里不建议使用 Executors来创建线程池？：因为会导致OOM，解决办法就是自定义&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;，为最大线程数和工作队列设置边界&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池的生命周期&lt;code&gt;ExecutorService&lt;/code&gt;：运行状态（创建后进入）、关闭状态（shutdown后进入）、已终止状态（所有线程都执行完成后进入）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;《Java并发编程实战》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《实战Java高并发》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;newFixedThreadPool的弊端：https://my.oschina.net/langwanghuangshifu/blog/3208320&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;银行办业务的场景参考：https://b23.tv/ygGjTH&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后记&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;愿你的意中人亦是中意你之人&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>