<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>574bc471af56d4ad463856ccd92b64bb</guid>
<title>Go 设计模式（二十四）：总结</title>
<link>https://toutiao.io/k/ch4mr21</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot; id=&quot;post-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;原本预计是在十月底更新完毕这个系列，到今天是 11-05，晚了几天，不过也还好，这是第一次这么密集的去更新博客上的内容，更多的是以笔记的形式来呈现，加上这篇一共 24 篇文章差不多两个半月的时间，平均每周输出两篇，感觉还是不错。后续可能会视情况不定期的更新一些实战内容，也有可能没有。接下来下一个系列应该是数据结构与算法，包含对 Go 中一些底层数据和标准库包的学习，例如 slice, sort 等等。&lt;/p&gt;&lt;p&gt;话说回来，回头再看学习设计模式我们究竟需要学习一些什么？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;写 Go 需要使用到设计模式么？&lt;ul&gt;&lt;li&gt;需要，但是切记请勿使用其他语言的方式来写 Go&lt;/li&gt;&lt;li&gt;如果看过之前的一些文章，就会发现类似 JAVA 的这些面向对象语言中的某些设计模式的写法在 Go 中会十分的别扭&lt;/li&gt;&lt;li&gt;但是 Go 不需要设计模式么？不是的，设计模式的思想是想通的，并且我们一直都在使用，例如我们常见的对象创建方式 &lt;code&gt;NewXXX&lt;/code&gt; 这其实就是一个简单工厂&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;设计模式学习的重点是什么？&lt;ul&gt;&lt;li&gt;设计原则，以及设计模式的使用场景和优缺点，实现相对来说还没有那么重要&lt;/li&gt;&lt;li&gt;如果是常见的设计模式是武术招式，那么设计原则就是内功心法，没有内功心法那么招式套路也就是花架子&lt;/li&gt;&lt;li&gt;熟练掌握不同设计模式的使用场景可以帮助我们学会见招拆招，灵活应用而不是只会套路&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;最后设计模式不是银弹，不要拿着 🔨 就觉得哪里都像是钉子，不要过早优化，持续重构才是正道&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;/&gt;设计原则&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;同时这也是 Code Review 的重要标准之一&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1604555465270-6b839dae-3cc4-43e8-bcad-b46ee314f0f7.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;/&gt;设计模式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1604555469082-5a1887e1-5640-4895-a018-8541ba78139e.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;Go-设计模式&quot;&gt;&lt;a href=&quot;#Go-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Go 设计模式&quot;/&gt;Go 设计模式&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;单例模式包含饿汉式和懒汉式两种实现&lt;/li&gt;&lt;li&gt;工厂模式包含简单工厂、工厂方法、抽象工厂、DI 容器&lt;/li&gt;&lt;li&gt;代理模式包含静态代理、动态代理（采用 go generate 模拟）&lt;/li&gt;&lt;li&gt;观察者模式包含观察者模式、eventbus&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8da2a8df84a6b9b9002f8b56da3b568f</guid>
<title>Hugo 之旅</title>
<link>https://toutiao.io/k/5ubz2q0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cont&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimg.com/t013d5132596de74ff5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前写了篇文章&lt;a href=&quot;https://imnerd.org/blog-migrate-to-hugo.html&quot;&gt;《博客迁移至 Hugo》&lt;/a&gt;，提了下使用 Typecho 多年后越发感受到运维的成本之高后，将博客迁移到了静态博客程序 Hugo 下。使用 &lt;a href=&quot;https://vercel.com&quot;&gt;Vercel&lt;/a&gt; + &lt;a href=&quot;https://github.com&quot;&gt;Github&lt;/a&gt; 可以免费搭建高性能博客，绑定域名还能自动帮忙创建 SSL 证书。当然偷懒的话也可以直接使用默认分配的二级域名。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-475&quot; class=&quot;anchor&quot; href=&quot;#toc-475&quot;/&gt;搭建&lt;/h2&gt;
&lt;a href=&quot;https://vercel.com/import/select-scope?s=https%3A%2F%2Fgithub.com%2Fvercel%2Fvercel%2Ftree%2Fmaster%2Fexamples%2Fhugo&amp;amp;template=hugo&amp;amp;id=67753070&quot; target=&quot;_vercel&quot;&gt;
  &lt;img src=&quot;https://vercel.com/button&quot; alt=&quot;创建 Hugo 博客&quot;/&gt;
&lt;/a&gt;

&lt;p&gt;点击上面的按钮快速抵达创建页面，未登录的会需要登录，这块直接使用 Github 登录即可。登录后第一步会让你选择 Vercel 账号，这里直接选择 &lt;code&gt;Personal Account&lt;/code&gt; 即可。之后会让你输入仓库名称，Vercel 会自动帮你创建并初始化该仓库。如果你的仓库不想让其它人看的话，这里可以勾选 &lt;code&gt;Private Git Repository&lt;/code&gt; 创建私有仓库。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://p3.ssl.qhimg.com/t010f5f1b79795f0eea.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一步这块会让你输入 Vercel 中项目的名称和一些配置。这里需要注意一下，官方提供的默认 Hugo 编译命令会把草稿文章也生成出来。需要在 &lt;code&gt;BUILD COMMAND&lt;/code&gt; 那打开 OVERRIDE 按钮后输入 &lt;code&gt;hugo --gc&lt;/code&gt; 进行覆盖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.ssl.qhimg.com/t0192e198b383471a87.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍等片刻之后，你就可以看到飘着满屏的彩带庆祝你创建博客成功叻！点击 &lt;code&gt;Visit&lt;/code&gt; 按钮你就可以看到你的博客的样子了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p5.ssl.qhimg.com/t01672bbd54b1afc7f5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于是静态博客，你所有的文章都会存储在你刚才新建的仓库中。你可以选择将仓库下来修改后提交，也可以利用 Github 的在线编辑功能在线修改提交。提交之后 Vercel 会自动触发更新，重新构建并更新你的博客。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-224&quot; class=&quot;anchor&quot; href=&quot;#toc-224&quot;/&gt;配置&lt;/h2&gt;
&lt;p&gt;默认每次提交 Vercel 构建完成之后都会把构建后的地址评论在你的 Github 提交下。你可以通过设置关闭该功能。另外默认 Vercel 指定的 Hugo 版本比较老了，在 Markdown 编译过程中会发生一些异常的行为。我们可以通过配置指定最新的 Hugo 版本进行编译。在项目根目录下新建 &lt;code&gt;vercel.json&lt;/code&gt; 文件，并加入以下内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;github&quot;: {
    &quot;silent&quot;: true
  },
  &quot;build&quot;: {
    &quot;env&quot;: {
      &quot;HUGO_VERSION&quot;: &quot;0.78.1&quot;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hugo 博客本身的配置都在 &lt;code&gt;config.toml&lt;/code&gt; 下。默认情况下 Hugo 生成的 URL 都是 &lt;code&gt;/posts/hello-world/&lt;/code&gt; 这种格式，不过之前做动态博客为了做伪静态，一般都将路由设置成了 &lt;code&gt;/hello-world.html&lt;/code&gt; 这种格式。这种时候就需要在 &lt;code&gt;config.toml&lt;/code&gt; 中增加 &lt;a href=&quot;https://gohugo.io/content-management/urls/#ugly-urls&quot;&gt;uglyurls&lt;/a&gt; 配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;uglyurls = true
[permalinks]
  posts = &quot;:slug&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面的 &lt;code&gt;permalinks&lt;/code&gt; 配置主要是用来去除文章的 &lt;code&gt;/posts&lt;/code&gt; 前缀的。除此之外，默认的配置文章中的 HTML 是会被转义的，对于我这种偶尔会在 Markdown 中写 HTML 的人来说操作有点多余。这时候可以在配置中定义它不转义。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[markup.goldmark.renderer]
  unsafe= true&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;toc-190&quot; class=&quot;anchor&quot; href=&quot;#toc-190&quot;/&gt;域名&lt;/h2&gt;
&lt;p&gt;使用 Vercel 搭建的网站，它会默认提供一个 &lt;code&gt;*.vercel.app&lt;/code&gt; 的二级域名，你可以直接使用这个域名访问网站。如果你想要绑定自己的域名，也可以在后台设置。进入网站后选择自己的项目，选择 &lt;kbd&gt;Settings&lt;/kbd&gt; - &lt;kbd&gt;Domains&lt;/kbd&gt; 进入域名配置界面，在输入框中添加自己的域名。它会提示你需要给域名增加 A 记录或者是 CNAME 解析。按照提示添加后后台会自动检测是否生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3.ssl.qhimg.com/t01c2a5a632902bd5fe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生效的时间视 DNS 服务器的生效时间而定，我这边使用 DNSPod 还挺快的，大概 30 秒之内就生效了。生效后 Vercel 会自动帮我们申请配置 SSL 证书，我们全然不用操心证书的问题。等待片刻之后我们就能直接使用新域名进行访问了。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-20d&quot; class=&quot;anchor&quot; href=&quot;#toc-20d&quot;/&gt;图片&lt;/h2&gt;
&lt;p&gt;默认所有的静态资源都放在 &lt;code&gt;static/&lt;/code&gt; 目录下。你可以将图片放在该目录下，例如 &lt;code&gt;static/hello-world.jpg&lt;/code&gt;。在文章中则直接使用 &lt;code&gt;/hello-world.jpg&lt;/code&gt; 地址引用即可。&lt;/p&gt;
&lt;p&gt;由于 Github 仅有单文件小于 100M 的&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/github/managing-large-files/what-is-my-disk-quota#file-and-repository-size-limitations&quot;&gt;限制&lt;/a&gt;，Vercel 会将所有的资源部署到自己服务器上。所以使用仓库存储的方式会非常方便和安全，而且还不损失速度。唯一美中不足的是，由于是 HTTP 路径，在本地编写文章的时候会不方便。如果是使用 Typora 的话可以点击标签栏 &lt;kbd&gt;格式&lt;/kbd&gt; - &lt;kbd&gt;图像&lt;/kbd&gt; - &lt;kbd&gt;设置图片根目录&lt;/kbd&gt; 将目录指定到 &lt;code&gt;static/&lt;/code&gt; 目录解决。VSCode 的话暂时没有倒腾出来。&lt;/p&gt;
&lt;p&gt;其实比较好的方案是建议大家创建一个文件夹，将该篇文章和它所用到的图片都归置到一块。使用类似组件化的思路管理内容，会更加方便后续的修改。&lt;/p&gt;
&lt;p&gt;除了使用本地存储之外，你也可以选择使用第三方的存储服务。免费服务的话可以试试 &lt;a href=&quot;https://www.upyun.com/league&quot;&gt;又拍云&lt;/a&gt; 提供的联盟计划，按照要求申请下即可。其他家的存储服务要么免费时间有限，要么有部分收费功能。第三方存储的好处在于带有 CDN 加速，在速度上会很方便。但目前 Vercel 的速度我觉得还挺不错的，所以最终还是选择了直接存仓库。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-553&quot; class=&quot;anchor&quot; href=&quot;#toc-553&quot;/&gt;评论&lt;/h2&gt;
&lt;p&gt;使用静态博客之后，评论则只能选择第三方评论系统了。鉴于国情，国内的第三方评论服务都已名存实亡。目前比较知名的 &lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt; , &lt;a href=&quot;https://www.hypercomments.com/&quot;&gt;HyperComments&lt;/a&gt; 以及 &lt;a href=&quot;https://www.livere.com/&quot;&gt;来必力&lt;/a&gt; 都是国外的服务。HyperComments 是付费的服务就不多做讨论，Disqus 是老牌服务，提供了强大的 API 对开发者较为友好。来必力则是对国内用户友好，集成了很多国内的社交账号登录。&lt;/p&gt;
&lt;p&gt;除了专门提供评论的第三方服务之外，也有一部分是选择自建评论服务。其中比较知名的是 &lt;a href=&quot;https://valine.js.org/&quot;&gt;Valine&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt; 以及 &lt;a href=&quot;https://staticman.net/&quot;&gt;Staticman&lt;/a&gt;，&lt;a href=&quot;https://posativ.org/isso/&quot;&gt;isso&lt;/a&gt;。Staticman 提供了强大的 API 但是缺少界面，isso 则是需要服务器部署，偏离了我使用静态博客的初衷就是不想维护服务器的目的，所以这两者都不多做讨论。Gitalk 是使用 Github issue 进行评论数据存储的评论脚本，适合纯技术博客和极客使用。Valine 则是基于&lt;a href=&quot;https://leancloud.app/&quot;&gt;LeanCloud&lt;/a&gt; Serverless 云存储进行评论数据存储的评论脚本，同时它还带有漂亮的外观，适合各类人群使用。&lt;/p&gt;
&lt;p&gt;博客站点上与评论相关的地方一般有三个地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首页显示最近评论&lt;/li&gt;
&lt;li&gt;文章下显示当前文章评论数&lt;/li&gt;
&lt;li&gt;文章底部显示该文章的评论列表以及输入框&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最开始我选择了 Disqus 作为本站的评论系统。但是它有个问题国内正常无法访问。后来我发现 Hugo 的模板中是可以使用 &lt;code&gt;getJSON&lt;/code&gt; 方法调取接口的。而 Vercel 的机器本身就在海外，那我实际上可以在博客编译阶段就获取到输入写到页面中。最近评论和评论数的显示还是比较简单的，而评论列表的显示则需要折腾一下了。不过 Disqus API 的使用频率是 1000 次/小时，当短时间部署频繁的话可能会有超过的风险。而且发布评论的接口没办法走该逻辑，还是需要一个代理服务。&lt;/p&gt;
&lt;p&gt;最终让我决定不使用 Disqus 的原因是它的评论没办法让评论者输入网站地址，评论列表中的评论者昵称点击也无法跳转到用户输入的网站中。这对于有着大量的老式评论数据的我来说是不太能接受的。所以基于这些种种原因，我最后又将评论迁移到了 Valine 下。&lt;/p&gt;
&lt;p&gt;我对 Valine 的主要问题在于两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;早前使用 Valine 的时候发现了大量的 XSS 漏洞&lt;/li&gt;
&lt;li&gt;荒野无灯大大反馈的“&lt;a href=&quot;https://ttys3.net/post/hugo/please-stop-using-valine-js-comment-system-until-it-fixed-the-privacy-leaking-problem/&quot;&gt;泄露用户隐私问题&lt;/a&gt;”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上两个是非常重要的安全问题，不过我看 XSS 的问题作者已经修复，实际上对用户输入的所有 HTML 内容进行转义可以规避该问题。而灯大反馈的 IP 泄露的问题，作者也通过不记录 IP 来规避该问题。这两个问题造成的原因其实还是因为 &lt;strong&gt;Serverless&lt;/strong&gt; 。因为我想直接在编译的时候将相关数据静态化，所以我势必是需要增加一个服务端来帮我进行接口的封装，最后也能规避这些问题。&lt;/p&gt;
&lt;p&gt;不过 Valine 不知因为什么原因不开放源码，只在 Github 提供编译后代码，这点除了让我比较无语之外，改造工作也比较慢。本来我只需要将它 UI 中调用 LeanCloud API 的逻辑替换成我的接口逻辑即可。但是因为没有源码，只能自己重新制作 UI 了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新：基于 Valine 衍生的带后端评论系统已经完成 &lt;a href=&quot;https://github.com/lizheming/waline&quot;&gt;https://github.com/lizheming/waline&lt;/a&gt; 已切换至该评论系统。2020/11/08&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id=&quot;toc-e5f&quot; class=&quot;anchor&quot; href=&quot;#toc-e5f&quot;/&gt;搜索&lt;/h2&gt;
&lt;p&gt;缺少服务端之后，静态博客的搜索功能也无法自己完成。目前比较知名的是第三方搜索服务 &lt;a href=&quot;https://www.algolia.com/&quot;&gt;Agolia&lt;/a&gt;，提供了免费的文章索引和搜索的功能。除了使用第三方服务之外，还发现有一种比较简单的做法就是将所有数据生成到一个文件中，前端下载该文件进行搜索结果展示。这里头比较知名的是 &lt;a href=&quot;https://www.npmjs.com/package/fuse&quot;&gt;fuse&lt;/a&gt;，它是一个 JS 模块，将输入传入之后它能帮我们快速的匹配到命中结果。&lt;/p&gt;
&lt;p&gt;目前本站使用的是后一种方法，该方法的优点是不依赖第三方服务，自己就能完成搜索功能。缺点是第一次搜索的时候需要下载完整的数据，对文章比较多的网站用户鸭梨会比较大。使用第二种方法第一步是需要先创建全量的数据索引，通过以下配置告知 Hugo 编译时创建 &lt;code&gt;index.json&lt;/code&gt; 索引文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[outputs]
  home = [&quot;HTML&quot;, &quot;RSS&quot;, &quot;JSON&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然我们还需要为新的数据编写生成的模板文件，在 &lt;code&gt;layouts/&lt;/code&gt; 下增加 &lt;code&gt;index.json&lt;/code&gt; 文件，并加入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-clojure&quot;&gt;{{- $.Scratch.Add &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;&lt;/span&gt; slice -}}
{{- range .Site.RegularPages -}}
    {{- $.Scratch.Add &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;dict&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;&lt;/span&gt; .Title &lt;span class=&quot;hljs-string&quot;&gt;&quot;contents&quot;&lt;/span&gt; .Plain  &lt;span class=&quot;hljs-string&quot;&gt;&quot;summary&quot;&lt;/span&gt; .Summary &lt;span class=&quot;hljs-string&quot;&gt;&quot;permalink&quot;&lt;/span&gt; .Permalink &lt;span class=&quot;hljs-string&quot;&gt;&quot;date&quot;&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;.Date.Format&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;2006年01月02日&quot;&lt;/span&gt;)) -}}
{{- end -}}
{{- $.Scratch.Get &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot;&lt;/span&gt; | jsonify -}}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;dict&lt;/code&gt;后的字典可以添加多个字段，视你 JS 渲染脚本中需要的字段而定。完成这些之后 Hugo 编译就会生成 &lt;code&gt;index.json&lt;/code&gt; 文件了。&lt;/p&gt;
&lt;p&gt;最后我们需要增加一个搜索页面，该页面会先加载 &lt;code&gt;index.json&lt;/code&gt; 然后使用 &lt;code&gt;fuse&lt;/code&gt; 进行数据查找，最后渲染成 HTML 输出搜索结果。具体的代码可以直接查看源码 &lt;a href=&quot;https://imnerd.org/search.html?q=hugo&quot;&gt;https://imnerd.org/search.html?q=hugo&lt;/a&gt; 参考本站的搜索页。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//以下为示例代码
let fuse;
async function search(text) {
  if(!fuse) {
    const indexData = await fetch(&#x27;/index.json&#x27;, {method: &#x27;GET&#x27;}).then(resp =&amp;gt; resp.json());
    fuse = new Fuse(indexData, {...});
  }
  const result = fuse.search(text);
  renderHTML(result, &#x27;#app&#x27;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;toc-5a0&quot; class=&quot;anchor&quot; href=&quot;#toc-5a0&quot;/&gt;其它&lt;/h2&gt;
&lt;p&gt;Hugo 静态博客能提供给我们发挥的空间非常多，比如说我参考 &lt;a href=&quot;https://imququ.com&quot;&gt;屈屈的博客&lt;/a&gt; 增加了一个博客文章发布 &amp;gt;180 天的话，就在文章详情页黄条提醒：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提醒：本文最后更新于 313 天前，文中所描述的信息可能已发生改变，请谨慎使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正常来说由于我没有服务端，所以只能使用前端来计算当前时间与发布时间的时间差。但其实转念一想，编译时也是可以拿到时间差的，只是这个时间差无法随着时间的变化而变化。不过我只要每天编译一次，就能解决变化的问题了。在 Vercel 项目 &lt;kbd&gt;Settings&lt;/kbd&gt; - &lt;kbd&gt;Git&lt;/kbd&gt; - &lt;kbd&gt;Deploy Hooks&lt;/kbd&gt; 中你可以输入 Hook 名称和触发分支创建一个 Hook URL。只要访问该 URL 就可以触发 Vercel 更新博客。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;{{ if eq .Type &quot;posts&quot; -}}
    {{ $ageDays := div (sub now.Unix .Date.Unix) 86400 }}
    {{ if gt $ageDays 180 }}
        &amp;lt;p class=&quot;expired-tips&quot;&amp;gt; 提醒：本文最后更新于&amp;amp;nbsp;{{$ageDays}}&amp;amp;nbsp;天前，文中所描述的信息可能已发生改变，请谨慎使用。&amp;lt;/p&amp;gt;
    {{ end }}
{{ end }}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 Vercel 的 Marketplace 中，有一个 &lt;a href=&quot;https://easycron.com/&quot;&gt;EasyCron&lt;/a&gt; 的服务提供了定时任务的功能。我在上面设置了每天零点访问 Hook URL 触发博客更新，就这样解决每天需要更新时间的问题。&lt;/p&gt;
&lt;p&gt;另外屈屈博客中的“查看本文Markdown版本”也是个不错的功能，在 Hugo 中也可以实现，本质是在编译的时候顺便生成一份 &lt;code&gt;.md&lt;/code&gt; 的 Markdown 文件即可。&lt;/p&gt;
&lt;p&gt;首先我们需要在 &lt;code&gt;layouts/&lt;/code&gt; 下增加 &lt;code&gt;single.md&lt;/code&gt; 文件，表示的是当文章页（Single）需要导出 &lt;code&gt;.md&lt;/code&gt; 的数据的时候使用该模板。模板内容不用填写，为空即可。然后在 &lt;code&gt;config.toml&lt;/code&gt; 中新增 &lt;code&gt;.md&lt;/code&gt; 文件类型，并告知 Hugo 文章需要增加编译 Markdown 文件类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[mediaTypes]
  [mediaTypes.&quot;text/plain&quot;]
    suffixes = [&quot;md&quot;]

[outputFormats.MarkDown]
  mediaType = &quot;text/plain&quot;
  isPlainText = true
  isHTML = false

[outputs]
  page = [&quot;HTML&quot;, &quot;MarkDown&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7185f385817be0ab117714f321551cda</guid>
<title>人生是一个回环：我的十年安全工作总结</title>
<link>https://toutiao.io/k/41asxjm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;span lang=&quot;EN-US&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5462962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kYREiceLybrhgkMKyuu37uUVDzG87Djz0ZOiba8GWhwy50bd2TnMiciaxhDukaC2PLhjia0OiaxawY2oK9JibKtA9F8fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;“大家好！&lt;/span&gt;&lt;span&gt;我是李雪琴……”，自去年起，那个北大毕业的“最土”女生火了。&lt;/span&gt;&lt;span&gt;近期，听到她在脱口秀大会讲她妈妈的“哲学”理论：&lt;/span&gt;&lt;span&gt;宇宙也有终点，终点在人生的起点；&lt;/span&gt;&lt;span&gt;看到她先从“人生的起点”来北京赴学，再回到“人生的起点”，这次又离开起点出来闯荡。&lt;/span&gt;&lt;span&gt;心里颇有感触，在“宇宙终点”之前，显然她的脚步还远没有停止。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;我的人生回环&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;大家好！我是叶猛，我又回到了北京，跟北京说声：“嗨！”。这次我用了自己的真名字。在这个名字之前，我还有一长串的昵称或称呼：梦晔、Monyer、梦之光芒、猛子、小叶、叶队、叶帅、叶师傅、叶支、猛队……，这些称呼伴随着我前十年工作生涯的各个阶段。梦晔是我的笔名，是我姓名的倒序，在那个年少轻狂且心中“文意纵横”的时代，看到老舍把自己的姓拆开做字，便有学有样起了这个笔名。Monyer是从梦晔的发音造出来的英文昵称，从高中起一直用到现在。梦之光芒是从梦晔拓展出来的中文昵称，因为“晔”就是光芒的意思。这个中文昵称先是从05年起作为《黑客防线》的投稿笔名，后是作为百度空间的博客名一直到空间关闭。猛子这个昵称主要是刚毕业后在B公司工作，大哥大姐们的亲切称呼；小叶是后来特招到某省公安厅后，领导们的“爱称”；叶队是在公安厅任某科室支队长后，兄弟单位及合作伙伴的称呼；叶师傅、叶帅是省厅同事间的敬称和戏称；叶支、猛队是来到Q公司后，组建起国内顶级实战攻防红队，大家的敬称。关于我的称呼曾有过很有意思的事情，曾有不少人认识网上的Monyer还加了QQ好友，也认识现实中的叶队，但却不知道这是一个人。所以今天我用我的真名字为自己代言，也算是第一个回环吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;听到宇宙的终点是人生的起点，我不禁莞尔，因为我也感觉人生是一个回环。称谓上的回环暂且不论，最近十年我又进行着另两个回环：一是从网络安全的甲方到监管方，再到乙方，又回到了甲方的回环；二是从沈阳到北京，到回沈阳，又回到北京的回环。我爱人说：你看你，兜兜转转，又转回去了。我说不然，虽然又转回去了，但能力变了、眼界变了、境遇也变了。如果用一个恰当的比较，这不是一个简单的循环，而是一个如同莫比乌斯带般的回环，虽然转了整整一圈，但已经站在了环的另外一面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近在和不少老板聊天时，都谈到了我的网络安全从业经历，也因此有了更多的感触。回顾是为了沉淀和畅想，总结是为了把握未来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的职业生涯从不同角度来看，算是既简单又惊奇。简单的原因是十余年工作经历全部是跟网络安全相关的，并且一共也只有3个东家。惊奇的原因则是恰好这3个东家覆盖了整个安全届的角色划分：甲方、监管和乙方，而且朋友同事听到我离开消息后，是一个比一个惊奇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？离开北京大公司回辽宁了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？公安厅支队长都不干了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？要抛家弃子回北京了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0462016881386051&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kYREiceLybrhgkMKyuu37uUVDzG87Djz0OH4icfUY9ibxSfXCdVCByKL80PA3hYJAp54q5L4AVCmX5E49BRxvp75g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2251&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（当别人告诉我，我的离职上了热门讨论，让大家震惊了一下，我还有些忍俊不禁。）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;甲方时代：安全是为业务服务的&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我甲方的工作经验，那就是：“安全是为业务服务的”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实去B公司是有着偶然因素和侥幸成分的。在去之前A公司曾邀请我去面试，不过去跟导员请假没有申请下来，就作罢了。等B公司找到我时，恰逢暑假，遂商定好只做暑期实习生。不过实习期间，所在团队给我很大触动，那是一个高效、团结、热情、专业的团队，值得我继续实习下去。于是我跟学院做了申请，整个大四都是在B公司度过的，顺利拿到Offer，毕业后的两年也一直在B公司。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我所在部门是当时处于创业状态下的电商团队，职位最开始是渗透测试工程师，主要是代码和业务层面的安全工作，前期一直是我一个人。那时敏捷开发还在尝试阶段，DevOps更是影儿都没有。系统还是版本制，上线时需要在半夜进行，停服维护。期间比较有意思的事儿是协助架构师做MVC 2.0框架设计，通过框架和系统架构天然防御常见漏洞，当然现在很多开源的MVC框架也都内置了安全防护功能。后来11年部门拆分，便到了基础平台架构部，负责公司产品线的安全测试、代码审计以及安全内训工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在工作中也慢慢发现，随着安全从业者能力的提升，在掌握更多安全知识和理念的过程中，很容易陷入脱离业务过度防御的误区。有时安全人员会有种系统到处都是漏洞无从下手的感觉，甚至认为系统功能的本身就是漏洞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Feature还是Bug这是一个问题！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这有点像我之前在知乎上回答的一个问题：某公司的安全人员认为手机验证码一定要是6位以上的，产品经理认为从易用性角度上一定要是4位的，于是就闹了很多矛盾。然而4位的验证码就一定不安全么？就没有更好的解决办法么？想当年支付密码必须要数字+大小写字母+特殊字符，要大于10位以上。而现如今，几乎所有支付应用的密码全部是6位纯数字，那么安全性是提升了，还是下降了呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全是为业务服务的。脱离了业务本身去谈安全是没意义的，过度强调安全而忽视了业务可用性也是无稽之谈。不考虑系统架构和网络运行情况，生搬硬套各种先进安全理念和安全框架，会浪费大量资源又达不到预期效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，这并不是说安全要无限制地为业务让路，而是说安全人员要时刻思考如何在尽量保证业务的前提下，去维护系统安全，要考虑安全与业务共生的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;皮之不存，毛将焉附？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;监管时代：技术是达成目标的一种手段&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我在网络监管单位的工作经验，那么就是：“技术是达成目标的一种手段”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时一些客观原因和机缘巧合，使我于11年底通过公务员特殊人才招募通道来到某省公安厅网安总队工作，一直到18年初离职为止。由于敏感性原因，工作内容暂且不谈。但这些年个人的成长和进步还是蛮大的，最重要的是在做人上有了长足的提高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用技术去辅助公安工作，可以起到四两拨千斤的效果。我举个的例子：譬如某舆情事件，领导的想法是通过统计分析得出关键线索。但统计分析的前提是数据的获取、处理、存储、分析和展示。随着事件的持续性发展，如果纯人工去做，那么投入成本会是时间线性增加的，甚至会出现人工分析赶不上事态发展速度的情况。而通过程序去做，则可以在更短的时间内获得更好的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是不是说技术就永远比传统手段更好用呢？也不尽然。从另外一个例子来看：如果拿到了犯罪嫌疑人的手机，还在想着用技术手段去破解开机密码，就没有那些公安老哥们直接从嫌疑人口中撬出密码来的方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然我只举两个很简单也不那么敏感的例子，实际上在这近7年的工作中，上百场战役和案件的侦办给我留下很深刻的认知：就是“技术是达成目标的一种手段”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网安的成功破案并不是在我们这种技术人员招进来后才有的，只不过我们给了网安多一种选择，有时则是一种更短的路径。而在工作中，包括体制内、甲方和乙方，也不应该总从纯技术角度去考虑问题，有时换一种思路会发现有更快更容易的解决途径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;乙方时代：打铁必须自身硬&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我在乙方的工作经验，那么就是：“打铁必须自身硬”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Q公司是目前网络安全toB领域的佼佼者。18年初我来Q公司时，它还没有自己的专业化红队。一些实战攻防演习任务的承接还要靠抽调各地渗透测试人员临时组队，人员战斗力以及演习排名均得不到保障。入职时，我在主管副总裁的引荐下，带着一个题为《专业化渗透团队可行性研究分析》的团队规划PPT赶赴北京见到了董事长。里面讲的就是要建立一支高精尖、能打胜仗的专业化渗透团队。汇报比较顺利，董事长最终同意给我5-6个HC来建设这样一支团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为这个团队主要是模拟黑客APT手段来开展工作业务，因此我从APT“高级持续性威胁”这个名词中借用了“高级”二字，从零开始组建了“高级攻防部”网络攻防实战团队。在团队建设过程中，我借鉴了体制内团队建设管理经验，以“队”为建制来组建红队，把每支红队的管理者称为“队长”，队内员工称之为“队员”，红队按区域做命名，譬如“成都队”、“南京队”、“沈阳队”、“杭州队”等。在接下来的两年中，队伍一直在向着最高效、最专业化的道路迈进。建设过程含辛茹苦暂且不谈，现如今高级攻防部已经是一支横跨全国三个大区，人数超过*0人的专业级红队，攻击队数量也从0增长到*支。每次工作任务都以攻击队为单位来开展，类似于特种部队中的作战单元。一支攻击队由*-*个人构成，以攻击队队长为技术及领导核心，团队成员各具打点、社工、内网等不同方向本领，大家协同作战。正如任正非所言：要把能力建立在组织上。这样的团队组成模式对于实战攻防演习及红队评估项目来说是最有战斗力的。我统计过去年（2019年）的全年实战演习项目，我们排名第一次数是76%，排名第二是24%（第三及以后没有），综合作战能力已经远远将友商团队甩到了后面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在部门的成长和管理过程当中，技术是我们的饭碗、能力是我们的本钱、排名是我们的荣誉。团队成员在技术能力、带队能力以及声望名气上均日新月异，长足提高。我们没有设立任何类似于996的工作制度，也不树立任何“舍己为人”的典型，但在项目中所有人都勇于吃苦耐劳、加班熬夜、奋战到底，因为大家都知道“打铁必须自身硬”，自身硬就是本钱，就是底气，就是话语权，是谁都拿不走的资本。前些日子，团队中某个毕业2年带队1年多的攻击队队长被某大型合资公司以高年薪挖走了，去做安全防护方面的负责人，还给配车。在不舍的同时，我也感到十分欣慰，有着沉甸甸的满足感，感觉团队没白带，人没看错也没白培养。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多管理者怕人员流动，其实正常的人员流动对于团队和个人都有着好处。对于团队所有人员，我一直在宣贯着我称之为“技术人员发展四阶段”的成长路线：技术输出、经验输出、思路输出和决策输出（这个上一篇公众号也有详细地说明）。我希望从我团队走出的技术人员能成为外面的技术Leader，技术Leader能成为外面的技术经理，技术经理能成为技术总监。在日常的团队管理中，我也会尽量为大家提供能够向下一阶段发展的舞台和平台，给大家锻炼成长的机会。我认为这样的团队氛围才是健康的，对于团队成员来说才是负责任的，这也是自身硬的表现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;坚守梦想，持续奋斗&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;最近“刘备”那段“接着奏乐，接着舞”火了，然而在这个梗之前“刘备”说了一句话：“我打了一辈子仗，就不能享受享受吗？”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以享受吗？当然可以！然而梦想达成了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于刘备来说，没有！对于我来说，也没有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么就远没有到可以享受的时候。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在机关单位后期的安逸并不是我想要的。很多人打破脑袋想要进机关，捧着铁饭碗“混机关”。但对我来说混的不是机关，混的是自己。铁饭碗不应该是某个单位，应该是自己的能力和本事。不能靠“混”的施舍，因为混着混着就到达“宇宙的终点”了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在乙方团队建成后的功成名就也不是我期望的状态。临走前有个大哥劝我说：如今团队已经建起来了，最难的时候都过去了，接下来可以养老了，只要大差不差干一干，可以活得比很多人都好。他说的都是真心话，我也都想到。但我还有追求，还想发展，还想做更多，还想做得更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如最近这个段子：“看到74岁与77岁的两个老人为了一份工作还争吵这么激烈，你的人生还有什么借口不努力呢？”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我的人生又经历了这一次回环：我又从乙方回到了甲方，我又从沈阳回到了北京。虽然岗位在变，城市在变，但奋斗的心没变。在接下来工作中，持续奋斗还是会贯穿我工作的始终。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仅以此文作为第一个十年工作的总结，也作为接下来工作的自勉吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感谢爱人的理解，朋友的支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也感谢屏幕前您的传阅，谢谢！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c43dc6428983c055f22b5d124bc860ff</guid>
<title>华东师范大学的数据库系统研究</title>
<link>https://toutiao.io/k/vjryow7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第421篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2020年 第45篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;93&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.9966329966329966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVLR21NicmyQxcmiaqQ2KOJJj2JLwgJL4KSbo7CcuMF1hLf4xFjGQiaDRhSPyERxWGChWYP47Oc4sKGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;【Top Talk/大咖说】由美团技术学院和科研合作部主办，面向全体技术同学，定期邀请美团资深技术专家、业界大咖、高校学者及畅销书作者，为大家分享最佳实践、互联网热门话题、学术界前沿技术进展等内容，帮助美团同学开拓视野、提升认知。&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;cpHY&quot;&gt;&lt;/p&gt;&lt;p line=&quot;cpHY&quot;&gt;&lt;span&gt;2020年10月27日，Top Talk邀请到了华东师范大学周烜老师，请他带来题为《华东师范大学的数据库系统研究》的分享。本文系周烜老师分享报告的文字版，希望能对大家有所帮助或者启发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4058823529411764&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTNV3hiab1rBLbv1KYiaxM1AibAKkZtEqSK6qzJVdq3lASpib6ZsKwGLfiaJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;170&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;/报告嘉宾/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p line=&quot;4ALq&quot;&gt;&lt;span&gt;&lt;strong&gt;周烜 | 华东师范大学教授，数据科学与工程学院副院长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;4ALq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;4ALq&quot;&gt;2001年本科毕业于复旦大学，2005年在新加坡国立大学取得博士学位，2005年至2010年期间先后在德国L3S研究中心和澳大利亚联邦科工组织从事科研工作，随后在中国人民大学信息学院任教6年，于2017年3月加入华东师范大学。研究兴趣包括数据库系统和信息检索技术。曾参与和负责多个国内外的科研项目和工业合作项目，积累了丰富的数据管理系统研发经验。研究成果被发表于众多国际一流的学术会议和期刊。凭借在分布式数据库领域的成果转化获得国家科技进步二等奖和教育部科技进步一等奖。入选教育部“新世纪优秀人才”支持计划。&lt;/p&gt;&lt;p line=&quot;4ALq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;&lt;span&gt;&lt;strong&gt;/报告摘要/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;华东师范大学是国内为数不多长期坚持数据库内核技术研究的高校，在学术界和工业界均建立了较好的声誉。本次讲座将分享华东师范大学数据库团队近期的一些科研思路和研究成果。首先分析驱动数据库技术发展的主要因素，谈一谈未来有价值的研究方向。再聊一聊团队近来取得的一些有趣的研究成果，领域包括新硬件的数据库适配、分布式事务处理、HTAP、系统实现模块化（&lt;span&gt;Modularization&lt;/span&gt;）等等。&lt;/p&gt;&lt;p line=&quot;DQv9&quot;&gt;&lt;/p&gt;&lt;p line=&quot;mwPp&quot;&gt;&lt;strong&gt;&lt;span&gt;00 引言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;Wkb8&quot;&gt;       &lt;img data-ratio=&quot;0.5612391930835735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaThBx3V4piaq7YMOCp2eBe8tT1rDKxBOLntKibOeibbP84lxl1W8KWNug8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;今天我代表华东师范大学的数据库团队，来分享一下对数据库这种技术或者这种产品的一些研究心得以及当前的研究成果。其实，高校跟企业实际上是处在两个不同的生态领域当中，高校更关注关于研究理论的一些问题，但是企业更多的关注企业本身的产品以及用户，所以两者面向的目标是不太一样的。但是经过我们在华师大这么多年的一些摸索，特别是我们自己研究上的一些摸索，以及跟企业合作的经历，我们觉得实际上高校和企业应该一起来做我们称为数据库系统或者基础软件的研究，因为只有这样才能够更好的推动这个行业本身的发展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我的报告内容会分成两个部分。首先分享一下我们对数据库这种技术发展动态的看法，我们团队在数据库这个领域也做了很多年，包括我之前在中国人民大学也是做数据库系统的，我在这个领域里面有可能不到20年的积累。我希望能够提出我们的看法，并且能够得到大家的一些反馈，纯粹是做一种探讨，因为对技术的发展方向的探索，没有标准的答案。我觉得大家应该集思广益，共同去探讨，才能把这个问题看得更清楚，这是讲座前面一部分的内容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;pTuF&quot;&gt;后面一部分的内容我会聚焦到我们的一些研究成果上，这些研究成果可能就会比较技术细节了，会更适合搞技术、数据库、系统的这些同学，但是我会尽量把讲座的形式变得更大众化一点，尽量用更通俗的方式去给大家介绍。我希望通过这种细节的介绍，也能够让大家了解一下，我们在设计系统的时候，通常一个工程师、一个研究者或者一个学者，他的思路大概是怎么样的，我不能代表所有的人，但是因为我们这个团队是一个典型的做系统的团队，所以这个思路可能仅代表了一部分做系统的学者的思路。&lt;/p&gt;&lt;p line=&quot;B1ee,2vCq,lVny,7tvx,BFNP,PtK4&quot;&gt; &lt;/p&gt;&lt;p line=&quot;XgnE&quot;&gt;&lt;span&gt;01 数据库系统的形态变化&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;XgnE&quot;&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 什么引起了数据库系统的形态变化？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先问大家一个问题，什么引起了数据库系统的形态变化？我们知道数据库系统实际上是一个有很长历史的系统，是现代软件开发的一个核心部件。任何应用都离不开某种数据库，但是我们其实也可以看到，如果你有一定的经验，比如大概10年的工作经验，你会看到数据库系统的形态是在发生变化的，10年前用的很流行的东西，现在不见得普遍被采用。这个系统虽然有很长很长的历史，也很成熟了，但是它的形态还是在发生变化的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;什么在驱动数据库系统的形态变化？这是一个很重要的问题，也是比较有趣的问题，但并不是一个好回答或者能够全面的回答的问题。我这里就直接抛出我们对这个问题的一些看法，我们觉得数据库系统的形态变化，主要来自三个方面的推动力：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;xF25&quot;&gt;&lt;/p&gt;&lt;p line=&quot;xF25&quot;&gt;我们看到的推动力主要就是这三个。我们认为未来推动数据库变化的原因也不出于这三个，我们可以通过这个东西去预知未来应该朝什么方面去推进我们的数据库技术的进步。下面我就大概做一个简单的展开。&lt;/p&gt;&lt;p line=&quot;MXZn&quot;&gt; &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;1.1.1 应用需求的变化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先第一点就是应用需求的变化。我们认为这实际上是在推动底层技术，像数据库系统这种技术变化的一个主要原因。&lt;/p&gt;&lt;p line=&quot;IgaT&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTXonKYl4ibx6zjocvs9H8jZiaINMsdhbcoLAQibL3zZAh0EvmdMfQYddTw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;115.84775086505189&quot; data-cropy2=&quot;541.8685121107266&quot; data-ratio=&quot;0.39444444444444443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTibHkHU0UDqEKjMn9ZaKbnichRpae1fqkGAqLJJ9rjE85kSfmcjFrWj5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;通过上面这三幅图大家能够很容易去理解数据库诞生的年代，那个时候磁盘作为一个存储介质，刚刚在市场上推广，磁盘取代了磁带，数据的随机访问变的可能了。那个时候对数据管理功能的需求一下子就增长了，当时出现了各种各样的数据库，包括网状数据库，包括后面的关系数据库，那个时候是我们叫前互联网时代就出来了。但那个时候应用的规模并不大，数据库的用户量一般，终端用户其实很少，对于一个银行来讲就是那些银行职员在使用数据库，普通用户在银行排队，他们不是终端的使用者。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后来进入到互联网时代之后，我们发现终端的使用者一下子就爆炸性的增长了。现在我们每个人有一个手机，随时都在使用手机上的App，然后这个App他随时都会把请求发送给后台的数据库。我们看到应用规模在最近20年有一个很大的增长，如果往后看的话，未来我们认为增长有可能还会继续。我们的工业互联网、物联网使用的话，我们的终端会变得更多，他可能对数据管理系统的压力会变得更大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以我们看到应用不断的扩张，给数据库这种底层系统有一个持续增长的压力，要应对这样的压力，以前对数据库的设计，它逐渐就变得不太实用，必须去革新，必须去改变它。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个是我们看到的一个最主要的推动力。但除了应用规模的扩展，当然就还有一个应用领域的扩展，最开始的数据库它就是金融领域或者电信领域去使用，并不会在互联网、销售或者传媒等等这些领域去大规模的使用，但是我们发现IT的渗透到各行各业之后，它的应用范围也在增加，应用范围增加对传统的系统来讲是不友好的，或者是说你的传统数据库系统对这些应用是不友好的，所以这个也在推动它的一个变革。&lt;/p&gt;&lt;p line=&quot;M2m5&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT1zLINEMUUAhHmZxd5qTYAlDs9SNlUuicicxtWiaJNoAdxnMdMScd8icHRw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;125.1903114186851&quot; data-cropy2=&quot;609.1349480968858&quot; data-ratio=&quot;0.44907407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT9dXdwb0ZRHmvZgcKuOcT841K5fpJZVMSRKAD6NIvqdYxTWvQvib7XYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;应用需求带来什么变化？我们回顾历史的话，我们看到分布式数据库现在变得越来越被大家所需要，大家看到了谷歌的一些分布式数据库的产品，它现在作为一种标杆的产品，然后国内也有一些分布式数据库的场景，包括美团在内，听说美团内部也在研制自己的分布式数据库，实际上是在对需求的负载增加的一个应对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应对它实际上并不是一个很简单的事情，如果要增加你的数据库的扩展性，有时候你必须要重新去设计你的数据库的架构。我们通常做系统的同学应该了解，其实在做系统的时候，你需要做很多折中的考量的，有些东西是不能兼顾的，比如说你的功能性和应用性对吧？一个东西特别简单去使用的话，它功能性有时候就是比较简单，它复杂的功能处理不了，或者是你的功能很复杂的时候，你的扩展性又上不去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在系统设计的时候你必须去做一种权衡，去获得一部分这方面的能力，你就必须丢失其他的一些能力。当你需要它的扩展性非常强的时候，你有可能就要去重新考量它，你要去丢弃什么东西，你要去忍受什么其他的一些东西，然后这个时候就产生架构的变化，这样的话我们就会发现有新的系统出来，比如说以前的是SQL，我们现在有讲NoSQL大家认为它的扩展性容易做的更好一些，然后会有其他形态的一些数据管理产品。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对这个问题，学界工业界都有很多的讨论，Michael Stonebrake大概10多年前发表的一些言论，就说“One size does not fit all”，你不太能指望某一个系统能够能够处理所有的应用需求。因为不同的应用需求，你可能必须要做不同的折中、重新的考量，你只能顾此，你顾此只能失彼，所以这样就产生了一个多样化的形态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;9M90,GE9z,Hbyh,tY7h,dOMR,BQlZ,dT0W,DJqI,Vibo,viDe&quot;&gt;我们现在看到的数据库，如果你们在使用的话，你会面临很多选择，你到底用MySQL还是MongoDB对吧？你的分析的时候你要用什么？用Hadoop还是用传统的数仓MPP产品，有不同的需求，可能有不同的考量。这个我们看到应用需求它的变化，它的增加，它在实际上对这个系统起到了一个很重要的推动的这个作用，这是我展开的第一点。&lt;/p&gt;&lt;p line=&quot;9M90,GE9z,Hbyh,tY7h,dOMR,BQlZ,dT0W,DJqI,Vibo,viDe&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;1.1.2 软件开发模式的转变&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;pVca&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTqsic7tlUygJ38IrJiaiboJWLPlzag68NCLKoEhQo1vOIzd5ktyw97twZA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;147.61245674740482&quot; data-cropy2=&quot;541.8685121107266&quot; data-ratio=&quot;0.36574074074074076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTaeKEhhf4OPEOJVee9FbmLdJlZLAaPHV1uiaSh1VL6aQCBymibgnZtLKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p&gt;然后，第二点就是我们发现软件开发模式的变化，也在促进数据库本身的改变。就像我刚才提到的，现在用到的很多软件开发的模式跟以前不一样。以前关系数据库这样的产品刚刚被广泛应用的时候，当时的软件开发它是以数据为中心的，一个数据库设计出来，有好多应用都会去用它，它是一个Shared底层系统。那个时候数据库的设计过程，它是相对独立的，DBA根据App开发人员的需求、用户的需求，以DBA的方式去设计数据库，按照对数据模型的理解，把它设计得非常的规整，要满足各种各样的范式，然后给不同的应用去用。但现在我们发现一旦用到微服务这种新的开发模式的时候，很多时候这种横向的分割变得不是那么重要了。原本数据是一层、应用逻辑是一层，这两层之间的解耦是很重要的，但现在不是了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现在是微服务的形式，是纵向的切割，把业务整个分成一块一块的，每一块里面都有单独的数据库，有单独的功能设计，这弱化了数据库跟应用之间的界限，强化了应用里面不同模块的界限。这样的话，每个模块可以用不同的数据库产品，比如说一个设备用MySQL，另外一个设备可能用MongoDB，第三个设备可能用ES，这些模块之间的数据有同步有交互，可以用一些比如像事件驱动的架构，像Kafka这种MQ (&lt;span&gt;Message Queue&lt;/span&gt;)去连接在一起，形成一个总体的架构。&lt;/p&gt;&lt;p line=&quot;bHDU&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTLIfh3K4huuFjPX0uvA3vgibqpPFIOEX1q8bDZANTZKSC5zJIjtcbHDw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;155.0865051903114&quot; data-cropy2=&quot;487.681660899654&quot; data-ratio=&quot;0.3074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTicoewcVusEPU2F0NphufNc4TU3vytk8hgbpU0SfyVY2qwOKRAUJezUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;这种设计跟以前的数据库是不太一样的，对于数据库本身的要求也不太一样。不同的Service会用不同形态的数据库产品，根据需求或者根据软件开发者的习惯，去采用各种缓存、消息队列等，去把这些东西给嫁接在一起。这样的形态对数据库有不同的要求，所以NoSQL被很多人接受。&lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;&lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;在某些软件开发的场景下，NoSQL就是比关系数据库使用起来更简单。然后事务的处理方式也变得很不一样，现在的消息队列在事务处理中，它的权重非常的高，而不是完全依赖于传统数据库内部支持事务处理的模式。这个是我们也看到这样的一些变化，这个是软件开发模式带来的一些改变。&lt;/p&gt;&lt;p line=&quot;1ZLg&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;1.1.3 硬件平台的革新&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;ATrQ&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT4nOniam8jx6V1E9zvzpibRDNFI7tU3lhv3ecxibiaVc4s0Id5jZgg1tKiaw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;115.84775086505189&quot; data-cropy2=&quot;569.8961937716263&quot; data-ratio=&quot;0.4212962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTdeWvL1JvyCzBE2uYcQ6mc33nA7ZKicibW2563ByqFmRcWXSvW1HXCWsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;第三个方面就是平台的革新。其实我们不会对传统的数据库的硬件平台灵活性有太多的关注，但现在数据库产品面向的基本上都是云平台，不是以前的IBM大型机了，不是Oracle那个时候的硬件平台。我们面对的是一个云平台，云平台自身是在发展的。以后的云平台其实可以预见得到，它不单单是现在我们看到的，是由一个个虚拟机或者是一个个容器组成的一个计算平台，还有可能就像一个大型的计算机一样，只是这种大型计算机它的资源非常的丰富，需要调用什么样的资源都可以获得，需要更多的内存、CPU、存储，都可以直接的获取。&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;云平台通过比较高效的网络方式把这些资源全部连在一起，然后给用户的接口也很简单，很多维护功能是在云平台内部去实现的。数据库要扎根在这样的一个云平台上面，其实对数据库系统就会有新的要求。以前的数据库，大家都记得有几种架构可以选择，叫Shared Everything、Shared Nothing、Shared Disk这样的一些架构。&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;但是我觉得在“云”层面上，数据库其实不再是那么简单去划分的，就是说数据库系统的产品，必须要做到具有很好的弹性。任何的资源在短缺的时候，可以通过云的这种方式很快的把资源调度过来，从而增加数据库的能力。对用户的话，只是提供一种数据库的服务，用户用多少？就提供多少。这样的一个云架构下的数据库，形态可能跟以前要有一些变化。除了这种云的体系之外，其实还有一些新硬件出现，硬件种类也变得越来越多。不同的种类的硬件，在不同的条件下，算力也在不断增加。当然除了计算，还有存储也发生很多变化，把这些放到云的里面去，云的资源变得更加丰富，对数据库的要求也会变得更高。&lt;/p&gt;&lt;p line=&quot;PlbU&quot;&gt;&lt;/p&gt;&lt;p line=&quot;XLat&quot;&gt;因此，我们看到这种硬件平台的变革，它实际上在推动数据库的一些发展。现在大家很常见的就是这种计算与存储分离的这种架构的数据库。我把数据库本身这种系统，它的计算层跟存储层完全的分割开，计算层可以自己扩展，存储层也可以自己扩展，两层就通过云这种高速的、互联的通道能够连接在一起，这种实际上就是针对云的一个特殊的处理。我们知道存储是便宜的，所以在存储需要扩展的时候，没有必要在扩展存储的基础上去加CPU的资源，因为CPU比较贵。如果分开扩展的话，这样确实会在成本上有极大的提升。&lt;/p&gt;&lt;p line=&quot;X64e&quot;&gt;&lt;/p&gt;&lt;p line=&quot;X64e&quot;&gt;未来各种资源加进去之后，它都有可能有扩展的需求。比如说缓存，新的存储器，新的内存加进去之后，有可能需要它跟底层的存储分开，进行一个隔离，再分别去扩展，这都是有可能的。但现在的数据库产品其实面对这种扩展能力，实际上是非常有限的，存储和计算分开扩展到一定程度，实际上它的能力就达到一个峰值了。那么怎样去推动它进一步的这种弹性的增加，实际上是一个挺难的问题，但是也是挺有趣的问题。&lt;/p&gt;&lt;p line=&quot;HQCb&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTicm1HcOmiaDe3VcEBUXrsicEjuE9nP5ovAHJoeN2L4edY0J0n1Gxibn03A/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;112.1107266435986&quot; data-cropy2=&quot;560.553633217993&quot; data-ratio=&quot;0.41574074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTBfAsC4jI9LvG062a9Z9TKIibvica9A50npLL9E0YXEyzews7c3aJEzHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;zdKI&quot;&gt;新硬件对数据库产品的影响，这里有一个简单的公式，公式的左边叫做Data/Cost，单位数据处理，单位代价上面可以处理多少数据。这个是我们需要提升的，因为可以想象以后的数据量会越来越大，如果不把单位价格上面能处理的数据这个值提升的话，应对数据的能力就没办法提升。数据越多，需要花费的资源或者代价就越多，这个是我们不希望看到的。希望左边这个式子中Data/Cost的值随着技术的进步，它可以逐渐的提升。&lt;/p&gt;&lt;p line=&quot;zdKI&quot;&gt;&lt;/p&gt;&lt;p line=&quot;mmR3&quot;&gt;然后把左边这个式子它分解一下，分解成Data/Hardware和Hardware/Cost的一个乘积。这其实是很简单的一个因素分解，大家能够看得很明白。我们发现后面这个式子Hardware/Cost，实际上它的增长在逐渐的趋缓甚至停滞，主要的一个问题就是单位价格能够买到的硬件资源，要在这上面做更进一步的提升，会变得非常的困难。&lt;/p&gt;&lt;p line=&quot;mmR3&quot;&gt;&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;最后，如果想实现Data/Cost的提升的话，只能去提升左边这个式子Data/Hardware，这个是未来一个很明显的趋势。怎么样能够提升Data/Hardware？就是单位硬件下处理数据的能力要怎样提升？我们认为只有两种途径，第一种是硬件定制化，面对不同的应用需求，需要为这种应用需求做特殊的硬件。其实我们能看到像GPU、TPU这种出现，其实就已经在揭示这种规律了，专用硬件效率总是要比通用硬件好的。然后软件是一样的，专用的软件的效率肯定比通用的软件好。&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;这个趋势我觉得可以从长期来看，短期可能并不是那么的明显，但长期来看的话，这个过程应该是不可阻挡的，也就是说我们可能会面临要去为应用去定制系统，要为专门的这种系统配置适合它的硬件。&lt;/p&gt;&lt;p line=&quot;97M0&quot;&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 数据库系统的未来发展趋势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;3MOW&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTwCGVsIOfhW57zGIBH1OPNNvjvesQ7M3skQlyDlNmXJeF64Iql1ibd4A/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;149.48096885813146&quot; data-cropy2=&quot;609.1349480968858&quot; data-ratio=&quot;0.42592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTj62ytEXKCsvjeCvEzEBCAq2YTKPxdBSfzL4g6DEcPmuHHiarBRgqcUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;UsZj&quot;&gt;我们刚才讲了三点，第一点就是应用的变化在推动系统的演进；第二个是软件开发模式的变化实际上也在带来系统的功能的一种变革；最后是硬件平台。因此，我们觉得未来数据库发展的趋势：&lt;/p&gt;&lt;p line=&quot;UsZj&quot;&gt;&lt;/p&gt;&lt;p line=&quot;CnGd&quot;&gt;&lt;/p&gt;&lt;p line=&quot;CnGd&quot;&gt;&lt;span&gt;02 华师大的数据库系统研究&lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 研究团队&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;Zj9d&quot;&gt;       &lt;img data-ratio=&quot;0.5655619596541787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTEsdiaDjp74FpLo90k4BlhUEYIGDaLT911F3Jyt8VGYqxNibphxKUlSCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;4Dxy&quot;&gt;然后介绍一下我们现在这个团队，华东师范大学数据科学工程学院大概有20多个老师，大概10个老师是从事数据库内核的研究的。整个团队的历史是超过20年的，我们近10年其实做了非常多的系统内核研发的工作，跟业界的很多的公司也有合作。我们的学生其实也做了很多工程性的工作。&lt;/p&gt;&lt;p line=&quot;4Dxy&quot;&gt;&lt;/p&gt;&lt;p line=&quot;kIr2&quot;&gt;去年我们有拿到一个国家科技进步二等奖，这个是基于我们当时和某银行一起做的一款数据库产品，是我们基于OceanBase的一个早期开源的版本上实现的一个系统，具体的这种内容我就不做过多的介绍，这个系统实际上在某银行得到了比较深入的应用，是我们比较引以为豪的一个研究成果。&lt;/p&gt;&lt;p line=&quot;kIr2&quot;&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 研究成果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;BXer&quot;&gt;我们团队的研究其实还是蛮广泛的，我们在事务型数据库和分析型数据库其实都有研究，但我们更多的精力还是集中在事务型数据库上面。然后接下来，我会介绍一些典型的研究成果，让大家了解一下我们的研究是在做一些什么事情，主要分三个部分，第一个是分布式事务，第二个是数据库系统解耦合，第三个是新硬件。&lt;/p&gt;&lt;p line=&quot;BXer&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;2.2.1 分布式事务&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p line=&quot;f4Ps&quot;&gt;分布式事务是一个几十年来大家都在探讨的话题，实际上也是有一定的争论：分布式事务到底合不合用？我们在使用事务处理这种功能的时候，是不是应该去规避分布式事务？还是我们应该进一步去增强数据库支撑分布式事务的能力，让程序员不要刻意去规避分布式思维？这实际上是一个疑问，目前没有一个明确的答案。&lt;/p&gt;&lt;p line=&quot;f4Ps&quot;&gt;&lt;/p&gt;&lt;p line=&quot;cnyq&quot;&gt;如果分布式事务确实是不行的，那我们就应该做一些其他方面的处理，来弥补分布式事务本身的缺陷，这样做有两种方式：&lt;/p&gt;&lt;p line=&quot;cnyq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;W2xX&quot;&gt;&lt;/p&gt;&lt;p line=&quot;W2xX&quot;&gt;我们认为现在以NoSQL为代表的这些系统的推动者，实际上是持这样的观点的。比如典型的NoSQL客户系统MongoDB，它的一般的事务处理或者数据库的访问，都是Single Document一个文档一个文档去处理的。实际上，就是如果真要进行复杂的事务处理，那就到上层应用去处理，就用最定制化的方式去应对这种事务，它的效率可以比较高。&lt;/p&gt;&lt;p line=&quot;W2xX&quot;&gt;&lt;/p&gt;&lt;p line=&quot;FLjF&quot;&gt;另外一种观点认为分布式事务本身应该是可行的，我们应该提升数据库处理分布式事务的能力，解放开发者。&lt;/p&gt;&lt;p line=&quot;FLjF&quot;&gt;&lt;/p&gt;&lt;p line=&quot;DMQ7&quot;&gt;&lt;span&gt;这样的观点就是那些推动NewSQL这一类系统的人所持的观点，比如说谷歌的Spanner 、TiDB、OceanBase。那么想要把分布式事务做好，怎样去优化，提升分布式事务的能力？首先要处理异常，分布式事务最害怕的一个问题就是出现异常，出现异常之后，如果是一个分布式事务，一旦事务锁掉一个节点上的数据，另一个节点出现故障的话，就会很麻烦。那为了处理异常，然后以Spanner为代表，使用了很多高可用的系统架构，用Paxos/Raft创建这种在云平台，在这种廉价计算机上同样能够有高可用能力的基础设施，在这个上面我可以去规避分布式事务所遇到的这种异常的问题。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;DMQ7&quot;&gt;&lt;/p&gt;&lt;p line=&quot;YREk&quot;&gt;但除了异常问题之外，实际上还有分布式事务的扩展性的问题。虽然分布式事务可以比较放心地应用于可靠的、高可用的系统上，但是它的性能会比较差。因此，我们必须要优化它的性能，为此学术界也做了很多尝试，对于团队来讲，最近几年，我们也做过一些研究和尝试。接下来我就大概讲一下我们的大概思路。&lt;/p&gt;&lt;p line=&quot;YREk&quot;&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;首先，我们要了解到底是什么限制了分布式事务的扩展能力，大家是比较公认的一种观点是制约分布式事务扩展的主要是事物之间的这种阻塞Blocking。你可以想象一下，当一个事物它去访问一个数据，特别是修改一个数据之后，它会加锁，然后在加锁的过程中，又要去跟其他的节点进行各种通信。&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;其实这种通信有时候是很耗时的，有时候甚至要跟异地的节点，比如说要做高可用，就需要跟异地的节点建立通信。在加锁的过程中去通信，由于通信的过程很长，然后就会把加锁的时长变得特别的长，阻塞就会变得很严重。一旦事务处理的阻塞时间增加，它的事物的吞吐有可能会受到很严重的影响，特别对于有一些热点的数据出现的话，不是时长增加一倍，性能就降低一倍的，有时候时长增加一倍，性能可能会降低若干倍，这是一个很麻烦的问题。&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;span&gt;所以说，真的想要解决分布式的扩展能力的话，在已经有高可用的前提下，我们最重要的目标就是要降低阻塞。怎样降低阻塞？其实可以用到很多的技术。比如说MVCC/OCC、 MVCC是多版本的数据管理，它可以降低阻塞，这个很直观，就是我一个数据有多个版本，当我的一个事务去改动数据的时候，我直接产生一个新的版本，这样就不用去阻止别人读你的旧版本。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;span&gt;因为你有多个版本，新版本在产生的过程中，你没有办法去读，可以去读旧版本不用阻塞，这就是MVCC的使用。然后OCC也是一样的，就是OCC就是乐观并发控制，也就是说默认不需要加锁，到最后再来检测这个事务是不是执行正确，如果执行不正确推翻就行了。然后还有一些锁的优化，通过各种各样的技术，来把阻塞的现象把它尽量的减少，从而来提升分布式事务的扩展能力。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;pghE&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MVCC时间戳分配去中心化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZFQJ&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaToZRRORibDibqAYXnGd1E1oDrSnJD2yA22tawn3bibicAL3pSgQHAlSUsPA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;147.61245674740482&quot; data-cropy2=&quot;543.7370242214532&quot; data-ratio=&quot;0.3675925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT4vX85pxibayOtZQXia7akDoiapflrmY0fjINAqKic30Vs6oibJwhC83qNOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;r6aP&quot;&gt;在MVCC上我们做过一些工作。当然MVCC有一个时间戳分配的问题，就是说它来判断一个事务或者一个数据或者一个数据的版本，它是不是应该由某一个事务去读取的话，它要通过一些时间戳的判断来做。时间戳的分配很麻烦，按道理来说，它是应该有一个中心的时钟，大家都去中心的时钟去拿时间戳，这样就可以保证事务处理正确无误。但通常如果有一个中心的时钟的话，那扩展性就受限了，比如谷歌的Spanner用一些原子钟去规避这个问题。然后我们做的一个研究就是去中心化，去优化了SI的隔离级别。&lt;/p&gt;&lt;p line=&quot;r6aP&quot;&gt;&lt;/p&gt;&lt;p line=&quot;r6aP&quot;&gt;SI是一种典型的MVCC的隔离算法或者并发控制的算法，它是需要时间戳的。我们做了一个去中心化。想法是我在给事务分配时间戳的时候，不是在事务开始的时候分配，而是在事务要结束的时候，根据它跟其他事务的关系、冲突情况，来给它指定一个合适的时间戳，所以叫后验时间戳，Posterior SI。这种方式使得我们可以不需要用一个中心的时间戳去做这个事情，但这个东西做起来其实蛮复杂的，我们大概5年前做了这件事情，最后有一些实验没有实现在现实的系统里面去，因为实现相对来说比较复杂，而实际应用中使用一个统一的中心的时间戳，基本的应用还是可以满足的。&lt;/p&gt;&lt;p line=&quot;xikF&quot;&gt;       &lt;img data-backh=&quot;241&quot; data-backw=&quot;402&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTW4V9moxItcbOGFEd1TItGfEvmQxoGDvEVG5hunr4nicuhUl0CVz7yiag/640?wx_fmt=png&quot; data-cropx1=&quot;145.7439446366782&quot; data-cropx2=&quot;896.8858131487889&quot; data-cropy1=&quot;125.1903114186851&quot; data-cropy2=&quot;575.5017301038062&quot; data-ratio=&quot;0.5992010652463382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT9R3JiaC7xJ8pniaBYU9EayvfKibiaUzvM2vjBW9icXmHXHdMnVO9Cq1U5Nw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;751&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;z9Eo&quot;&gt;我们做了很多的实验，实验结果可以表明我们的方法，当扩展到一定程度的时候，这种时间戳的分配是不会成为一个扩展性的瓶颈的。&lt;/p&gt;&lt;p line=&quot;z9Eo&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;降低OCC的阻塞时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;NxUT&quot;&gt;&lt;/p&gt;&lt;p line=&quot;NxUT&quot;&gt;我们也做了一些OCC的工作。OCC在事务访问数据的时候，就放开让事务去访问，访问完了事务要结束的时候会做一个验证叫Validation，做完验证，再决定这个事务是提交还是回滚。这种方式也是降低事务之间阻塞的一种方法。其实这种事务的最后的正确性验证，有时候会挺耗时间的，所以在这个上面做了一个优化。&lt;/p&gt;&lt;p line=&quot;MNpV&quot;&gt;       &lt;img data-backh=&quot;222&quot; data-backw=&quot;490&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTGMjBGFg13oqsaMoVnOiaDajC6hyxgbicsx6EuzrzLza20RrDL1NYgpKw/640?wx_fmt=png&quot; data-cropx1=&quot;69.13494809688581&quot; data-cropx2=&quot;984.7058823529412&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;560.553633217993&quot; data-ratio=&quot;0.453551912568306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT1bdVQsckBR8Ju8HYj4lT8dzd9Ek2hcnQAt57moKeT8ufft1AOPdibZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;915&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;OKhI&quot;&gt;       &lt;img data-backh=&quot;239&quot; data-backw=&quot;498&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTF3Jnx0rIU7icUs5L7B9iaTqu217er4xs1V1I17vZRkMicyKEeCQyV5Jqw/640?wx_fmt=png&quot; data-cropx1=&quot;65.39792387543253&quot; data-cropx2=&quot;995.916955017301&quot; data-cropy1=&quot;160.69204152249134&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.4806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTk3p1JJX9UmfBGZpyz3iag84fACL4QeEN6pt8cMtsPp6Mm4kXAVGevdw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;930&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;X1Vz&quot;&gt;我们认为做正确性验证的方式有两种，一种主要的方式叫Local Readset Validation，每个事务把它读过的数据记录下来，最后再去查读过的数据有没有被改动过。这种方式的缺点是当读取的东西特别多的时候，它的代价就会相当的大。&lt;/p&gt;&lt;p line=&quot;X1Vz&quot;&gt;&lt;/p&gt;&lt;p line=&quot;X1Vz&quot;&gt;然后，还有一种方式叫Global Writeset Validation，这种方式就是我不去记录每个事务读过的数据，只记录现在有多少正在运行的事务改动了那些数据，也就是说记录的是那些被改动的数据。然后读的时候，观察它的范围有没有包括改的数据，如果包括了验证就失败。这种方式对读取数据内容比较多的事务是友好的，但对那种小的、短的事务并没有那么友好。&lt;/p&gt;&lt;p line=&quot;Na2V&quot;&gt;       &lt;img data-backh=&quot;230&quot; data-backw=&quot;419&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTmYEHO1U2BHdwsaFYy4tj1mTLcr2Jg1nvWJVRWxYbuGjnofpkEloUNg/640?wx_fmt=png&quot; data-cropx1=&quot;117.71626297577855&quot; data-cropx2=&quot;900.6228373702422&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;573.6332179930795&quot; data-ratio=&quot;0.5478927203065134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTFic64VB8CIDMfiaX00ZXymENfiaDNQLn2fG6LDGuTuzaXkfM1o4gHzLnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;783&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;rwgq&quot;&gt;所以我们就做了一个叫AOCC，Adaptive OCC，就是把这两种方式给结合起来，我们会判断一个事务的运行情况，如果读取的数据很多，就用Writeset Validation；如果读取得很少，就用Local Readset Validation，这样的话就把两种方式的优点结合起来。&lt;/p&gt;&lt;p line=&quot;ghLQ&quot;&gt;       &lt;img data-backh=&quot;310&quot; data-backw=&quot;342&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTEngputapG24yO7N5fowlNhjSd4kxtepgiaQt83zhMAEzPZVsPtPIlOw/640?wx_fmt=png&quot; data-cropx1=&quot;282.1453287197232&quot; data-cropx2=&quot;921.1764705882352&quot; data-cropy1=&quot;28.02768166089965&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.9076682316118936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTQ5w0opBmhq8wxRialVq8I9BYOwyZEeKGwJ3SLhBd9J2xXE6s4I9k4ibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;639&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;ZTaV&quot;&gt;我们做了一些实验，实际上结果确实证明这种方式没有极端的情况的缺陷。因为以前的那种就是读集Receipt Validation和Receipt，德行在在各自的极端情况下都会呈现出特别差的一个性能。但是我们这种方法实际上它是比较均衡的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;跨区域高可用系统的锁时长&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;fwPy&quot;&gt;&lt;/p&gt;&lt;p line=&quot;fwPy&quot;&gt;然后第三个工作也是关于分布式事务的，就是我们做了类似于Spanner这样的系统，跨区域的高可用的系统。&lt;/p&gt;&lt;p line=&quot;8JIn&quot;&gt;       &lt;img data-backh=&quot;213&quot; data-backw=&quot;360&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTjImxGq9yRSAka04d4EFJ470I0Lf01evjiamUusEmJQSX2VF3SkxGqSw/640?wx_fmt=png&quot; data-cropx1=&quot;175.6401384083045&quot; data-cropx2=&quot;848.3044982698962&quot; data-cropy1=&quot;153.21799307958474&quot; data-cropy2=&quot;551.2110726643598&quot; data-ratio=&quot;0.5913818722139673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT9VSxMwoiaZgAicPKLaL1ADPOwUfo5ANCqNdRVbbxiac98K3VIkMdkibcEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;673&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;1Pnr&quot;&gt;就像我刚才提到的，一旦加锁，加锁的过程中，出现了跨区域数据的通信，这个持锁的时间就会特别的长。这里是一个例子，在跨区域高可用的系统上做的一个两阶段提交。可以看到红色的线是一个加锁的过程，这个过程已经是在一个正常的事务里面最短的加锁过程了，它是在事务提交开始之前加锁，一直到事务提交完成之后释放锁。&lt;/p&gt;&lt;p line=&quot;1Pnr&quot;&gt;&lt;/p&gt;&lt;p line=&quot;1Pnr&quot;&gt;对一个普通的事务来说，它本身就是要加锁的，但这个加锁的时间可以看到，在加锁过程中，Prepare阶段会有大量的本地节点跟异地节点之间的同步，然后在Commit阶段，同样的也有大量的本地节点跟异地节点之间的同步，这样的一个同步是很耗时间的，如果在这个时间上去做加锁的话，一旦遇到热点的数据访问，这个事务处理的性能就会极度的下降。所以在这样的条件下，我们就想可不可以用提前释放锁的方式去规避加锁，缩短加锁的长度，直接降低阻塞概率。&lt;/p&gt;&lt;p line=&quot;pbK8&quot;&gt;       &lt;img data-backh=&quot;207&quot; data-backw=&quot;356&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTYNrJwdz4SsGEHsgGzYf4GuZkQderzvnq3736ib7jdy8mm3sJQMia1moA/640?wx_fmt=png&quot; data-cropx1=&quot;199.93079584775086&quot; data-cropx2=&quot;865.121107266436&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;532.5259515570933&quot; data-ratio=&quot;0.581081081081081&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTcQu8vgLsmzk8gctp3IQ4Etuya0ibgBVrBwUyNWvxO9sDZ9iaGUr1rMHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;666&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;KZN5&quot;&gt;然后我们就设计了叫DLV，LV的意思是Lock Violation，实际上就是提前释放锁。DLV的话我们叫Distributed Lock Violation，同样是一个两阶段提交的一个协议。我们就看在什么地方释放所，它的效率是好的。我们选择了四个时间点：&lt;/p&gt;&lt;p line=&quot;KZN5&quot;&gt;&lt;/p&gt;&lt;p line=&quot;nwpn&quot;&gt;       &lt;img data-backh=&quot;295&quot; data-backw=&quot;426&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTD5BibjO3PnjzlvI0EUvWOnIpt463LcCmkKXyWnUJVYUiaXcbxgbTNicKQ/640?wx_fmt=png&quot; data-cropx1=&quot;205.53633217993078&quot; data-cropx2=&quot;1001.522491349481&quot; data-cropy1=&quot;56.0553633217993&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.6922110552763819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT1zNep73xZpzJkLM1TFk2tQyuPy1xB3sqV9n16BB8HERjk0HsQUbZrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;796&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;然后我们就实验了这些不同的加锁和释放锁的方式，得到的一个结论，左边这两张图（&lt;span&gt;横轴是远程通信的时长&lt;/span&gt;）说明两个计算机中心离得越远，它通信时间越长，然后用这种传统的方式，会看到时长越长，它的性能就会越差。在高冲突的情况下，分布式事务处理性能就会比较差。但是如果使用提前释放锁的方式，性能就是绿色蓝色的线，表示着它的性能会有一个比较大的提升，这个就说明提前释放锁是有用的。&lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;&lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;但什么时候提前释放锁最合适呢？右边这个图我们做的一个实验最后的结论是第三个时间点就是DLV1x这种方式，协调节点跟事务处理阶段有一个短通信，这个是本地通信，不是异地通信，通信之后确认所有节点都做完了，这个时候释放锁，这样的负面作用是最少的，而且它的加锁时间也会很短，这种方式它的效率是最高的。&lt;/p&gt;&lt;p line=&quot;491G&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;2.2.2 数据库系统解耦合&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;8g8H&quot;&gt;       &lt;img data-backh=&quot;200&quot; data-backw=&quot;498&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTh66fVSNmTowgtKAVv9xPjWeqkbcqtMeGIhTf9pWYZykakGbswOEyEw/640?wx_fmt=png&quot; data-cropx1=&quot;61.660899653979236&quot; data-cropx2=&quot;992.1799307958478&quot; data-cropy1=&quot;156.95501730103805&quot; data-cropy2=&quot;530.6574394463668&quot; data-ratio=&quot;0.40171858216971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTibH3uL7tQ8cezOwOOZse5tJjiaF9ZzIhWeyHYB6Wc80JQzIicrDRAZGgw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;931&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;我刚才介绍了三项研究，都是关于分布式事务处理的，然后我接下来再讲一讲我们在数据库系统解耦上面的一些研究，这也是非常有趣的一个问题。什么叫数据库系统的解耦？实际上教科书会把数据库系统拆成一个一个的模块，比如说这个是collector就是跟应用对接的连接器，还有Query Optimize、Query Evaluator或者叫Query Processor，就是查询处理查询优化的模块，New Storage Manager、New Transaction Manager，还有各种日志、Lock、Manager等等，这个是我们教科书上面对数据库一个模块的切分。&lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;&lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;但实际上当我们去真正的看一个数据库系统的实现，就会发现这些模块之间实际上没有切分的那么干净的，而且有时候是实际上模块之间很高耦合的，很紧的耦合在一起。对于一个刚开始做数据库的人会觉得跟我们学的东西会不完全一样。然后很少的人真的去探究为什么会是这样。我们在实现数据库系统的时候，实际上这种高耦合的系统架构给我们带来了很大的困扰。&lt;/p&gt;&lt;p line=&quot;cne7&quot;&gt;&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;我们当时在某银行改那个OceanBase的系统时，改动一个数据类型，我记得好像花了好几个月的时间，很多人去做这个事情。这实际上一听上去会让人比较诧异，但实际上你去看系统的实现，它就是这么回事。一个数据类型好多地方都会用到，必须把每一个地方都清除掉，这个时候就必须花很多时间去读代码去理解去测试的。其实我们觉得如果一个系统的耦合度能够变低，模块之间能够分得很清楚，实际上对系统工程来讲是有很大收益的。&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;我们回顾刚才讲的一个数据库的发展趋势，叫“One size fits a bunch”，也就是说我们认为以后系统会变得很定制化。如果一个系统的模块化做得很好的话，去定制去改动这个系统也会变得很简单。一旦一个新的硬件出现的时候，我们要去使用新的硬件去对这个系统进行优化，会变得更简单。&lt;/p&gt;&lt;p line=&quot;4Orv&quot;&gt;&lt;/p&gt;&lt;p line=&quot;7zIu&quot;&gt;其实一个数据库系统的实现，是有需要去做进一步的解耦合，这里面其实有很多问题。我们去做了一些探索，但其实是非常有限的探索，我觉得这个工作其实可以有更多的人去做。我们做的探索，就是说想把并发控制直接从数据库的存储层抽离出来，然后让存储的代码跟并发控制的代码尽量的互不相关。&lt;/p&gt;&lt;p line=&quot;DOkc&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTD6s9cxJNvTgO3ldo2HcJ3SZHrbibI75OpDWPNGOFK4ChKl7icoZJ8yTA/640?wx_fmt=png&quot; data-cropx1=&quot;276.53979238754323&quot; data-cropx2=&quot;794.1176470588235&quot; data-cropy1=&quot;203.66782006920414&quot; data-cropy2=&quot;397.99307958477505&quot; data-ratio=&quot;0.3745173745173745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTJ8o5uft5AePSpPVrO54qdo8Xr42dfOUMHZiaarAibibh18xI1VHev8hicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;518&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;KtWr&quot;&gt;这是一个B-Tree的Search Function的例子，在教科书里面，关于B-Tree的Search，你可能会看到这样一个代码，非常简单。&lt;/p&gt;&lt;p line=&quot;nOrD&quot;&gt;       &lt;img data-backh=&quot;263&quot; data-backw=&quot;385&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTG1lTEqWBa3wu7Al8tT6qZXm6hctrfK30FoLUJicaNXhX2Zxb30wgGHw/640?wx_fmt=png&quot; data-cropx1=&quot;188.719723183391&quot; data-cropx2=&quot;908.0968858131488&quot; data-cropy1=&quot;117.71626297577853&quot; data-cropy2=&quot;609.1349480968858&quot; data-ratio=&quot;0.6833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTNoCTDlsAWGacibOniaAglickXiboOD0YdYKZCDlibwal8lYpuwD6jaAzSrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;wmaq&quot;&gt;但实际上一个B-Tree的Search没有那么简单，可以看到这里面有好多的东西，这还只是一个例子。如果对开源系统比较熟悉的话，一般的一个开源系统的B-Tree，差不多要将近十万行代码，非常复杂。&lt;/p&gt;&lt;p line=&quot;wmaq&quot;&gt;&lt;/p&gt;&lt;p line=&quot;AC2e&quot;&gt;这个代码为什么这么复杂？可以看到B-Tree里面有很多的锁，有比如Latch、Lock之类的很多东西，它实际上是在做并发控制。当然并发控制只是导致代码复杂的原因之一，但还有其他的原因，并发控制把这个代码变得远远的复杂于B-tree本身功能的程度。其实这就是数据库解耦合的一个动机，如果可以把耦合度解开，并发控制可以交给一个单独的模块去做，B-Tree的代码就可以像第一个例子那样写，事情就变得很简单。&lt;/p&gt;&lt;p line=&quot;Hm1Y&quot;&gt;       &lt;img data-backh=&quot;193&quot; data-backw=&quot;432&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTyuWTZKXsK15libXklicxuPice3N4cBF8GTpzMzDaXS3guGCCVvkIdNntQ/640?wx_fmt=png&quot; data-cropx1=&quot;134.53287197231833&quot; data-cropx2=&quot;941.7301038062284&quot; data-cropy1=&quot;164.42906574394462&quot; data-cropy2=&quot;525.0519031141868&quot; data-ratio=&quot;0.44609665427509293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT5icnEoibNu5kl3W1ASyx1PFZkehSia0MMEiaZYko7YUqCgpibibMV9dGxf0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;807&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;于是，我们就想如果把CC就是并发控制从数据库这种体系里面解耦出来应该怎么做？有很多种方式，最左边的这种其实是比较传统的方式，这种方式实际上并没有让数据库存储层变得更简单，只是在存储地上面做了一个事务处理层，这是一个比较浅的做法。中间的这种就是一个很暴力的做法，它是在物理的存储上面加一个Transaction Tier，然后在上面做存储做运算。&lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;&lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;大家应该听说过Transactional Memory，就是事务内存，这种就是直接用事务内存做事务处理，是一种很暴力的方式。最右边是我们提出来的方式，把并发控制的层次分成了两层，一种是我们叫操作层的并发控制，一种是事务层的并发控制，把它们合在一起变成一个新的模块。实践下来肯定是我们这种方式效果明显地更好，这种很暴力的事务内存的方式，实际上性能是不可以接受的。&lt;/p&gt;&lt;p line=&quot;tI2k&quot;&gt;&lt;/p&gt;&lt;p line=&quot;dTrb&quot;&gt;我们其实看到现在有一些做存储的同学，他有一些比较天真的想法，他认为把事务做到存储的最底层，然后上面就不需要关心事务了，实际上那是不行的。事务是跟系统的功能是有很多耦合的因子在里面的，不能完全把它抛弃掉。然后最左边这种方式的结果是不彻底的，实现B-tree的时候还是会挺复杂的。然后我们提出的这种方式，可以清楚的把CC给抽离出来。&lt;/p&gt;&lt;p line=&quot;aDJk&quot;&gt;       &lt;img data-backh=&quot;182&quot; data-backw=&quot;436&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT5iaScYviaz5CQicAAKw8Ak5araOeLKhjiaEfYjnqq8LJPdiacTOHb3jN9Ag/640?wx_fmt=png&quot; data-cropx1=&quot;142.00692041522493&quot; data-cropx2=&quot;956.6782006920415&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;485.81314878892726&quot; data-ratio=&quot;0.4176904176904177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTj2oD9s9TpVAsWYCnEI78DfTia2a4Aib6YjiceLztV2OY6icenxMyEiaNDCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;814&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;YSY0&quot;&gt;这个事情其实并不是那么的简单，上面是一个很简单的例子，A和B是两个物理数据，然后在数据库的数据结构里面，定义两个引用（&lt;span&gt;Reference&lt;/span&gt;），A1和A2，B1和B2，A1和A2都是指向A的，B1和B2都是指向B的。上面的事务层实际上是对A1、A2、B1、B2进行访问的。这个时候如果只是通过逻辑层去决定事物跟事物是否冲突的话，是会出错的。因为这里的逻辑层跟物理层，有一个重复引用的关系，可以看到下面这个事务处理的Schedule，从A1、A2、B1、B2这种方式去看，好像这两个事务这样处理是没问题的，它是有这种可串行化的能力的，但实际上并没有，因为A1和A2指向的是同样一个数据。&lt;/p&gt;&lt;p line=&quot;qbXP&quot;&gt;       &lt;img data-backh=&quot;191&quot; data-backw=&quot;505&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTIrNqI2M8waiarCOyicjmWGT3SmJwzzn39jzh1iaY0LqksLxVq899pl3hQ/640?wx_fmt=png&quot; data-cropx1=&quot;67.26643598615917&quot; data-cropx2=&quot;1010.8650519031141&quot; data-cropy1=&quot;160.69204152249134&quot; data-cropy2=&quot;517.5778546712802&quot; data-ratio=&quot;0.37857900318133614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTfLxkDrldBrEGksXbqK8NzJGw7PmPPgGQiaWIheAVgITg7H9icuSY8oZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;943&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;AeH5&quot;&gt;这种实际上就是说如果真的要去把这个事务抽离出来的时候，会有很多的问题需要去解决，我这里没有办法深入地探讨，总之我们做了这样一个尝试，我们叫Transparent Concurrency Control（&lt;span&gt;TCC&lt;/span&gt;），就是透明的并发控制的一种模式。&lt;/p&gt;&lt;p line=&quot;AeH5&quot;&gt;&lt;/p&gt;&lt;p line=&quot;AeH5&quot;&gt;我们把这个事务层抽成两层，一个是事务层次的并发控制，一个是操作层次的并发控制，让这两种东西能够配合起来使用。然后用户去编写程序的时候，他可以不要去关心操作层面的并发控制，他直接去写他的B-Tree就行了。但是写好B-Tree之后，在事务层次上的这种并发控制，需要提供一些语义的信息说明哪种操作跟哪种操作之间实际上是不会冲突的，这样整个事务处理过程就可以保证正确性和高效性。&lt;/p&gt;&lt;p line=&quot;IgJe&quot;&gt;       &lt;img data-backh=&quot;223&quot; data-backw=&quot;460&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTFu2ParAjJVYGdicq6VNEK3zMfIGmKr9wogskpVrKtvTCtEPoLdhwj6Q/640?wx_fmt=png&quot; data-cropx1=&quot;108.37370242214533&quot; data-cropx2=&quot;967.8892733564014&quot; data-cropy1=&quot;134.53287197231833&quot; data-cropy2=&quot;551.2110726643598&quot; data-ratio=&quot;0.48544819557625146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTmZO81dz21ofCXL2eUSm4LnictVQCa1nwCy0cctkVG5GiblJiahX94jFjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;859&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;gg5e&quot;&gt;我们做了一些实验，去验证这样的一个解耦。右边的这些图，这种圆圈的线代表原始数据库实现的性能，可以看到我们的方式（&lt;span&gt;TCC&lt;/span&gt;）的性能在很多情况下可以接近原始数据库的性能，这是解耦之后数据库的表现。很多时候解耦之后的表现可以接近原始数据库的性能，所以我们觉得这种解耦实际上还是可行的。但如果真的要把它用到一个现实的系统当中，其实并没有那么简单。这是我介绍的第二个研究工作，就是我们在数据库解耦上面的一些有趣的发现。&lt;/p&gt;&lt;p line=&quot;gg5e&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;2.2.3 新硬件&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;I4N8&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaT3kXadsGickTPyKzqNFAfEEUhql9nqXsHmNsxBtZfiajWE0FPLLiaK5ADA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;145.74394463667818&quot; data-cropy2=&quot;568.0276816608996&quot; data-ratio=&quot;0.3907407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTOl7dwhA1pr8uBmxvpEeKEBjorTkic4KKgOFd7RgXMb93EWNt24Aqs2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;8RxG&quot;&gt;最后我再谈一谈新硬件，就是这种非易失内存。英特尔的傲腾是现在市面上唯一的一个真正的非易失内存产品，图中是产品的相关指标。对于存储器件的话，我们一般看两个指标，一个是带宽，一个是延迟。&lt;/p&gt;&lt;p line=&quot;8RxG&quot;&gt;&lt;/p&gt;&lt;p line=&quot;8RxG&quot;&gt;可以看到它的带宽和延迟都是远远超过SSD，当然更加超过这种硬盘。它的价格会比SSD和硬盘要昂贵不少，但相对于内存而言，它还是便宜的，我们可以预测它后面会越来越便宜，它跟SSD之间的一个价格的差异会变得越来越小，所以以后它有可能会取代SSD这种固态硬盘，但是不会太早。这种新的存储，它的性能更好，又比内存的造价低，所以它以后在系统当中肯定是有很重要的一个位置的。现在有了这种硬件之后，我们需要讨论在数据库系统里面，这个硬件到底起什么作用，一个新的数据库的架构应该怎么去使用它？怎么定位它的价值和位置？&lt;/p&gt;&lt;p line=&quot;Nt28&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTiavTGlszibXJQiaHyX22JjBuJroHS4uSCXawAsczrUXHeWOMgFC5maJHQ/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;113.97923875432525&quot; data-cropy2=&quot;577.3702422145328&quot; data-ratio=&quot;0.42962962962962964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTeeiahla1YObFT4AwDtf3TviajIqycVySowAFZ02ib5viaM66qmsM5N3q5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;JQjv&quot;&gt;我们团队对这个东西讨论了很长的时间，最后有一个这样的设计，首先非易失内存这个东西，当然要用到数据库里面，数据库有各种形态的数据库，不同的形态的数据库使用方式是不一样的，但我们最后把它定位在云的数据库上面，因为我们知道云是未来的最主要的架构。在云的数据库上面怎么去用这个东西，我们觉得它跟RDMA的使用应该结合在一起。&lt;/p&gt;&lt;p line=&quot;u6pT&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTeZSRqaMZhwdfcLibhctwQgA36w32tcFwp23X5FnvRAHiazKW9cErqsXA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;104.63667820069203&quot; data-cropy2=&quot;554.9480968858131&quot; data-ratio=&quot;0.41759259259259257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTQXicvm7z9ZHqic2zuZmVtKkbmzXgzcZ6XfCUs1hEtQjNXib1G2XwwsdvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;现在的云数据库变成一种计算节点跟存储节点是相对分开的架构方式。然后一旦NVM加进来之后，我们希望它成为计算节点跟存储节点之间的一个缓存。我们觉得现在暂时不能用它来做全量数据的存储，因为它的价格实在是比较昂贵，很多冷的数据，完全没有必要存在这样昂贵的存储里面，所以它作为一种缓存，比较合适的。&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;另外一方面，它作为一个缓存，不应该是一个割裂的节点，因为我们去看它的性能指标，可以看到实际上这种非易失内存的吞吐、延迟，和在高速网络上的RDMA的吞吐和延迟是比较接近的。如果比较接近的话，这个器件是通过RDMA的远程去访问，还是通过本地访问的速度差异有可能并不会很大。如果这个速度的差异并不会很大的话，我们实际上是可以把多个节点的NVM联合在一起，作为共享的缓存，缓存共享有非常多的优势，省去了很多缓存数据同步的代价，然后还可以让系统的负载均衡变得更好。&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;8Olk&quot;&gt;&lt;span&gt;我们决定去设计这样一个系统架构。这个是NVM，我们叫存储节点和计算节点之间的一个缓存。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;gQEX&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTZoPoEQ56kVOic5vsKO1QBapAFsqQAuaFcXHTlw4bm51DbesfRd6ichrw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;102.76816608996539&quot; data-cropy2=&quot;562.4221453287197&quot; data-ratio=&quot;0.42592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTuAr5RrEfaukqKBEC3nSCLAnVoGG5uNhrFe4piaVTBsiaKkWaEoNzPrwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt;       &lt;/span&gt;&lt;img data-ratio=&quot;0.5632682574114244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTbhFb6ib4MKMlvTzrbF3kMdyAlnVZA8WnRSNwFdnDJwG9ZopViauuHiczw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1383&quot;/&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;vf9m&quot;&gt;我们这个事情正在做的过程中，所以目前为止我们是实现了一个分布式的缓存，可以作为共享缓存来用。我们开始讨论它应该是作为数据库而言，是行级别的缓存还是块级别的缓存，最后我们的选择是块级别的缓存，主要的原因还是因为实现起来更简单。我们先试一试，如果做到行级别的缓存的话，是有很多的工作量的，我们后期可能还会去尝试。&lt;/p&gt;&lt;p line=&quot;7vV5&quot;&gt;       &lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTT0VaGiawEjNpibdHn3TINOIVxBNyRSR3AuzpcytEGREf9lGkQJZyBEWA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;100.89965397923874&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.46944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTzE8VdQ9gXZ4iacUMK4wSian43eWU3H7ttMpqmENnkWWftYWaJeCbCeKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;
      &lt;/p&gt;&lt;p line=&quot;2G3d&quot;&gt;然后缓存的基本的测试，我们觉得我们的实现基本已经到位了，就是它的带宽的瓶颈基本上压到了RDMA访问带宽的瓶颈，如果要对它进行读写的话，它的瓶颈基本上就是RDMA远程访问的瓶颈，然后它的性能是远远高于像Redis这样的一个系统的，我们希望用这个缓存把它放在数据库里面，去提升这种云数据库的一个性能，但这个过程我们还在实现当中，我们有一些初步的结果，它是有一些效果的，特别是面对底层是SSD或者磁盘这样的系统的时候。我们希望后面有更明确结果的时候，再给大家介绍。&lt;/p&gt;&lt;p line=&quot;2G3d&quot;&gt;&lt;/p&gt;&lt;p line=&quot;ulnt&quot;&gt;&lt;span&gt;&lt;strong&gt;03 相关论文列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;       &lt;img data-backh=&quot;253&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTiawGPRfk7oF9ywo26L2qTiaDFy1JY5F93jjYQva4Lib8W10KgqLoibDsKw/640?wx_fmt=png&quot; data-cropx1=&quot;74.14925373134328&quot; data-cropx2=&quot;1005.8507462686567&quot; data-cropy1=&quot;157.78988441434143&quot; data-cropy2=&quot;563.5353014797909&quot; data-ratio=&quot;0.4371643394199785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXxeDF1tmBSQ3pIqCicPGPaTkXQ4WA6eNWibiaF6qKL6vgNxib9THIRXeY3xHRoeT0M0k2AEq7yGibD9cQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;931&quot;/&gt;&lt;span&gt;这是我们实验室的一些代表性论文，不是很全，我刚才讲的部分技术并不在列，因为还没有公开发表。如果感兴趣的话，大家可以阅读一下。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;写在后面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;华东师范大学周烜教授也是2020-2021年度美团科研课题合作学者。当前美团技术团队与超过30位来自国内外高校和科研院所的学者建立了科研课题合作。美团科研合作计划，基于美团在生活服务领域全场景里提炼出的科研命题，面向学术界征集前沿解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们致力于与学术界“一起解决真实世界的问题”，愿与学术界共同推动产学研成果落地。2021年将更加精彩纷呈，敬请期待。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753413&amp;amp;idx=2&amp;amp;sn=b121efdbbed54888f59a61fbcf7a7301&amp;amp;chksm=bd1252888a65db9e6a89e772298827fc302e22b6f84d17e9fa60c3bbe384e3988a9061920126&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;美团内部讲座｜清华大学莫一林：信息物理系统中的安全控制算法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753855&amp;amp;idx=2&amp;amp;sn=3032c8c0904fd8924fd8b8a0c71a5a6d&amp;amp;chksm=bd1254328a65dd2428955ee261ccc5a838ef7a1dbf5d920fc42dfebd7eff0748dea35429bf66&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;美团内部讲座｜北航全权：一种城市空中移动性管理分布式控制框架&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;| &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753413&amp;amp;idx=3&amp;amp;sn=580964919c613404f35864205ff69ed9&amp;amp;chksm=bd1252888a65db9eafea57ec18d9abc7a11de6bf30446c4beb7a21f37a0377633864355fc32c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651753413&amp;amp;idx=3&amp;amp;sn=580964919c613404f35864205ff69ed9&amp;amp;chksm=bd1252888a65db9eafea57ec18d9abc7a11de6bf30446c4beb7a21f37a0377633864355fc32c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;喜讯！美团-清华大数据课程对外开放啦！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;560&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;249&quot; data-ratio=&quot;0.44533333333333336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacsJ3aFxXFol84VVW89JYtgorr2aQnLz2YzwrVicCFXS7hEPGWvVJ6LWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1875&quot;/&gt;&lt;/p&gt;&lt;p line=&quot;ZP2M&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>