<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b830a8d762140c0cb944a559eabc9825</guid>
<title>缓存原理与微服务缓存自动管理</title>
<link>https://toutiao.io/k/t2bvzew</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;为什么需要缓存？&lt;/h2&gt;

&lt;p&gt;先从一个老生常谈的问题开始谈起：我们的程序是如何运行起来的？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;程序存储在 &lt;code&gt;disk&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;程序是运行在 &lt;code&gt;RAM&lt;/code&gt; 之中，也就是我们所说的 &lt;code&gt;main memory&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;程序的计算逻辑在 &lt;code&gt;CPU&lt;/code&gt; 中执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看一个最简单的例子：&lt;code&gt;a = a + 1&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;load x:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x0 = x0 + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load x0 -&amp;gt; RAM&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3dd026f6502435fb3c704e7e9512d27%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面提到了3种存储介质。我们都知道，三类的读写速度和成本成反比，所以我们在克服速度问题上需要引入一个 &lt;strong&gt;中间层&lt;/strong&gt;。这个中间层，需要高速存取的速度，但是成本可接受。于是乎，&lt;code&gt;Cache&lt;/code&gt; 被引入&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd6ad665a200454191b9691fa495399d%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而在计算机系统中，有两种默认缓存：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU 里面的末级缓存，即 &lt;code&gt;LLC&lt;/code&gt;。缓存内存中的数据&lt;/li&gt;
&lt;li&gt;内存中的高速页缓存，即 &lt;code&gt;page cache&lt;/code&gt;。缓存磁盘中的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;缓存读写策略&lt;/h2&gt;

&lt;p&gt;引入 &lt;code&gt;Cache&lt;/code&gt; 之后，我们继续来看看操作缓存会发生什么。因为存在存取速度的差异「而且差异很大」，从而在操作数据时，延迟或程序失败等都会导致缓存和实际存储层数据不一致。&lt;/p&gt;

&lt;p&gt;我们就以标准的 &lt;code&gt;Cache+DB&lt;/code&gt; 来看看经典读写策略和应用场景。&lt;/p&gt;

&lt;h3&gt;Cache Aside&lt;/h3&gt;

&lt;p&gt;先来考虑一种最简单的业务场景，比如用户表：&lt;code&gt;userId:用户id, phone:用户电话token，avtoar:用户头像url&lt;/code&gt;，缓存中我们用 &lt;code&gt;phone&lt;/code&gt; 作为key存储用户头像。当用户修改头像url该如何做？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;更新&lt;code&gt;DB&lt;/code&gt;数据，再更新&lt;code&gt;Cache&lt;/code&gt; 数据&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;DB&lt;/code&gt; 数据，再删除 &lt;code&gt;Cache&lt;/code&gt; 数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先 &lt;strong&gt;变更数据库&lt;/strong&gt; 和 &lt;strong&gt;变更缓存&lt;/strong&gt; 是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据不一致。&lt;/p&gt;

&lt;p&gt;所以更好的方案是 &lt;code&gt;2&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更新数据时不更新缓存，而是直接删除缓存&lt;/li&gt;
&lt;li&gt;后续的请求发现缓存缺失，回去查询 &lt;code&gt;DB&lt;/code&gt; ，并将结果 &lt;code&gt;load cache&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e581e968b4174e519714bddfab927e1d%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个策略就是我们使用缓存最常见的策略：&lt;code&gt;Cache Aside&lt;/code&gt;。这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的，分为读策略和写策略。&lt;/p&gt;

&lt;p&gt;但是可见的问题也就出现了：频繁的读写操作会导致 &lt;code&gt;Cache&lt;/code&gt; 反复地替换，缓存命中率降低。当然如果在业务中对命中率有监控报警时，可以考虑以下方案：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;更新数据时同时更新缓存，但是在更新缓存前加一个 &lt;strong&gt;分布式锁&lt;/strong&gt;。这样同一时间只有一个线程操作缓存，解决了并发问题。同时在后续读请求中时读到最新的缓存，解决了不一致的问题。&lt;/li&gt;
&lt;li&gt;更新数据时同时更新缓存，但是给缓存一个较短的 &lt;code&gt;TTL&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然除了这个策略，在计算机体系还有其他几种经典的缓存策略，它们也有各自适用的使用场景。&lt;/p&gt;

&lt;h3&gt;Write Through&lt;/h3&gt;

&lt;p&gt;先查询写入数据key是否击中缓存，如果在 -&amp;gt; 更新缓存，同时缓存组件同步数据至DB；不存在，则触发 &lt;code&gt;Write Miss&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而一般 &lt;code&gt;Write Miss&lt;/code&gt; 有两种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Write Allocate&lt;/code&gt;：写时直接分配 &lt;code&gt;Cache line&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;No-write allocate&lt;/code&gt;：写时不写入缓存，直接写入DB，return&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 &lt;code&gt;Write Through&lt;/code&gt; 中，一般采取 &lt;code&gt;No-write allocate&lt;/code&gt; 。因为其实无论哪种，最终数据都会持久化到DB中，省去一步缓存的写入，提升写性能。而缓存由 &lt;code&gt;Read Through&lt;/code&gt; 写入缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51d5e77a1929411992f16fbf3153965e%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个策略的核心原则：&lt;strong&gt;用户只与缓存打交道，由缓存组件和DB通信，写入或者读取数据&lt;/strong&gt;。在一些本地进程缓存组件可以考虑这种策略。&lt;/p&gt;

&lt;h3&gt;Write Back&lt;/h3&gt;

&lt;p&gt;相信你也看出上述方案的缺陷：写数据时缓存和数据库同步，但是我们知道这两块存储介质的速度差几个数量级，对写入性能是有很大影响。那我们是否异步更新数据库？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Write back&lt;/code&gt; 就是在写数据时只更新该 &lt;code&gt;Cache Line&lt;/code&gt; 对应的数据，并把该行标记为 &lt;code&gt;Dirty&lt;/code&gt;。在读数据时或是在缓存满时换出「缓存替换策略」时，将 &lt;code&gt;Dirty&lt;/code&gt; 写入存储。&lt;/p&gt;

&lt;p&gt;需要注意的是：在 &lt;code&gt;Write Miss&lt;/code&gt; 情况下，采取的是 &lt;code&gt;Write Allocate&lt;/code&gt;，即写入存储同时写入缓存，这样我们在之后的写请求只需要更新缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597824bcd15a4e9f853c8cb96bb326b2%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;async purge&lt;/code&gt; 此类概念其实存在计算机体系中。&lt;code&gt;Mysql&lt;/code&gt; 中刷脏页，本质都是尽可能防止随机写，统一写磁盘时机。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Redis&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;是一个独立的系统软件，和我们写的业务程序是两个软件。当我们部署了&lt;code&gt;Redis&lt;/code&gt; 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 &lt;code&gt;Redis&lt;/code&gt; 缓存，我们就要在程序中增加相应的缓存操作代码。所以我们也把 &lt;code&gt;Redis&lt;/code&gt; 称为 &lt;strong&gt;旁路缓存&lt;/strong&gt;，也就是说：读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。&lt;/p&gt;

&lt;p&gt;而作为缓存的 &lt;code&gt;Redis&lt;/code&gt;，同样需要面临常见的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缓存的容量终究有限&lt;/li&gt;
&lt;li&gt;上游并发请求冲击&lt;/li&gt;
&lt;li&gt;缓存与后端存储数据一致性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;替换策略&lt;/h3&gt;

&lt;p&gt;一般来说，缓存对于选定的被淘汰数据，会根据其是干净数据还是脏数据，选择直接删除还是写回数据库。但是，在 Redis 中，被淘汰数据无论干净与否都会被删除，所以，这是我们在使用 Redis 缓存时要特别注意的：当数据修改成为脏数据时，需要在数据库中也把数据修改过来。&lt;/p&gt;

&lt;p&gt;所以不管替换策略是什么，脏数据有可能在换入换出中丢失。那我们在产生脏数据就应该删除缓存，而不是更新缓存，一切数据应该以数据库为准。这也很好理解，缓存写入应该交给读请求来完成；写请求尽可能保证数据一致性。&lt;/p&gt;

&lt;p&gt;至于替换策略有哪些，网上已经有很多文章归纳之间的优劣，这里就不再赘述。&lt;/p&gt;

&lt;h3&gt;ShardCalls&lt;/h3&gt;

&lt;p&gt;并发场景下，可能会有多个线程（协程）同时请求同一份资源，如果每个请求都要走一遍资源的请求过程，除了比较低效之外，还会对资源服务造成并发的压力。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go-zero&lt;/code&gt; 中的 &lt;code&gt;ShardCalls&lt;/code&gt; 可以使得同时多个请求只需要发起一次拿结果的调用，其他请求&quot;坐享其成&quot;，这种设计有效减少了资源服务的并发压力，可以有效防止缓存击穿。&lt;/p&gt;

&lt;p&gt;对于防止暴增的接口请求对下游服务造成瞬时高负载，可以在你的函数包裹：&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;fn = func() (interface{}, error) {
  // 业务查询
}
data, err = g.Do(apiKey, fn)
// 就获得到data，之后的方法或者逻辑就可以使用这个data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实原理也很简单：&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;func (g *sharedGroup) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
  // done: false，才会去执行下面的业务逻辑；为 true，直接返回之前获取的data
  c, done := g.createCall(key)
  if done {
    return c.val, c.err
  }

  // 执行调用者传入的业务逻辑
  g.makeCall(c, key, fn)
  return c.val, c.err
}

func (g *sharedGroup) createCall(key string) (c *call, done bool) {
  // 只让一个请求进来进行操作
  g.lock.Lock()
  // 如果携带标示一系列请求的key在 calls 这个map中已经存在，
  // 则解锁并同时等待之前请求获取数据，返回
  if c, ok := g.calls[key]; ok {
    g.lock.Unlock()
    c.wg.Wait()
    return c, true
  }

  // 说明本次请求是首次请求
  c = new(call)
  c.wg.Add(1)
  // 标注请求，因为持有锁，不用担心并发问题
  g.calls[key] = c
  g.lock.Unlock()

  return c, false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种 &lt;code&gt;map+lock&lt;/code&gt; 存储并限制请求操作，和&lt;a href=&quot;https://github.com/golang/groupcache/tree/master/singleflight&quot;&gt;groupcache&lt;/a&gt;中的 &lt;code&gt;singleflight&lt;/code&gt; 类似，都是防止缓存击穿的利器&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/tal-tech/go-zero/blob/master/core/syncx/sharedcalls.go#L45&quot;&gt;sharedcalls.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;缓存和存储更新顺序&lt;/h3&gt;

&lt;p&gt;这是开发中常见纠结问题：&lt;strong&gt;到底是先删除缓存还是先更新存储？&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;情况一：先删除缓存，再更新存储；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 删除缓存，更新存储时网络延迟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 读请求，发现缓存缺失，读存储 -&amp;gt; 此时读到旧数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样会产生两个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 读取旧值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 同时读请求会把旧值写入缓存，导致后续读请求读到旧值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;既然是缓存可能是旧值，那就不管删除。有一个并不优雅的解决方案：&lt;strong&gt;在写请求更新完存储值以后，&lt;code&gt;sleep()&lt;/code&gt; 一小段时间，再进行一次缓存删除操作&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sleep&lt;/code&gt; 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据，当然也要考虑到 redis 主从同步的耗时。不过还是要根据实际业务而定。&lt;/p&gt;

&lt;p&gt;这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，被称为：&lt;strong&gt;延迟双删&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;情况二：先更新数据库值，再删除缓存值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 删除存储值，但是删除缓存网络延迟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 读请求时，缓存击中，就直接返回旧值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种情况对业务的影响较小，而绝大多数缓存组件都是采取此种更新顺序，满足最终一致性要求。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;情况三：新用户注册，直接写入数据库，同时缓存中肯定没有。如果程序此时读从库，由于主从延迟，导致读取不到用户数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种情况就需要针对 &lt;code&gt;Insert&lt;/code&gt; 这种操作：插入新数据入数据库同时写缓存。使得后续读请求可以直接读缓存，同时因为是刚插入的新数据，在一段时间修改的可能性不大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上方案在复杂的情况或多或少都有潜在问题，需要贴合业务做具体的修改&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;如何设计好用的缓存操作层？&lt;/h2&gt;

&lt;p&gt;上面说了这么多，回到我们开发角度，如果我们需要考虑这么多问题，显然太麻烦了。所以如何把这些缓存策略和替换策略封装起来，简化开发过程？&lt;/p&gt;

&lt;p&gt;明确几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将业务逻辑和缓存操作分离，留给开发这一个写入逻辑的点&lt;/li&gt;
&lt;li&gt;缓存操作需要考虑流量冲击，缓存策略等问题。。。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们从读和写两个角度去聊聊 &lt;code&gt;go-zero&lt;/code&gt;是如何封装。&lt;/p&gt;

&lt;h3&gt;QueryRow&lt;/h3&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;// res: query result
// cacheKey: redis key
err := m.QueryRow(&amp;amp;res, cacheKey, func(conn sqlx.SqlConn, v interface{}) error {
  querySQL := `select * from your_table where campus_id = ? and student_id = ?`
  return conn.QueryRow(v, querySQL, campusId, studentId)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将开发查询业务逻辑用 &lt;code&gt;func(conn sqlx.SqlConn, v interface{})&lt;/code&gt; 封装。用户无需考虑缓存写入，只需要传入需要写入的 &lt;code&gt;cacheKey&lt;/code&gt;。同时把查询结果 &lt;code&gt;res&lt;/code&gt; 返回。&lt;/p&gt;

&lt;p&gt;那缓存操作是如何被封装在内部呢？来看看函数内部：&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;func (c cacheNode) QueryRow(v interface{}, key string, query func(conn sqlx.SqlConn, v interface{}) error) error {
 cacheVal := func(v interface{}) error {
  return c.SetCache(key, v)
 }
 // 1. cache hit -&amp;gt; return
  // 2. cache miss -&amp;gt; err
 if err := c.doGetCache(key, v); err != nil {
    // 2.1 err defalut val {*}
  if err == errPlaceholder {
   return c.errNotFound
  } else if err != c.errNotFound {
   return err
  }
  // 2.2 cache miss -&amp;gt; query db
    // 2.2.1 query db return err {NotFound} -&amp;gt; return err defalut val「see 2.1」
  if err = query(c.db, v); err == c.errNotFound {
   if err = c.setCacheWithNotFound(key); err != nil {
    logx.Error(err)
   }

   return c.errNotFound
  } else if err != nil {
   c.stat.IncrementDbFails()
   return err
  }
  // 2.3 query db success -&amp;gt; set val to cache
  if err = cacheVal(v); err != nil {
   logx.Error(err)
   return err
  }
 }
 // 1.1 cache hit -&amp;gt; IncrementHit
 c.stat.IncrementHit()

 return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17ff7f8597754cfdb4256aa4bb983810%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从流程上恰好对应缓存策略中的：&lt;code&gt;Read Through&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/tal-tech/go-zero/blob/master/core/stores/sqlc/cachedsql.go#L75&quot;&gt;cachedsql.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Exec&lt;/h3&gt;

&lt;p&gt;而写请求，使用的就是之前缓存策略中的 &lt;code&gt;Cache Aside&lt;/code&gt;  -&amp;gt; 先写数据库，再删除缓存。&lt;/p&gt;

&lt;pre lang=&quot;go&quot;&gt;&lt;code&gt;_, err := m.Exec(func(conn sqlx.SqlConn) (result sql.Result, err error) {
  execSQL := fmt.Sprintf(&quot;update your_table set %s where 1=1&quot;, m.table, AuthRows)
  return conn.Exec(execSQL, data.RangeId, data.AuthContentId)
}, keys...)

func (cc CachedConn) Exec(exec ExecFn, keys ...string) (sql.Result, error) {
 res, err := exec(cc.db)
 if err != nil {
  return nil, err
 }

 if err := cc.DelCache(keys...); err != nil {
  return nil, err
 }

 return res, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和 &lt;code&gt;QueryRow&lt;/code&gt; 一样，调用者只需要负责业务逻辑，缓存写入和删除对调用透明。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/tal-tech/go-zero/blob/master/core/stores/sqlc/cachedsql.go#L58&quot;&gt;cachedsql.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;线上的缓存&lt;/h2&gt;

&lt;p&gt;开篇第一句话：脱离业务将技术都是耍流氓。以上都是在对缓存模式分析，但是实际业务中缓存是否起到应有的加速作用？最直观就是缓存击中率，而如何观测到服务的缓存击中？这就涉及到监控。&lt;/p&gt;

&lt;p&gt;下图是我们线上环境的某个服务的缓存记录情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85f2198e53074252a38e25c5cc5a2489%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还记得上面 &lt;code&gt;QueryRow&lt;/code&gt; 中：查询缓存击中，会调用 &lt;code&gt;c.stat.IncrementHit()&lt;/code&gt;。其中的 &lt;code&gt;stat&lt;/code&gt; 就是作为监控指标，不断在计算击中率和失败率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fa22049a75b4eba9eee94ad02dc3dc1%7Etplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/tal-tech/go-zero/blob/master/core/stores/cache/cachestat.go#L47&quot;&gt;cachestat.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在其他的业务场景中：比如首页信息浏览业务中，大量请求不可避免。所以缓存首页的信息在用户体验上尤其重要。但是又不像之前提到的一些单一的key，这里可能涉及大量消息，这个时候就需要其他缓存类型加入：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;拆分缓存：可以分 &lt;code&gt;消息id&lt;/code&gt; -&amp;gt; 由 &lt;code&gt;消息id&lt;/code&gt; 查询消息，并缓存插入&lt;code&gt;消息list&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;消息过期：设置消息过期时间，做到不占用过长时间缓存。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里也就是涉及缓存的最佳实践：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不允许不过期的缓存「尤为重要」&lt;/li&gt;
&lt;li&gt;分布式缓存，易伸缩&lt;/li&gt;
&lt;li&gt;自动生成，自带统计&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;本文从缓存的引入，常见缓存读写策略，如何保证数据的最终一致性，如何封装一个好用的缓存操作层，也展示了线上缓存的情况以及监控。所有上面谈到的这些缓存细节都可以参考 &lt;code&gt;go-zero&lt;/code&gt; 源码实现，见 &lt;code&gt;go-zero&lt;/code&gt; 源码的 &lt;code&gt;core/stores&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;项目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tal-tech/go-zero&quot;&gt;https://github.com/tal-tech/go-zero&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎使用 go-zero 并 &lt;strong&gt;star&lt;/strong&gt; 鼓励我们！👏🏻&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>69e3dde804b78157e58c8f23a1623570</guid>
<title>在 MySQL 中查询时间和日期</title>
<link>https://toutiao.io/k/i71sj4o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;MySQL 具有以下函数来获取当前日期和时间：&lt;/p&gt;

&lt;pre lang=&quot;sql&quot;&gt;&lt;code&gt;SELECT now();  -- datetime
SELECT curdate(); --date
SELECT curtime(); --time in 24-hour format
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要查找两个日期或时间戳之间的数据:&lt;/p&gt;

&lt;pre lang=&quot;sql&quot;&gt;&lt;code&gt;SELECT *
FROM task_instance
where execution_date between &#x27;2021-01-01&#x27; and &#x27;2021-01-31&#x27;;

-- 也可以写成时间戳格式
SELECT *
FROM task_instance
WHERE execution_date BETWEEN &#x27;2021-01-01 00:00:00&#x27; AND &#x27;2021-01-31 23:59:59&#x27;;

SELECT *
FROM task_instance
WHERE execution_date &amp;gt;= &#x27;2021-01-01&#x27; AND  execution_date &amp;lt; &#x27;2021-02-01&#x27;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询最近一周的数据:&lt;/p&gt;

&lt;pre lang=&quot;sql&quot;&gt;&lt;code&gt;SELECT *
FROM task_instance
WHERE execution_date &amp;gt; (now() + interval 1 week);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过函数&lt;code&gt;DATE_ADD&lt;/code&gt; 和　&lt;code&gt;DATE_SUB&lt;/code&gt; 来计算时间&lt;/p&gt;

&lt;pre lang=&quot;sql&quot;&gt;&lt;code&gt;SELECT *
FROM task_instance
WHERE execution_date BETWEEN DATE_SUB(now(), interval 1 week) AND DATE_ADD(now(), interval 1 day);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从时间戳里面提取年月日时分秒和星期几等：&lt;/p&gt;

&lt;pre lang=&quot;sql&quot;&gt;&lt;code&gt;SELECT year(now());
SELECT month(now());
SELECT day(now());
SELECT hour(now());
SELECT minute(now());
SELECT second(now());

SELECT dayofweek(now()); -- 从周日开始周六结束，所以 1 是周日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间戳转成UNIX时间戳&lt;/p&gt;

&lt;pre lang=&quot;sql&quot;&gt;&lt;code&gt;SELECT unix_timestamp(&#x27;2021-02-01&#x27;);
SELECT unix_timestamp(&#x27;2021-02-01 18:50:00&#x27;);
SELECT unix_timestamp(); -- 等同于 SELECT unix_timestamp(now());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算两个时间字段之间的间隔&lt;/p&gt;

&lt;pre lang=&quot;sql&quot;&gt;&lt;code&gt;SELECT unix_timestamp(end_date) - unix_timestamp(start_date)
FROM task_instance;

-- 用 sec_to_time 函数转换成时分秒格式

SELECT sec_to_time(unix_timestamp(end_date) - unix_timestamp(start_date))
FROM task_instance;

-- TIMEDIFF 转换成时分秒格式
SELECT TIMEDIFF(end_date, start_date)
FROM task_instance;

-- 计算间隔天数
SELECT DATEDIFF(&quot;2021-02-01&quot;, &quot;2020-06-30&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd34722ed22c0c6cadb4bcd8ea9766ea</guid>
<title>硬不硬你说了算！近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</title>
<link>https://toutiao.io/k/3a36mkk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;本文目录&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;init\&amp;quot;&amp;quot;],[20,&amp;quot;背景&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;9crj\&amp;quot;|list-start:\&amp;quot;1\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;简单幂等实现&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;JpMI\&amp;quot;|list-start:\&amp;quot;2\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;    2.1 数据库记录判断&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;No07\&amp;quot;&amp;quot;],[20,&amp;quot;    2.2 并发问题解决&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;XEao\&amp;quot;&amp;quot;],[20,&amp;quot;通用幂等实现&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;57em\&amp;quot;|list-start:\&amp;quot;3\&amp;quot;|ordered:\&amp;quot;decimal\&amp;quot;&amp;quot;],[20,&amp;quot;    3.1 设计方案&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Djsy\&amp;quot;&amp;quot;],[20,&amp;quot;        3.1.1 通用存储&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;XVDa\&amp;quot;&amp;quot;],[20,&amp;quot;        3.1.2 使用简单&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;lAmZ\&amp;quot;&amp;quot;],[20,&amp;quot;        3.1.3 支持注解&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;FuKa\&amp;quot;&amp;quot;],[20,&amp;quot;        3.1.4 多级存储&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;gehy\&amp;quot;&amp;quot;],[20,&amp;quot;        3.1.5 并发读写&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;f9PN\&amp;quot;&amp;quot;],[20,&amp;quot;        3.1.6 执行流程&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;9IHk\&amp;quot;&amp;quot;],[20,&amp;quot;    3.2 幂等接口&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;PGMT\&amp;quot;&amp;quot;],[20,&amp;quot;    3.3 幂等注解&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;LreR\&amp;quot;&amp;quot;],[20,&amp;quot;    3.4 自动区分重复请求&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;6TLO\&amp;quot;&amp;quot;],[20,&amp;quot;    3.5 存储结构&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;ImhL\&amp;quot;&amp;quot;],[20,&amp;quot;    3.6 源码地址&amp;quot;]]&quot;&gt;&lt;hr/&gt;&lt;blockquote cid=&quot;n234&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n238&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;越努力，越幸运，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n239&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;本文已收藏在GitHub中JavaCommunity, 里面有面试分享、源码分析系列文章，欢迎收藏，点赞&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n241&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/Ccww-lx/JavaCommunity&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h6&gt;&lt;span&gt;每日一句英语学习，每天进步一点点：&lt;/span&gt;&lt;br/&gt;&lt;/h6&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6628664495114006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843LuRdDiaPGWPhME1eaaeOETfz78Md5sNNzI7bHbGnhdkKiaytJZHYdNDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;不管面试 Java 、C/C++、Python 等开发岗位， &lt;code&gt;TCP&lt;/code&gt; 的知识点可以说是的必问的了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;任 TCP 虐我千百遍，我仍待 TCP 如初恋。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;遥想小林当年校招时常因 &lt;code&gt;TCP&lt;/code&gt; 面试题被刷，真是又爱又狠….&lt;/p&gt;&lt;p&gt;过去不会没关系，今天就让我们来消除这份恐惧，微笑着勇敢的面对它吧！&lt;/p&gt;&lt;p&gt;所以小林整理了关于 &lt;strong&gt;TCP 三次握手和四次挥手的面试题型&lt;/strong&gt;，跟大家一起探讨探讨。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TCP 基本认识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7391975308641975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843PvjUjeM1AEqsdRCeZCODPM3k8fNbTe2BHlme1VmNNKlz3L0wyWcQxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TCP 连接建立&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5197568389057751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8439Tu5oialB8LLgGRSjD36eicoafXOgndoBLicQa4JPEQB6Ud8DZrGhvq5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TCP 连接断开&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4977168949771689&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843WyTcnaErCIbRDmRYIWoo4ug9FkN86eDcnJSkibqQ6TSMv8qIO75Xd4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Socket 编程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.300314465408805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843iaiaB8VOItwTI3Vibxl1Xd1bQ1CF6ymhgQEZoYtVsViaePhIc09ib93LAag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;PS：本次文章不涉及 TCP 流量控制、拥塞控制、可靠性传输等方面知识，这些留在下篇哈！&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;01 TCP 基本认识&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;瞧瞧 TCP 头格式&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7863247863247863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843ZPb6tFLvCVuXEn98khfs7y2KRvOV0ia5icVByzIK3aAKRURuVZKagsKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1053&quot; title=&quot;TCP 头格式&quot;/&gt;&lt;figcaption&gt;TCP 头格式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;序列号&lt;/strong&gt;：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。&lt;strong&gt;用来解决网络包乱序问题。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;确认应答号&lt;/strong&gt;：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。&lt;strong&gt;用来解决不丢包的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;控制位：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;ACK&lt;/em&gt;：该位为 &lt;code&gt;1&lt;/code&gt; 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 &lt;code&gt;SYN&lt;/code&gt; 包之外该位必须设置为 &lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;RST&lt;/em&gt;：该位为 &lt;code&gt;1&lt;/code&gt; 时，表示 TCP 连接中出现异常必须强制断开连接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;SYC&lt;/em&gt;：该位为 &lt;code&gt;1&lt;/code&gt; 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;FIN&lt;/em&gt;：该位为 &lt;code&gt;1&lt;/code&gt; 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 &lt;code&gt;FIN&lt;/code&gt; 位置为 1 的 TCP 段。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么需要 TCP 协议？TCP 工作在哪一层？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;IP&lt;/code&gt; 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0847457627118644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843tzTAWL4l6rZB0pulNqkLno7buMqnh5Hlphn7aibB798ga1t3a0Dqmzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;472&quot; title=&quot;OSI 参考模型与 TCP/IP 的关系&quot;/&gt;&lt;figcaption&gt;OSI 参考模型与 TCP/IP 的关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 &lt;code&gt;TCP&lt;/code&gt; 协议来负责。&lt;/p&gt;&lt;p&gt;因为 TCP 是一个工作在&lt;strong&gt;传输层&lt;/strong&gt;的&lt;strong&gt;可靠&lt;/strong&gt;数据传输的服务，它能确保接收端接收的网络包是&lt;strong&gt;无损坏、无间隔、非冗余和按序的。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是 TCP ？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TCP 是&lt;strong&gt;面向连接的、可靠的、基于字节流&lt;/strong&gt;的传输层通信协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3112244897959184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8438HibyWCtJ5Tn9VN7YuzgAibg46Ocdf7swUxgeKMQ9ge8Nic3WOibTSxPXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;面向连接&lt;/strong&gt;：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可靠的&lt;/strong&gt;：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;字节流&lt;/strong&gt;：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;什么是 TCP 连接？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们来看看 RFC 793 是如何定义「连接」的：&lt;/p&gt;&lt;p&gt;&lt;em&gt;Connections: &lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;The reliability and flow control mechanisms described above require
that TCPs initialize and maintain certain status information for
each data stream.  &lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;The combination of this information, including
sockets, sequence numbers, and window sizes, is called a connection.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;简单来说就是，&lt;strong&gt;用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9479166666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843wVoVXxKKTibcN9sLAuSgibkDfV2X8LH8eicpV1yAJ1uffibGqAuWShXibYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;288&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Socket&lt;/strong&gt;：由 IP 地址和端口号组成&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;序列号&lt;/strong&gt;：用来解决乱序问题等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;窗口大小&lt;/strong&gt;：用来做流量控制&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如何唯一确定一个 TCP 连接呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TCP 四元组可以唯一的确定一个连接，四元组包括如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2777101096224117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843m0iaYviaJWmRyichZmR3x1gptwEsnJ6yAObqicnLkO0uNBwbYrxCoic27cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;821&quot; title=&quot;TCP 四元组&quot;/&gt;&lt;figcaption&gt;TCP 四元组&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。&lt;/p&gt;&lt;p&gt;源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;服务器通常固定在某个本地端口上监听，等待客户端的连接请求。&lt;/p&gt;&lt;p&gt;因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.06821963394342762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843wBh1Ca3jpEqO0Xia0YzlicCgFdhLw8N4f0TCfglTwtxzecpECvmhBtEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;对 IPv4，客户端的 IP 数最多为 &lt;code&gt;2&lt;/code&gt; 的 &lt;code&gt;32&lt;/code&gt; 次方，客户端的端口数最多为 &lt;code&gt;2&lt;/code&gt; 的 &lt;code&gt;16&lt;/code&gt; 次方，也就是服务端单机最大 TCP 连接数，约为 &lt;code&gt;2&lt;/code&gt; 的 &lt;code&gt;48&lt;/code&gt; 次方。&lt;/p&gt;&lt;p&gt;当然，服务端最大并发 TCP 连接数远不能达到理论上限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;UDP 和 TCP 有什么区别呢？分别的应用场景是？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。&lt;/p&gt;&lt;p&gt;UDP 协议真的非常简，头部只有 &lt;code&gt;8&lt;/code&gt; 个字节（ 64 位），UDP 的头部格式如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5977011494252874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8431Mymq2yPGjMPGodSEg8b31eoyQbibzGjDEHiaQUUDlbvCEwcXN3aicOTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;783&quot; title=&quot;UDP 头部格式&quot;/&gt;&lt;figcaption&gt;UDP 头部格式&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;TCP 和 UDP 区别：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;1. 连接&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;2. 服务对象&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;3. 可靠性&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;4. 拥塞控制、流量控制&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;5. 首部开销&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TCP 和 UDP 应用场景：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：&lt;/p&gt;&lt;p&gt;由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;包总量较少的通信，如 &lt;code&gt;DNS&lt;/code&gt; 、&lt;code&gt;SNMP&lt;/code&gt; 等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;视频、音频等多媒体通信&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;广播通信&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;原因是 TCP 有&lt;strong&gt;可变长&lt;/strong&gt;的「选项」字段，而 UDP 头部长度则是&lt;strong&gt;不会变化&lt;/strong&gt;的，无需多一个字段去记录 UDP 的首部长度。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;先说说 TCP 是如何计算负载数据长度：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.06156901688182721&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843bzI6JAcXCXOvBbURJoFAsBWnFrSCc8xibRxNEWerFaY8dWFJDlbYibaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。&lt;/p&gt;&lt;p&gt;大家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？为何还要有「包长度」呢？”&lt;/p&gt;&lt;p&gt;这么一问，确实感觉 UDP 「包长度」是冗余的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;因为为了网络设备硬件设计和处理方便，首部长度需要是 &lt;code&gt;4&lt;/code&gt;字节的整数倍。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 &lt;code&gt;4&lt;/code&gt; 字节的整数倍了，所以小林觉得这可能是为了补全 UDP 首部长度是 &lt;code&gt;4&lt;/code&gt; 字节的整数倍，才补充了「包长度」字段。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;02 TCP 连接建立&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;TCP 三次握手过程和状态变迁&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而&lt;strong&gt;建立连接是通过三次握手而进行的。&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8339483394833949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843fFol7gd3035Kibg3gPMSAZQLVibf9nwEblOUaX80hoOaRLVpaYCAI44w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot; title=&quot;TCP 三次握手&quot;/&gt;&lt;figcaption&gt;TCP 三次握手&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6035805626598465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843V0vbLBibXMvJbdiaqbfw4CictHX1Uc3OpOFWvZwxeI8B5Pv7y3beeAN9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot; title=&quot;第一个报文—— SYN 报文&quot;/&gt;&lt;figcaption&gt;第一个报文—— SYN 报文&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5959595959595959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS84320oABn0E6jjsYHLicn6L5mlunbCDWGImCCHs41AWjZMnV8P1qdM99fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1188&quot; title=&quot;第二个报文 —— SYN + ACK 报文&quot;/&gt;&lt;figcaption&gt;第二个报文 —— SYN + ACK 报文&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5959595959595959&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843OM01fA1X8oZ3wpr2AV8ngpjSJcyhoTQEAFKo8UdYMr456Fb5dv0alQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1188&quot; title=&quot;第三个报文 —— ACK 报文&quot;/&gt;&lt;figcaption&gt;第三个报文 —— ACK 报文&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从上面的过程可以发现&lt;strong&gt;第三次握手是可以携带数据的，前两次握手是不可以携带数据的&lt;/strong&gt;，这也是面试常问的题。&lt;/p&gt;&lt;p&gt;一旦完成三次握手，双方都处于 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，此致连接就已建立完成，客户端和服务端就可以相互发送数据了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如何在 Linux 系统中查看 TCP 状态？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TCP 的连接状态查看，在 Linux 可以通过 &lt;code&gt;netstat -napt&lt;/code&gt; 命令查看。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2092130518234165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843TdYaGI3f27nYYR47ibmH0iaV6zODCZhwpVoX7t7iasTTplcibpXXMib2DJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1563&quot; title=&quot;TCP 连接状态查看&quot;/&gt;&lt;figcaption&gt;TCP 连接状态查看&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;为什么是三次握手？不是两次、四次？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”&lt;/p&gt;&lt;p&gt;这回答是没问题，但这回答是片面的，并没有说出主要的原因。&lt;/p&gt;&lt;p&gt;在前面我们知道了什么是 &lt;strong&gt;TCP 连接&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;所以，重要的是&lt;strong&gt;为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接下来以三个方面分析三次握手的原因：&lt;/p&gt;&lt;p&gt;&lt;em&gt;原因一：避免历史连接&lt;/em&gt;&lt;/p&gt;&lt;p&gt;我们来看看 RFC 793 指出的 TCP 连接使用三次握手的&lt;strong&gt;首要原因&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;em&gt;The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;简单来说，三次握手的&lt;strong&gt;首要原因是为了防止旧的重复连接初始化造成混乱。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.3507604562737643&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8436nKau10lAsztRqbyhjC1C1GRcsEz04icZmomMjwcxgeGn97BnKUoxibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot; title=&quot;三次握手避免历史连接&quot;/&gt;&lt;figcaption&gt;三次握手避免历史连接&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;那么此时服务端就会回一个 &lt;code&gt;SYN + ACK&lt;/code&gt; 报文给客户端；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 &lt;code&gt;RST&lt;/code&gt; 报文给服务端，表示中止这一次连接。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：&lt;/p&gt;&lt;p&gt;所以， TCP 使用三次握手建立连接的最主要原因是&lt;strong&gt;防止历史连接初始化了连接。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;原因二：同步双方初始序列号&lt;/em&gt;&lt;/p&gt;&lt;p&gt;TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：&lt;/p&gt;&lt;p&gt;可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 &lt;code&gt;SYN&lt;/code&gt; 报文的时候，需要服务端回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，&lt;strong&gt;这样一来一回，才能确保双方的初始序列号能被可靠的同步。&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6567267683772539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843HWajXhQQfx6CH4EUxLqib0AAOXolZfIvuoEDkDoXaQ3RIceibo8ia9MQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1442&quot; title=&quot;四次握手与三次握手&quot;/&gt;&lt;figcaption&gt;四次握手与三次握手&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;四次握手其实也能够可靠的同步双方的初始化序号，但由于&lt;strong&gt;第二步和第三步可以优化成一步&lt;/strong&gt;，所以就成了「三次握手」。&lt;/p&gt;&lt;p&gt;而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。&lt;/p&gt;&lt;p&gt;&lt;em&gt;原因三：避免资源浪费&lt;/em&gt;&lt;/p&gt;&lt;p&gt;如果只有「两次握手」，当客户端的 &lt;code&gt;SYN&lt;/code&gt; 请求连接在网络中阻塞，客户端没有接收到 &lt;code&gt;ACK&lt;/code&gt; 报文，就会重新发送 &lt;code&gt;SYN&lt;/code&gt; ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 &lt;code&gt;ACK&lt;/code&gt; 确认信号，所以每收到一个 &lt;code&gt;SYN&lt;/code&gt; 就只能先主动建立一个连接，这会造成什么情况呢？&lt;/p&gt;&lt;p&gt;如果客户端的 &lt;code&gt;SYN&lt;/code&gt; 阻塞了，重复发送多次 &lt;code&gt;SYN&lt;/code&gt; 报文，那么服务器在收到请求后就会&lt;strong&gt;建立多个冗余的无效链接，造成不必要的资源浪费。&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.7228195937873356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843CaTeGEvR5jg3iaHbUTEroayMBUoK3yfy9zGwlIia8pJu8x4RDkDGFLicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot; title=&quot;两次握手会造成资源浪费&quot;/&gt;&lt;figcaption&gt;两次握手会造成资源浪费&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 &lt;code&gt;SYN&lt;/code&gt; 报文，而造成重复分配资源。&lt;/p&gt;&lt;p&gt;&lt;em&gt;小结&lt;/em&gt;&lt;/p&gt;&lt;p&gt;TCP 建立连接时，通过三次握手&lt;strong&gt;能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号&lt;/strong&gt;。序列号能够保证数据包不重复、不丢弃和按序传输。&lt;/p&gt;&lt;p&gt;不使用「两次握手」和「四次握手」的原因：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么客户端和服务端的初始序列号 ISN 是不相同的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;因为网络中的报文&lt;strong&gt;会延迟、会复制重发、也有可能丢失&lt;/strong&gt;，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;初始序列号 ISN 是如何随机产生的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;起始 &lt;code&gt;ISN&lt;/code&gt; 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。&lt;/p&gt;&lt;p&gt;RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。&lt;/p&gt;&lt;p&gt;&lt;em&gt;ISN = M + F (localhost, localport, remotehost, remoteport)&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们先来认识下 MTU 和 MSS&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.39550140581068416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS84378ic06fUySbbZgdeQ0uo6q0ulThJWexy6Bic6sJGCLVzkvXmvgjk7B2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1067&quot; title=&quot;MTU 与 MSS&quot;/&gt;&lt;figcaption&gt;MTU 与 MSS&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？&lt;/p&gt;&lt;p&gt;当 IP 层有一个超过 &lt;code&gt;MTU&lt;/code&gt; 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。&lt;/p&gt;&lt;p&gt;这看起来井然有序，但这存在隐患的，&lt;strong&gt;那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。&lt;/p&gt;&lt;p&gt;当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。&lt;/p&gt;&lt;p&gt;因此，可以得知由 IP 层进行分片传输，是非常没有效率的。&lt;/p&gt;&lt;p&gt;所以，为了达到最佳的传输效能 TCP 协议在&lt;strong&gt;建立连接的时候通常要协商双方的 MSS 值&lt;/strong&gt;，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12588652482269502&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843rY0QQwfo48NIMIACvuLSobQMva9xicjtGtGmcDtpPyrulyYXZLibYJjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;564&quot; title=&quot;握手阶段协商 MSS&quot;/&gt;&lt;figcaption&gt;握手阶段协商 MSS&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;经过 TCP 层分片后，如果一个 TCP 分片丢失后，&lt;strong&gt;进行重发时也是以 MSS 为单位&lt;/strong&gt;，而不用重传所有的分片，大大增加了重传的效率。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是 SYN 攻击？如何避免 SYN 攻击？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;em&gt;SYN 攻击&lt;/em&gt;&lt;/p&gt;&lt;p&gt;我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 &lt;code&gt;SYN&lt;/code&gt; 报文，服务端每接收到一个 &lt;code&gt;SYN&lt;/code&gt; 报文，就进入&lt;code&gt;SYN_RCVD&lt;/code&gt; 状态，但服务端发送出去的 &lt;code&gt;ACK + SYN&lt;/code&gt; 报文，无法得到未知 IP 主机的 &lt;code&gt;ACK&lt;/code&gt; 应答，久而久之就会&lt;strong&gt;占满服务端的 SYN 接收队列（未连接队列）&lt;/strong&gt;，使得服务器不能为正常用户服务。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843T2LZtpQAej3iasyuMyvrDvCiazkEndRXrsk2zvcjItPFl6QNvaov3DFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot; title=&quot;SYN 攻击&quot;/&gt;&lt;figcaption&gt;SYN 攻击&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;em&gt;避免 SYN 攻击方式一&lt;/em&gt;&lt;/p&gt;&lt;p&gt;其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;.core.netdev_max_backlog&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;.ipv4.tcp_max_syn_backlog&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;.ipv4.tcp_abort_on_overflow&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;避免 SYN 攻击方式二&lt;/em&gt;&lt;/p&gt;&lt;p&gt;我们先来看下Linux 内核的 &lt;code&gt;SYN&lt;/code&gt; （未完成连接建立）队列与 &lt;code&gt;Accpet&lt;/code&gt; （已完成连接建立）队列是如何工作的？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7042062415196744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843ACpyQCkuFKfWROystv5qxMPs71O9FCx9GiaGmeOjCSticOKcX2ZB9p4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot; title=&quot;正常流程&quot;/&gt;&lt;figcaption&gt;正常流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;正常流程：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用通过调用 &lt;code&gt;accpet()&lt;/code&gt; socket 接口，从「 Accept 队列」取出的连接。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6766623207301173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843AthUXYfJCiakrHFc22ibjA7wmEDrkqwYEsicASXSLfAfSicmFfKicuMLBwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot; title=&quot;应用程序过慢&quot;/&gt;&lt;figcaption&gt;应用程序过慢&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;应用程序过慢：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7659846547314578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8432qlbW7sdxgh2Y9E2PtEibl5ORa1Dxt3JhGJTsGpzUtwMxFfuxwnNzPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot; title=&quot;受到 SVN 攻击&quot;/&gt;&lt;figcaption&gt;受到 SYN 攻击&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;受到 SYN 攻击：&lt;/p&gt;&lt;p&gt;&lt;code&gt;tcp_syncookies&lt;/code&gt; 的方式可以应对 SYN 攻击的方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7401574803149606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843J4ygolhCqYoh52C8EFia9QUGsEY52oGTNicruORWBg0MD7TTeIiajh0rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot; title=&quot;tcp_syncookies 应对 SYN 攻击&quot;/&gt;&lt;figcaption&gt;tcp_syncookies 应对 SYN 攻击&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;计算出一个 &lt;code&gt;cookie&lt;/code&gt; 值，再以 SYN + ACK 中的「序列号」返回客户端，&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最后应用通过调用 &lt;code&gt;accpet()&lt;/code&gt; socket 接口，从「 Accept 队列」取出的连接。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;03 TCP 连接断开&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;TCP 四次挥手过程和状态变迁&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过&lt;strong&gt;四次挥手&lt;/strong&gt;方式。&lt;/p&gt;&lt;p&gt;双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0544488711819389&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843KaMMu2mHfFLZNgiaREDZ5JicRYrlaiciayQjh9HDsacxIbMT0emGUpAX5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot; title=&quot;客户端主动关闭连接 —— TCP 四次挥手&quot;/&gt;&lt;figcaption&gt;客户端主动关闭连接 —— TCP 四次挥手&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端打算关闭连接，此时会发送一个 TCP 首部 &lt;code&gt;FIN&lt;/code&gt; 标志位被置为 &lt;code&gt;1&lt;/code&gt; 的报文，也即 &lt;code&gt;FIN&lt;/code&gt; 报文，之后客户端进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端收到该报文后，就向客户端发送 &lt;code&gt;ACK&lt;/code&gt; 应答报文，接着服务端进入 &lt;code&gt;CLOSED_WAIT&lt;/code&gt; 状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端收到服务端的 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，之后进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等待服务端处理完数据后，也向客户端发送 &lt;code&gt;FIN&lt;/code&gt; 报文，之后服务端进入 &lt;code&gt;LAST_ACK&lt;/code&gt; 状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端收到服务端的 &lt;code&gt;FIN&lt;/code&gt; 报文后，回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，之后进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务器收到了 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，就进入了 &lt;code&gt;CLOSE&lt;/code&gt; 状态，至此服务端已经完成连接的关闭。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端在经过 &lt;code&gt;2MSL&lt;/code&gt; 一段时间后，自动进入 &lt;code&gt;CLOSE&lt;/code&gt; 状态，至此客户端也完成连接的关闭。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;你可以看到，每个方向都需要&lt;strong&gt;一个 FIN 和一个 ACK&lt;/strong&gt;，因此通常被称为&lt;strong&gt;四次挥手&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这里一点需要注意是：&lt;strong&gt;主动关闭连接的，才有 TIME_WAIT 状态。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么挥手需要四次？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;再来回顾下四次挥手双方发 &lt;code&gt;FIN&lt;/code&gt; 包的过程，就能理解为什么需要四次了。&lt;/p&gt;&lt;p&gt;从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 &lt;code&gt;ACK&lt;/code&gt; 和 &lt;code&gt;FIN&lt;/code&gt; 一般都会分开发送，从而比三次握手导致多了一次。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么 TIME_WAIT 等待的时间是 2MSL？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;MSL&lt;/code&gt; 是 Maximum Segment Lifetime，&lt;strong&gt;报文最大生存时间&lt;/strong&gt;，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 &lt;code&gt;TTL&lt;/code&gt; 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。&lt;/p&gt;&lt;p&gt;MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 &lt;strong&gt;MSL 应该要大于等于 TTL 消耗为 0 的时间&lt;/strong&gt;，以确保报文已被自然消亡。&lt;/p&gt;&lt;p&gt;TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以&lt;strong&gt;一来一回需要等待 2 倍的时间&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。&lt;/p&gt;&lt;p&gt;&lt;code&gt;2MSL&lt;/code&gt; 的时间是从&lt;strong&gt;客户端接收到 FIN 后发送 ACK 开始计时的&lt;/strong&gt;。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 &lt;strong&gt;2MSL 时间将重新计时&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;在 Linux 系统里 &lt;code&gt;2MSL&lt;/code&gt; 默认是 &lt;code&gt;60&lt;/code&gt; 秒，那么一个 &lt;code&gt;MSL&lt;/code&gt; 也就是 &lt;code&gt;30&lt;/code&gt; 秒。&lt;strong&gt;Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; TCP_TIMEWAIT_LEN (60*HZ) &lt;span&gt;/* how long to wait to destroy TIME-WAIT &lt;br/&gt;                                    state, about 60 seconds  */&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么需要 TIME_WAIT 状态？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;主动发起关闭连接的一方，才会有 &lt;code&gt;TIME-WAIT&lt;/code&gt; 状态。&lt;/p&gt;&lt;p&gt;需要 TIME-WAIT 状态，主要是两个原因：&lt;/p&gt;&lt;p&gt;&lt;em&gt;原因一：防止旧连接的数据包&lt;/em&gt;&lt;/p&gt;&lt;p&gt;假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0360576923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843VW5hMOGfQzFhXk6su4eND82ocOI6fKTB7dwUcuLCLIiciaTLSbjICYfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot; title=&quot;接收到历史数据的异常&quot;/&gt;&lt;figcaption&gt;接收到历史数据的异常&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;所以，TCP 就设计出了这么一个机制，经过 &lt;code&gt;2MSL&lt;/code&gt; 这个时间，&lt;strong&gt;足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;原因二：保证连接正确关闭&lt;/em&gt;&lt;/p&gt;&lt;p&gt;在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：&lt;/p&gt;&lt;p&gt;&lt;em&gt;TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;也就是说，TIME-WAIT 作用是&lt;strong&gt;等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7939093484419264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843qohxKiaI9HTRicKXwNWLDoap0OabBhnaNeuibYrrtLvFAFWwoSgum6N2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot; title=&quot;没有确保正常断开的异常&quot;/&gt;&lt;figcaption&gt;没有确保正常断开的异常&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：&lt;/p&gt;&lt;p&gt;所以客户端在 &lt;code&gt;TIME-WAIT&lt;/code&gt; 状态等待 &lt;code&gt;2MSL&lt;/code&gt; 时间后，就可以&lt;strong&gt;保证双方的连接都可以正常的关闭。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;TIME_WAIT 过多有什么危害？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。&lt;/p&gt;&lt;p&gt;过多的 TIME-WAIT 状态主要的危害有两种：&lt;/p&gt;&lt;p&gt;第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 &lt;code&gt;32768～61000&lt;/code&gt;，也可以通过如下参数设置指定&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;.ipv4.ip_local_port_range&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;如果服务端 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如何优化 TIME_WAIT？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;net.ipv4.tcp_max_tw_buckets&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;程序中使用 SO_LINGER ，应用强制使用 RST 关闭。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps&lt;/em&gt;&lt;/p&gt;&lt;p&gt;如下的 Linux 内核参数开启后，则可以&lt;strong&gt;复用处于 TIME_WAIT 的 socket 为新的连接所用&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_tw_reuse = 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即&lt;/p&gt;&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_timestamps=1（默认即为 1）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。&lt;/p&gt;&lt;p&gt;由于引入了时间戳，我们在前面提到的 &lt;code&gt;2MSL&lt;/code&gt; 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。&lt;/p&gt;&lt;p&gt;温馨提醒：&lt;code&gt;net.ipv4.tcp_tw_reuse&lt;/code&gt;要慎用，因为使用了它就必然要打开时间戳的支持 &lt;code&gt;net.ipv4.tcp_timestamps&lt;/code&gt;，&lt;strong&gt;当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉&lt;/strong&gt;。小林在工作中就遇到过。。。排查了非常的久&lt;/p&gt;&lt;p&gt;&lt;em&gt;方式二：net.ipv4.tcp_max_tw_buckets&lt;/em&gt;&lt;/p&gt;&lt;p&gt;这个值默认为 18000，当系统中处于 TIME_WAIT 的连接&lt;strong&gt;一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。&lt;/p&gt;&lt;p&gt;&lt;em&gt;方式三：程序中使用 SO_LINGER&lt;/em&gt;&lt;/p&gt;&lt;p&gt;我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;linger&lt;/span&gt; &lt;span&gt;so_linger&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;so_linger.l_onoff = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;so_linger.l_linger = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;amp;so_linger,&lt;span&gt;sizeof&lt;/span&gt;(so_linger));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果&lt;code&gt;l_onoff&lt;/code&gt;为非 0， 且&lt;code&gt;l_linger&lt;/code&gt;值为 0，那么调用&lt;code&gt;close&lt;/code&gt;后，会立该发送一个&lt;code&gt;RST&lt;/code&gt;标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，直接关闭。&lt;/p&gt;&lt;p&gt;但这为跨越&lt;code&gt;TIME_WAIT&lt;/code&gt;状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果已经建立了连接，但是客户端突然出现故障了怎么办？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TCP 有一个机制是&lt;strong&gt;保活机制&lt;/strong&gt;。这个机制的原理是这样的：&lt;/p&gt;&lt;p&gt;定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。&lt;/p&gt;&lt;p&gt;在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_keepalive_time=7200&lt;br/&gt;net.ipv4.tcp_keepalive_intvl=75  &lt;br/&gt;net.ipv4.tcp_keepalive_probes=9&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3377926421404682&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843ibOkA76vK9uapCGP4jU5Kw7RBK03IhXDGAkpjT80XEMDm4uicEwNLN7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这个时间是有点长的，我们也可以根据实际的需求，对以上的保活相关的参数进行设置。&lt;/p&gt;&lt;p&gt;如果开启了 TCP 保活，需要考虑以下几种情况：&lt;/p&gt;&lt;p&gt;第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 &lt;strong&gt;TCP 保活时间会被重置&lt;/strong&gt;，等待下一个 TCP 保活时间的到来。&lt;/p&gt;&lt;p&gt;第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，&lt;strong&gt;会产生一个 RST 报文&lt;/strong&gt;，这样很快就会发现 TCP 连接已经被重置。&lt;/p&gt;&lt;p&gt;第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，&lt;strong&gt;TCP 会报告该 TCP 连接已经死亡&lt;/strong&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;03 Socket 编程&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;针对 TCP 应该如何 Socket 编程？&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8476430976430976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8436ACEChhUgLWdrnLISt2gyF5LrC5D3yrnQHtgGQHj4iaTwUBqz4VEW5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1188&quot; title=&quot;基于 TCP 协议的客户端和服务器工作&quot;/&gt;&lt;figcaption&gt;基于 TCP 协议的客户端和服务器工作&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;服务端和客户端初始化 &lt;code&gt;socket&lt;/code&gt;，得到文件描述符；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端调用 &lt;code&gt;bind&lt;/code&gt;，将绑定在 IP 地址和端口;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端调用 &lt;code&gt;listen&lt;/code&gt;，进行监听；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端调用 &lt;code&gt;accept&lt;/code&gt;，等待客户端连接；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端调用 &lt;code&gt;connect&lt;/code&gt;，向服务器端的地址和端口发起连接请求；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端 &lt;code&gt;accept&lt;/code&gt; 返回用于传输的 &lt;code&gt;socket&lt;/code&gt; 的文件描述符；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端调用 &lt;code&gt;write&lt;/code&gt; 写入数据；服务端调用 &lt;code&gt;read&lt;/code&gt; 读取数据；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端断开连接时，会调用 &lt;code&gt;close&lt;/code&gt;，那么服务端 &lt;code&gt;read&lt;/code&gt; 读取数据的时候，就会读取到了 &lt;code&gt;EOF&lt;/code&gt;，待处理完数据后，服务端调用 &lt;code&gt;close&lt;/code&gt;，表示连接关闭。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里需要注意的是，服务端调用 &lt;code&gt;accept&lt;/code&gt; 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。&lt;/p&gt;&lt;p&gt;所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作&lt;strong&gt;监听 socket&lt;/strong&gt;，一个叫作&lt;strong&gt;已完成连接 socket&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;listen 时候参数 backlog 的意义？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Linux内核中会维护两个队列：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9334811529933481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8430Kt5CTsvVQ1mDUje71yzWXvib7sORcicJ97E3aDTtZoNKN41yBTGG0Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; title=&quot;SYN 队列 与 Accpet 队列&quot;/&gt;&lt;figcaption&gt;SYN 队列 与 Accpet 队列&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;listen&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt; socketfd, &lt;span&gt;int&lt;/span&gt; backlog)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。&lt;/p&gt;&lt;p&gt;在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，&lt;strong&gt;所以现在通常认为 backlog 是 accept 队列。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;accept 发送在三次握手的哪一步？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们先看看客户端连接服务端时，发送了什么？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7643742953776775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843DNG7QkUgx7nngibHCicOCGsJuxwKHodNPFRUFufaygVEyPKfRxLXyib0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;887&quot; title=&quot;客户端连接服务端&quot;/&gt;&lt;figcaption&gt;客户端连接服务端&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 client_isn，客户端进入 SYNC_SENT 状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务器端进入 SYNC_RCVD 状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端协议栈收到 ACK 之后，使得应用程序从 &lt;code&gt;connect&lt;/code&gt; 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 server_isn+1；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应答包到达服务器端后，服务器端协议栈使得 &lt;code&gt;accept&lt;/code&gt; 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;从上面的描述过程，我们可以得知&lt;strong&gt;客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;客户端调用 close 了，连接是断开的流程是什么？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们看看客户端主动调用了 &lt;code&gt;close&lt;/code&gt;，会发生什么？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0544488711819389&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843MWlg2EawibAicfiaFrloAWoZRUwKrsuqZJKabqbVAvg1s92N2DHd9Msfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot; title=&quot;客户端调用 close 过程&quot;/&gt;&lt;figcaption&gt;客户端调用 close 过程&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端调用 &lt;code&gt;close&lt;/code&gt;，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 &lt;code&gt;EOF&lt;/code&gt; 到接收缓冲区中，应用程序可以通过 &lt;code&gt;read&lt;/code&gt; 调用来感知这个 FIN 包。这个 &lt;code&gt;EOF&lt;/code&gt; 会被&lt;strong&gt;放在已排队等候的其他已接收的数据之后&lt;/strong&gt;，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;接着，当处理完数据后，自然就会读到 &lt;code&gt;EOF&lt;/code&gt;，于是也调用 &lt;code&gt;close&lt;/code&gt; 关闭它的套接字，这会使得会发出一个 FIN 包，之后处于 LAST_ACK 状态；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端进过 &lt;code&gt;2MSL&lt;/code&gt; 时间之后，也进入 CLOSED 状态；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h6&gt;&lt;span&gt;巨人的肩膀&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;&lt;span&gt;[1] 趣谈网络协议专栏.刘超.极客时间.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2] 网络编程实战专栏.盛延敏.极客时间.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3] 计算机网络-自顶向下方法.陈鸣 译.机械工业出版社&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4] TCP/IP详解 卷1：协议.范建华 译.机械工业出版社&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5] 图解TCP/IP.竹下隆史.人民邮电出版社&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6] https://www.rfc-editor.org/rfc/rfc793.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[7] https://draveness.me/whys-the-design-tcp-three-way-handshake&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[9] https://draveness.me/whys-the-design-tcp-time-wait&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e34c02296cd253309bd154134d4dad1</guid>
<title>条分缕析 Raft 算法</title>
<link>https://toutiao.io/k/pa5a9hf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;em&gt;&lt;strong data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(0, 0, 0)&quot; data-style=&quot;max-width: 100%; font-size: medium; letter-spacing: 0.544px; text-align: start; white-space: normal; caret-color: rgb(52, 73, 94); background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot; data-darkmode-color-16094149065186=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(0, 0, 0)&quot; data-darkmode-color-16107273892940=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-color-16121907968588=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-color-16094149065186=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(136, 136, 136)&quot; data-darkmode-color-16107273892940=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-color-16121907968588=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(217, 33, 66)&quot; data-darkmode-color-16094149065186=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(217, 33, 66)&quot; data-darkmode-color-16107273892940=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-color-16121907968588=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(217, 33, 66)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot;&gt;▲ &lt;/span&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(2, 30, 170)&quot; data-style=&quot;max-width: 100%; color: rgb(2, 30, 170); text-align: center; font-size: 11px; letter-spacing: 1px; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__2&quot; data-darkmode-color-16094149065186=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(2, 30, 170)&quot; data-darkmode-color-16107273892940=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-color-16121907968588=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(2, 30, 170)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot;&gt;点击上方&quot;多颗糖&quot;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(62, 62, 62)&quot; data-style=&quot;max-width: 100%; color: rgb(62, 62, 62); text-align: center; font-size: 11px; letter-spacing: 1px; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot; data-darkmode-color-16094149065186=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(62, 62, 62)&quot; data-darkmode-color-16107273892940=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16107273892940=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(62, 62, 62)&quot; data-darkmode-color-16121907968588=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16121907968588=&quot;#fff|rgb(52, 73, 94)|rgb(0, 0, 0)|rgb(136, 136, 136)|rgb(62, 62, 62)&quot; data-darkmode-bgcolor-16121907968588=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16121907968588=&quot;#fff|rgb(255, 255, 255)&quot;&gt;关注公众号&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;本文整理自 Ongaro 在 Youtube 上的视频。&lt;/em&gt;&lt;/p&gt;&lt;h2&gt;目标&lt;/h2&gt;&lt;p&gt;Raft 的目标（或者说是分布式共识算法的目标）是：&lt;strong&gt;保证 log 完全相同地复制到多台服务器上&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35764235764235763&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic3906cUlV5niaAMrHFXiaoZph1eCmsAibK2JKOx42wWoB4KpFH3XMmvPkRDag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2002&quot;/&gt;&lt;/p&gt;&lt;p&gt;只要每台服务器的日志相同，那么，在不同服务器上的状态机以相同顺序从日志中执行相同的命令，将会产生相同的结果。&lt;/p&gt;&lt;p&gt;共识算法的工作就是管理这些日志。&lt;/p&gt;&lt;h2&gt;系统模型&lt;/h2&gt;&lt;p&gt;我们假设：&lt;/p&gt;&lt;p&gt;Raft 是基于 Leader 的共识算法，故主要考虑：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader 正常运行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 故障，必须选出新的 Leader&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;优点：只有一个 Leader，简单。&lt;/p&gt;&lt;p&gt;难点：&lt;strong&gt;Leader 发生改变时，可能会使系统处于不一致的状态，因此，下一任 Leader 必须进行清理；&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们将从 6 个部分解释 Raft：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader 选举；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;正常运行：日志复制（最简单的部分）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 变更时的安全性和一致性（最棘手、最关键的部分）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理旧 Leader：旧的 Leader 并没有真的下线怎么办？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;客户端交互：实现线性化语义(linearizable semantics)；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;配置变更：如何在集群中增加或删除节点；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;开始之前&lt;/h2&gt;&lt;p&gt;开始之前需要了解 Raft 的一些术语。&lt;/p&gt;&lt;h3&gt;服务器状态&lt;/h3&gt;&lt;p&gt;服务器在任意时间只能处于以下三种状态之一：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;系统正常运行时，只有一个 Leader，其余都是 Followers.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;状态转换图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35294117647058826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390aEUv3yVxXicGYHqKxO1T39O352iaWyduWTO35Id0FuBia9zo4k0jMRbfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1870&quot;/&gt;&lt;/p&gt;&lt;h3&gt;任期&lt;/h3&gt;&lt;p&gt;时间被划分成一个个的&lt;strong&gt;任期(Term)&lt;/strong&gt;，每个任期都由一个数字来表示任期号，任期号单调递增并且永远不会重复。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2598639455782313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390uhbZCcaTLmEoQSMpAXoUQGkiaDxByGt0wpiaK51hPZ42icoIONzIdnMOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot;/&gt;&lt;/p&gt;&lt;p&gt;一个正常的任期至少有一个 Leader，通常分为两部分：&lt;/p&gt;&lt;p&gt;有些任期可能没有选出 Leader（如图 Term 3），这时候会立即进入下一个任期，再次尝试选出一个 Leader。&lt;/p&gt;&lt;p&gt;每个节点维护一个 &lt;code&gt;currentTerm&lt;/code&gt; 变量，表示系统中当前任期。&lt;code&gt;currentTerm&lt;/code&gt; &lt;strong&gt;必须持久化存储&lt;/strong&gt;，以便在服务器宕机重启时将其恢复。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;任期非常重要！任期能够帮助 Raft 识别过期的信息。&lt;/strong&gt;例如：如果 &lt;code&gt;currentTerm = 2&lt;/code&gt; 的节点与 &lt;code&gt;currentTerm = 3&lt;/code&gt; 的节点通信，我们可以知道第一个节点上的信息是过时的。&lt;/p&gt;&lt;p&gt;我们只使用最新任期的信息。后面我们会遇到各种情况，去检测和消除不是最新任期的信息。&lt;/p&gt;&lt;h3&gt;两个 RPC&lt;/h3&gt;&lt;p&gt;Raft 中服务器之间所有类型的通信通过两个 RPC 调用：&lt;/p&gt;&lt;h2&gt;1. Leader 选举&lt;/h2&gt;&lt;h3&gt;启动&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46091954022988507&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390rbmR4QTiaecDNuhI7ibM57cDRA9sTmicGhIVicCQgTf7P5mZGD4DAjnO6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1740&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;节点启动时，都是 Follower 状态；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Follower 被动地接受 Leader 或 Candidate 的 RPC；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所以，如果 Leader 想要保持权威，必须向集群中的其它节点发送心跳包（空的 &lt;code&gt;AppendEntries RPC&lt;/code&gt;）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等待选举超时(&lt;code&gt;electionTimeout&lt;/code&gt;，一般在 100~500ms)后，Follower 没有收到任何 RPC：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Follower 认为集群中没有 Leader&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开始新的一轮选举&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3&gt;选举&lt;/h3&gt;&lt;p&gt;当一个节点开始竞选：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;获得超过半数的选票：成为 Leader，并向其它节点发送 &lt;code&gt;AppendEntries&lt;/code&gt; 心跳；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;收到来自 Leader 的 RPC：转为 Follower；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其它两种情况都没发生，没人能够获胜(&lt;code&gt;electionTimeout&lt;/code&gt; 已过)：增加 &lt;code&gt;currentTerm&lt;/code&gt;，开始新一轮选举；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6734317343173432&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390u9eAcpaF6WrF5bZibUibrISnFXeAR6CG9qsiatTyLpApAxXpyCh2H54Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/p&gt;&lt;h3&gt;选举安全性&lt;/h3&gt;&lt;p&gt;选举过程需要保证两个特性：&lt;strong&gt;安全性(safety)&lt;/strong&gt;和&lt;strong&gt;活性(liveness)&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;安全性(safety)：一个任期内只会有一个 Leader 被选举出来。需要保证：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14987405541561713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390ibL530UicXPKyYtOfmakUbHbL4PL3E7uYrHapxxfw5bT0iaaNjib26icbhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1588&quot;/&gt;&lt;/p&gt;&lt;p&gt;活性(liveness)：确保最终能选出一个 Leader。&lt;/p&gt;&lt;p&gt;问题是：原则上我们可以无限重复分割选票，假如选举同一时间开始，同一时间超时，同一时间再次选举，如此循环。&lt;/p&gt;&lt;p&gt;解决办法很简单：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;节点随机选择超时时间，通常在 [T, 2T] 之间（T = &lt;code&gt;electionTimeout&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;这样，节点不太可能再同时开始竞选，先竞选的节点有足够的时间来索要其他节点的选票&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;T &amp;gt;&amp;gt; broadcast time(T 远大于广播时间)时效果更佳&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2. 日志复制&lt;/h2&gt;&lt;h3&gt;日志结构&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42492639842983315&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390VOTs4VxN2O2SnQFFmHSoBnyZdYl3FIURs9Lc9icodlnKEMib9nQGbAibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2038&quot;/&gt;&lt;/p&gt;&lt;p&gt;每个节点存储自己的日志副本(&lt;code&gt;log[]&lt;/code&gt;)，每条日志记录包含：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;索引：该记录在日志中的位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;任期号：该记录首次被创建时的任期号&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;命令&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;日志必须持久化存储。&lt;/strong&gt;一个节点必须先将记录安全写到磁盘，才能向系统中其他节点返回响应。&lt;/p&gt;&lt;p&gt;如果一条日志记录被存储在超过半数的节点上，我们认为该记录&lt;strong&gt;已提交&lt;/strong&gt;(&lt;code&gt;committed&lt;/code&gt;)——这是 Raft 非常重要的特性！如果一条记录已提交，意味着状态机可以安全地执行该记录。&lt;/p&gt;&lt;p&gt;在上图中，第 1-7 条记录被提交，第 8 条尚未提交。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;提醒：多数派复制了日志即已提交，这个定义并不精确，我们会在后面稍作修改。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;正常运行&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端向 Leader 发送命令，希望该命令被所有状态机执行；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 先将该命令追加到自己的日志中；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Leader 并行地向其它节点发送 &lt;code&gt;AppendEntries RPC&lt;/code&gt;，等待响应；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;收到超过半数节点的响应，则认为新的日志记录是被提交的：&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果 Follower 宕机/超时：Leader 将反复尝试发送 RPC；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;性能优化：Leader 不必等待每个 Follower 做出响应，只需要超过半数的成功响应（确保日志记录已经存储在超过半数的节点上）——一个很慢的节点不会使系统变慢，因为 Leader 不必等他；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;日志一致性&lt;/h3&gt;&lt;p&gt;Raft 尝试在集群中保持日志较高的一致性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Raft 日志的 index 和 term 唯一标示一条日志记录。&lt;/strong&gt;（这非常重要！！！）&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果两个节点的日志在相同的索引位置上的任期号相同，则认为他们具有一样的命令；&lt;strong&gt;从头到这个索引位置之间的日志完全相同&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;如果给定的记录已提交，那么所有前面的记录也已提交&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;code&gt;AppendEntries&lt;/code&gt; 一致性检查&lt;/h3&gt;&lt;p&gt;Raft 通过 &lt;code&gt;AppendEntries RPC&lt;/code&gt; 来检测这两个属性。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3379174852652259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390Gkk4qrtHQqbVQQljlFwwmoTJf13B2XYLdFQkFh66T8Jo4v0z5xAeKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2036&quot;/&gt;&lt;/p&gt;&lt;h2&gt;3. Leader 更替&lt;/h2&gt;&lt;p&gt;当新的 Leader 上任后，日志可能不会非常干净，因为前一任领导可能在完成日志复制之前就宕机了。&lt;strong&gt;Raft 对此的处理方式是：无需采取任何特殊处理。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当新 Leader 上任后，他不会立即进行任何清理操作，他将会在正常运行期间进行清理。&lt;/p&gt;&lt;p&gt;原因是当一个新的 Leader 上任时，往往意味着有机器故障了，那些机器可能宕机或网络不通，所以没有办法立即清理他们的日志。在机器恢复运行之前，我们必须保证系统正常运行。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;大前提是 Raft 假设了 Leader 的日志始终是对的。&lt;/strong&gt;所以 Leader 要做的是，随着时间推移，让所有 Follower 的日志最终都与其匹配。&lt;/p&gt;&lt;p&gt;但与此同时，Leader 也可能在完成这项工作之前故障，日志会在一段时间内堆积起来，从而造成看起来相当混乱的情况，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5842696629213483&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390rprMk8iaPA4RA2viatXUmc7MHq98zyuLhia2J1OlQK9sKEsicKg7wBVsQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/p&gt;&lt;p&gt;因为我们已经知道 index 和 term 是日志记录的唯一标识符，这里不再显示日志包含的命令，下同。&lt;/p&gt;&lt;p&gt;如图，这种情况可能出现在 S4 和 S5 是任期 2、3、4 的 Leader，但不知何故，他们没有复制自己的日志记录就崩溃了，系统分区了一段时间，S1、S2、S3 轮流成为了任期 5、6、7 的 Leader，但无法与 S4、S5 通信以进行日志清理——所以我们看到的日志非常混乱。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;唯一重要的是，索引 1-3 之间的记录是已提交的(已存在多数派节点)，因此我们必须确保留下它们&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;其它日志都是未提交的，我们还没有将这些命令传递给状态机，也没有客户端会收到这些执行的结果，所以不管是保留还是丢弃它们都无关紧要。&lt;/p&gt;&lt;h3&gt;安全性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一旦状态机执行了一条日志里的命令，必须确保其它状态机在同样索引的位置不会执行不同的命令。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Raft 安全性(Safety)：如果某条日志记录在某个任期号已提交，那么这条记录必然出现在更大任期号的未来 Leader 的日志中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14336917562724014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390ydKy37vuR7yj4TFodBP2sYs2W7jchGSibJQ1X9rv7IBanW8OTlhNAdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1674&quot;/&gt;&lt;/p&gt;&lt;p&gt;这保证了安全性要求：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Leader 不会覆盖日志中的记录；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;只有 Leader 的日志中的记录才能被提交；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在应用到状态机之前，日志必须先被提交；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这决定我们要修改选举程序：&lt;/p&gt;&lt;h3&gt;延迟提交，选出最佳 Leader&lt;/h3&gt;&lt;p&gt;问题来了：我们如何确保选出了一个很好地保存了所有已提交日志的 Leader ？&lt;/p&gt;&lt;p&gt;这有点棘手，举个例子：假设我们要在下面的集群中选出一个新 Leader，但此时第三台服务器不可用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4043261231281198&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390hXbf7lr7UFux0RE1ROT96jka8SDZzMwCH9jkE4MMQUkkxadfWUQ6Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种情况下，仅看前两个节点的日志我们无法确认是否达成多数派，故无法确认第五条日志是否已提交。&lt;/p&gt;&lt;p&gt;那怎么办呢？&lt;/p&gt;&lt;p&gt;通过比较日志，在选举期间，选择最有可能包含所有已提交的日志：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Candidate 在 &lt;code&gt;RequestVote RPCs&lt;/code&gt; 中包含日志信息（最后一条记录的 index 和 term，记为 &lt;code&gt;lastIndex&lt;/code&gt; 和 &lt;code&gt;lastTerm&lt;/code&gt;）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;收到此投票请求的服务器 V 将比较谁的日志更完整：&lt;code&gt;(lastTermV &amp;gt; lastTermC) ||&lt;br/&gt;(lastTermV == lastTermC) &amp;amp;&amp;amp; (lastIndexV &amp;gt; lastIndexC)&lt;/code&gt; 将拒绝投票；（即：V 的任期比 C 的任期新，或任期相同但 V 的日志比 C 的日志更完整）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;无论谁赢得选举，可以确保 Leader 和超过半数投票给它的节点中拥有最完整的日志——&lt;strong&gt;最完整的意思就是 index 和 term 这对唯一标识是最大的&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;举个例子&lt;/h3&gt;&lt;h4&gt;Case 1: Leader 决定提交日志&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6196943972835314&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390zTR12Pjz6YtHHI2hNVA39ARuHU48ToVIJaCfict6qKJOIky6A9fpWRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/p&gt;&lt;p&gt;任期 2 的 Leader S1 的 index = 4 日志刚刚被复制到 S3，并且 Leader 可以看到 index = 4 已复制到超过半数的服务器，那么该日志可以提交，并且安全地应用到状态机。&lt;/p&gt;&lt;p&gt;现在，这条记录是安全的，下一任期的 Leader 必须包含此记录，因此 S4 和 S5 都不可能从其它节点那里获得选票：S5 任期太旧，S4 日志太短。&lt;/p&gt;&lt;p&gt;只有前三台中的一台可以成为新的 Leader——S1 当然可以，S2、S3 也可以通过获取 S4 和 S5 的选票成为 Leader。&lt;/p&gt;&lt;h4&gt;Case 2: Leader 试图提交之前任期的日志&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5952380952380952&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390N8aXyiag3T2M2TjamDA1IRmw2Z0k6j44bspZWQDH6dQ5aUd0lzvkn2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;/p&gt;&lt;p&gt;如图所示的情况，在任期 2 时记录仅写在 S1 和 S2 两个节点上，由于某种原因，任期 3 的 Leader S5 并不知道这些记录，S5 创建了自己的三条记录然后宕机了，然后任期 4 的 Leader S1 被选出，S1 试图与其它服务器的日志进行匹配。因此它复制了任期 2 的日志到 S3。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;此时 index=3 的记录时是不安全的&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;因为 S1 可能在此时宕机，然后 S5 可能从 S2、S3、S4 获得选票成为任期 5 的 Leader。一旦 S5 成为新 Leader，它将覆盖 index=3-5 的日志，S1-S3 的这些记录都将消失。&lt;/p&gt;&lt;p&gt;我们还要需要一条新的规则，来处理这种情况。&lt;/p&gt;&lt;h3&gt;新的 Commit 规则&lt;/h3&gt;&lt;p&gt;新的选举不足以保证日志安全，我们还需要继续修改 commit 规则。&lt;/p&gt;&lt;p&gt;Leader 要提交一条日志：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7598343685300207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390nAD5JEdKKyic0DFz45jJR0uvYXaqsTV2oykJWvlRTGQtfxvjtia4la8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;如图，回到上面的 Case 2: 当 index = 3 &amp;amp; term = 2 被复制到 S3 时，它还不能提交该记录，必须等到 term = 4 的记录存储在超过半数的节点上，此时 index = 3 和 index = 4 可以认为是已提交。&lt;/p&gt;&lt;p&gt;此时 S5 无法赢得选举了，它无法从 S1-S3 获得选票。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;结合新的选举规则和 commit 规则，我们可以保证 Raft 的安全性。&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;日志不一致&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5146484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390J0eqAwNldWxIE5VexDMhDxElNuRk9tsJzWwHrksOmickHvRt88FlZnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;/p&gt;&lt;p&gt;Leader 变更可能导致日志的不一致，这里展示一种可能的情况。&lt;/p&gt;&lt;p&gt;可以从图中看出，Raft 集群中通常有两种不一致的日志：&lt;/p&gt;&lt;p&gt;我们要做的就是清理这两种日志。&lt;/p&gt;&lt;h3&gt;修复 Follower 日志&lt;/h3&gt;&lt;p&gt;新的 Leader 必须使 Follower 的日志与自己的日志保持一致，通过：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;删除 Extraneous Entries；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;补齐 Missing Entries；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Leader 为每个 Follower 保存 &lt;code&gt;nextIndex&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;Leader 通过 &lt;code&gt;nextIndex&lt;/code&gt; 来修复日志。当 &lt;code&gt;AppendEntries RPC&lt;/code&gt; 一致性检查失败，递减 &lt;code&gt;nextIndex&lt;/code&gt; 并重试。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41146496815286626&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390yTRkJmlribtPTfjWSYvNjpgmSx3omU9ZurZAGcE7b8GcKqPBkQma3BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1570&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于 a：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;一开始 &lt;code&gt;nextIndex&lt;/code&gt; = 11，带上日志 index = 10 &amp;amp; term = 6，检查失败；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;nextIndex&lt;/code&gt; = 10，带上日志 index = 9 &amp;amp; term = 6，检查失败；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如此反复，直到 &lt;code&gt;nextIndex&lt;/code&gt; = 5，带上日志 index = 4 &amp;amp; term = 4，该日志现在匹配，会在 a 中补齐 Leader 的日志。如此往下补齐。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于 b：&lt;br/&gt;会一直检查到 &lt;code&gt;nextIndex&lt;/code&gt; = 4 才匹配。值得注意的是，对于 b 这种情况，当 Follower 覆盖不一致的日志时，它将删除所有后续的日志记录（任何无关紧要的记录之后的记录也都是无关紧要的）。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43691899070385126&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390NdmiclRY8CCYulIy59NoygwprHicAu1UyIIqy88QXvibLTcJhCbA4PNDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1506&quot;/&gt;&lt;/p&gt;&lt;h2&gt;4. 处理旧 Leader&lt;/h2&gt;&lt;p&gt;实际上，老的 Leader 可能不会马上消失，例如：网络分区将 Leader 与集群的其余部分分隔，其余部分选举出了一个新的 Leader。问题在于，如果老的 Leader 重新连接，也不知道新的 Leader 已经被选出来，它会尝试作为 Leader 继续提交日志。此时如果有客户端向老 Leader 发送请求，老的 Leader 会尝试存储该命令并向其它节点复制日志——我们必须阻止这种情况发生。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;任期就是用来发现过时的 Leader&lt;/strong&gt;(和 Candidates)：&lt;/p&gt;&lt;p&gt;由于新 Leader 的选举会更新超过半数服务器的任期，旧的 Leader 不能提交新的日志，因为它会联系至少一台多数派集群的节点，然后发现自己任期太老，会转为 Follower 继续工作。&lt;/p&gt;&lt;p&gt;这里不打算继续讨论别的极端情况。&lt;/p&gt;&lt;h2&gt;5. 客户端协议&lt;/h2&gt;&lt;p&gt;客户端只将命令发送到 Leader：&lt;/p&gt;&lt;p&gt;Leader 直到将命令记录、提交和执行到状态机之前，不会做出响应。&lt;/p&gt;&lt;p&gt;这里的问题是如果 Leader 宕机会导致请求超时：&lt;/p&gt;&lt;p&gt;这留下了一个命令可能被执行两次的风险——Leader 可能在执行命令之后但响应客户端之前宕机，此时客户端再去寻找下一个 Leader，同一个命令就会被执行两次——这是不可接受的！&lt;/p&gt;&lt;p&gt;解决办法是：客户端发送给 Leader 的每个命令都带上一个唯一 id&lt;/p&gt;&lt;p&gt;&lt;strong&gt;每个命令只会被执行一次，这就是所谓的线性化的关键要素&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;6. 配置变更&lt;/h2&gt;&lt;p&gt;随着时间推移，会有机器故障需要我们去替换它，或者修改节点数量，需要有一些机制来变更系统配置，并且是安全、自动的方式，无需停止系统。&lt;/p&gt;&lt;p&gt;系统配置是指：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每台服务器的 id 和地址&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;系统配置信息是非常重要的，它决定了多数派的组成&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;首先要意识到，我们不能直接从旧配置切换到新配置，这可能会导致矛盾的多数派。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.34083930399181167&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390UfhWDZiaAGIm3n4LOPXfSfKicd1zHDjwEnvJ92HEcGGicsjlsBluc9M7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1954&quot;/&gt;&lt;/p&gt;&lt;p&gt;如图，系统以三台服务器的配置运行着，此时我们要添加两台服务器。如果我们直接修改配置，他们可能无法完全在同一时间做到配置切换，这会导致 S1 和 S2 形成旧集群的多数派，而同一时间 S3-S5 已经切换到新配置，这会产生两个集群。&lt;/p&gt;&lt;p&gt;这说明我们必须使用一个两阶段(two-phase)协议。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果有人告诉你，他可以在分布式系统中一个阶段就做出决策，你应该非常认真地询问他，因为他要么错了，要么发现了世界上所有人都不知道的东西。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;共同一致(Joint Consensus)&lt;/h3&gt;&lt;p&gt;Raft 通过共同一致(Joint Consensus)来完成两阶段协议，即：新、旧两种配置上都获得多数派选票。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4156769596199525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390r8ImFlyAicXKvqueRgD9ZTCia8EpBu4WJicIQuAkibfekf82y4Xicn4oicXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1684&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一阶段：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;mjx-container jax=&quot;SVG&quot; role=&quot;presentation&quot; tabindex=&quot;0&quot; ctxtmenu_counter=&quot;10&quot; data-formula=&quot;C_{old+new}&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -705 3496.6 913&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;43&quot; d=&quot;M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(715, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(485, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(783, 0)&quot;&gt;&lt;path data-c=&quot;64&quot; d=&quot;M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1303, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2081, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2681, 0)&quot;&gt;&lt;path data-c=&quot;65&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3147, 0)&quot;&gt;&lt;path data-c=&quot;77&quot; d=&quot;M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;日志已提交保证了后续任何 Leader 一定有&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;mjx-container jax=&quot;SVG&quot; role=&quot;presentation&quot; tabindex=&quot;0&quot; ctxtmenu_counter=&quot;10&quot; data-formula=&quot;C_{old+new}&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -705 3496.6 913&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;43&quot; d=&quot;M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(715, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(485, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(783, 0)&quot;&gt;&lt;path data-c=&quot;64&quot; d=&quot;M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1303, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2081, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2681, 0)&quot;&gt;&lt;path data-c=&quot;65&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3147, 0)&quot;&gt;&lt;path data-c=&quot;77&quot; d=&quot;M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;日志，Leader 选举过程必须获得旧配置中的多数派和新配置中的多数派同时投票。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二阶段：&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3947078280044101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA0Nb7z15Y0QdBGSyIPVic390ARW5pYWGgkseaNEEqD2PuZmWMPqU3ibibfUAjgj75xlQibIkfK5vz89Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1814&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Joint Consensus 还有一些细节：&lt;/p&gt;&lt;p&gt;如图所示，旧 Leader 不再是新配置的成员之后，还有可能继续服务一小段时间；即旧 Leader 可能在&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;mjx-container jax=&quot;SVG&quot; role=&quot;presentation&quot; tabindex=&quot;0&quot; ctxtmenu_counter=&quot;8&quot; data-formula=&quot;C_{new}&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -705 2025.1 862.8&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;43&quot; d=&quot;M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(715, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(600, 0)&quot;&gt;&lt;path data-c=&quot;65&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1066, 0)&quot;&gt;&lt;path data-c=&quot;77&quot; d=&quot;M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;配置下继续当 Leader（虽然实质上并不是Leader），直到&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;mjx-container jax=&quot;SVG&quot; role=&quot;presentation&quot; tabindex=&quot;0&quot; ctxtmenu_counter=&quot;8&quot; data-formula=&quot;C_{new}&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -705 2025.1 862.8&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msub&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;43&quot; d=&quot;M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(715, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(600, 0)&quot;&gt;&lt;path data-c=&quot;65&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1066, 0)&quot;&gt;&lt;path data-c=&quot;77&quot; d=&quot;M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;的日志复制到多数派上而 committed；&lt;/p&gt;&lt;h2&gt;相关阅读&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注我的公众号：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA2qgPwzomIicebbmoOGzU1IsUWQMb3xr4nLcjtfIy5Zwyia3HTKnIJ8xc9NFkkPBkL8MEAfh3YdNuaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0967da03b1d72ed84084f9ef3433d04f</guid>
<title>Go：实现项目内链路追踪</title>
<link>https://toutiao.io/k/ic65md7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么项目内需要链路追踪？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个请求中，请求了多个服务单元，如果请求出现了错误或异常，很难去定位是哪个服务出了问题，这时就需要链路追踪。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1858407079646018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhTZqG9aQ0doMjaVkoFiaYfSmESqm8MgOxQ4BESXT1rfAUpfn55XiaIvHGaqygNWicTb78ESfSCYD7r9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;339&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图画的比较简单，从图中可以清晰的看出他们之间的调用关系，通过一个例子说明下链路的重要性，比如对方调我们一个接口，反馈在某个时间段这接口太慢了，在排查代码发现逻辑比较复杂，不光调用了多个三方接口、操作了数据库，还操作了缓存，怎么快速定位是哪块执行时间很长？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不卖关子，先说下本篇文章最终实现了什么，如果感兴趣再继续往下看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现了通过记录如下参数，来进行问题定位，关于每个参数的结构在下面都有介绍。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Trace 记录的参数&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Trace struct {&lt;br/&gt;    mux                sync.Mutex&lt;br/&gt;    Identifier         string    `json:&lt;span&gt;&quot;trace_id&quot;&lt;/span&gt;`             // 链路 ID&lt;br/&gt;    Request            *Request  `json:&lt;span&gt;&quot;request&quot;&lt;/span&gt;`              // 请求信息&lt;br/&gt;    Response           *Response `json:&lt;span&gt;&quot;response&quot;&lt;/span&gt;`             // 响应信息&lt;br/&gt;    ThirdPartyRequests []*Dialog `json:&lt;span&gt;&quot;third_party_requests&quot;&lt;/span&gt;` // 调用第三方接口的信息&lt;br/&gt;    Debugs             []*Debug  `json:&lt;span&gt;&quot;debugs&quot;&lt;/span&gt;`               // 调试信息&lt;br/&gt;    SQLs               []*SQL    `json:&lt;span&gt;&quot;sqls&quot;&lt;/span&gt;`                 // 执行的 SQL 信息&lt;br/&gt;    Redis              []*Redis  `json:&lt;span&gt;&quot;redis&quot;&lt;/span&gt;`                // 执行的 Redis 信息&lt;br/&gt;    Success            bool      `json:&lt;span&gt;&quot;success&quot;&lt;/span&gt;`              // 请求结果 &lt;span&gt;true&lt;/span&gt; or &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    CostSeconds        float64   `json:&lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;`         // 执行时长(单位秒)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参数结构&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;链路 ID&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String&lt;/code&gt; 例如：4b4f81f015a4f2a01b00。如果请求 Header 中存在 &lt;code&gt;TRACE-ID&lt;/code&gt;，就使用它，反之，重新创建一个。将 &lt;code&gt;TRACE_ID&lt;/code&gt; 放到接口返回值中，这样就可以通过这个标示查到这一串的信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;请求信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt;，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Request struct {&lt;br/&gt; TTL        string      `json:&lt;span&gt;&quot;ttl&quot;&lt;/span&gt;`         // 请求超时时间&lt;br/&gt; Method     string      `json:&lt;span&gt;&quot;method&quot;&lt;/span&gt;`      // 请求方式&lt;br/&gt; DecodedURL string      `json:&lt;span&gt;&quot;decoded_url&quot;&lt;/span&gt;` // 请求地址&lt;br/&gt; Header     interface{} `json:&lt;span&gt;&quot;header&quot;&lt;/span&gt;`      // 请求 Header 信息&lt;br/&gt; Body       interface{} `json:&lt;span&gt;&quot;body&quot;&lt;/span&gt;`        // 请求 Body 信息&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;响应信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt;，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Response struct {&lt;br/&gt; Header          interface{} `json:&lt;span&gt;&quot;header&quot;&lt;/span&gt;`                      // Header 信息&lt;br/&gt; Body            interface{} `json:&lt;span&gt;&quot;body&quot;&lt;/span&gt;`                        // Body 信息&lt;br/&gt; BusinessCode    int         `json:&lt;span&gt;&quot;business_code,omitempty&quot;&lt;/span&gt;`     // 业务码&lt;br/&gt; BusinessCodeMsg string      `json:&lt;span&gt;&quot;business_code_msg,omitempty&quot;&lt;/span&gt;` // 提示信息&lt;br/&gt; HttpCode        int         `json:&lt;span&gt;&quot;http_code&quot;&lt;/span&gt;`                   // HTTP 状态码&lt;br/&gt; HttpCodeMsg     string      `json:&lt;span&gt;&quot;http_code_msg&quot;&lt;/span&gt;`               // HTTP 状态码信息&lt;br/&gt; CostSeconds     float64     `json:&lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;`                // 执行时间(单位秒)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;调用三方接口信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt;，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Dialog struct {&lt;br/&gt; mux         sync.Mutex&lt;br/&gt; Request     *Request    `json:&lt;span&gt;&quot;request&quot;&lt;/span&gt;`      // 请求信息&lt;br/&gt; Responses   []*Response `json:&lt;span&gt;&quot;responses&quot;&lt;/span&gt;`    // 返回信息&lt;br/&gt; Success     bool        `json:&lt;span&gt;&quot;success&quot;&lt;/span&gt;`      // 是否成功，&lt;span&gt;true&lt;/span&gt; 或 &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; CostSeconds float64     `json:&lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;` // 执行时长(单位秒)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面的 &lt;code&gt;Request&lt;/code&gt; 和 &lt;code&gt;Response&lt;/code&gt; 结构与上面保持一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细节来了，为什么 &lt;code&gt;Responses&lt;/code&gt; 结构是 &lt;code&gt;[]*Response&lt;/code&gt; ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是因为 HTTP 可以进行重试请求，比如当请求对方接口的时候，HTTP 状态码为 503 &lt;code&gt;http.StatusServiceUnavailable&lt;/code&gt;，这时需要重试，我们也需要把重试的响应信息记录下来。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;调试信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt; 结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Debug struct {&lt;br/&gt; Key         string      `json:&lt;span&gt;&quot;key&quot;&lt;/span&gt;`          // 标示&lt;br/&gt; Value       interface{} `json:&lt;span&gt;&quot;value&quot;&lt;/span&gt;`        // 值&lt;br/&gt; CostSeconds float64     `json:&lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;` // 执行时间(单位秒)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;SQL 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt;，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; SQL struct {&lt;br/&gt; Timestamp   string  `json:&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;`     // 时间，格式：2006-01-02 15:04:05&lt;br/&gt; Stack       string  `json:&lt;span&gt;&quot;stack&quot;&lt;/span&gt;`         // 文件地址和行号&lt;br/&gt; SQL         string  `json:&lt;span&gt;&quot;sql&quot;&lt;/span&gt;`           // SQL 语句&lt;br/&gt; Rows        int64   `json:&lt;span&gt;&quot;rows_affected&quot;&lt;/span&gt;` // 影响行数&lt;br/&gt; CostSeconds float64 `json:&lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;`  // 执行时长(单位秒)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Redis 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt;，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Redis struct {&lt;br/&gt; Timestamp   string  `json:&lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;`       // 时间，格式：2006-01-02 15:04:05&lt;br/&gt; Handle      string  `json:&lt;span&gt;&quot;handle&quot;&lt;/span&gt;`          // 操作，SET/GET 等&lt;br/&gt; Key         string  `json:&lt;span&gt;&quot;key&quot;&lt;/span&gt;`             // Key&lt;br/&gt; Value       string  `json:&lt;span&gt;&quot;value,omitempty&quot;&lt;/span&gt;` // Value&lt;br/&gt; TTL         float64 `json:&lt;span&gt;&quot;ttl,omitempty&quot;&lt;/span&gt;`   // 超时时长(单位分)&lt;br/&gt; CostSeconds float64 `json:&lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;`    // 执行时间(单位秒)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;请求结果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;，这个和统一定义返回值有点关系，看下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 错误返回&lt;br/&gt;c.AbortWithError(code.ErrParamBind.WithErr(err))&lt;br/&gt;&lt;br/&gt;// 正确返回&lt;br/&gt;c.Payload(code.OK.WithData(data))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当错误返回时 且 &lt;code&gt;ctx.Writer.Status() != http.StatusOK&lt;/code&gt; 时，为 &lt;code&gt;false&lt;/code&gt;，反之为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;执行时长&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;，例如：0.041746869，记录的是从请求开始到请求结束所花费的时间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何收集参数？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时有老铁会说了：“规划的稍微还行，使用的时候会不会很麻烦？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“No，No，使用起来一丢丢都不麻烦”，接着往下看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;无需关心的参数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链路 ID、请求信息、响应信息、请求结果、执行时长，这 5 个参数，开发者无需关心，这些都在中间件封装好了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;调用第三方接口的信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需多传递一个参数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里厚脸皮自荐下 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448835805&amp;amp;idx=1&amp;amp;sn=22b604de89071040430bacba78223197&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;httpclient 包&lt;/a&gt; 。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持设置失败时重试，可以自定义重试次数、重试前延迟等待时间、重试的满足条件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置失败时告警，可以自定义告警渠道（邮件/微信）、告警的满足条件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置调用链路；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// httpclient 是项目中封装的包&lt;br/&gt;api := &lt;span&gt;&quot;http://127.0.0.1:9999/demo/post&quot;&lt;/span&gt;&lt;br/&gt;params := url.Values{}&lt;br/&gt;params.Set(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, name)&lt;br/&gt;body, err := httpclient.PostForm(api, params,&lt;br/&gt;    httpclient.WithTrace(ctx.Trace()),  // 传递上下文&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;调试信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需多传递一个参数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// p 是项目中封装的包&lt;br/&gt;p.Println(&lt;span&gt;&quot;key&quot;&lt;/span&gt;, &lt;span&gt;&quot;value&quot;&lt;/span&gt;,&lt;br/&gt; p.WithTrace(ctx.Trace()), // 传递上下文&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;SQL 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微复杂一丢丢，需要多传递一个参数，然后再写一个 &lt;code&gt;GORM&lt;/code&gt; 插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用的 &lt;code&gt;GORM V2&lt;/code&gt; 自带的 &lt;code&gt;Callbacks&lt;/code&gt; 和 &lt;code&gt;Context&lt;/code&gt; 知识点，细节不多说，可以看下这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDM4MDIwNw==&amp;amp;mid=2448835781&amp;amp;idx=1&amp;amp;sn=8cd67bbc3118241e09ce41ede2a07ac9&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;基于 GORM 获取当前请求所执行的 SQL 信息&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 原来查询这样写&lt;br/&gt;err := u.db.GetDbR().&lt;br/&gt;    First(data, id).&lt;br/&gt;    Where(&lt;span&gt;&quot;is_deleted = ?&quot;&lt;/span&gt;, -1).&lt;br/&gt;    Error&lt;br/&gt;&lt;br/&gt;// 现在只需这样写&lt;br/&gt;err := u.db.GetDbR().&lt;br/&gt;    WithContext(ctx.RequestContext()).&lt;br/&gt;    First(data, id).&lt;br/&gt;    Where(&lt;span&gt;&quot;is_deleted = ?&quot;&lt;/span&gt;, -1).&lt;br/&gt;    Error&lt;br/&gt;    &lt;br/&gt;// .WithContext 是 GORM V2 自带的。    &lt;br/&gt;// 插件的代码就不贴了，去上面的文章查看即可。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Redis 信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需多传递一个参数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// cache 是基于 go-redis 封装的包&lt;br/&gt;d.cache.Get(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;br/&gt;    cache.WithTrace(c.Trace()),&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心原理是啥？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这没关子可卖，看到这相信老铁们都知道了，就两个：一个是 拦截器，另一个是 &lt;code&gt;Context&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9370629370629371&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/go9jpG3BuhTZqG9aQ0doMjaVkoFiaYfSmgH1HBLmojYnZm2ESiaia0uUwglTOqrjoG9I6ribDZxqtF3aqmOhkjiaUrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;429&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何记录参数？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将以上数据转为 &lt;code&gt;JSON&lt;/code&gt; 结构记录到日志中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;JSON 示例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;level&quot;&lt;/span&gt;:&lt;span&gt;&quot;info&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;:&lt;span&gt;&quot;2021-01-30 22:32:48&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;caller&quot;&lt;/span&gt;:&lt;span&gt;&quot;core/core.go:444&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;core-interceptor&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;domain&quot;&lt;/span&gt;:&lt;span&gt;&quot;go-gin-api[fat]&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;method&quot;&lt;/span&gt;:&lt;span&gt;&quot;GET&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;path&quot;&lt;/span&gt;:&lt;span&gt;&quot;/demo/trace&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;http_code&quot;&lt;/span&gt;:200,&lt;br/&gt;    &lt;span&gt;&quot;business_code&quot;&lt;/span&gt;:1,&lt;br/&gt;    &lt;span&gt;&quot;success&quot;&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.054025302,&lt;br/&gt;    &lt;span&gt;&quot;trace_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;trace_info&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;trace_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;request&quot;&lt;/span&gt;:{&lt;br/&gt;            &lt;span&gt;&quot;ttl&quot;&lt;/span&gt;:&lt;span&gt;&quot;un-limit&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;method&quot;&lt;/span&gt;:&lt;span&gt;&quot;GET&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;decoded_url&quot;&lt;/span&gt;:&lt;span&gt;&quot;/demo/trace&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;header&quot;&lt;/span&gt;:{&lt;br/&gt;                &lt;span&gt;&quot;Accept&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;application/json&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Accept-Encoding&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;gzip, deflate, br&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Accept-Language&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;zh-CN,zh;q=0.9,en;q=0.8&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VySUQiOjEsIlVzZXJOYW1lIjoieGlubGlhbmdub3RlIiwiZXhwIjoxNjEyMTAzNTQwLCJpYXQiOjE2MTIwMTcxNDAsIm5iZiI6MTYxMjAxNzE0MH0.2yHDdP7cNT5uL5xA0-j_NgTK4GrW-HGn0KUxcbZfpKg&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Connection&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;keep-alive&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Referer&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;http://127.0.0.1:9999/swagger/index.html&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Sec-Fetch-Dest&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;empty&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Sec-Fetch-Mode&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;cors&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Sec-Fetch-Site&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;same-origin&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;User-Agent&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36&quot;&lt;/span&gt;&lt;br/&gt;                ]&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;&quot;body&quot;&lt;/span&gt;:&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;&quot;response&quot;&lt;/span&gt;:{&lt;br/&gt;            &lt;span&gt;&quot;header&quot;&lt;/span&gt;:{&lt;br/&gt;                &lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;application/json; charset=utf-8&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Trace-Id&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;Vary&quot;&lt;/span&gt;:[&lt;br/&gt;                    &lt;span&gt;&quot;Origin&quot;&lt;/span&gt;&lt;br/&gt;                ]&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;&quot;body&quot;&lt;/span&gt;:{&lt;br/&gt;                &lt;span&gt;&quot;code&quot;&lt;/span&gt;:1,&lt;br/&gt;                &lt;span&gt;&quot;msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;OK&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;data&quot;&lt;/span&gt;:[&lt;br/&gt;                    {&lt;br/&gt;                        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;Tom&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;job&quot;&lt;/span&gt;:&lt;span&gt;&quot;Student&quot;&lt;/span&gt;&lt;br/&gt;                    },&lt;br/&gt;                    {&lt;br/&gt;                        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;Jack&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;job&quot;&lt;/span&gt;:&lt;span&gt;&quot;Teacher&quot;&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;id&quot;&lt;/span&gt;:&lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;&quot;business_code&quot;&lt;/span&gt;:1,&lt;br/&gt;            &lt;span&gt;&quot;business_code_msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;OK&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;http_code&quot;&lt;/span&gt;:200,&lt;br/&gt;            &lt;span&gt;&quot;http_code_msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;OK&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.054024874&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;&quot;third_party_requests&quot;&lt;/span&gt;:[&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;request&quot;&lt;/span&gt;:{&lt;br/&gt;                    &lt;span&gt;&quot;ttl&quot;&lt;/span&gt;:&lt;span&gt;&quot;5s&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;method&quot;&lt;/span&gt;:&lt;span&gt;&quot;GET&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;decoded_url&quot;&lt;/span&gt;:&lt;span&gt;&quot;http://127.0.0.1:9999/demo/get/Tom&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;header&quot;&lt;/span&gt;:{&lt;br/&gt;                        &lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;:[&lt;br/&gt;                            &lt;span&gt;&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VySUQiOjEsIlVzZXJOYW1lIjoieGlubGlhbmdub3RlIiwiZXhwIjoxNjEyMTAzNTQwLCJpYXQiOjE2MTIwMTcxNDAsIm5iZiI6MTYxMjAxNzE0MH0.2yHDdP7cNT5uL5xA0-j_NgTK4GrW-HGn0KUxcbZfpKg&quot;&lt;/span&gt;&lt;br/&gt;                        ],&lt;br/&gt;                        &lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;:[&lt;br/&gt;                            &lt;span&gt;&quot;application/x-www-form-urlencoded; charset=utf-8&quot;&lt;/span&gt;&lt;br/&gt;                        ],&lt;br/&gt;                        &lt;span&gt;&quot;TRACE-ID&quot;&lt;/span&gt;:[&lt;br/&gt;                            &lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;&lt;br/&gt;                        ]&lt;br/&gt;                    },&lt;br/&gt;                    &lt;span&gt;&quot;body&quot;&lt;/span&gt;:null&lt;br/&gt;                },&lt;br/&gt;                &lt;span&gt;&quot;responses&quot;&lt;/span&gt;:[&lt;br/&gt;                    {&lt;br/&gt;                        &lt;span&gt;&quot;header&quot;&lt;/span&gt;:{&lt;br/&gt;                            &lt;span&gt;&quot;Content-Length&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;87&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;application/json; charset=utf-8&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Date&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;Sat, 30 Jan 2021 14:32:48 GMT&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Trace-Id&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Vary&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;Origin&quot;&lt;/span&gt;&lt;br/&gt;                            ]&lt;br/&gt;                        },&lt;br/&gt;                        &lt;span&gt;&quot;body&quot;&lt;/span&gt;:&lt;span&gt;&quot;{&quot;&lt;/span&gt;code&lt;span&gt;&quot;:1,&quot;&lt;/span&gt;msg&lt;span&gt;&quot;:&quot;&lt;/span&gt;OK&lt;span&gt;&quot;,&quot;&lt;/span&gt;data&lt;span&gt;&quot;:{&quot;&lt;/span&gt;name&lt;span&gt;&quot;:&quot;&lt;/span&gt;Tom&lt;span&gt;&quot;,&quot;&lt;/span&gt;job&lt;span&gt;&quot;:&quot;&lt;/span&gt;Student&lt;span&gt;&quot;},&quot;&lt;/span&gt;id&lt;span&gt;&quot;:&quot;&lt;/span&gt;2cdb2f96934f573af391&lt;span&gt;&quot;}&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;http_code&quot;&lt;/span&gt;:200,&lt;br/&gt;                        &lt;span&gt;&quot;http_code_msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;200 OK&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.000555089&lt;br/&gt;                    }&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;success&quot;&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.000580202&lt;br/&gt;            },&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;request&quot;&lt;/span&gt;:{&lt;br/&gt;                    &lt;span&gt;&quot;ttl&quot;&lt;/span&gt;:&lt;span&gt;&quot;5s&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;method&quot;&lt;/span&gt;:&lt;span&gt;&quot;POST&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;decoded_url&quot;&lt;/span&gt;:&lt;span&gt;&quot;http://127.0.0.1:9999/demo/post&quot;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;&quot;header&quot;&lt;/span&gt;:{&lt;br/&gt;                        &lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;:[&lt;br/&gt;                            &lt;span&gt;&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VySUQiOjEsIlVzZXJOYW1lIjoieGlubGlhbmdub3RlIiwiZXhwIjoxNjEyMTAzNTQwLCJpYXQiOjE2MTIwMTcxNDAsIm5iZiI6MTYxMjAxNzE0MH0.2yHDdP7cNT5uL5xA0-j_NgTK4GrW-HGn0KUxcbZfpKg&quot;&lt;/span&gt;&lt;br/&gt;                        ],&lt;br/&gt;                        &lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;:[&lt;br/&gt;                            &lt;span&gt;&quot;application/x-www-form-urlencoded; charset=utf-8&quot;&lt;/span&gt;&lt;br/&gt;                        ],&lt;br/&gt;                        &lt;span&gt;&quot;TRACE-ID&quot;&lt;/span&gt;:[&lt;br/&gt;                            &lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;&lt;br/&gt;                        ]&lt;br/&gt;                    },&lt;br/&gt;                    &lt;span&gt;&quot;body&quot;&lt;/span&gt;:&lt;span&gt;&quot;name=Jack&quot;&lt;/span&gt;&lt;br/&gt;                },&lt;br/&gt;                &lt;span&gt;&quot;responses&quot;&lt;/span&gt;:[&lt;br/&gt;                    {&lt;br/&gt;                        &lt;span&gt;&quot;header&quot;&lt;/span&gt;:{&lt;br/&gt;                            &lt;span&gt;&quot;Content-Length&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;88&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;application/json; charset=utf-8&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Date&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;Sat, 30 Jan 2021 14:32:48 GMT&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Trace-Id&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;2cdb2f96934f573af391&quot;&lt;/span&gt;&lt;br/&gt;                            ],&lt;br/&gt;                            &lt;span&gt;&quot;Vary&quot;&lt;/span&gt;:[&lt;br/&gt;                                &lt;span&gt;&quot;Origin&quot;&lt;/span&gt;&lt;br/&gt;                            ]&lt;br/&gt;                        },&lt;br/&gt;                        &lt;span&gt;&quot;body&quot;&lt;/span&gt;:&lt;span&gt;&quot;{&quot;&lt;/span&gt;code&lt;span&gt;&quot;:1,&quot;&lt;/span&gt;msg&lt;span&gt;&quot;:&quot;&lt;/span&gt;OK&lt;span&gt;&quot;,&quot;&lt;/span&gt;data&lt;span&gt;&quot;:{&quot;&lt;/span&gt;name&lt;span&gt;&quot;:&quot;&lt;/span&gt;Jack&lt;span&gt;&quot;,&quot;&lt;/span&gt;job&lt;span&gt;&quot;:&quot;&lt;/span&gt;Teacher&lt;span&gt;&quot;},&quot;&lt;/span&gt;id&lt;span&gt;&quot;:&quot;&lt;/span&gt;2cdb2f96934f573af391&lt;span&gt;&quot;}&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;http_code&quot;&lt;/span&gt;:200,&lt;br/&gt;                        &lt;span&gt;&quot;http_code_msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;200 OK&quot;&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.000450153&lt;br/&gt;                    }&lt;br/&gt;                ],&lt;br/&gt;                &lt;span&gt;&quot;success&quot;&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.000468387&lt;br/&gt;            }&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&quot;debugs&quot;&lt;/span&gt;:[&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;key&quot;&lt;/span&gt;:&lt;span&gt;&quot;res1.Data.Name&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;Tom&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.000005193&lt;br/&gt;            },&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;key&quot;&lt;/span&gt;:&lt;span&gt;&quot;res2.Data.Name&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;Jack&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.000003907&lt;br/&gt;            },&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;key&quot;&lt;/span&gt;:&lt;span&gt;&quot;redis-name&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;tom&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.000009816&lt;br/&gt;            }&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&quot;sqls&quot;&lt;/span&gt;:[&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;:&lt;span&gt;&quot;2021-01-30 22:32:48&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;stack&quot;&lt;/span&gt;:&lt;span&gt;&quot;/Users/xinliang/github/go-gin-api/internal/api/repository/db_repo/user_demo_repo/user_demo.go:76&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;sql&quot;&lt;/span&gt;:&lt;span&gt;&quot;SELECT `id`,`user_name`,`nick_name`,`mobile` FROM `user_demo` WHERE user_name = &#x27;test_user&#x27; and is_deleted = -1 ORDER BY `user_demo`.`id` LIMIT 1&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;rows_affected&quot;&lt;/span&gt;:1,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.031969072&lt;br/&gt;            }&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&quot;redis&quot;&lt;/span&gt;:[&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;:&lt;span&gt;&quot;2021-01-30 22:32:48&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;handle&quot;&lt;/span&gt;:&lt;span&gt;&quot;set&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;key&quot;&lt;/span&gt;:&lt;span&gt;&quot;name&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;tom&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;ttl&quot;&lt;/span&gt;:10,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.009982091&lt;br/&gt;            },&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;:&lt;span&gt;&quot;2021-01-30 22:32:48&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;handle&quot;&lt;/span&gt;:&lt;span&gt;&quot;get&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;key&quot;&lt;/span&gt;:&lt;span&gt;&quot;name&quot;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.010681579&lt;br/&gt;            }&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&quot;success&quot;&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;cost_seconds&quot;&lt;/span&gt;:0.054025302&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;zap 日志组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有对日志收集感兴趣的老铁们可以往下看，&lt;code&gt;trace_info&lt;/code&gt; 只是日志的一个参数，具体日志参数包括：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;level&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;日志级别，例如：info,warn,error,debug&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;time&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;时间，例如：2021-01-30 16:05:44&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;caller&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;调用位置，文件+行号，例如：core/core.go:443&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;msg&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;日志信息，例如：xx 错误&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;domain&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;域名或服务名，例如：go-gin-api[fat]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;method&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;请求方式，例如：POST&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;path&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;请求路径，例如：/user/create&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;http_code&lt;/td&gt;&lt;td&gt;Int&lt;/td&gt;&lt;td&gt;HTTP 状态码，例如：200&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;business_code&lt;/td&gt;&lt;td&gt;Int&lt;/td&gt;&lt;td&gt;业务状态码，例如：10101&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;success&lt;/td&gt;&lt;td&gt;Bool&lt;/td&gt;&lt;td&gt;状态，true or false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cost_seconds&lt;/td&gt;&lt;td&gt;Float64&lt;/td&gt;&lt;td&gt;花费时间，单位：秒，例如：0.01&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;trace_id&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;链路ID，例如：ec3c868c8dcccfe515ab&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;trace_info&lt;/td&gt;&lt;td&gt;Object&lt;/td&gt;&lt;td&gt;链路信息，结构化数据。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;error&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;错误信息，当出现错误时才有这字段。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;errorVerbose&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;详细的错误堆栈信息，当出现错误时才有这字段。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志记录可以使用 &lt;code&gt;zap&lt;/code&gt;，&lt;code&gt;logrus&lt;/code&gt; ，这次我使用的 &lt;code&gt;zap&lt;/code&gt;，简单封装一下即可，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持设置日志级别；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置日志输出到控制台；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置日志输出到文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持设置日志输出到文件(可自动分割)；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能比较常用，使用起来也很爽，比如调用方发现接口出问题时，只需要提供 &lt;code&gt;TRACE-ID&lt;/code&gt; 即可，我们就可以查到关于它整个链路的所有信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以上代码都在 go-gin-api 项目中，地址：https://github.com/xinliangnote/go-gin-api&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>