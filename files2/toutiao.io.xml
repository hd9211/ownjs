<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bde832b7e7d856cf90275bb2f3e8331a</guid>
<title>45 张图庖丁解牛 18 种 Queue，你知道几种？</title>
<link>https://toutiao.io/k/fvryjlb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451944303&amp;amp;idx=1&amp;amp;sn=6fc5a3198e4216eed667a26648028b71&amp;amp;chksm=8d1c4af0ba6bc3e6c5b4638c8e33deac79f8646343a03ba44e10dcb14a0eeb7095f437e9c554&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《集合的线程不安全》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《21张图讲解集合的线程不安全》&lt;/a&gt;那一篇，我留了一个彩蛋，就是&lt;span&gt;&lt;strong&gt;Queue（队列）&lt;/strong&gt;&lt;/span&gt;还没有讲，这次我们重点来看看Java中的Queue家族，总共涉及到&lt;strong&gt;18&lt;/strong&gt;种Queue。这篇恐怕是市面上&lt;span&gt;&lt;strong&gt;最全最细&lt;/strong&gt;&lt;/span&gt;讲解Queue的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本篇主要内容如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9628712871287128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJhNWArwClvXEychM1SLu16haahZJutLlwmmNLdlICS0mOCst9z1SZYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;本篇主要内容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;帮你总结好的阻塞队列：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8221830985915493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJk9SYIaS9gMG3vSJeTVaZJ0rRQp4d1dbgU5YlrQXsM2Ha5z02bnYAZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;figcaption&gt;18种Queue总结&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、Queue自我介绍&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3476764199655766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJZwicYhUaj40hMochInxf003SmMGtLQb5afaOZ0juicy2PT5ESicpYKw7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;figcaption&gt;队列原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Queue自我介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hi，大家好，我的英文名叫&lt;code&gt;Queue&lt;/code&gt;，中文名叫&lt;code&gt;队列&lt;/code&gt;，无论现实生活中还是计算机的世界中，我都是一个很重要的角色哦~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是一种&lt;code&gt;数据结构&lt;/code&gt;，大家可以把我想象成一个数组，元素从我的一头进入、从另外一头出去，称为FIFO原则（先进先出原则）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还有两个亲兄弟：&lt;code&gt;List&lt;/code&gt;（列表）、&lt;code&gt;Set&lt;/code&gt;（集），他们都是&lt;code&gt;Collection&lt;/code&gt;的儿子，我还有一个远房亲戚：&lt;code&gt;Map&lt;/code&gt;（映射）。他们都是&lt;code&gt;java.util&lt;/code&gt;包这个大家庭的成员哦~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 现实生活中的场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;海底捞排号等位（先排号的优先进餐厅）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;邮政员寄送信件（信箱是队列）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 计算机世界中的场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息队列 RabbitMQ&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UDP协议（接收端将消息存放在队列中，从队列中读取数据）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、高屋建瓴，纵览全局&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;18种队列分为三大类：&lt;/strong&gt; 接口、抽象类、普通类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;弄清楚下面的继承实现关系对后面理解18种队列有很大帮助。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4917946003176284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJibwxGsgkDzdicE71NGtiaYTurP4uq2TvvOytNDEYzxvreJ2UKUI8q8SUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1889&quot;/&gt;&lt;figcaption&gt;18个Queue的继承实现关系图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Queue&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;Collection&lt;/code&gt;接口，&lt;code&gt;Collection&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt;  &lt;code&gt;Iterable&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingQueue&lt;/code&gt;接口、&lt;code&gt;Deque&lt;/code&gt;接口 &lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;Queue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;Queue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingDeque&lt;/code&gt;接口、&lt;code&gt;TransferQueue&lt;/code&gt;接口&lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;BlockingQueue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BlockingDeque&lt;/code&gt;接口继承&lt;code&gt;Deque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;BlockingDeque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类接口&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;TransferQueue&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LinkedList&lt;/code&gt;类、&lt;code&gt;ArrayDeque&lt;/code&gt;类、&lt;code&gt;ConcurrentLinkedDeque&lt;/code&gt;类&lt;strong&gt;实现&lt;/strong&gt; 了&lt;code&gt;Deque&lt;/code&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkendBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类、&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类、&lt;code&gt;SynchronousQueue&lt;/code&gt;类、&lt;code&gt;PriorityBlockQueue&lt;/code&gt;类、&lt;code&gt;DelayQueue类&lt;/code&gt;&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类和&lt;strong&gt;实现&lt;/strong&gt;了BlockingQueue接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;类和&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;类&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Deque：全称Double-Ended queue，表示双端队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类实现接口，用implements&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接口继承接口，用 extends&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类继承类，用extends&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、万物归宗Queue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 深入理解Queue接口的本质&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Queue接口是一种Collection，被设计用于处理之前临时保存在某处的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除了基本的Collection操作之外，队列还提供了额外的插入、提取和检查操作。每一种操作都有两种形式：如果操作失败，则抛出一个异常；如果操作失败，则返回一个特殊值（null或false，取决于是什么操作）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;队列通常是以FIFO（先进先出）的方式排序元素，但是这不是必须的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;只有优先级队列可以根据提供的比较器对元素进行排序或者是采用正常的排序。无论怎么排序，队列的头将通过调用remove()或poll()方法进行移除。在FIFO队列种，所有新的元素被插入到队尾。其他种类的队列可能使用不同的布局来存放元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个Queue必须指定排序属性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Queue接口的核心方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共有3组方法，每一组方法对应两个方法。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47738693467336685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJLhZBYql2pbJmya4wqficx8OPibDUPYwQEicadiaJWPhoz8fczkkH8BlnCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;&lt;figcaption&gt;Queue的核心方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;动作&lt;/th&gt;&lt;th&gt;抛异常&lt;/th&gt;&lt;th&gt;返回特殊值&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Insert&lt;/td&gt;&lt;td&gt;add(e)&lt;/td&gt;&lt;td&gt;offer(e)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Remove&lt;/td&gt;&lt;td&gt;remove()&lt;/td&gt;&lt;td&gt;poll&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Examine&lt;/td&gt;&lt;td&gt;element()&lt;/td&gt;&lt;td&gt;peek()&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1）比如&lt;code&gt;添加（Insert）&lt;/code&gt;元素的动作，会有两种方式：&lt;code&gt;add(e)&lt;/code&gt;和&lt;code&gt;offer(e)&lt;/code&gt;。如果调用add(e)方法时，添加失败，则会&lt;code&gt;抛异常&lt;/code&gt;，而如果调用的是offer(e)方法失败时，则会&lt;code&gt;返回false&lt;/code&gt;。offer方法用于异常是正常的情况下使用，比如在有界队列中，优先使用offer方法。假如队列满了，不能添加元素，offer方法返回false，这样我们就知道是队列满了，而不是去handle运行时抛出的异常。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）同理，移除（Remove）元素的动作，队列为空时，remove方法抛异常，而poll返回null。如果移除头部的元素成功，则返回移除的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（3）同理，检测（Examine）元素的动作，返回头部元素（最开始加入的元素），但不删除元素， 如果队列为空，则element()方法抛异常，而peek()返回false。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（4）Queue接口没有定义阻塞队列的方法，这些方法在BlockQueue接口中定义了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（5）Queue实现类通常不允许插入null元素，尽管一些实现类比如LinkedList不禁止插入null，但是还是不建议插入null，因为null也被用在poll方法的特殊返回值，以说明队列不包含元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、双端可用Deque接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 深入理解Deque接口的原理&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33224043715846996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ8MLQ9wiaulv3bYib3zOLuvnfbFnkgrFB8fkriaHqFTN2ntuWOFLWlsWvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;915&quot;/&gt;&lt;figcaption&gt;双端队列Deque&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）Deque概念：&lt;/strong&gt; 支持两端元素插入和移除的线性集合。名称&lt;code&gt;deque&lt;/code&gt;是双端队列的缩写，通常发音为&lt;code&gt;deck&lt;/code&gt;。大多数实现Deque的类，对它们包含的元素的数量没有固定的限制的，支持有界和无界。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）Deque方法说明：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2430406852248394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ7VI8ibWPsGfZpsUnuSFc2hNNI7B3zzdjLZtbRMJVlHKcVv5vLl9FBlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;figcaption&gt;Deque方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;该列表包含包含访问deque两端元素的方法，提供了插入，移除和检查元素的方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这些方法种的每一种都存在两种形式：如果操作失败，则会抛出异常，另一种方法返回一个特殊值（null或false，取决于具体操作）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;插入操作的后一种形式专门设计用于容量限制的Deque实现，大多数实现中，插入操作不能失败，所以可以用插入操作的后一种形式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deque接口扩展了Queue接口，当使用deque作为队列时，作为FIFO。元素将添加到deque的末尾，并从头开始删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;作为FIFO时等价于Queue的方法如下表所示：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;0.68&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJxX9R0yafxvXwyEBIB4rrib2jadpUefEHicqkiaat5U9zrA5cyXibG8MAlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Queue的add方法和Deque的addLast方法等价。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Deque也可以用作LIFO（后进先出）栈，这个接口优于传统的Stack类。当作为栈使用时，元素被push到deque队列的头，而pop也是从队列的头pop出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Stack（栈）的方法正好等同于Deque的如下方法：&lt;/p&gt;&lt;img data-ratio=&quot;0.4048140043763676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJroxMuwzueQmTSuNEQQaShTCbAElicDW4XIWG7SaXwtEBPvIYLdIGNcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：peek方法不论是作为栈还是队列，都是从队列的检测队列的头，返回最先加入的元素。比如第一次put 100，第二次put 200，则peek返回的是100。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27247191011235955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ3LF89TibshJvvIP8oxB1dlc0ic1tJzkia6GGibZ876pbe1rkh4MicHxbeCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;figcaption&gt;示例代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 哪些类实现了Deque接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedList类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ArrayDeque类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConcurrentLinkedDeque类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 哪些类继承了Deque接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、队列骨架AbstractQueue抽象类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1  深入理解AbstractQueue抽象类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueue是一个抽象类，继承了Queue接口，提供了一些Queue操作的骨架实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ2G9kCia1e7kyZwhzd0zt1TOiaUzWSuQ4iaZDsfX4hVIiciaSJhsU1MjCucw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;432&quot;/&gt;&lt;figcaption&gt;AbstractQueue的方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法add、remove、element方法基于offer、poll和peek。也就是说如果不能正常操作，则抛出异常。我们来看下AbstactQueue是怎么做到的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(E e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (offer(e))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;Queue full&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    E x = poll();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;element&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    E x = peek();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果继承AbstractQueue抽象类则必须保证offer方法不允许null值插入。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 哪些类继承了AbstractQueue抽象类&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkendBlockingQueue&lt;/code&gt;类、&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;类、&lt;code&gt;LinkedTransferQueue&lt;/code&gt;类、&lt;code&gt;SynchronousQueue&lt;/code&gt;类、&lt;code&gt;PriorityBlockQueue&lt;/code&gt;类、&lt;code&gt;DelayQueue类&lt;/code&gt;&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;类和&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;类&lt;strong&gt;继承&lt;/strong&gt; 了&lt;code&gt;AbstractQueue&lt;/code&gt;抽象类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、阻塞缓冲BlockingQueue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 宏观来看BlockingQueue（阻塞队列）&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43462897526501765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJqnaw8XAaeRAcAro3oBsdRJ9jJurTk1reGiaswo8ygXEHxLlbvQjqECw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;figcaption&gt;阻塞队列满了的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33223684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJPN2K0wCQK8JicbZwicCWWB1P7iaicWickQQpfDm5BnAdNyw1HCBn2abMaWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;figcaption&gt;阻塞队列为空的情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）BlockingQueue（阻塞队列）也是一种队列，支持阻塞的插入和移除方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）阻塞的插入：当队列满时，队列会阻塞插入元素的线程，直到队列不满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）阻塞的移除：当队列为空，获取元素的线程会等待队列变为非空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）应用场景：生产者和消费者，生产者线程向队列里添加元素，消费者线程从队列里移除元素，阻塞队列时获取和存放元素的容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）为什么要用阻塞队列：生产者生产和消费者消费的速率不一样，需要用队列来解决速率差问题，当队列满了或空的时候，则需要阻塞生产或消费动作来解决队列满或空的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 案例解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程A往阻塞队列（Blocking Queue）中&lt;code&gt;添加&lt;/code&gt;元素，而线程B从阻塞队列中&lt;code&gt;移除&lt;/code&gt;元素。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;当阻塞队列为空的时候&lt;/strong&gt; （一个元素都没有），则从队列中获取元素的操作将会被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生活中的案例：去海底捞吃火锅的时候，早上8点没人来吃火锅，所以需要等客人过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;翻译成线程：现在没有元素需要添加，而且阻塞队列为空，所以线程B不需要从队列中拿元素出来，所以线程B获取元素的操作被阻塞了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;当阻塞队列满了的时候&lt;/strong&gt; （所有位置都放有元素），则从队列中添加元素的操作将会被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生活中的案例：去海底捞吃火锅的时候，人太多了，需要排号，等其他桌空出来了才能进去。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;翻译成线程：线程A往阻塞队列中添加元素，将队列填满了，线程B现在正在忙，无法拿出队列中的元素，所以阻塞队列没有地方再放元素了，这个时候线程A添加元素的操作就被阻塞了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 操刀BlockingQueue接口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BlockingQueue接口的10个核心方法：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.264935064935065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTx6DnvptfKQWLJvicgKze5mmJ4ahicOZdV9dFN2eFm6YcECEzSotVXkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;385&quot;/&gt;&lt;figcaption&gt;继承的方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;10个核心方法总结如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4692218350754936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ3gcghRqzJ1yE6VxxNLK5Op0jIKpDPwZCRPiaSLQmia1sW9e7JzaGyJxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;figcaption&gt;BlockingQueue接口的10个核心方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三大类操作：插入、移除、检查。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;插入有四种方法：&lt;/strong&gt; add、offer、put、offer超时版。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IllegalStateException&lt;/code&gt; - 队列满了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ClassCastException&lt;/code&gt; - 添加的元素类型不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NullPointerException&lt;/code&gt; - 添加的元素为null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt; - 添加的元素某些属性不匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add方法特别之处用于添加失败时抛出异常，共有四种异常：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;offer方法特别之处用于添加失败时只返回false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;put方法特别之处用于当阻塞队列满时，生产者如果往队列里put元素，则队列会一直阻塞生产者线程，直到队列可用或者响应中断退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;offer超时方法特别之处用于当阻塞队列满时，生产者如果往队列里面插入元素，队列会阻塞生产者线程一段时间，如果超过了指定时间，生产者线程会退出，并返回false。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;移除有四种方法：&lt;/strong&gt; remove、poll、take、poll超时版&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NoSuchElementException&lt;/code&gt; - 如果这个队列是空的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove方法特别之处用于移除失败时抛出异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll方法特别之处用于移除失败时返回null&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;take方法特别之处用于当阻塞队列为空时，消费者线程如果从队列里面移除元素，则队列会一直阻塞消费者线程，直到队列不为空&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;poll超时方法特别之处用于当阻塞队列空时，消费者如果从队列里面删除元素，则队列会一直阻塞消费者线程，如果超过了指定时间，消费者线程会退出，并返回null&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;检查有两种方法：&lt;/strong&gt; element、peek&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;element方法用于检测头部元素的存在性，如果队列为空，则抛出异常，否则返回头部元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;peek方法用于检测头部元素的存在性，如果队列为空，返回特殊值null，否则返回头部的元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 BlockingQueue通过什么来阻塞插入和移除的？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过LockSupport. park（this）来实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;park这个方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与park对应的unpark执行或已经执行时。“已经执行”是指unpark先执行，然后再执行park的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程被中断时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待完time参数指定的毫秒数时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常现象发生时，这个异常现象没有任何原因。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 哪些类继承了BlockingQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingDeque接口 - 双端阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TransferQueue接口 - 传输队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 哪些类实现了BlockingQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue类 - 由数组构成的有界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue类 - 由链表构成的有界阻塞队列，界限默认大小为Integer.MAX_Value（2^31-1），值非常大，相当于无界。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque类 - 由链表构成的双向阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue类 - 由链表构成的无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue类 - 不存储元素的阻塞队列，只有一个元素进行数据传递。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue类 - 由链表构成的无界阻塞TransferQueue队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DelayQueue类 - 使用优先级队列实现的延迟无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 BlockingQueue接口继承了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口继承了Queue接口，可作为队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、双端阻塞BlockingDeque接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 从原理图上理解BlockDeque&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockQueue满了，两端的Take操作被阻塞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3497142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJu0Jg2A69ic93bxxdFjpsLsFIguhbK9Ke82mqjiaswzzwK2xXicZicVUAQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;figcaption&gt;BlockingDeque满了&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockQueue为空，两端的Take操作被阻塞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38426453819840367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJAiabUoZo3H9L6zP16Zeq6139w2jxIcnU7ZeE7bcfug0UFbo0iaLbj8OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;figcaption&gt;BlockQueue为空&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 BlockingDeque接口方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是阻塞队列&lt;code&gt;BlockingQueue&lt;/code&gt;和双向队列&lt;code&gt;Deque&lt;/code&gt;接口的结合。有如下方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJqO622N0N9UqV3AXvbJ2PDYIaCiahWq1OYibGaZ8n0MqeoicibPXPd3QHrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;BlockingDeque接口方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试执行以下方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LinkedBlockingDeque queue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque();&lt;br/&gt;queue.addFirst(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;queue.addFirst(&lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;queue.addLast(&lt;span&gt;&quot;400&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后队列中的元素顺序如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;300, test1, 400。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先添加了test1放到队列的头部，然后在头部的前面放入300，所以300在最前面，成为头部，然后将400放入队列的尾部，所以最后的结果是300, test1, 400。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4056737588652482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ6oonNqOfibNa8YwtexzxUzXPgFDtfVLehI0yFCt1zQl7NoT4MdOTtPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;705&quot;/&gt;&lt;figcaption&gt;队列种的元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 BlockDeque和BlockQueue的对等方法&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9040767386091128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJdvRsiaEcrAbBsgbZW0dq7nB1JJj8Me072ic4m71emBpauL6IXpIpHesQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;417&quot;/&gt;&lt;figcaption&gt;BlockDeque和BlockQueue的对等方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.4 BlockingDeque的特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许使用null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无界和有界都可以。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.5 BlockingDeque接口继承了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Queue接口，具有队列的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Deque接口，具有双端队列的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.6 哪些类实现了BlockDeque接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、使命必达TransferQueue接口&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 Transfer怎么理解？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有消费者正在获取元素，则将队列中的元素传递给消费者。如果没有消费者，则等待消费者消费。我把它称作使命必达队列，必须将任务完成才能返回。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 生活中的案例&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的transfer方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。小明一次只能拿一个，快递员必须等小明拿了一个后，才能继续给第二个。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的tryTransfer方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。发现小明不在家，就把快递直接放到菜鸟驿站了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对TransferQueue的tryTransfer超时方法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;圆通快递员要将小明的2个快递送货到门，韵达快递员也想将小明的2个快递送货到门。发现小明不在家，于是先等了5分钟，发现小明还没有回来，就把快递直接放到菜鸟驿站了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 TransferQueue的原理解析&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;transfer(E e)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;原理如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1124807395993837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJHichW8Licd6XGq1yuzqVshsJ5bZz5iclmEjtNPSPEL4licLI7kN8OKMXvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;transfer方法的原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原理图解释：生产者线程Producer Thread尝试将元素B传给消费者线程，如果没有消费者线程，则将元素B放到尾节点。并且生产者线程等待元素B被消费。当元素B被消费后，生产者线程返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前有消费者正在等待接收元素（消费者通过take方法或超时限制的poll方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者等待接收元素，transfer方法会将元素放在队列的tail（尾）节点，并等到该元素被消费者消费了才返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tryTransfer(E e)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;试探生产者传入的元素是否能直接传给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者等待接收元素，则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和transfer方法的区别是，无论消费者是否接收，方法立即返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tryTransfer(E e, long timeout, TimeUnit unit)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;带有时间限制的tryTransfer方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;试图把生产者传入的元素直接传给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有消费者消费该元素则等待指定的时间再返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果超时了还没有消费元素，则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在超时时间内消费了元素，则返回true。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;getWaitingConsumerCount()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取通过BlockingQueue.take()方法或超时限制poll方法等待接受元素的消费者数量。近似值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回等待接收元素的消费者数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;hasWaitingConsumer()&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取是否有通过BlockingQueue.tabke()方法或超时限制poll方法等待接受元素的消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回true则表示至少有一个等待消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 TransferQueue接口继承了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Queue接口，可作为队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.4 哪些类实现了TransferQueue接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;九、优先由你PriorityQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.1 理解PriorityQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2513020833333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTcwqRggrf6iaIosrWcyFECoksV0icLMMuic2EpowLF4wWSaq0wOpDiauUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;figcaption&gt;本应该按照升序排序&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40618955512572535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ5zW3eJWFWe4bqiaud3ysVKjK6nD4e9bhaWOSChp3En8Xj07saMBokmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;figcaption&gt;按照自定义优先级排序&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;PriorityQueue是一个支持优先级的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;默认自然顺序升序排序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以通过构造参数Comparator来对元素进行排序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;PriorityQueue&lt;/span&gt;&lt;span&gt;(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt; comparator)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;this&lt;/span&gt;(DEFAULT_INITIAL_CAPACITY, comparator);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;自定义实现comapreTo()方法来指定元素排序规则。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt; comparator() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; comparator;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现PriorityQueue接口的类，不保证线程安全，除非是PriorityBlockingQueue。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PriorityQueue的迭代器不能保证以任何特定顺序遍历元素，如果需要有序遍历，请考虑使用&lt;code&gt;Arrays.sort(pq.toArray)&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进列(&lt;code&gt;offer&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;)和出列（ &lt;code&gt;poll&lt;/code&gt;、&lt;code&gt;remove()&lt;/code&gt;）的时间复杂度O(log(n))。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove(Object) 和 contains(Object)的算法时间复杂度O(n)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;peek、element、size的算法时间复杂度为O(1)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 PriorityQueue类继承了哪些类？&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 PriorityQueue类实现了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十、双向链表LinkedList类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.1 LinkedList的结构&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedList实现了List和Deque接口，所以是一种双链表结构，可以当作堆栈、队列、双向队列使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个双向列表的每一个元素都有三个整数值：元素、向后的节点链接、向前的节点链接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4586709886547812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJKmXvYjJLMscqianGo1L4esvfux0WQJB49X2G0IWRRaviaNF9d8ZgibRHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;figcaption&gt;LinkedList的结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下节点类Node&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    E item; &lt;span&gt;//元素&lt;/span&gt;&lt;br/&gt;    Node&amp;lt;E&amp;gt; next; &lt;span&gt;//向后的节点链接&lt;/span&gt;&lt;br/&gt;    Node&amp;lt;E&amp;gt; prev; &lt;span&gt;//向前的节点链接&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.item = element;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.prev = prev;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.2 与ArrayList的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.LinkedList的增加和删除效率相对较高，而查找和修改的效率相对较低。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.以下情况建议使用ArrayList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;频繁访问列表中的一个元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只在列表的首尾添加元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.以下情况建议使用LinkedList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;频繁地在列表开头、中间、末尾添加和删除元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要通过循环迭代来访问列表中的元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.3 LinkedList不是线程安全的&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedList不是线程安全的，所以可以使用如下方式保证线程安全。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List list = Collections.synchronizedList(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.4 LinkedList的家庭成员关系&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 继承了 AbstractSequentialList 类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Queue 接口，可作为队列使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 继承了 AbstractQueue抽象类，具有队列的功能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 List 接口，可进行列表的相关操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Deque 接口，可作为双向队列使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 Cloneable 接口，可实现克隆。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十一、并发安全ConcurrentLinkedQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.1 理解ConcurrentLinkedQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29554655870445345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJEiaia1ZAyqIo9wdTIHSMwz086HxMSR9Pk8kr5ryOXocdOGBXYOyBgmXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1235&quot;/&gt;&lt;figcaption&gt;ConcurrentLinkedQueue原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ConcurrentLinked是由链表结构组成的线程安全的先进先出无界队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当多线程要共享访问集合时，ConcurrentLinkedQueue是一个比较好的选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持非阻塞地访问并发安全的队列，不会抛出ConcurrentModifiationException异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size方法不是准确的，因为在统计集合的时候，队列可能正在添加元素，导致统计不准。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量操作addAll、removeAll、retainAll、containsAll、equals和toArray不保证原子性（操作不可分割）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加元素happen-before其他线程移除元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用法如下：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ConcurrentLinkedQueue queue = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedQueue();&lt;br/&gt;BuildingBlockWithName buildingBlock = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;concurrentLinkedQueue.add(buildingBlock);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.2 ConcurrentLinkedQueue类继承了哪些类？&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.3 ConcurrentLinkedQueue类实现了哪些接口？&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十二、双向数组ArrayDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3778538812785388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJMmrib4dwnWGTsygrFwTWibVUrswCHBI2QgUwZ8iaSl8RQ4cGKlR90ib2iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;figcaption&gt;ArrayDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.1 理解ArrayDeque&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由数组组成的双端队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有容量限制，根据需要扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不是线程安全的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁止插入null元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当用作栈时，比栈速度快，当用作队列时，速度比LinkList快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大部分方法的算法时间复杂度为O(1)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;remove、removeFirstOccurrence、removeLastOccurrence、contains、remove 和批量操作的算法时间复杂度O(n)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.2 使用方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个ArrayDeque，往arrayDeque队尾添加元素。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ArrayDeque arrayDeque = &lt;span&gt;new&lt;/span&gt; ArrayDeque();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;50&lt;/span&gt;; i++) {&lt;br/&gt;    arrayDeque.add(buildingBlock); &lt;span&gt;// add方法等价于addLast方法&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.3 ArrayDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十三、双向并发ConcurrentLinkedDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.1 理解ConcurrentLinkedDeque类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31805555555555554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ9xj2FHI5oYumlvYFMqTqrl0HZ4pSU16GKmTE05BRVjrwNFkxgJ6ZPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;figcaption&gt;ConcurrentLinkedDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由链表结构组成的双向无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;插入、删除和访问操作可以并发进行，线程安全的类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许插入null元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在并发场景下，计算队列的大小是不准确的，因为计算时，可能有元素加入队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量操作addAll、removeAll、retainAll、containsAll、equals和toArray不保证原子性（操作不可分割）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.2 ConcurrentLinkedDeque使用示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建两个积木：三角形、四边形，然后添加到队列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BuildingBlockWithName buildingBlock1 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;BuildingBlockWithName buildingBlock2 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;四边形&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;ConcurrentLinkedDeque concurrentLinkedDeque = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedDeque();&lt;br/&gt;concurrentLinkedDeque.addFirst(buildingBlock1);&lt;br/&gt;concurrentLinkedDeque.addLast(buildingBlock2);&lt;br/&gt;&lt;span&gt;//结果：顺序：三角形、四边形&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.3 ConcurrentLinkedDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十四、数组阻塞ArrayBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.1 理解ArrayBlockingQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7349768875192604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ4AelrbnDcEVoibNIKYw2v7b7FfnjMbYWKuicPlXm1TjbfJ2eZTvRsgicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;ArrayBlockingQueuey原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照先进先出（FIFO）原则对元素进行排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认不保证线程公平的访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平访问队列：按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格。有可能先阻塞的线程最后才访问访问队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平性会降低吞吐量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.2 ArrayBlockingQueue使用示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建两个积木：三角形、四边形，然后添加到队列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BuildingBlockWithName buildingBlock1 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;三角形&quot;&lt;/span&gt;, &lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;BuildingBlockWithName buildingBlock2 = &lt;span&gt;new&lt;/span&gt; BuildingBlockWithName(&lt;span&gt;&quot;四边形&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;ArrayBlockingQueue arrayBlockingQueue = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;arrayBlockingQueue.add(buildingBlock1);&lt;br/&gt;arrayBlockingQueue.add(buildingBlock2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.3 ArrayBlockQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十五、链表阻塞LinkedBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.1 理解LinkedBlockingQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.502906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ52Nwoq0ticKZDgBHXwCC1rrweeTm36fsXzu2tqKF2c80rrK4xdMbK1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;figcaption&gt;LinkedBlockingQueue原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue具有单链表和有界阻塞队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认和最大长度为Integer.MAX_VALUE，相当于无界(值非常大：2^31-1)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.2 LinkedBlockingQueue使用示例&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LinkedList linkedList1 = &lt;span&gt;new&lt;/span&gt; LinkedList();&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;A&quot;&lt;/span&gt;);&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;linkedList1.add(&lt;span&gt;&quot;C&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.3 LinkedBlockingQueue的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;吞吐量通常要高于ArrayBlockingQueue。创建线程池时，参数runnableTaskQueue（任务队列），用于保存等待执行的任务的阻塞队列可以选择LinkedBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.4 LinkedBlockingQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 BlockingQueue类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十六、双向阻塞LinkedBlockingDeque类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.1 理解LinkedBlockingDeque类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5433422698838248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJUO5lMaTjDSMYJR8jqF6a8usvYR83tVtgMHicRqialNUOIqPyFypFJyicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;figcaption&gt;LinkedBlockingDeque原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由链LinkedBlockingDeque = 阻塞队列+链表+双端访问&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程同时入队时，因多了一端访问入口，所以减少了一半的竞争。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认容量大小为Integer.MAX_VALUE。可指定容量大小。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.2 LinkedBlockingDeque的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedBlockingDeque可以用在“工作窃取“模式中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;工作窃取算法&lt;/code&gt;：某个线程比较空闲，从其他线程的工作队列中的队尾窃取任务来帮忙执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.3 LinkedBlockingDeque实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 BlockingDeque类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十七、链表阻塞LinkedTransferQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.1 理解LinkedTransferQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8032608695652174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJnuEia8W6DDz933PxpIibNqficRq8X2BvNXenMZaDiaw3DZWB7gvr0UoaCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;figcaption&gt;LinkedTransferQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedTransferQueue = 阻塞队列+链表结构+TransferQueue&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们讲“使命必达TransferQueue接口时&lt;strong&gt;已经介绍过了TransferQueue接口&lt;/strong&gt; ，所以LinkedTransferQueue接口跟它相似，只是加入了阻塞插入和移除的功能，以及结构是链表结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的TransferQueue也讲到了3个案例来说明TransferQueue的原理，大家可以回看TransferQueue。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.2 LinkedTransferQueue接口比其他阻塞队列多了5个方法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;transfer(E e)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryTransfer(E e)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryTransfer(E e, long timeout, TimeUnit unit)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getWaitingConsumerCount()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hasWaitingConsumer()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.3 LinkedTransferQueue代码示例&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个LinkedTransferQueue，生产者1 依次往队列中添加 A、B、C&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5511450381679389&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJzic0OgKOb0PGhzpkWvLPdlk7UULKw5catOfQnCMm29xbCcH9vHRWBng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;figcaption&gt;生产者1 依次往队列中添加 A、B、C&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5583941605839416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJQMia0eDcicAuEhAfvPlQSlSjn9BKcreqro9J3ia0tt7SPz1N4GKPjbktg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;figcaption&gt;生产者2 依次往队列中添加 D、E、F&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费者依次从队列首部开始消费元素，每次消费前，先sleep 2s，来演示transfer方法是否进行了等待。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9723926380368099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJTJYFibiaqtLNDECfEkHg2Zk1zzkEIlQJcaVKvtR1v3Nx7kWN7iaNskfVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;figcaption&gt;消费者消费元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;生产者&lt;span&gt;1&lt;/span&gt;     transfer A &lt;br/&gt;生产者&lt;span&gt;2&lt;/span&gt;     transfer D &lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;  &lt;br/&gt;消费者      take A&lt;br/&gt;生产者&lt;span&gt;1&lt;/span&gt;     put B &lt;br/&gt; &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;     &lt;br/&gt;消费者      take D&lt;br/&gt;生产者&lt;span&gt;2&lt;/span&gt;     transfer E &lt;br/&gt;    &lt;br/&gt;&lt;span&gt;2&lt;/span&gt;s后...&lt;br/&gt;  &lt;br/&gt;消费者      take B&lt;br/&gt;生产者&lt;span&gt;1&lt;/span&gt;     transfer C &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）首先生产者线程1和2 调用transfer方法来传输A和D，发现没有消费者线程接收，所以被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）消费者线程过了2s后将A拿走了，然后生产者1 被释放继续执行，传输元素B，发现又没有消费者消费，所以进行了等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）消费者线程过了2s后，将排在队列首部的D元素拿走，生产者2继续往下执行，传输元素E，发现没有消费者，所以进行了等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）消费者线程过了2s后，将排在队列首部的B元素拿走，生产者1传输C元素，等待消费者拿走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）消费者不再消费了，所以生产者1和生产者2都被阻塞了，元素C和，元素E都没有被拿走，而且生产者2的F元素还没有开始传输，因为在等待元素D被拿走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）看下队列里面确实有C和E元素，而且E排在队列的首部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3099787685774947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJpyZN59TpEbAz3fVWVF9I2iaibdlVbCypZ2MFI9ShP1Ap5TLhdzSzR82g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;figcaption&gt;队列里面的元素&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.4 LinkedTransferQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 BlockingQeque类，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingDeque继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十八、传球好手SynchronousQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.1 理解SynchronousQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJ6zTDxpibX2gqloNEdHILkibMVpfiacObUMGxV3RHVZ5Ou42nVwpFEvqjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;figcaption&gt;SynchronousQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我称SynchronousQueue为”传球好手“。想象一下这个场景：小明抱着一个篮球想传给小花，如果小花没有将球拿走，则小明是不能再拿其他球的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue负责把生产者产生的数据传递给消费者线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue本身不存储数据，调用了put方法后，队列里面也是空的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每一个put操作必须等待一个take操作完成，否则不能添加元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;适合传递性场景。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;性能高于ArrayBlockingQueue和LinkedBlockingQueue。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.2 SynchronousQueue示例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建了两个线程，一个线程用于生产，一个线程用于消费&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.587378640776699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJLhibG0DhicSTdXTiaohQ3axf7ibEsXKI8W2ibPjiaKFcJDT1unibdoCibbS1WA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;figcaption&gt;生产的线程依次put A、B、C三个值&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消费线程使用take来消费阻塞队列中的内容，每次消费前，等待5秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.151291512915129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJccAiaDxjRjEND19qvu7LxwJPBq5icG2zq2icJn8jOGkA5f807RxicSYEPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;figcaption&gt;消费线程每隔5s调用take方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;t1     put A &lt;br/&gt;t2     take A &lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;秒后...&lt;br/&gt;&lt;br/&gt;t1     put B &lt;br/&gt;t2     take B &lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;秒后...&lt;br/&gt;&lt;br/&gt;t1     put C &lt;br/&gt;t2     take C &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结：说明生产线程执行put第一个元素&quot;A&quot; 操作后，需要等待消费者线程take完“A”后，才能继续往下执行代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.1 SynchronousQueue应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;吞吐量通常要高于LinkedBlockingQueue。创建线程池时，参数runnableTaskQueue（任务队列），用于保存等待执行的任务的阻塞队列可以选择SynchronousQueue。静态工厂方法Executors.newCachedThreadPool()使用了这个队列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.2 SynchronousQueue和LinkedTransferQueue的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue 不存储元素，而LinkedTransferQueue存储元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue 队列里面没有元素，而LinkedTransferQueue可以有多个存储在队列等待传输。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue还支持若传输不了，则丢到队列里面去。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedTransferQueue还支持若超过一定时间传输不了，则丢到队列里面去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十九、优先级阻塞PriorityBlockingQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;19.1 理解PriorityBlockQueue类&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5834333733493398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJv5KNjwGPMD1vcFKu1LQ1pCiaAQARA1icReSHTNCHo2QDic3kUpxDe022Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;figcaption&gt;PriorityBlockQueue的原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;PriorityBlockQueue = PriorityQueue + BlockingQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之前我们也讲到了PriorityQueue的原理，支持对元素排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元素默认自然排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以自定义CompareTo()方法来指定元素排序规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以通过构造函数构造参数Comparator来对元素进行排序。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;19.2 PriorityBlockQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue继承了 AbstractQueue抽象类，具有队列的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二十、延时阻塞DelayQueue类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.1 理解DelayQueue&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5750736015701668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJV6rM80dYpyq576annxX1MbRC67ERbDEdFLRT9fDyeWavoJ0zYPjuTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;&lt;figcaption&gt;DelayQueue原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DelayQueue = Delayed + BlockingQueue。队列中的元素必须实现Delayed接口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Delayed&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在创建元素时，可以指定多久可以从队列中获取到当前元素。只有在延时期满才能从队列中获取到当前元素。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.2 源码解析&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(E e, &lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; offer(e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取元素的方法poll需要等待延时时间过了才能获取到元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt; || first.getDelay(NANOSECONDS) &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; q.poll();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5941043083900227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ15FD3ebksZdnZeeWicsyDnJpdu4xyQQfQw7VlejFelbv6XeicsWK4Igiaiac1oDmMlSicOLtKvfXGb34g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;figcaption&gt;poll方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.3 应用场景&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存系统的设计：可以用DelayQueue保存缓存元素的有效期。然后用一个线程循环的查询DelayQueue队列，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定时任务调度：使用DelayQueue队列保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行。比如Java中的TimerQueue就是使用DelayQueue实现的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;20.4 DelayQueue实现了哪些接口&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DelayQueue实现了 BlockingQueue接口，可作为阻塞队列使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一篇&lt;span&gt;花了很多心思&lt;/span&gt;在上面，看&lt;strong&gt;官方英文文档、画原理图、写demo代码，排版&lt;/strong&gt;。这恐怕是市面上&lt;strong&gt;&lt;span&gt;最全最细&lt;/span&gt;&lt;/strong&gt;讲解Queue的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>36012aa4c43ba490dabc1e594e3dc85d</guid>
<title>VSCode 多进程架构和插件加载原理</title>
<link>https://toutiao.io/k/4mlkrsi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;上周我在公司做了一个VSCode的分享，反响不是很好。内容坡度大，没有深入浅出。所以这一次我会更加详细的介绍细节，希望网上的同学看完之后有所收获。&lt;/p&gt;&lt;h2&gt;先提出三个问题&lt;/h2&gt;&lt;p&gt;1、为什么我打开VSCode，会打开N多个进程？&lt;/p&gt;&lt;p&gt;2、为什么我的全局搜索能用，但单个文件内的代码搜索却卡住了？&lt;/p&gt;&lt;p&gt;3、VSCode插件装多了会不会影响性能？&lt;/p&gt;&lt;p&gt;这些问题在本文都将得到解决。&lt;/p&gt;&lt;h2&gt;目录&lt;/h2&gt;&lt;p&gt;本文分为4个部分。&lt;/p&gt;&lt;p&gt;1、VSCode简介&lt;/p&gt;&lt;p&gt;2、多进程架构详解&lt;/p&gt;&lt;p&gt;3、最简单的插件&lt;/p&gt;&lt;p&gt;4、源码解析&lt;/p&gt;&lt;h2&gt;VSCode简介&lt;/h2&gt;&lt;blockquote&gt; 本文都是基于VSCode 1.47.3 的版本。&lt;br/&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;作者，Erich Gamma，Eclipse 架构师，《设计模式》经典书籍，妥妥的业内大佬。&lt;/li&gt;&lt;li&gt;关键词：免费、开源、轻量级、编辑器、跨平台、多语言、Git开箱即用、插件扩展。这里提一下扩平台，VSCode支持Mac、Windows、Linux、Web。&lt;/li&gt;&lt;li&gt;体量：前端大型项目，总代码量100万，其中60万TypeScript代码（cloc工具统计）&lt;/li&gt;&lt;li&gt;技术：&lt;b&gt;Electron&lt;/b&gt;、TypeScript、Monaco、xTerm、&lt;b&gt;LSP（Language Server Protocol）&lt;/b&gt;、&lt;b&gt;DAP（Debug Adapter Protocol）&lt;/b&gt;。我们将会着重介绍加粗的3个内容。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;时间线&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_b.jpg&quot; data-rawwidth=&quot;1632&quot; data-rawheight=&quot;924&quot; data-size=&quot;normal&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1632&quot; data-rawheight=&quot;924&quot; data-size=&quot;normal&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ef3ffa7ff9db90ac811d1be55df3bf39_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我第一次使用VSCode是2016年底，一个PHP同事和我说，VSCode写PHP真好用，随即我就被安利了。果然最好的语言就是要用最好的编辑器。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Electron&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_b.jpg&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8a5bacf2aea4a8b0bf43bccdc6decca6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;LSP&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_b.jpg&quot; data-rawwidth=&quot;1162&quot; data-rawheight=&quot;538&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1162&quot; data-rawheight=&quot;538&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-29503440c846432313d90cb245229120_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;语言服务协议，编程语言需要为编辑器实现一些常用的功能，比如hover效果，代码提示（intelligence），代码诊断（diagnostics）等功能，每个编辑器都有一套自己的规则。 从图中我们可以看出，左边为编程语言，右边为编辑器。没有LSP之前，编程语言和编辑器之间是多对多的关系，这种复杂性为 n^2 。但是引入LSP之后，就变成了一对多的关系，主流编辑器都采用同一个协议规则，而编程语言只需要面向语言服务协议编写功能即可，这像不像面向接口编程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_b.jpg&quot; data-rawwidth=&quot;1197&quot; data-rawheight=&quot;516&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1197&quot; data-rawheight=&quot;516&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-258470ddf304577fcc920bc3c656730c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是一张HTML语言服务协议和PHP语言服务协议的图，PHP和HTML实现了这种服务，而客户端通过JSON RPC这种远程调用，在VSCode插件进程内初始化这些语言服务。（语言服务运行在插件进程内）。&lt;/p&gt;&lt;p&gt;想了解如何自定义一个语言服务，可以看一下这篇文章&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.csdn.net/lusing/article/details/90755702&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;vscode插件快餐教程(7) - 从头开始写一个完整的lsp工程 &lt;/a&gt;&lt;/p&gt;&lt;p&gt;DAP&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_b.jpg&quot; data-rawwidth=&quot;1214&quot; data-rawheight=&quot;998&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1214&quot; data-rawheight=&quot;998&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1703f4edd8ab0dcc99e74853570f8923_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;调试适配器协议&lt;/p&gt;&lt;p&gt;它其实和LSP很像，所有的编程语言都公用一个调试界面，只需要实现DAP这个协议即可。&lt;/p&gt;&lt;h2&gt;多进程架构详解&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_b.jpg&quot; data-rawwidth=&quot;1648&quot; data-rawheight=&quot;1018&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1648&quot; data-rawheight=&quot;1018&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e5767697b4372a19103f3413c0113108_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;1、主进程（Main），一个 Electron 应用只有一个主进程。创建 GUI 相关的接口只由主进程来调用。&lt;/p&gt;&lt;p&gt;2、渲染进程（Renderer），每一个工作区（workbench）对应一个进程，同时是BrowserWindow实例。一个Electron项目可以有多个渲染进程。&lt;/p&gt;&lt;p&gt;3、插件进程（Extension），fork了渲染进程，每个插件都运行在一个NodeJS宿主环境中，即插件间共享进程。VSCode规定，插件不允许直接访问UI，这和Atom不同。&lt;/p&gt;&lt;p&gt;4、Debug进程，一个特殊的插件进程。&lt;/p&gt;&lt;p&gt;5、Search进程，搜索是密集型任务，单独占用一个进程。&lt;/p&gt;&lt;p&gt;6、进程之间通过IPC、RPC进行通信，这个后面会介绍。&lt;/p&gt;&lt;p&gt;7、LSP和DAP像两座桥梁，连接起语言和调试服务，它们都运行在插件进程中。&lt;/p&gt;&lt;p&gt;因为VSCode基于Electron，Electron基于chromium，所以进程和浏览器架构十分相似。&lt;/p&gt;&lt;h2&gt;进程间通信&lt;/h2&gt;&lt;p&gt;&lt;b&gt;IPC&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;nx&quot;&gt;electron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ipcRenderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;sendMessageFromRendererProcesses&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;渲染进程向主进程发送异步消息&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;electron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ipcMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sendMessageFromRendererProcesses&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sendMessageFromMainProcesses&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;回应异步消息：&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;VSCode的IPC通信是基于Electron，进程间可以双向通信，并且支持同步异步通信。&lt;/p&gt;&lt;p&gt;&lt;b&gt;RPC&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BrowserWindow&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;electron&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;win&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BrowserWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;600&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;win&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;loadURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://github.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是渲染进程直接调用Electron的远程模块，重新初始化一个界面BrowserWindow，并且打开一个页面，地址为&lt;code&gt;https://github.com&lt;/code&gt;。RPC一般用于单向调用，如渲染进程调用主进程。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1、多进程架构，实现了视图与逻辑分离。&lt;/p&gt;&lt;p&gt;2、基于接口编程（LSP、DAP），规范了扩展功能。&lt;/p&gt;&lt;p&gt;3、插件进程，单独开启一个进程。不影响启动速度，不影响主进程和渲染进程，不能直接改变UI样式。缺点，UI可扩展性差，优点，带来了统一的视觉效果和交互风格。&lt;/p&gt;&lt;h2&gt;最简单的插件&lt;/h2&gt;&lt;p&gt;下面是官方的一个搭建插件的教程&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//code.visualstudio.com/api/get-started/your-first-extension&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-dc8335c668dc4edf2695a6da12c2b6c4_180x120.jpg&quot; data-image-width=&quot;1012&quot; data-image-height=&quot;506&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;Your First Extension&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;code.visualstudio.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-dc8335c668dc4edf2695a6da12c2b6c4_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g yo generate-code
yo code
code ./helloworld&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们就生成了一个VSCode插件，目录如下，我和一个普通的前端项目没啥区别。我们只需要关心&lt;code&gt;package.json&lt;/code&gt;和&lt;code&gt;extension.ts&lt;/code&gt;。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;package.json&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;engines&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;vscode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;^1.47.0&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;activationEvents&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onLanguage:java&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.show.references&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.show.implementations&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.open.output&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.open.serverLog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.execute.workspaceCommand&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;onCommand:java.projectConfiguration.update&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;workspaceContains:pom.xml&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;workspaceContains:build.gradle&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有两个关键字，engines指VSCode兼容版本，activationEvents表示触发事件。onLanguage为语言为java时，输入命令onCommand:java.show.references（通过cmd + p可进入输入命令界面），或者工作区中包含pom.xml文件，这些都会加载插件。插件的加载机制是懒加载，只有触发了指定事件才会加载。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;extension.ts&lt;/b&gt;&lt;/p&gt;&lt;p&gt;extension里导出一个activate函数，表示当插件被激活时执行函数内的内容。Demo里注册了一个命令到VSCode的context上下文中，且当执行&lt;code&gt;hellworld&lt;/code&gt;这个命令时，会弹出一个提示语，我们将提示语由Hello World 改为了 Hello VS Code。&lt;/p&gt;&lt;p&gt;VSCode能自动实现插件项目，我们按F5即可进入调试模式，下面是一个输出提示语的视频。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.zhihu.com/zvideo/1294950108916887552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;知乎视频&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.zhihu.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--square&quot; alt=&quot;图标&quot; src=&quot;https://zhstatic.zhihu.com/assets/zhihu/editor/zhihu-card-default.svg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;源码解析&lt;/h2&gt;&lt;p&gt;源码解析分为4大块。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;目录结构&lt;/li&gt;&lt;li&gt;源码调试&lt;/li&gt;&lt;li&gt;工作台（WorkBench）加载&lt;/li&gt;&lt;li&gt;插件（Extension）加载&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;目录结构&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_b.jpg&quot; data-rawwidth=&quot;1578&quot; data-rawheight=&quot;1138&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1578&quot; data-rawheight=&quot;1138&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b367d5e51146312885847df1f573a609_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图分为上下两块内容，上面是VSCode外层的目录结构。下面为VSCode内部组织代码的规则，以base目录为例，它包含了个模块，vs目录下的其他模块，code、editor也是按照这个规则。&lt;/p&gt;&lt;h2&gt;源码调试&lt;/h2&gt;&lt;p&gt;项目的搭建比较简单，可以直接看官方的教程，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/microsoft/vscode/wiki/How-to-Contribute&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;How to Contribute&lt;/a&gt;。Mac的话主要一下Python版本和NodeJS脚本。&lt;/p&gt;&lt;p&gt;&lt;b&gt;web版启动&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;桌面版启动&lt;/b&gt;&lt;/p&gt;&lt;p&gt;本文讲的内容都是桌面版，启动完成之后，我们可以看到VSCode给我们提供的源码调试工具，OSS。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_b.jpg&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;316&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;316&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9d54e2a15b1e06e6c0a0f8f443e28b74_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;调试模式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;调试模式和桌面启动有所不同，我们直接在VSCode里打开源码项目，进入调试面板，先Launch VS Code，然后就可以选择是调试主进程、渲染进程还是插件进程。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_b.jpg&quot; data-rawwidth=&quot;1536&quot; data-rawheight=&quot;1064&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1536&quot; data-rawheight=&quot;1064&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-0565315a78665cc0347637403218afc9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;查看所有进程&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_b.jpg&quot; data-rawwidth=&quot;1786&quot; data-rawheight=&quot;506&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1786&quot; data-rawheight=&quot;506&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-41d28594e400bfb151f8526e22afc70f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;启动完成之后，通过命令行查看进程情况，上面我截取了插件进程相关的信息。如果是源码情况下，关键词就是OSS Helper。我们正常使用VSCode，就可以用关键词Code Helper查看进程相关情况。&lt;/p&gt;&lt;p&gt;&lt;b&gt;进程类型介绍&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_b.jpg&quot; data-rawwidth=&quot;1692&quot; data-rawheight=&quot;898&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1692&quot; data-rawheight=&quot;898&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-90e6d1eaa274a700c2b1e4fe46078876_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这是VSCode进程的类型，--type就是VSCode启动进程时识别进程类型的标识。有渲染进程，插件进程，GPU进程，可关闭，Watcher进程，和Webpack的Watch有些相似，都是监控文件变化的，搜索进程。插件是由渲染进程fork出来的，且一般情况插件共享一个进程，Debug进程比较特殊，它单独占用一个进程。&lt;/p&gt;&lt;h2&gt;源码之加载工作台&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// src/main.js
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 获取缓存文件目录地址和语言配置，用AMD Loader加载真正主入口
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;electron&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ready&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;onReady&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onReady() {&lt;/span&gt;
 &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nlsConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;nodeCachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ensureExists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;resolveNlsConfiguration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nlsConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cachedDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nlsConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kr&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;./bootstrap-amd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;vs/code/electron-main/main&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// src/vs/code/electron-main/main.ts
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 创建服务，初始化编辑器实例
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CodeMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CodeMain&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;main() {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;ParsedArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instanceEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;environmentService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bufferLogService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CodeApplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mainIpcServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instanceEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;VSCode初始化实例的方式比较特殊，采用的是依赖注入的模式，关于VSCod依赖注入的文章，可以看腾讯同学写的文章，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/96902077&quot; class=&quot;internal&quot;&gt;vscode 源码解析 - 依赖注入 &lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;// 打开一个窗口 &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// src/vs/code/electron-main/app.ts
class CodeApplication extends Disposable {
  async startup(): Promise&amp;lt;void&amp;gt; {
    const appInstantiationService = await this.createServices(machineId, sharedProcess, sharedProcessReady);

    const windows = appInstantiationService.invokeFunction((accessor) =&amp;gt;
      this.openFirstWindow(accessor, electronIpcServer, sharedProcessClient)
    );
  }

  private openFirstWindow(accessor: ServicesAccessor, electronIpcServer: ElectronIPCServer, sharedProcessClient: Promise&amp;lt;Client&amp;lt;string&amp;gt;&amp;gt;): ICodeWindow[] {
    const windowsMainService = this.windowsMainService = accessor.get(IWindowsMainService);
    return windowsMainService.open({
      context: OpenContext.API,
      cli: { ...environmentService.args },
      forceEmpty: true,
      gotoLineMode: true
    });
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;// 打开浏览器窗口，并加载配置&lt;br/&gt;// src/vs/platform/windows/electron-main/windowsMainService.ts &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;WindowsMainService&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Disposable&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IWindowsMainService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;open() {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;doOpen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doOpen() {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;openInBrowserWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;openInBrowserWindow() {&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createdWindow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;CodeWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;extensionDevelopmentPath&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;configuration.extensionDevelopmentPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;isExtensionTestHost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;extensionTestsPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doOpenInBrowserWindow() {&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 加载页面
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;// src/vs/code/electron-main/window.ts&lt;br/&gt;// this._win 为 BrowserWindow 对象，是electron一个模块 &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class CodeWindow extends Disposable {
  load() {
    this._win.loadURL(this.getUrl(configuration));
  }

  private getUrl() {
    let configUrl = this.doGetUrl(config);
    return configUrl;
  }

  private doGetUrl(config: object): string {
    // 打开 VSCode 的工作台，也就是 workbench
    return `${require.toUrl(
      &quot;vs/code/electron-browser/workbench/workbench.html&quot;
    )}?config=${encodeURIComponent(JSON.stringify(config))}`;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;src/vs/code/electron-browser/workbench/workbench.html&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;aria-label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Init Bootstrap Helpers --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../../../../bootstrap.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../../../../vs/loader.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../../../../bootstrap-window.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Startup via workbench.js --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;workbench.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;源码之插件加载&lt;/h2&gt;&lt;blockquote&gt;src/vs/code/electron-browser/workbench/workbench.js &lt;br/&gt;加载桌面插件，加载插件服务&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;bootstrapWindow.load(
  [
    &quot;vs/workbench/workbench.desktop.main&quot;,
    &quot;vs/nls!vs/workbench/workbench.desktop.main&quot;,
    &quot;vs/css!vs/workbench/workbench.desktop.main&quot;,
  ],
  (workbench, configuration) =&amp;gt; {
    // …
  }
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/workbench.desktop.main.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import &quot;vs/workbench/services/extensions/electron-browser/extensionService&quot;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/electron-browser/extensionService.ts &lt;br/&gt;监听生命周期钩子，实例化 ExtensionHostManager&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ExtensionService&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AbstractExtensionService&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IExtensionService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_lifecycleService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LifecyclePhase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// reschedule to ensure this runs after restoring viewlets, panels, and editors
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;nx&quot;&gt;runWhenIdle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*max delay*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_startExtensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_startExtensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isInitialStart&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialActivationEvents&lt;/span&gt;: &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// extensionHosts 为LocalProcessExtensionHost、RemoteExtensionHost、WebWorkerExtensionHost。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;extensionHosts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_createExtensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isInitialStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;extensionHosts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;extensionHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;processManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_instantiationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ExtensionHostManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;extensionHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialActivationEvents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/common/extensionHostManager.ts&lt;br/&gt;fork渲染进程，并加载 extensionHostProcess&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class ExtensionHostManager extends Disposable {
  constructor() {
      this._proxy = this._extensionHost.start()!.then();
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/electron-browser/localProcessExtensionHost.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class LocalProcessExtensionHost implements IExtensionHost {
  public start(): Promise&amp;lt;IMessagePassingProtocol&amp;gt; | null {
    // ...
    const opts = {
      env: objects.mixin(objects.deepClone(process.env), {
        // 加载插件进程
        AMD_ENTRYPOINT: &#x27;vs/workbench/services/extensions/node/extensionHostProcess&#x27;,
      }),
    }

    // Run Extension Host as fork of current process
    this._extensionHostProcess = fork(getPathFromAmdModule(require, &#x27;bootstrap-fork&#x27;), [&#x27;--type=extensionHost&#x27;], opts);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/node/extensionHostProcess.ts&lt;br/&gt;插件进程的入口，同时开启插件激活逻辑&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import { startExtensionHostProcess } from &quot;vs/workbench/services/extensions/node/extensionHostProcessSetup&quot;;
startExtensionHostProcess().catch((err) =&amp;gt; console.log(err));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/node/extensionHostProcessSetup.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;export async function startExtensionHostProcess(): Promise&amp;lt;void&amp;gt; {
    const extensionHostMain = new ExtensionHostMain(
        renderer.protocol,
        initData,
        hostUtils,
        uriTransformer
    );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/services/extensions/common/extensionHostMain.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;export class ExtensionHostMain {
  constructor() {
    // must call initialize *after* creating the extension service
        // because `initialize` itself creates instances that depend on it
        this._extensionService = instaService.invokeFunction(accessor =&amp;gt; accessor.get(IExtHostExtensionService));
        this._extensionService.initialize();
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/api/node/extHost.services.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import { ExtHostExtensionService } from &#x27;vs/workbench/api/node/extHostExtensionService&#x27;;

// 注册插件服务
registerSingleton(IExtHostExtensionService, ExtHostExtensionService);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/api/node/extHostExtensionService.ts&lt;br/&gt;继承了抽象类，AbstractExtHostExtensionService&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;export class ExtHostExtensionService extends AbstractExtHostExtensionService {

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;src/vs/workbench/api/common/extHostExtensionService.ts&lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class AbstractExtHostExtensionService extends Disposable {
  constructor() {
    this._activator = new ExtensionsActivator();
  }

  // 根据activationEvent事件名激活插件
  private _activateByEvent(activationEvent: string, startup: boolean): Promise&amp;lt;void&amp;gt; {
    return this._activator.activateByEvent(activationEvent, startup);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;整体的流程图如下&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_b.jpg&quot; data-rawwidth=&quot;1784&quot; data-rawheight=&quot;912&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1784&quot; data-rawheight=&quot;912&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f5c2ba69281ee1c3d04a01cc6572fbc4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;1、VSCode使用了哪些技术，TS、Electron、Monaco、LSP、DAP。&lt;/p&gt;&lt;p&gt;2、多进程架构（记住图即可）。&lt;/p&gt;&lt;p&gt;3、从一个Hello World插件入手。&lt;/p&gt;&lt;p&gt;4、源码解析，从加载工作区，到开启插件进程，最后激活插件。&lt;/p&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>963ede67bc85078c6dfe7a7e1110a9d5</guid>
<title>COW 奶牛！Copy On Write 机制了解一下</title>
<link>https://toutiao.io/k/0o00zy6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;output_wrapper&quot;&gt;&lt;h1&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;只有光头才能变强&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在读《Redis设计与实现》关于哈希表扩容的时候，发现这么一段话：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;执行BGSAVE命令或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用&lt;strong&gt;写时复制（copy-on-write）来优化子进程的使用效率&lt;/strong&gt;，所以在子进程存在期间，服务器会提高负载因子的阈值，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入操作，最大限度地节约内存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;触及到知识的盲区了，于是就去搜了一下copy-on-write写时复制这个技术究竟是怎么样的。发现涉及的东西蛮多的，也挺难读懂的。于是就写下这篇笔记来记录一下我学习copy-on-write的过程。&lt;/p&gt;&lt;p&gt;本文&lt;strong&gt;力求简单讲清copy-on-write这个知识点&lt;/strong&gt;，希望大家看完能有所收获。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;一、Linux下的copy-on-write&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在说明Linux下的copy-on-write机制前，我们首先要知道两个函数：&lt;code&gt;fork()&lt;/code&gt;和&lt;code&gt;exec()&lt;/code&gt;。需要注意的是&lt;code&gt;exec()&lt;/code&gt;并不是一个特定的函数, 它是&lt;strong&gt;一组函数的统称&lt;/strong&gt;, 它包括了&lt;code&gt;execl()&lt;/code&gt;、&lt;code&gt;execlp()&lt;/code&gt;、&lt;code&gt;execv()&lt;/code&gt;、&lt;code&gt;execle()&lt;/code&gt;、&lt;code&gt;execve()&lt;/code&gt;、&lt;code&gt;execvp()&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1.1简单来用用fork&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先我们来看一下&lt;code&gt;fork()&lt;/code&gt;函数是什么鬼：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;fork is an operation whereby a process creates a copy of itself.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;fork是类Unix操作系统上&lt;strong&gt;创建进程&lt;/strong&gt;的主要方法。fork用于&lt;strong&gt;创建子进程&lt;/strong&gt;(等同于当前进程的副本)。&lt;/p&gt;&lt;p&gt;如果接触过Linux，我们会知道Linux下&lt;strong&gt;init进程是所有进程的爹&lt;/strong&gt;(相当于Java中的Object对象)&lt;/p&gt;&lt;p&gt;下面以例子说明一下fork吧：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;   &lt;br/&gt;&lt;/span&gt;{   &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;pid_t&lt;/span&gt; fpid; &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; count=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;    fpid=fork();&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fpid &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)   &lt;br/&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;创建进程失败!/n&quot;&lt;/span&gt;);   &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (fpid == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {  &lt;br/&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;我是子进程，由父进程fork出来/n&quot;&lt;/span&gt;);   &lt;br/&gt;        count++;  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {  &lt;br/&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;我是父进程/n&quot;&lt;/span&gt;);   &lt;br/&gt;        count++;  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;统计结果是: %d/n&quot;&lt;/span&gt;,count);  &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;得到的结果输出为：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;c language-c hljs cpp&quot;&gt;我是子进程，由父进程fork出来&lt;br/&gt;&lt;br/&gt;统计结果是: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;我是父进程&lt;br/&gt;&lt;br/&gt;统计结果是: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释一下：&lt;/p&gt;&lt;p&gt;所以说：&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1.2再来看看exec()函数&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;从上面我们已经知道了fork会创建一个子进程。&lt;strong&gt;子进程的是父进程的副本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;exec函数的作用就是：&lt;strong&gt;装载一个新的程序&lt;/strong&gt;（可执行映像）覆盖&lt;strong&gt;当前进程&lt;/strong&gt;内存空间中的映像，&lt;strong&gt;从而执行不同的任务&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我去画张图来理解一下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5874877810361682&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0rYD4UOuqE979tribZmQRWtI85m00yPsAdibaaBt9PITibxxqosPDkw4WTGfyKMHDqwvsVqicbCxUgJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot; title=&quot;exec函数的作用&quot;/&gt;&lt;figcaption&gt;exec函数的作用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;程序员必备知识——fork和exec函数详解https://blog.csdn.net/bad_good_man/article/details/49364947&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;linux中fork（）函数详解（原创！！实例讲解）：https://blog.csdn.net/jason314/article/details/5640969&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;linux c语言 fork() 和 exec 函数的简介和用法：https://blog.csdn.net/nvd11/article/details/8856278&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Linux下Fork与Exec使用：https://www.cnblogs.com/hicjiajia/archive/2011/01/20/1940154.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Linux 系统调用 —— fork()内核源码剖析：https://blog.csdn.net/chen892704067/article/details/76596225&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;1.3回头来看Linux下的COW是怎么一回事&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;fork()会产生一个和父进程完全相同的子进程(除了pid)&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果按&lt;strong&gt;传统&lt;/strong&gt;的做法，会&lt;strong&gt;直接&lt;/strong&gt;将父进程的数据拷贝到子进程中，拷贝完之后，父进程和子进程之间的数据段和堆栈是&lt;strong&gt;相互独立的&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7365771812080537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0rYD4UOuqE979tribZmQRWttdbQdfdsWz9FXNm9bibFIeOibsp6X1fkbTgeKvKDRVb0xwwC72wGr4tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot; title=&quot;父进程的数据拷贝到子进程中&quot;/&gt;&lt;figcaption&gt;父进程的数据拷贝到子进程中&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;但是，以我们的使用经验来说：往往子进程都会执行&lt;code&gt;exec()&lt;/code&gt;来做自己想要实现的功能。&lt;/p&gt;&lt;p&gt;既然很多时候复制给子进程的数据是无效的，于是就有了Copy On Write这项技术了，原理也很简单：&lt;/p&gt;&lt;p&gt;另外的表达方式：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在fork之后exec之前两个进程&lt;strong&gt;用的是相同的物理空间&lt;/strong&gt;（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的&lt;strong&gt;物理空间是同一个&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当父子进程中&lt;strong&gt;有更改相应段的行为发生时&lt;/strong&gt;，再&lt;strong&gt;为子进程相应的段分配物理空间&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。&lt;/p&gt;&lt;p&gt;而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Copy On Write技术&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会&lt;strong&gt;把触发的异常的页复制一份&lt;/strong&gt;，于是父子进程各自持有独立的一份。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Copy On Write技术&lt;strong&gt;好处&lt;/strong&gt;是什么？&lt;/p&gt;&lt;p&gt;Copy On Write技术&lt;strong&gt;缺点&lt;/strong&gt;是什么？&lt;/p&gt;&lt;p&gt;几句话总结Linux的Copy On Write技术：&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Linux进程基础：http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Linux写时拷贝技术(copy-on-write)http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当你在 Linux 上启动一个进程时会发生什么？https://zhuanlan.zhihu.com/p/33159508&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Linux fork()所谓的写时复制(COW)到最后还是要先复制再写吗？https://www.zhihu.com/question/265400460&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写时拷贝（copy－on－write） COW技术https://blog.csdn.net/u012333003/article/details/25117457&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Copy-On-Write 写时复制原理https://blog.csdn.net/ppppppppp2009/article/details/22750939&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;二、解释一下Redis的COW&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;基于上面的基础，我们应该已经了解COW这么一项技术了。&lt;/p&gt;&lt;p&gt;下面我来说一下我对《Redis设计与实现》那段话的理解：&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那Redis会&lt;strong&gt;fork出一个子进程来读取数据，从而写到磁盘中&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现&lt;strong&gt;很多的分页错误(页异常中断page-fault)&lt;/strong&gt;，这样就得耗费不少性能在复制上。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;而在&lt;strong&gt;rehash阶段上，写操作是无法避免&lt;/strong&gt;的。所以Redis在fork出子进程之后，&lt;strong&gt;将负载因子阈值提高&lt;/strong&gt;，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;fork()后copy on write的一些特性：https://zhoujianshi.github.io/articles/2017/fork()%E5%90%8Ecopy%20on%20write%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/index.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写时复制：https://miao1007.github.io/gitbook/java/juc/cow/&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;三、文件系统的COW&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;下面来看看文件系统中的COW是啥意思：&lt;/p&gt;&lt;p&gt;Copy-on-write在对数据进行修改的时候，&lt;strong&gt;不会直接在原来的数据位置上进行操作&lt;/strong&gt;，而是重新找个位置修改，这样的好处是一旦系统突然断电，重启之后不需要做Fsck。好处就是能&lt;strong&gt;保证数据的完整性，掉电的话容易恢复&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;h1&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;最后我们再来看一下写时复制的思想(摘录自维基百科)：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;至少从本文我们可以总结出：&lt;/p&gt;&lt;p&gt;其实在Java里边，也有Copy On Write技术。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;1.0232974910394266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0rYD4UOuqE979tribZmQRWtF3SboPve3ypddzLwO9ypzYluc0VOulf6zJMpLndTsKDiagqcaLzneug/640?wx_fmt=png&quot; data-type=&quot;png&quot; title=&quot;Java中的COW&quot; data-w=&quot;&quot;/&gt;&lt;figcaption&gt;Java中的COW&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这部分留到下一篇来说，敬请期待~&lt;/p&gt;&lt;p&gt;如果大家有更好的理解方式或者文章有错误的地方还请大家不吝在评论区留言，大家互相学习交流~~~&lt;/p&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一个&lt;strong&gt;坚持原创的Java技术公众号：Java3y&lt;/strong&gt;，欢迎大家关注&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;3y所有的原创文章：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>abcddc3404323497a17217ef58058df2</guid>
<title>微保的 Serverless 云函数实践之路</title>
<link>https://toutiao.io/k/weh95rw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Markdown__Wrapper-sbgo4h-0 kKEhyL markdown-body&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285206848-00.jpg&quot;/&gt;      &lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot; aria-label=&quot;背景 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;微保前端架构在业务发展中，根据业务、团队、开发等实际情况，不断进化调整。本文将具体介绍微保前端的架构演进过程，以及团队最终选择使用腾讯云 Serverless 技术支撑前端架构的原因。&lt;/p&gt;
&lt;p&gt;微保团队使用 Serverless 技术的主要应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端开发同学，应用在BFF层，目前接入的有小程序，H5 页面。&lt;/li&gt;
&lt;li&gt;数据组同学，面向的风控和推荐算法应用，做计算使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;微保架构-v1&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E6%9E%B6%E6%9E%84-v1&quot; aria-label=&quot;微保架构 v1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保架构 v1&lt;/h2&gt;
&lt;p&gt;早期，团队使用经典的前后分离架构，前端开发与后端开发通过接口进行合作。&lt;/p&gt;
&lt;p&gt;合作流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285210728-01.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;毫无疑问，前后端分离的架构有比较显著的优势：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前后端开发解耦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285212842-02.jpg&quot;/&gt;            &lt;/p&gt;

&lt;p&gt;前后端分别设计与实现自己的错误监控和告警系统，前端对页面脚本错误进行捕获，上报至日志平台，经过日志处理工具，设置告警机制，将错误信息推送至相应的开发人员。&lt;/p&gt;

&lt;p&gt;前后端分离后，前端可以使用更为便捷的框架以及基于这些框架的基础UI组件，大大提升开发效率。另外，前端开发也会基于业务的特点，提取业务专属的公共组件，所有组件化的沉淀，都是对生产效率的提升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 部署解耦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前端项目中有大量的静态文件，包括 html、css、js、图片、视频等，将这些文件部署在 CDN 上，充分利用现有云服务的CDN能力，既能提升资源访问的速度又能保证资源访问的稳定性，尤其是在高并发的场景下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更加快捷的 CI/CD ，前端的编译过程可以非常简单地接入 CI/CD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前后端耦合的时代，前后端的统一部署相互依赖，分开部署后，可以针对前端项目以gitlab的repo 级别来做相应的 CI/CD。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，&lt;/strong&gt; 前后分离的架构对于业务早期的快速发展非常有效，而且在团队规模较小的时候，前后端开发人员合作固定，彼此对于对方的开发习惯、性格较熟，因此跨角色沟通的问题并不突出。但随着团队规模和业务规模持续扩大，这个架构模式给团队带来的副作用慢慢浮出水面。实践中，遇到的几个比较明显的问题，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前后端协作耦合慢慢成为开发效率提升的瓶颈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285216810-03.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;团队规模与业务规模的扩大，意味着合作的人员变多、接口的复杂度也会相应增加。&lt;/p&gt;
&lt;p&gt;早期专人专项大家彼此的开发习惯也熟悉，对业务也都比较熟悉，因此业务接口参数的调整沟通成本较低。但随着业务规模和团队成员扩充，在各种跨业务合作时就会有人碰到不习惯阅读proto，或有些复杂业务需要花费大量时间阅读proto文档，或前后端反复沟通接口调用时参数的具体含义等问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 页面渲染效率较差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285219013-04.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;以产品详情页为例，页面的渲染需要请求至少5个后端接口，然后再对数据进行组装和处理。这不仅增加了小程序端的代码体积，页面渲染的速度也是被拉低了。&lt;/p&gt;
&lt;p&gt;即使在前端页面对接口进行并行访问，但数据的整合逻辑依然会非常复杂。小程序作为微保主要的产品承载形态，代码量巨大，几近达到微信规定的代码上限，这种对于代码的增加随着业务增长也是一个隐形的风险。&lt;/p&gt;
&lt;h2 id=&quot;微保架构-v2&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E6%9E%B6%E6%9E%84-v2&quot; aria-label=&quot;微保架构 v2 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保架构 v2&lt;/h2&gt;
&lt;p&gt;鉴于上述前后端合作模式中的痛点，团队对架构再次进行优化，原则是业务“前”移、核心下沉。在前期的各种业务支撑中，团队已经有了一些业务中台的沉淀，比如投保服务、续保服务、保单服务等。&lt;/p&gt;
&lt;p&gt;中间层的引入让团队的开发效率进一步得到提升，前端对于业务的把控力及页面性能优化的操作空间也大大加强。不管是从团队的敏捷性、还是应用的体验，都有不错的改善，比如以下几个方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 前后端流程上的耦合大大减小，角色责任的专一性逐步形成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于一部分后端服务能力的积累，比如保单相关的需求，在需求评审及开发过程中，只需要前端开发同学参加即可。前端开发同学与业务产品沟通业务逻辑，在api市场或服务文档查询相应的服务能力，完成业务开发。同时对于团队逐步开展业务中台化、前端组件化大有助益，整个架构对于丰富多变的业务需求的响应更敏捷。&lt;/p&gt;
&lt;p&gt;2&lt;strong&gt;. 渲染层对后端的服务进行聚合，减少页面请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285222648-05.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;不管是H5网页还是小程序页面，均只需跟中间层打交道，前端开发人员根据业务的诉求，自行对接口进行聚合，端上只需要1个请求就可以开始渲染页面。接口聚合之前，产品详情页面的显示需要请求5个接口，平均的接口请求耗时为120ms左右，聚合后，通过中间层来请求5个内网接口，避免端与服务的多次连接耗时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 中间层对数据进行加工，大大减少小程序端的逻辑代码量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前在小程序端的数据整合代码，有些复杂的逻辑，可以交给中间层处理，这些代码的节省对于业务持续增长时会越来越体现出价值。以年金产品详情页为例，数据在中间层聚合能够节省10KB的体积。&lt;/p&gt;
&lt;p&gt;中间层的引入是对生产力的进一步解放，但基于一个巨型 app 的 node 中间层，在后期的运维中也暴露出一些问题。中间层的应用部署在2台CVM机器上，有其先天的一些不足：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 应对尖峰流量的冲击能力差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微保经常会有一些运营和投放需求，这些事件都会导致瞬间的大流量打入，CVM的扩容相对滞后。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. App级别的部署与发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中间层不断积累业务代码，整个应用线性增长，每次部署与发布都是巨石应用的发布，部署效率低、风险高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 前端开发人员在开发、测试环境中需要自己在机器上查阅日志和服务操作，提高了普及的门槛。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;微保架构-v3&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E6%9E%B6%E6%9E%84-v3&quot; aria-label=&quot;微保架构 v3 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保架构 v3&lt;/h2&gt;
&lt;p&gt;基于上面的这些限制，团队开始关注新的技术，加州大学伯克利分校计算机科学 Riselab 团队的实验室研究室提出：Serverless 是云计算的下一个浪潮。国内各大厂商也都开始布局 Serverless ，腾讯云 Serverless 团队是国内比较早在这方面进行部署的团队，技术已经非常成熟，在新东方、蘑菇街、哔哩哔哩、TP-link 等数百家企业成功落地实践。&lt;/p&gt;
&lt;p&gt;通过调研了解到腾讯云 Serverless 云函数的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强大的扩所容能力，特别适合应对流量洪峰，且性能稳定。&lt;/li&gt;
&lt;li&gt;每个函数都是单独运行、单独部署、单独伸缩的，用户上传代码后即可自动部署，提升了独立开发和迭代的速度。&lt;/li&gt;
&lt;li&gt;云函数提供精细的日志记录，可方便地查看函数的运行状况，并对代码进行调试、测试和审计；支持相关的监控指标上报，能快速了解函数的整体运行概况，也可自定义云函数的监控指标。&lt;/li&gt;
&lt;li&gt;精确到 1ms 计费规则，只对正在运行的函数计费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，基本解决了架构 v2 中面临的问题，可以说是省时省力。经过团队整体评估，我们决定使用腾讯云 Serverless 云函数进行架构的进一步调整。调整后的角色合作流程示意图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285231734-06.jpg&quot;/&gt;            &lt;/p&gt;
&lt;p&gt;C 端的请求发至云函数 API 网关，网关转发请求至相应的云函数实例，云函数再向后请求服务的网关。整个链条上最大的变化是将云函数取代了node app，成为中间层的技术形态。&lt;/p&gt;
&lt;p&gt;使用云函数替换掉 node app，背后的考量有以下几方面，也基本是针对 node app 实践中遇到的一些问题去加以解决：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 自动扩缩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发者不需要专门去配置，云函数可以自己根据请求量在函数层级水平扩展，正常情况下，一个空的云函数（运行时间 50 ms），300 个并发，压测可以达到 6000+ 的 qps，应对日常的高并发需求基本没什么问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 函数级别的开发与部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个云函数对应一个 gitlab 的项目，函数开发与发布都是围绕单个项目进行 CI/CD，高效、安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 按需收费&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于金融模式下的流量特点，大部分情况下请求量较少，云函数的使用可以避免稳定的资源投入，空闲情况下费用大大减少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 简单的运维管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发者不需要在服务器上自己维护服务和查阅日志，通过云函数的配套工具轻松管理函数、查阅日志，也可以根据自己的诉求设置告警机制。&lt;/p&gt;
&lt;h2 id=&quot;微保使用-serverless-技术的总体架构&quot;&gt;&lt;a href=&quot;#%E5%BE%AE%E4%BF%9D%E4%BD%BF%E7%94%A8-serverless-%E6%8A%80%E6%9C%AF%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84&quot; aria-label=&quot;微保使用 serverless 技术的总体架构 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;微保使用 Serverless 技术的总体架构&lt;/h2&gt;
&lt;p&gt;微保每一次架构的调整，都致力于让各种研发角色的职责更为单一、内聚，角色间更加解耦。但这种调整也需要有配套的工具，其中的 trade-off 需要根据短期成本和长期利益来衡量。腾讯云Servelrss 云函数很好的支持了本次架构的重新调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.serverlesscloud.cn/2020928/1601285234546-07.jpg&quot;/&gt;            &lt;/p&gt;
&lt;h2 id=&quot;落地中的问题和解决办法&quot;&gt;&lt;a href=&quot;#%E8%90%BD%E5%9C%B0%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95&quot; aria-label=&quot;落地中的问题和解决办法 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;落地中的问题和解决办法&lt;/h2&gt;
&lt;p&gt;使用腾讯云 Serverless 过程中也不免遇到问题。&lt;/p&gt;
&lt;p&gt;例如，公司有自建 es 集群，所有日志都会放在es里面，但是云函数的日志无法直接放入我们es里面，只能存入腾讯云的 cls，这个对于我们后期日志分析， 告警都不好处理。通过调研腾讯云cls， 发现里面有个挺好用的功能，可以日志投递到 kafka，在通过监听 kafka，我们将日志成功存入我们的 es, 且时延保证在秒级。&lt;/p&gt;
&lt;p&gt;另一个日志规范问题, 日志的规范关乎后期日志分析、告警， 但是实际处理中发现日志的元数据信息较少， 比如我们有版本 tag，云函数绑定了 cmdb 相关信息，这些都希望在日志中打印出来, 后面我们发现云函数有个别名字段。我们在云函数中发现一个别名字段, 通过扩展了一下这个字段，填入了更多信息， 例如版本、cmdb 相关信息，这样在日志里面相关信息也会体现出来。&lt;/p&gt;
&lt;p&gt;关于使用腾讯云 Serverless 技术在风控和推荐算法应用的介绍会在之后的文章为大家详细展开，敬请期待！&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;
&lt;p id=&quot;scf-deploy-iframe-or-md&quot;/&gt;
&lt;hr/&gt;
&lt;p&gt;欢迎访问：&lt;a href=&quot;https://serverlesscloud.cn/&quot;&gt;Serverless 中文网&lt;/a&gt;，您可以在 &lt;a href=&quot;https://serverlesscloud.cn/best-practice&quot;&gt;最佳实践&lt;/a&gt; 里体验更多关于 Serverless 应用的开发！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>