<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>781bc63996c4da2069d962e4b5dfced5</guid>
<title>95% 的算法都是基于这 6 种算法思想</title>
<link>https://toutiao.io/k/pbwl6pl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjUxOTM2Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmTRcFWKB5pLtwz9auwyvjn6nhiaSydyGVuAfOfGmdpTBaqLJyLHVwDgXKNicS1VHhJSBADHCk2dib4Q/0?wx_fmt=png&quot; data-nickname=&quot;三分钟学前端&quot; data-alias=&quot;&quot; data-signature=&quot;每日三分钟，学习一个前端小 Tip！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;三分钟学前端&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;交流&lt;/span&gt;&lt;span&gt;，加入前端编程面试算法每日一题群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx27c980b913cbfb08&quot; data-miniprogram-path=&quot;pages/index/index&quot; data-miniprogram-nickname=&quot;高级前端面试&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;面试官也在看的前端面试资料&lt;/a&gt;&lt;/p&gt;&lt;p&gt;算法思想是解决问题的核心，万丈高楼起于平地，在算法中也是如此，95% 的算法都是基于这 6 种算法思想，结下了介绍一下这 6 种算法思想，帮助你理解及解决各种算法问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1 递归算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;1.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;递归算法是一种直接或者间接调用自身函数或者方法的算法。&lt;/p&gt;&lt;p&gt;递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：实现简单易上手&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：递归算法对常用的算法如普通循环等，运行效率较低；并且在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归太深，容易发生栈溢出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;1.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;递归算法一般用于解决三类问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据的定义是按递归定义的。（斐波那契数列）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问题解法按递归算法实现。（回溯）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据的结构形式是按递归定义的。（树的遍历，图的搜索）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;递归的解题策略：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：明确你这个函数的输入输出，先不管函数里面的代码什么，而是要先明白，你这个函数的输入是什么，输出为何什么，功能是什么，要完成什么样的一件事。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：寻找递归结束条件，我们需要找出什么时候递归结束，之后直接把结果返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：明确递归关系式，怎么通过各种递归调用来组合解决当前问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;1.3 使用递归算法求解的一些经典问题&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;DOM树为例&lt;/h4&gt;&lt;p&gt;下面以以 DOM 🌲为例，实现一个 &lt;code&gt;document.getElementById&lt;/code&gt; 功能&lt;/p&gt;&lt;p&gt;由于DOM是一棵树，而树的定义本身就是用的递归定义，所以用递归的方法处理树，会非常地简单自然。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：明确你这个函数的输入输出&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从 DOM 🌲根节点一层层往下递归，判断当前节点的 id 是否是我们要寻找的 &lt;code&gt;id=&#x27;d-cal&#x27;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输入：DOM 🌲根节点 &lt;code&gt;document&lt;/code&gt; ，我们要寻找的 &lt;code&gt;id=&#x27;d-cal&#x27;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出：返回满足 &lt;code&gt;id=&#x27;sisteran&#x27;&lt;/code&gt; 的子结点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第二步：寻找递归结束条件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从document开始往下找，对所有子结点递归查找他们的子结点，一层一层地往下查找：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前结点的 id 符合查找条件，则返回当前结点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果已经到了叶子结点了还没有找到，则返回 null&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 当前结点不存在，已经到了叶子结点了还没有找到，返回 null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 当前结点的 id 符合查找条件，返回当前结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：明确递归关系式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当前结点的 id 不符合查找条件，递归查找它的每一个子结点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 当前结点不存在，已经到了叶子结点了还没有找到，返回 null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 当前结点的 id 符合查找条件，返回当前结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node&lt;br/&gt;    &lt;span&gt;// 前结点的 id 不符合查找条件，继续查找它的每一个子结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; node.childNodes.length; i++){&lt;br/&gt;        &lt;span&gt;// 递归查找它的每一个子结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; found = getElementById(node.childNodes[i], id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(found) &lt;span&gt;return&lt;/span&gt; found;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就这样，我们的一个 &lt;code&gt;document.getElementById&lt;/code&gt; 功能已经实现了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getElementById&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!node) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; node.childNodes.length; i++){&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; found = getElementById(node.childNodes[i], id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(found) &lt;span&gt;return&lt;/span&gt; found;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;getElementById(&lt;span&gt;document&lt;/span&gt;, &lt;span&gt;&quot;d-cal&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后在控制台验证一下，执行结果如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.15047021943573669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjAl3KN8xL01fGUYkLliaQeV28Qf6gficmIPbTGPuBeXEgdiaRR5N9W1Qjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;319&quot;/&gt;&lt;/figure&gt;&lt;p&gt;使用递归的优点是代码简单易懂，缺点是效率比不上非递归的实现。Chrome浏览器的查DOM是使用非递归实现。非递归要怎么实现呢？&lt;/p&gt;&lt;p&gt;如下代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getByElementId&lt;/span&gt;(&lt;span&gt;node, id&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//遍历所有的Node&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(node){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(node.id === id) &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;        node = nextElement(node);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还是依次遍历所有的 &lt;code&gt;DOM&lt;/code&gt; 结点，只是这一次改成一个 &lt;code&gt;while&lt;/code&gt; 循环，函数 &lt;code&gt;nextElement&lt;/code&gt; 负责找到下一个结点。所以关键在于这个 &lt;code&gt;nextElement&lt;/code&gt; 如何实现非递归查找结点功能：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 深度遍历&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;nextElement&lt;/span&gt;(&lt;span&gt;node&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 先判断是否有子结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.children.length) {&lt;br/&gt;        &lt;span&gt;// 有则返回第一个子结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node.children[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 再判断是否有相邻结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(node.nextElementSibling){&lt;br/&gt;        &lt;span&gt;// 有则返回它的下一个相邻结点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; node.nextElementSibling;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 否则，往上返回它的父结点的下一个相邻元素，相当于上面递归实现里面的for循环的i加1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(node.parentNode){&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(node.parentNode.nextElementSibling) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; node.parentNode.nextElementSibling;&lt;br/&gt;        }&lt;br/&gt;        node = node.parentNode;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在控制台里面运行这段代码，同样也可以正确地输出结果。不管是非递归还是递归，它们都是深度优先遍历，这个过程如下图所示。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjd6ic73IhdCfhuBp5nM2vCQdkT2D3D8h4JrG1Kib0APPJviaApib8ZsAkpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上 getElementById 浏览器是用的一个哈希 map 存储的，根据 id 直接映射到 DOM 结点，而 getElementsByClassName 就是用的这样的非递归查找。&lt;/p&gt;&lt;p&gt;参考：我接触过的前端数据结构与算法&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2 分治算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;2.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在计算机科学中，分治算法是一个很重要的算法，快速排序、归并排序等都是基于分治策略进行实现的，所以，建议理解掌握它。&lt;/p&gt;&lt;p&gt;分治，顾名思义，就是 &lt;strong&gt;分而治之&lt;/strong&gt; ，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为阿子问题解的合并。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;当出现满足以下条件的问题，可以尝试只用分治策略进行求解：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原始问题可以分成多个相似的子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子问题可以很简单的求解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;原始问题的解是子问题解的合并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;各个子问题是相互独立的，不包含相同的子问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;分治的解题策略：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：解决，解决各个子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步：合并，将各个子问题的解合并为原问题的解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;2.3 &lt;strong&gt;使用分治法求解的一些经典问题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二分查找&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;归并排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;快速排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;汉诺塔问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 时间分片&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;二分查找&lt;/h4&gt;&lt;p&gt;也称折半查找算法，它是一种简单易懂的快速查找算法。例如我随机写0-100之间的一个数字，让你猜我写的是什么？你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：分解&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每次猜拳都把上一次的结果分出大的一组和小的一组，两组相互独立&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// low、mid、high将数组分成两组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        elem = items[mid]&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第二步：解决子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;查找数与中间数对比&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比中间数低，则去中间数左边的子数组中寻找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比中间数高，则去中间数右边的子数组中寻找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;相等则返回查找成功&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) { &lt;span&gt;// 比中间数高&lt;/span&gt;&lt;br/&gt;  low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) { &lt;span&gt;// 比中间数低&lt;/span&gt;&lt;br/&gt;  high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;// 相等&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：合并&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid, elem&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        elem = items[mid]&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) {&lt;br/&gt;            low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) {&lt;br/&gt;            high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，二分法只能应用于数组有序的情况，如果数组无序，二分查找就不能起作用了&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;binarySearch&lt;/span&gt;(&lt;span&gt;items, item&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 快排&lt;/span&gt;&lt;br/&gt;    quickSort(items)&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; low = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        high = items.length - &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        mid, elem&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low &amp;lt;= high) {&lt;br/&gt;        mid = &lt;span&gt;Math&lt;/span&gt;.floor((low+high)/&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        elem = items[mid]&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(elem &amp;lt; item) {&lt;br/&gt;            low = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(elem &amp;gt; item) {&lt;br/&gt;            high = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; mid&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; arr = [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;binarySearch(arr, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;binarySearch(arr, &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// -1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试成功&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3 贪心算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;3.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。&lt;/p&gt;&lt;p&gt;某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在日常生活中，我们使用到贪心算法的时候还是挺多的，例如：&lt;/p&gt;&lt;p&gt;从100章面值不等的钞票中，抽出 10 张，怎样才能获得最多的价值？&lt;/p&gt;&lt;p&gt;我们只需要每次都选择剩下的钞票中最大的面值，最后一定拿到的就是最优解，这就是使用的贪心算法，并且最后得到了整体最优解。&lt;/p&gt;&lt;p&gt;但是，我们任然需要明确的是，期望通过局部的最优选择获得整体的最优选择，仅仅是期望而已，也可能最终得到的结果并不一定不能是整体最优解。&lt;/p&gt;&lt;p&gt;例如：求取A到G最短路径：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45131086142322097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj8nz3CUJ0yel7n0cL6hl2u6HuN8JmQK2xicriaVlSRTibsv2c7YRicN3BSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根据贪心算法总是选择当前最优选择，所以它首先选择的路径是 AB，然后 BE、EG，所得到的路径总长为 1 + 5 + 4 = 10，然而这并不是最短路径，最短路径为 A-&amp;gt;C-&amp;gt;G : 2 + 2 = 4，所以说，贪心算法得到得并不一定是最优解。&lt;/p&gt;&lt;p&gt;那么一般在什么时候可以尝试选择使用贪心算法喃？&lt;/p&gt;&lt;p&gt;当满足一下条件时，可以使用：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原问题复杂度过高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;求全局最优解的数学模型难以建立或计算量过大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有太大必要一定要求出全局最优解，“比较优”就可以&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果使用贪心算法求最优解，可以按照以下 &lt;strong&gt;步骤求解&lt;/strong&gt; ：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，我们需要明确什么是最优解（期望）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，把问题分成多个步骤，每一步都需要满足：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;- 不可取消：选择一旦做出，在后面遇到任何情况都不可取消&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，叠加所有步骤的最优解，就是全局最优解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;3.3 经典案例：活动选择问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用贪心算法求解的经典问题有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最小生成树算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单源最短路径的 Dijkstra 算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Huffman 压缩编码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;背包问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;活动选择问题等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中活动选择问题是最简单的，这里详细介绍这个。&lt;/p&gt;&lt;p&gt;活动选择问题是《算法导论》上的例子，也是一个非常经典的问题。有 n 个活动（a1,a2,…,an）需要使用同一个资源（例如教室），资源在某个时刻只能供一个活动使用。每个活动 ai 都有一个开始时间 si 和结束时间 fi 。一旦被选择后，活动 ai 就占据半开时间区间 [si,fi) 。如果 [si,fi) 和 [sj,fj) 互不重叠，ai 和 aj 两个活动就可以被安排在这一天。&lt;/p&gt;&lt;p&gt;该问题就是要安排这些活动，使得尽量多的活动能不冲突的举行。例如下图所示的活动集合S，其中各项活动按照结束时间单调递增排序。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjE2QHwZsdIbcH8Qqib0bpI6iciaCaRcCNnWxZJVmibzkVLnhdN8RHsrjvHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;p&gt;共有 7 个活动，它们在 18 个小时内需要占用的时间如上图，如何选择活动，能让这间教室利用率最高喃（能够举行更多的活动）？&lt;/p&gt;&lt;p&gt;贪心算法对这种问题的解决很简单的，它开始时刻开始选择，每次选择开始时间与与已选择活动不冲突的，结束时间又比较靠前的活动，这样会让剩下的时间区间更长。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj5rHSHmzhnYj2X9wh1B1OE9chyvTIUib10QZxyHe51fEeeFqsx6Ng7Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先 a1 活动的结束时间最早，选择 a1 活动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;a1 结束后，a2 有时间冲突，不可选择，a3、a4 都可选择，但 a4 结束时间最早，选择 a4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依次选择时间没有冲突的，又结束时间最早的活动&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最终选择活动为 a1，a4，a5，a7。为最优解。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4 回溯算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;4.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.3 使用回溯算法的经典案例&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;深度优先搜索&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;0-1背包问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;正则表达式匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;八皇后&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数独&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全排列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等，深度优先搜索我们在图那一章已经介绍过，这里以正则表达式匹配为例，介绍一下&lt;/p&gt;&lt;h4&gt;正则表达式匹配&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;var string = &quot;abbc&quot;&lt;/p&gt;&lt;p&gt;var regex = /ab{1,3}c/&lt;/p&gt;&lt;p&gt;console.log( string.match(regex) )&lt;/p&gt;&lt;p&gt;// [&quot;abbc&quot;, index: 0, input: &quot;abbc&quot;, groups: undefined]&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它的匹配过程：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8680445151033387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjc1PczkYecKZVGhyibXe5pHNaexicB9XQx65zwicysE4XGFibQaBXYxZFoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在第 5 步匹配失败，此时 &lt;code&gt;b{1,3}&lt;/code&gt; 已经匹配到了两个 &lt;code&gt;b&lt;/code&gt; 正在尝试第三个 &lt;code&gt;b&lt;/code&gt; ，结果发现接下来是 &lt;code&gt;c&lt;/code&gt; 。此时就需要回溯到上一步， &lt;code&gt;b{1,3}&lt;/code&gt; 匹配完毕（匹配到了 &lt;code&gt;bb&lt;/code&gt; ），然后再匹配 &lt;code&gt;c&lt;/code&gt; ，匹配到了 &lt;code&gt;c&lt;/code&gt; 匹配结束。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;5 动态规划&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;5.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。&lt;/p&gt;&lt;p&gt;所以，动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5.2 适用场景&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;动态规划适用于求解最优解问题，比如，从面额不定的100个硬币中任意选取多个凑成10元，求怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够了10元。这就是一个典型的动态规划问题。它可以分成一个个子问题（每次选取硬币），每个子问题又有公共的子子问题（选取硬币），子问题之间相互关联（已选取的硬币总金额不能超过10元），边界条件就是最终选取的硬币总金额为 10 元。&lt;/p&gt;&lt;p&gt;针对上例，也许你也可以说，我们可以使用回溯算法，不断的去试探，但回溯算法是使用与求解广度的解（满足要求的解），如果是用回溯算法，我们需要尝试去找所有满足条件的解，然后找到最优解，时间复杂度为 O(2^n^) ，这性能是相当差的。大多数适用于动态规划的问题，都可以使用回溯算法，只是使用回溯算法的时间复杂度比较高而已。&lt;/p&gt;&lt;p&gt;最后，总结一下，我们使用动态规划求解问题时，需要遵循以下几个重要步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现需要反复执行解决的子子问题部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;识别并求解出边界条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;5.3 使用动态规划求解的一些经典问题&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里以最长公共子序列为例。&lt;/p&gt;&lt;h4&gt;爬楼梯问题&lt;/h4&gt;&lt;p&gt;这里以动态规划经典问题爬楼梯问题为例，介绍求解动态规划问题的步骤。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果用 &lt;code&gt;dp[n]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数等于第 &lt;code&gt;n-1&lt;/code&gt; 级台阶的方案数加上第 &lt;code&gt;n-2&lt;/code&gt; 级台阶的方案数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = dp[n−&lt;span&gt;1&lt;/span&gt;] + dp[n−&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 第 1 级也是 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化空间复杂度：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = &lt;span&gt;1&lt;/span&gt;, n1 = &lt;span&gt;1&lt;/span&gt;, n2 = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        res = n1 + n2&lt;br/&gt;        n1 = n2&lt;br/&gt;        n2 = res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;h2&gt;&lt;span&gt;6 枚举算法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;6.1 算法策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;6.2 解题思路&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确定枚举对象、枚举范围和判定条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逐一列举可能的解，验证每个解是否是问题的解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;7 刷题&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;7.1 爬楼梯问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 给定 n 是一个正整数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入： &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;输出： &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;解释： 有两种方法可以爬到楼顶。&lt;br/&gt;&lt;span&gt;1.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; 阶&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入： &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;输出： &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;解释： 有三种方法可以爬到楼顶。&lt;br/&gt;&lt;span&gt;1.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;2.&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 阶 + &lt;span&gt;2&lt;/span&gt; 阶&lt;br/&gt;&lt;span&gt;3.&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; 阶 + &lt;span&gt;1&lt;/span&gt; 阶&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;动态规划（Dynamic Programming，DP）是一种将复杂问题分解成小问题求解的策略，但与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们使用动态规划求解问题时，需要遵循以下几个重要步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;定义子问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现需要反复执行解决的子子问题部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;识别并求解出边界条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果用 &lt;code&gt;dp[n]&lt;/code&gt; 表示第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 &lt;code&gt;n&lt;/code&gt; 级台阶的方案数等于第 &lt;code&gt;n-1&lt;/code&gt; 级台阶的方案数加上第 &lt;code&gt;n-2&lt;/code&gt; 级台阶的方案数&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = dp[n−&lt;span&gt;1&lt;/span&gt;] + dp[n−&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 第 1 级也是 1 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        dp[i] = dp[i - &lt;span&gt;1&lt;/span&gt;] + dp[i - &lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化空间复杂度：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; climbStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;n&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = &lt;span&gt;1&lt;/span&gt;, n1 = &lt;span&gt;1&lt;/span&gt;, n2 = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= n; i++) {&lt;br/&gt;        res = n1 + n2&lt;br/&gt;        n1 = n2&lt;br/&gt;        n2 = res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间复杂度：O(1)&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.2 使用最小花费爬楼梯&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数组的每个索引作为一个阶梯，第 &lt;code&gt;i&lt;/code&gt; 个阶梯对应着一个非负数的体力花费值 &lt;code&gt;cost[i]&lt;/code&gt; (索引从0开始)。&lt;/p&gt;&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。&lt;/p&gt;&lt;p&gt;您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: cost = [&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;15&lt;/span&gt;&lt;br/&gt;解释: 最低花费是从cost[&lt;span&gt;1&lt;/span&gt;]开始，然后走两步即可到阶梯顶，一共花费&lt;span&gt;15&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: cost = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;解释: 最低花费方式是从cost[&lt;span&gt;0&lt;/span&gt;]开始，逐个经过那些&lt;span&gt;1&lt;/span&gt;，跳过cost[&lt;span&gt;3&lt;/span&gt;]，一共花费&lt;span&gt;6&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cost&lt;/code&gt; 的长度将会在 &lt;code&gt;[2, 1000]&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一个 &lt;code&gt;cost[i]&lt;/code&gt; 将会是一个Integer类型，范围为 &lt;code&gt;[0, 999]&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;本题注意理解题意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第 &lt;code&gt;i&lt;/code&gt; 级台阶是第 &lt;code&gt;i-1&lt;/code&gt; 级台阶的阶梯顶部。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶花费 &lt;code&gt;cost[i]&lt;/code&gt; ，直接迈一大步跨过而不踏上去则不用花费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;楼梯顶部在数组之外，如果数组长度为 &lt;code&gt;len&lt;/code&gt;，那么楼顶就在下标为 &lt;code&gt;len&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶的体力消耗为到达前两个阶梯的最小体力消耗加上本层体力消耗：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最后迈 1 步踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶：&lt;code&gt;dp[i-1] + cost[i]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后迈 1 步踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶：&lt;code&gt;dp[i-2] + cost[i]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;所以踏上第 &lt;code&gt;i&lt;/code&gt; 级台阶的最小花费为：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i] = min(dp[i&lt;span&gt;-2&lt;/span&gt;], dp[i&lt;span&gt;-1&lt;/span&gt;]) + cost[i]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 第 0 级 cost[0] 种方案 &lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;0&lt;/span&gt;] = cost[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;// 第 1 级，有两种情况&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1：分别踏上第0级与第1级台阶，花费cost[0] + cost[1]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2：直接从地面开始迈两步直接踏上第1级台阶，花费cost[1]&lt;/span&gt;&lt;br/&gt;dp[&lt;span&gt;1&lt;/span&gt;] = min(cost[&lt;span&gt;0&lt;/span&gt;] + cost[&lt;span&gt;1&lt;/span&gt;], cost[&lt;span&gt;1&lt;/span&gt;]) = cost[&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; minCostClimbingStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;cost&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    cost.push(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dp = [], n = cost.length&lt;br/&gt;    dp[&lt;span&gt;0&lt;/span&gt;] = cost[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;    dp[&lt;span&gt;1&lt;/span&gt;] = cost[&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; n; i++){&lt;br/&gt;        dp[i] = &lt;span&gt;Math&lt;/span&gt;.min(dp[i&lt;span&gt;-2&lt;/span&gt;] , dp[i&lt;span&gt;-1&lt;/span&gt;]) + cost[i]&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dp[n&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优化：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; minCostClimbingStairs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;cost&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; n = cost.length,&lt;br/&gt;        n1 = cost[&lt;span&gt;0&lt;/span&gt;],&lt;br/&gt;        n2 = cost[&lt;span&gt;1&lt;/span&gt;] &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;;i &amp;lt; n;i++){&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; tmp = n2&lt;br/&gt;        n2 = &lt;span&gt;Math&lt;/span&gt;.min(n1,n2)+cost[i]&lt;br/&gt;        n1 = tmp&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.min(n1,n2)&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.3 最大子序和&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;-2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;解释: 连续子数组 [&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] 的和最大，为 &lt;span&gt;6&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;动态规划是将整个数组归纳考虑，假设我们已经知道了以第 &lt;code&gt;i-1&lt;/code&gt; 个数结尾的连续子数组的最大和 &lt;code&gt;dp[i-1]&lt;/code&gt;，显然以第&lt;code&gt;i&lt;/code&gt;个数结尾的连续子数组的最大和的可能取值要么为 &lt;code&gt;dp[i-1]+nums[i]&lt;/code&gt;，要么就是 &lt;code&gt;nums[i]&lt;/code&gt; 单独成一组，也就是 &lt;code&gt;nums[i]&lt;/code&gt; ，在这两个数中我们取最大值&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[n] = &lt;span&gt;Math&lt;/span&gt;.max(dp[n−&lt;span&gt;1&lt;/span&gt;]+nums[n], nums[n])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[&lt;span&gt;0&lt;/span&gt;]=nums[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为我们在计算 &lt;code&gt;dp[i]&lt;/code&gt; 的时候，只关心 &lt;code&gt;dp[i-1]&lt;/code&gt; 与 &lt;code&gt;nums[i]&lt;/code&gt;，因此不用把整个 &lt;code&gt;dp&lt;/code&gt; 数组保存下来，只需设置一个 &lt;code&gt;pre&lt;/code&gt; 保存 &lt;code&gt;dp[i-1]&lt;/code&gt; 就好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxSubArray = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = nums[&lt;span&gt;0&lt;/span&gt;], pre = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(pre &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            pre += num&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            pre = num&lt;br/&gt;        }&lt;br/&gt;        max = &lt;span&gt;Math&lt;/span&gt;.max(max, pre)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.4 买卖股票的最佳时机&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;2&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天（股票价格 = &lt;span&gt;6&lt;/span&gt;）的时候卖出，最大利润 = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;5&lt;/span&gt; 。&lt;br/&gt;     注意利润不能是 &lt;span&gt;7&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;6&lt;/span&gt;, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 &lt;span&gt;0&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第一步：定义子问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;动态规划是将整个数组归纳考虑，假设我们已经知道了 &lt;code&gt;i-1&lt;/code&gt; 个股票的最大利润为 &lt;code&gt;dp[i-1]&lt;/code&gt;，显然 &lt;code&gt;i&lt;/code&gt; 个连续股票的最大利润为 &lt;code&gt;dp[i-1]&lt;/code&gt; ，要么就是就是 &lt;code&gt;prices[i] - minprice&lt;/code&gt; （ &lt;code&gt;minprice&lt;/code&gt; 为前 &lt;code&gt;i-1&lt;/code&gt; 支股票的最小值 ），在这两个数中我们取最大值&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二步：实现需要反复执行解决的子子问题部分&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i] = &lt;span&gt;Math&lt;/span&gt;.max(dp[i−&lt;span&gt;1&lt;/span&gt;], prices[i] - minprice)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三步：识别并求解出边界条件&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后一步：把尾码翻译成代码，处理一些边界情况&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因为我们在计算 &lt;code&gt;dp[i]&lt;/code&gt; 的时候，只关心 &lt;code&gt;dp[i-1]&lt;/code&gt; 与 &lt;code&gt;prices[i]&lt;/code&gt;，因此不用把整个 &lt;code&gt;dp&lt;/code&gt; 数组保存下来，只需设置一个 &lt;code&gt;max&lt;/code&gt; 保存 &lt;code&gt;dp[i-1]&lt;/code&gt; 就好了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxProfit = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;prices&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = &lt;span&gt;0&lt;/span&gt;, minprice = prices[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; prices.length; i++) {&lt;br/&gt;        minprice = &lt;span&gt;Math&lt;/span&gt;.min(prices[i], minprice)&lt;br/&gt;        max = &lt;span&gt;Math&lt;/span&gt;.max(max, prices[i] - minprice)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.5 回文子串&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;br/&gt;输出：3&lt;br/&gt;解释：三个回文子串: &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：&lt;span&gt;&quot;aaa&quot;&lt;/span&gt;&lt;br/&gt;输出：6&lt;br/&gt;解释：6个回文子串: &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;aa&quot;&lt;/span&gt;, &lt;span&gt;&quot;aa&quot;&lt;/span&gt;, &lt;span&gt;&quot;aaa&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法一：暴力法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; s.length; i++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = i; j &amp;lt; s.length; j++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isPalindrome(s.substring(i, j + &lt;span&gt;1&lt;/span&gt;))) {&lt;br/&gt;        count++&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; isPalindrome = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = s.length - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (i &amp;lt; j) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s[i] != s[j]) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    i++&lt;br/&gt;    j--&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法二：动态规划&lt;/h4&gt;&lt;p&gt;一个字符串是回文串，它的首尾字符相同，且剩余子串也是一个回文串。其中，剩余子串是否为回文串，就是规模小一点的子问题，它的结果影响大问题的结果。&lt;/p&gt;&lt;p&gt;我们怎么去描述子问题呢？&lt;/p&gt;&lt;p&gt;显然，一个子串由两端的 &lt;code&gt;i&lt;/code&gt; 、&lt;code&gt;j&lt;/code&gt; 指针确定，就是描述子问题的变量，子串 &lt;code&gt;s[i...j]&lt;/code&gt; （ &lt;code&gt;dp[i][j]&lt;/code&gt; ） 是否是回文串，就是子问题。&lt;/p&gt;&lt;p&gt;我们用二维数组记录计算过的子问题的结果，从base case出发，像填表一样递推出每个子问题的解。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    j&lt;br/&gt;    a  a  b  a&lt;br/&gt;i a ✅&lt;br/&gt;  a    ✅  &lt;br/&gt;  b       ✅&lt;br/&gt;  a          ✅&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意： &lt;code&gt;i&amp;lt;=j&lt;/code&gt; ，只需用半张表，竖向扫描&lt;/p&gt;&lt;p&gt;所以：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;i === j：dp[i][j]=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;j - i == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] == s[j]：dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;j - i &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] == s[j] &amp;amp;&amp;amp; dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]：dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;s[i] == s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]): dp[i][j]=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;否则为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = s.length&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++) {&lt;br/&gt;    dp[i] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len).fill(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (s[i] == s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;])) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        count++&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dp[i][j] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码实现（优化）：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;把上图的表格竖向一列看作一维数组，还是竖向扫描，此时仅仅需要将 &lt;code&gt;dp&lt;/code&gt; 定义为一维数组即可&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; countSubstrings = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = s.length&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(len)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (s[i] === s[j] &amp;amp;&amp;amp; (j - i &amp;lt;= &lt;span&gt;1&lt;/span&gt; || dp[i + &lt;span&gt;1&lt;/span&gt;])) {&lt;br/&gt;        dp[i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        count++&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dp[i] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.6 最长回文子串&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: &lt;span&gt;&quot;babad&quot;&lt;/span&gt;&lt;br/&gt;输出: &lt;span&gt;&quot;bab&quot;&lt;/span&gt;&lt;br/&gt;注意: &lt;span&gt;&quot;aba&quot;&lt;/span&gt; 也是一个有效答案。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: &lt;span&gt;&quot;cbbd&quot;&lt;/span&gt;&lt;br/&gt;输出: &lt;span&gt;&quot;bb&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：动态规划&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第 1 步：定义状态&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; 表示子串 &lt;code&gt;s[i..j]&lt;/code&gt; 是否为回文子串，这里子串 &lt;code&gt;s[i..j]&lt;/code&gt; 定义为左闭右闭区间，可以取到 &lt;code&gt;s[i]&lt;/code&gt; 和 &lt;code&gt;s[j]&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第 2 步：思考状态转移方程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于一个子串而言，如果它是回文串，那么在它的首尾增加一个相同字符，它仍然是个回文串&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i][j] = (s[i] === s[j]) &amp;amp;&amp;amp; dp[i+&lt;span&gt;1&lt;/span&gt;][j&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第 3 步：初始状态&lt;/strong&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dp[i][i] = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 单个字符是回文串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(s[i] === s[i+&lt;span&gt;1&lt;/span&gt;]) dp[i][i+&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 连续两个相同字符是回文串 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; longestPalindrome = &lt;span&gt;(&lt;span&gt;s&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (s.length &amp;lt; &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;  &lt;span&gt;// res: 最长回文子串&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; res = s[&lt;span&gt;0&lt;/span&gt;], dp = []&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; s.length; i++) {&lt;br/&gt;    dp[i][i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; s.length; j++) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; j; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (j - i === &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; s[i] === s[j]) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s[i] === s[j] &amp;amp;&amp;amp; dp[i + &lt;span&gt;1&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]) {&lt;br/&gt;        dp[i][j] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      }   &lt;br/&gt;      &lt;span&gt;// 获取当前最长回文子串&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (dp[i][j] &amp;amp;&amp;amp; j - i + &lt;span&gt;1&lt;/span&gt; &amp;gt; res.length) {&lt;br/&gt;        res = s.substring(i, j + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;时间复杂度：O(n^2^)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空间复杂度：O(n^2^)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.7 最小路径和&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个包含非负整数的 &lt;code&gt;m x n&lt;/code&gt; 网格 &lt;code&gt;grid&lt;/code&gt; ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjD5nBiaBYpbXPy8fhkwdKOYfxkKTjcR6mlzWHVKM8aTlfwBbGH9coOLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;242&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：grid = [[1,3,1],[1,5,1],[4,2,1]]&lt;br/&gt;输出：7&lt;br/&gt;解释：因为路径 1→3→1→1→1 的总和最小。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：grid = [[1,2,3],[4,5,6]]&lt;br/&gt;输出：12&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;m == grid.length&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;n == grid[i].length&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 100&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、DP方程&lt;/strong&gt; 当前项最小路径和 = 当前项值 + 上项或左项中的最小值 &lt;code&gt;grid[i][j] += Math.min( grid[i - 1][j], grid[i][j - 1] )&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、边界处理&lt;/strong&gt; grid的第一行与第一列 分别没有上项与左项 故单独处理计算起项最小路径和 计算第一行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++) grid[&lt;span&gt;0&lt;/span&gt;][j] += grid[&lt;span&gt;0&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;计算第一列：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++) grid[i][&lt;span&gt;0&lt;/span&gt;] += grid[i - &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3、代码实现&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; minPathSum = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;grid&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; row = grid.length, col = grid[&lt;span&gt;0&lt;/span&gt;].length&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// calc boundary&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++)&lt;br/&gt;        &lt;span&gt;// calc first col&lt;/span&gt;&lt;br/&gt;        grid[i][&lt;span&gt;0&lt;/span&gt;] += grid[i - &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++)&lt;br/&gt;        &lt;span&gt;// calc first row&lt;/span&gt;&lt;br/&gt;        grid[&lt;span&gt;0&lt;/span&gt;][j] += grid[&lt;span&gt;0&lt;/span&gt;][j - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; row; i++)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; col; j++)&lt;br/&gt;            grid[i][j] += &lt;span&gt;Math&lt;/span&gt;.min(grid[i - &lt;span&gt;1&lt;/span&gt;][j], grid[i][j - &lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; grid[row - &lt;span&gt;1&lt;/span&gt;][col - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.8 买卖股票的最佳时机 II&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;7&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;2&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;3&lt;/span&gt; 天（股票价格 = &lt;span&gt;5&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 。&lt;br/&gt;     随后，在第 &lt;span&gt;4&lt;/span&gt; 天（股票价格 = &lt;span&gt;3&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天（股票价格 = &lt;span&gt;6&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;-3&lt;/span&gt; = &lt;span&gt;3&lt;/span&gt; 。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;解释: 在第 &lt;span&gt;1&lt;/span&gt; 天（股票价格 = &lt;span&gt;1&lt;/span&gt;）的时候买入，在第 &lt;span&gt;5&lt;/span&gt; 天 （股票价格 = &lt;span&gt;5&lt;/span&gt;）的时候卖出, 这笔交易所能获得利润 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt; = &lt;span&gt;4&lt;/span&gt; 。&lt;br/&gt;     注意你不能在第 &lt;span&gt;1&lt;/span&gt; 天和第 &lt;span&gt;2&lt;/span&gt; 天接连购买股票，之后再将它们卖出。&lt;br/&gt;     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;输出: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 &lt;span&gt;0&lt;/span&gt;。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1 &amp;lt;= prices.length &amp;lt;= 3 * 10 ^ 4&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0 &amp;lt;= prices[i] &amp;lt;= 10 ^ 4&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;解法一：峰底买入，峰顶卖出&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgjP7RDxmGAicjUsWiaxTshwHfmGlpZAxf6FXF3yry4MOIdmibzibDZfa5hVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如图，在第二天买入，第三天卖出，第四天买入，第五天卖出获利最高，此处代码不再赘述，可以自己尝试写一下&lt;/p&gt;&lt;h4&gt;解法二：贪心算法&lt;/h4&gt;&lt;p&gt;贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。&lt;/p&gt;&lt;p&gt;某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。&lt;/p&gt;&lt;p&gt;对应于该题，第一天买入，第二天卖出，…，第 &lt;code&gt;i&lt;/code&gt; 天买入，第 &lt;code&gt;i+1&lt;/code&gt; 天卖出，如果 &lt;code&gt;i&lt;/code&gt; 天买入第 &lt;code&gt;i+1&lt;/code&gt; 天卖出有利润则买入，否则不买&lt;/p&gt;&lt;p&gt;第 &lt;code&gt;i-1&lt;/code&gt; 天买入第 &lt;code&gt;i&lt;/code&gt; 天卖出获利 &lt;code&gt;prices[i+1]-prices[i]&lt;/code&gt; ，我们仅仅需要将 &lt;code&gt;prices[i+1]-prices[i]&lt;/code&gt; 的所有正值加起来就是可获取的最大利益&lt;/p&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; maxProfit = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;prices&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; profit = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; prices.length - &lt;span&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (prices[i + &lt;span&gt;1&lt;/span&gt;] &amp;gt; prices[i]) {&lt;br/&gt;            profit += prices[i + &lt;span&gt;1&lt;/span&gt;] - prices[i]&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; profit&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.9 分发饼干&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 g~i~ ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s~j~。如果 s~j~ &amp;gt;= g~i~ ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3], [1,1]&lt;br/&gt;&lt;br/&gt;输出: 1&lt;br/&gt;&lt;br/&gt;解释: &lt;br/&gt;你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。&lt;br/&gt;虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。&lt;br/&gt;所以你应该输出1。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2], [1,2,3]&lt;br/&gt;&lt;br/&gt;输出: 2&lt;br/&gt;&lt;br/&gt;解释: &lt;br/&gt;你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。&lt;br/&gt;你拥有的饼干数量和尺寸都足以让所有孩子满足。&lt;br/&gt;所以你应该输出2.&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：贪心算法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; findContentChildren = &lt;span&gt;(&lt;span&gt;g, s&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!g.length || !s.length) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    g.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a - b)&lt;br/&gt;    s.sort(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a - b)&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; gi = &lt;span&gt;0&lt;/span&gt;, si = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (gi &amp;lt; g.length &amp;amp;&amp;amp; si &amp;lt; s.length) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (g[gi] &amp;lt;= s[si++]) gi++&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; gi&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.10 分割数组为连续子序列&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给你一个按升序排序的整数数组 &lt;code&gt;num&lt;/code&gt;（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。&lt;/p&gt;&lt;p&gt;如果可以完成上述分割，则返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,3,4,5]&lt;br/&gt;输出: True&lt;br/&gt;解释:&lt;br/&gt;你可以分割出这样两个连续子序列 : &lt;br/&gt;1, 2, 3&lt;br/&gt;3, 4, 5&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,3,4,4,5,5]&lt;br/&gt;输出: True&lt;br/&gt;解释:&lt;br/&gt;你可以分割出这样两个连续子序列 : &lt;br/&gt;1, 2, 3, 4, 5&lt;br/&gt;3, 4, 5&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [1,2,3,4,4,5]&lt;br/&gt;输出: False&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;解法：贪心算法&lt;/h4&gt;&lt;p&gt;从头开始，我们每次仅仅寻找满足条件的序列（连续子序列长度为3），剔除之后，依次往后遍历：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前元素是否能够拼接到前一个满足条件的连续子序列上，可以的话，则拼接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不可以，则判断以当前元素开始能否构成连续子序列（长度为3），可以的话，则剔除连续子序列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，返回 false&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; isPossible = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; max = nums[nums.length - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;// arr：存储原数组中数字每个数字出现的次数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// tail：存储以数字num结尾的且符合题意的连续子序列个数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(max + &lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;0&lt;/span&gt;), &lt;br/&gt;        tail = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(max + &lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        arr[num] ++&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; num &lt;span&gt;of&lt;/span&gt; nums) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(arr[num] === &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(tail[num&lt;span&gt;-1&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            tail[num&lt;span&gt;-1&lt;/span&gt;]--&lt;br/&gt;            tail[num]++&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(arr[num+&lt;span&gt;1&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; arr[num+&lt;span&gt;2&lt;/span&gt;] &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            arr[num+&lt;span&gt;1&lt;/span&gt;]--&lt;br/&gt;            arr[num+&lt;span&gt;2&lt;/span&gt;]--&lt;br/&gt;            tail[num+&lt;span&gt;2&lt;/span&gt;]++&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        arr[num]--&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.11 全排列问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;给定一个 &lt;strong&gt;没有重复&lt;/strong&gt; 数字的序列，返回其所有可能的全排列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;输出:&lt;br/&gt;[&lt;br/&gt;  [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解法：回溯算法&lt;/h4&gt;&lt;p&gt;本题是回溯算法的经典应用场景&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 算法策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;回溯算法很简单，它就是不断的尝试，直到拿到解。它的这种算法思想，使它通常用于解决广度的搜索问题，即从一组可能的解中，选择一个满足要求的解。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 代码实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们可以写一下，数组 [1, 2, 3] 的全排列有：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;即回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。&lt;/p&gt;&lt;p&gt;这显然是一个 &lt;strong&gt;递归&lt;/strong&gt; 结构；&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;递归的终止条件是：一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 &lt;code&gt;depth&lt;/code&gt; ，或者命名为 &lt;code&gt;index&lt;/code&gt; ，表示当前要确定的是某个全排列中下标为 &lt;code&gt;index&lt;/code&gt; 的那个数是多少；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;used（object）：用于把表示一个数是否被选中，如果这个数字(num)被选择这设置为 &lt;code&gt;used[num] = true&lt;/code&gt; ，这样在考虑下一个位置的时候，就能够以 O(1)的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; permute = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 使用一个数组保存所有可能的全排列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; res = []&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (nums.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; used = {}, path = []&lt;br/&gt;    dfs(nums, nums.length, &lt;span&gt;0&lt;/span&gt;, path, used, res)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; dfs = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;nums, len, depth, path, used, res&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 所有数都填完了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (depth === len) {&lt;br/&gt;        res.push([...path])&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!used[i]) {&lt;br/&gt;            &lt;span&gt;// 动态维护数组&lt;/span&gt;&lt;br/&gt;            path.push(nums[i])&lt;br/&gt;            used[i] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 继续递归填下一个数&lt;/span&gt;&lt;br/&gt;            dfs(nums, len, depth + &lt;span&gt;1&lt;/span&gt;, path, used, res)&lt;br/&gt;            &lt;span&gt;// 撤销操作&lt;/span&gt;&lt;br/&gt;            used[i] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;            path.pop()&lt;br/&gt;        }&lt;br/&gt;      &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4. 复杂度分析&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;时间复杂度：O(n∗n!)，其中 n 为序列的长度&lt;/p&gt;&lt;p&gt;这是一个排列组合，每层的排列组合数为：A^m^ ~n~=n!/(n−m)! ，故而所有的排列有 ：&lt;/p&gt;&lt;p&gt;A^1^ ~n~ + A^2^ ~n~ + … + A^n-1^ ~n~ = n!/(n−1)! + n!/(n−2)! + … + n! = n! * (1/(n−1)! + 1/(n−2)! + … + 1) &amp;lt;= n! * (1 + 1/2 + 1/4 + … + 1/2^n-1^) &amp;lt; 2 * n!&lt;/p&gt;&lt;p&gt;并且每个内部结点循环 n 次，故非叶子结点的时间复杂度为 O(n∗n!)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;空间复杂度：O(n)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;h3&gt;&lt;span&gt;7.12 括号生成&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;输入：n = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;输出：[&lt;br/&gt;       &lt;span&gt;&quot;((()))&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;(()())&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;(())()&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;()(())&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;()()()&quot;&lt;/span&gt;&lt;br/&gt;     ]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;解答：回溯算法（深度优先遍历）&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;算法策略：&lt;/strong&gt; 回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。&lt;/p&gt;&lt;p&gt;对应于本题，我们可以每次试探增加 &lt;code&gt;(&lt;/code&gt; 或 &lt;code&gt;)&lt;/code&gt; ，注意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加入 &lt;code&gt;(&lt;/code&gt; 的条件是，当前是否还有 &lt;code&gt;(&lt;/code&gt; 可以选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加入 &lt;code&gt;)&lt;/code&gt; 的时候，受到 &lt;code&gt;(&lt;/code&gt; 的限制，如果已选择的结果里的 &lt;code&gt;(&lt;/code&gt; 小于等于已选择里的 &lt;code&gt;)&lt;/code&gt; 时，此时是不能选择 &lt;code&gt;)&lt;/code&gt; 的，例如如果当前是 &lt;code&gt;()&lt;/code&gt; ，继续选择 &lt;code&gt;)&lt;/code&gt; 就是 &lt;code&gt;())&lt;/code&gt; ，是不合法的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; generateParenthesis = &lt;span&gt;(&lt;span&gt;n&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res = []&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; dfs = &lt;span&gt;(&lt;span&gt;path, left, right&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 肯定不合法，提前结束&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left &amp;gt; n || left &amp;lt; right) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 到达结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (left + right === &lt;span&gt;2&lt;/span&gt; * n) {&lt;br/&gt;            res.push(path)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 选择&lt;/span&gt;&lt;br/&gt;        dfs(path + &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;, left + &lt;span&gt;1&lt;/span&gt;, right)&lt;br/&gt;        dfs(path + &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;, left, right + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    dfs(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;复杂度分析（来源leetcode官方题解）：&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.24057217165149544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKnuJoEMkRQzmiawsflfy7jgj2ZzfgK706a8fGSYEL3egXoHlb82mKFreHYTckX7IeAnlJsP76438sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;/figure&gt;&lt;p&gt;更多解答&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近开源&lt;/span&gt;&lt;span&gt;了一个github仓库：&lt;/span&gt;&lt;span&gt;百问百答，在工作中很难做到对社群问题进行立即解答，所以可以将问题提交至 https://github.com/Advanced-Frontend/Just-Now-QA ，我会在每晚花费 1 个小时左右进行处理，更多的是鼓励与欢迎更多人一起参与探讨与解答🌹&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-13&quot;&gt;最后&lt;/h2&gt;&lt;section&gt;&lt;span&gt;欢迎关注「&lt;/span&gt;&lt;span&gt;三分钟学前端&lt;/span&gt;&lt;span&gt;」，回复「&lt;/span&gt;&lt;span&gt;交流&lt;/span&gt;&lt;span&gt;」自动加入&lt;/span&gt;&lt;span&gt;前端三分钟进阶群，每日一道编程算法面试题（含解答），助力你成为更优秀的前端开发！&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjUxOTM2Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmTRcFWKB5pLtwz9auwyvjn6nhiaSydyGVuAfOfGmdpTBaqLJyLHVwDgXKNicS1VHhJSBADHCk2dib4Q/0?wx_fmt=png&quot; data-nickname=&quot;三分钟学前端&quot; data-alias=&quot;&quot; data-signature=&quot;每日三分钟，学习一个前端小 Tip！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;号内回复：&lt;/p&gt;&lt;section&gt;「&lt;strong&gt;网络&lt;/strong&gt;」，自动获取三分钟学前端网络篇小书（90+页）&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;JS&lt;/strong&gt;」，自动获取三分钟学前端 JS 篇小书（120+页）&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;算法&lt;/strong&gt;」，自动获取 github 2.9k+ 的前端算法小书&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;面试&lt;/strong&gt;」，自动获取 github 23.2k+ 的前端面试小书&lt;/section&gt;&lt;section&gt;「&lt;strong&gt;简历&lt;/strong&gt;」，自动获取程序员系列的 &lt;code&gt;120&lt;/code&gt; 套模版&lt;/section&gt;&lt;section&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx27c980b913cbfb08&quot; data-miniprogram-path=&quot;pages/index/index&quot; data-miniprogram-nickname=&quot;高级前端面试&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot; href=&quot;&quot;&gt;》》面试官也在看的前端面试资料《《&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;“在看和转发”&lt;/span&gt;&lt;span&gt;就是最大的&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>425113ce32ae56021f0689e7b2b1f433</guid>
<title>Spring Boot 引起的 “堆外内存泄漏”</title>
<link>https://toutiao.io/k/o802afr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;组内一个项目最近一直报swap区域使用过高异常，笔者被叫去帮忙查看原因。发现配置的4G堆内内存，但是实际使用的物理内存高达7G，确实有点不正常，JVM参数配置是：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;-XX:MetaspaceSize=&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;M -XX:MaxMetaspaceSize=&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;M -XX:+AlwaysPreTouch -XX:ReservedCodeCacheSize=&lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt;m -XX:InitialCodeCacheSize=&lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt;m, -Xss512k -Xmx4g -Xms4g,-XX:+UseG1GC -XX:G1HeapRegionSize=&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;M
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;但是使用的虚拟内存和物理内存使用情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386034&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h1&gt;排查过程&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;步骤一：先使用java层面的工具定位是不是堆内内存、code区域或者使用unsafe.allocateMemory和DirectByteBuffer申请的堆外内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者在项目中添加“-XX:NativeMemoryTracking=summary ”JVM参数重启项目，查看查到的内存分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386059&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现这个命令显示的committed的远内存小于物理内存。因为之前就对NativeMemoryTracking有所了解和测试，知道NativeMemoryTracking可以追踪到堆内内存、code区域、通过unsafe.allocateMemory和DirectByteBuffer申请的内存，但是追踪不到其他native code（c代码）申请的堆外内存。这一步也可以使用arthas去查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386084&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了防止误判，笔者适应了pmap查看内存分布，发现大量的64M的地址，而这些地址空间不在NativeMemoryTracking所给出的地址空间里面。基本上就断定就是这些64M的内存导致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386087&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤二：使用系统层面的工具定位堆外内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为基本上确定是native code引起之后，java层面的工具基本上就失效了，只能使用系统层面的工具去查找问题。首先使用了gperftools去查看，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386113&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以看出，使用malloc申请的的内存最高到3G之后就释放了，之后始终维持在700M-800M。第一反应就是难道native code 中没有使用malloc申请，直接使用mmap/brk申请的？（gperftools原理就使用动态链接的方式替换了操作系统默认的内存分配器（glibc））&lt;/p&gt;
&lt;p&gt;直接使用strace对mmap/brk进行追踪发现，并没有申请内存，此时陷入了比较迷茫的状态。于是想着能不能看看内存里面是啥东西，就用gdb去dump这些64M的内存下来看看，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386121&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从内容上来看像解压后的jar信息。读取jar信息应该是在项目启动的时候，那么在项目启动之后使用strace作用就不是很大了，于是在项目启动的时候就使用strace，发现确实申请了很多64M内存空间，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386153&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用该mmap申请的地址空间在pmap对应如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386182&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据strace显示的线程Id，去jstack一下java进程，找到线程栈如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386188&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里基本上就可以看出问题来了，这里使用了Reflections进行扫包，底层使用了spring boot loader去加载了jar。因为需要解压jar肯定需要Inflater类，这个需要用到堆外内存，然后使用btrace去追踪这个方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386197&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在代码中找到扫包的地方，发现没有配置扫包路径，默认的是扫描所有jar，修改为扫描特定的jar路径。上线测试，内存正常，问题修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤三：为什么堆外内存没有释放掉呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到步骤二的时候，问题已经解决了，但是有几个疑问：&lt;/p&gt;
&lt;p&gt;为什么堆外内存没有释放&lt;/p&gt;
&lt;p&gt;为什么内存大小都是64M，jar大小不可能这么大，而且都是一样大&lt;/p&gt;
&lt;p&gt;为什么gperftools最终显示使用的的内存大小是700M左右，解压包真的没有使用malloc申请内存吗？&lt;/p&gt;
&lt;p&gt;直接看了一下spring boot loader那一块源码，发现spring对jdk的JarFile的进行了包装。他使用Inflater却没有手动去释放，依赖于Inflater中的finalize机制，在gc的时候释放。于是怀疑gc的时候没有调用finalize。带着这样的怀疑，我把Inflater进行包装在spring loader里面替换成我包装的Inflater，在finalize进行打点监控，发现finalize在young gc 的时候确实被调用了啊。去看了一下Inflater对应的C代码，初始化的使用了malloc 申请内存，调用end的时候调用了free去释放内存了。于是怀疑free的时候没有真正释放内存。然后想着把spring boot包装JarFile 替换成jdk 自带的 JarFile，发现替换之后内存问题解决。&lt;/p&gt;
&lt;p&gt;然后再返过来看gperftools的内存分布情况。发现使用spring loader的时候，内存使用一直在增加，突然某个点内存使用下降了好多。这个点应该就是gc引起的，内存应该释放了。但是操作系统层面没有看到内存变化，怀疑没有释放到操作系统，被内存分配器持有了。&lt;/p&gt;
&lt;p&gt;发现和不使用gperftools内存地址分布差别很明显，2.5G地址使用smaps发现他是属于native stack。物理内存地址分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386217&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此基本上可以确定是内存分配器在捣鬼，搜索了一下glibc 64M，发现从glibc 从2.11 开始对每个线程引入内存池（64位机器大小就是64M内存），原文如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386228&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照文中所说去修改MALLOC_ARENA_MAX环境变量，发现没什么效果，去查看tcmalloc（gperftools使用的内存分配器）也使用了内存池方式。&lt;/p&gt;
&lt;p&gt;因为glibc 内存分配器代码太多，懒得去看，为了验证就自己简单写个内存分配器。使用动态链接替换掉glibc 的内存分配器，代码如下（因为都是从main中分配内存，没有考虑线程安全，realloc，calloc代码类似没截图了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过在自定义分配器当中埋点可以发现其实程序启动之后程序实际申请的堆外内存其实始终在700M-800M之前，tcmalloc 也有相关埋点也是在700M-800M左右。但是从操作系统角度来看进程占用的内存差别很大（这里只是监控堆外内存）。&lt;/p&gt;
&lt;p&gt;笔者做了一下测试，使用不同分配器进行不同程度的扫包，占用的内存如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386259&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么自定义的malloc 申请800M，最终占用的物理内存在1.7G呢？&lt;/p&gt;
&lt;p&gt;因为自定义内存采用的是mmap分配内存，mmap分配内存的单位是page，也就是page的整数倍，笔者使用的系统pagesize=4k，也就说如果用户申请了1一个字节，也会分配一个page，存在着巨大的空间浪费，可以通过埋点查看系统申请了多少页。埋点发现最终在536k左右吧。那实际上向系统申请的内存 = 512k * 4k = 2G，为什么这个数据由大于1.7G内，因为操作系统采取的是延迟加载的方式，也就是说通过mmap向系统申请内存的时候系统仅仅返回地址并没有分配真实的物理地址，只有在使用的时候系统产生一个缺页中断然后在加载这个page到内存当中，这也是使用pmap看到的物理和虚拟内存的区别。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386284&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个内存分配的流程如上图。在扫描包的时候，spring loader不会主动去释放堆外内存，导致在扫描过程中，堆外内存占用量一直持续飙升。当发生gc 的时候会依赖于finalize机制一并去释放了堆外内存。但是glibc为了性能考虑，并没有真正把内存归返到操作系统，而是留下来当做内存池了，导致应用层以为发生了“内存泄漏”。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ba38c6e5fc6ec3a01b7c05c837633387</guid>
<title>Spring Boot 2 参数管理实践，入参出参与校验</title>
<link>https://toutiao.io/k/hhwhm3y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、参数管理&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在编程系统中，为了能写出良好的代码，会根据是各种设计模式、原则、约束等去规范代码，从而提高代码的可读性、复用性、可修改，实际上个人觉得，如果写出的代码很好，即别人修改也无法破坏原作者的思路和封装，这应该是非常高水准。&lt;/p&gt;&lt;p&gt;但是在日常开发中，碍于很多客观因素，很少有时间去不断思考和优化代码，所以只能从实际情况的角度去思考如何构建系统代码，保证以后自己还能读懂自己的代码，在自己的几年编程中，实际会考虑如下几个方面：代码层级管理，命名和注释统一，合理的设计业务数据库，明确参数风格。&lt;/p&gt;&lt;p&gt;这里就来聊一下参数管理，围绕：入参、校验、返参三个方面内容。&lt;/p&gt;&lt;p&gt;如何理解代码规范这个概念：即大多数开发认同，愿意遵守的约束，例如Spring框架和Mvc模式对于工程的管理，《Java开发手册》中对于业务开发的规定，其根本目的都是想避免随着业务发展，代码演变到无法维护的境界。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、接收参数&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;接收参数方式有很多种，List，Map，Object等等，但是为了明确参数的语义，通常都需要设计参数对象的结构并且遵守一定的规范，例如明确禁止Map接收参数：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Rest风格接收单个ID参数：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/param/single/{id}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;paramSingle&lt;/span&gt; &lt;span&gt;(@PathVariable Integer id)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Resp:&quot;&lt;/span&gt;+id ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;接收多个指定的参数：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/param/multi&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;paramMulti&lt;/span&gt; &lt;span&gt;(@RequestParam(&lt;span&gt;&quot;key&quot;&lt;/span&gt;)&lt;/span&gt; String key, @&lt;span&gt;RequestParam&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;var&quot;&lt;/span&gt;)&lt;/span&gt; String &lt;span&gt;var&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Resp:&quot;&lt;/span&gt;+key+&lt;span&gt;var&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;基于Java包装对象入参：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/param/wrap&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ParamIn &lt;span&gt;paramWrap&lt;/span&gt; &lt;span&gt;(@RequestBody ParamIn paramIn)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; paramIn ;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;-- 参数对象实体&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParamIn&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String key ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String &lt;span&gt;var&lt;/span&gt; ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是在开发中常用的几种接参方式，这里通常会遵守下面几个习惯：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;参数语义：明确接收参数的作用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;个数限制：参数超过三个使用包装对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免多个接口使用单个包装对象入参；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免包装对象主体过于复杂；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;参数接收并没有很复杂的约束，整体上也比较容易遵守，通常的问题在于处理较大主体对象时，容易产生一个包装对象被多处复用，进而导致对象字段属性很多，这种情况在复杂业务中尤其容易出现，这种对象并不利于web层接口使用，或者很多时候都会在业务层和接口层混用对象；&lt;/p&gt;&lt;p&gt;在业务层封装复杂的BO对象来降低业务管理的复杂度，这是合理常见的操作，可以在web接口层面根据接口功能各自管理入参主体，在业务实现的过程中，再传入BO对象中。&lt;/p&gt;&lt;p&gt;避免复杂的业务包装对象在各个层乱飘，如果多个接口入参都是同一个复杂的对象，很容易让开发人员迷茫。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、响应参数&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;与参数接收相对应的就是参数响应，参数响应通常具有明确的约束规范：响应主体数据，响应码，描述信息。通常来说就是这样三个核心要素。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;响应参数主体：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这里泛型的使用通常用来做主体数据的接收。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Resp&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String msg ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T data ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;Resp&amp;lt;T&amp;gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;(T data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Resp&amp;lt;T&amp;gt; result = &lt;span&gt;new&lt;/span&gt; Resp&amp;lt;&amp;gt;(HttpStatus.OK);&lt;br/&gt;        result.setData(data);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Resp&lt;/span&gt; &lt;span&gt;(HttpStatus httpStatus)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = httpStatus.value();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.msg = httpStatus.getReasonPhrase();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Resp&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String msg, T data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.code = code;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.msg = msg;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.data = data;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Code状态码&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;即接口状态，建议参照并遵守&lt;code&gt;HttpStatus&lt;/code&gt;中状态码的描述，这是开发普遍遵守的规范，如果不满足业务需求，在适当自定义部分编码，可以完全自定义一套响应码，但是没太多必要。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Msg描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;描述接口的响应的Msg可能就是：成功或失败，更多的时候是需要处理业务异常的提示信息，例如单号不存在，账号冻结等等，通常需要从业务异常中捕获提示信息，并响应页面，或者入参校验不通过的描述。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Data数据&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接口响应的主体数据，不同的业务响应的对象肯定不同，所以这里基于泛型机制接收即可，再以JSON格式响应页面。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;参考案例&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接口返参：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/resp/wrap&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Resp&amp;lt;KeyValue&amp;gt; &lt;span&gt;respWrap&lt;/span&gt; &lt;span&gt;(@RequestBody KeyValue keyValue)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Resp.ok(keyValue) ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;响应格式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;   &lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;200&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;&quot;msg&quot;&lt;/span&gt;: &lt;span&gt;&quot;OK&quot;&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;&quot;data&quot;&lt;/span&gt;: {&lt;br/&gt;       &lt;span&gt;&quot;key&quot;&lt;/span&gt;: &lt;span&gt;&quot;hello&quot;&lt;/span&gt;,&lt;br/&gt;       &lt;span&gt;&quot;value&quot;&lt;/span&gt;: &lt;span&gt;&quot;world&quot;&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、参数校验&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;参数接收和响应相对都不是复杂的，比较难处理的就是参数校验：入参约束校验，业务合法性校验，响应参数非空非null校验，等各种场景。&lt;/p&gt;&lt;p&gt;在系统运行过程中，任何参数都不是绝对可靠的，所以参数校验随处可见，不同场景下的参数校验，都有其必要性，但其根本目的都是为了给到请求端提示信息，快速打断流程，快速响应。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、借鉴参考&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;很多封装思想，设计模式，或者这里说的参数校验，都可以参考现有Java源码或者优秀的框架，这是一个应该具备的基础意识。&lt;/p&gt;&lt;p&gt;Java原生方法之&lt;code&gt;java.lang.Thread&lt;/code&gt;线程:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;interrupt&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; != Thread.currentThread())&lt;br/&gt;        checkAccess();&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (blockerLock) {&lt;br/&gt;        Interruptible b = blocker;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (b != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            interrupt0();   &lt;br/&gt;            b.interrupt(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    interrupt0();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Java源码中，大部分都是采用原生的if判断方式，对参数执行校验&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Spring框架&lt;/strong&gt;之&lt;code&gt;org.springframework.util.ClassUtils&lt;/code&gt;工具类部分代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Class&amp;lt;?&amp;gt; forName(String name, &lt;span&gt;@Nullable&lt;/span&gt; ClassLoader classLoader)&lt;br/&gt;   &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException, LinkageError {&lt;br/&gt;  Assert.notNull(name, &lt;span&gt;&quot;Name must not be null&quot;&lt;/span&gt;);&lt;br/&gt;  Class&amp;lt;?&amp;gt; clazz = resolvePrimitiveClassName(name);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   clazz = commonClassCache.get(name);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (clazz != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; clazz;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Spring框架中除了基础的if判断之外，还封装一个&lt;code&gt;org.springframework.util.Assert&lt;/code&gt;断言工具类。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、常用校验方式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;If判断&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/check/base&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;baseCheck&lt;/span&gt; &lt;span&gt;(@RequestParam(&lt;span&gt;&quot;var&quot;&lt;/span&gt;)&lt;/span&gt; String &lt;span&gt;var&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;+&lt;span&gt;&quot; is null&quot;&lt;/span&gt; ;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(&lt;span&gt;var&lt;/span&gt;)){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;+&lt;span&gt;&quot; is empty&quot;&lt;/span&gt; ;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;hello&quot;&lt;/span&gt;.equals(&lt;span&gt;var&lt;/span&gt;)){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;+&lt;span&gt;&quot; sensitive word &quot;&lt;/span&gt; ;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; + &lt;span&gt;&quot; through &quot;&lt;/span&gt; ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这&lt;/span&gt;种&lt;span&gt;判断在代码中很常见，只是一旦遇到校验的主体对象很大，并且在分布式的环境中，需要重复写if判断的话，容易出错是一个方面，对开发人员的耐心考验是另一个方面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Valid组件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在早几年的时候，比较流行的常用校验组件&lt;code&gt;Hibernate-Validator&lt;/code&gt;，后来兴起的&lt;code&gt;Validation-Api&lt;/code&gt;，据说是参考前者实现，不过这并不重要，二者都简化了对JavaBean的校验机制。&lt;/p&gt;&lt;p&gt;基于注解的方式，标记Java对象的字段属性，并设定如果校验失败的提示信息。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JavaValid&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotNull&lt;/span&gt;(message=&lt;span&gt;&quot;ID不能为空&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Email&lt;/span&gt;(message=&lt;span&gt;&quot;邮箱格式异常&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String email ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@NotEmpty&lt;/span&gt;(message = &lt;span&gt;&quot;字段不能为空&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;@Size&lt;/span&gt;(min = &lt;span&gt;2&lt;/span&gt;,max = &lt;span&gt;10&lt;/span&gt;,message = &lt;span&gt;&quot;字段长度不合理&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String data ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;校验结果打印：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JavaValidTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Validator validator ;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@BeforeClass&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;beforeBuild&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        validator = Validation.buildDefaultValidatorFactory().getValidator();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;checkValid&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        JavaValid valid = &lt;span&gt;new&lt;/span&gt; JavaValid(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;&quot;email&quot;&lt;/span&gt;,&lt;span&gt;&quot;data&quot;&lt;/span&gt;) ;&lt;br/&gt;        Set&amp;lt;ConstraintViolation&amp;lt;JavaValid&amp;gt;&amp;gt; validateInfo = validator.validate(valid) ;&lt;br/&gt;        &lt;span&gt;// 打印校验结果&lt;/span&gt;&lt;br/&gt;        validateInfo.stream().forEach(validObj -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;validateInfo：&quot;&lt;/span&gt;+validObj.getMessage());&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接口使用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/java/valid&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; JavaValid &lt;span&gt;javaValid&lt;/span&gt; &lt;span&gt;(@RequestBody @Valid JavaValid javaValid,BindingResult errorMsg)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (errorMsg.hasErrors()){&lt;br/&gt;        List&amp;lt;ObjectError&amp;gt; objectErrors = errorMsg.getAllErrors() ;&lt;br/&gt;        objectErrors.stream().forEach(objectError -&amp;gt; {&lt;br/&gt;            logger.info(&lt;span&gt;&quot;CheckRes:{}&quot;&lt;/span&gt;,objectError.getDefaultMessage());&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; javaValid ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种校验机制基于注解方式，可以大幅度简化普通的入参校验，但是对业务参数的合法校验并不适应，例如常见的ID不存在，状态拦截等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Assert断言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;关于Assert断言方式，起初是在单元测试中常见，后来在各种优秀的框架中开始常见，例如Spring、Mybatis等，然后就开始出现在业务代码中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssertTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String varObject ;&lt;br/&gt;    &lt;span&gt;@Before&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;before&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        varObject = RandomUtil.randomString(&lt;span&gt;6&lt;/span&gt;) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testEquals&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        Assert.assertEquals(varObject+&lt;span&gt;&quot;不匹配&quot;&lt;/span&gt;,varObject,RandomUtil.randomString(&lt;span&gt;6&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testEmpty&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        Assert.assertTrue(StrUtil.isNotEmpty(varObject));&lt;br/&gt;        Assert.assertFalse(varObject+&lt;span&gt;&quot; not empty&quot;&lt;/span&gt;,StrUtil.isNotEmpty(varObject));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testArray&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;/*&lt;br/&gt;            数组元素不相等: arrays first differed at element [1];&lt;br/&gt;            Expected :u08&lt;br/&gt;            Actual   :mwm&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        String &lt;span&gt;var&lt;/span&gt; = RandomUtil.randomString(&lt;span&gt;5&lt;/span&gt;) ;&lt;br/&gt;        String[] arrOne = &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;var&lt;/span&gt;,RandomUtil.randomString(&lt;span&gt;3&lt;/span&gt;)} ;&lt;br/&gt;        String[] arrTwo = &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;var&lt;/span&gt;,RandomUtil.randomString(&lt;span&gt;3&lt;/span&gt;)} ;&lt;br/&gt;        Assert.assertArrayEquals(&lt;span&gt;&quot;数组元素不相等&quot;&lt;/span&gt;,arrOne,arrTwo);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assert断言，可以替换传统的if判断，大量减少参数校验的代码行数，提高程序的可读性，这种风格是目前比较流行的方式。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https://github.com/cicadasmile/middle-ware-parent&lt;br/&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile/middle-ware-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb5078a17972a2d25640a8746f64ebce</guid>
<title>社招面试的架构分析</title>
<link>https://toutiao.io/k/m438ibl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;社招面试的同学往往有个误区：认为面试准备更多的是刷leetcode和按照网上的常见面试题准备。甚至花钱买网课学习kafka、flume、Redis、ES等框架，以便可以进入大厂。但是这种准备方法，最后拿到的offer级别都不会太高。一般是阿里的P6、字节的2-1、京东的T6或T7、滴滴的D7、美团老职级体系的2-3及以下。阿里的P9、美团的4-1以上我也不知道该怎么面试。但是针对阿里P7-P8、美团3-X级别，个人有如下建议。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;重点考察点的比重&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;项目经历&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;项目经历在面试中比重很大，大概占到60%-80%。如果这部分回答的不好，实际上已经被pass了。面试官问基础知识环节只是为了符合面试的流程要求走的过场。因为一般大厂为了体现对面试者的尊重，对面试时间有要求，不能低于40分钟。&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人履历&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;个人履历背景占比10%以上。这个背景主要指学习经历、工作经历等。比如跳槽频繁、没有长时间在一个公司或者岗位工作的经历会严重减分。这里面的逻辑是这样的：&lt;/section&gt;&lt;section&gt;对于一个岗位或者业务真正达到精通一般需要2年以上的时间，这时候&lt;span&gt;一般都完成了从&lt;/span&gt;&lt;span&gt;0到&lt;/span&gt;&lt;span&gt;1的过程&lt;/span&gt;&lt;span/&gt;，业务也会趋于稳定。自己的能力和创造性将项目带的更长远至少还需要1年或者更久。也有可能按照公司的规划，所负责的项目目前的设施和能力已经够用，不需要再深耕。那就说明自己这块已经做的不错了，理论上上级会有新的业务来让自己做。所以，有4年以上同一家公司的工作经历侧面上有可能表示之前做的还不错。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;软素质&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;软素质占比5%以上。常见的软素质包含沟通能力、领导力、抗压能力等。其实价值观也是面试官非常希望考察的项目，只是在短时间里很难精准的判断。这部分主要依赖背景调查阶段的了解。但是问题比较大的话，还是能被面试官在面试阶段捕捉到。&lt;/section&gt;&lt;section&gt;比如面试官问了一个问题：Java线程池参数详解。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;面试者回答如果使用ThreadPoolExecutor来创建，有5个参数(实际有7个，这个无伤大雅)，分别是&lt;span&gt;线程池基本大小、&lt;span&gt;线程池最大大小&lt;/span&gt;、&lt;span&gt;线程存活保持时间&lt;/span&gt;、&lt;span&gt;任务队列&lt;/span&gt;、&lt;span&gt;策略(实际为线程饱和策略，说的不明确也可以接受，如果希望面试者说明确，面试官有义务进一步提问，否则不应该给面试者扣分。)&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;然后面试官问到策略有几种。因为面试过程中面试官已经提前到面试者共享了桌面，所以面试者提议可否看着代码说还是需要背下来。面试官说可以看着代码说。面试者小声说：“我感觉是想让我背下来”同时打开了&lt;/span&gt;&lt;/span&gt;代码(说话的原则应该是言之有物、言之有理、言之有力。此时面试官脑子里画了问号：你这句补充是想表达啥？)。面试者通过代码查找到了有4种线程饱和后拒绝策略。我问面试者这四种策略都代表的什么意思，面试者说就是英文代表的意思。面试官问那这个英文是什么意思。面试者支支吾吾说英文不好，所以面试官告诉了面试者：AbortPolicy的Abort是中止的意思，DiscardPolicy是Discard是废弃的意思。那两个策略究竟有什么区别呢。面试者说没啥区别(实际上&lt;span&gt;AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。&lt;/span&gt;&lt;span&gt;DiscardPolicy：&lt;/span&gt;&lt;span&gt;也是丢弃任务，但是不抛出异常。&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;。这里面面试者本来只是知识深度不够。但是其回答方式容易让人联想到不符合实事求是的价值观或者是容易在压力下降低标准。但是面试官不会从一个问题给面试者定性，会结合其他问题一起来看。但是这整道题的分大概率没有了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目经历怎么表述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;项目经历的表述大体和很多公司每年都会有的述职差不多。个人有个三段式的架构：先介绍项目上下文，拉齐背景信息；再介绍项目做了哪些优化或者个人有哪些业绩；最后总结一下项目心得。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目上下文，拉齐背景信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这部分表述的好要建立在站位清楚、逻辑清晰、对业务理解深入的基础上。建议从大到小、从整体到局部的顺序来介绍。不用着急，一定让面试官理解。否则下面的面试官都听不懂。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;项目优化或个人业绩&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这部分是我发现大多数面试者欠缺的地方。面试者会说目前只是维护或者是接入的工作，来了一个接入方我们对接一下之类的。给人的感觉是萧规曹随，自己没做什么。举个例子说明一下，如果是我的话，我怎么表达。&lt;/p&gt;&lt;p&gt;比如一个支付网关系统，所做的事情是就是对接支付宝支付、微信支付、其他第三方支付或者直接对接银行。经常面临的业务需求是一个新支付机构或者银行的接入。&lt;/p&gt;&lt;p&gt;我所做的项目优化如下：&lt;/p&gt;&lt;p&gt;1、配置化&lt;/p&gt;&lt;p&gt;将底层能力下沉，将原有新项目接入走代码变更发布转变为配置数据变更，提高了系统的稳定性及开发运维效率。&lt;/p&gt;&lt;p&gt;2、监控告警优化&lt;/p&gt;&lt;p&gt;之前告警频繁，以至于电话告警被无视，造成了“狼来了”&lt;span&gt;式告警麻木。经过告警梳理&lt;/span&gt;，每周邮件告警降低到了40封以下，电话告警3个以下。提高了告警的敏感度。当然这么表述是不够的，要把方法说清楚，详见：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485677&amp;amp;idx=1&amp;amp;sn=c9993454549f177d3dd0fecfab1c3369&amp;amp;chksm=fafde243cd8a6b5562931fc718321c5fb1adf5be615518d0c641bf18a7d98945f74168c1da5d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《通知&amp;amp;告警治理(降噪)的7种方法》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;通知&amp;amp;告警治理(降噪)的7种方法&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;其他优化省略。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目心得&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个可以从很多方面来说，比如跨部门沟通方面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9904076738609112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8UW3Y871WzfmMUiapeyYNNDMI4iavkoyxD8Oe9qcd8ia2shG094jlhfbZSlawB74n1vO7ociaRaw7iaQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;417&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>866f6ef9395e1ca31426667023ebb1bc</guid>
<title>助力程序员升职加薪的做图技法</title>
<link>https://toutiao.io/k/6f4krdc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出色的 PPT 不管是对述职晋级，还是技术分享，都有很大的助力作用。出色的 PPT，往往包含大量的图。图能生动形象的把事情讲清楚，一图胜千言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是面向程序员的，介绍开发相关领域的做图技法。想点亮做图技能的，不妨来看看~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;做图技法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做图分为三步：内容，呈现，优化。&lt;img data-ratio=&quot;0.6661514683153014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxCvJH7c0BN3pRqcKokh0e9vEwxnK0vIGRlZBaNG1H1350o5SMOUMs6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1294&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内容&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容是图的根本。为了画图而画图，就像“少年不知愁滋味，为赋新词强说愁”。因此，做图首先想清楚要表达的内容。从描述的内容中，&lt;strong&gt;提炼&lt;/strong&gt;出&lt;strong&gt;主体&lt;/strong&gt;和主体之间的&lt;strong&gt;关系&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，我们要介绍 Vue。Vue 官网的介绍如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vue：渐进式 JavaScript 框架。&lt;/p&gt;&lt;p&gt;易用:已经会了 HTML、CSS、JavaScript？即刻阅读指南开始构建应用！。&lt;/p&gt;&lt;p&gt;灵活：不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。&lt;/p&gt;&lt;p&gt;高效：20kB min+gzip 运行大小；超快虚拟 DOM；最省心的优化。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以初步提炼出主体：Vue，简介，易用及描述，灵活及描述，高效及描述。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19754464285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLx9wAaUIJAmic2cezTMTkYlNHm9crIo2lORGX1Ua2csuTOpVWUCFe2G6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进一步提炼，可以将易用，灵活，高效归类为 Vue 的优点。将优点的描述，提炼成一些关键字。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22564102564102564&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxEIIAyhWBfLibt0deGBgCVDp4qZgciaz4VP60Hnl9H2ReoChWfMmKz7IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主体之间都是从属关系。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;呈现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想清楚要表达的内容后，下面做的是选择合适的呈现方式。本文介绍的是适合用图来呈现内容的场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;流程图&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;流程图：以特定的图形符号加上说明，表示算法的图。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程图适合呈现信息，内容等的流动。主体之间有先后关系。常用流程图来呈现算法。下图描述了二分法求解方程的算法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0779896013864818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxGgr7WWgnIbwZWtA5vLkS9OHwQN3fAkrFOo1lII3JjnUUTjzDZlnPEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1154&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;泳道图&lt;/strong&gt;也叫跨职能流程图，是一种特殊的流程图。泳道图是在流程图的基础上，添加了职能的维度。如，下图描述了饿了么的订餐流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4395833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxwsAn7EugolcrNFPSicKK1WaWVpkicbz1jDDzXiaallmxdZsQGDMiccgInA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画流程图，推荐几个工具:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PressOn&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;专业强大的作图工具，支持多人实时在线协作，可用于原型图、UML、BPMN、网络拓扑图等多种图形绘制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网: https://www.processon.com/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的两个图，都是用 PressOn 做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;diagrams.net&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Security-first diagramming for teams.
Bring your storage to our online tool, or go max privacy with the desktop app.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网: https://www.diagrams.net&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;diagrams.net 以前叫 draw.io。VS Code 有个集成 draw.io 的插件，通过它，可以在 VSCode 中使用 draw.io 来画图。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8167053364269141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxqg8yc41PPiaNRMtR2149LEbyKDBvot85FOb5dxVhG1MXAzv9dpREw3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1724&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件地址：https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Markdown Preview Mermaid Support&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Adds Mermaid diagram and flowchart support to VS Code&#x27;s builtin markdown preview&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件地址：https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid&amp;amp;ssr=false&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个 VSCode 插件，通过它，可以用 Markdown 的拓展语法来画流程图:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;graph TD;&lt;br/&gt;    A--&amp;gt;B;&lt;br/&gt;    A--&amp;gt;C;&lt;br/&gt;    B--&amp;gt;D;&lt;br/&gt;    C--&amp;gt;D;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渲染效果:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7105263157894737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxC8KX6Fg9BcToozYxsLvibqGWbqh4TT5JgnuibU6yAeNdAhTIjWSibJ60Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;304&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制一点的例子&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;graph TD;&lt;br/&gt;    t[旅行]&lt;br/&gt;    t --&amp;gt; c1[夏天]&lt;br/&gt;&lt;br/&gt;    c1 --&amp;gt; cd1{温度超过30度}&lt;br/&gt;    cd1 --&amp;gt; |是| p1((去商场))&lt;br/&gt;    p1 --&amp;gt;  d[呆2小时]&lt;br/&gt;    d --&amp;gt;  h[回家]&lt;br/&gt;&lt;br/&gt;    cd1 --&amp;gt; |否| p2((去海边))&lt;br/&gt;    t --&amp;gt; c2[冬天]&lt;br/&gt;    c2 --&amp;gt; cd3{温度低于30度}&lt;br/&gt;    cd3 --&amp;gt; |是| p1&lt;br/&gt;    cd3 --&amp;gt; |否| p2&lt;br/&gt;    p2 --&amp;gt;  d3[呆1小时]&lt;br/&gt;    d3 --&amp;gt;  h&lt;br/&gt;    h --&amp;gt;  t&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渲染效果:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5150812064965198&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxLVIm4jjicNHIsfOwgHOW8T5h0Fa51W8xkibibQk9MF0ibZia6c0zZFmuUww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;862&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构图&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;架构图：用来描述整体结构与其组成部分关系的图。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构图适合来呈现一个大的结构，以及组成部分的关系。比如：业务架构、应用架构、数据架构和技术架构。下面是一个前后端分离的架构图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.048428207306712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxs0uwIJLRv1hvZkDxmd1n5PoIT9Fq4icEp0GlXrE6o6r4jSKfQ5OKq5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐文章：《一文看懂架构图怎么画》(https://zhuanlan.zhihu.com/p/269201440)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用 Keynote，Power Point 来画架构图。架构图主要以一些矩形，文字组成，用 Keynote 可以完全胜任。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8721174004192872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxLTvpgp61vXH2gCZNJWbibFsicmI8OaSmYGna00ibOYImB1VeGtVSHY0Yg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;954&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图也是用 Keynote 画的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6661514683153014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxCvJH7c0BN3pRqcKokh0e9vEwxnK0vIGRlZBaNG1H1350o5SMOUMs6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1294&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思维导图&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;思维导图又叫心智导图，是表达发散性思维的有效图形思维工具 ，它简单却又很有效，是一种革命性的思维工具。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思维导图适合呈现主体间有从属，关联关系的信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxCoeOV6A2ma1V3uZTCPqRaC5brMvkmcnTVAdagYgqTps7C8U8zwGuMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面推荐几个画思维导图的工具&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MindNode&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MindNode 最大的优点是漂亮，缺点是只支持 Mac。本文的思维导图，都是有这画的。付费版支持多款主题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.30188679245283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLx8xzHQ6Pt5PhFd21Os42awuoGibhXnxVwibPngEDgvFtwfmYMn17KF0Nw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;530&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.262172284644195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxM205yWuuUEZicNeSuxAHOKibdgXZZbKib3rsZwroOBYfT2ExkKsQaaA2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;534&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网: https://mindnode.com/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;XMind&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;a full-featured mind mapping and brainstorming tool, designed to generate ideas, inspire creativity, brings efficiency both in work and life. Millions and millions of people love it.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网: https://www.xmind.net/&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其他&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他的图还有很多，如：UML 图，饼图，折线图，甘特图等。这里就不做一一介绍了。推荐个网站：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图之典&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;可视化图表的词典。&lt;br/&gt;简单易用的图表词典，为你的学习和工作提供科学的可视化建议。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址: http://tuzhidian.com/introduce&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们对图做些优化。优化的方向包括：&lt;strong&gt;排版&lt;/strong&gt;和&lt;strong&gt;配色&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;排版&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的排版应该符合四大原则：对齐原则，对比原则，重复原则，亲密原则。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对齐原则&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对齐指：任何元素都不能在页面上随意安放，每一项都应当与页面上的某个内容存在某种视觉联系。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4191542288557214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxqYsxiaR76MpeHBl1icbxt7FZqiczKLofMvwRn4uv0llmLOVxBqlqAyuRA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对齐能让内容规整有序、严谨美观。常规情况下，我们将内容做左对齐即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐文章：《设计太乱？“对齐”原则肯定没学会》(https://zhuanlan.zhihu.com/p/112299210)&lt;/p&gt;&lt;h5&gt;&lt;span&gt;对比原则&lt;/span&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对比指：强调两个或者两个以上事物之间的差异性。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2867965367965368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxXgYp5n4nJEepo0kicRg5WIlk8GqiaP41eSneRTOeTDiccZdrSd3tJIIdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;924&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比可以让内容主次分明，突出重点。做图时常用的对比有：大小，颜色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐文章：《画面太平？你学会对比原则了吗》(https://zhuanlan.zhihu.com/p/108677853)&lt;/p&gt;&lt;h5&gt;&lt;span&gt;重复原则&lt;/span&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;重复指：视觉要素要重复出现。功能上一样的内容，应该用相同的 UI。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重复可以加强一致性。处处不一样的图，给人的感觉是东拼西凑的，会看得非常难受。比如下图:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6447166921898928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLxfRXKkB50FodmvO3327fmbedS9BiaL6MqNZtwyeIX3kE6R4kGYPdZ19w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1306&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐文章：《你会用“重复原则”来设计排版吗？》(https://www.shejidaren.com/chongfu-yuanze-paiban.html)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;亲密原则&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;亲密指: 指彼此相关的项应当靠近。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;亲密原则和就近原则是一个意思。亲密原则，就是分类，把相似的内容放在一起。亲密原则可以让内容显得井井有条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐文章：《利用“亲密性”原则，让排版不再散乱》(https://www.shejidaren.com/qinmi-xing-yuan-ze.html)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;配色&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;配色指：色彩的搭配。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的色彩带给人不同的视觉效果，从而产生不同的心理感受。通过合理的配色，能更好的体现想表现的内容。做好配色，要学习色彩理论和配色方法。偷懒一点，可以直接从配色网站上选:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Color Hunt: https://colorhunt.co/palettes/popular&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://webgradients.com/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐阅读：《知乎问题：如何学习配色？》(https://www.zhihu.com/question/22148127)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设计入门书籍推荐&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐我以前看过的一本书，内容通俗易懂，读起来很轻松。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4194444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mEakJnD74mibM2tGM5LDT8TVd7ej7lrLx5DsKDH2cjMjo8pDaBXCm6tMKC1KZt4Y6CNtgEZH387x2y1oZ7HWTzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文比较笼统的介绍了做图的技法。后面，我会针对常见的图(流程图，思维导图等)，做一些深入的内容~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注公众号: 前端GoGoGo，助你升职加薪~&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwNzIyMTYzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mEakJnD74m965xnGDuRc9yHa3d69a3nXZZO0qiaXjklno7xJqiaZ1tqotAEKOEBLNnbN3XB7zBpjNK5SzoqHyZibQ/0?wx_fmt=png&quot; data-nickname=&quot;前端GoGoGo&quot; data-alias=&quot;fegogogo&quot; data-signature=&quot;致力于提升前端收入。提供有深度的面试，晋级提升的前端内容。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>