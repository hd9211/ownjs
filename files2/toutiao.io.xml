<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f4099a1c2ef0f35b9ca20256bc4cedf2</guid>
<title>时间轮原理及其在框架中的应用</title>
<link>https://toutiao.io/k/1dwwpfd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;28&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Li Wanghong&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、时间轮简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 为什么要使用时间轮&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在平时开发中，经常会与定时任务打交道。下面举几个定时任务处理的例子。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）心跳检测&lt;/strong&gt;。在Dubbo中，需要有心跳机制来维持Consumer与Provider的长连接，默认的心跳间隔是60s。当Provider在3次心跳时间内没有收到心跳响应，会关闭连接通道。当Consumer在3次心跳时间内没有收到心跳响应，会进行重连。Provider侧和Consumer侧的心跳检测机制都是通过定时任务实现的，而且是本篇文章要分析的时间轮HashedWheelTimer处理的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）超时处理&lt;/strong&gt;。在Dubbo中发起RPC调用时，通常会配置超时时间，当消费者调用服务提供者出现超时进行一定的逻辑处理。那么怎么检测任务调用超时了呢？我们可以利用定时任务，每次创建一个Future，记录这个Future的创建时间与超时时间，后台有一个定时任务进行检测，当Future到达超时时间并且没有被处理时，就需要对这个Future执行超时逻辑处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）Redisson分布式锁续期&lt;/strong&gt;。在分布式锁处理中，通常会指定分布式锁的超时时间，同样会在finally块里释放分布式锁。但是有一个问题时，通常分布式锁的超时时间不好判断，如果设置短了业务却没执行完成就把锁释放掉了，或者超时时间设置很长，同样也会存在一些问题。Redisson提供了一种看门狗机制，通过时间轮定时给分布式锁续期，也就是延长分布式锁的超时时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到，上述几个例子都与定时任务有关，那么传统的定时任务有什么缺点呢？为什么要使用时间轮来实现？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如使用普通的定时任务处理机制来处理&lt;strong&gt;例2）&lt;/strong&gt;中的超时情况：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）简单地，可以针对每一次请求创建一个线程，然后Sleep到超时时间，之后若判断超时则进行超时逻辑处理。存在的问题是如果面临是高并发请求，针对每个请求都要去创建线程，这样太耗费资源了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）针对方案1的不足，可以改成一个线程来处理所有的定时任务，比如这个线程可以每隔50ms扫描所有需要处理的超时任务，如果发现有超时任务，则进行处理。但是，这样也存在一个问题，可能一段时间内都没有任务达到超时时间，那么就让CPU多了很多无用的轮询遍历操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对上述方案的不足，可以采用时间轮来进行处理。下面先来简单介绍下时间轮的概念。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1.2 单层时间轮&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们先以单层时间轮为例，假设时间轮的周期是1秒，时间轮中有10个槽位，则每个槽位代表100ms。假设我们现在有3个任务，分别是任务A（220ms后执行）、B（410ms之后运行）、C（1930ms之后运行）。则这三个任务在时间轮所处的槽位如下图，可以看到任务A被放到了槽位2，任务B被放到了槽位4，任务C被放到了槽位9。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当时间轮转动到对应的槽时，就会从槽中取出任务判断是否需要执行。同时可以发现有一个剩余周期的概念，这是因为任务C的执行时间为1930ms，超过了时间轮的周期1秒，所以可以标记它的剩余周期为1，当时间轮第一次转动到它的位置时，发现它的剩余周期为1，表示还没有到要处理的时间，将剩余周期减1，时间轮继续转动，当下一次转动到C任务位置时，发现剩余周期为0，表示时间到了需要处理该定时任务了。Dubbo中采用的就是这种单层时间轮机制。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8234165067178503&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvoL7qrRAPH5Sjd5mXWGZYTdE1Dff4YUjYG60iagKEoTMl54fq1jGfc1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 多层时间轮&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;既然有单层时间轮，那么自然而然可以想到利用多层时间轮来解决上述任务执行时间超出时间轮周期的情况。下面以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;301&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5205949656750573&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvArjABxkglzibdia54ficuEN81VNEvLAu5R2EBwxFNro15bVQsBpaIicocw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、时间轮原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面先来看一下Dubbo中的时间轮的结构，可以看到，它和时钟很像，它被划分成了一个个Bucket，每个Bucket有一个头指针和尾指针，分别指向双向链表的头节点和尾节点，双向链表中存储的就是要处理的任务。时间轮不停转动，当指向Bucket0所负责维护的双向链表时，就将它所存储的任务遍历取出来处理。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7009063444108762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvMgiba9hibt6JoX2NGjmuAeml6DdMHzNCunDaI6QXQRg5NEJj0IYLzcrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面我们先来介绍下Dubbo中时间轮HashedWheelTimer所涉及到的一些核心概念，在讲解完这些核心概念之后，再来对时间轮的源码进行分析。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 TimerTask&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在Dubbo中，TimerTask封装了要执行的任务，它就是上图双向链表中节点所封装的任务。所有的定时任务都需要继承TimerTask接口。如下图，可以看到Dubbo中的心跳任务HeartBeatTask、注册失败重试任务FailRegisteredTask等都实现了TimerTask接口。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TimerTask&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Timeout timeout)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;153&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.264&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvlBwPu6NhLhYN3ttTY9HJd2FRPEfrzzvsHujH2Qew9zfQlZyjPmf7JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 Timeout&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;TimerTask中run方法的入参是Timeout，Timeout与TimerTask一一对应，Timeout的唯一实现类HashedWheelTimeout中就封装了TimerTask属性，可以理解为HashedWheelTimeout就是上述双向链表的一个节点，因此它也包含两个HashedWheelTimeout类型的指针，分别指向当前节点的上一个节点和下一个节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Timeout&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;Timer &lt;span class=&quot;code-snippet__title&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;TimerTask &lt;span class=&quot;code-snippet__title&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isExpired&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isCancelled&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout是Timeout的唯一实现，它的作用有两个：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面来看一下Timeout的实现类HashedWheelTimeout的核心字段与实现。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_INIT = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;、&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_CANCELLED = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;、&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_EXPIRED = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   HashedWheelTimeout里定义了三种状态，分别表示任务的初始化状态、被取消状态、已过期状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) STATE_UPDATER&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   用于更新定时任务的状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) HashedWheelTimer timer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指向时间轮对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) TimerTask task&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   实际要执行的任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指定时任务执行的时间，这个时间是在创建 HashedWheelTimeout 时指定的&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   计算公式是: currentTime(创建 HashedWheelTimeout 的时间) + delay(任务延迟时间)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             - startTime(HashedWheelTimer 的启动时间)，时间单位为纳秒&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; state = ST_INIT&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   任务初始状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; remainingRounds&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指当前任务剩余的时钟周期数. 时间轮所能表示的时间长度是有限的， 在任务到期时间与当前时刻&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   的时间差超过时间轮单圈能表示的时长，就出现了套圈的情况，需要该字段值表示剩余的时钟周期&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;) HashedWheelTimeout next、HashedWheelTimeout prev&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   分别对应当前定时任务在链表中的前驱节点和后继节点，这也验证了时间轮中每个槽所对应的任务链表是&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   一个双链表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;9&lt;/span&gt;) HashedWheelBucket bucket&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮中的一个槽，对应时间轮圆圈的一个个小格子，每个槽维护一个双向链表，当时间轮指针转到当前&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   槽时，就会从槽所负责的双向链表中取出任务进行处理&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了remove操作，可以从双向链表中移除当前自身节点，并将当前时间轮所维护的定时任务数量减一。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelBucket bucket = &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.bucket;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timer.pendingTimeouts.decrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了cancel操作，可以取消时间轮中的定时任务。当定时任务被取消时，它会首先被暂存到canceledTimeouts队列中。在时间轮转动到槽进行任务处理之前和时间轮退出运行时都会调用cancel，而cancel会调用remove，从而清理该队列中被取消的定时任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; boolean cancel() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!compareAndSetState(ST_INIT, ST_CANCELLED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timer.cancelledTimeouts.add(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了expire操作，当时间轮指针转动到某个槽时，会遍历该槽所维护的双向链表，判断节点的状态，如果发现任务已到期，会通过remove方法移除，然后调用expire方法执行该定时任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;expire&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!compareAndSetState(ST_INIT, ST_EXPIRED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        task.run(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 HashedWheelBucket&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前面也介绍过了，它是时间轮中的槽，它内部维护了双向链表的首尾指针。下面我们来看一下它内部的核心资源和实现。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) HashedWheelTimeout head、HashedWheelTimeout tail&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指向该槽所维护的双向链表的首节点和尾节点&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了addTimeout方法，用于添加任务到双向链表的尾节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addTimeout&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(HashedWheelTimeout timeout)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;assert&lt;/span&gt; timeout.bucket == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timeout.bucket = &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (head == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        head = tail = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tail.next = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.prev = tail;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tail = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了remove方法，用于从双向链表中删除指定节点。核心逻辑如下图所示，根据要删除的节点找到其前置节点和后置节点，然后分别调整前置节点的next指针和后置节点的prev指针。删除过程中需要考虑一些边界情况。删除之后将pendingTimeouts，也就是当前时间轮的待处理任务数减一。remove代码逻辑较简单，这边就不贴代码了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;259&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.44880546075085326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvjNKodCNcQugf5JQlFp2yQoibg2aw3SnCcsw8IkbeS9vEf7QcicFWX7Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了expireTimeouts方法，当时间轮指针转动到某个槽时，通过该方法处理该槽上双向链表的定时任务，分为3种情况：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;定时任务已到期，则会通过remove方法取出，并调用其expire方法执行任务逻辑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定时任务已被取消，则通过remove方法取出直接丢弃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定时任务还未到期，则会将remainingRounds（剩余时钟周期）减一。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;expireTimeouts&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelTimeout timeout = head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (timeout != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout next = timeout.next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.remainingRounds &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next = &lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.deadline &amp;lt;= deadline) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                timeout.expire();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.isCancelled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next = &lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            timeout.remainingRounds--;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout = next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket也提供了clearTimeouts方法，该方法会在时间轮停止的时候被使用，它会遍历并移除所有双向链表中的节点，并返回所有未超时和未被取消的任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.4 Worker&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Worker实现了Runnable接口，时间轮内部通过Worker线程来处理放入时间轮中的定时任务。下面先来看一下它的核心字段和run方法逻辑。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Timeout&lt;/span&gt;&amp;gt; unprocessedTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   当时间轮停止时，用于存放时间轮中未过期的和未被取消的任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tick&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮指针，指向时间轮中某个槽，当时间轮转动时该tick会自增&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;729&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.26171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvpuyqYmHbpeG02qJOSrNo4pp7FPsn8nw4jgpqoem0O62GIDkI5rXDPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    startTime = System.nanoTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    startTimeInitialized.countDown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;do&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = waitForNextTick();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (deadline &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; idx = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) (tick &amp;amp; mask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            processCancelledTasks();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            HashedWheelBucket bucket = wheel[idx];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            transferTimeoutsToBuckets();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            bucket.expireTimeouts(deadline);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            tick++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (WORKER_STATE_UPDATER.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(HashedWheelTimer.&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    == WORKER_STATE_STARTED);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (HashedWheelBucket bucket : wheel) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.clearTimeouts(unprocessedTimeouts);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (; ; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = timeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timeout.isCancelled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            unprocessedTimeouts.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    processCancelledTasks();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面对run方法中涉及到的一些方法进行介绍：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）waitForNextTick&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;逻辑比较简单，它会判断有没有到达处理下一个槽任务的时间了，如果还没有到达则sleep一会。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）processCancelledTasks&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;遍历cancelledTimeouts，获取被取消的任务并从双向链表中移除。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processCancelledTasks&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (; ; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = cancelledTimeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3）transferTimeoutsToBuckets&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当调用newTimeout方法时，会先将要处理的任务缓存到timeouts队列中，等时间轮指针转动时统一调用transferTimeoutsToBuckets方法处理，将任务转移到指定的槽对应的双向链表中，每次转移10万个，以免阻塞时间轮线程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;transferTimeoutsToBuckets&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;100000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = timeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; calculated = timeout.deadline / tickDuration;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.remainingRounds = (calculated - tick) / wheel.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; ticks = Math.max(calculated, tick);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; stopIndex = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) (ticks &amp;amp; mask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelBucket bucket = wheel[stopIndex];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.addTimeout(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.5 HashedWheelTimer&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后，我们来分析时间轮HashedWheelTimer，它实现了Timer接口，提供了newTimeout方法可以向时间轮中添加定时任务，该任务会先被暂存到timeouts队列中，等时间轮转动到某个槽时，会将该timeouts队列中的任务转移到某个槽所负责的双向链表中。它还提供了stop方法用于终止时间轮，该方法会返回时间轮中未处理的任务。它也提供了isStop方法用于判断时间轮是否终止了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先来看一下HashedWheelTimer的核心字段。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) HashedWheelBucket[] wheel&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   该数组就是时间轮的环形队列，数组每个元素都是一个槽，一个槽负责维护一个双向链表，用于存储定时&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   任务。它会被在构造函数中初始化，当指定为n时，它实际上会取最靠近n的且为&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;的幂次方值。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) Queue&amp;lt;HashedWheelTimeout&amp;gt; timeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   timeouts用于缓存外部向时间轮提交的定时任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) Queue&amp;lt;HashedWheelTimeout&amp;gt; cancelledTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   cancelledTimeouts用于暂存被取消的定时任务，时间轮会在处理槽负责的双向链表之前，先处理这两&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   个队列中的数据。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) Worker worker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮处理定时任务的逻辑&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;) Thread workerThread&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮处理定时任务的线程&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) AtomicLong pendingTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮剩余的待处理的定时任务数量&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tickDuration&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮每个槽所代表的时间长度&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; workerState&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮状态，可选值有init、started、shut down&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面来看一下时间轮的构造函数，用于初始化一个时间轮。首先它会对传入参数ticksPerWheel进行转换处理，返回大于该值的2的幂次方，它表示时间轮上有多少个槽，默认是512个。然后创建大小为该值的HashedWheelBucket[]数组。接着通过传入的tickDuration对时间轮的tickDuration赋值，默认是100ms。节通过threadFactory创建workerThread工作线程，该线程就是负责处理时间轮中的定时任务的线程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;HashedWheelTimer&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ThreadFactory threadFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tickDuration, TimeUnit unit,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ticksPerWheel,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; maxPendingTimeouts&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    wheel = createWheel(ticksPerWheel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mask = wheel.length - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.tickDuration = unit.toNanos(tickDuration);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    workerThread = threadFactory.newThread(worker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.maxPendingTimeouts = maxPendingTimeouts;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; HashedWheelBucket[] &lt;span class=&quot;code-snippet__title&quot;&gt;createWheel&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ticksPerWheel&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelBucket[] wheel = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelBucket[ticksPerWheel];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; wheel.length; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        wheel[i] = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelBucket();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; wheel;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;初始化时间轮之后，就可以向其中提交定时任务了，可以通过时间轮提供的newTimeout方法来完成。首先将待处理的任务数量加1，然后启动时间轮线程，这时worker的run方法就会被系统调度运行。然后将该定时任务封装成HashedWheelTimeout加入到timeouts队列中。start之后，时间轮就开始运行起来了，直到外界调用stop方法终止退出。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Timeout &lt;span class=&quot;code-snippet__title&quot;&gt;newTimeout&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;TimerTask task, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; delay, TimeUnit unit&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; pendingTimeoutsCount = pendingTimeouts.incrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = System.nanoTime() + unit.toNanos(delay) - startTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelTimeout timeout = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelTimeout(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, task, deadline);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timeouts.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt; (WORKER_STATE_UPDATER.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_INIT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (WORKER_STATE_UPDATER.compareAndSet(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     WORKER_STATE_INIT, WORKER_STATE_STARTED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                workerThread.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_STARTED:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_SHUTDOWN:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Invalid WorkerState&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (startTime == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            startTimeInitialized.&lt;span class=&quot;code-snippet__keyword&quot;&gt;await&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException ignore) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、时间轮应用&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;到这里，Dubbo中的时间轮原理就分析完了。接下来呼应本文开头的三个例子，结合它们来分析下时间轮在Dubbo或Redisson中是如何使用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）HeartbeatTimerTask&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在Dubbo的HeaderExchangeClient类中会向时间轮中提交该心跳任务。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;startHeartBeatTask&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;URL url&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!client.canHandleIdle()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        AbstractTimerTask.ChannelProvider cp =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          () -&amp;gt; Collections.singletonList(HeaderExchangeClient.&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; heartbeat = getHeartbeat(url);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; heartbeatTick = calculateLeastDuration(heartbeat);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.heartBeatTimerTask =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HeartbeatTimerTask(cp, heartbeatTick, heartbeat);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; HashedWheelTimer IDLE_CHECK_TIMER =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                              &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelTimer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; NamedThreadFactory(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dubbo-client-idleCheck&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;), &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS, TICKS_PER_WHEEL);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doTask&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long lastRead = lastRead(channel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long lastWrite = lastWrite(channel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((lastRead != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; now() - lastRead &amp;gt; heartbeat)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            || (lastWrite != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; now() - lastWrite &amp;gt; heartbeat)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Request req = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Request();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setVersion(Version.getProtocolVersion());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setTwoWay(&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setEvent(HEARTBEAT_EVENT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            channel.send(req);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2）Redisson锁续期机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当获取锁成功后，Redisson会封装一个锁续期任务放入时间轮中，默认10s检查一下，用于对获取到的锁进行续期，延长持有锁的时间。如果业务机器宕机了，那么该续期的定时任务也就没法跑了，就没法续期了，那等加锁时间到了锁就自动释放了。逻辑封装在RedissonLock中的renewExpiration()方法中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;194&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3363886342804766&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvd2SgvYgR98dCAEVAYibSSxpib3gIOaoMjJNpJzw1HtuB0G5Hbt2ZcGKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; void renewExpiration() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(getEntryName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ee == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void run(Timeout timeout) throws Exception {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(getEntryName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ent == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt; threadId = ent.getFirstThreadId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (threadId == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            RFuture&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;&amp;gt; future = renewExpirationAsync(threadId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            future.onComplete((res, e) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Can&#x27;t update lock &quot;&lt;/span&gt; + getName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; expiration&quot;&lt;/span&gt;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (res) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    renewExpiration();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }, internalLockLeaseTime / &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ee.setTimeout(task);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;renewExpirationAsync&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; threadId&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return 1; &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;end; &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return 0;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          Collections.singletonList(getName()),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          internalLockLeaseTime, getLockName(threadId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3）超时重试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用方式和HeartbeatTimerTask方式类似，读者可以自己动手去分析下它是在哪里被引入的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在本篇文章中，先是举了3个例子来论述为什么需要使用时间轮，使用时间轮的优点，在文末处也分别对这3个例子在Dubbo或Redisson中的使用做了介绍。接着通过画图讲解了单层时间轮与多层时间轮机制，让读者对时间轮算法有了一个简单的认识。在第二部分，依次讲解了Dubbo时间轮中涉及到的TimerTask、Timeout、HashedWheelBucket、Worker、HashedWheelTimer，分析了它们的原理与源码实现。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:117.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1fed054fbdb58d06d75c4467b34b13b3</guid>
<title>「GoCN酷Go推荐」后现代时代远程办公网络问题的golang开源解决方案 —— PairMesh</title>
<link>https://toutiao.io/k/bnh6bt7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;PairMesh是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;Pairmesh是一款先进的虚拟局域网（VPN）工具，用来搭建与访问安全，易用，高性能的点对点的软件定义虚拟局域网，为远程办公的网络连接问题提供了开箱即用的解决方案。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥抱开源，拥抱开放&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;PairMesh是主要使用go语言开发实现的开源项目，您可以查看并获取PairMesh源代码：https://github.com/pairmesh/pairmesh&lt;/p&gt;&lt;p&gt;这个repo包含了PairMesh的全部三个核心组件。具体的PairMesh服务组件架构如图：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbBlNcWrHkNTMmkWZwzicBk5CFtaGp1mnF2A1olUnVArDRicAzGQDUWUo0JUsnmoGiaZ7nmalXIspSWCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Peer Node&lt;/span&gt;&lt;/p&gt;&lt;p&gt;使用者在终端计算设备安装并启动PairMesh应用之后，PairMesh将会创建一个虚拟网络设备，用来进行虚拟局域网内的收发与路由，成为一个终端节点。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Portal Service&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Portal Service是集中化的节点元数据管理中心。所有的终端节点需要与其连接来进行验证登录，获取网络接入权限，并定期进行网络拓扑信息更新，从而获得网络内其他节点的信息。除此之外，节点间的实际网络信息传输并不需要经过Portal。同时Portal也负责用户的注册，登录。其前端作为可视化显示面板呈现用户，节点与网络的详细统计信息。Portal的后端元数据管理和前端可视化共同构成PairMesh的Control Plane（控制平面）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Relay Service&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在大多数情况下，终端节点A与B之间可以建立稳定高速的点对点直连网络连接。但是在少数情况下，点对点的连接无法稳定创建，例如节点处于动态SNAT内网环境中。这时我们还拥有relay server作为中转服务器，用来提供可靠的网络转发传输服务。终端节点在此时将会自动切换至relay模式进行网络传输。并且在建立连接时，还会通过内置算法自动寻找最优的relay server，来使得两点间的传输延迟最低。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;后现代时代的远程办公&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;在被Covid-19深刻影响与改变后的世界，我们都看到了远程办公的意义与价值。远程办工/远程协同的能力已成为企业IT基础架构的重要组成部分,并也许将成为衡量企业竞争力与吸引力的标准之一。&lt;/p&gt;&lt;p&gt;在远程办公的场景下，无论在舒适的家里，旅途的火车或飞机上，还是出差会议的酒店，您都想要使用手中的笔记本电脑或者移动设备去快速稳定地访问位于公司内网的资源，例如您在公司内部的专有开发用机，或是公司内部的共享文档系统。&lt;/p&gt;&lt;p&gt;在远程协同的场景下，您的同事也在家里远程办公，并在本地搭建了一个产品原型（例如游戏服务，3D建模，或是商业计划）。而您在自己的家中想要直接访问，试用，评估并推动这个原型的迭代。这甚至不需要同事将产品原型部署到公司的内网中去 - 毕竟，在产品的快速迭代中，提升的效率意味着降低的成本和巨大的价值。&lt;/p&gt;&lt;p&gt;而所有这些，PairMesh都可以为您做到。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;点对点的轻巧架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;传统的虚拟局域网（VPN）工具采用中心化架构 - 所有终端都通过加密tunnel（隧道）连接到一个远程服务器gateway server，并由这个服务器统一进行信息解密，转译与分发。这样的架构带来了如下问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单点故障问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一旦gateway server出现故障，所有连接在其上的VPN用户都将面临连接断开的风险。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;扩展性问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;gateway server的单机性能也是有限的。当连接的终端过多，网络流量和计算的负载过大时，gateway server将会成为性能瓶颈。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络路径问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;设想在海淀区的您想要和朝阳区的同事发起视频通话，但是VPN gateway server架设在位于上海的公司总部，那么所有您和同事之间的网络传输将不得不在北京和上海之间辗转折返，从而带来巨大的网络延迟。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;随着企业的规模扩大，并随着企业对于远程办公/协作的网络稳定性与性能要求的日益提高，传统的VPN架构面临着来自企业需求的众多挑战。&lt;/p&gt;&lt;p&gt;PairMesh采用最新的点对点分布式架构。只要终端A和终端B都登录进入同一个虚拟网络，并从portal获知对方的存在与相应网络信息，一个加密tunnel便将会在A和B之间直接建立，后续的网络传输将不再需要经过任何中转的gateway server。在这样的由众多点对点直连所构成的mesh(网格)网络下，我们有效解决了传统VPN架构所面临的挑战：&lt;/p&gt;&lt;p&gt;*&lt;em&gt;如上文所介绍过，在某些特定环境下，点对点tunnel无法稳定建立，所以我们还有辅助的中转服务器relay service作为备用方案。&lt;/em&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;您的信息安全，我们最在乎&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;PairMesh使用最新的 Noise Protocol 协议框架进行加密传输，并且在框架下采用多种安全保障措施，确保您的网络传输安全无虞：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;对等公钥和隧道源 IP 地址之间的关联。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用基于 NoiseIK 的单次往返密钥交换.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用新的计时器状态机机制对用户透明地处理所有会话创建。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;短的预共享静态密钥（Curve25519点）用于 OpenSSH 风格的相互认证。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供高度的身份隐藏之外，还提供了强大的完美前向保密性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 ChaCha20Poly1305 身份验证加密将数据包封装在 UDP 中可以实现传输速度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过 PairMesh 管控面使用非对称加密的方式对 IP 地址签名并包含过期时间，避免 Credential 泄露。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所有从终端节点发起的登录请求，在portal端不仅要进行密保验证，同时也要验证相应的机器信息，才能够被允许接入网络。这样即使密码或Token泄露，非法的节点也无法接入网络。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在切换至中转服务器relay模式时，在终端节点和中转服务器之间的所有TCP连接都需要在握手阶段通过对节点的信息进行验证才能够建立。只要那些已经被portal注册过的节点才能够被允许接入中转服务器，进行后续的网络传输。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;连入同一虚拟局域网络的所有终端节点都使用不同的密保密码，并且任意一组点对点连接都使用独一无二的唯一密码进行保护，有效防止密码泄露对于整个网络的安全冲击。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;开箱即用的SaaS体验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;想要立即开始PairMesh为您带来的高效便利的远程协作体验，您只需要：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;登陆 https://www.pairmesh.com/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用GitHub或微信进行注册与登录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;登录之后进入 https://my.pairmesh.com/console/keys 创建属于您的设备密码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;记得把它保存到一个安全的地方。密码生成之后只会为您显示一次。这也是密码安全保障的措施之一。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;下载与您的终端设备平台与操作系统相匹配的pairmesh应用，并安装运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;All Set！在 https://my.pairmesh.com/console/devices 中找到在同一个虚拟局域网络中您想要连接的远程地址，用您想要的方式连接它们，即刻开启PairMesh为您带来的可靠快捷的远程办公协同体验！&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;搭建属于您自己的PairMesh&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;如果您希望搭建属于自己的一整套PairMesh服务，您可以:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;确保您有完整的golang与nodejs的编译与运行环境。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取我们的开源代码：&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;git clone https://github.com/pairmesh/pairmesh&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;执行 &lt;code&gt;make&lt;/code&gt; 编译之后，您将获得&lt;code&gt;pairmesh&lt;/code&gt;, &lt;code&gt;pairrelay&lt;/code&gt;和&lt;code&gt;pairportal&lt;/code&gt;的二进制可执行文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将&lt;code&gt;pairportal&lt;/code&gt;部署在可访问的机器上。使用yaml文件进行相关设置。具体的yaml设置方式与pairportal的启动方式详见repo的README。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码库的&lt;code&gt;webui&lt;/code&gt;文件夹内是portal的vue前端。部署前端使其与后端pairportal连接，然后通过前端进行用户的注册与登录等初始化管理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将&lt;code&gt;pairrelay&lt;/code&gt;部署在可访问的机器上，并通过设置yaml文件使其连接至您的pairportal。具体的yaml设置方式与pairrelay的启动方式请详见repo的README。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;pairmesh&lt;/code&gt;是您的终端节点应用。将其在需要接入虚拟局域网的终端设备内启动：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; PAIRMESH_GATEWAY_API=&amp;lt;您的portal后端服务部署地址&amp;gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; PAIRMESH_GATEWAY_MY=&amp;lt;您的portal vue网站地址&amp;gt;&lt;br/&gt;pairmesh -k &amp;lt;您的密码或token&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;即可开始使用您搭建的PairMesh系统。&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;来和我们一起让PairMesh变得更好&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;我们相信社区的力量。我们期待您可以帮助PairMesh使它变得更好。您有很多方式可以为PairMesh做出贡献：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;参与PairMesh的开发,提交PR至我们的代码repo。在README中您可以看到所有您可以改进优化PairMesh的地方和方式。repo地址：https://github.com/pairmesh/pairmesh&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在Github上提交bug report或者feature request让我们看见，我们会第一时间为您做出修补，解答或功能实现。提交地址: https://github.com/pairmesh/pairmesh/issues&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;参与到我们的社区讨论。欢迎您的发言。社区地址：https://github.com/pairmesh/pairmesh/discussions&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;发布PairMesh的使用教程和blog，让更多的人可以体验PairMesh服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果喜欢PairMesh的话，记得在repo上给出您的小星星&lt;/span&gt;⭐&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在使用中，也欢迎您将问题，建议或反馈发邮件给我们。联系方式：contact@pairmesh.com&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;酷Go推荐》招募：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;各位Gopher同学，最近我们社区打算推出一个类似GoCN每日新闻的新栏目《酷Go推荐》，主要是每周推荐一个库或者好的项目，然后写一点这个库使用方法或者优点之类的，这样可以真正的帮助到大家能够学习到&lt;/p&gt;&lt;p&gt;新的库，并且知道怎么用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大概规则和每日新闻类似，如果报名人多的话每个人一个月轮到一次，欢迎大家报名！戳「阅读原文」，即可报名&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;想要了解更多 Golang 相关的内容，欢迎扫描下方👇 &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;关注 &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;公众号&lt;/strong&gt;&lt;strong&gt;，回复关键词 [实战群]  ,就有机会进群&lt;/strong&gt;&lt;strong&gt;和我们进行交流~&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5763688760806917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDrrBk1KBPqY1QNI320ZK2IIycDa77FcDQAeAFJRVb240xr8biceh23auy7ZpPibEYXPNOnmfsEewkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot; data-backw=&quot;379&quot; data-backh=&quot;219&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1c9277fb79eb4e7dac62816973283da</guid>
<title>不会这个技巧，成不了高级开发</title>
<link>https://toutiao.io/k/pjxqnnq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNTM0ODY1Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQRExEUUR3RSCrwsjzAYNvk3jz2zK7JVGoMY7Lmls5U11TVz4dqvtoxhAlicstb2cmd1ljrsPn9qN9Hag/0?wx_fmt=png&quot; data-nickname=&quot;码上实战&quot; data-alias=&quot;Push-Code&quot; data-signature=&quot;实战演练方可大成，关注Java基础及最新技术。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高级开发起码得会些高级技巧吧？那这些高级技巧从哪里取得呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式肯定是读书，什么？你没那么多时间？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/JJRW7FxQRExwnnunK9UdMEwS1DiclxF7nc79umKzesogVO7StI2jNLJvFhxBsZ39PWOtfxzSyvyichZ2icXOX9l2Q/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸好，我这里帮你开启了速读模式，跟着我一起学习 《高效Java》系列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们第一站就来到了: 静态工厂方法&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 什么是静态工厂方法？&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;静态工厂方法是一种创建对象的方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;这里的静态工厂方法，并不是设计模式中的工厂模式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;静态工厂方法仅仅是类的一个普通的静态方法，它的最终效果等同于构造器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，给你举个例子就明白了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Integer &lt;span&gt;integer&lt;/span&gt; = Integer.valueOf(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;Boolean aBoolean = Boolean.valueOf(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Calendar calendar = Calendar.getInstance();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子中 &lt;code&gt;valueOf&lt;/code&gt; 和 &lt;code&gt;getInstance&lt;/code&gt; 方法就被称为 &lt;strong&gt;静态工厂方法&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 静态工厂方法优势&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么鼓励用静态工厂方法来创造对象，而不是鼓励使用构造器呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因有如下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;静态工厂方法拥有名称，而构造器没有&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不必在每次调用静态工厂方法时都创建一个对象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可以返回当前类的任何子类型对象&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;减少使用者出错的概率&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来逐一了解这些优点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.1 静态工厂方法拥有名称，而构造器没有&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为构造器的本身并没有确切的描述被返回的对象，而静态工厂方法因为有方法名，所以他能够更为清楚的描述将被返回的对象。尤其是拥有多个不同参数的构造方法，在选择构造方法的时候，会让人有些迷惑，而静态工厂方法则更加清楚明了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//Date类&lt;br/&gt;Date date0 = new Date();&lt;br/&gt;Date date1 = new Date(2022L);&lt;br/&gt;Date date2 = new Date(&lt;span&gt;&quot;2022&quot;&lt;/span&gt;);&lt;br/&gt;Date date3 = new Date(2022,3,20);&lt;br/&gt;Date date4 = new Date(2022,3,20,18,30,59);&lt;br/&gt;&lt;br/&gt;// LocalDate类&lt;br/&gt;public static LocalDate &lt;span&gt;&lt;span&gt;now&lt;/span&gt;&lt;/span&gt;(){}&lt;br/&gt;public static LocalDate ofEpochDay(long epochDay){}&lt;br/&gt;public static LocalDate of(int year, Month month, int dayOfMonth) {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;&lt;span&gt;看下这么多不同参数的构造方法，如果不去了解Date，懵不懵？&lt;/span&gt;&lt;span&gt; 再看看 Java8 &lt;/span&gt;中&lt;span&gt;的LocalDate类。&lt;/span&gt;&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.2 不必在每次调用静态工厂方法时都创建一个对象&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造器每次调用的时候都会创建一个新的对象，而使用静态工厂方法则可以不必每次都创建新的对象，我们可以提前创建好对象或重用已有的对象，以达到提升性能的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来我给你们举个例子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、Integer 类中的 &lt;code&gt;valueOf&lt;/code&gt; 方法，当数值在 -128 ~ 127之间时，是不会创建新的Integer类的，而是从缓存中取出。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public static Integer valueOf(int i) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; IntegerCache.cache[i + (-IntegerCache.low)];&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; new Integer(i);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、Boolean 类中的 &lt;code&gt;valueOf&lt;/code&gt; 方法，直接取出提前创建好的静态常量返回，也没有创建新的对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public final class Boolean{&lt;br/&gt; public static final Boolean TRUE = new Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    public static final Boolean FALSE = new Boolean(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;   public static Boolean valueOf(boolean b) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (b ? TRUE : FALSE);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.3 可以返回原类型的任何子类型对象&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里牵涉到最基础的多态：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;向上转型：多态本身就是向上转型过的过程&lt;/p&gt;&lt;p&gt;使用格式：父类类型 变量名=new 子类类型();&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有就是设计模式六大原则中的&amp;lt;里氏替换原则&amp;gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public class Test {&lt;br/&gt; //静态工厂方法，返回Test的子类型T1&lt;br/&gt;    public static Test &lt;span&gt;&lt;span&gt;valueOf&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; new T1();&lt;br/&gt;    }&lt;br/&gt;    private static class T1 extends Test{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然可以这样用，但是不建议这样使用，因为这样不利于解耦，父类最好不要依赖于子类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐的做法是：像 Collections 类一样，它像一个工具类，它提供了许多静态工厂方法，你去看会发现静态工厂方法返回的并不是确定的类型，而是List接口的一些子类，这些子类被作为私有类定义在Collections 中，我们无法直接构造这些类，但却可以通过静态工厂方法使用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的目的是精减API的数量，对客户端来说也是一种减压。我们有时不必知道返回的类是什么，但我们可以像我们熟知的接口一样使用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// SingletonList 是私有的，实现List接口的类&lt;br/&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; singletonList(T o) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; new SingletonList&amp;lt;&amp;gt;(o);&lt;br/&gt;}&lt;br/&gt;// EmptyList 是私有的，实现List接口的类&lt;br/&gt;public static final &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; &lt;span&gt;&lt;span&gt;emptyList&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; (List&amp;lt;T&amp;gt;) EMPTY_LIST;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.4 减少使用者出错的概率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看下例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;class Run {&lt;br/&gt;    public static final int RUNNING = 1;&lt;br/&gt;    public static final int STOP = 2;&lt;br/&gt;    protected int state;&lt;br/&gt;    public Run(int state) {&lt;br/&gt;        this.state = state;&lt;br/&gt;    }&lt;br/&gt;    public void &lt;span&gt;&lt;span&gt;process&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        // &lt;span&gt;if&lt;/span&gt; RUNNING / STOP&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面例子中，我只想对 RUNNING / STOP 两种状态处理，但我却无法控制使用者的行为，比如他可以这样调用：&lt;code&gt;new Run(4)&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况怎么办呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;class Run {&lt;br/&gt;    public static final int RUNNING = 1;&lt;br/&gt;    public static final int STOP = 2;&lt;br/&gt;    protected int state;&lt;br/&gt;    //私有构造方法外部无法调用&lt;br/&gt;    private Run(int state) {&lt;br/&gt;        this.state = state;&lt;br/&gt;    }&lt;br/&gt;    public static Run &lt;span&gt;&lt;span&gt;running&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; new Run(RUNNING);&lt;br/&gt;    }&lt;br/&gt;    public static Run &lt;span&gt;&lt;span&gt;stop&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; new Run(STOP);&lt;br/&gt;    }&lt;br/&gt;    public void &lt;span&gt;&lt;span&gt;process&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        // &lt;span&gt;if&lt;/span&gt; RUNNING / STOP&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过这样改造后，我们严格控制了取值范围，使用者出错的机会就大大减少了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为类的提供者，我们要尽量确保自身性能好，具有灵活性，让使用者使用起来更容易，更不容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恰恰静态工厂方法可以让我们做到这些，所有&lt;span&gt;建议创建对象的时候优先考虑使用静态工厂方法。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9cd8b9b333fb757802dc009a3e8e3704</guid>
<title>京东二面：MySQL 主从延迟，读写分离 7 种解决方案</title>
<link>https://toutiao.io/k/iqa9o4a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道互联网数据有个特性，大部分场景都是 &lt;code&gt;读多写少&lt;/code&gt;，比如：微博、微信、淘宝电商，按照 &lt;code&gt;二八原则&lt;/code&gt;，读流量占比甚至能达到 90%&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合这个特性，我们对底层的数据库架构也会做相应调整。采用 &lt;code&gt;读写分离&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.53515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfFdE4Dq3ECB8kZibLvl64XY8RqGNE7fCOTVB5BhsEQcpDNI4ib2xS9ADvrpDcx564GQPOrIbfS0eZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;处理过程：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端会集成 SDK，每次执行 SQL 时，会判断是 &lt;code&gt;写&lt;/code&gt; 或 &lt;code&gt;读&lt;/code&gt; 操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是 &lt;code&gt;写&lt;/code&gt; SQL，请求会发到 &lt;code&gt;主库&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库执行SQL，事务提交后，会生成 &lt;code&gt;binlog&lt;/code&gt; ，并同步给 &lt;code&gt;从库&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;从库&lt;/code&gt; 通过 SQL 线程回放 &lt;code&gt;binlog&lt;/code&gt; ，并在从库表中生成相应数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是 &lt;code&gt;读&lt;/code&gt; SQL，请求会通过 &lt;code&gt;负载均衡&lt;/code&gt; 策略，挑选一个 &lt;code&gt;从库&lt;/code&gt; 处理用户请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看似非常合理，细想却不是那么回事&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;主库&lt;/code&gt; 与 &lt;code&gt;从库&lt;/code&gt; 是采用异步复制数据，如果这两者之间数据还没有同步怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主库刚写完数据，从库还没来得及拉取最新数据，&lt;code&gt;读&lt;/code&gt; 请求就来了，给用户的感觉，&lt;code&gt;数据丢了？？？&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfFdE4Dq3ECB8kZibLvl64XYDvXYBH9lLRorVyd4CILmGnjic6Gr6VuJwg1wCGKLghccBybqedP0Kxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这个问题，今天，我们就来探讨下有什么解决方案？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;一、强制走主库&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对不用的业务诉求，区别性对待&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景一：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是对数据的 &lt;code&gt;实时性&lt;/code&gt; 要求不是很高，比如：大V有千万粉丝，发布一条微博，粉丝晚几秒钟收到这条信息，并不会有特别大的影响。这时，可以走 &lt;code&gt;从库&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景二：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对数据的 &lt;code&gt;实时性&lt;/code&gt; 要求非常高，比如金融类业务。我们可以在客户端代码标记下，让查询强制走主库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、从库延迟查询&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于主从库之间数据同步需要一定的时间间隔，那么有一种策略是延迟从从库查询数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select sleep(1)&lt;br/&gt;select * from order &lt;span&gt;where&lt;/span&gt; order_id=11111;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正式的业务查询时，先执行一个sleep 语句，给从库预留一定的数据同步缓冲期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为是采用一刀切，当面对高并发业务场景时，性能会下降的非常厉害，一般不推荐这个方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、判断主从是否延迟？决定选主库还是从库&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前写过一篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247491111&amp;amp;idx=1&amp;amp;sn=202d8dcb3e551039c129ac673414559b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《京东一面：MySQL 主备延迟有哪些坑？主备切换策略
》&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有讲过 &lt;code&gt;什么是主备延迟？&lt;/code&gt;、&lt;code&gt;主备延迟的常见原因？&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在从库 执行 命令 &lt;code&gt;show slave status&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看 &lt;code&gt;seconds_behind_master&lt;/code&gt; 的值，单位为秒，如果为 0，表示主备库之间无延迟&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较主从库的文件点位&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是执行 &lt;code&gt;show slave status&lt;/code&gt;，响应结果里有截个关键参数&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Master_Log_File   读到的主库最新文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Read_Master_Log_Pos 读到的主库最新文件的坐标位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Relay_Master_Log_File 从库执行到的最新文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Exec_Master_Log_Pos 从库执行到的最新文件的坐标位置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两两比较，上面的参数是否相等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方案三：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较 GTID 集合&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Auto_Position=1   主从之间使用 GTID 协议&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Retrieved_Gtid_Set 从库收到的所有binlog日志的 GTID 集合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Executed_Gtid_Set 从库已经执行完成的 GTID 集合&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较 &lt;code&gt;Retrieved_Gtid_Set&lt;/code&gt; 和 &lt;code&gt;Executed_Gtid_Set&lt;/code&gt; 的值是否相等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行业务SQL操作时，先判断从库是否已经同步最新数据。从而决定是操作主库，还是操作从库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论采用上面哪一种方案，如果主库的写操作频繁不断，那么从库的值永远跟不上主库的值，那么读流量永远是打在了主库上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;针对这个问题，有什么解决方案？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题跟 MQ消息队列 既要求高吞吐量又要保证顺序是一样的，从全局来看确实无解，但是缩小范围就容易多了，我们可以保证一个分区内的消息有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到 &lt;code&gt;主从库&lt;/code&gt; 之间的数据同步问题，从库查询哪条记录，我们只要保证之前对应的写binglog已经同步完数据即可，可以不用管主从库的所有的事务binlog 是否同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题是不是一下简单多了&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9867256637168141&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfFdE4Dq3ECB8kZibLvl64XYGdofqYicWibQMpIHVHvAOYmv3rp0KZx4JtAuUHMHhmPHRhIVX8T0hlnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;226&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、从库节点判断主库位点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在从库执行下面命令，返回是一个正整数 M，表示从库从参数节点开始执行了多少个事务&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select master_pos_wait(file, pos[, timeout]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;file 和 pos 表示主库上的文件名和位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;timeout 可选， 表示这个函数最多等待 N 秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;master_pos_wait&lt;/code&gt; 返回结果无法与具体操作的数据行做关联，所以每次接收&lt;code&gt;读请求&lt;/code&gt;时，从库还是无法确认是否已经同步数据，方案实用性不高。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、比较 GTID&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行下面查询命令&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;阻塞等待，直到从库执行的事务中包含 gtid_set，返回 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;超时，返回 1&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select wait_for_executed_gtid_set(gtid_set, 1);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端。具体操作，将参数&lt;code&gt;session_track_gtids&lt;/code&gt; 设置为&lt;code&gt;OWN_GTID&lt;/code&gt;，调用 API 接口&lt;code&gt;mysql_session_track_get_first&lt;/code&gt; 返回结果解析出 GTID&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;处理流程：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发起 &lt;code&gt;写&lt;/code&gt; SQL 操作，在主库成功执行后，返回这个事务的 GTID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发起 &lt;code&gt;读&lt;/code&gt; SQL 操作时，先在从库执行 &lt;code&gt;select wait_for_executed_gtid_set (gtid_set, 1)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果返回 0，表示已经从库已经同步了数据，可以在从库执行 &lt;code&gt;查询&lt;/code&gt; 操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，在主库执行 &lt;code&gt;查询&lt;/code&gt; 操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟上面的 &lt;code&gt;master_pos_wait&lt;/code&gt; 类似，如果 &lt;code&gt;写操作&lt;/code&gt; 与 &lt;code&gt;读操作&lt;/code&gt; 没有上下文关联，那么 GTID 无法传递 。方案实用性不高。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、引入缓存中间件&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7405498281786942&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfFdE4Dq3ECB8kZibLvl64XYcjicwkFnebY1VAfFKQHJQCicSicmDibicic6PCrOMeJHgeicQksqCLpicduaKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1164&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高并发系统，缓存作为性能优化利器，应用广泛。我们可以考虑引入缓存作为&lt;code&gt;缓冲介质&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;处理过程：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端 &lt;code&gt;写&lt;/code&gt; SQL ，操作主库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同步将缓存中的数据删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当客户端读数据时，优先从缓存加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 缓存中没有，会强制查询主库预热数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K-V 存储，适用一些简单的查询条件场景。如果复杂的查询，还是要查询从库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、数据分片&lt;span/&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwfFdE4Dq3ECB8kZibLvl64XYa4cq8TiagDQhAbxpC5nmOibVZcOz2cqThricSYbGYU9JDogeDTZNahQCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 Redis Cluster 模式， 集群网络拓扑通常是 3主 3从，主节点既负责写，也负责读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过水平分片，支持数据的横向扩展。由于每个节点都是独立的服务器，可以提高整体集群的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转换到数据库方面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的解决方式，是分库分表，每次&lt;code&gt;读写&lt;/code&gt;都是操作主库的一个分表，从库只用来做数据备份。当主库发生故障时，主从切换，保证集群的高可用性。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，offer收割机，参加多次淘宝双11大促活动。欢迎关注，我会持续输出更多经典原创文章，为你晋级大厂助力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前微信群已开放，&lt;/span&gt;&lt;span&gt;&lt;span&gt;想进交流群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的小伙伴请添加Tom哥微信，暗号「&lt;/span&gt;&lt;span&gt;&lt;span&gt;进群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;」，唠嗑聊天， 技术交流，围观朋友圈，人生打怪不再寂寞&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.092130518234165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdaSEqIP60fNXXqd7e15vycGo75wsfR2yTDKxOpJaKG0BKzFod8CQxLtibu2vMp1GKBMDJRbk3rpLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;521&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-darkmode-bgcolor-16362991689819=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16362991689819=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16362991689819=&quot;rgb(132, 144, 168)&quot; data-darkmode-original-color-16362991689819=&quot;#fff|rgb(0, 0, 0)|rgb(66, 75, 93)&quot; data-style=&quot;outline: 0px; max-width: 100%; font-weight: bolder; color: rgb(66, 75, 93); letter-spacing: 1px; word-spacing: 3px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__152&quot;&gt;推荐阅读👍：&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2NzYyNjQzNg==&amp;amp;action=getalbum&amp;amp;album_id=1911852085562703875#wechat_redirect&quot; textvalue=&quot;《我想去大厂列》（包含Java、MySQL、Redis、MQ消息队列、TCP网络、项目亮点、团队管理等）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;《我想去大厂》（包含Java、MySQL、Redis、MQ消息队列、TCP网络、项目亮点、团队管理等）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-darkmode-bgcolor-16362991689819=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16362991689819=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16362991689819=&quot;rgb(132, 144, 168)&quot; data-darkmode-original-color-16362991689819=&quot;#fff|rgb(0, 0, 0)|rgb(66, 75, 93)&quot; data-style=&quot;outline: 0px; max-width: 100%; font-weight: bolder; color: rgb(66, 75, 93); letter-spacing: 1px; word-spacing: 3px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__152&quot;&gt;推荐阅读👍：&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2NzYyNjQzNg==&amp;amp;action=getalbum&amp;amp;album_id=1874600102896467974#wechat_redirect&quot; textvalue=&quot;SpringBoot 生态系列，JPA、ElasticSearch、Kafka、Redis等几十个主流开源框架&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;SpringBoot 生态系列，JPA、ElasticSearch、Kafka、Redis等几十个主流开源框架&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a424d04af836336ebc1362e6d2e13835</guid>
<title>流程开放平台表单引擎的设计与实现</title>
<link>https://toutiao.io/k/o2s925x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;312&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHHbFwtMbSjr4QsXjMXnV4jWaibtddj9Sq134xa64Aah4EVf86bB8icxRibzTiapwk7pZC72f8SbHGp5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景和业务痛点&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;58 的 OA 系统中存在上百个业务表单与审批流程，每个表单都需要单独开发，而且每个表单上线之后，都经常出现与其他表单重复的小需求，这些问题导致了 OA 系统上线新表单及维护旧表单的效率非常低，大概每两周只能上线一个业务表单或审批流程。因此，58 企业平台开始着手尝试使用技术手段提高此类业务表单与审批流程的开发上线效率，解决这些重复的、有规律的表单页面与审批流程的开发维护效率问题。低代码、0 代码平台是一种通过尽可能少的代码就可以快速生成应用程序的开发平台。通过所见即所得的方式，使没有技术背景的运营人员也可以使用拖拽组件和预设的流程模型来创建应用程序，避免让研发团队重复开发相似需求，提高业务表单与流程的研发效率。本篇文章主要介绍 58 流程开放平台中表单设计器和渲染器的设计与实现。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;架构设计和模块拆解&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 整体设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程开放平台面对的用户主要分为两类：配置表单用户、使用表单用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）配置表单的用户主要是产品运营或职能岗位的用户。表单的配置信息可以由用户在流程开放平台的表单设计器中编辑产生，也可以由第三方业务系统根据流程开放平台的协议自动化的构建出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）填写表单的用户可以在集成了表单渲染器的页面中填写、提交、查看表单数据，并查看表单相应的审批流程信息。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;每一个表单都是一份各个组件组成的 JSON Schema，表单设计器的输出是一份描述表单字段的 JSON Schema，表单设计完成后 JSON Schema 将被存储到数据库中。表单发布后，前端渲染器再根据 JSON Schema 渲染表单。表单中每一个组件对应 Schema 数组中的一个对象，该组件的所有字段的信息都是存储在对象中，所以每次对表单的组件增删都是增删 JSON Schema 对应的对象 ，修改具体组件的属性则是修改对应的对象。借助表单设计器，不但将开发人员从应对业务变更的频繁改动中解放出来，同时大大提高了非专业开发人的生产力，减少了沟通成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3022222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25r1hjeibZ5futWVBdOC0892nuqVAkjhztjtHR4ksibBnJ8H92opgraqog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.2 表单设计器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;表单设计器的作用，主要是提供一个可视化界面，让用户能够通过所见即所得的方式，快速编辑出可被解析渲染的 JSON Schema。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在实际业务场景中，表单由多个用户输入类组件和基础信息类组件组成，用户输入类组件包含多种形式：文本、数字、单选，多选，附件以及明细等。基础信息类组件也有很多：姓名，工号，公司主体，银行账号，办公地点等。Schema 中的对象除了需要描述组件类型外，还需要描述组件本身的行为，例如单选组件的下拉选项是手动添加，还是设置接口拉取；单行文本组件的值是由接口获取，还是用户填写，是否必填，是否加密等。某些业务场景下还需要添加更加复杂的设置，比如各个组件之间有没有内容联动（用户在一个组件中输入了内容之后，是否需要自动地填充或修改另外一个组件的内容），有没有显隐联动（一个组件的显隐由另外一个或多个组件控制，用户在一个组件中输入了内容之后，是否需要自动地控制另一个组件显示或隐藏）。有了这些描述后，表单渲染器才能根据 Schema 渲染出符合预期的表单。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;表单设计器为左中右三栏布局:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左侧是组件列表，列出了设计器支持的表单组件；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;中间部分是画布，左侧的组件可直接拖拽到画布中，并支持组件调整顺序、删除操作；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;右侧是表单字段的配置区域，在画布中选中一个组件，右侧将展示此字段的所有属性，用户可在此处设置字段标题、描述、排列方式等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4965079365079365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25q2BlsfH0pYwFRHD2KNIfW4dJkU3eaOG4JJhESricTUlSfzMdauhMGiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1575&quot;/&gt;&lt;br/&gt;&lt;span&gt;表单设计器可以从零开始，或者在已有的 JSON Schema 基础上，编辑 JSON Schema 的内容，最后输出 Schema。表单设计器的功能可以用下图表示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25A4TmQJicKk9abJIC9BzsMMJ9Zia31Jib1XDIj8ltPkQbqS0Ns8WXpBbGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了能够让运营人员快速编辑每个组件的配置，表单设计器中提供了组件配置区域，用户无需关心前后端技术或 JSON Schema 的具体格式，表单设计器负责将用户配置的结果转化成 JSON Schema，同时也负责将 Schema 解析成设计器配置区域中的选项。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.3 表单渲染器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;表单渲染器是 58 流程开放平台的另一个核心模块。负责解析 JSON Schema，并将其中定义的组件渲染到页面中。相比传统的表单开发模式，引入表单渲染器有以下优势与劣势：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;-优势：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）研发环节减少，需要投入的人力、沟通成本减少，研发成本降低。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）表单需求变化时，无需前端修改发版，只需在表单设计器重新配置，生成新的 JSON，需求交付更快。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;-劣势：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）需要加载多余的组件，性能相对而言更差。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）如果业务场景需要渲染器无法覆盖的能力，比如组件交互逻辑过于灵活，则可能无法支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10288808664259928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25ibvibm1oJvIydcEW9icKwrC7BNkBUjHibl3MHUMNjd6dXEknVa6gbaDnkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1662&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;58 流程开放平台中的表单在设计之初时，充分考虑了灵活性与扩展性，可以支持以下特性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;- 支持从业务后端拉取某个字段的填充值或选项。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;- 支持用户在某个组件中输入内容后，控制其他组件的填充值或选项。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;- 支持用户在某个组件中输入内容后，控制其他组件的是否可用或是否显示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;- 支持用户在某个组件中输入内容后，由业务后端控制上述组件间的联动逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述这些特性都是由表单渲染器在解析 JSON Schema 之后负责 UI 渲染与用户交互响应的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8262839879154078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25Zphxx0xrpOmsFC5wNcL3uK9SE5PWaMXhqnrZhw9J0n7AhWjwcmRQBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;表单渲染器是如何把 JSON Schema 中的对象回显成组件呢？我们采取的方法是遍历 JSON Schema，根据其中每个组件描述中的类型定义，对应的从组件库中找到组件，然后动态构建整个表单的布局、组件结构，并为每个组件添加相应的事件回调。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;template&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &amp;lt;el-row &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;render-content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;el-col&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      v-&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;item in formConfig&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      :key=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;item.name&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;render-content-item-box&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      :span=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Number(item.attributes.width)&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &amp;lt;component :&lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;`${item.type}Form`&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;formItem&quot;&lt;/span&gt; :detail-index=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;index&quot;&lt;/span&gt; :item=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;item&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;/el-col&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &amp;lt;/el-row&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/template&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当我们从后端接口读取 JSON 文件之后，表单渲染器会按照 Schema 协议加载和渲染该 JSON 的内容。&lt;/span&gt;&lt;span&gt;那么，这个加载和渲染是怎样的一个过程呢？&lt;/span&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29124709527498066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25pbYUib93JLfrB8Y4jbmSHocWDUcR99QEUMciaSIVplibbFasjn6pict1Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1291&quot;/&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;表单渲染器会将获取到的 JSON Schema 和表单的初始数据整合成渲染表单需要的数据，然后根据这些数据渲染整个表单页面。同时，对于存在显隐联动、内容联动或计算公式类的组件，表单渲染器会监听这些组件的用户输入。当用户在一个组件中输入内容触发其他组件的联动时，表单渲染器会自动计算所有联动组件在内存中对应的表单字段的数据，并将这些数据变动回显到页面上。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;Schema 协议的设计&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;Schema 协议的格式非常重要，它必须简单、易懂，这样可以比较方便的由设计器输出，而且要高效率、可扩展，这样方便渲染器渲染，也更准确的表达页面的所有信息。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;Schema协议的JSON格式由来&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;本平台设计的 JSON 格式整体上成树型结构，每一个节点是一个对象，每个节点的属性或功能被标记在对象的字段中，节点的共有属性放在树顶层的节点中，特殊属性 visibileProps、contentProps 来描述联动关系。而由于是树型结构，通过 children 字段属性指定子节点，所以理解起来也非常简单。以一个请假申请单为例：&lt;/span&gt;&lt;/h4&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0092879256965945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU2548KdAdHO2JkuLRY0FGIbpQlWibwsgs2H1u8iaqYDY19ealS3fgJDOMcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;646&quot;/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;蓝色框内页面元素可以提取为基础组件和明细容器类组件。每一个组件就是一个节点，是一个对象，对应的 JSON 节点格式就是：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;applicantName&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ApplicantName&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;申请人&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;applicantDept&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ApplicantDept&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;申请人部门&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;applicantJobNum&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ApplicantNum&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;申请人工号&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Detail&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;明细&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;AsZJ1634892182751&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;children&quot;&lt;/span&gt;: [{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SingleSelect&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请加类型&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DateTimeRange&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;日期区间&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;nPiG1634892209750&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;MultiLine&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请假原因&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;NnDD1634892259871&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;KBTA1615274618115&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请假期间联系方式&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SingleLine&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}]&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;设计节点基础信息&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;针对具体的节点，选中节点的时候右边显示所有可以设置的属性可以进行单独设置。如下图选中单选—请假类型所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5571428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25LJB79MwXaMvNvfOGF4fBCCJ3Wyz0SibMXycNPZt4M6Kl9btFY07c25A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;props 对应的属性就是&lt;/span&gt;&lt;span&gt;该节点自己设置的独有属性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SingleSelect&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请加类型&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;单选&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cnQu1634892188818&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;showDeleteIcon&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;props&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;width&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;12&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;optionsWarn&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;placeholder&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请选择&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;helpUrl&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://pan.58corp.com/oashare/1610166607390700&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;radioType&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;options&quot;&lt;/span&gt;: [{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Yuyr1634883484964&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;选项一&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatKey&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;url&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://xxx&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;token&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请输入token&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;key&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;encrypt&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;emptyError&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;canChangeUrl&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;print&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;key&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cXrV1634892188818&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;设计节点联动信息&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;其中联动关系的设计也比较关键。普通的 JSON 是很难表达一些动态信息的。比如 A 节点是否显示，是由 B 字段的值是否等于 10 来决定的。这一逻辑，在动态表单领域被称为“显隐联动”。如果 A 节点的值是由 B 组件的值控制的，当 B 节点的值变化时，会调用接口返回A组件的值，这一逻辑，在动态表单领域被称为“内容联动”。如下图所示请假类型由时长节点控制显隐和内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4992211838006231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU259Nc85BtJEUV1ZVaft3TGbdnfV5w8xJcO9DIKUfRaMFuRwFCHP9npWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1284&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4878240377062058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU25HGOCwe2eATWabnos5yaLSB8RpFYOBUtwpeoH3FSnibHiaXLFgXjzibbSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1273&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们的设计是把所有控制请假类型节点的信息都放在该节点的属性上。分别为 visibileProps , contentProps。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;SingleSelect&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请加类型&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;单选&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cnQu1634892188818&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;showDeleteIcon&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;props&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;width&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;12&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;optionsWarn&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;placeholder&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请选择&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;helpUrl&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://pan.58corp.com/oashare/1610166607390700&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;radioType&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;options&quot;&lt;/span&gt;: [{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Yuyr1634883484964&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;选项一&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatKey&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;url&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://xxx&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;token&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;请输入token&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;key&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;encrypt&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;emptyError&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;canChangeUrl&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;print&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;visibileProps&quot;&lt;/span&gt;: [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    [{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;labelName&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;nPiG1634892209750&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;时长&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DateTimeRange&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;condition&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;==&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;labelValue&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;contentProps&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;watchTools&quot;&lt;/span&gt;: [{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;label&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;日期区间&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;nPiG1634892209750&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;disabled&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;url&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://test.com&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;token&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;kkkktestsssss&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;key&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cXrV1634892188818&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，就是 Schema 协议设计的全过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;阶段成果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;依靠低代码拖拽生成表单，58 企业平台创建、修改表单的效率得到了大幅提升，需求积压排队等待时长明显减少，需求的响应速度获得了提升。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3058823529411765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2VY3NksPSaHQGw0f4AlBCJ69MAKYVU252w2nCQcmveZIIPUyyAxwwJDKowRdwFicoImFTfmM4hzkt7KQKx26qog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，零代码平台相比传统方式，表单业务的开发上线效率提升了 3 倍，同时降低了表单业务的技术门槛，过去需要研发同学写代码才能做到的事情，现在产品运营同学完全可以自己完成了。以 OA 系统为例，2021 年 1 月至 7 月，流程开放平台支撑了 100+ 个表单，覆盖了 OA 系统中 80% 的表单，月办结量 7W+ 单。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;流程开放平台支持除了支持通过后台设计器配置表单以外，还支持通过 API 提单，目前已支持了 OA 等 8 个业务系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，在需要管理后台的业务场景中，也存在着许多类似的表单页面前端需求。为了提高这类前端需求的开发效率，流程开放平台在自身的技术上进行了抽象封装，开发了表单 SDK。相比以往从 0 开始搭建开发表单需求，基于表单 SDK 进行开发不需要编写大量的页面、样式、交互相关的代码，可以节省大量的开发时间。目前，流程开放平台的表单 SDK 已在 5 个项目中得到的应用。&lt;/span&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>