<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>227435be5599059c14bcd82558d914ca</guid>
<title>[推荐] 如何画好一张架构图？</title>
<link>https://toutiao.io/k/bu1pi73</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;正文&quot; data-mpa-template-id=&quot;1440&quot;&gt;&lt;section label=&quot;powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;正文&quot; data-mpa-template-id=&quot;1440&quot;&gt;&lt;section label=&quot;powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;正文&quot; data-mpa-template-id=&quot;1440&quot;&gt;&lt;section label=&quot;powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;这是一篇来自&lt;span&gt;高级技术专家箫逸畅谈架构经验&lt;/span&gt;的经典好文。在本文中你将了解到：架构图是什么？为什么要画架构图？如何画？有哪些方法？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot;&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;什么是架构图？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBcaFy7sGU6CictXmjCqrUaILaZUI9ElG7bgMib5QqrWtvvxmsJqWaicGlYpRrLS8PGmqibBa8NNv8kGuA/640?wx_fmt=png&quot; data-cropx1=&quot;60&quot; data-cropx2=&quot;193&quot; data-cropy1=&quot;-5&quot; data-cropy2=&quot;5&quot; data-fileid=&quot;100024892&quot; data-ratio=&quot;0.03731343283582089&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vz1ttk8KwbQWJOAbPz4ZdVS3nIyXyHsL9q7A1y3YmFgahUrhxNLl6cPssIDoQGyMlFicslicxUbhD0ld4Y0K67yw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;134&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何画好一张架构图，要做好这件事情首先要回答的就是什么是架构图。我们日常工作中经常能看到各种各样的架构图，而且经常会发现大家对架构图的理解各有侧重。深入追究到这个问题，可能一下子还很难有一个具象的定义，如果我们把这个问题进行拆分（如下图）理解起来就会容易一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;架构图 = 架构 + 图&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照这个等式，我们可以把问题转换：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图是什么？这个比较容易回答，图是一种信息的表达方式，所以&lt;strong&gt;架构图，即表达“架构”的图，也就是一种架构的表达方式。&lt;/strong&gt;也即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;架构图 = 架构的表达 = 表达架构的图&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照这种思路我们需要回答：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是架构？要表达的到底是什么？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何画好一张架构图？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;接下来的内容基本上就是按照这两个维度来做分析。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;什么是架构？要表达的到底是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBcaFy7sGU6CictXmjCqrUaILaZUI9ElG7bgMib5QqrWtvvxmsJqWaicGlYpRrLS8PGmqibBa8NNv8kGuA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;257&quot; data-cropy1=&quot;-5&quot; data-cropy2=&quot;5&quot; data-fileid=&quot;100024892&quot; data-ratio=&quot;0.019455252918287938&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vz1ttk8KwbRicdlrFHIicBqUSdQwiage8xygibARUZ6Bf3YvB68kMoT1CVLCe6tVlvTib6SCUWNsLdibply1IuKw8nicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;257&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linus 03 年在聊到拆分和集成时有一个很好的描述：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;I claim that you want to start communicating between independent modules no sooner than you absolutely HAVE to, and that you should avoid splitting things up  until you really need to, because that communication complexity often swamps the complexity of the actual pieces involved in it.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让我们认识到一种现象，把复杂系统拆分成模块，似乎并没有降低整个系统的复杂度。它降低的只是子系统的复杂度。而整个系统的复杂度，反而会由于拆分后的模块之间，不得不进行交互，变得更加复杂。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;我理解这里描述的系统拆分就是架构的过程，基本出发点是为了效率，通过架构的合理拆分（无论是空间还是时间上的拆分），最终目的让效率最大化。那到底什么是架构，其实没有完全统一且明确的定义，如下三个定义可以参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;在百度百科上的定义：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;架构，又名软件架构，是有关软件整体结构与组件的抽象描述，⽤于指导⼤型软件系统各个方面的设计。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;在 Wikipedia 上的定义：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Architecture&lt;span&gt; &lt;/span&gt;is&lt;span&gt; &lt;/span&gt;both&lt;span&gt; &lt;/span&gt;the&lt;span&gt; &lt;/span&gt;process&lt;span&gt; &lt;/span&gt;and&lt;span&gt; &lt;/span&gt;the&lt;span&gt; &lt;/span&gt;product&lt;span&gt; &lt;/span&gt;of&lt;span&gt; &lt;/span&gt;planning,&lt;span&gt; &lt;/span&gt;designing,&lt;span&gt; &lt;/span&gt;and&lt;span&gt; &lt;/span&gt;constructing&lt;span&gt; &lt;/span&gt;buildings&lt;span&gt; &lt;/span&gt;or&lt;span&gt; &lt;/span&gt;any&lt;span&gt; &lt;/span&gt;other&lt;span&gt; &lt;/span&gt;structures.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;ISO/IEC 42010:20072 中对架构有如下定义：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;The&lt;span&gt; &lt;/span&gt;fundamental&lt;span&gt; &lt;/span&gt;organization&lt;span&gt; &lt;/span&gt;of&lt;span&gt; &lt;/span&gt;a&lt;span&gt; &lt;/span&gt;system,&lt;span&gt; &lt;/span&gt;embodied&lt;span&gt; &lt;/span&gt;in&lt;span&gt; &lt;/span&gt;its&lt;span&gt; &lt;/span&gt;components,&lt;span&gt; &lt;/span&gt;their&lt;span&gt; &lt;/span&gt;relationships&lt;span&gt; &lt;/span&gt;to&lt;span&gt; &lt;/span&gt;each&lt;span&gt; &lt;/span&gt;other&lt;span&gt; &lt;/span&gt;and&lt;span&gt; &lt;/span&gt;the&lt;span&gt; &lt;/span&gt;environment,&lt;span&gt; &lt;/span&gt;and&lt;span&gt; &lt;/span&gt;the&lt;span&gt; &lt;/span&gt;principles&lt;span&gt; &lt;/span&gt;governing&lt;span&gt; &lt;/span&gt;its&lt;span&gt; &lt;/span&gt;design&lt;span&gt; &lt;/span&gt;and&lt;span&gt; &lt;/span&gt;evolution.　&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;74&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.1275797373358349&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441ExDKbJ5IoBFm2fOpHP59Qg7DTOIPdkibibmfypr7eJCuLnA1ej5udaBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1066&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三个定义也是见仁见智，但是我们基本可以得出：&lt;strong&gt;架构体现的是整体结构和组件之间的关系。&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;架构的本质&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;这里引用三个观点来探讨架构的本质：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述三个观点提到的内容，基本表达了架构的核心目的：&lt;strong&gt;管理复杂性，效率最大化。&lt;/strong&gt;以及架构的两个主要变化来源：&lt;strong&gt;一个是以改善软件质量为目的的内在结构性变化；另外一个是以满足客户需求为目的的外在功能性变化。&lt;/strong&gt;无论是何种变化，在我看来架构都是在不断的判断和取舍，在业务需求和系统实现之间做权衡，从而应对未来变化的不确定性，下图可以比较粗浅直观的表达这种理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;146&quot; data-backw=&quot;405&quot; data-ratio=&quot;0.36106750392464676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441wVodn0iasictvKBO0p0SmKZjorCXice0lVmwLkoZa7ehVJAicGfGH1QiayQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;要表达的是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在 EA 架构领域，有两种常见架构方法 RUP 和 TOGAF，这两个框架也是我们常常了解架构分类的两个维度。从个人的角度，我自己觉得 TOGAF 9 的分类方式更加广泛使用（如下右图）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;221&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.38359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj4415ibjv2GkfJB9SRzlpv4z7notw6PSB2AEJ08CLVpZwBcJYHibnUGm9gibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结合日常的业务开发，其实我们更多的是关注业务架构和应用架构，所以把上边的表达式进一步的拆解，在回答如何画好一张架构图之前，我们需要关注业务架构和系统架构，讨论清楚如何进行业务架构和系统架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.634375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441YlTeGgYHib74e6bef0d9DLptlvNBqWwK8AtMNvRlUn5Zh2WbRPQrLXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;架构的过程其实就是建模的过程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我们都知道现实世界到软件世界或者面向对象的世界的过程，是一个不断抽象的过程，这其中的方法就是不断的建立模型。从现实世界到业务模型，从业务模型到概念模型，从概念模型到设计模型，通过不断地抽象去粗取精，形成对现实世界的层层抽象，所以架构的过程其实就是建模的过程。至此，我们有必要了解一下什么是建模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;百度百科定义：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;建模就是建立模型，就是为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《Thinking in UML》定义：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;建模（Modeling），是指通过对客观事物建立一种抽象的方法用以表征事物并获得对事物本身的理解，同时把这种理解概念化，将这些逻辑概念组织起来，构成一种对所观察的对象的内部结构和工作原理的便于理解的表达。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;从上述两个定义基本可以了解到建模就是抽象，对业务或现实世界的抽象，虽然不足以帮我们理解架构本身，但是可以将我们上述关注的业务架构和系统架构进一步向下 Down 一层，架构的过程是建模的过程，我们转换成两个简单的问题：模是什么？如何建？&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;模是什么？如何建？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;这是两个比较容易陷入理论性的问题，我们跳出来从结果看过程。接下来通过已经产出的一些架构图来反向看这些架构图是如何产出的，同时来回答这两个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;203&quot; data-backw=&quot;416&quot; data-ratio=&quot;0.48671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441ynFPFib80ycJFvzwC5v2riczHw2V0eYrplQzib0wWMM4jKQpBGkZkTuibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、业务建模&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到当下业务本身，对我而言也是全新的，在最初接触的时候凭仅有的行业背景去理解，结合了大量的文档阅读最终产出了如下图示的《业务核心流程图》和《业务功能模块图》。这两张图基本上就涵盖了所有的业务内容。左边的业务流程图得到了这个行业 20 多年从业经验专家认可，他认为这就是 20 多年所从事的业务内容（涉及到项目的保密性质，大图故意缩小了，但不影响整体信息传递）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vz1ttk8KwbSgvIWDTgCFjXicMfWic7ialPG7wLKbytGpmZTOFic6xYxxWUGZwqLof5XDX8S8jTBjNfKlBqlKOT2Tww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;回溯整个过程，特别是左侧的业务核心流程图，我们看这张流程图很容易构架起一个基本逻辑，纵向是不同的业务角色和系统，横向是时间的推进。但最开始的理解和分析是极其耗时和压力极大的过程，这个过程中我所用的方法就是：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;把书读厚：&lt;/strong&gt;&lt;span&gt;大量的信息输入，同时探求可能性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;把书读薄：&lt;/strong&gt;&lt;span&gt;归类汇总，形成大图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;逻辑对照：&lt;/strong&gt;&lt;span&gt;确保理解和分析的正确性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1）把书读厚&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图基本涵盖“把书读厚”的过程，汇聚大量的文档信息，尝试用多维度去形成逻辑。这个维度可能是依据历史经验，也可能是依据文档内容，比如在形成业务大图的过程中，我曾按可能的场景逻辑、可能的系统或领域逻辑分别把多个文档中的内容归类，探求可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个过程会很枯燥，特别是涉及一些业务的术语内容，理解起来就会很困难。我的方式就是把自己当做一名“探索者”，如同我们玩游戏一样，常常问自己“我的游戏地图全部点亮了吗？” 未必要照顾到所有细节，但是需要力求覆盖整体内容。仔细想想，似乎也和日常的读书类似，这期间值得注意的是：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重点关注一些业务概念被界定的地方、一些与自己逻辑推理有出入的地方。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不断调整自己阅读过程中记录的维度，矫正自己的分析方向。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;老老实实用文档中的原话来记录和呈现（这点很重要，特别是阅读英文材料，最好原汁原味的记录，有助于提升自己的专业性）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;261&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.45054945054945056&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441Zy09xeCang0oicSjsp88t0hVxlvKsbicCvkaIvbLAsiaPgYWmzbf2NjWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2）把书读薄&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个时候的重点是建立“大局观”，尝试梳理自己的逻辑主线，常规逻辑上讲都会划分为横纵，或者矩阵式的框架，当然这需要建立在前期的理解和分析上，&lt;strong&gt;这里常常隐含一个最重要的假设：系统一定是给人用的，一定是解决客户问题的，否则毫无存在的意义。&lt;/strong&gt;所以核心的套路是：谁？用什么样的服务/功能/能力？解决什么样的问题？从而刻画出：参与者角色、系统能力、交互关系，需要常常问自己的是：边界是什么？输入输出是什么？逐步通过用例来梳理出业务功能，形成角色—&amp;gt;主流程—&amp;gt;分支流程，进而通过不断地归纳演绎形成最终的业务抽象描述“一张图”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个小的细节是不能妄图通过这些过程迅速在大脑里完成大图的绘制，还是需要从小的环节做起，把一部分小的业务闭环做成一个个的小组块，不要让它再占用大脑的空间，然后逐步整体思考和把握，渐进式地形成大图。与此同时，大图的样式美观先完全忽略，走通逻辑再细致调整。之所以强调这个细节，是因为尝试通过“一张图”去描述一个非常大的业务本身就是件很有挑战的事情，如果不这么做容易让自己变得焦虑和急躁，这是一个慢功夫，需要耐心，需要在关键阻塞的地方慢下来，甚至一遍一遍的反复才能最终完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;250&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.43125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441cQIXp8UInI4lnxXpPIDFJPdmp6bkBXThxlfAZia6DttwctPoX7d9F4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3）逻辑对照&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个闭环封装的过程，把前期“读厚”过程中的记录，一些逻辑细节、关键流程都要逐一放到大图里去对照验证，确保业务理解的完整性和准确性，确保业务抽象能够覆盖所有已知的业务用例，甚至能够支持可能的业务场景。这个环节也是必不可少的部分。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结一下业务建模（如下图），通过上述三个主要的过程，我们基本可以产出一些业务架构的大图、框图、流程图、用例图等等，是什么样的图并不重要，重要的是这个图面对的是谁？主要用来做什么？我后边也会讲到画图角度的问题。从我们目前的业务场景上看，&lt;strong&gt;业务架构图的核心目的是统一共识、减少沟通成本，无论是项目中的哪个角色大家都能讲一样的话，描述一样的事情。&lt;/strong&gt;建立对话能力和对话语境，特别是有大量外部客户的时候，一方面体现我们自己的专业性很重要，另外一方面这种与客户对话的能力更重要，这也是上文中提到为什么要尽可能用原汁原味的文字去呈现一张图的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;121&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.209375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441ZteNHeP4uedtHU9Xyxo9WWWjRazU6icjA01FPiaegnb3acHrqztulCAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、系统建模&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过业务建模完成了从现实世界到业务模型的构建，在此基础上，如何通过抽象完成业务模型到设计模型的映射，这是系统建模要解决的问题。从研发实现的角度，这个阶段会产出各种各样的模型图，比如实体模型图、时序图、状态图、各个层次的架构图等等，但是无论何种角度，何种层次，系统建模一定是在业务建模的基础上，完成业务需求到系统模型之间的映射；这其中涉及业务功能到系统能力、业务流程到数据流程的映射；系统建模更强调职责、依赖、约束关系，用于指导研发的落地实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;抛开具体的时序图、状态图不谈，简单看几个维度的架构图（示意）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;434&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.75078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441D2HtzeWdI0YKqP8qdDJwA1PxaI7FlGwzUxwBbRGKShoNzAibbBiaKfiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;图片&lt;/span&gt;&lt;span&gt;源于&lt;/span&gt;&lt;span&gt;网络，为&lt;/span&gt;&lt;span&gt;示意图，侵删&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上述几张图的视角、层次和面向用户各不相同，基本上都能看到整体，但是细节程度不同，侧重表达的信息也完全不同。那么系统建模时应该如何去做呢，这个过程中我常常用的方法是（不尽然如此）：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;“剥洋葱式”的由大到小，由粗到细，覆盖所有已知和未来可能业务场景；善于利用各种模型表述：&lt;/strong&gt;&lt;span&gt;自然语言、关系模型、时序图、状态图、流程图、各种层次架构图等等进行模型表述，充分表达各种业务场景并不断验证。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;核心实体抽取：&lt;/strong&gt;&lt;span&gt;抓住核心概念，核心关系完成核心模型建立。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;终极武器：&lt;/strong&gt;&lt;span&gt;所有的设计/逻辑模糊的点，将所有已知场景分别套入，自己讲给自己。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1）“剥洋葱”&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在业务建模结果的基础上进行“剥洋葱”。这是一个不断拆解的过程，这个过程中的拆解非常重要的方式是就系统分工。如何分工？哪个模块负责什么？模块的输入和输出是什么？内部提供什么样的服务和能力？这几个问题在后文关于抽象的部分回答。一句话总结“剥洋葱”就是：从业务建模的“大局观”去按职责分工拆解成多个子系统、多个子模块，然后在模块层面进行细分，层层剥解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2）核心实体抽取&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于核心实体的抽取，这里的关键问题是：哪些是实体？如何判断核心实体？如何抽取？抽取后的结果是什么样的？很难用一种方法论的形式去描述，我也没有完全形成我自己一成不变的方法论，但是我觉得如下三种方式可以供大家参考。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;实体(Entity)：客观存在并可相互区别的事物称之为实体。实体可以是具体的人、事、物,也可以是抽象的概念或联系。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;从这个概念理解，和我们面向对象万物兼对象的理解是基本一致的。所以实体的抽取也可以借鉴对象分析的方法：独立、可抽象、有层次性、在单个层次上又具备原子性。如下图是《Thinking in UML》中关于对象的分析方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;351&quot; data-backw=&quot;573&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441T5cUS9ia4YfiagMDwgLOq9XhNwcyyWVsvtqkZeupDhQfrbicJXJ8fIvTw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;898.1626297577855&quot; data-cropy1=&quot;6.269896193771626&quot; data-cropy2=&quot;556.4532871972318&quot; data-ratio=&quot;0.6124721603563474&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441A8jt64kvAicPpzjTIYB50zC1Pav1t0bzJSlsU60SUX6jgBvicYic1GSYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过从业务用例中提取其中的关键词，不同的关键词可能表达了实体、关系、属性等等内容，从而完成模型分析与建立。这里引用六铢老师在《问题空间领域模型基本抽象方法》中的的内容，简述如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;一句完整的用例描述中，首先找名词，以「主语」和「宾语」为主，这些名词基本可以确定我们的实体；其次找形容词，存在于「定语」和「状语」中，找到形容词基本可以确定对应属性的值；然后通过对用例的补充，细化，对名词进行定义，慢慢的，我们会得到我们的领域模型和对应的属性。最后通过动词&amp;amp;形容词（存在于【谓语】【状语】【定语】）来确定他们之间的关联关系。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这是《聊聊架构》中提的方式，具体讲就是通过寻找问题的主体，然后分析主体的生命周期，进而通过区分生命周期里的关键活动来聚焦主体的关键属性和关键关系。推荐大家阅读前 9 章的内容，总计才 40 页的内容，可能会有所体会。这里举一个书中的例子：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;一个笑话：一位女士对老公说：把袋子里的土豆削一半下锅。结果，所有土豆都下锅了，而且每个土豆被削了一半。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;作者指出，这里其实是没有清晰的识别主体，这个主体不单是土豆，而是隐含的人要吃土豆，包括人和土豆两个实体，这两个实体之间的关系就是要解决的业务场景：怎样吃？如何吃？为什么吃？所以主体识别不清楚，可能会导致整体实现的偏离。当然实际过程中不会犯这么愚蠢的错误，但是也侧面说明核心实体的抽取是非常关键的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3）终极武器：自己讲给自己&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际的业务开发中，往往一种业务设计实现要满足上层N个业务场景，这其中有共性也有个性化诉求，这个过程中我们很容易被多场景之间的异同搞混乱，要么逻辑不清晰，要么过度设计，要么考虑不周。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我观察过很多同学包括我自己，在一定的业务复杂度时容易失去设计的焦点。我的做法与业务建模类似，一定要逻辑对照：在所有的设计/逻辑模糊的点，将所有已知场景分别套入，自己讲给自己。请注意这里是“分别套入”，在当前的设计层次下一个场景验证完再去验证下一个场景，找出阻塞的、模糊的点，重新梳理再优化设计。系统建模的结果指导我们软件设计实现，所以一定要反复梳理打通，这个反复的过程其实也是提升架构能力的过程，累积到一定程度就会自然通透。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到开始的那个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;模是什么？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;通过上面业务建模和系统建模的描述，简单来讲模就是业务的映射，这个映射的结果是业务模型、概念模型或设计模型，但是所有的出发点都是业务需求：客户是谁？核心诉求是什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何建？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;上面通过业务建模和系统建模两个维度，从个人实践角度大概讲了常规的套路，建模的本质其实一个抽象的过程，但是上述业务和系统建模抽象的过程其实还有两个问题并没有完全说清楚：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;说回抽象&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100025728&quot; data-ratio=&quot;0.0471698&quot; data-type=&quot;png&quot; data-w=&quot;106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBcaFy7sGU6CictXmjCqrUaILtsiaW0Duomh4dxS8yGaUuQW65UhibciaF0YqsgicT0QeicFO7fkKNjOSiaEA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Haskell 语言的设计者之一 Paul Hudak 曾说过一句略带夸张的话：编程中最重要的三件事是：&lt;strong&gt;抽象，抽象，抽象。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&#x27;abstraction, abstraction, abstraction&#x27; are the three most important things in programming.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;如果要问程序员最重要的能力有哪些，我相信抽象一定是其中最重要的之一。那到底什么是抽象？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;百度百科定义：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;如果更精炼的概括：抽象就是做减法和做除法。通过舍弃非本质和无关紧要的部分，着眼于问题的本质，去粗取精；通过透过现象看本质，发现不同事物之间的共同之处，异中求同，同类归并，也就是做除法。上文中建模过程是共性抽象，通过不断的抽象达到某个状态为止，我理解这个状态没有确定性的答案，核心就是满足业务场景的需要，其实这背后也有一个边界的问题。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;抽象的角度&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;生活中处处都是抽象，但是我们似乎少了为什么是这样或那样抽象的思考。抽象是有角度之分的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生活中我们常常说“我的观点是…”，其实这里的“观点”就是一个角度问题，从一定的立场或角度出发，对事物或问题所持的看法。以生活中的常见的实物来说（如下图），我们是否能快速的说出其中的相同点和不同点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;155&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.26796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441ZZxsd1QDFQclRnZQjwpw3AMoutHv71ThvhA9YuxQNA4Vs3SuV20GsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图中已经标注的，我们从功用的角度对它们定义了椅子、桌子、凳子和柜子这样的区分，但显然很有很多很多角度，比如：物料、文字、高矮等等维度，从不同维度看过去，会有完全不同的相同点和不同点表述，所以，本质是什么？本质是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重新回到我们前边的两个问题，业务建模中我们谈到了归类，按什么去归类，答案呼之欲出，按我们的业务流程去归类、按客户的角色去归类，又回到了那个最初始的问题：客户是谁？核心诉求是什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，上文中我们提到，模是业务的映射，基于对抽象的理解，我们可以进一步展开：&lt;strong&gt;模是在确定抽象角度下的业务映射。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;138&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.2390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441ey998ibcXSibX4uHxvsUDG54RcwTjdbmwLjL3wibmqJ358b3cBUsTZzzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;抽象的层次&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Wikipedia 关于抽象的定义中有一个关于报纸的例子：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;1. 我的 5 月 18 日的《旧金山纪事报》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 5 月 18 日的《旧金山纪事报》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 《旧金山纪事报》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 一份报纸&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 一个出版品&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这五句话中，我们可以感受到抽象的层次，抽象层次越高，细节越少，普适性越强。再比如下图中关于网络模型的抽象，关于操作系统内核的抽象，我们可以明显看到，不同层次的抽象就是过滤不同的信息，最终留下来的信息才是当前抽象层次所需要的信息。从系统设计实现上来说，抽象层次越高，越接近设计，越远离实现，同时抽象的模型越不受细节的羁绊，稳定性越高，普适性越强，可重用性就越高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;248&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.42954545454545456&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441EPDXHSB0BKJp5Uic1T8d2QGIpdMIENUXXuxRwPTNQDsx8guGqyklAvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么这里抽象的划分层次的依据是什么？原则又是什么？我的经验是，&lt;strong&gt;划分抽象层次的依据主要包含两个：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以抽象角度分层（可能一层是多角度的聚合）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;面对变化分层（用层次隔离变化）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其实这个也不能完全解释如何分层，原则是什么？我觉得这是几个最通用的原则：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;公用的往下走&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;个性的往上走&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;下层可以独立于上层存在&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;控制下层的变化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;考虑抽象层次的好处是不论在哪一个层次上，我们只需要面对有限的复杂度，从而专心考虑这个层次上的抽象是什么，要表达的信息是什么。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;抽象的边界&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;除了角度、层次之外，我们还需要考虑抽象的边界。如果说层次考虑的是纵向维度的表达，那么边界考虑的是横向维度的表达。如何确定边界，&lt;strong&gt;一个总的原则是按照职责进行划分，这里的职责其实也就是分工。&lt;/strong&gt;一旦职责确定，我们在做建模分析时就不需要把整个业务大局放进来从头到尾去分析一遍，我们只需要考虑当前分工下的上游和下游即可，这样的信息量大大减少，自然我们面对的领域复杂度也会降低到一定程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一定要给出边界的定义，我的理解是：&lt;strong&gt;边界是在确定抽象角度下，通过寻找核心的业务活动，抽取核心实体，进一步确定实体核心生命周期的结果。&lt;/strong&gt;可能有一点点绕，关键词是：核心业务活动、核心实体、核心实体生命周期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以现场娱乐行业为例，如下这张图包含了最高抽象层次下业务的全生命周期，这个抽象层次下的主体是什么，我的理解是票，项目生产的结果是票，分销或电商服务是对票的销售，现场是对票的核验，至此以票为核心实体的生命周期结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;189&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.3265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441o466Vpp1dFZp5RBmur9JnBRLic3EKPnqdDDWJ89wQPFviaEXBR6xViaibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们往下 Down 一层，从项目生产这一个业务活动去看，整个业务流程是这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;项目管理-&amp;gt;场馆座位分销-&amp;gt;票房预测-&amp;gt;场次管理-&amp;gt;配额管理-&amp;gt;绘座-&amp;gt;票房规划&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从生产这个视角去看，核心的实体不是票，而是场次（确定时间、确定地点、确定内容的一场演出或赛事），所有的关键业务活动都是以场次为维度，生产领域里需要考虑的主要就是场次的核心生命周期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以，在不同的抽象角度、不同的抽象层次，根据分工的不同会有不同的核心业务活动、不同的核心实体，边界的确定关键在寻找核心的生命周期。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;寻找生命周期的过程，就是发现内聚的过程；将所有关于生命周期的业务活动累积，就可以提升领域或模块的内聚性。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;抽象的评估&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前边我们基本说清楚了抽象的角度、层次和边界，从三个维度确定了抽象的结果。那么如何评估抽象结果的好坏呢？答案是“高内聚，低耦合”，当然还有更多的原则，但是单从实践的角度，我觉得这是最最重要的。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;耦合是软件结构中各模块之间相互连接的一种度量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内聚是一个模块内部各成分之间相关联程度的度量&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;“高内聚，低耦合”从内部、外部两个视角去评估抽象结果的好坏。这其中也有对应的原则和方法论，常规的套路是：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;抽象的方法论（套路）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我想，至此，我们说清楚了前面的那两个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;总结前面说的所有关于抽象的内容，形成&lt;strong&gt;抽象的方法论：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抽象有两种方法，一种是自顶向下，另一种是自底向上&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务建模，是从小到大，从局部到整体，自底向上的归纳、演绎的抽象过程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统建模，是从大到小，从整体到局部，自顶向下的拆解、切分的抽象过程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;但不绝对，自上而下和自下而上，往往在过程中是随意切换的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面这张图来自于《Thinking in UML》，我觉得这个循环的过程可以表达上面这四个点，供大家参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj4419Hnqo72HJby5ibN2zVmicGibic3UZlic6SrwNBrRTrngSSo4FEXb1icGld3g/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;766&quot; data-cropy1=&quot;27.488038277511965&quot; data-cropy2=&quot;775.1626794258374&quot; data-ratio=&quot;0.9778067885117493&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441AcPoj7NVU4BGibhrP5PAxJYlYPSwo0cRPtbRic8DoSpDOED1eqicKmsdg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;如何画好一张架构图？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBcaFy7sGU6CictXmjCqrUaILaZUI9ElG7bgMib5QqrWtvvxmsJqWaicGlYpRrLS8PGmqibBa8NNv8kGuA/640?wx_fmt=png&quot; data-cropx1=&quot;38&quot; data-cropx2=&quot;218&quot; data-cropy1=&quot;-5&quot; data-cropy2=&quot;5&quot; data-fileid=&quot;100024892&quot; data-ratio=&quot;0.027777777777777776&quot; data-type=&quot;jpeg&quot; data-w=&quot;180&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vz1ttk8KwbTLmn6Mf3fKuS0JTf7DicxPGjJlNe3tzaBoEZCibDPw9sr17IS2p3pJBiblsToy1BHdJDphCahaP2ZmQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到主题，如果上边的问题说清楚了，接下来的事情就相对简单了。对于架构图是什么这个问题，我们可以把之前的等式进行延展：&lt;strong&gt;架构图 = 架构的表达 = 架构在不同抽象角度和不同抽象层次的表达&lt;/strong&gt;，这是一个自然而然的过程。不是先有图再有业务流程、系统设计和领域模型等，而是相反，&lt;strong&gt;用图来表达抽象的思考和内容。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么架构图有什么用？给谁看？回答这个问题需要讲清楚为什么要画架构图，同时也需要考虑一个问题就是：架构图是不是越多越好，越详细越好？&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;画架构图是为了什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;A picture is worth a thousand words (一图胜千言)，从 Why 层面讲，我觉得就是如下两点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但是上述两点其实是非常笼统的信息，如果放在 What 层面，我们必须要考虑架构图面对的“客户”，不同的客户有不同的诉求（其实也就是角度和层次），在不同的抽象层次架构图所表达的信息内容可以完全不一样。以目前团队做的事情为例，架构图的目标客户至少有几类：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以&lt;strong&gt;画架构图，我们必须首先明确沟通交流的目的和面向的客户，&lt;/strong&gt;只有明确了这两个点，才能更加有针对性地达成上边所说的那两点目标：解决沟通障碍，提升协作效率。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;怎么画？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、先说分类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构图分类，本质上是从不同的视角，不同的抽象角度去看，作出清晰、简化的描述，涵盖特点方面忽略无关方面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从业务应用开发的维度，一般的抽象层次可以分为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;业务全域—&amp;gt;子域—&amp;gt;模块—&amp;gt;子模块—&amp;gt;包—&amp;gt;类—&amp;gt;方法&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这其中：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，还有很多其他的分类方式，比如：RUP 4+1，GOGAF9 等等分类方式。&lt;strong&gt;单从实践的角度，我觉得何种分类不是最重要的，最重要的是想清楚面向谁和解决什么诉求，然后思考架构图到底从哪个角度、哪个层次去抽象。&lt;/strong&gt;我们目前所做的项目，有很多时候要去和国外的业务专家、技术专家沟通，大家也并没有一个明确的标准定义，表述清楚问题，达成共识是最最关键的，至于架构图的粒度、类别、内容可以逐步地迭代优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、再说构图&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;构图的部分，我们大家都用 UML 画过类图，涉及泛化、聚合、组合、依赖等等关系，分别用不同的虚实线、箭头样式进行表达。所以画架构图需要考虑架构图的组成元素，要保证符合一贯理解，架构图的组成元素可能涉及：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方框、各种形状、虚实线、箭头、颜色（不同颜色代表什么意思）和文字内容&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虚实线表达什么？组件类型，模块类型，层，服务，需要考虑是否已经实现等？不同状态的标识怎么传递？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;箭头表达什么?数据流或关联关系？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;交互类型可以是同步或异步的；关联类型可以是指依赖、继承、实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;构图最最重要的是需要考虑内容术语一致性问题、碎片化问题、信息粒度大小的问题，以及图表的外观问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如何评判架构图的好坏&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;架构图的好坏，我理解主要是两个方向，一个是需要跳出图本身去看，业务领域的抽象设计合理性，是否符合“高内聚，低耦合”的要求，这个需要回到前文的业务建模、系统建模和抽象过程去寻找答案。另外一个方向是图本身，以下几个点供参考：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内容术语一致、信息粒度大小一致，图例清晰，颜色类型统一，美观；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图中的信息与相应的抽象级别相关，且满足利益相关者(合作方)的需求；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一张好的架构图不需要多余的文字解释。受众有没有准确接收到想传递的信息；如果它所导致的疑问比它能解释的问题还要多，那么它就不是一张好的架构图；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;架构图应该帮助每个人看到大局，了解周围的环境，适当的上下文信息；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;架构图应该避免“只见树木不见森林”。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;最后也聊聊架构师&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBcaFy7sGU6CictXmjCqrUaILaZUI9ElG7bgMib5QqrWtvvxmsJqWaicGlYpRrLS8PGmqibBa8NNv8kGuA/640?wx_fmt=png&quot; data-cropx1=&quot;38&quot; data-cropx2=&quot;218&quot; data-cropy1=&quot;-5&quot; data-cropy2=&quot;5&quot; data-fileid=&quot;100024892&quot; data-ratio=&quot;0.027777777777777776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vz1ttk8KwbTLmn6Mf3fKuS0JTf7DicxPGjJlNe3tzaBoEZCibDPw9sr17IS2p3pJBiblsToy1BHdJDphCahaP2ZmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;180&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是来自于阿白老师的文章《架构师到底是做什么的？》，越是琢磨，越觉得深以为然。其中提到了好的架构师的画像和不好的画像，如下图，与大家共勉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;293&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.50546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441mjIueOGQkrGYyDviaC9y8ZIibfJ94gHRPGADdkHXiab75CVTFGDEicUib6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;从我个人的成长经历看，&lt;strong&gt;架构师很重要的一点要学会“权衡”，既要兼顾当下痛点也要符合未来一定时间的发展，既要保留未来的可扩展性也要避免过度设计。&lt;/strong&gt;选择什么样的时间节点、什么样的业务场景以及什么样的架构迭代策略至关重要，这些决策的关键在于判断和取舍，需要结合深刻的业务思考乃至组织架构去做权衡落地。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;和大家分享一点点不算经验的经验：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;快速学习&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;快不是一个速度问题，也是一个判断或者标准问题。面对一个全新业务场景，如何能够识别20%的关键业务路径、关键业务痛点，如何短时间把自己变成业务专家，这是一个架构师基本的素质。我的经验就是要去「吸金式」的思考，带着问题主动思考，客户是谁？有什么诉求？需要解决什么样的问题？我们能提供什么样的价值？多问为什么？这也需要长时间的刻意训练。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;不要屁股决定脑袋&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;要跨角色、跨层级去看待业务问题，这个点容易陷入说教，说实话我自己做得也未必到位。但是时刻提醒自己的思考是否被局限，在哪一个维度，是 Have-do-be，还是 be-do-Have ，同时要一直提醒自己不要屁股决定脑袋。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100025737&quot; data-ratio=&quot;1.0909090909090908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;11&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CoqxIF8TxBdGHPBice38SlYyYlBaEj1tKSARFeMLno5Uy7jr1zFpFnicKMqY4EWW91x0wiaToibLelOou3BETLZtzA/640?wx_fmt=png&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;提升思考能力和对于技术原理或本质的理解&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我觉得这是最底层的能力，业务开发中我觉得最大的两个难点：一是逻辑的复杂性，二是需求的变化性。我们不应该把大部分时间花在寻找解决方案上，而应该花更多的时间在选择解决方案上。这就要求我们对业务全局、行业深度、技术视野、技术深度、业务共性、个性特征等等形成自己的认知。权衡取舍，取什么舍什么？该怎么取怎么舍？那个度在哪里？唯有思考，自驱，累积和坚持，勇猛精进，志愿无倦。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;最后的最后&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;希望这篇文章对大家有帮助，附上最初在考虑这个主题时的构思过程及思考路径，供大家参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;382&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.6609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIBibiaCPNjJBiczoibTg9tj441SwxEIGeOyYpp1rjFvE280Hy8Z2BYfF89DliaO8CPJKxO91GnQ4Ymcqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101256&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;310:417&quot;&gt;END&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;   ……&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;加入读者群，请在公众号后台回复：&lt;strong&gt;读者群&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资料获取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 识别并关注下方公众号；&lt;br/&gt;2. 在下面公众号后台回复关键字「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」即可下载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;技术琐话 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxMzEzMjM5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nhlGsolibOWF3auwD2unWLZHOt6TeCJ1iboL4Po7ickwKsibk7WgicbkOxG7wibMw8ZsSMQtDpR9D3OsF2RKibxKN00Xg/0?wx_fmt=png&quot; data-nickname=&quot;技术琐话&quot; data-alias=&quot;TheoryPractice&quot; data-signature=&quot;最干货的java+分布式技术公众号，兼及研发管理。本号专家阵容：蚂蚁金服右军、NETSTARS CTO陈斌、江苏百瑞赢李伟山、前蚂蚁金服高级技术专家张翔、美团高级技术专家杨彪等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a979dde6a234599b29f32e6a6ab09160</guid>
<title>[推荐] 阿里10年沉淀｜那些技术实战中的架构设计方法</title>
<link>https://toutiao.io/k/e9vlh55</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;ali_tech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>33085700e02cec92060ed57a3b2edd69</guid>
<title>[推荐] 聊聊接口设计的36个小技巧</title>
<link>https://toutiao.io/k/yqm776v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;l前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是苏三。作为后端开发，不管是什么语言，&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;Go&lt;/code&gt;还是&lt;code&gt;C++&lt;/code&gt;，其背后的后端思想都是类似的。后面打算出一个后端思想的技术专栏，主要包括后端的一些设计、或者后端规范相关的，希望对大家日常工作有帮助哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们做后端开发工程师，主要工作就是：&lt;strong&gt;如何把一个接口设计好&lt;/strong&gt;。所以，今天就给大家介绍，设计好接口的36个锦囊。本文就是后端思想专栏的第一篇哈。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8443782576321668&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdHrWl1Oiaw2S7hpicOL0Vb4v5wHRCXejQwFArOlBdwSWic1YY4dQBZeATQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 接口参数校验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参出参校验是每个程序员必备的基本素养。你设计的接口，必须先校验参数。比如入参是否允许为空，入参长度是否符合你的预期长度。这个要养成习惯哈，日常开发中，很多低级bug都是不校验参数导致的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如你的数据库表字段设置为&lt;code&gt;varchar(16)&lt;/code&gt;,对方传了一个32位的字符串过来，如果你不校验参数，&lt;strong&gt;插入数据库直接异常了&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出参也是，比如你定义的接口报文，参数是不为空的，但是你的接口返回参数，没有做校验，因为程序某些原因，直返回别人一个&lt;code&gt;null&lt;/code&gt;值。。。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7933333333333333&quot; data-type=&quot;gif&quot; data-w=&quot;150&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdreK8hYeFhMDP8HUJQ7lBszcb85BG3zdgtUGdeHQn4ic5EGMRJMIEZDQ/640?wx_fmt=gif&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 修改老接口时，注意接口的兼容性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多bug都是因为修改了对外旧接口，但是却&lt;strong&gt;不做兼容&lt;/strong&gt;导致的。关键这个问题多数是比较严重的，可能直接导致系统发版失败的。新手程序员很容易犯这个错误哦~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7916666666666666&quot; data-type=&quot;png&quot; data-w=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdtoaYQsvtjUX6oGmJbReda6qJlJM1I98DL44R6Tp2vnsR59NTt96g1g/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果你的需求是在原来接口上修改，尤其这个接口是对外提供服务的话，一定要考虑接口兼容。举个例子吧，比如dubbo接口，原本是只接收A，B参数，现在你加了一个参数C，就可以考虑这样处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//老接口&lt;br/&gt;void oldService(A,B){&lt;br/&gt;  //兼容新接口，传个null代替C&lt;br/&gt;  newService(A,B,null);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//新接口，暂时不能删掉老接口，需要做兼容。&lt;br/&gt;void newService(A,B,C){&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.  设计接口时，充分考虑接口的可扩展性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要根据实际业务场景设计接口，充分考虑接口的可扩展性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你接到一个需求：是用户添加或者修改员工时，需要刷脸。那你是反手提供一个员工管理的提交刷脸信息接口？还是先思考：提交刷脸是不是通用流程呢？比如转账或者一键贴现需要接入刷脸的话，你是否需要重新实现一个接口呢？还是当前按业务类型划分模块，复用这个接口就好，保留接口的可扩展性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果按模块划分的话，未来如果其他场景比如一键贴现接入刷脸的话，不用再搞一套新的接口，只需要新增枚举，然后复用刷脸通过流程接口，实现一键贴现刷脸的差异化即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4934696195343555&quot; data-type=&quot;png&quot; data-w=&quot;1761&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdQZdAGK3sj9C1EZUYayIQKX4NTBIZ51vlVaITsR1P9uQtibA42h5f9nQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.接口考虑是否需要防重处理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果前端重复请求，你的逻辑如何处理？是不是考虑接口去重处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果是查询类的请求，其实不用防重。如果是更新修改类的话，尤其金融转账类的，就要过滤重复请求了。简单点，你可以使用Redis防重复请求，同样的请求方，一定时间间隔内的相同请求，考虑是否过滤。当然，转账类接口，并发不高的话，&lt;strong&gt;推荐使用数据库防重表&lt;/strong&gt;，以&lt;strong&gt;唯一流水号作为主键或者唯一索引&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37011173184357543&quot; data-type=&quot;png&quot; data-w=&quot;716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdUJvMPHnj5mpLpgH8o1pRxfyL0Q7mr4PNcePwLEibYIPpxROfN5hIyrg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 重点接口，考虑线程池隔离。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些登陆、转账交易、下单等重要接口，考虑线程池隔离哈。如果你所有业务都共用一个线程池，有些业务出bug导致线程池阻塞打满的话，那就杯具了，&lt;strong&gt;所有业务都影响了&lt;/strong&gt;。因此进行线程池隔离，重要业务分配多一点的核心线程，就更好保护重要业务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3845454545454545&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdPiazEAHIKgvhaYpJoa6o3bXSzbrFqdjgcgEFdFBB7ntrl7wZuLsiawag/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 调用第三方接口要考虑异常和超时处理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你调用第三方接口，或者分布式远程服务的的话，需要考虑：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如，你调别人的接口，如果异常了，怎么处理，是重试还是当做失败还是告警处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;没法预估对方接口一般多久返回，一般设置个超时断开时间，以保护你的接口。&lt;strong&gt;之前见过一个生产问题&lt;/strong&gt;，就是http调用不设置超时时间，最后响应方进程假死，请求一直占着线程不释放，拖垮线程池。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你的接口调失败，需不需要重试？重试几次？需要站在业务上角度思考这个问题&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6174496644295302&quot; data-type=&quot;gif&quot; data-w=&quot;298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdaHcCQm2HDIPNQJwS58B4b4Wv8CCbOkjnnUj8V3LOusaANY5PMJYtcw/640?wx_fmt=gif&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 接口实现考虑熔断和降级&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前互联网系统一般都是分布式部署的。而分布式系统中经常会出现某个基础服务不可用，最终导致整个系统不可用的情况, 这种现象被称为&lt;strong&gt;服务雪崩效应&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如分布式调用链路&lt;code&gt;A-&amp;gt;B-&amp;gt;C....&lt;/code&gt;，下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5128983308042488&quot; data-type=&quot;png&quot; data-w=&quot;659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpd8YswPLVF768Tsia939UnlzYxicwqgr4Vb3ibBsmRnHZPhqfTWZXsjBibeA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果服务C出现问题，比如是&lt;strong&gt;因为慢SQL导致调用缓慢&lt;/strong&gt;，那将导致B也会延迟，从而A也会延迟。堵住的A请求会消耗占用系统的线程、IO等资源。当请求A的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了应对服务雪崩, 常见的做法是&lt;strong&gt;熔断和降级&lt;/strong&gt;。最简单是加开关控制，当下游系统出问题时，开关降级，不再调用下游系统。还可以选用开源组件&lt;code&gt;Hystrix&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 日志打印好，接口的关键代码，要有日志保驾护航。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键业务代码无论身处何地，都应该有足够的日志保驾护航。比如：你实现转账业务，转个几百万，然后转失败了，接着客户投诉，然后你还没有打印到日志，想想那种水深火热的困境下，你却毫无办法。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，你的转账业务都需要哪些日志信息呢？至少，方法调用前，入参需要打印需要吧，接口调用后，需要捕获一下异常吧，同时打印异常相关日志吧，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void transfer(TransferDTO transferDTO){&lt;br/&gt;    log.info(&lt;span&gt;&quot;invoke tranfer begin&quot;&lt;/span&gt;);&lt;br/&gt;    //打印入参&lt;br/&gt;    log.info(&lt;span&gt;&quot;invoke tranfer,paramters:{}&quot;&lt;/span&gt;,transferDTO);&lt;br/&gt;    try {&lt;br/&gt;      res=  transferService.transfer(transferDTO);&lt;br/&gt;    }catch(Exception e){&lt;br/&gt;     log.error(&lt;span&gt;&quot;transfer fail,account：{}&quot;&lt;/span&gt;,&lt;br/&gt;     transferDTO.getAccount（）)&lt;br/&gt;     log.error(&lt;span&gt;&quot;transfer fail,exception:{}&quot;&lt;/span&gt;,e);&lt;br/&gt;    }&lt;br/&gt;    log.info(&lt;span&gt;&quot;invoke tranfer end&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前写过一篇打印日志的15个建议，大家可以看看哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247494838&amp;amp;idx=1&amp;amp;sn=cdb15fd346bddf3f8c1c99f0efbd67d8&amp;amp;chksm=cf22339ff855ba891616c79d4f4855e228e34a9fb45088d7acbe421ad511b8d090a90f5b019f&amp;amp;token=162724582&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;工作总结！日志打印的15个建议&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 接口的功能定义要具备单一性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单一性是指接口做的事情比较单一、专一。比如一个登陆接口，它做的事情就只是校验账户名密码，然后返回登陆成功以及&lt;code&gt;userId&lt;/code&gt;即可。&lt;strong&gt;但是如果你为了减少接口交互，把一些注册、一些配置查询等全放到登陆接口，就不太妥。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这也是微服务一些思想，接口的功能单一、明确。比如订单服务、积分、商品信息相关的接口都是划分开的。将来拆分微服务的话，是不是就比较简便啦。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.接口有些场景，使用异步更合理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个简单的例子，比如你实现一个用户注册的接口。用户注册成功时，发个邮件或者短信去通知用户。这个邮件或者发短信，就更适合异步处理。因为总不能一个通知类的失败，导致注册失败吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于做异步的方式，简单的就是&lt;strong&gt;用线程池&lt;/strong&gt;。还可以使用消息队列，就是用户注册成功后，生产者产生一个注册成功的消息，消费者拉到注册成功的消息，就发送通知。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2038327526132404&quot; data-type=&quot;png&quot; data-w=&quot;1148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdoQxBiczYHqAa1EEU2m8Mb5Zp47bFWzpBwSOjtHx6wCNRebiaZ5hHibspw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不是所有的接口都适合设计为同步接口。比如你要做一个转账的功能，如果你是单笔的转账，你是可以把接口设计同步。用户发起转账时，客户端在静静等待转账结果就好。如果你是批量转账，一个批次一千笔，甚至一万笔的，你则可以把接口设计为异步。就是用户发起批量转账时，持久化成功就先返回受理成功。然后用户隔十分钟或者十五分钟等再来查转账结果就好。又或者，批量转账成功后，再回调上游系统。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44280442804428044&quot; data-type=&quot;png&quot; data-w=&quot;813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdBtDw9Yible4HIThFHj9stia1iaTLC3XNXn6PHwTBxXL1AU4XcKv8nhLAA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. 优化接口耗时，远程串行考虑改并行调用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们设计一个APP首页的接口，它需要查用户信息、需要查banner信息、需要查弹窗信息等等。那你是一个一个接口串行调，还是并行调用呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2056239015817223&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdT2V3RMiavvZnKM6aibzI9VicpsETGxiaaicbvuwlHzaau0IzSW6Sia2iaFV7w/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是串行一个一个查，比如查用户信息200ms，查banner信息100ms、查弹窗信息50ms，那一共就耗时&lt;code&gt;350ms&lt;/code&gt;了，如果还查其他信息，那耗时就更大了。这种场景是可以改为并行调用的。也就是说查用户信息、查banner信息、查弹窗信息，可以同时发起。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5670731707317073&quot; data-type=&quot;png&quot; data-w=&quot;820&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdbkvw3UO2e6WL0ZYsVVyHw3kpFERdVY2es04w1IETXicuPbj4TcDGVBw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中有个异步编程利器：&lt;code&gt;CompletableFuture&lt;/code&gt;，就可以很好实现这个功能。有兴趣的小伙伴可以看我之前这个文章哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247490456&amp;amp;idx=1&amp;amp;sn=95836324db57673a4d7aea4fb233c0d2&amp;amp;chksm=cf21c4b1f8564da72dc7b39279362bcf965b1374540f3b339413d138599f7de59a5f977e3b0e&amp;amp;token=1260947715&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;CompletableFuture详解&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12. 接口合并或者说考虑批量处理思想&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库操作或或者是远程调用时，能批量操作就不要for循环调用。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0433333333333332&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdgc2flibD2xrMbfvMVnpC3mmQYDDH7MwmHkkuzqabmiasib6iaQqPMM3VuA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单例子，我们平时一个列表明细数据插入数据库时，不要在for循环一条一条插入，建议一个批次几百条，进行批量插入。同理远程调用也类似想法，比如你查询营销标签是否命中，可以一个标签一个标签去查，也可以批量标签去查，那批量进行，效率就更高嘛。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//反例&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(int i=0;i&amp;lt;n;i++){&lt;br/&gt;  remoteSingleQuery(param)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//正例&lt;br/&gt;remoteBatchQuery(param);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙伴们是否了解过&lt;code&gt;kafka&lt;/code&gt;为什么这么快呢？其实其中一点原因，就是kafka&lt;strong&gt;使用批量消息&lt;/strong&gt;提升服务端处理能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13. 接口实现过程中，恰当使用缓存&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪些场景适合使用缓存？&lt;strong&gt;读多写少且数据时效要求越低的场景&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存用得好，可以承载更多的请求，提升查询效率，减少数据库的压力。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如一些平时变动很小或者说几乎不会变的商品信息，可以放到缓存，请求过来时，先查询缓存，如果没有再查数据库，并且把数据库的数据更新到缓存。但是，使用缓存增加了需要考虑这些点：缓存和数据库一致性如何保证、集群、缓存击穿、缓存雪崩、缓存穿透等问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;保证数据库和缓存一致性：&lt;strong&gt;缓存延时双删、删除缓存重试机制、读取biglog异步删除缓存&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存击穿：设置数据永不过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存&lt;span&gt;雪崩&lt;/span&gt;：Redis集群高可用、均匀设置过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存穿透：接口层校验、查询为空设置个默认空值标记、布隆过滤器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般用&lt;code&gt;Redis&lt;/code&gt;分布式缓存，当然有些时候也可以考虑使用本地缓存，如&lt;code&gt;Guava Cache、Caffeine&lt;/code&gt;等。使用本地缓存有些缺点，就是无法进行大数据存储，并且应用进程的重启，缓存会失效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14. 接口考虑热点数据隔离性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;瞬时间的高并发，可能会打垮你的系统。可以做一些热点数据的隔离。比如&lt;strong&gt;业务隔离、系统隔离、用户隔离、数据隔离&lt;/strong&gt;等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务隔离性，比如12306的分时段售票，将热点数据分散处理，降低系统负载压力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统隔离：比如把系统分成了用户、商品、社区三个板块。这三个块分别使用不同的域名、服务器和数据库，做到从接入层到应用层再到数据层三层完全隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户隔离：重点用户请求到配置更好的机器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据隔离：使用单独的缓存集群或者数据库服务热点数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. 可变参数配置化，比如红包皮肤切换等&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如产品经理提了个红包需求，圣诞节的时候，红包皮肤为圣诞节相关的，春节的时候，为春节红包皮肤等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在代码写死控制，可有类似以下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(duringChristmas){&lt;br/&gt;   img = redPacketChristmasSkin;&lt;br/&gt;}&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(duringSpringFestival){&lt;br/&gt;   img =  redSpringFestivalSkin;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果到了元宵节的时候，运营小姐姐突然又有想法，红包皮肤换成灯笼相关的，这时候，是不是要去修改代码了，重新发布了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从一开始接口设计时，可以实现&lt;strong&gt;一张红包皮肤的配置表&lt;/strong&gt;，将红包皮肤做成配置化呢？更换红包皮肤，只需修改一下表数据就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，还有一些场景适合一些配置化的参数：一个分页多少数量控制、某个抢红包多久时间过期这些，都可以搞到参数配置化表里面。&lt;strong&gt;这也是扩展性思想的一种体现。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.接口考虑幂等性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口是需要考虑幂等性的，尤其抢红包、转账这些重要接口。最直观的业务场景，就是&lt;strong&gt;用户连着点击两次&lt;/strong&gt;，你的接口有没有&lt;strong&gt;hold住&lt;/strong&gt;。或者消息队列出现重复消费的情况，你的业务逻辑怎么控制？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回忆下，&lt;strong&gt;什么是幂等？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;计算机科学中，幂等表示一次和多次请求某一个资源应该具有同样的副作用，或者说，多次请求所产生的影响与一次请求执行的影响效果相同。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家别搞混哈，&lt;strong&gt;防重和幂等设计其实是有区别的&lt;/strong&gt;。防重主要为了避免产生重复数据，把重复请求拦截下来即可。而幂等设计除了拦截已经处理的请求，还要求每次相同的请求都返回一样的效果。不过呢，很多时候，它们的处理流程、方案是类似的哈。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdhJNGyOUwiaicpD6Q1Rvzz9yVhXDYHIcyGibER7y1P6KCviatIlb2355pyw/640?wx_fmt=gif&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口幂等实现方案主要有8种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;select+insert+主键/唯一索引冲突&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接insert + 主键/唯一索引冲突&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态机幂等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;抽取防重表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;token令牌&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;悲观锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;乐观锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以看我这篇文章哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247497427&amp;amp;idx=1&amp;amp;sn=2ed160c9917ad989eee1ac60d6122855&amp;amp;chksm=cf2229faf855a0ecf5eb34c7335acdf6420426490ee99fc2b602d54ff4ffcecfdab24eeab0a3&amp;amp;token=1260947715&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊幂等设计&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17. 读写分离，优先考虑读从库，注意主从延迟问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的数据库都是集群部署的，有主库也有从库，当前一般都是读写分离的。比如你写入数据，肯定是写入主库，但是对于读取实时性要求不高的数据，则优先考虑读从库，因为可以分担主库的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果读取从库的话，需要考虑主从延迟的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.接口注意返回的数据量，如果数据量大需要分页&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个接口返回报文，不应该包含过多的数据量。过多的数据量不仅处理复杂，并且数据量传输的压力也非常大。因此数量实在是比较大，可以分页返回，如果是功能不相关的报文，那应该考虑接口拆分。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19. 好的接口实现，离不开SQL优化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们做后端的，写好一个接口，离不开SQL优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL优化从这几个维度思考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;explain 分析SQL查询计划（重点关注type、extra、filtered字段）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;show profile分析，了解SQL执行的线程的状态以及消耗的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引优化 （覆盖索引、最左前缀原则、隐式转换、order by以及group by的优化、join优化）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大分页问题优化（延迟关联、记录上一页最大ID）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据量太大（&lt;strong&gt;分库分表&lt;/strong&gt;、同步到es，用es查询）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.代码锁的粒度控制好&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是加锁粒度呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;其实就是就是你要锁住的范围是多大。比如你在家上卫生间，你只要锁住卫生间就可以了吧，不需要将整个家都锁起来不让家人进门吧，卫生间就是你的加锁粒度。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们写代码时，如果不涉及到共享资源，就没有必要锁住的。这就好像你上卫生间，不用把整个家都锁住，锁住卫生间门就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，在业务代码中，有一个ArrayList因为涉及到多线程操作，所以需要加锁操作，假设刚好又有一段比较耗时的操作（代码中的&lt;code&gt;slowNotShare&lt;/code&gt;方法）不涉及线程安全问题，你会如何加锁呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//不涉及共享资源的慢方法&lt;br/&gt;private void &lt;span&gt;&lt;span&gt;slowNotShare&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    try {&lt;br/&gt;        TimeUnit.MILLISECONDS.sleep(100);&lt;br/&gt;    } catch (InterruptedException e) {&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//错误的加锁方法&lt;br/&gt;public int &lt;span&gt;&lt;span&gt;wrong&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    long beginTime = System.currentTimeMillis();&lt;br/&gt;    IntStream.rangeClosed(1, 10000).parallel().forEach(i -&amp;gt; {&lt;br/&gt;        //加锁粒度太粗了，slowNotShare其实不涉及共享资源&lt;br/&gt;        synchronized (this) {&lt;br/&gt;            slowNotShare();&lt;br/&gt;            data.add(i);&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    log.info(&lt;span&gt;&quot;cosume time:{}&quot;&lt;/span&gt;, System.currentTimeMillis() - beginTime);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; data.size();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public int &lt;span&gt;&lt;span&gt;right&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    long beginTime = System.currentTimeMillis();&lt;br/&gt;    IntStream.rangeClosed(1, 10000).parallel().forEach(i -&amp;gt; {&lt;br/&gt;        slowNotShare();//可以不加锁&lt;br/&gt;        //只对List这部分加锁&lt;br/&gt;        synchronized (data) {&lt;br/&gt;            data.add(i);&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    log.info(&lt;span&gt;&quot;cosume time:{}&quot;&lt;/span&gt;, System.currentTimeMillis() - beginTime);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; data.size();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.接口状态和错误需要统一明确&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供必要的接口调用状态信息。比如你的一个转账接口调用是成功、失败、处理中还是受理成功等，需要明确告诉客户端。如果接口失败，那么具体失败的原因是什么。这些必要的信息都必须要告诉给客户端，因此需要定义明确的错误码和对应的描述。同时，尽量对报错信息封装一下，不要把后端的异常信息完全抛出到客户端。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6051282051282051&quot; data-type=&quot;png&quot; data-w=&quot;975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdzFZ69ufhLVpJa3oxOKUDia0acvqia0GJOCRqKwlRz7qxdibtzrQ7TU4kg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.接口要考虑异常处理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现一个好的接口，离不开优雅的异常处理。对于异常处理，提十个小建议吧：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;尽量不要使用&lt;code&gt;e.printStackTrace()&lt;/code&gt;,而是使用&lt;code&gt;log&lt;/code&gt;打印。因为&lt;code&gt;e.printStackTrace()&lt;/code&gt;语句可能会导致内存占满。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;catch&lt;/code&gt;住异常时，建议打印出具体的&lt;code&gt;exception&lt;/code&gt;，利于更好定位问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要用一个&lt;code&gt;Exception&lt;/code&gt;捕捉所有可能的异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;记得使用&lt;code&gt;finally&lt;/code&gt;关闭流资源或者直接使用&lt;code&gt;try-with-resource&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;捕获到的异常，不能忽略它，至少打点日志吧&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意异常对你的代码层次结构的侵染&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义封装异常，不要丢弃原始异常的信息&lt;code&gt;Throwable cause&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行时异常&lt;code&gt;RuntimeException&lt;/code&gt; ，不应该通过&lt;code&gt;catch&lt;/code&gt;的方式来处理，而是先预检查，比如：&lt;code&gt;NullPointerException&lt;/code&gt;处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意异常匹配的顺序，优先捕获具体的异常&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙伴们有兴趣可以看下我之前写的这篇文章哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247488009&amp;amp;idx=1&amp;amp;sn=7c27849c67476143660e3ea0dcdfae3d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Java 异常处理的十个建议&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23. 优化程序逻辑&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化程序逻辑这块还是挺重要的，也就是说，你实现的业务代码，&lt;strong&gt;如果是比较复杂的话，建议把注释写清楚&lt;/strong&gt;。还有，代码逻辑尽量清晰，代码尽量高效。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如，你要使用用户信息的属性，你根据session已经获取到&lt;code&gt;userId&lt;/code&gt;了，然后就把用户信息从数据库查询出来，使用完后，后面可能又要用到用户信息的属性，有些小伙伴没想太多，反手就把&lt;code&gt;userId&lt;/code&gt;再传进去，再查一次数据库。。。我在项目中，见过这种代码。。。直接把用户对象传下来不好嘛。。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public Response &lt;span&gt;test&lt;/span&gt;(Session session){&lt;br/&gt;    UserInfo user = UserDao.queryByUserId(session.getUserId());&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(user==null){&lt;br/&gt;       reutrn new Response();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;(session.getUserId());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public Response &lt;span&gt;do&lt;/span&gt;(String UserId){&lt;br/&gt;  //多查了一次数据库&lt;br/&gt;  UserInfo user = UserDao.queryByUserId(session.getUserId());&lt;br/&gt;  ......&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; new Response(); &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public Response &lt;span&gt;test&lt;/span&gt;(Session session){&lt;br/&gt;    UserInfo user = UserDao.queryByUserId(session.getUserId());&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(user==null){&lt;br/&gt;       reutrn new Response();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;(session.getUserId());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//直接传UserInfo对象过来即可，不用再多查一次数据库&lt;br/&gt;public Response &lt;span&gt;do&lt;/span&gt;(UserInfo user){&lt;br/&gt;  ......&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; new Response(); &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这只是一些很小的一个例子，还有很多类似的例子，需要大家开发过程中，多点思考的哈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24. 接口实现过程中，注意大文件、大事务、大对象&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读取大文件时，不要&lt;code&gt;Files.readAllBytes&lt;/code&gt;直接读取到内存，这样会OOM的，建议使用&lt;code&gt;BufferedReader&lt;/code&gt;一行一行来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大事务可能导致死锁、回滚时间长、主从延迟等问题，开发中尽量避免大事务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意一些大对象的使用，因为大对象是直接进入老年代的，可能会触发fullGC&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25. 你的接口，需要考虑限流&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的系统每秒扛住的请求是1000，如果一秒钟来了十万请求呢？换个角度就是说，高并发的时候，流量洪峰来了，超过系统的承载能力，怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不采取措施，所有的请求打过来，系统CPU、内存、Load负载飚的很高，最后请求处理不过来，所有的请求无法正常响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种场景，我们可以采用限流方案。就是为了保护系统，多余的请求，直接丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流定义：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用Guava的&lt;code&gt;RateLimiter&lt;/code&gt;单机版限流，也可以使用&lt;code&gt;Redis&lt;/code&gt;分布式限流，还可以使用阿里开源组件&lt;code&gt;sentinel&lt;/code&gt;限流&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以看下我之前这篇文章哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247490393&amp;amp;idx=1&amp;amp;sn=98189caa486406f8fa94d84ba0667604&amp;amp;chksm=cf21c470f8564d665ce04ccb9dc7502633246da87a0541b07ba4ac99423b28ce544cdd6c036b&amp;amp;token=162724582&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4种经典限流算法讲解&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.代码实现时，注意运行时异常（比如空指针、下标越界等）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，我们需要采取措施&lt;strong&gt;规避数组边界溢出，被零整除，空指针&lt;/strong&gt;等运行时错误。类似代码比较常见：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String name = list.get(1).getName(); //list可能越界，因为不一定有2个元素哈&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该采取措施，预防一下数组边界溢出。正例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(CollectionsUtil.isNotEmpty(list)&amp;amp;&amp;amp; list.size()&amp;gt;1){&lt;br/&gt;  String name = list.get(1).getName(); &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.95&quot; data-type=&quot;png&quot; data-w=&quot;280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpd6upNCOzmYTazr6H8pDta2VUJLHq0SMCBFmIBmMVo7hDorrObibK6XYw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.保证接口安全性&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的API接口是对外提供的，需要保证接口的安全性。保证接口的安全性有&lt;strong&gt;token机制和接口签名&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;token机制身份验证&lt;/strong&gt;方案还比较简单的，就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981481481481481&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdeujCpQs8KLHTQN0sDyqiaRIuMbo71Nh3jOxFnRibvXXNOtb7OaRPaaXg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端发起请求，申请获取token。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端生成全局唯一的token，保存到redis中（一般会设置一个过期时间），然后返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端带着token，发起请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端去redis确认token是否存在，一般用 redis.del(token)的方式，如果存在会删除成功，即处理业务逻辑，如果删除失败不处理业务逻辑，直接返回结果。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口签名&lt;/strong&gt;的方式，就是把接口请求相关信息（请求报文，包括请求时间戳、版本号、appid等），客户端私钥加签，然后服务端用公钥验签，验证通过才认为是合法的、没有被篡改过的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关于加签验签的，大家可以看下我这篇文章哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247488022&amp;amp;idx=1&amp;amp;sn=70484a48173d36006c8db1dfb74ab64d&amp;amp;chksm=cf21cd3ff8564429a1205f6c1d78757faae543111c8461d16c71aaee092fe3e0fed870cc5e0e&amp;amp;token=162724582&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;程序员必备基础：加签验签&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&lt;strong&gt;加签验签和token机制，接口报文一般是要加密的&lt;/strong&gt;。当然，用https协议是会对报文加密的。如果是我们服务层的话，如何加解密呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;可以参考HTTPS的原理，就是服务端把公钥给客户端，然后客户端生成对称密钥，接着客户端用服务端的公钥加密对称密钥，再发到服务端，服务端用自己的私钥解密，得到客户端的对称密钥。这时候就可以愉快传输报文啦，客户端用&lt;strong&gt;对称密钥加密请求报文&lt;/strong&gt;，&lt;strong&gt;服务端用对应的对称密钥解密报文&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，接口的安全性，还包括&lt;strong&gt;手机号、身份证等信息的脱敏&lt;/strong&gt;。就是说，&lt;strong&gt;用户的隐私数据，不能随便暴露&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.分布式事务，如何保证&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分布式事务：就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单来说，分布式事务指的就是分布式系统中的事务，它的存在就是为了保证不同数据库节点的数据一致性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式事务的几种解决方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;2PC(二阶段提交)方案、3PC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCC（Try、Confirm、Cancel）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地消息表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大努力通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;seata&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以看下这篇文章哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247498358&amp;amp;idx=1&amp;amp;sn=aa6c7ceb61b73267d68d1b4fb7ccc2ed&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;看一遍就理解：分布式事务详解&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29. 事务失效的一些经典场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的接口开发过程中，经常需要使用到事务。所以需要避开事务失效的一些经典场景。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;方法的访问权限必须是public，其他private等权限，事务失效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法被定义成了final的，这样会导致事务失效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在同一个类中的方法直接内部调用，会导致事务失效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个方法如果没交给spring管理，就不会生成spring事务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程调用，两个方法不在同一个线程中，获取到的数据库连接不一样的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表的存储引擎不支持事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果自己try...catch误吞了异常，事务失效。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误的传播特性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐大家看下这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247494570&amp;amp;idx=2&amp;amp;sn=17357bcd328b2d1d83f4a72c47daac1b&amp;amp;chksm=cf223483f855bd95351a778d5f48ddd37917ce2790ebbbcd1d6ee4f27f7f4b147f0d41101dcc&amp;amp;token=2044040586&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊spring事务失效的12种场景，太坑了&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30. 掌握常用的设计模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把代码写好，还是需要熟练常用的设计模式，比如策略模式、工厂模式、模板方法模式、观察者模式等等。设计模式，是代码设计经验的总结。使用设计模式可以可重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前写过一篇总结工作中常用设计模式的文章，写得挺不错的，大家可以看下：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247495616&amp;amp;idx=1&amp;amp;sn=e74c733d26351eab22646e44ea74d233&amp;amp;chksm=cf2230e9f855b9ffe1ddb9fe15f72a273d5de02ed91cc97f3066d4162af027299718e2bf748e&amp;amp;token=1260947715&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;实战！工作中常用到哪些设计模式&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31. 写代码时，考虑线性安全问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;高并发&lt;/strong&gt;情况下，&lt;code&gt;HashMap&lt;/code&gt;可能会出现死循环。因为它是非线性安全的，可以考虑使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。所以这个也尽量养成习惯，不要上来反手就是一个&lt;code&gt;new HashMap()&lt;/code&gt;;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Hashmap、Arraylist、LinkedList、TreeMap等都是线性不安全的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vector、Hashtable、ConcurrentHashMap等都是线性安全的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9540540540540541&quot; data-type=&quot;png&quot; data-w=&quot;370&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwtZZzVTaZ1SJg4ytV0rhpdd0qF9txicn0icllddBtYLr3dMmkM4JXkWgJYFcrguPOs7xOb5Lhv4icqg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.接口定义清晰易懂，命名规范。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们写代码，不仅仅是为了实现当前的功能，也要有利于后面的维护。说到维护，代码不仅仅是写给自己看的，也是给别人看的。所以接口定义要清晰易懂，命名规范。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33. 接口的版本控制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口要做好版本控制。就是说，请求基础报文，应该包含&lt;code&gt;version&lt;/code&gt;接口版本号字段，方便未来做接口兼容。其实这个点也算接口扩展性的一个体现点吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如客户端APP某个功能优化了，新老版本会共存，这时候我们的&lt;code&gt;version&lt;/code&gt;版本号就派上用场了，对&lt;code&gt;version&lt;/code&gt;做升级，做好版本控制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34. 注意代码规范问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意一些常见的代码坏味道：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;大量重复代码（抽共用方法，设计模式）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法参数过多（可封装成一个DTO对象）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法过长（抽小函数）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断条件太多（优化if...else）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不处理没用的代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不注重代码格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免过度设计&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的坏味道，这里我都写到啦：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247490148&amp;amp;idx=1&amp;amp;sn=00a181bf74313f751b3ea15ebc303545&amp;amp;chksm=cf21c54df8564c5bc5b4600fce46619f175f7ae557956f449629c470a08e20580feef4ea8d53&amp;amp;token=162724582&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;25种代码坏味道总结+优化示例&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;35.保证接口正确性，其实就是保证更少的bug&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证接口的正确性，换个角度讲，就是保证更少的bug，甚至是没有bug。所以接口开发完后，一般需要开发&lt;strong&gt;自测一下&lt;/strong&gt;。然后的话，接口的正确还体现在，多线程并发的时候，&lt;strong&gt;保证数据的正确性&lt;/strong&gt;,等等。比如你做一笔转账交易，扣减余额的时候，可以通过CAS乐观锁的方式保证余额扣减正确吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是实现秒杀接口，得防止超卖问题吧。你可以使用Redis分布式锁防止超卖问题。使用Redis分布式锁，有几个注意要点，大家可以看下我之前这篇文章哈：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247488142&amp;amp;idx=1&amp;amp;sn=79a304efae7a814b6f71bbbc53810c0c&amp;amp;chksm=cf21cda7f85644b11ff80323defb90193bc1780b45c1c6081f00da85d665fd9eb32cc934b5cf&amp;amp;token=162724582&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;七种方案！探讨Redis分布式锁的正确使用姿势&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;36.学会沟通，跟前端沟通，跟产品沟通&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把这一点放到最后，学会沟通是非常非常重要的。比如你开发定义接口时，&lt;strong&gt;一定不能上来就自己埋头把接口定义完了&lt;/strong&gt;，&lt;strong&gt;需要跟客户端先对齐接口&lt;/strong&gt;。遇到一些难点时，跟技术leader对齐方案。实现需求的过程中，有什么问题，及时跟产品沟通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之就是，开发接口过程中，一定要沟通好~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后(求关注，别白嫖我)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，求一键三连：点赞、转发、在看，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e4288d5ebf5fa4086f6234a95e84ecb2</guid>
<title>[推荐] 关于技术能力的思考和总结</title>
<link>https://toutiao.io/k/jo2jtja</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;ali_tech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>