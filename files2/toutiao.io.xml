<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ce296fb34058beaa93d36b4abba0f67e</guid>
<title>技术变化那么快，如何做到不被淘汰呢？</title>
<link>https://toutiao.io/k/8958dqc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;作为程序员，技术变化那么快，如何做到不被淘汰呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav94sFJmRfZmWtb6Z7heu46zN3fozSgjLyDuicyEokozKXKQ3YCagOicLcHDylwhnWMTWesHo5XaKIJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数位上市公司 CTO 都在订阅的「码农周刊 VIP 会员专属邮件周报」，了解一下？&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！还没加入的，抓紧时间啦！&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;260&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavibNJDoLvVWUq6RKn5LwtlzRHSMFBED29234hRwibmOzJF4XxKOv5lzRVCelQJIEIOaXh3vYRHOMRzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a25fd535a30bdad555fb2d005505cac2</guid>
<title>分布式搜索引擎 Elasticsearch 的架构分析</title>
<link>https://toutiao.io/k/j4aoyho</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、写在前面&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt; ES（Elasticsearch下文统一称为ES）越来越多的企业在业务场景是使用ES存储自己的非结构化数据，例如电商业务实现商品站内搜索，数据指标分析，日志分析等，ES作为传统关系型数据库的补充，提供了关系型数据库不具备的一些能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES最先进入大众视野的是其能够实现全文搜索的能力，也是由于基于Lucene的实现，内部有一种倒排索引的数据结构。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文作者将介绍ES的分布式架构，以及ES的存储索引机制，本文不会详细介绍ES的API，会从整体架构层面进行分析，后续作者会有其他文章对ES的使用进行介绍。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、什么是倒排索引&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;要讲明白什么是倒排索引，首先我们先梳理下什么索引，比如一本书，书的目录页，有章节，章节名称，我们想看哪个章节，我们通过目录页，查到对应章节和页码，就能定位到具体的章节内容，通过目录页的章节名称查到章节的页码，进而看到章节内容，这个过程就是一个索引的过程，那么什么是倒排索引呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如查询《java编程思想》这本书的文章，翻开书本可以看到目录页，记录这个章节名字和章节地址页码，通过查询章节名字“继承”可以定位到“继承”这篇章节的具体地址，查看到文章的内容，我们可以看到文章内容中包含很多“对象”这个词。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么如果我们要在这本书中查询所有包含有“对象”这个词的文章，那该怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按照现在的索引方式无疑大海捞针，假设我们有一个“对象”--→文章的映射关系，不就可以了吗？类似这样的反向建立映射关系的就叫倒排索引。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如图1所示，将文章进行分词后得到关键词，在根据关键词建立倒排索引，关键词构建成一个词典，词典中存放着一个个词条（关键词），每个关键词都有一个列表与其对应，这个列表就是倒排表，存放的是章节文档编号和词频等信息，倒排列表中的每个元素就是一个倒排项，最后可以看到，整个倒排索引就像一本新华字典，所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件被称之为倒排文件。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.61875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSI7oibNs8pACX2nnvzUz12ErCz3U8FBCkpA7kbpTzpsdvBcPEIK58ic8YQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图1）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;词典和倒排文件是Lucene的两种基本数据结构，但是存储方式不同，词典在内存中存储，倒排文件在磁盘上。本文不会去介绍分词，tf-idf，BM25，向量空间相似度等构建倒排索引和查询倒排索引所用到的技术，读者只需要对倒排索引有个基本的认识即可。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、ES的集群架构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;集群节点&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个ES集群可以有多个节点构成，一个节点就是一个ES服务实例，通过配置集群名称cluster.name加入集群。那么节点是如何通过配置相同的集群名称加入集群的呢？要搞明白这个问题，我们必须先搞清楚ES集群中节点的角色。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ES中节点有角色的区分的，通过配置文件conf/elasticsearch.yml中配置以下配置进行角色的设定。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node.master: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;/&lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node.&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;/&lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;集群中单个节点既可以是候选主节点也可以是数据节点，通过上面的配置可以进行两两组合形成四大分类：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）仅为候选主节点&lt;br/&gt;（2）既是候选主节点也是数据节点&lt;br/&gt;（3）仅为数据节点&lt;br/&gt;（4）既不是候选主节点也不是数据节点&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;候选主节点：&lt;/strong&gt;只有是候选主节点才可以参与选举投票，也只有候选主节点可以被选举为主节点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主节点：&lt;/strong&gt;负责索引的添加、删除，跟踪哪些节点是群集的一部分，对分片进行分配、收集集群中各节点的状态等，稳定的主节点对集群的健康是非常重要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据节点：&lt;/strong&gt;负责对数据的增、删、改、查、聚合等操作，数据的查询和存储都是由数据节点负责，对机器的CPU，IO以及内存的要求比较高，一般选择高配置的机器作为数据节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;此外还有一种节点角色叫做&lt;strong&gt;协调节点&lt;/strong&gt;，其本身不是通过设置来分配的，用户的请求可以随机发往任何一个节点，并由该节点负责分发请求、收集结果等操作，而不需要主节点转发。这种节点可称之为协调节点，集群中的任何节点都可以充当协调节点的角色。每个节点之间都会保持联系。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9761904761904762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIiaEp5sbQSYFolFc7SJCVhLxLbaGKsyjH97xkpUTIITTXYR8vlzlqtLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;462&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图2）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 发现机制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前文说到通过设置一个集群名称，节点就可以加入集群，那么ES是如何做到这一点的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就要讲一讲ES特殊的发现机制ZenDiscovery。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZenDiscovery是ES的内置发现机制，提供单播和多播两种发现方式，主要职责是集群中节点的发现以及选举Master节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;多播也叫组播&lt;/strong&gt;，指一个节点可以向多台机器发送请求。生产环境中ES不建议使用这种方式，对于一个大规模的集群，组播会产生大量不必要的通信。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单播&lt;/strong&gt;，当一个节点加入一个现有集群，或者组建一个新的集群时，请求发送到一台机器。当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系Master节点，并加入集群。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;只有在同一台机器上运行的节点才会自动组成集群。ES 默认被配置为使用单播发现，单播列表不需要包含集群中的所有节点，它只是需要足够的节点，当一个新节点联系上其中一个并且通信就可以了。如果你使用 Master 候选节点作为单播列表，你只要列出三个就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这个配置在 elasticsearch.yml 文件中：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;discovery&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.zen&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.ping&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.unicast&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.hosts&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[&quot;host1&quot;, &quot;host2:port&quot;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;集群信息收集阶段采用了 Gossip 协议，上面配置的就相当于一个seed nodes，Gossip协议这里就不多做赘述了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES官方建议unicast.hosts配置为所有的候选主节点，ZenDiscovery 会每隔ping_interval（配置项）ping一次，每次超时时间是discovery.zen.ping_timeout（配置项），3次(ping_retries配置项)ping失败则认为节点宕机，宕机的情况下会触发failover，会进行分片重分配、复制等操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果宕机的节点不是Master，则Master会更新集群的元信息，Master节点将最新的集群元信息发布出去，给其他节点，其他节点回复Ack，Master节点收到discovery.zen.minimum_master_nodes的值-1个 候选主节点的回复，则发送Apply消息给其他节点，集群状态更新完毕。如果宕机的节点是Master，则其他的候选主节点开始Master节点的选举流程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1 选主&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Master的选主过程中要确保只有一个master，ES通过一个参数quorum的代表多数派阈值，保证选举出的master被至少quorum个的候选主节点认可，以此来保证只有一个master。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;选主的发起由候选主节点发起，当前候选主节点发现自己不是master节点，并且通过ping其他节点发现无法联系到主节点，并且包括自己在内已经有超过minimum_master_nodes个节点无法联系到主节点，那么这个时候则发起选主。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;选主流程图&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.9256559766763848&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIXPOTlNGb66uD03SRKj0ZGyF5BuJBY7mY6g3do2MdgntnXdN2N8ZVoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图3）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;选主的时候按照集群节点的参数&amp;lt;stateVersion, id&amp;gt; 排序。stateVersion从大到小排序，以便选出集群元信息较新的节点作为Master，id从小到大排序，避免在stateVersion相同时发生分票无法选出 Master。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;排序后第一个节点即为Master节点。当一个候选主节点发起一次选举时，它会按照上述排序策略选出一个它认为的Master。     &lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2 脑裂&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;提到分布式系统选主，不可避免的会提到脑裂这样一个现象，什么是脑裂呢？如果集群中选举出多个Master节点，使得数据更新时出现不一致，这种现象称之为脑裂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简而言之集群中不同的节点对于 Master的选择出现了分歧，出现了多个Master竞争。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;  一般而言脑裂问题可能有以下几个&lt;strong&gt;原因&lt;/strong&gt;造成：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;网络问题：&lt;/strong&gt;集群间的网络延迟导致一些节点访问不到Master，认为Master 挂掉了，而master其实并没有宕机，而选举出了新的Master，并对Master上的分片和副本标红，分配新的主分片。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;节点负载：&lt;/strong&gt;主节点的角色既为Master又为Data，访问量较大时可能会导致 ES 停止响应（假死状态）造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;内存回收：&lt;/strong&gt;主节点的角色既为Master又为Data，当Data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如何避免脑裂：我们可以基于上述原因，做出优化措施：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;适当调大响应超时时间，减少误判。通过参数 discovery.zen.ping_timeout 设置节点ping超时时间，默认为 3s，可以适当调大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;选举触发，我们需要在候选节点的配置文件中设置参数 discovery.zen.munimum_master_nodes 的值。这个参数表示在选举主节点时需要参与选举的候选主节点的节点数，默认值是 1，官方建议取值(master_eligibel_nodes/2)+1，其中 master_eligibel_nodes 为候选主节点的个数。这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性，因为只要不少于 discovery.zen.munimum_master_nodes 个候选节点存活，选举工作就能正常进行。当小于这个值的时候，无法触发选举行为，集群无法使用，不会造成分片混乱的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;角色分离，即是上面我们提到的候选主节点和数据节点进行角色分离，这样可以减轻主节点的负担，防止主节点的假死状态发生，减少对主节点宕机的误判。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、索引如何写入的&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1.  写索引原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1.1 分片&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES支持PB级全文搜索，通常我们数据量很大的时候，查询性能都会越来越慢，我们能想到的一个方式的将数据分散到不同的地方存储，ES也是如此，ES通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据库块称之为一个分片Shard，很像MySQL的分库分表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同的主分片分布在不同的节点上，那么在多分片的索引中数据应该被写入哪里？肯定不能随机写，否则查询的时候就无法快速检索到对应的数据了，这需要有一个路由策略来确定具体写入哪一个分片中，怎么路由我们下文会介绍。在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.2 副本&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;副本就是对分片的复制，每个主分片都有一个或多个副本分片，当主分片异常时，副本可以提供数据的查询等操作。主分片和对应的副本分片是不会在同一个节点上的，避免数据的丢失，当一个节点宕机的时候，还可以通过副本查询到数据，副本分片数的最大值是 N-1（其中 N 为节点数）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对doc的新建、索引和删除请求都是写操作，这些写操作是必须在主分片上完成，然后才能被复制到对应的副本上。ES为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES通过乐观锁的方式控制，每个文档都有一个 _version号，当文档被修改时版本号递增。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.132890365448505&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIJ5yn7SADwniaoNUUtFNKK9xVCbAUkJ7wSusG6WOV9xkVpUkhl4myR3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;301&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图4）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.3 Elasticsearch 的写索引流程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面提到了写索引是只能写在主分片上，然后同步到副本分片，那么如图4所示，这里有四个主分片分别是S0、S1、S2、S3，一条数据是根据什么策略写到指定的分片上呢？这条索引数据为什么被写到S0上而不写到 S1 或 S2 上？这个过程是根据下面这个公式决定的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;shard&lt;/span&gt; = hash(routing) % number_of_primary_shards&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以上公式的值是在0到number_of_primary_shards-1之间的余数，也就是数据档所在分片的位置。routing通过Hash函数生成一个数字，然后这个数字再除以number_of_primary_shards（主分片的数量）后得到余数。routing是一个可变值，默认是文档的_id ，也可以设置成一个自定义的值。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在一个写请求被发送到某个节点后，该节点按照前文所述，会充当协调节点，会根据路由公式计算出写哪个分片，当前节点有所有其他节点的分片信息，如果发现对应的分片是在其他节点上，再将请求转发到该分片的主分片节点上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在ES集群中每个节点都通过上面的公式知道数据的在集群中的存放位置，所以每个节点都有接收读写请求的能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么为什么在创建索引的时候就确定好主分片的数量，并且不可修改？因为如果数量变化了，那么所有之前路由计算的值都会无效，数据也就再也找不到了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.654510556621881&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIBHFm80tQEuh9sIeecFsRGdZgoX42oic9ibS4Tibr8TviaVCxwDpCMMqc3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（ 图5）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上图5所示，当前一个数据通过路由计算公式得到的值是 shard=hash(routing)%4=0，则具体流程如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）数据写请求发送到 node1 节点，通过路由计算得到值为1，那么对应的数据会应该在主分片S1上。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;（2）node1节点将请求转发到 S1 主分片所在的节点node2，node2 接受请求并写入到磁盘。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;（3）并发将数据复制到三个副本分片R1上，其中通过乐观并发控制数据的冲突。一旦所有的副本分片都报告成功，则节点 node2将向node1节点报告成功，然后node1节点向客户端报告成功。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这种模式下，只要有副本在，写入延时最小也是两次单分片的写入耗时总和，效率会较低，但是这样的好处也很明显，避免写入后单个机器硬件故障导致数据丢失，在数据完整性和性能方面，一般都是优先选择数据，除非一些允许丢数据的特殊场景。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在ES里为了减少磁盘IO保证读写性能，一般是每隔一段时间（比如30分钟）才会把数据写入磁盘持久化，对于写入内存，但还未flush到磁盘的数据，如果发生机器宕机或者掉电，那么内存中的数据也会丢失，这时候如何保证？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于这种问题，ES借鉴数据库中的处理方式，增加CommitLog模块，在ES中叫transLog，在下面的ES存储原理中会介绍。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.  存储原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面介绍了在ES内部的写索引处理流程，数据在写入到分片和副本上后，目前数据在内存中，要确保数据在断电后不丢失，还需要持久化到磁盘上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们知道ES是基于Lucene实现的，内部是通过Lucene完成的索引的创建写入和搜索查询，Lucene 工作原理如下图所示，当新添加一片文档时，Lucene进行分词等预处理，然后将文档索引写入内存中，并将本次操作写入事务日志（transLog），transLog类似于mysql的binlog，用于宕机后内存数据的恢复，保存未持久化数据的操作日志。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;默认情况下，Lucene每隔1s(refresh_interval配置项)将内存中的数据刷新到文件系统缓存中，称为一个segment（段）。一旦刷入文件系统缓存，segment才可以被用于检索，在这之前是无法被检索的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此refresh_interval决定了ES数据的实时性，因此说ES是一个准实时的系统。segment 在磁盘中是不可修改的，因此避免了磁盘的随机写，所有的随机写都在内存中进行。随着时间的推移，segment越来越多，默认情况下，Lucene每隔30min或segment 空间大于512M，将缓存中的segment持久化落盘，称为一个commit point，此时删掉对应的transLog。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当我们在进行写操作的测试的时候，可以通过手动刷新来保障数据能够被及时检索到，但是不要在生产环境下每次索引一个文档都去手动刷新，刷新操作会有一定的性能开销。一般业务场景中并不都需要每秒刷新。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以通过在 Settings 中调大 refresh_interval = &quot;30s&quot; 的值，来降低每个索引的刷新频率，设值时需要注意后面带上时间单位，否则默认是毫秒。当 refresh_interval=-1 时表示关闭索引的自动刷新。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6065773447015834&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIqicx9Qwynb3hkrEN7m1Xe2T9hmHhp8fwryaiblSFZ5tM5olv2sEYlXcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;821&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图6）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;索引文件分段存储并且不可修改，那么新增、更新和删除如何处理呢？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;segment被设定为不可修改具有一定的优势也有一定的缺点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其它缓存(像 Filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;当对旧数据进行删除时，旧数据不会马上被删除，而是在 .del 文件中被标记为删除。而旧数据只能等到段更新时才能被移除，这样会造成大量的空间浪费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 若有一条数据频繁的更新，每次更新都是新增新的，标记旧的，则会有大量的空间浪费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每次新增数据时都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源例如文件句柄的消耗会非常大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在查询的结果中包含所有的结果集，需要排除被标记删除的旧数据，这增加了查询的负担。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1  段合并&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由于每当刷新一次就会新建一个segment（段），这样会导致短时间内的段数量暴增，而segment数目太多会带来较大的麻烦。大量的segment会影响数据的读性能。每一个segment都会消耗文件句柄、内存和CPU 运行周期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;更重要的是，每个搜索请求都必须轮流检查每个segment然后合并查询结果，所以segment越多，搜索也就越慢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此Lucene会按照一定的策略将segment合并，合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档不会被拷贝到新的大segment中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;合并的过程中不会中断索引和搜索，倒排索引的数据结构使得文件的合并是比较容易的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;段合并在进行索引和搜索时会自动进行，合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这些段既可以是未提交的也可以是已提交的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;合并结束后老的段会被删除，新的段被刷新到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点，新的段被打开，可以用来搜索。段合并的计算量庞大，而且还要吃掉大量磁盘 I/O，并且段合并会拖累写入速率，如果任其发展会影响搜索性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES在默认情况下会对合并流程进行资源限制，所以搜索性能可以得到保证。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7016742770167428&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIc9XA81prMddC48pDjca3zHGvWU7lGK1Tsic6RsDvhHz9cZVAV81icxOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图7）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、写在最后&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者对ES的架构原理和索引存储和写机制进行介绍，ES的整体架构体系相对比较巧妙，我们在进行系统设计的时候可以借鉴其设计思路，本文只介绍ES整体架构部分，更多的内容，后续作者会在其他文章中继续分享。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1730382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSI80WRIpDRicCaQdHjjurJ7VdYSt9xD2qibbm0EDareT9m7B3JDcFobIhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;994&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIRx2tcy1EZsbvicvcAMzjDVQgUH5c0PjUbm8leBX8b6YRSgJCPRAOznA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;vivo互联网技术&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo移动互联网是基于vivo 智能手机所建立的完整移动互联网生态圈，围绕vivo大数据运营，打造包括应用、游戏、资讯、品牌、电商、内容、金融、搜索的全方位服务生态，满足海量用户的多样化需求。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;点一下，代码无 Bug&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8808777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIcZEEmjkyld5v3qhALAJDpVxa9wt6PgeX5C5f2rYkPcWJD9KiaxD9riaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>538568a608f9c28e75b6e2c7645a5764</guid>
<title>码仔漫画：重学设计模式之装饰者模式</title>
<link>https://toutiao.io/k/38691ur</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>84bbafa2cf7edfaa33b5b9940d905c56</guid>
<title>常见算法模版总结（一）</title>
<link>https://toutiao.io/k/m7uyc89</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/f93EtXu3Zk9TibJxSn9tLMfK37bcbQtgTXznNxWSfwp7FGx94fcczKB8YwbC3HctNntf3XDibgYQ6ibykpGa7c0xA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; title=&quot;日常&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;日常&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;鉴于leetcode刷题即使有了思路，代码也总是磕磕绊绊调试好久，也调不对……直到发现网上不少算法模版，原来模版像单词一样，是需要背的。背会了模版也许能事半功倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本篇文章233酱准备了二分法、排序、位运算的一些模版，欢迎小伙伴们交流指正，持续更新中&amp;gt;_&amp;lt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;二分法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;「二分查找」的思想是待搜索的数据元素满足一些&lt;strong&gt;二段性&lt;/strong&gt;（前面的一半不满足这段性质，后面的一半满足这个性质，如有序数组），能够通过中间元素&lt;/span&gt;&lt;code&gt;&lt;span&gt;arr[mid]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和判断条件&lt;/span&gt;&lt;code&gt;&lt;span&gt;check(mid)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;将数据分为两半,目标值&lt;/span&gt;&lt;code&gt;&lt;span&gt;target&lt;/span&gt;&lt;/code&gt;&lt;span&gt;一定在符合条件的一半中。这样通过每次折半，查找的时间的复杂为O(logN)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设目标值存在闭区间[l,r]中，每次将区间长度缩小一半，当l=r时，就找到了目标值target。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;    &lt;span&gt;//区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;binarySearch1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(l&amp;lt;r){&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = l +r &amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//如果mid满足了这个性质，target在区间[l,mid]中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(mid)) r=mid;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; l = mid + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//此时l==r,跳出后判断arr[r]是不是我们要的target即可&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; r;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//区间[l, r]被划分成[l, mid -1]和[mid, r]时使用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;binarySearch2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(l&amp;lt;r){&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = l + r+ &lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//如果mid满足了这个性质，target在右区间[mid,r]中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(mid)) l=mid;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; r = mid - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//此时l==r,跳出后判断arr[r]是不是我们要的target即可&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; r;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;check&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; mid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// mid是否满足我们区分二段性的条件&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上面两段模版代码&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;微妙的区别在于mid应该被划分在区间[l,mid] 还是 区间[mid,r]。前者在满足check条件下不断向左试探target，后者在满足条件的情况下不断向右试探target。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通过leetcodee34 来理解这两个模版代码。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;br/&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;br/&gt;如果数组中不存在目标值 target，返回 [-1, -1]。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目分析：&lt;/strong&gt;&lt;br/&gt;这道题让我们找到target的开始位置和结束位置，&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;Step1:找开始位置&lt;/span&gt;&lt;/code&gt; &lt;br/&gt;&lt;span&gt;从[l,r]中找到start,不断向左试探。更新r=mid，套用模版&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Step2:找结束位置&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;span&gt;Step1结束后如果 arr[r] == target,则说明r是target的开始位置&lt;br/&gt;继续二分[r,nums-1]：不断向右试探。更新l=mid，套用模版&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整代码为：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] &lt;span&gt;searchRange&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; target&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;        result[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        result[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;0&lt;/span&gt;, r = nums.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//Step1:从[l,r]中找到start,不断向左试探&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (l &amp;lt; r) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = l + r &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[mid] &amp;gt;= target) {&lt;br/&gt;                r = mid;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                l = mid + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums[r] != target) {&lt;br/&gt;            &lt;span&gt;//不存在目标元素&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        result[&lt;span&gt;0&lt;/span&gt;] = r;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//Step2:从[r,nums.length-1]中寻找end，不断向右试探&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; L = r, R = nums.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (L &amp;lt; R) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = L + R + &lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[mid] == target) {&lt;br/&gt;                L = mid;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                R = mid - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        result[&lt;span&gt;1&lt;/span&gt;] = L;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;排序算法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;排序算法的复杂度图表如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4548254620123203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9TibJxSn9tLMfK37bcbQtgTNt2zsC4BsmR5EeFGJeXWBnTQ5VBVxhxAADial7Ll2CX7T0zWurlUpfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;这里我准备了一下快速排序、堆排序和归并排序的模版。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;快速排序和归并排序都用了&lt;strong&gt;分治思想&lt;/strong&gt;，就是将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。通过将全局排序不断分解，局限在子问题内排序，减少了排序中不必要的重复比较操作。从而使平均复杂度降为O(nlogn)。不过在全局排序的分与合的策略上，两者有一些区别。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;快速排序&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;「快速排序」的思想是使用&lt;/span&gt;&lt;span&gt;分治法&lt;/span&gt;&lt;span&gt;（Divide and conquer）策略来把一个&lt;/span&gt;&lt;span&gt;序列&lt;/span&gt;&lt;span&gt;（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;quickSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[]nums,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (l&amp;gt;=r) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = l - &lt;span&gt;1&lt;/span&gt;, j = r + &lt;span&gt;1&lt;/span&gt;, partition = nums[l + r &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i&amp;lt;j){&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (nums[ ++ i] &amp;lt; partition);&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (nums[ -- j] &amp;gt; partition);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i&amp;lt;j) {&lt;br/&gt;                swap(nums,i,j);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;span&gt;//递推步骤&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//注意：分界区间是[l,j] 和 [j+1,r],因为如果r-l+1 = 偶数时，跳出循环时 i&amp;gt;j。此时j才是分区的位置&lt;/span&gt;&lt;br/&gt;        quickSort(nums,l,j);&lt;br/&gt;        quickSort(nums,j+&lt;span&gt;1&lt;/span&gt;,r);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[]nums,&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; temp = nums[i];&lt;br/&gt;        nums[i] = nums[j];&lt;br/&gt;        nums[j] = temp;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;归并排序&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;「归并排序」指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;mergeSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (l&amp;gt;=r) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; mid = l+r&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//递推公式&lt;/span&gt;&lt;br/&gt;        mergeSort(nums,l,mid);&lt;br/&gt;        mergeSort(nums,mid+&lt;span&gt;1&lt;/span&gt;,r);&lt;br/&gt;&lt;span&gt;//合并过程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] temp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[r-l+&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; k =&lt;span&gt;0&lt;/span&gt;,i=l,j=mid+&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i&amp;lt;=mid &amp;amp;&amp;amp; j &amp;lt;= r){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[i]&amp;lt;= nums[j]) {&lt;br/&gt;                temp[k++] = nums[i++];&lt;br/&gt;            }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                temp[k++] = nums[j++];&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i&amp;lt;=mid) temp[k++] = nums[i++];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (j&amp;lt;=r) temp[k++] = nums[j++];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; ( i=l,j=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=r;i++,j++){&lt;br/&gt;            nums[i] = temp[j];&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;堆排序&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;堆是一个近似&lt;/span&gt;&lt;span&gt;完全二叉树&lt;/span&gt;&lt;span&gt;的结构，并同时满足&lt;strong&gt;堆的性质&lt;/strong&gt;：即子节点的键值或索引总是小于（或者大于）它的父节点。&lt;br/&gt;如果先构建一个大顶堆，重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的&lt;/span&gt;&lt;span&gt;堆&lt;/span&gt;&lt;span&gt;维持最大堆性质，从而完成排序。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;heapSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//构建一个大顶堆&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; lastIndex = nums.length &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxParent = (lastIndex&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = maxParent;i&amp;gt;= &lt;span&gt;0&lt;/span&gt;;i--){&lt;br/&gt;            maxHeapify(nums,i,lastIndex);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//不断交换数组的最后面&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = lastIndex;i&amp;gt;&lt;span&gt;0&lt;/span&gt;;i--){&lt;br/&gt;            swap(nums,&lt;span&gt;0&lt;/span&gt;,i);&lt;br/&gt;            maxHeapify(nums,&lt;span&gt;0&lt;/span&gt;,i&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;maxHeapify&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums,&lt;span&gt;int&lt;/span&gt; parent,&lt;span&gt;int&lt;/span&gt; lastIndex)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; lChild = (parent&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+ &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rChild = lChild + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (lChild &amp;gt; lastIndex) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxChild = lChild;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (rChild &amp;lt;= lastIndex &amp;amp;&amp;amp; nums[rChild] &amp;gt; nums[lChild]) maxChild = rChild;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums[maxChild] &amp;gt; nums[parent]) {&lt;br/&gt;            swap(nums,maxChild,parent);&lt;br/&gt;            &lt;span&gt;//需要继续判断换下后的父节点是否符合堆的特性&lt;/span&gt;&lt;br/&gt;            maxHeapify(nums,maxChild, lastIndex);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[]nums,&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; temp = nums[i];&lt;br/&gt;        nums[i] = nums[j];&lt;br/&gt;        nums[j] = temp;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;位运算&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我们看一下leetcode191如何运用上述性质。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;计算数字的二进制中有多少个1&lt;br/&gt;&lt;strong&gt;题目示例：&lt;/strong&gt;&lt;br/&gt;输入：00000000000000000000000000001011&lt;br/&gt;输出：3&lt;br/&gt;解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法一：&lt;/strong&gt;常规解法，如果n &amp;amp; mask != 0，说明n的右边第k位为1，则计数+1，mask左移一位。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hammingWeight&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; bits = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; mask = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;32&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((n &amp;amp; mask) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                bits++;&lt;br/&gt;            }&lt;br/&gt;            mask &amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bits;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法二：&lt;/strong&gt;令n=n&amp;amp;(n-1)，如果 n!=0，则说明去掉了最右面的1，则计数+1&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hammingWeight&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; bits =&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(n != &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            bits++;&lt;br/&gt;            n = n&amp;amp;(n&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bits;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考资料：&lt;br/&gt;[1].https://www.acwing.com/blog/content/277/&lt;br/&gt;[2].https://stackoverflow.com/questions/4678333/n-n-1-what-does-this-expression-do&lt;br/&gt;[3].维基百科&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>06c6376ec88be66b9a047431cb25266b</guid>
<title>之前遇到一位老面试官，问我的问题真的有点东西</title>
<link>https://toutiao.io/k/zfokmsr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章其实源于一次我的面试经历。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那次我面对是一位&lt;span&gt;老面试官&lt;/span&gt;，真的很有东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那次面试我和他叨叨了&lt;span&gt;两小时&lt;/span&gt;....我滴妈我嘴巴都干了真的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他的提问都很有深度，可以说对我的学习之路有很大的帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我记得有个问题，差不多是面了一个小时的时候他问我：Cookie、Session、Token知道的吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我说：知道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那你从&lt;span&gt;演进的角度&lt;/span&gt;来讲讲 Cookie 、Session、Token？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时就懵了，单独的说我都清楚，这演进的角度让我一下不知从何说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个面试官会从各个角度去感受我对&lt;span&gt;一个知识点到底是背的，还是有自己理解的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他提问的方式真的很有东西，他也给我反馈了很多他的理解，相谈甚欢，真的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这个问题他从 HTTP 无状态开始慢慢的引导我.....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他的这波引导其实就串联起了这一系列的知识点，零散的东西就被他整理的明明白白。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以后来的学习我都喜欢找缘由，也就是为什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也是我一直强调的要知道：&lt;span&gt;为什么会有这个东西的存在，这个的东西是为了解决什么痛点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起初是因为我怕面试官再问我这样的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在是因为&lt;span&gt;就应该这样学。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今儿就来捋捋之前面试官问我的这个题的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1990 年。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;蒂姆·伯纳斯·李创建了 HTTP 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;李老的想法是把文档存储在服务器中，谁需要这个文档直接从服务器获取即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照这个思想，当时的需求只有 GET。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且按照拿文档的思路：拿完了连接就可以断了，也不需要什么交互。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;span&gt;HTTP 起初的设计就是无状态的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是请求和请求之间是没有关联的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而随着互联网的发展，交互开始兴起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人们不再满足简单的静态文件获取，各种购物、社交接踵而至。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着服务器需要判断每个请求的发起者是谁，也就是需要状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你聊天总得表明你是谁，并且和谁聊吧？不然服务器可不知这聊天信息得发给谁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你购物总得让服务器知道是谁买了这玩意吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总不能你买完了下线，再上线发现你买的东西没了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候就是需要一种技术让请求与请求之间建立起联系，让请求变得有状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这技术叫 Cookie，&lt;span&gt;就是一个以 Key-Value 格式存储的小文件，保存在客户端本地&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如登录之后，服务器就能设置 Cookie 返回给浏览器，然后保存在本地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随便截了个百度的，列出来的就是 key，下拉箭头打开里面就有 value。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5327380952380952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGbpzvSt6CHQ1iaaKrst0V9GBqtQIwDTIvnUZyic2tlSe3VicWxKxliaicib4HM5ya27ejZ6PUjP7gSltMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后对百度的请求就可以带着 Cookie 去访问服务器，这里假设 BAIDUID 是用户 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百度的服务器一看原来是这个 ID 啊，就知道是“我”请求了，这就有状态了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单地说 Cookie 就是存储在本地的一份文件，每次请求都会带上 Cookie 去访问服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以把一些&lt;span&gt;用户信息塞到 Cookie 里，这样服务器就能判别是哪个用户的请求了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意 &lt;span&gt;Cookie 是有域的划分的&lt;/span&gt;，来看下这个图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37683284457478006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGbpzvSt6CHQ1iaaKrst0V9GP31wWUoWs8zzjSNCnIzySiclYQG4KRawVzKjCj7gJSGeJK1FwA6PVNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是每个域下面都有各自的 Cookie ，访问不同的网站带属于这个网站的 Cookie ，不会带别人的 Cookie ，不然就乱套了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4860392967942089&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGbpzvSt6CHQ1iaaKrst0V9GM1n3UKeq98ZdPHJHCv647F1UpPaIoGv2FxVcHjH5fNpbqoEGnZFvjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;967&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 Cookie 是&lt;span&gt;明文存储在用户本地，而且带有大量的用户信息&lt;/span&gt;这不太安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且每次请求都需要带这么多 Cookie 对带宽来说也不太划算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Session&lt;/span&gt; 就解决了这个问题，Session 就是会话，&lt;span&gt;它有更加广泛的含义&lt;/span&gt;，在和 Cookie 这些一起谈论的场景，我们把它狭义化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Session 就是把用户的会话信息存储在服务端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后颁发给客户端一个 sessionId，让客户端之后带着 sessionId 来请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样服务端就可以通过 sessionId 去找到这个用户的信息，从而识别请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那客户端是如何带上 sessionId 的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 sessionId 还是按照 Cookie 的形式存储在用户的本地，发起请求的时候带上即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.329608938547486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGbpzvSt6CHQ1iaaKrst0V9GoG0kkAoKNfFyC3q85D8o9ibNawSLviaYQJ1exUPZUzBGAJWKsWWXoPibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是把这种状态信息存储到服务器中&lt;span&gt;使得服务器就有状态了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般我们部署在线上的服务器会有多台来做负载均衡，也互相作为 backup。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果 Session 的信息存在某一台机器上，那么当&lt;span&gt;下一次请求被负载分到另一台机器&lt;/span&gt;那就找不到这个 Session 信息了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就不认得这个请求了，可能的现象就是告诉用户没登录，那用户不就傻了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这刚还登录着呢，这就告诉我没登录了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以处理方式有 session 复制，就是服务器之间互相同步 session，这样不论请求到哪个服务器都有用户的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这复制就冗余了，有额外的开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种就是 session sticky，其实就是把你的请求一直粘在某一个服务器上，如果你请求的一开始被指派的是 A 服务器，那么之后的所有请求都只会被指派到 A 服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是&lt;span&gt;如果 A 服务器挂了&lt;/span&gt;，你的请求还是会被指派到别的服务器上，这样一来用户登录信息还是会丢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到复制和 sticky 都有缺陷，所以可以把 session 放到第三方存储，比如 Redis 里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样服务器等于又没状态了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而服务器的无状态意味着可以随意伸缩，服务集群根据流量加几台减几台，很方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是把 session 放第三方存储上只是把这个维护从服务器转嫁到第三方身上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三方得保证它的高可用，不然用户登录信息又会丢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过一般而言我们的系统本来就要维护的第三方存储，所以影响不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结一下&lt;/span&gt;：Cookie 明文存储在本地不太安全，所以想着把用户状态存在服务端，而 Session 就是将用户状态信息保存在服务端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就暴露 sessionId 给客户端，这样相对而言安全些，并且也减少了网络流量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样服务端就有状态了，难以扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此可以把 Session 放到第三方存储上，但是等于状态还是由服务端维护。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实仔细想想，&lt;span&gt;是不是不需要在服务端存储用户的信息？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要一个&lt;span&gt;能代表身份的凭证&lt;/span&gt;即可，一个服务端颁发给用户凭证，之后的请求让用户带着这个凭证就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像我们的身份证，就代表我们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个凭证里面就包含了用户的信息，有人可能怕凭证被伪造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没事，&lt;span&gt;把凭证给签名了&lt;/span&gt;，这样我们服务器就能验证凭证的真伪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和别人做不得假身份证一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种凭证叫 Token。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个用户登录了系统，我就返回一个 Token 给他，之后每次请求他带着这个 Token 来就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器验证了真伪之后拿到 Token 里面的用户信息就知道这个请求是谁发的了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5743362831858407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGbpzvSt6CHQ1iaaKrst0V9GwcXzJtbqApe14VIVUygHqVIkwJicVARr55wy2ib9BhsWIEn0Ieyqw7UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1130&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样服务器就无状态了，是真的无状态了，当然客户端有状态了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由客户端来保存 Token ，这样是最合理的，不需要在服务端冗余数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 Token 之后服务器因为无状态所以可扩展，&lt;span&gt;并且 Token 还能跨应用使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如同一个公司不同应用之间的调用，所有应用只要能识别这个 Token 就都能登录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Token 就搞定了，不用每个网站都登录一遍，这就是单点登录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是第三方服务提供方也更容易地提供服务，只需要颁发一个 Token 给调用者即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Token  简单的说就是一个含有凭证信息的令牌&lt;/span&gt;，只要服务器能识别这个令牌就能根据令牌的身份进行相应的响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这还&lt;span&gt;蕴含了时间换空间的思想&lt;/span&gt;，把存储在服务器的用户信息暴露出去，利用签名来验证 Token 的真伪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样每次请求都需要耗费时间去验签，不过好处就是不需要存储信息，也就是时间换空间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实像 Cookie + Session 除了可扩展还有跨域啊、跨站伪造请求等问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 Token 更加灵活，在移动端等场景也更加的适用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有关文章所讲的演进&lt;span&gt;看起来&lt;/span&gt;好像就是 &lt;code&gt;Cookie =&amp;gt; Session =&amp;gt;Token&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不是的&lt;/span&gt;，这几个东西都很有用，&lt;span&gt;文章只是单从认证这一方面来看罢了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎加我好友进行深入地交流，备注「进群」，拉你进交流&amp;amp;内推群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平日的面试题遇到难处，或者看某个知识点翻遍全网的资料还是感觉很模糊、不透彻，可以私聊我，给我留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遇到合适的我会整理写出一篇文章，注意这个前提我认为合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那种工作遇到很细节的场景的还是别了，这种问你上司比较合适:)。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1555555555555554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGbpzvSt6CHQ1iaaKrst0V9GjLvabMsdhXD0icVfZYnrIFaUFWfSricQibzlOCC9Cmrn6qUc1ceMTr1sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;270&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，欢迎在看、转发、留言，我们下篇见。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>