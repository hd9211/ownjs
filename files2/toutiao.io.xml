<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dc05c13cb0614d6cdcae7b43cb9c5e2c</guid>
<title>文末送福利｜十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6a7b06d89a3fede47264d4dce5b6e57e</guid>
<title>并发编程：SIMD 介绍</title>
<link>https://toutiao.io/k/z43chab</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SIMD 简介&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，计算机程序需要编译成指令才能让 CPU 识别并执行运算。所以，CPU 指令处理数据的能力是衡量 CPU 性能的重要指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提高 CPU 指令处理数据的能力，半导体厂商在 CPU 中推出了一些可以同时并行处理多个数据的指令 —— &lt;span&gt;SIMD&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SIMD 的全称是 Single Instruction Multiple Data，中文名“单指令多数据”。顾名思义，一条指令处理多个数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26782884310618066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOFgSeabMCl12q5vbA2bKXf3IxbRuaCbdpo9fMiasuicdegqObCbLFTgia7nib1p8tEkjwunXL51DO2IeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;如上图所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个普通加法指令，一次只能对两个数执行一个加法操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 SIMD 加法指令，一次可以对两个数组（向量）执行加法操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SIMD 简史&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过多年的发展，支持 SIMD 的指令集有很多。各种 CPU 架构都提供各自的 SIMD 指令集，本文的介绍以 x86 架构为主。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7027777777777777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9637P74IBOFgSeabMCl12q5vbA2bKXf3BPYWeclGpmAGK5jDfzoduveOb5kSakpTdNRPia5Q5TEuMOCpUVHQe1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1997 年，Intel 推出了第一个 SIMD 指令集 —— MultiMedia eXtensions（MMX）。MMX 指令主要使用的寄存器为 MM0 ~ MM7，大小为 64 位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1999 年，Intel 在 Pentium III 对 SIMD 做了扩展，名为 Streaming SIMD eXtensions（SSE）。SSE 采用了独立的寄存器组 XMM0 ~ XMM7，64位模式下为 XMM0 ~ XMM15 ，并且这些寄存器的长度也增加到了 128 位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2000 年，Intel 从 Pentium 4  开始引入 SSE2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2004年，Intel 在 Pentium 4 Prescott 将 SIMD 指令集扩展到了 SSE3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2006 年，Intel 发布 SSE4 指令集，并在 2007 年推出的 CPU 上实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2008 年，Intel 和 AMD 提出了 Advanced Vector eXtentions（AVX）。并于 2011 年分别在 Sandy Bridge 以及 Bulldozer 架构上提供支持。AVX 对 XMM 寄存器做了扩展，从原来的128 位扩展到了256 位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2013年，Intel 在发布的 Haswell 处理器上开始支持AVX2。同年，Intel 提出了 AVX-512。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2016 年，Xeon Phi x200 (Knights Landing) 是第一款支持了 AVX-512 的 CPU。如扩展名所示，AVX-512 主要改进是把 SIMD 寄存器扩展到了 512 位。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何使用 SIMD？&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编译器自动向量化。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些比较简单的场景，编译器可以自动将目标代码向量化（auto vectorization）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2949479940564636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOFgSeabMCl12q5vbA2bKXf3VwwDMxxge6icia4MEgZFp3sNmNshwD4QWbpPia5GEUG8WrSDddZ8ibBn5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 GCC 可以通过 -S 参数，输出中间汇编文件，以检查是否自动将代码进行向量化了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以 v 开头的指令，如 vpmulld、vpaddd、vmovdqu 都是向量化指令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;xmm、ymm、zmm 分别表示 128 位、256 位 和 512 位的向量化使用的寄存器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本例中使用了 -mavx512f 编译选项要求编译器使用 AVX512，所以汇编代码使用的寄存器是 512 位的 zmm 系列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本例中将数组 x 的长度固定为 64 个 int（512 位的倍数），是为了让实例生成的汇编代码更加简洁，不是向量化的强制要求。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编译器&lt;span&gt;扩展的向量支持&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让编译器进行自动向量化，其实有点“看运气”的成分。你可以使用编译器扩展的向量支持能力来实现向量化。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// v16si 表示 16 个 int 的向量（数组），长度为 64 字节&lt;/span&gt;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; v16si __attribute__ ((vector_size (&lt;span&gt;64&lt;/span&gt;)));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; v16si &amp;amp; v)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;[ &quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;16&lt;/span&gt;; i++) {&lt;br/&gt;        s += &lt;span&gt;std&lt;/span&gt;::to_string(v[i]) + &lt;span&gt;&quot; &quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    s += &lt;span&gt;&quot;]&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; s;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    v16si v0, v1;&lt;br/&gt;    &lt;span&gt;memset&lt;/span&gt;(&amp;amp;v0, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(v0));&lt;br/&gt;    &lt;span&gt;memset&lt;/span&gt;(&amp;amp;v1, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(v1));&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;v0: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(v0) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;v1: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(v1) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    v0 = v0 + &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;// v0 + {1, 1, ..., 1}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;v0 = v0 + 1: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(v0) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    v1 = v1 + &lt;span&gt;2&lt;/span&gt;;  &lt;span&gt;// v1 + {2, 3, ..., 2}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;v1 = v1 + 2: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(v1) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    v0 = v0 + v1;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;v0 = v0 + v1: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(v0) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    v1 = v0 * v1;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;v1 = v0 * v1: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(v1) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    v16si a = {&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;};&lt;br/&gt;    v16si b = {&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;// Vectors are compared element-wise producing 0 when comparison is false &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// and -1 (constant of the appropriate type where all bits are set) otherwise. &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; c = a &amp;gt; b;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;c = a &amp;gt; b: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(c) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; d = (a &amp;gt; b) ? v0 : v1;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;d = (a &amp;gt; b) ? v0 : v1: &quot;&lt;/span&gt; &amp;lt;&amp;lt; toString(d) &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译：g++ -o built-vec -mavx512f built-vec.cc&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-mavx512f 表示使用 AVX512 指令集。如果 CPU 不支持 AVX512，可以使用其它 SIMD 指令集。相关编译选项有：-mmmx、-msse、-msse2、-msse3、-mssse3、-msse4.1、-msse4.2、-msse4、-mavx、-mavx2、-mavx512f、-mavx512pf、-mavx512er、-mavx512cd、-mavx512vl、-mavx512bw、-mavx512dq、-mavx512ifma、-mavx512vbmi。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;指令封装&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 &lt;span&gt;The Intel Intrinsics Guide&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 这里，主流的几个编译器 gcc、clang 和 msvc 都将 SIMD 指令封装成 C 函数，方便使用，具体可以参考官方文档。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;SIMD: &lt;em&gt;https://en.wikipedia.org/wiki/SIMD&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;扩展的向量支持: &lt;em&gt;https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;The Intel Intrinsics Guide: &lt;em&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0f5397b0fb04e8ddd552cd3ce6615fb4</guid>
<title>写给互联网工程师的 5G 书（六）：参考实现</title>
<link>https://toutiao.io/k/skbdvsx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;早就想写一个系列，给互联网行业的朋友介绍一下移动通信网络，特别是5G移动通信系统，但一直没想好怎么写。最近看到ONF发布的开源书《5G Mobile Networks：A Systems Approach》，其目标读者正是互联网从业者，因此打算将全书翻译为中文，希望能让有兴趣的朋友们能够了解移动通信网络的一些基本概念、网络架构和演进方向。原文：5G Mobile Networks: A Systems Approach&lt;span&gt;[1]&lt;/span&gt;。中文版Github仓库：https://github.com/yuff100/5GSystemApproachCHN。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;6. 参考实现（Exemplar Implementation）&lt;/h1&gt;&lt;p&gt;我们在前几章中介绍了移动网络的虚拟化、解耦、优化、分布式和切片，不仅有助于我们理解5G的内部工作，而且对于在实践中简化5G移动网络的实现工作也是很有必要的。我们的目标是做出具体的工程选择，从而完成一个参考实现。这只是一个范例，不是唯一的可能性。&lt;/p&gt;&lt;p&gt;我们描述的系统被称为CORD，如果你还记得，我们在引言中介绍过这是&lt;span&gt;C&lt;/span&gt;entral &lt;span&gt;O&lt;/span&gt;ffice &lt;span&gt;R&lt;/span&gt;e-architected as a &lt;span&gt;D&lt;/span&gt;atacenter的首字母缩写。具体来说，CORD是一份基于商用硬件和开源软件组件构建5G系统的蓝图。我们称这种硬件/软件组合为CORD POD，其想法是在蜂窝网络的每个边缘站点部署一个POD。下面从一组工程决策的角度来描述CORD。它不能代替安装、开发和操作CORD的详细文档。还要记住，尽管CORD在其名称中包含“Central Office”，但CORD POD是一种通用设计，并不严格局限于部署在传统的Central Office中。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读：&lt;/span&gt;&lt;br/&gt;要了解如何安装、操作CORD开源软件平台，并对其做出贡献，请参阅CORD指南&lt;span&gt;[2]&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在讨论细节之前，重要的是要了解，CORD是一个正在进行中的工作，有一个相当大的开源社区为它的代码库做出贡献。其中许多组件相当成熟，目前正在进行运营商测试并在生产网络中运行。其他的（主要对应于上一章中描述的高级功能）是在“演示模式”中运行的原型，还不够完整，不足以包含在正式发布版本中。此外，正如前面关于部署选项的讨论中所概述的，CORD从一个产品质量的EPC开始实现，并正在逐步向5G演进（本章使用特定于EPC的组件进行说明）。&lt;/p&gt;&lt;h2&gt;6.1. 框架（Framework）&lt;/h2&gt;&lt;p&gt;图34给出了CORD POD的示意图。它的下游连接到一组DU（以及相关的RU），并将上游连接到互联网的其余部分。在内部，它包括一组商用服务器（图中显示了四个机架，每个机架有三个服务器，但设计上可以支持从部分机架到16个机架的任何部署）和一组白盒交换机，这些交换机以叶脊网络拓扑结构排列（图中显示了两个叶脊交换机，但设计上既能够支持单一的交换机或者每机架两个叶交换机，也能够支持多个脊交换机，只要能够提供足够的东西向带宽）。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5504731861198738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VDUaRibzdTe0aZXvicHFNNWibPqHBQjHCCtXJrfZxn7dbpB077EaJtfCXEmFic6Mx3VxaCSKHO94rafg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图34. CORD实现的RAN和移动核心网。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;软件方面，图34显示了RAN（红色）和移动核心网（蓝色），以及定义CORD平台的模块（橙色）。我们将在本章后面介绍平台组件，但您可以将它们看作是一个多租户云的整体实现，许多不同的可伸缩服务可以在其上运行。RAN和移动核心网就是这样的两个租户。CORD平台还可以承载其他边缘服务（这是CORD从一开始就使用云技术构建的原因之一），但有哪些边缘服务可以在CORD POD上运行不在本书讨论范围之内。&lt;/p&gt;&lt;p&gt;与RAN和核心网相关的组件在前面的章节中已经介绍过了，分别包括CU和移动核心网的控制平面和用户平面。为了简化起见，我们将SGW和PGW合并为单个S/PGW。另一个值得关注的细节是CU控制面中包含的RAN控制组件，包括了4.3节介绍的近实时RIC，这意味着一个CORD POD包含两个SDN控制器：控制RAN的RIC，控制网络的ONOS（在CORD中运行的RIC实际上是ONOS的第二个定制版本，不过这是实现细节了）。&lt;/p&gt;&lt;p&gt;接下来我们来看一下RAN和移动核心网组件是如何实现的。具体来说，图中所示的功能组件有三种不同的表现形式：（1）CU-U和S/PGW-U的数据面以P4程序加载到可编程交换机中实现；（2）CU-U和S/PGW-U的控制面（以及Trellis平台模块）作为加载到ONOS上的控制应用实现；（3）其余组件实现为Kubernetes管理的微服务（Kubernetes是隐含的，没有在图中显示出来）。&lt;/p&gt;&lt;p&gt;为了扩展这一思想，图35给出了CORD POD的另一种视图，舍弃了承载哪些服务的细节，而关注于这些服务是如何在POD上实例化的。在该图中，所有实例化到POD上的功能都是作为基于Kubernetes的微服务和基于ONOS的控制应用程序组合实现的。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8537170263788969&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VDUaRibzdTe0aZXvicHFNNWibgBbBLbZ1xYoibbfSfkvfteGFZcUgeumFkDicZWK9hGoHy6AiafaElUKRg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;417&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图35. CORD的另一种视图，通过CI/CD工具链管理平台和服务，这些服务是由基于ONOS的控制应用程序和基于Kubernetes的微服务组合实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当以这种方式进行抽象时，我们可以将POD视为三个子系统：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;平台（Platform）&lt;/span&gt;：通用的基础层，包括作为容器管理系统的Kubernetes，作为SDN控制器的ONOS，每台交换机上都会加载的Strata（开源交换机操作系统）。ONOS和它托管的控制应用程序都是Kubernetes管理的微服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置（Profile）&lt;/span&gt;：特定部署的微服务和SDN控制应用程序的集合，这些应用程序被调度在特定的POD上运行。这是一个可变的集合，还可以包括在其他地方描述的控制面和边缘服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CI/CD工具链&lt;/span&gt;：用于封装、部署、操作和升级特定的平台/配置，它通过一系列处理流程，将一组分离的、虚拟化的组件转换为能够响应运维工程师的指令并承载实时流量的操作系统。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;CI/CD工具链使用标准的DevOps工具将软件部署到服务器和交换机集群上，并在需要的时候可以隔离/回滚单个微服务和控制应用程序。它还可以基于POD配置自动生成管理POD的NBI（Northbound Interface，北向接口），运维工程师可以在生产环境中通过NBI接口操作CORD POD。&lt;/p&gt;&lt;h2&gt;6.2. 平台组件（Platform Components）&lt;/h2&gt;&lt;p&gt;现在我们回头看一下图34和35中所示的三个平台相关组件。就其本身而言，每个组件都是一个开源项目，但就我们的目的而言，了解它们在支持CORD的5G配置中所扮演的角色就足够了。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Stratum&lt;/span&gt;：轻量级白盒交换机操作系统，提供硬件无关接口，用于对CORD中的交换机进行管理和编程，支持通过&lt;em&gt;P4&lt;/em&gt;定义交换机转发管道的行为（可以视为控制面和数据面之间的契约)，以及使用&lt;em&gt;P4Runtime&lt;/em&gt;在运行时控制转发。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ONOS&lt;/span&gt;：网络操作系统，用于配置和控制由可编程白盒交换机组成的网络。逻辑上它作为集中的SDN控制器运行，并托管一组SDN控制应用程序，每个应用程序控制底层网络的某些功能。由于ONOS在逻辑上是集中式的，因此被设计为高可用性和可伸缩的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Trellis&lt;/span&gt;：ONOS托管的SDN控制应用程序，用于在白盒交换机网络上实现叶脊网络。它支持多个应用的控制，包括VLAN和L2桥接、IPv4和IPv6单播和组播路由、DHCP L3中继、双链接（dual-homing）服务器、上行路由器、QinQ转发/终止、MPLS pseudowires等。此外，Trellis可以使整个网络体现为一个单一的（虚拟的）路由器连接到上游路由器上，上游路由器使用标准的BGP与Trellis进行通信。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Stratum（运行在交换机上）和ONOS（运行在交换机外部，管理整个交换机网络）通过以下接口进行通信：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;P4&lt;/span&gt;：定义可编程交换芯片的转发行为，以及对功能固定的ASIC管道建模。P4程序定义了一个由控制面通过编程定义，并由数据面实现的契约。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;P4Runtime&lt;/span&gt;：为SDN准备的接口，用于控制运行时的转发行为，是用于配置转发表和控制转发状态的关键模块，其工作方式与硬件无关。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OpenConfig模型&lt;/span&gt;：定义了设备配置和管理的最小集。这些模型通过可编程的方式扩展特定于平台的功能，其目标是最小化模型之间的差异，从而支持与供应商无关的管理平面。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;gNMI（gRPC网络管理接口，gRPC Network Management Interface）&lt;/span&gt;：为SDN准备的接口，通过使用二进制接口和双向流来改进现有配置接口，与OpenConfig模型配合使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;gNOI（gRPC网络运维接口，gRPC Network Operations Interfaces）&lt;/span&gt;：一组用于支持特定交换机操作的微服务，如证书管理、设备测试、软件升级和网络故障排除等。gNOI提供了语义丰富的API，取代现有的基于CLI的方式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Trellis作为运行在ONOS上的SDN控制应用程序，可以控制从内部交换网络到CORD POD的包转发（在单个站点内）。但是Trellis也可以通过多个层级的脊柱网络扩展到多个站点，如图36所示。这意味着Trellis具有在RAN的中传和后传网络中发挥作用的潜力，也可以帮助将RAN扩展到客户现场（图中“On Site”域)。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5342679127725857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0VDUaRibzdTe0aZXvicHFNNWibzWq0y1q4E6qPiabLYFKj4YLdpD2pX6hYIENPmPNGmSgQG6wrHcPSSTg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图36. Trellis控制应用程序管理(可能是分布式的)叶棘网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们刚才介绍的软件栈非常庞大，有可能会破坏蜂窝网络现有的构建和运行方式。特别需要注意的是，图34所示的RAN智能控制器是作为ONOS的一组扩展实现的，这种架构将基于ONOS的RIC置于设计的中心，位于SDN和5G世界的交界处。&lt;/p&gt;&lt;p&gt;本次讨论虽然只聚焦于部署5G网络的一种选择，但这也说明了为什么5G被视为电信行业转型的原因之一。5G架构充分利用了几个重要的、广泛的行业趋势，远超以往任何电信网络。融合了SDN的崛起、开源软件的力量及其在网络中日益广泛的使用，当然还有以云技术作为提供创新服务的基础。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读：&lt;/span&gt;&lt;br/&gt;关于SDN软件栈的更多信息，推荐阅读：《软件定义的网络：一种系统方法（Software-Defined Networks: A Systems Approach）》&lt;span&gt;[3]&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Reference:&lt;/span&gt;&lt;br/&gt;[1] https://5g.systemsapproach.org/index.html&lt;br/&gt;[2] https://guide.opencord.org/&lt;br/&gt;[3] https://sdn.systemsapproach.org/&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/article&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d539090f3324bcf939e2f81a3e292077</guid>
<title>领导为什么不听我的汇报和授权方法</title>
<link>https://toutiao.io/k/derylod</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNjAxODg4MQ==&amp;amp;action=getalbum&amp;amp;album_id=2042396491880677377#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2042396491880677377&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#职场经验&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;3个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;国庆放假期间，为了不让大家在假期太烧脑，还是再来一篇综合能力培训的文章。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;领导为什么不听我的汇&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;报&lt;/span&gt;？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面三点造成汇报的失败&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、没有框架&lt;/p&gt;&lt;p&gt;2、陷入细节&lt;/p&gt;&lt;p&gt;3、仓促回答&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;汇报小贴士&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、汇报工作时，先讲结果与进度，突出重点&lt;/p&gt;&lt;p&gt;2、汇报工作时，如要讲所遇问题，简要概括，并提出建议解决方案&lt;/p&gt;&lt;p&gt;3、汇报工作最后，总结后续行动计划&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;怎样避免仓促回答&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简而言之就是采用上菜式的方法：&lt;/p&gt;&lt;p&gt;1、澄清问题&lt;/p&gt;&lt;p&gt;在回答问题前加上澄清来对焦，确保正确的响应问题。&lt;/p&gt;&lt;p&gt;2、清楚回答&lt;/p&gt;&lt;p&gt;针对准确的问题，给予清楚与具体的回答，解除领导的疑问。&lt;/p&gt;&lt;p&gt;3、确认满意&lt;/p&gt;&lt;p&gt;在回答后加上询问反馈，增加自己未来进步的机会。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;做好确认&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、目标是什么&lt;/p&gt;&lt;p&gt;2、为什么&lt;/p&gt;&lt;p&gt;3、用什么来评价&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;换个角度来看，就是确认&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9179566563467493&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8M9YPr9I5tCib3KvLIALm0KKYZNlfa27DRxwQ5HY4U2YMRiaPEf5lOwFqYeRsnc6Q7JIXrlWHEg42Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;授权方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;授权原则一二三&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一、授权要有层次，跨级授权要小心&lt;/p&gt;&lt;p&gt;二、给予适当协助&lt;/p&gt;&lt;p&gt;三、对行为进行控制&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3R式授权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.953810623556582&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic0JWgb6kG3bztXyAZyRTu0ib21dMOjSuulGQw9zmDGTBBibJjLImjEIbMe4zEddtFaMCKxWP8yEtKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/p&gt;&lt;p&gt;尊重下属，体现在管理者平时的言行举止中，和缓的语气、微笑的面容；当中的表扬和私下的批评。&lt;/p&gt;&lt;p&gt;为下属提供充分的资源。&lt;/p&gt;&lt;p&gt;重复，是再授权。不断提供新的机会，激发更大的工作热情。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;有效授权的五要素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7349177330895795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlic0JWgb6kG3bztXyAZyRTu0XNJ5O3MDVt2xuecn9OxqcErb427J5EFNuwoibhzD8rLudpfp4oky9TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们在工作过程中，经常看到同事使用很多的方法，比如：如果没有听清楚或者理解对方的内容，会对内容先进行复述。我们通过实际经验学习也能学到一二，但是如果可以系统性的学习，就能知道，原来那个同事是在澄清问题，我们还可以通过清楚回答和确认满意，来达到整体更理想的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>67a88156bd2ef5902905f77cd9f29c01</guid>
<title>Elasticsearch 基础之相关性介绍</title>
<link>https://toutiao.io/k/9gpfegt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-inner&quot;&gt;
                                                    
&lt;p&gt;众所周知，Elasticsearch返回的结果其实根据其相关性进行排序的。所以这里就会涉及到一个概念，就是相关性是怎么定义的，也就是说凭什么这个结果的相关性就比另一个结果的相关性好。本文就来针对这个问题详细介绍一下。&lt;/p&gt;



&lt;h1&gt;什么是相关性&lt;/h1&gt;



&lt;p&gt;Elasticsearch中的相关性是通过一个浮点的数值_score来显示的，这个_score的值越大，就表示相关性越高。那这个_score的值是如何计算的呢？我们通常在全文本查询的时候，使用的是标准相似算法，它的名字是TF/IDF （term frequency/inverse document frequency），它包含下面三个重要的方面：&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Term frequency&lt;/strong&gt;：我们所查的term在这个field中出现的次数，通常来说，出现的次数越多，则相关性越高。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Inverse document frequency&lt;/strong&gt;：我们所查的term在整个index中出现的频率，出现的频率越高，则相关性越低。这个可以理解，所谓物以稀为贵就是这个道理。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Fiel-length norm&lt;/strong&gt;：这个是用来看field的长度的，field的长度越大，则相关性越低。好吧，什么时候专一都是一个好的品质。&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;当然TF/IDF不是决定score的唯一因素，这里还有很多别的影响因素，比如说fuzzy查询中的term相似度等等。那么在实践中，我们如何才能知道score都是由哪些部分决定的呢？&lt;/p&gt;



&lt;h1&gt;理解Score&lt;/h1&gt;



&lt;p&gt;我们在实际工作中可以通过下面的explain参数来具体查看score是如何得到的。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-10.png&quot; alt=&quot;&quot; class=&quot;wp-image-925&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-10.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-10-300x59.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;在返回的结果中就会包含一个explanation的域如下所示，其中description就是计算使用的类型，value就是score的结果，details就详细记录了各个子计算的情况。你可以看到我们上面提到的TF/IDF/FLN的结果各是什么，最终的score（value）就是基于这三个结果计算出来的。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-11.png&quot; alt=&quot;&quot; class=&quot;wp-image-926&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-11.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-11-254x300.png 254w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;h1&gt;Score的算法介绍&lt;/h1&gt;



&lt;p&gt;这个时候也许你就会好奇，上面这些1，0.30685282以及0.25都是怎么算出来的。这节我们就一起来看看具体的算法：&lt;/p&gt;



&lt;h2&gt;Term Frequency&lt;/h2&gt;



&lt;p&gt;我们上面也提到对TF来说就是它在整个field中出现的次数，越多则分数越高。它的值是通过这个公式来计算的：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-12.png&quot; alt=&quot;&quot; class=&quot;wp-image-927&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-12.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-12-300x24.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;其实就是出现的次数开方就得到了最终的值。&lt;/p&gt;



&lt;h2&gt;Inverse document frequency&lt;/h2&gt;



&lt;p&gt;IDF是说出现在越多的field中，那么分数就越低。所以它是通过下面公式进行计算的：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-13.png&quot; alt=&quot;&quot; class=&quot;wp-image-928&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-13.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-13-300x25.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;其中numDocs就是index有多少个documents，docFreq就是有多少个document中有这个term，很明显，docFreq越大，这个值就越小。&lt;/p&gt;



&lt;h2&gt;Field-length norm&lt;/h2&gt;



&lt;p&gt;FIN是说field的长度越大，则分数越小。所以它使用的公式如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-14.png&quot; alt=&quot;&quot; class=&quot;wp-image-929&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-14.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-14-300x24.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;很简单，term长度取根号之后被1除。很显然，长度越长，数值越小。&lt;/p&gt;



&lt;h2&gt;三者结合计算&lt;/h2&gt;



&lt;p&gt;有了上面三个值的计算方法之后，我们来看一下他们三个是如何计算出最终的score值的。我们先来看 一个最简单的例子，就是我们只搜索了一个term：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-15.png&quot; alt=&quot;&quot; class=&quot;wp-image-930&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-15.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-15-300x138.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;就是在quick brown box中搜索fox，那么它得到的结果就如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-16.png&quot; alt=&quot;&quot; class=&quot;wp-image-931&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-16.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-16-300x92.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;总得分数是0.15342641,其实就是下面的三个tf*idf*filedNorm。&lt;/li&gt;&lt;li&gt;Tf的值，因为fox就出现了一次，所以开根号之后还是1。&lt;/li&gt;&lt;li&gt;总共就一个documents，所以numDocs=1，出现fox的documents也是1，所以，根据上面的结果就可以得到对应的结果是0.30685282&lt;/li&gt;&lt;li&gt;这里的总得terms是3，然后根据上面的计算可以得到结果是0.5&lt;/li&gt;&lt;/ol&gt;



&lt;h2&gt;向量空间模型&lt;/h2&gt;



&lt;p&gt;上面的例子就是一个简单的term的情况，而事实上，我们一般会同时搜索多个词，这个时候的score如何计算呢？一个常见的方法就是使用向量空间模型，说白了就是给每个词一个权重，然后根据权重来计算最终的score值。&lt;/p&gt;



&lt;p&gt;比如说我们搜索happy hippopotamus这两个词，显然我们认为hippopotamus这个词的权重会大一点，比如我们给happy赋予的权重是2，hippopotamus赋予的权重是5，那么这里的向量值就是[2,5]。我们把它画到一个二维图中就如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-17.png&quot; alt=&quot;&quot; class=&quot;wp-image-932&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-17.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-17-300x203.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;现在我们假设我们有以下几个documents：&lt;/p&gt;



&lt;ol type=&quot;1&quot;&gt;&lt;li&gt;I am happy in summer.&lt;/li&gt;&lt;li&gt;After Christmas I’m a hippopotamus.&lt;/li&gt;&lt;li&gt;The happy hippopotamus helped Harry.&lt;/li&gt;&lt;/ol&gt;



&lt;p&gt;这样我们就可以根据这两个term在各个documents出现的情况来得到相应文本的向量：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-18.png&quot; alt=&quot;&quot; class=&quot;wp-image-933&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-18.png 362w, https://donggeitnote.com/wp-content/uploads/2021/09/image-18-300x94.png 300w&quot; sizes=&quot;(max-width: 362px) 100vw, 362px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;根据这个我们就可以得到对应的向量图如下所示：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-19.png&quot; alt=&quot;&quot; class=&quot;wp-image-934&quot; srcset=&quot;https://donggeitnote.com/wp-content/uploads/2021/09/image-19.png 624w, https://donggeitnote.com/wp-content/uploads/2021/09/image-19-300x200.png 300w&quot; sizes=&quot;(max-width: 624px) 100vw, 624px&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;这样一来，我们就可以根据它和查询的那个向量之间的夹角来计算相关性，这个夹角越大，那么相关性就越小。&lt;/p&gt;



&lt;p&gt;从人的观察来看，二维和三维的向限是比较容易直观理解的，但是对计算机来说，其实不管几维（搜索几个term）都是可以用同样的方法来计算最终结果的。&lt;/p&gt;



&lt;h1&gt;总结&lt;/h1&gt;



&lt;p&gt;本文重点介绍了ElasticSearch中的score的计算方法，希望能够给大家在平时的实践中提供理论的支撑。&lt;/p&gt;
                                                    &lt;nav class=&quot;pagination group&quot;&gt;
                      &lt;/nav&gt;
        &lt;/div&gt;

        
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>