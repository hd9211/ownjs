<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2117d50ff4768a62fbedaf6104ecd6f9</guid>
<title>Web3建设者的去中心化指南；科学居家运动指南；谷歌工程最佳实践｜码农周刊VIP会员专属Newsletter Vol.087</title>
<link>https://toutiao.io/k/gdesf1u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078463&amp;amp;idx=1&amp;amp;sn=95f0bdce33a58fcfca68d01de3c75cfd&amp;amp;chksm=bd2918088a5e911ee49f12cb649c16057350d1a11c884496460b3052d653f9fe80e31ac10f7b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavib3NlJt37DBSrTmLaGd7y82icbyrtFQ5edhQTZA13mpdrBmbianfFq2ib4Jiar4GBhSN4ppvVY1RrTgPQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0ODkyMA==&amp;amp;mid=2655078463&amp;amp;idx=1&amp;amp;sn=95f0bdce33a58fcfca68d01de3c75cfd&amp;amp;chksm=bd2918088a5e911ee49f12cb649c16057350d1a11c884496460b3052d653f9fe80e31ac10f7b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何获取优质信息？推荐一种高手都在用的方式！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何获取优质信息？推荐一种高手都在用的方式！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;本期，首先分享的是&lt;strong&gt;迪士尼CEO的45条领导哲学&lt;/strong&gt;，摘录几条，供参考。&lt;br/&gt;1）想要讲述精彩的故事，你就需要杰出的人才； &lt;br/&gt;2）拼死创新； &lt;br/&gt;3）在犯错时勇敢承担责任；&lt;br/&gt; 4）以善待人；&lt;br/&gt; 5）过去已逝，未来才是重点；&lt;br/&gt;……&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;科学居家运动指南&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;https://mp.weixin.qq.com/s/rL4GW-YfJL39GznOtHRSgA&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;如果你一时不能出门，没法到户外运动也去不了健身房、运动馆，在家也可以用一些简单的运动来帮助保持身体和心理的健康。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;Web3 建设者的去中心化指南：原则、模型、方法&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://mp.weixin.qq.com/s/7kxUA2oQp_POklrNJuZSwA&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以多个场景为例对 Web3 应用去中心化的基本原理与方法进行深度解析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;谷歌工程最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/q19mmjh&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google 团队长期以来的内部项目最佳实践&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;10道不得不会的JVM面试题&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/t1vquz4&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;试试吧&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Rust语言中不可变性、可变性、内部可变性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/01n5z5r&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构杂谈&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GitHub 最受欢迎的Top 20 JavaScript 项目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/pc5k15b&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;Git 全功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/k2gx16j&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;2022年MySQL最新面试题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/to1dvco&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基础知识&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd76875173a8e8570cc188d9632eeebe</guid>
<title>9大高性能优化经验总结，强烈建议收藏！！！</title>
<link>https://toutiao.io/k/26za4ep</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mid=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;点击蓝字&lt;/span&gt;&lt;span&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;&lt;span&gt;△&lt;/span&gt;&lt;/span&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;【&lt;/span&gt;&lt;span&gt;架构&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;&lt;span&gt;领取300期+原创架构技术系列文章与1000+大厂面试题答案合集&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.400352733686067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVrWjNky6BuHcED9ibNbodAg6lfiaE5LCcZKKVbs2CYic8Azia2GVx0iba3V0UhibEKajJur5UW00fd2jxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot; title=&quot;9大性能优化经验总结，强烈建议收藏！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;p&gt;性能优化基本属于Java高级岗的必备技能了，特备对于大流量的互联网应用至关重要@&lt;a href=&quot;https://mikechen.cc/&quot; data-linktype=&quot;2&quot;&gt;mikechen&lt;/a&gt;&lt;/p&gt;&lt;p&gt;今天主要给大家介绍下9种性能优化：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7040169133192389&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVrWjNky6BuHcED9ibNbodAgPfSWoDhWK8qzlO4rov7OwGicVnHLqUxGFoTRELVs0NOaicure2O5WyIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1419&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;nav&gt;&lt;p&gt;&lt;span&gt;1.代码&lt;/span&gt;&lt;/p&gt;&lt;/nav&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;之所以把代码放到第一位，是因为这一点最容易引忽视，比如拿到一个性能优化的需求以后，言必称缓存、异步等。&lt;/p&gt;&lt;p&gt;实际上，第一步就应该是分析相关的代码，找出相应的瓶颈，再来考虑具体的优化策略。&lt;/p&gt;&lt;p&gt;有一些性能问题，完全是由于代码写的不合理，通过直接修改一下代码就能解决问题的，比如for循环次数过多、作了很多无谓的条件判断、相同逻辑重复多次等，这样的优化成本是最低的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span/&gt;2.数据库&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31837307152875177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVrWjNky6BuHcED9ibNbodAg9JT6PFnPTsq0icljR0HrQSQS9MYiarx1jFvPnEIQ9uX3C8jOEiaMuEnIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot; title=&quot;9大性能优化经验总结，强烈建议收藏！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;1.SQL优化&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;这里以MySQL为例，最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线。&lt;/p&gt;&lt;p&gt;这里举几个优化的例子：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.查询优化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.避免null判断&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; id &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; t &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; num &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3.避免全表扫描&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;应尽量避免在 where 子句中使用 != 或 &amp;lt;&amp;gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。&lt;/p&gt;&lt;p&gt;应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;&lt;p&gt;in和 not in 也要慎用，否则会导致全表扫描，如：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; id &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; t &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; num &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;对于连续的数值，能用 between就不要用 in 了：&lt;/p&gt;&lt;pre data-enlighter-language=&quot;generic&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; id &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; t &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; num between &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.大数据量查询&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于多张大数据量的表JOIN，要先分页再JOIN，否则逻辑读会很高。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5.合理使用索引&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。&lt;/p&gt;&lt;p&gt;一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;6.多使用数字型字段&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。&lt;/p&gt;&lt;p&gt;这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;7.避免大数量&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;8.避免大事务&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;尽量避免大事务操作，提高系统并发能力。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h3&gt;&lt;span/&gt;2.连接池调优&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;我们的应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池。&lt;/p&gt;&lt;p&gt;随着业务访问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，通过反复的几次调试得到最终的调优参数。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h3&gt;&lt;span/&gt;3.架构层面&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;这一类调优包括读写分离、多从库负载均衡、水平和垂直分库分表等方面，一般需要的改动较大，但是频率没有SQL调优高，而且一般需要DBA来配合参与。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5283757338551859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVrWjNky6BuHcED9ibNbodAgSIOWZ5zThVBYql0CLq25cSua8NkJibaTRebIvib12iccNaW51IR5G7UbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot; title=&quot;9大性能优化经验总结，强烈建议收藏！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span/&gt;3.分布式缓存&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;缓存可以称的上是性能优化的利器，缓存主要用来存放那些读写比很高、很少变化的数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3347778981581798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVrWjNky6BuHcED9ibNbodAg03j0QPB2bTlYtcNTmSSG0D7ybKDcoAJUGiaPoC26oedQNialvnFCkeibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1846&quot; title=&quot;9大性能优化经验总结，强烈建议收藏！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;p&gt;什么情况适合用缓存？考虑以下两种场景：&lt;/p&gt;&lt;p&gt;使用缓存需要注意的问题：&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;1.避免缓存失效&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;把频繁修改的数据放入缓存，容易出现数据写入缓存后，应用还来不及读取缓存，数据就已经失效的情形，徒增系统负担。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;2.缓存热点数据&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;缓存使用的内存资源非常宝贵，只能将最新访问的数据缓存起来，而把历史数据清理出缓存，即缓存资源应该留给20%的热点数据。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt; 3.数据不一致性&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;一般会对缓存设置失效时间，超过失效时间，就要从数据库重新加载。&lt;/p&gt;&lt;p&gt;因此应用要忍受一定时间的数据不一致，另一种策略是数据更新时立即更新缓存，不过这也会带来更多的系统开销和事务一致性的问题。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt; 4.缓存可用性&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;业务发展到一定阶段时，缓存会承担大部分数据访问的压力，数据库已经习惯了有缓存的日子，所以当缓存服务器崩溃时，数据库会因为完全不能承受如此大的压力而宕机，进而导致整个网站不可用，这种情况被称作缓存雪崩，发生这种故障，甚至不能简单地重启缓存服务器和数据库服务器来恢复网站访问。&lt;/p&gt;&lt;p&gt;解决方式：&lt;/p&gt;&lt;p&gt;1）缓存热备（当某台服务器宕机时，将缓存访问切换到热备服务器上；&lt;/p&gt;&lt;p&gt;2）缓存服务器集群。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;5. 缓存预热&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;缓存中存放的是热点数据，热点数据是缓存系统用LRU对不断访问的数据筛选出来的，这个过程需要较长的时间。&lt;/p&gt;&lt;p&gt;新启动的缓存系统没有任何数据，此时系统的性能和数据库负载都不太好。因此可以选择在启动缓存是就把热点数据预加载好。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt; 6.缓存穿透&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;因为不恰当的业务或恶意攻击，持续高并发地访问某一个不存在的数据，如果缓存不保存该数据，就会有大量的请求压力落在数据库上。&lt;/p&gt;&lt;p&gt;简单的解决方式是把请求的不存在的数据也放进缓存，其value是null。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;4.异步化&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;针对某些客户端的请求，在服务端可能需要针对这些请求做一些附属的事情，这些事情其实用户并不关心或者用户不需要立即拿到这些事情的处理结果，这种情况就比较适合用异步的方式处理这些事情。&lt;/p&gt;&lt;p&gt;异步化的作用：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt; 缩短接口响应时间，使用户的请求快速返回，用户体验更好。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 避免线程长时间处于运行状态，这样会引起服务线程池的可用线程长时间不够用，进而引起线程池任务队列长度增大，从而阻塞更多请求任务，使得更多请求得不到技术处理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 线程长时间处于运行状态，可能还会引起系统Load、CPU使用率、机器整体性能下降等一系列问题，甚至引发雪崩。异步的思路可以在不增加机器数和CPU数的情况下，有效解决这个问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;比如：使用消息队列（MQ）中间件服务，MQ天生就是异步的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8270967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVrWjNky6BuHcED9ibNbodAgpmic3Ic6lQHBepNng8MjPRfgj5acbQ2VroCazk1mPDUw9m890KtRu4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;775&quot; title=&quot;9大性能优化经验总结，强烈建议收藏！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;p&gt;一些额外的任务，可能不需要我这个系统来处理，但是需要其他系统来处理，这个时候可以先把它封装成一个消息，扔到消息队列里面，通过消息中间件的可靠性保证把消息投递到关心它的系统，然后让这个系统来做相应的处理。&lt;/p&gt;&lt;p&gt;再比如C端在完成一个提单动作以后，可能需要其它端做一系列的事情，但是这些事情的结果不会立刻对C端用户产生影响，那么就可以先把C端下单的请求响应先返回给用户，返回之前往MQ中发一个消息即可，而且这些事情理应不是C端的负责范围，所以这个时候用MQ的方式，来解决这个问题最合适。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span/&gt;5.Web前段&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Web前端指网站业务逻辑之前的部分，包括：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3108298171589311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVrWjNky6BuHcED9ibNbodAggJwlEnbibUeKrCHgNBrZElu8MOE6SicUlEsAo7pOWeMYXY8jx9FMY19A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot; title=&quot;9大性能优化经验总结，强烈建议收藏！-mikechen的互联网架构&quot;/&gt;&lt;/p&gt;&lt;p&gt;主要优化手段有优化浏览器访问，使用反向代理，CDN等。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;1.浏览器访问优化&lt;span/&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span/&gt;(1)减少http请求&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;HTTP协议是无状态的应用层协议，意味着每次HTTP请求都需要简历通信链路，进行数据传输，而在服务器端，每个HTTP都需要启动独立的线程去处理，这些通信和服务的开销都很昂贵，减少HTTP请求的数目可有效提高访问性能。&lt;/p&gt;&lt;p&gt;减少HTTP请求的主要手段是:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt; 合并CSS，以及压缩CSS大小&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 合并JavaScript，以及压缩JS大小&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 合并图片&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将浏览器一次访问需要的JavaScript,CSS合并成一个文件，这样浏览器就只需要一次请求。多张图片合并成一张，如果每张图片都有不同的超链接，可通过CSS偏移响应鼠标点击操作，构造不同的URL。&lt;/p&gt;&lt;h4&gt;&lt;span/&gt;(2)使用浏览器缓存&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;对一个网站而言，CSS,JavaScript,Logo,图标等这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次HTTP请求都需要的，如果将这些文件缓存在浏览器中，可以极好地改善性能。通过设置HTTP头中Cache-Control和Expires属性，可设定浏览器缓存，缓存时间可以是数天甚至是几个月。有时候，静态资源文件变化需要及时应用到客户端浏览器，这种情况可以通过改变文件名实现，比如一般会在JavaScript后面加上一个版本号，使浏览器刷新修改的文件。&lt;/p&gt;&lt;h4&gt;&lt;span/&gt;(3)启用压缩&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效较少通信传输的数据量。文本文件的压缩效率科大80%以上。&lt;/p&gt;&lt;h4&gt;&lt;span/&gt;(4)CSS放在页面最上面，JavaScript放在页面最下面&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;浏览器会在下载完全部CSS之后对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS。JS则想法，浏览器在加载JS后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此JS最好放在页面最下面。&lt;/p&gt;&lt;h4&gt;&lt;span/&gt;(5)减少Cookie传输&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;一方面，Cookie包含在每次请求和响应中，太大的Cookie会严重影响数据传输，因此哪些数据需要写入Cookie需要慎重考虑，尽量减少Cookie中传输的数据量。另一方面，对于某些静态资源的访问，如CSS,JS等，发送Cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送Cookie，减少Cookie传输的次数。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;2.CDN加速&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;CDN(Content Distribute Network,内存分发网络)的本质上仍然是一个缓存，而且将数据缓存在离用户最近的地方，是用户以最快速度获取数据，即所谓网络访问第一跳。&lt;/p&gt;&lt;p&gt;CDN一般缓存的是静态资源，如图片，文件，CSS，Script脚本，静态网页等，但是这些文件访问频率很高，将其缓存在CDN可极大改善网页的打开速度。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;3.反向代理&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;传统代理服务器位于浏览器一侧，代理浏览器将HTTP请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站Web服务器接收HTTP请求。&lt;/p&gt;&lt;p&gt;和传统代理服务器可以保护浏览器安全一样，反向代理服务器也具有保护网站安全的作用，来自互联网的访问请求必须经过代理服务器，相当于在Web服务器和可能的网络攻击之间建立了一个屏障。&lt;/p&gt;&lt;p&gt;除了安全功能，代理服务器也可以通过配置缓存功能加速Web请求，当用户第一次访问静态内容的时候，静态内容就被缓存在反向代理服务器上，这样当其他用户访问该静态内容的时候，就可以直接从反向代理服务器返回，加速Web请求响应速度，减轻服务器负载要。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;strong&gt;6.服务化&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;做服务化最基础的是按业务做服务拆分，避免跨业务间的互相影响，数据和服务同时拆分。同一个业务内部我们还按计算密集型/IO密集型的服务拆分、C端/B端服务拆分、核心/非核心服务拆分、高频服务单独部署等原则做拆分。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;strong&gt;7.硬件升级&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;硬件问题对性能的影响不容忽视。&lt;/p&gt;&lt;p&gt;举一个例子：一个DB集群经常有慢SQL报警，业务排查下来发现SQL都很简单，该做的索引优化也都做了，后来DBA同学帮忙定位到问题是硬件过旧导致，将机械硬盘升级成固态硬盘之后报警立马消失了，效果立竿见影！&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;strong&gt;8.搜索引擎&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;复杂查询以及一些聚合计算不适合在数据库中做，可以利用搜索引擎来实现，另外搜索引擎还可以帮我们很好的解决跨库、跨数据源检索的场景。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;strong&gt;9.产品逻辑优化&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;业务逻辑优化经常会容易被忽略，但效果却往往比&lt;a href=&quot;https://mikechen.cc/collection/performance&quot; data-linktype=&quot;2&quot;&gt;数据库性能优化&lt;/a&gt;、&lt;a href=&quot;https://mikechen.cc/3321.html&quot; data-linktype=&quot;2&quot;&gt;JVM调优&lt;/a&gt;之类的来的更明显。&lt;/p&gt;&lt;p&gt;举一个例子，12306春运抢火车票的场景，由于访问的人多，用户点击“查票”之后系统会非常卡，进度条非常慢，作为用户，我们会习惯性的再去点“查票”，可能会连续点个好几次。&lt;/p&gt;&lt;p&gt;假设平均一个用户点5次，则后端系统负载就增加了5倍！而其中80%的请求是重复请求。&lt;/p&gt;&lt;p&gt;这个时候我们可以通过产品逻辑的方式来优化，比如，在用户点击查询之后将“按钮置灰”，或者通过JS控制xx秒只能只能提交一次请求等，有效的拦截了80%的无效流量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;必看●文章干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MDAxNDEwMA==&amp;amp;mid=2247488808&amp;amp;idx=1&amp;amp;sn=258331df45fc236b0650e3e1b197398a&amp;amp;chksm=fcf4b5d3cb833cc555733775e15df0075e56cef9e8cbce6034927b7dcd79b633e5437e998bcc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;史上最强消息队列MQ万字图文总结！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/8280.html&quot; textvalue=&quot;JVM(Java虚拟机)从0到1全部合集，强烈建议收藏！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;JVM(Java虚拟机)从0到1全部合集，强烈建议收藏！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/8225.html&quot; textvalue=&quot;Java多线程与并发系列从0到1全部合集，强烈建议收藏！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Java多线程与并发系列从0到1全部合集，强烈建议收藏！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/7161.html&quot; textvalue=&quot;单点登录SSO的实现原理与方案详解&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;单点登录SSO的实现原理与方案详解&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/7319.html&quot; textvalue=&quot;史上最强消息队列MQ万字图文总结！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;史上最强消息队列MQ万字图文总结！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;必看●视频干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;如何快速达到50W+年薪？我的独家经验分享！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;如何快速达到50W+年薪？我的独家经验分享！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;如何快速达到50W+年薪？我的独家经验分享！视频详解&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;阿里P6-&amp;gt;P7-&amp;gt;P8有哪些技能要求？哪些技术栈需要精通？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;阿里P6-&amp;gt;P7-&amp;gt;P8的技能要求？独家完整揭秘！视频详解&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;大厂必考的HashMap有哪些必考点？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;大厂必考的HashMap底层实现源码深度剖析&lt;/a&gt;！&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;Redis如何实现高性能？有哪3大核心原因？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;视频详解&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;如何快速达到50W+年薪？我的独家经验分享！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;2022金三银四最新一线大厂Java必考题解析！视频详解&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;手把手教你如何阅读RocketMQ中间件源码？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;手把手教你如何阅读RocketMQ中间件源码？&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;Redis如何实现高性能？有哪3大核心原因？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;视频详解&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mikechen.cc/779.html&quot; textvalue=&quot;如何快速达到50W+年薪？我的独家经验分享！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注「mikechen的互联网架构」公众号，回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;【&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，领取我&lt;/span&gt;原创的300期+架构技术系列文章与1000+大厂面试题答案合集&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你对大厂、架构等感兴趣或者遇到职业发展瓶颈想交流，&lt;span&gt;关注「mikechen的互联网架构」公众号，&lt;/span&gt;回复&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;【交流】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，即可加我微信，一起交流学习。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SdOdAZX2thVeCmXchLLhiaOatUyyjibibUOMaT2IXKy4LugIbJCmwe90rvtjQRl1DMABWl11jPQvuPdrmibVia3ppOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>60cfaf5f1f4d5359433afc8695764958</guid>
<title>大前端性能体系建设，记住这几条tips</title>
<link>https://toutiao.io/k/lxaqahw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context wx_tap_card js_wx_tap_highlight&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                  
                  &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;HeapDump性能社区&lt;/strong&gt;
                                          &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                      &lt;p class=&quot;original_primary_desc&quot;&gt;PerfMa旗下专注于性能领域的技术社区。为您提供性能领域的知识、问答、课程，以及各种解决性能问题的工具插件。&lt;/p&gt;
                                      &lt;/div&gt;
                  &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                &lt;/a&gt;
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8df54fdb49c587e7bff5e4690da8e7ef</guid>
<title>基于HiKariCP组件，分析连接池原理</title>
<link>https://toutiao.io/k/n613vsx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;池塘里养：Connection；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、设计与原理&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基础案例&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;HiKariCP作为SpringBoot2框架的默认连接池，号称是跑的最快的连接池，数据库连接池与之前两篇提到的线程池和对象池，从设计的原理上都是基于池化思想，只是在实现方式上有各自的特点；首先还是看HiKariCP用法的基础案例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; com.zaxxer.hikari.HikariConfig;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.zaxxer.hikari.HikariDataSource;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.sql.Connection;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.sql.ResultSet;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.sql.Statement;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConPool&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HikariConfig &lt;span&gt;buildConfig&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        HikariConfig hikariConfig = &lt;span&gt;new&lt;/span&gt; HikariConfig() ;&lt;br/&gt;        &lt;span&gt;// 基础配置&lt;/span&gt;&lt;br/&gt;        hikariConfig.setJdbcUrl(&lt;span&gt;&quot;jdbc:mysql://127.0.0.1:3306/junit_test?characterEncoding=utf8&quot;&lt;/span&gt;);&lt;br/&gt;        hikariConfig.setUsername(&lt;span&gt;&quot;root&quot;&lt;/span&gt;);&lt;br/&gt;        hikariConfig.setPassword(&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 连接池配置&lt;/span&gt;&lt;br/&gt;        hikariConfig.setPoolName(&lt;span&gt;&quot;dev-hikari-pool&quot;&lt;/span&gt;);&lt;br/&gt;        hikariConfig.setMinimumIdle(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        hikariConfig.setMaximumPoolSize(&lt;span&gt;8&lt;/span&gt;);&lt;br/&gt;        hikariConfig.setIdleTimeout(&lt;span&gt;600000L&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; hikariConfig ;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 构建数据源&lt;/span&gt;&lt;br/&gt;        HikariDataSource dataSource = &lt;span&gt;new&lt;/span&gt; HikariDataSource(buildConfig()) ;&lt;br/&gt;        &lt;span&gt;// 获取连接&lt;/span&gt;&lt;br/&gt;        Connection connection = dataSource.getConnection() ;&lt;br/&gt;        &lt;span&gt;// 声明SQL执行&lt;/span&gt;&lt;br/&gt;        Statement statement = connection.createStatement();&lt;br/&gt;        ResultSet resultSet = statement.executeQuery(&lt;span&gt;&quot;SELECT count(1) num FROM jt_activity&quot;&lt;/span&gt;) ;&lt;br/&gt;        &lt;span&gt;// 输出执行结果&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (resultSet.next()) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;query-count-result：&quot;&lt;/span&gt;+resultSet.getInt(&lt;span&gt;&quot;num&quot;&lt;/span&gt;));&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、核心相关类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HikariDataSource类&lt;/strong&gt;：汇集数据源描述的相关信息，例如配置、连接池、连接对象、状态管理等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HikariConfig类&lt;/strong&gt;：维护数据源的配置管理，以及参数校验，例如userName、passWord、minIdle、maxPoolSize等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;HikariPool类&lt;/strong&gt;：提供对连接池与池中对象管理的核心能力，并实现池相关监控数据的查询方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ConcurrentBag类&lt;/strong&gt;：抛弃了常规池中采用的阻塞队列作为容器的方式，自定义该并发容器来存储连接对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PoolEntry类&lt;/strong&gt;：拓展连接对象的信息，例如状态、时间等，方便容器中追踪这些实例化对象；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过对连接池中几个核心类的分析，也能直观地体会到该源码的设计原理，与上篇总结的对象池应用有异曲同工之妙，只是不同的组件不同的开发者在实现的时候，都具备各自的抽象逻辑。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、加载逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDgPbk1z87ibOlfz4x3Kia3R4tXsTujHNibZlMGHl9ULI680jZ49diaCM5APcGkHohnwEiaAYzEibQaTzLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过配置信息去构建数据源描述，在构造方法中基于配置再去实例化连接池，在HikariPool的构造中，实例化ConcurrentBag容器对象；下面再从源码层面分析实现细节。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、容器分析&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、容器结构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;容器ConcurrentBag类提供PoolEntry类型的连接对象存储，以及基本的元素管理能力，对象的状态描述；虽然被HikariPool对象池类所持有，但是实际的操作逻辑是在该类中；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.1 基础属性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;其中最为核心的是&lt;code&gt;sharedList&lt;/code&gt;共享集合、&lt;code&gt;threadList&lt;/code&gt;线程级缓存、&lt;code&gt;handoffQueue&lt;/code&gt;即时队列；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 共享对象集合，存放数据库连接&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; CopyOnWriteArrayList&amp;lt;T&amp;gt; sharedList;&lt;br/&gt;&lt;span&gt;// 缓存线程级连接对象，会被优先使用，避免被争抢&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;List&amp;lt;Object&amp;gt;&amp;gt; threadList;&lt;br/&gt;&lt;span&gt;// 等待获取连接的线程数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger waiters;&lt;br/&gt;&lt;span&gt;// 标记是否关闭&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; closed;&lt;br/&gt;&lt;span&gt;// 即时处理连接的队列，当有等待线程时，通过该队列将连接分配给等待线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SynchronousQueue&amp;lt;T&amp;gt; handoffQueue;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;1.2 状态描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在ConcurrentBag类中的IConcurrentBagEntry内部接口，被PoolEntry类实现，该接口定义连接对象的状态：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;STATE_NOT_IN_USE：未使用，即闲置中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;STATE_IN_USE：使用中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;STATE_REMOVED：被废弃；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;STATE_RESERVED：保留态，中间状态，用于尝试驱逐连接对象时；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、包装对象&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;容器的基本能力是用来存储连接对象的，而对象的管理则需要很多扩展的跟踪信息，以有效的完成各种场景下的识别，此时就需要借助包装类的引入；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 业务真正使用的连接对象&lt;/span&gt;&lt;br/&gt;Connection connection;&lt;br/&gt;&lt;span&gt;// 最近访问时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;long&lt;/span&gt; lastAccessed;&lt;br/&gt;&lt;span&gt;// 最近借出时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;long&lt;/span&gt; lastBorrowed;&lt;br/&gt;&lt;span&gt;// 状态描述&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 是否驱逐&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; evict;&lt;br/&gt;&lt;span&gt;// 生命周期结束时的调度任务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt; endOfLife;&lt;br/&gt;&lt;span&gt;// 连接生成的Statement对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FastList&amp;lt;Statement&amp;gt; openStatements;&lt;br/&gt;&lt;span&gt;// 池对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HikariPool hikariPool;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要注意FastList类实现List接口，为HiKariCP组件自定义，相比ArrayList类，出于对性能的追求，在元素的管理时，去掉诸多的范围校验。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、对象管理&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;基于连接池的常规用法，来看看连接对象具体是如何管理，比如被借出，被释放，被废弃等，以及这些操作下对象的状态转换过程；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、初始化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;上文&lt;strong&gt;加载逻辑&lt;/strong&gt;的描述中，已经提到在构建数据源的时候，会根据配置实例化连接池，在初始化的时候，基于两个核心切入点来分析源码：1.实例化多少连接对象、2.连接对象转换包装对象；&lt;/p&gt;&lt;p&gt;在连接池的构造中执行了&lt;code&gt;checkFailFast&lt;/code&gt;方法，在该方法内执行MinIdle最小空闲数的判断，如果大于0，则创建一个包装对象并放入容器中；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDgPbk1z87ibOlfz4x3Kia3R4l00I0uEMyMX82tmFS7RliajZFojG3bYHJY7TQshMLwl73KUW6bK1m5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;HikariPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; HikariConfig config)&lt;/span&gt; &lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;checkFailFast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; PoolEntry poolEntry = createPoolEntry();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (config.getMinimumIdle() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        connectionBag.add(poolEntry);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意两个问题，创建的连接包装对象，初始状态是0即闲置中；另外虽然案例中设置&lt;code&gt;MinIdle=4&lt;/code&gt;的值，但是这里的判断大于0，也只在容器中预先放入一个空闲对象；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、借用对象&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;从池中获取连接对象时，实际调用的是容器类中的&lt;code&gt;borrow&lt;/code&gt;方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; Connection HikariPool.getConnection(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; hardTimeout) &lt;span&gt;throws&lt;/span&gt; SQLException ;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; T ConcurrentBag.borrow(&lt;span&gt;long&lt;/span&gt; timeout, &lt;span&gt;final&lt;/span&gt; TimeUnit timeUnit) &lt;span&gt;throws&lt;/span&gt; InterruptedException ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDgPbk1z87ibOlfz4x3Kia3R4up2y4Dr3hVpNwVicBMZD3IAzV1Vlv0MPmnkNdgQ6rsuL33ScKKKa7LA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在执行&lt;code&gt;borrow&lt;/code&gt;方法时，涉及如下几个核心步骤与逻辑：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;borrow&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeout, &lt;span&gt;final&lt;/span&gt; TimeUnit timeUnit)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 遍历本地线程缓存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; list = threadList.get();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = list.size() - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;       &lt;span&gt;final&lt;/span&gt; Object entry = list.remove(i);&lt;br/&gt;       &lt;span&gt;final&lt;/span&gt; T bagEntry = weakThreadLocals ? ((WeakReference&amp;lt;T&amp;gt;) entry).get() : (T) entry;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (bagEntry != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) { }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 增加等待线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; waiting = waiters.incrementAndGet();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 遍历Shared共享集合&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (T bagEntry : sharedList) {&lt;br/&gt;           &lt;span&gt;if&lt;/span&gt; (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) { }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 一定时间内轮询handoff队列&lt;/span&gt;&lt;br/&gt;        listener.addBagItem(waiting);&lt;br/&gt;        timeout = timeUnit.toNanos(timeout);&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;final&lt;/span&gt; T bagEntry = handoffQueue.poll(timeout, NANOSECONDS);&lt;br/&gt;        } &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 减少等待线程数&lt;/span&gt;&lt;br/&gt;       waiters.decrementAndGet();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先反向遍历本地线程缓存，如果存在空闲连接，则返回该对象；如果没有则寻找共享集合；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遍历Shared共享集合前，会标记等待线程数加1，如果存在空闲连接则直接返回；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当Shared共享集合中也没有空闲连接时，这时当前线程进行一定时间的&lt;code&gt;handoffQueue&lt;/code&gt;队列轮询，可能会有资源的释放，也可能是新添加的资源；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意这里在遍历集合时，取出的对象都会对状态进行判断和更新，如果得到空闲对象，会更新为&lt;code&gt;IN_USE&lt;/code&gt;状态，然后返回；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、释放对象&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;从池中释放连接对象时，实际调用的是容器类中的&lt;code&gt;requite&lt;/code&gt;方法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt; HikariPool.recycle(&lt;span&gt;final&lt;/span&gt; PoolEntry poolEntry) ;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConcurrentBag.requite(&lt;span&gt;final&lt;/span&gt; T bagEntry) ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDgPbk1z87ibOlfz4x3Kia3R4K9xlEhRra4HghU6QlZeDAbzuuOeJkU2abNzGByNEyoDo8XicJRbXkHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在释放连接对象时，首先更新对象状态为空闲，然后判断当前是否有等待的线程，在&lt;code&gt;borrow&lt;/code&gt;方法中等待线程会进入一定时间的轮询，如果没有的话则把对象放入本地线程缓存中：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;requite&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; T bagEntry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 更新状态&lt;/span&gt;&lt;br/&gt;    bagEntry.setState(STATE_NOT_IN_USE);&lt;br/&gt;    &lt;span&gt;// 等待线程判断&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; waiters.get() &amp;gt; &lt;span&gt;0&lt;/span&gt;; i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (bagEntry.getState() != STATE_NOT_IN_USE || handoffQueue.offer(bagEntry)) { }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 本地线程缓存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; threadLocalList = threadList.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (threadLocalList.size() &amp;lt; &lt;span&gt;50&lt;/span&gt;) {&lt;br/&gt;        threadLocalList.add(weakThreadLocals ? &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(bagEntry) : bagEntry);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意这里涉及到连接对象的状态从使用中转为&lt;code&gt;NOT_IN_USE&lt;/code&gt;空闲；&lt;code&gt;borrow&lt;/code&gt;与&lt;code&gt;requite&lt;/code&gt;作为连接池中两个核心方法，负责资源创建与回收；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;本篇文章并没有站在HiKariCP组件的整体设计上构思，只是分析连接池这冰山一角，尽管只是部分源码，但是已经足够彰显出作者对于性能的极致追求，比如：本地线程缓存、自定义容器类型、FastList等；能被普遍采用必然存在诸多支撑的理由。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、参考源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;br/&gt;组件封装：&lt;br/&gt;https://gitee.com/cicadasmile/butte-frame-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19a44c41e98240c12cbaad6b1ef1f9ec</guid>
<title>面试官：来说一说Go语言的函数调用惯例</title>
<link>https://toutiao.io/k/7nne2ee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈喽，大家好，我是&lt;code&gt;asong&lt;/code&gt;。好久没有更新了，最近因工作需要忙着写&lt;code&gt;python&lt;/code&gt;，&lt;code&gt;Go&lt;/code&gt;语言我都有些生疏了，但是我不能放弃&lt;code&gt;Go&lt;/code&gt;语言，该学习还是要学习的，今天与大家聊一聊&lt;code&gt;Go&lt;/code&gt;语言的函数调用惯例，调用惯例是调用方和被调用方对于参数和返回值传递的约定，Go语言的调用惯例在1.17版本进行了优化，本文我们就看一下两个版本的调用惯例是什么样的吧～。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.17版本前栈传递&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go1.17&lt;/code&gt;版本之前，&lt;code&gt;Go&lt;/code&gt;语言函数调用是通过栈来传递的，我们使用&lt;code&gt;Go1.12&lt;/code&gt;版本写个例子来看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a + b, a - b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; Test(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行&lt;code&gt;go tool compile -S -N -l main.go&lt;/code&gt;可以看到其汇编指令，我们分两部分来看，先看&lt;code&gt;main&lt;/code&gt;函数部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;.main STEXT size=&lt;span&gt;68&lt;/span&gt; args=&lt;span&gt;0x0&lt;/span&gt; locals=&lt;span&gt;0x28&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        TEXT    &lt;span&gt;&quot;&quot;&lt;/span&gt;.main(SB), ABIInternal, $&lt;span&gt;40&lt;/span&gt;&lt;span&gt;-0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        MOVQ    (TLS), CX&lt;br/&gt;        &lt;span&gt;0x0009&lt;/span&gt; &lt;span&gt;00009&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        CMPQ    SP, &lt;span&gt;16&lt;/span&gt;(CX)&lt;br/&gt;        &lt;span&gt;0x000d&lt;/span&gt; &lt;span&gt;00013&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        JLS     &lt;span&gt;61&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x000f&lt;/span&gt; &lt;span&gt;00015&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        SUBQ    $&lt;span&gt;40&lt;/span&gt;, SP &lt;span&gt;// 分配40字节栈空间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0013&lt;/span&gt; &lt;span&gt;00019&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        MOVQ    BP, &lt;span&gt;32&lt;/span&gt;(SP) &lt;span&gt;// 基址指针存储到栈上&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0018&lt;/span&gt; &lt;span&gt;00024&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        LEAQ    &lt;span&gt;32&lt;/span&gt;(SP), BP&lt;br/&gt;        &lt;span&gt;0x001d&lt;/span&gt; &lt;span&gt;00029&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;0&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x001d&lt;/span&gt; &lt;span&gt;00029&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;1&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x001d&lt;/span&gt; &lt;span&gt;00029&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;3&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x001d&lt;/span&gt; &lt;span&gt;00029&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        PCDATA  $&lt;span&gt;2&lt;/span&gt;, $&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x001d&lt;/span&gt; &lt;span&gt;00029&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        PCDATA  $&lt;span&gt;0&lt;/span&gt;, $&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x001d&lt;/span&gt; &lt;span&gt;00029&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        MOVQ    $&lt;span&gt;10&lt;/span&gt;, (SP) &lt;span&gt;// 第一个参数压栈&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0025&lt;/span&gt; &lt;span&gt;00037&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        MOVQ    $&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;(SP) &lt;span&gt;// 第二个参数压栈&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x002e&lt;/span&gt; &lt;span&gt;00046&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        CALL    &lt;span&gt;&quot;&quot;&lt;/span&gt;.Test(SB) &lt;span&gt;// 调用函数Test &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0033&lt;/span&gt; &lt;span&gt;00051&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;)        MOVQ    &lt;span&gt;32&lt;/span&gt;(SP), BP &lt;span&gt;// Test函数返回后恢复栈基址指针&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0038&lt;/span&gt; &lt;span&gt;00056&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;)        ADDQ    $&lt;span&gt;40&lt;/span&gt;, SP &lt;span&gt;// 销毁40字节栈内存&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x003c&lt;/span&gt; &lt;span&gt;00060&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;)        RET &lt;span&gt;// 返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x003d&lt;/span&gt; &lt;span&gt;00061&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;)        NOP&lt;br/&gt;        &lt;span&gt;0x003d&lt;/span&gt; &lt;span&gt;00061&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        PCDATA  $&lt;span&gt;0&lt;/span&gt;, $&lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x003d&lt;/span&gt; &lt;span&gt;00061&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        PCDATA  $&lt;span&gt;2&lt;/span&gt;, $&lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x003d&lt;/span&gt; &lt;span&gt;00061&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        CALL    runtime.morestack_noctxt(SB)&lt;br/&gt;        &lt;span&gt;0x0042&lt;/span&gt; &lt;span&gt;00066&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        JMP     &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;b &lt;span&gt;0&lt;/span&gt;c &lt;span&gt;25&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;b &lt;span&gt;61&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;76&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;e &lt;span&gt;48&lt;/span&gt;  eH..%....H;a.v.H&lt;br/&gt;        &lt;span&gt;0x0010&lt;/span&gt; &lt;span&gt;83&lt;/span&gt; ec &lt;span&gt;28&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; &lt;span&gt;89&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;c &lt;span&gt;24&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;d &lt;span&gt;6&lt;/span&gt;c &lt;span&gt;24&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; c7 &lt;span&gt;04&lt;/span&gt;  ..(H.l$ H.l$ H..&lt;br/&gt;        &lt;span&gt;0x0020&lt;/span&gt; &lt;span&gt;24&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;a &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; c7 &lt;span&gt;44&lt;/span&gt; &lt;span&gt;24&lt;/span&gt; &lt;span&gt;08&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; e8 &lt;span&gt;00&lt;/span&gt;  $....H.D$.......&lt;br/&gt;        &lt;span&gt;0x0030&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;b &lt;span&gt;6&lt;/span&gt;c &lt;span&gt;24&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;48&lt;/span&gt; &lt;span&gt;83&lt;/span&gt; c4 &lt;span&gt;28&lt;/span&gt; c3 e8 &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;  ...H.l$ H..(....&lt;br/&gt;        &lt;span&gt;0x0040&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; &lt;span&gt;00&lt;/span&gt; eb bc                                      ....&lt;br/&gt;        rel &lt;span&gt;5&lt;/span&gt;+&lt;span&gt;4&lt;/span&gt; t=&lt;span&gt;16&lt;/span&gt; TLS+&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        rel &lt;span&gt;47&lt;/span&gt;+&lt;span&gt;4&lt;/span&gt; t=&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;.Test+&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        rel &lt;span&gt;62&lt;/span&gt;+&lt;span&gt;4&lt;/span&gt; t=&lt;span&gt;8&lt;/span&gt; runtime.morestack_noctxt+&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的汇编指令我们可以分析出，参数&lt;code&gt;10&lt;/code&gt;、&lt;code&gt;20&lt;/code&gt;按照从右向左进行压栈，所以第一个参数在栈顶的位置&lt;code&gt;SP~SP+8&lt;/code&gt;，第二个参数存储在&lt;code&gt;SP+8 ~ SP+16&lt;/code&gt;，参数准备完毕后就去调用&lt;code&gt;TEST&lt;/code&gt;函数，对应的汇编指令：&lt;code&gt;CALL    &quot;&quot;.Test(SB)&lt;/code&gt;，对应的汇编指令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;.Test STEXT nosplit size=&lt;span&gt;49&lt;/span&gt; args=&lt;span&gt;0x20&lt;/span&gt; locals=&lt;span&gt;0x0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        TEXT    &lt;span&gt;&quot;&quot;&lt;/span&gt;.Test(SB), NOSPLIT|ABIInternal, $&lt;span&gt;0&lt;/span&gt;&lt;span&gt;-32&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;0&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;1&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;3&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        PCDATA  $&lt;span&gt;2&lt;/span&gt;, $&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        PCDATA  $&lt;span&gt;0&lt;/span&gt;, $&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    $&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r2+&lt;span&gt;24&lt;/span&gt;(SP)&lt;span&gt;// SP+16 ~ SP+24 存储第一个返回值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0009&lt;/span&gt; &lt;span&gt;00009&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    $&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r3+&lt;span&gt;32&lt;/span&gt;(SP)&lt;br/&gt;&lt;span&gt;// SP+24 ~ SP+32 存储第二个返回值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0012&lt;/span&gt; &lt;span&gt;00018&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.a+&lt;span&gt;8&lt;/span&gt;(SP), AX &lt;span&gt;// 第一个参数放入AX寄存器 AX = 10&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0017&lt;/span&gt; &lt;span&gt;00023&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        ADDQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.b+&lt;span&gt;16&lt;/span&gt;(SP), AX &lt;span&gt;// 第二个参数放入AX寄存器做加法 AX = AX + 20 = 30&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x001c&lt;/span&gt; &lt;span&gt;00028&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    AX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r2+&lt;span&gt;24&lt;/span&gt;(SP)&lt;br/&gt;&lt;span&gt;// AX寄存器中的值在存回栈中：24(SP)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0021&lt;/span&gt; &lt;span&gt;00033&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.a+&lt;span&gt;8&lt;/span&gt;(SP), AX&lt;br/&gt;&lt;span&gt;// 第一个参数放入AX寄存器 AX = 10&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0026&lt;/span&gt; &lt;span&gt;00038&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        SUBQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.b+&lt;span&gt;16&lt;/span&gt;(SP), AX&lt;br/&gt;&lt;span&gt;// 第二个参数放入AX寄存器做减法 AX = AX - 20 = -10&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x002b&lt;/span&gt; &lt;span&gt;00043&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    AX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r3+&lt;span&gt;32&lt;/span&gt;(SP)&lt;br/&gt;&lt;span&gt;// AX寄存器中的值在存回栈中：32(SP)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0030&lt;/span&gt; &lt;span&gt;00048&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        RET &lt;span&gt;// 函数返回&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上的汇编指令我们可以得出结论：&lt;code&gt;Go&lt;/code&gt;语言使用栈传递参数和接收返回值，多个返回值也是通过多分配一些内存来完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种基于栈传递参数和接收返回值的设计大大降低了实现的复杂度，但是牺牲了函数调用的性能，像&lt;code&gt;C&lt;/code&gt;语言采用同时使用栈和寄存器传递参数，在性能上是优于&lt;code&gt;Go&lt;/code&gt;语言的，下面我们就来看一看&lt;code&gt;Go1.17&lt;/code&gt;引入的寄存器传参。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么寄存器传参性能优于栈传参&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;CPU&lt;/code&gt;是一台计算机的运算核心和控制核心，其主要功能是解释计算机指令以及处理计算机软件中的数据，&lt;code&gt;CPU&lt;/code&gt;的大致内部结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7448275862068966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB9xg647D1ib6kibysvQibtKnRY9ta43Mw15y4vulbSW0oJAsh3Mfa3kFB91CdLnOJDEOVn6urwbrVtYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;图片来自于网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要由运算器和控制器组成，运算器负责完成算术运算和逻辑运算，寄存器临时保存将要被运算器处理的数据和处理后的结果，回到主题上，寄存器是&lt;code&gt;CPU&lt;/code&gt;内部组件，而存储一般在外部，&lt;code&gt;CPU&lt;/code&gt;操作寄存器与读取内存的速度差距是数量级别的，当要进行数据计算时，如果数据处于内存中，&lt;code&gt;CPU&lt;/code&gt;需要先将数据从内存拷贝到寄存器进行计算，所以对于栈传递参数与接收返回值这种调用规约，每次计算都需要从内存拷贝到寄存器，计算完毕在拷贝回内存，如果使用寄存器传参的话，参数就已经按顺序放在特定寄存器了，这样就减少了内存和寄存器之间的数据拷贝，从而改善了性能，提供程序运行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然寄存器传参性能高于栈传递参数，为什么所有语言不都使用寄存器传递参数呢？因为不同架构上的寄存器差异不同，所以要支持寄存器传参就要在编译器上进行支持，这要就使编译器变得更加复杂且不易维护，并且寄存器的数量也是有限的，还要考虑超过寄存器数量的参数应该如何传递。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.17基于寄存器传递&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Go&lt;/code&gt;语言在&lt;code&gt;1.17&lt;/code&gt;版本设计了一套基于寄存器传参的调用规约，目前也只支持&lt;code&gt;x86&lt;/code&gt;平台，我们也是通过一个简单的例子看一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;span&gt;(a, b, c, d &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a, b, c, d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; Test(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ,&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行&lt;code&gt;go tool compile -S -N -l main.go&lt;/code&gt;可以看到其汇编指令，我们分两部分来看，先看&lt;code&gt;main&lt;/code&gt;函数部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;.main STEXT size=&lt;span&gt;62&lt;/span&gt; args=&lt;span&gt;0x0&lt;/span&gt; locals=&lt;span&gt;0x28&lt;/span&gt; funcid=&lt;span&gt;0x0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        TEXT    &lt;span&gt;&quot;&quot;&lt;/span&gt;.main(SB), ABIInternal, $&lt;span&gt;40&lt;/span&gt;&lt;span&gt;-0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        CMPQ    SP, &lt;span&gt;16&lt;/span&gt;(R14)&lt;br/&gt;        &lt;span&gt;0x0004&lt;/span&gt; &lt;span&gt;00004&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        PCDATA  $&lt;span&gt;0&lt;/span&gt;, $&lt;span&gt;-2&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0004&lt;/span&gt; &lt;span&gt;00004&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        JLS     &lt;span&gt;55&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0006&lt;/span&gt; &lt;span&gt;00006&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        PCDATA  $&lt;span&gt;0&lt;/span&gt;, $&lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0006&lt;/span&gt; &lt;span&gt;00006&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        SUBQ    $&lt;span&gt;40&lt;/span&gt;, SP&lt;span&gt;// 分配40字节栈空间，基址指针存储到栈上&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x000a&lt;/span&gt; &lt;span&gt;00010&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        MOVQ    BP, &lt;span&gt;32&lt;/span&gt;(SP)&lt;span&gt;// 基址指针存储到栈上&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x000f&lt;/span&gt; &lt;span&gt;00015&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        LEAQ    &lt;span&gt;32&lt;/span&gt;(SP), BP&lt;br/&gt;        &lt;span&gt;0x0014&lt;/span&gt; &lt;span&gt;00020&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;0&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x0014&lt;/span&gt; &lt;span&gt;00020&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;7&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;1&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x0014&lt;/span&gt; &lt;span&gt;00020&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        MOVL    $&lt;span&gt;1&lt;/span&gt;, AX &lt;span&gt;// 参数1使用AX寄存器传递&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0019&lt;/span&gt; &lt;span&gt;00025&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        MOVL    $&lt;span&gt;2&lt;/span&gt;, BX &lt;span&gt;// 参数2使用BX寄存器传递&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x001e&lt;/span&gt; &lt;span&gt;00030&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        MOVL    $&lt;span&gt;3&lt;/span&gt;, CX &lt;span&gt;// 参数3使用CX寄存器传递&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0023&lt;/span&gt; &lt;span&gt;00035&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        MOVL    $&lt;span&gt;4&lt;/span&gt;, DI &lt;span&gt;// 参数4使用DI寄存器传递&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0028&lt;/span&gt; &lt;span&gt;00040&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        PCDATA  $&lt;span&gt;1&lt;/span&gt;, $&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0028&lt;/span&gt; &lt;span&gt;00040&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;)        CALL    &lt;span&gt;&quot;&quot;&lt;/span&gt;.Test(SB) &lt;span&gt;// 调用Test函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x002d&lt;/span&gt; &lt;span&gt;00045&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;)        MOVQ    &lt;span&gt;32&lt;/span&gt;(SP), BP &lt;span&gt;// Test函数返回后恢复栈基址指针&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0032&lt;/span&gt; &lt;span&gt;00050&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;)        ADDQ    $&lt;span&gt;40&lt;/span&gt;, SP &lt;span&gt;// 销毁40字节栈内存&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0036&lt;/span&gt; &lt;span&gt;00054&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;)        RET &lt;span&gt;// 返回&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的汇编指令我们可以分析出，现在参数已经不是从右向左进行压栈了，参数直接在寄存器上了，参数准备完毕后就去调用&lt;code&gt;TEST&lt;/code&gt;函数，对应的汇编指令：&lt;code&gt;CALL    &quot;&quot;.Test(SB)&lt;/code&gt;，对应的汇编指令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;.Test STEXT nosplit size=&lt;span&gt;133&lt;/span&gt; args=&lt;span&gt;0x20&lt;/span&gt; locals=&lt;span&gt;0x28&lt;/span&gt; funcid=&lt;span&gt;0x0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        TEXT    &lt;span&gt;&quot;&quot;&lt;/span&gt;.Test(SB), NOSPLIT|ABIInternal, $&lt;span&gt;40&lt;/span&gt;&lt;span&gt;-32&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0000&lt;/span&gt; &lt;span&gt;00000&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        SUBQ    $&lt;span&gt;40&lt;/span&gt;, SP&lt;br/&gt;        &lt;span&gt;0x0004&lt;/span&gt; &lt;span&gt;00004&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    BP, &lt;span&gt;32&lt;/span&gt;(SP)&lt;br/&gt;        &lt;span&gt;0x0009&lt;/span&gt; &lt;span&gt;00009&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        LEAQ    &lt;span&gt;32&lt;/span&gt;(SP), BP&lt;br/&gt;        &lt;span&gt;0x000e&lt;/span&gt; &lt;span&gt;00014&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;0&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x000e&lt;/span&gt; &lt;span&gt;00014&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;1&lt;/span&gt;, gclocals·&lt;span&gt;33&lt;/span&gt;cdeccccebe80329f1fdbee7f5874cb(SB)&lt;br/&gt;        &lt;span&gt;0x000e&lt;/span&gt; &lt;span&gt;00014&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        FUNCDATA        $&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;.Test.arginfo1(SB)&lt;br/&gt;&lt;span&gt;0x000e&lt;/span&gt; &lt;span&gt;00014&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    AX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.a+&lt;span&gt;48&lt;/span&gt;(SP) &lt;span&gt;// 从寄存器AX获取参数 1 放入栈中 48(SP)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x0013&lt;/span&gt; &lt;span&gt;00019&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    BX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.b+&lt;span&gt;56&lt;/span&gt;(SP) &lt;span&gt;// 从寄存器BX获取参数 2 放入栈中 56(SP)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x0018&lt;/span&gt; &lt;span&gt;00024&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    CX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.c+&lt;span&gt;64&lt;/span&gt;(SP) &lt;span&gt;// 从寄存器CX获取参数 3 放入栈中 64(SP)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x001d&lt;/span&gt; &lt;span&gt;00029&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    DI, &lt;span&gt;&quot;&quot;&lt;/span&gt;.d+&lt;span&gt;72&lt;/span&gt;(SP) &lt;span&gt;// 从寄存器DI获取参数 4 放入栈中 72(SP)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x0022&lt;/span&gt; &lt;span&gt;00034&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    $&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r4+&lt;span&gt;24&lt;/span&gt;(SP)&lt;br/&gt;        &lt;span&gt;0x002b&lt;/span&gt; &lt;span&gt;00043&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    $&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r5+&lt;span&gt;16&lt;/span&gt;(SP)&lt;br/&gt;        &lt;span&gt;0x0034&lt;/span&gt; &lt;span&gt;00052&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    $&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r6+&lt;span&gt;8&lt;/span&gt;(SP)&lt;br/&gt;        &lt;span&gt;0x003d&lt;/span&gt; &lt;span&gt;00061&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;)        MOVQ    $&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r7(SP)&lt;br/&gt;        &lt;span&gt;0x0045&lt;/span&gt; &lt;span&gt;00069&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.a+&lt;span&gt;48&lt;/span&gt;(SP), DX &lt;span&gt;// 以下操作是返回值放到寄存器中返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x004a&lt;/span&gt; &lt;span&gt;00074&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    DX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r4+&lt;span&gt;24&lt;/span&gt;(SP)&lt;br/&gt;        &lt;span&gt;0x004f&lt;/span&gt; &lt;span&gt;00079&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.b+&lt;span&gt;56&lt;/span&gt;(SP), DX&lt;br/&gt;        &lt;span&gt;0x0054&lt;/span&gt; &lt;span&gt;00084&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    DX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r5+&lt;span&gt;16&lt;/span&gt;(SP)&lt;br/&gt;        &lt;span&gt;0x0059&lt;/span&gt; &lt;span&gt;00089&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.c+&lt;span&gt;64&lt;/span&gt;(SP), DX&lt;br/&gt;        &lt;span&gt;0x005e&lt;/span&gt; &lt;span&gt;00094&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    DX, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r6+&lt;span&gt;8&lt;/span&gt;(SP)&lt;br/&gt;        &lt;span&gt;0x0063&lt;/span&gt; &lt;span&gt;00099&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.d+&lt;span&gt;72&lt;/span&gt;(SP), DI&lt;br/&gt;        &lt;span&gt;0x0068&lt;/span&gt; &lt;span&gt;00104&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    DI, &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r7(SP)&lt;br/&gt;        &lt;span&gt;0x006c&lt;/span&gt; &lt;span&gt;00108&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r4+&lt;span&gt;24&lt;/span&gt;(SP), AX&lt;br/&gt;        &lt;span&gt;0x0071&lt;/span&gt; &lt;span&gt;00113&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r5+&lt;span&gt;16&lt;/span&gt;(SP), BX&lt;br/&gt;        &lt;span&gt;0x0076&lt;/span&gt; &lt;span&gt;00118&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;&quot;&quot;&lt;/span&gt;.~r6+&lt;span&gt;8&lt;/span&gt;(SP), CX&lt;br/&gt;        &lt;span&gt;0x007b&lt;/span&gt; &lt;span&gt;00123&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        MOVQ    &lt;span&gt;32&lt;/span&gt;(SP), BP&lt;br/&gt;        &lt;span&gt;0x0080&lt;/span&gt; &lt;span&gt;00128&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        ADDQ    $&lt;span&gt;40&lt;/span&gt;, SP&lt;br/&gt;        &lt;span&gt;0x0084&lt;/span&gt; &lt;span&gt;00132&lt;/span&gt; (main.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;4&lt;/span&gt;)        RET&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传参和返回都采用了寄存器进行传递，并且返回值和输入都使用了完全相同的寄存器序列，并且使用的顺序也是一致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个优化，在一些函数调用嵌套层次较深的场景下，内存有一定概率会降低，有机会做压测可以试一试～。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟练掌握并理解函数的调用过程是我们深入学习&lt;code&gt;Go&lt;/code&gt;语言的重要一课，看完本文希望你已经熟练掌握了函数的调用惯例～。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，本文到这里就结束了，我是&lt;strong&gt;asong&lt;/strong&gt;，我们下期见。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkyNzI1NzM5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB96zTfSmymj9jWokyhvSIXMRcLRAfFJsrB4uz6HBsml4T6iaia3yyCSB4aicX97icT7xBUCgw4O1PsKFQ/0?wx_fmt=png&quot; data-nickname=&quot;Golang梦工厂&quot; data-alias=&quot;AsongDream&quot; data-signature=&quot;asong是一名后端程序员，目前就职于一家电商公司，专注于Golang技术，定期分享Go语言、MySQL、Redis、Elasticsearch、计算机基础、微服务架构设计、面试等知识。这里不仅有技术，还有故事！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>