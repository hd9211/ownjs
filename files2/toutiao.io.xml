<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fb2df63f5523c5e3b48401b0b93f2078</guid>
<title>IndexedDB 快速入门</title>
<link>https://toutiao.io/k/7hbxp47</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;&lt;h1 class=&quot;title&quot;&gt;IndexedDB 快速入门&lt;/h1&gt;&lt;p class=&quot;meta&quot;&gt;冯宇 Posted at — Aug 7, 2021
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;markdown&quot;&gt;&lt;p&gt;&lt;strong&gt;注：如果你只是想快速体验一下 IndexedDB，建议直接去使用 &lt;a href=&quot;https://jsstore.net/&quot;&gt;JsStore&lt;/a&gt; 。它基本上完全隐藏了 IndexedDB 繁琐的技术细节，提供的接口也更加人性化，同时还有更高级的特性（如 sql join、upsert、webworker 等）。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;indexeddb-简介&quot;&gt;IndexedDB 简介&lt;/h2&gt;&lt;p&gt;作为前端开发工程师，你可能已经习惯了使用一些前端的存储方案，如 LocalStorage, Session Storage, Cookie 之类等等。而这些存储在存储结构简单、数据量小的场景中非常好用，但是遇到大规模结构化存储的场景中就不那么好用了。为此，诞生了一种新的存储标准 IndexedDB，用于在前端解决大规模量结构化数据存储的场景。如服务端数据缓存至前端加速，前端日志缓存记录等。&lt;/p&gt;&lt;p&gt;本文将介绍 IndexedDB 快速入门的相关内容，至于高级使用，仍建议详细阅读 IndexedDB 的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;性能评测可参考： &lt;a href=&quot;https://zhuanlan.zhihu.com/p/104536473&quot;&gt;https://zhuanlan.zhihu.com/p/104536473&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;indexeddb-的兼容性&quot;&gt;IndexedDB 的兼容性&lt;/h2&gt;&lt;p&gt;如今 IndexedDB 几乎在现代化的浏览器都已经实现，因此可以放心大胆的在产品环境使用。截至本文撰写时间，当前 IndexedDB 的浏览器兼容性参考如下:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;imgs/indexeddb1.png&quot; alt=&quot;IndexedDB 兼容性概览&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;数据来源: &lt;a href=&quot;https://caniuse.com/indexeddb&quot;&gt;https://caniuse.com/indexeddb&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;indexeddb-的存储容量限制&quot;&gt;IndexedDB 的存储容量限制&lt;/h2&gt;&lt;p&gt;IndexedDB 的最大存储容量通常是动态的，通常&lt;strong&gt;全局限制&lt;/strong&gt;为当前磁盘空间的 50%，如浏览器安装分区容量为 500GB，则 IndexedDB 最大可能占用空间为 250GB —— 这对于前端存储来几乎是足够的&lt;/p&gt;&lt;p&gt;还有另一个限制称为&lt;strong&gt;组限制&lt;/strong&gt;——这被定义为全局限制的 20％，但它至少有 10 MB，最大为 2GB。 每个源都是一组（源组）的一部分。 每个 eTLD+1 域都有一个组。 例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;mozilla.org&lt;/code&gt;——组 1，源 1&lt;/li&gt;&lt;li&gt;&lt;code&gt;www.mozilla.org&lt;/code&gt;——组 1，源 2&lt;/li&gt;&lt;li&gt;&lt;code&gt;joe.blogs.mozilla.org&lt;/code&gt;——组 1，源 3&lt;/li&gt;&lt;li&gt;&lt;code&gt;firefox.com&lt;/code&gt; ——组 2，源 4&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个组中，mozilla.org、www.mozilla.org和joe.blogs.mozilla.org可以聚合使用最多20％的全局限制。 firefox.com 单独最多使用 20％。&lt;/p&gt;&lt;p&gt;达到限制后有两种不同的反应：&lt;/p&gt;&lt;p&gt;组限制也称为“硬限制”：它不会触发源回收。
全局限制是一个“软限制”，因为其有可能释放一些空间并且这个操作可能持续。&lt;/p&gt;&lt;h2 id=&quot;indexeddb-安全性&quot;&gt;IndexedDB 安全性&lt;/h2&gt;&lt;p&gt;IndexedDB 使用同源原则，这意味着它把存储空间绑定到了创建它的站点的源（典型情况下，就是站点的域或是子域），所以它不能被任何其他源访问。&lt;/p&gt;&lt;h2 id=&quot;indexeddb-简易示例&quot;&gt;IndexedDB 简易示例&lt;/h2&gt;&lt;p&gt;IndexedDB 的 API 是基于事件响应全异步性的，使用的时候需要监听对应的事件完成操作。一个基本的创建数据库的操作实例如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// 如果被打开的数据库不存在，则会自动创建
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;);

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Why didn&#x27;t you allow my web app to use IndexedDB?!&quot;&lt;/span&gt;);
};

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 在不使用 db 的时候尽可能 close掉，否则无法打开一个更高版本的 db，表现形式为 hang 死，无法接收到 onsuccess 事件
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 注意 close() 函数不会立即中断已经在运行中的 transaction
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 但是不能再用这个实例创建新的transaction，否则会抛异常
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;();
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;数据库的版本号&quot;&gt;数据库的版本号&lt;/h3&gt;&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 函数可以传一个可选的 &lt;code&gt;version&lt;/code&gt; 参数指定版本号，当 version 比当前 &lt;code&gt;db.version&lt;/code&gt; 高时，会触发 &lt;code&gt;onupgradeneeded&lt;/code&gt; 事件，同时，会更新 &lt;code&gt;db.version&lt;/code&gt; 属性：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;// 该事件仅在较新的浏览器中实现了
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 保存 IDBDataBase 接口
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 为该数据库创建一个对象仓库
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 注意 createObjectStore() 只能在 onupgradeneeded 事务中运行
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, { &lt;span&gt;keyPath&lt;/span&gt;: &lt;span&gt;&quot;myKey&quot;&lt;/span&gt; });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了防止在其他标签页中打开高版本的数据库 hang 住的情况，一种做法可以参考如下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;openReq&lt;/span&gt; = &lt;span&gt;mozIndexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onblocked&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 如果其他的一些页签加载了该数据库，在我们继续之前需要关闭它们
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;请关闭其他由该站点打开的页签！&quot;&lt;/span&gt;);
};

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 其他的数据已经被关闭，一切就绪
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;/* ... */&lt;/span&gt;);
  &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;);
};

&lt;span&gt;openReq&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
  &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;);
  &lt;span&gt;return&lt;/span&gt;;
};

&lt;span&gt;function&lt;/span&gt; &lt;span&gt;useDatabase&lt;/span&gt;(&lt;span&gt;db&lt;/span&gt;) {
  &lt;span&gt;// 当由其他页签请求了版本变更时，确认添加了一个会被通知的事件处理程序。
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 这里允许其他页签来更新数据库，如果不这样做，版本升级将不会发生知道用户关闭了这些页签。
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;onversionchange&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;();
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;A new version of this page is ready. Please reload or close this tab!&quot;&lt;/span&gt;);
  };

  &lt;span&gt;// 处理数据库
&lt;/span&gt;&lt;span/&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;一个基本的存储示例&quot;&gt;一个基本的存储示例&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;dbName&lt;/span&gt; = &lt;span&gt;&quot;the_name&quot;&lt;/span&gt;;

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;dbName&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);

&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onupgradeneeded&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path）
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;// 因为 ssn 可以保证是不重复的
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;createObjectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;, { &lt;span&gt;keyPath&lt;/span&gt;: &lt;span&gt;&quot;ssn&quot;&lt;/span&gt; });

  &lt;span&gt;// 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;createIndex&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;name&quot;&lt;/span&gt;, { &lt;span&gt;unique&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt; });

  &lt;span&gt;// 使用邮箱建立索引，我们向确保客户的邮箱不会重复，所以我们使用 unique 索引
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;createIndex&lt;/span&gt;(&lt;span&gt;&quot;email&quot;&lt;/span&gt;, &lt;span&gt;&quot;email&quot;&lt;/span&gt;, { &lt;span&gt;unique&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });

  &lt;span&gt;// 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;oncomplete&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 将数据保存到新创建的对象仓库
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;customerObjectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;, &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
    &lt;span&gt;customerData&lt;/span&gt;.&lt;span&gt;forEach&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;customer&lt;/span&gt;) {
      &lt;span&gt;// add 函数在 keyPath 冲突时会抛异常，如果期望直接覆盖，请使用 put 函数
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;customerObjectStore&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;customer&lt;/span&gt;);
    });
  };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;关于索引&lt;/strong&gt;: IndexedDB 的索引会自动按照由小到大的顺序自动进行排列(有点像 HBase 的 RowKey 设计)，同时可以支持多个字段联合索引，如: objectStore.createIndex(“f1-f2”, [“f1”, “f2”]); 对于要想使用类似于 SQL 中的 where 条件查询，则必须预先在对应的字段创建索引才能实现。另外由于 IndexedDB API 并不提供类似于 Order By 的功能，因此只能使用 cursor 的遍历方向来替代。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;基本-curd-示例&quot;&gt;基本 CURD 示例&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// ========= 增加数据 ============
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 在所有数据添加完毕后的处理
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;oncomplete&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;All done!&quot;&lt;/span&gt;);
};

&lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 不要忘记错误处理！
&lt;/span&gt;&lt;span/&gt;};

&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;customerData&lt;/span&gt;.&lt;span&gt;forEach&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;customer&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;add&lt;/span&gt;(&lt;span&gt;customer&lt;/span&gt;);
  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// event.target.result === customer.ssn;
&lt;/span&gt;&lt;span/&gt;  };
});

&lt;span&gt;// =========== 删除数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;
  .&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;], &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;)
  .&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
  .&lt;span&gt;delete&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 删除成功！
&lt;/span&gt;&lt;span/&gt;};

&lt;span&gt;// =========== 读取数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;]);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;transaction&lt;/span&gt;.&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理!
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 对 request.result 做些操作！
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN 444-44-4444 is &quot;&lt;/span&gt; + &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
};

&lt;span&gt;// 简化示例，和上面等效
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;).&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (
  &lt;span&gt;event&lt;/span&gt;
) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN 444-44-4444 is &quot;&lt;/span&gt; + &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
};

&lt;span&gt;// 使用游标
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);

&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;openCursor&lt;/span&gt;().&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;cursor&lt;/span&gt;) {
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Name for SSN &quot;&lt;/span&gt; + &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;key&lt;/span&gt; + &lt;span&gt;&quot; is &quot;&lt;/span&gt; + &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;value&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
    &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;continue&lt;/span&gt;();
  } &lt;span&gt;else&lt;/span&gt; {
    &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;No more entries!&quot;&lt;/span&gt;);
  }
};

&lt;span&gt;// 使用 index 索引数据
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 首先，确定你已经在 request.onupgradeneeded 中创建了索引:
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// objectStore.createIndex(&quot;name&quot;, &quot;name&quot;);
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 否则你将得到 DOMException。
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);

&lt;span&gt;index&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;Donna&quot;&lt;/span&gt;).&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;alert&lt;/span&gt;(&lt;span&gt;&quot;Donna&#x27;s SSN is &quot;&lt;/span&gt; + &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;ssn&lt;/span&gt;);
};

&lt;span&gt;// =========== 更新数据 ==================
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;objectStore&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;.&lt;span&gt;transaction&lt;/span&gt;([&lt;span&gt;&quot;customers&quot;&lt;/span&gt;], &lt;span&gt;&quot;readwrite&quot;&lt;/span&gt;).&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;);
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;);
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;};
&lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
  &lt;span&gt;// 获取我们想要更新的数据
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;data&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;

  &lt;span&gt;// 更新你想修改的数据
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;data&lt;/span&gt;.&lt;span&gt;age&lt;/span&gt; = &lt;span&gt;42&lt;/span&gt;;

  &lt;span&gt;// 把更新过的对象放回数据库
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;var&lt;/span&gt; &lt;span&gt;requestUpdate&lt;/span&gt; = &lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;put&lt;/span&gt;(&lt;span&gt;data&lt;/span&gt;);
  &lt;span&gt;requestUpdate&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 错误处理
&lt;/span&gt;&lt;span/&gt;  };
  &lt;span&gt;requestUpdate&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;// 完成，数据已更新！
&lt;/span&gt;&lt;span/&gt;  };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;关于搜索查询&quot;&gt;关于搜索查询&lt;/h2&gt;&lt;p&gt;通过上述的示例，可以看到其实 IndexedDB 存储其实是文档型数据库的套路，并且自身的 API 并不支持像 SQL 那样复杂功能多样的查询功能，因此在使用前必须好好设计存储结构，务必确保自己的查询条件不至于太复杂难以实现，这里列出一些常见的查询示例与 SQL 的对照(所有需要用到的 index 需要事先创建好，这里不再赘述):&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// select * from table order by field desc
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;field&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;prev&quot;&lt;/span&gt;);

&lt;span&gt;// select * from table where field between 1 and 10
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;field&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;IDBKeyRange&lt;/span&gt;.&lt;span&gt;bound&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;));

&lt;span&gt;// select distinct on (f1, f2) * from table
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;// 需要预先创建f1, f2的联合索引: objectStore.createIndex(&quot;f1-f2&quot;, [&quot;f1&quot;, &quot;f2&quot;], { unique: false });
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;objectStore&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;(&lt;span&gt;&quot;f1-f2&quot;&lt;/span&gt;).&lt;span&gt;openCursor&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;&quot;nextunique&quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;条件搜索主要使用&lt;code&gt;openCursor(keyRange, direction)&lt;/code&gt;函数，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange&quot;&gt;IDBKeyRange&lt;/a&gt; 参数表示查询的范围，类似于&lt;code&gt;where&lt;/code&gt;的功能，而&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/direction&quot;&gt;direction&lt;/a&gt; 决定游标遍历的方向，因此可以实现简单的&lt;code&gt;order by&lt;/code&gt;的功能。但是特别注意对于联合索引，每个字段也都是按照&lt;code&gt;asc&lt;/code&gt;顺序排序的，因此没办法通过 direction 实现类似于&lt;code&gt;order by f1 asc, f2 desc, f3 desc&lt;/code&gt;这样的排序，使用前务必设计好存储结构。&lt;/p&gt;&lt;p&gt;还需要注意无论&lt;code&gt;nextunique&lt;/code&gt;还是&lt;code&gt;prevunique&lt;/code&gt;，由于它们内部对于相同 value 的排序都是从小到大的，因此它们返回的内容都是一样的，例如:&lt;/p&gt;&lt;p&gt;假设创建&lt;code&gt;objectStore.createIndex(&quot;f1-f2&quot;, [&quot;f1&quot;, &quot;f2&quot;], { unique: false })&lt;/code&gt;索引，无论&lt;code&gt;openCursor&lt;/code&gt;的 direction 参数是&lt;code&gt;nextunique&lt;/code&gt;还是&lt;code&gt;prevunique&lt;/code&gt;，都只会筛选出&lt;code&gt;{&quot;f1&quot;:&quot;a&quot;,&quot;f2&quot;:&quot;b&quot;,&quot;f3&quot;:&quot;c&quot;}&lt;/code&gt;这条结果，cursor 的遍历顺序只会影响这条记录出现的次序而已。&lt;/p&gt;&lt;h2 id=&quot;promise&quot;&gt;Promise&lt;/h2&gt;&lt;p&gt;IndexedDB API 本身并不提供 Promise 接口，如果你的场景确实需要用到 Promise，可以考虑自己简单封装下:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;resolve&lt;/span&gt;, &lt;span&gt;reject&lt;/span&gt;) {
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;request&lt;/span&gt; = &lt;span&gt;window&lt;/span&gt;.&lt;span&gt;indexedDB&lt;/span&gt;.&lt;span&gt;open&lt;/span&gt;(&lt;span&gt;&quot;MyTestDatabase&quot;&lt;/span&gt;);

  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reject&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;);
  }

  &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;db&lt;/span&gt; = &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;getReq&lt;/span&gt; = &lt;span&gt;db&lt;/span&gt;
      .&lt;span&gt;transaction&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
      .&lt;span&gt;objectStore&lt;/span&gt;(&lt;span&gt;&quot;customers&quot;&lt;/span&gt;)
      .&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;444-44-4444&quot;&lt;/span&gt;)

    &lt;span&gt;getReq&lt;/span&gt;.&lt;span&gt;onsuccess&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;resolve&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;.&lt;span&gt;target&lt;/span&gt;.&lt;span&gt;result&lt;/span&gt;.&lt;span&gt;name&lt;/span&gt;);
    };

    &lt;span&gt;getReq&lt;/span&gt;.&lt;span&gt;onerror&lt;/span&gt; = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;event&lt;/span&gt;) {
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reject&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果需要大量使用 Promise，可以考虑使用第三方类库&lt;a href=&quot;https://www.npmjs.com/package/idb&quot;&gt;idb&lt;/a&gt;或更精简的版本&lt;a href=&quot;https://www.npmjs.com/package/idb-keyval&quot;&gt;idb-keyval&lt;/a&gt;，它们将 IndexedDB 的 API 进行了 Promise 的封装，其中&lt;a href=&quot;https://www.npmjs.com/package/idb-keyval&quot;&gt;idb-keyval&lt;/a&gt;对 KV 对这种存储结构进行了更简化的封装调用，对于自己的场景只有简单的 KV 存储这种场景可以考虑使用&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4d5636bfda27716b709e5f03be48c443</guid>
<title>Java 进阶：从整体上观察面向对象</title>
<link>https://toutiao.io/k/d5zzykx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、面向对象&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;面向对象是Java编程中最核心的思想，基本特征：继承、封装、多态。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、特征之封装&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;将结构、数据、操作封装在对象实体中，使用时可以不关注对象内部结构，只能访问开放权限的功能入口，从而降低程序耦合程度，提供安全性和可持续维护性。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Student student = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;张三&quot;&lt;/span&gt;,&lt;span&gt;&quot;高三&quot;&lt;/span&gt;,&lt;span&gt;29f&lt;/span&gt;);&lt;br/&gt;        student.conclusion();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String grade ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Float score ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;&lt;span&gt;(String name, String grade, Float score)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.grade = grade;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.score = score;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;conclusion&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;姓名：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getName());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;年级：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getGrade());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;分数：&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.getGrade());&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.getScore() &amp;gt;= &lt;span&gt;100.0f&lt;/span&gt;){&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;评语：本学期优等生&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;评语：本学期潜力股&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;案例描述Student的学期总结，通过构造方法构建具体的学生对象，并且只通过conclusion方法获取学生学期评价。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、特征之继承&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;子类除了提供自身的能力之外，还可以通过继承的方式获取父类开放的属性和方法，以增强自身的功能。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 判断 Digital 是 Phone 父类&lt;/span&gt;&lt;br/&gt;        System.out.println(Digital&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;isAssignableFrom&lt;/span&gt;(&lt;span&gt;Phone&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Digital&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Phone&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Digital&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里通过isAssignableFrom方法判断Digital是Phone父类。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、特征之多态&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;不同主体类对同一个动作给出不同的实现方式，多态也是Java描述设计模式的常用手段，最直接的作用就是程序解耦。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Concept03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Animal animalDog = &lt;span&gt;new&lt;/span&gt; Dog();&lt;br/&gt;        Animal animalCat = &lt;span&gt;new&lt;/span&gt; Cat();&lt;br/&gt;        animalDog.voice();&lt;br/&gt;        animalCat.voice();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Animal ... voice&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Dog ... Wang wang&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;voice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Cat ... Meow meow&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常动物都有发出声音的能力，但是不同动物声音不同，这里基于多态实现，不同动物的声音特征。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、关系图谱&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在了解面向对象之后，还需要理解一下基础的关系模型，在实际的业务中都是基于这些基础的关系解决场景问题。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、继承与实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;继承关系：强调属性和方法从父类向子类的传承。实现关系：强调描述抽象和具体实现的逻辑。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 继承&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classB&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;classA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;interfaceB&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 实现&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;classC&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;interfaceA&lt;/span&gt;,&lt;span&gt;interfaceB&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37073170731707317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blibdg8u4iaTKknBD8PdpHIFeQjC0Wx7icgjqDmibVASTEkoSwS8apFdXdM8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、依赖与关联&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;依赖关系：常用来描述方法局部变量或者入参，即类的方法中调用了另一个类。关联关系：类的成员变量是另一个类，比如常见的一对一，一对多关系。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 依赖&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RelyA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RelyB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;depend&lt;/span&gt; &lt;span&gt;(RelyA rely)&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 关联&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssociateA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AssociateB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AssociateA associateA ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35960591133004927&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blibScn5TqWrXZL8tD5gRQBUIiaDsibWia4wib00Cw70gicBdatAiabUJsDZcpZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、组合与聚合&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;聚合关系：描述整体与部分的关系，但是部分不需要依赖整体存在。组合关系：描述整体与部分的关系，但是部分需要依赖整体存在。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 聚合&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ElementA&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ElementB&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Aggregation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ElementA elementA ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ElementB elementB ;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 组合&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PortionA&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PortionB&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Composition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PortionA portionA ;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PortionB portionB ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3117408906882591&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCp2RA5msCibTSo4dpYP8blib0OdSWJPrr8jrOYjBq3UM6QTc4w2BBLic3kgS1YwHt2BfISTXSJjXG1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、模式与原则&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在面对复杂业务时，可以时常参考设计模式和基本原则，以此设计合理的业务结构，实现代码的高内聚低耦合，但是在一些特定场景下，也要果断的突破这些模板或原则，可以更好的支撑业务。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、设计模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;抽象对象实例化的创建过程，对不同类型的对象提供高效的管理方式与合理的创建手段。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;结构模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设计类的组装模式，合理的对象结构，有利于支持业务的持续迭代，结构会直接影响代码的可持续维护性。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;代理模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外观模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;适配器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;装饰者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组合模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;享元模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桥梁模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;行为模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;行为模式涉及对象职责定义，通信协作，和最具体的业务逻辑实现，明确程序运行时的流程轨迹。&lt;/p&gt;&lt;p&gt;可以基于继承或实现的方式控制不同类的行为职责，即顶层抽象控制行为，下层逐级做具体逻辑实现；或者直接聚合管理责任对象，做统一分配。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;观察者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模版方法模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;策略模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调停者模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;备忘录模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;迭代器模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;责任链模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问者模式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、基本原则&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;开闭原则：在做代码结构设计时，应该考虑对扩展开放，对修改关闭，抽象思维搭建结构，具体实现扩展细节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单一职责：一个类应该只负责一项职责；减少代码一处变更引起的程序大规模改动情况，降低类的复杂度；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接口隔离：每一个接口应该是一种角色；尽量避免具体实现类中用不到但是又必须实现的方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;依赖倒转：上层模块不应该依赖下层模块，抽象逻辑不应该依赖具体细节，即中心思想是面向接口编程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;里氏替换：继承时遵循里氏替换原则，子类中尽量不要重写父类的方法，可以扩展父类的功能；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;迪米特原则：最少知道原则即类对象对其依赖的类知道的越少越好，以此降低耦合程度；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;组合/聚合复用：新对象应使用部分已有的对象，使其成为新对象组成部分，实现已有功能的复用，以此降低单个类的复杂程度。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;span&gt;四、业务应用&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在业务开发中，很多复杂的逻辑都是基于面向对象的思想做的设计和具体实现，但是在实际上业务是不断变化的，所以不管是常用的Mvc模式，或者领域设计，只要经过多个版本迭代，多人参与的开发，到最后代码在逻辑层面都会让人着迷。&lt;/p&gt;&lt;p&gt;也就是常说的一种现象：新人重构，老人不断修复问题，然而铁打的问题，流水的开发，但凡经历过重构的同学都知道，所谓的大规模重构很难彻底解决问题，甚至这是个循环动作。所以业务代码更多是在那个版本周期内是合理的，站在一个开发的角度，这里也可以理解为笔者个人角度，通常从下面几个角度去思考具体的业务开发：&lt;/p&gt;&lt;p&gt;这是个人认为业务工程中最重要的基础，不管业务如何复杂，都离不开与之相应的数据增删改查，所以对常规基础操作做好统一代码风格管理，这样有助于别人快速理解整体结构和逻辑。&lt;/p&gt;&lt;p&gt;这里风格指：接口命名，参数，组件，中间件等统一，以持久层为例，避免多个组件混用的情况，如果是周期相对较长的项目，经常看到单是分页查询的实现逻辑都有多种情况。&lt;/p&gt;&lt;p&gt;易变是业务本身的特点，所以高度复用的业务代码本身就存在很大的限制，例如常见的很多方法，为了适配各种场景，不断扩展入参，然后有些特殊业务也会进行特殊传参。&lt;/p&gt;&lt;p&gt;还有一些开发常说的，能用一个接口实现，绝对不使用两个接口，看似很有个性，实际已经走在挖坑的路上，多个功能请求同一个接口，即意味着任何接口的改动都要考虑很多逻辑的适配。&lt;/p&gt;&lt;p&gt;所以从上层向下看，不必过度考虑复用，从下向上看，底层的改动相对较少，应该考虑复用。&lt;/p&gt;&lt;p&gt;从项目生命周期的角度思考，业务是一个迭代的过程，不需要过度前卫的设计，项目的生命周期是多久没人知道，最稳妥的做法是快速迭代，产品和技术工程能快速稳定的支撑业务发展即可。&lt;/p&gt;&lt;p&gt;经典的业务分层管理是快速迭代的基本支撑，例如常用的Mvc模式，在复杂的业务场景下可以再次细化管理，或者向领域设计靠近。&lt;/p&gt;&lt;p&gt;业务可以理解为流程管理，小的流程通常service中可以直接处理，但是复杂流程则十分讲究设计，一个基础思想就是分段管理，比较经典的案例就是下单：构建结算页面时初始化订单-支付时订单提交-支付成功才会执行订单。&lt;/p&gt;&lt;p&gt;逻辑上的细节要持续追求严谨，业务实现手段和思路适当放宽，流程经得起考验，底层实现合理的复用，组件选择上应该站在高纬度，就基本足以。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https://github.com/cicadasmile/java-base-parent&lt;br/&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile/java-base-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac14c4b9298e7a43c4d0a98c1d07b436</guid>
<title>容器三把斧之 namespace 原理与实现</title>
<link>https://toutiao.io/k/1uwmeyu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;span&gt;namespace介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;namespace（命名空间）&lt;/code&gt; 是Linux提供的一种内核级别环境隔离的方法，很多编程语言也有 namespace 这样的功能，例如C++，Java等，编程语言的 namespace 是为了解决项目中能够在不同的命名空间里使用相同的函数名或者类名。而Linux的 namespace 也是为了实现资源能够在不同的命名空间里有相同的名称，譬如在 &lt;code&gt;A命名空间&lt;/code&gt; 有个pid为1的进程，而在 &lt;code&gt;B命名空间&lt;/code&gt; 中也可以有一个pid为1的进程。&lt;/p&gt;&lt;p&gt;有了 &lt;code&gt;namespace&lt;/code&gt; 就可以实现基本的容器功能，著名的 &lt;code&gt;Docker&lt;/code&gt; 也是使用了 namespace 来实现资源隔离的。&lt;/p&gt;&lt;p&gt;Linux支持6种资源的 &lt;code&gt;namespace&lt;/code&gt;，分别为（文档）：&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Parameter&lt;/th&gt;&lt;th&gt;Linux Version&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Mount namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWNS&lt;/td&gt;&lt;td&gt;Linux 2.4.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UTS namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWUTS&lt;/td&gt;&lt;td&gt;Linux 2.6.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IPC namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWIPC&lt;/td&gt;&lt;td&gt;Linux 2.6.19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PID namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWPID&lt;/td&gt;&lt;td&gt;Linux 2.6.24&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Network namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWNET&lt;/td&gt;&lt;td&gt;Linux 2.6.24&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;User namespaces&lt;/td&gt;&lt;td&gt;CLONE_NEWUSER&lt;/td&gt;&lt;td&gt;Linux 2.6.23&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;在调用 &lt;code&gt;clone()&lt;/code&gt; 系统调用时，传入以上的不同类型的参数就可以实现复制不同类型的namespace。比如传入 &lt;code&gt;CLONE_NEWPID&lt;/code&gt; 参数时，就是复制 &lt;code&gt;pid命名空间&lt;/code&gt;，在新的 &lt;code&gt;pid命名空间&lt;/code&gt; 里可以使用与其他 &lt;code&gt;pid命名空间&lt;/code&gt; 相同的pid。代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; _GNU_SOURCE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sched.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; child_stack[&lt;span&gt;5000&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;child&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;* arg)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Child - %d\n&quot;&lt;/span&gt;, getpid());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Parent - fork child\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; pid = clone(child, child_stack+&lt;span&gt;5000&lt;/span&gt;, CLONE_NEWPID, &lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;        perror(&lt;span&gt;&quot;clone:&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    waitpid(pid, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Parent - child(%d) exit\n&quot;&lt;/span&gt;, pid);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Parent - fork child&lt;br/&gt;Parent - child(9054) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;Child - 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从运行结果可以看出，在子进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 里当前进程的pid为1，但在父进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 中子进程的pid却是9045。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;namespace实现原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;为了让每个进程都可以从属于某一个namespace，Linux内核为进程描述符添加了一个 &lt;code&gt;struct nsproxy&lt;/code&gt; 的结构，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;/* namespaces */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;nsproxy&lt;/span&gt; *&lt;span&gt;nsproxy&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;nsproxy&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;atomic_t&lt;/span&gt; count;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;uts_namespace&lt;/span&gt;  *&lt;span&gt;uts_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;ipc_namespace&lt;/span&gt;  *&lt;span&gt;ipc_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;mnt_namespace&lt;/span&gt;  *&lt;span&gt;mnt_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt;  *&lt;span&gt;pid_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;user_namespace&lt;/span&gt; *&lt;span&gt;user_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;net&lt;/span&gt;            *&lt;span&gt;net_ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 &lt;code&gt;struct nsproxy&lt;/code&gt; 结构的定义可以看出，Linux为每种不同类型的资源定义了不同的命名空间结构体进行管理。比如对于 &lt;code&gt;pid命名空间&lt;/code&gt; 定义了 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构来管理 。由于 namespace 涉及的资源种类比较多，所以本文主要以 &lt;code&gt;pid命名空间&lt;/code&gt; 作为分析的对象。&lt;/p&gt;&lt;p&gt;我们先来看看管理 &lt;code&gt;pid命名空间&lt;/code&gt; 的 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构的定义：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kref&lt;/span&gt; &lt;span&gt;kref&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pidmap&lt;/span&gt; &lt;span&gt;pidmap&lt;/span&gt;[&lt;span&gt;PIDMAP_ENTRIES&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; last_pid;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;child_reaper&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kmem_cache&lt;/span&gt; *&lt;span&gt;pid_cachep&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; level;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;parent&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifdef&lt;/span&gt; CONFIG_PROC_FS&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;vfsmount&lt;/span&gt; *&lt;span&gt;proc_mnt&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 &lt;code&gt;struct pid_namespace&lt;/code&gt; 结构主要用于为当前 &lt;code&gt;pid命名空间&lt;/code&gt; 分配空闲的pid，所以定义比较简单：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;kref&lt;/code&gt; 成员是一个引用计数器，用于记录引用这个结构的进程数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;pidmap&lt;/code&gt; 成员用于快速找到可用pid的位图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;last_pid&lt;/code&gt; 成员是记录最后一个可用的pid&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level&lt;/code&gt; 成员记录当前 &lt;code&gt;pid命名空间&lt;/code&gt; 所在的层次&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;parent&lt;/code&gt; 成员记录当前 &lt;code&gt;pid命名空间&lt;/code&gt; 的父命名空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;由于 &lt;code&gt;pid命名空间&lt;/code&gt; 是分层的，也就是说新创建一个 &lt;code&gt;pid命名空间&lt;/code&gt; 时会记录父级 &lt;code&gt;pid命名空间&lt;/code&gt; 到 &lt;code&gt;parent&lt;/code&gt; 字段中，所以随着 &lt;code&gt;pid命名空间&lt;/code&gt; 的创建，在内核中会形成一颗 &lt;code&gt;pid命名空间&lt;/code&gt; 的树，如下图（图片来源）：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7692307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J74NbeVUdkM6eOh9r4NC48Kf8z17iaicxOZKQNUthUYx2NBictpiaIUdZIF6BPC7Ty4XI3GyUAYGvTvhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;figcaption&gt;pid-namespace&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;第0层的 &lt;code&gt;pid命名空间&lt;/code&gt; 是 &lt;code&gt;init&lt;/code&gt; 进程所在的命名空间。如果一个进程所在的 &lt;code&gt;pid命名空间&lt;/code&gt; 为 &lt;code&gt;N&lt;/code&gt;，那么其在 &lt;code&gt;0 ~ N 层pid命名空间&lt;/code&gt; 都有一个唯一的pid号。也就是说 &lt;code&gt;高层pid命名空间&lt;/code&gt; 的进程对 &lt;code&gt;低层pid命名空间&lt;/code&gt; 的进程是可见的，但是 &lt;code&gt;低层pid命名空间&lt;/code&gt; 的进程对 &lt;code&gt;高层pid命名空间&lt;/code&gt; 的进程是不可见的。&lt;/p&gt;&lt;p&gt;由于在 &lt;code&gt;第N层pid命名空间&lt;/code&gt; 的进程其在 &lt;code&gt;0 ~ N层pid命名空间&lt;/code&gt; 都有一个唯一的pid号，所以在进程描述符中通过 &lt;code&gt;pids&lt;/code&gt; 成员来记录其在每个层的pid号，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_link&lt;/span&gt; &lt;span&gt;pids&lt;/span&gt;[&lt;span&gt;PIDTYPE_MAX&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; pid_type {&lt;br/&gt;    PIDTYPE_PID,&lt;br/&gt;    PIDTYPE_PGID,&lt;br/&gt;    PIDTYPE_SID,&lt;br/&gt;    PIDTYPE_MAX&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; nr;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;ns&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; &lt;span&gt;pid_chain&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;atomic_t&lt;/span&gt; count;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_head&lt;/span&gt; &lt;span&gt;tasks&lt;/span&gt;[&lt;span&gt;PIDTYPE_MAX&lt;/span&gt;];&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;rcu_head&lt;/span&gt; &lt;span&gt;rcu&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; level;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; &lt;span&gt;numbers&lt;/span&gt;[1];&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_link&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; &lt;span&gt;node&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几个结构的关系如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5994623655913979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J74NbeVUdkM6eOh9r4NC48KicZDODa01icT37hqUoqJYhtiaUHDRjuzIFSKqa0v0dj6woKv60F77w9Uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;figcaption&gt;pid-namespace-structs&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们主要关注 &lt;code&gt;struct pid&lt;/code&gt; 这个结构，&lt;code&gt;struct pid&lt;/code&gt; 有个类型为 &lt;code&gt;struct upid&lt;/code&gt; 的成员 &lt;code&gt;numbers&lt;/code&gt;，其定义为只有一个元素的数组，但是其实是一个动态的数据，它的元素个数与 &lt;code&gt;level&lt;/code&gt; 的值一致，也就是说当 &lt;code&gt;level&lt;/code&gt; 的值为5时，那么 &lt;code&gt;numbers&lt;/code&gt; 成员就是一个拥有5个元素的数组。而每个元素记录了其在每层 &lt;code&gt;pid命名空间&lt;/code&gt; 的pid号，而 &lt;code&gt;struct upid&lt;/code&gt; 结构的 &lt;code&gt;nr&lt;/code&gt; 成员就是用于记录进程在不同层级 &lt;code&gt;pid命名空间&lt;/code&gt; 的pid号。&lt;/p&gt;&lt;p&gt;我们通过代码来看看怎么为进程分配pid号的，在内核中是用过 &lt;code&gt;alloc_pid()&lt;/code&gt; 函数分配pid号的，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct pid *&lt;span&gt;alloc_pid&lt;/span&gt;&lt;span&gt;(struct pid_namespace *ns)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;enum&lt;/span&gt; pid_type type;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i, nr;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid_namespace&lt;/span&gt; *&lt;span&gt;tmp&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; *&lt;span&gt;upid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    pid = kmem_cache_alloc(ns-&amp;gt;pid_cachep, GFP_KERNEL);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!pid)&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; out;&lt;br/&gt;&lt;br/&gt;    tmp = ns;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = ns-&amp;gt;level; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;        nr = alloc_pidmap(tmp);    &lt;span&gt;// 为当前进程所在的不同层级pid命名空间分配一个pid&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nr &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;goto&lt;/span&gt; out_free;&lt;br/&gt;&lt;br/&gt;        pid-&amp;gt;numbers[i].nr = nr;   &lt;span&gt;// 对应i层namespace中的pid数字&lt;/span&gt;&lt;br/&gt;        pid-&amp;gt;numbers[i].ns = tmp;  &lt;span&gt;// 对应i层namespace的实体&lt;/span&gt;&lt;br/&gt;        tmp = tmp-&amp;gt;parent;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    get_pid_ns(ns);&lt;br/&gt;    pid-&amp;gt;level = ns-&amp;gt;level;&lt;br/&gt;    atomic_set(&amp;amp;pid-&amp;gt;count, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (type = &lt;span&gt;0&lt;/span&gt;; type &amp;lt; PIDTYPE_MAX; ++type)&lt;br/&gt;        INIT_HLIST_HEAD(&amp;amp;pid-&amp;gt;tasks[type]);&lt;br/&gt;&lt;br/&gt;    spin_lock_irq(&amp;amp;pidmap_lock);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = ns-&amp;gt;level; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;        upid = &amp;amp;pid-&amp;gt;numbers[i];&lt;br/&gt;        &lt;span&gt;// 把upid连接到全局pid中, 用于快速查找pid&lt;/span&gt;&lt;br/&gt;        hlist_add_head_rcu(&amp;amp;upid-&amp;gt;pid_chain,&lt;br/&gt;                &amp;amp;pid_hash[pid_hashfn(upid-&amp;gt;nr, upid-&amp;gt;ns)]);&lt;br/&gt;    }&lt;br/&gt;    spin_unlock_irq(&amp;amp;pidmap_lock);&lt;br/&gt;&lt;br/&gt;out:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pid;&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码中，那个 &lt;code&gt;for (i = ns-&amp;gt;level; i &amp;gt;= 0; i--)&lt;/code&gt; 就是通过 &lt;code&gt;parent&lt;/code&gt; 成员不断向上检索为不同层级的 &lt;code&gt;pid命名空间&lt;/code&gt; 分配一个唯一的pid号，并且保存到对应的 &lt;code&gt;nr&lt;/code&gt; 字段中。另外，还会把进程所在各个层级的pid号添加到全局pid哈希表中，这样做是为了通过pid号快速找到进程。&lt;/p&gt;&lt;p&gt;现在我们来看看怎么通过pid号快速找到一个进程，在内核中 &lt;code&gt;find_get_pid()&lt;/code&gt; 函数用来通过pid号查找对应的 &lt;code&gt;struct pid&lt;/code&gt; 结构，代码如下（find_get_pid() -&amp;gt; find_vpid() -&amp;gt; find_pid_ns()）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;struct pid *&lt;span&gt;find_get_pid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;pid_t&lt;/span&gt; nr)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;pid&lt;/span&gt; *&lt;span&gt;pid&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    rcu_read_lock();&lt;br/&gt;    pid = get_pid(find_vpid(nr));&lt;br/&gt;    rcu_read_unlock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; pid;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct pid *&lt;span&gt;find_vpid&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nr)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; find_pid_ns(nr, current-&amp;gt;nsproxy-&amp;gt;pid_ns);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;struct pid *&lt;span&gt;find_pid_ns&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nr, struct pid_namespace *ns)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;hlist_node&lt;/span&gt; *&lt;span&gt;elem&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;upid&lt;/span&gt; *&lt;span&gt;pnr&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    hlist_for_each_entry_rcu(pnr, elem,&lt;br/&gt;            &amp;amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pnr-&amp;gt;nr == nr &amp;amp;&amp;amp; pnr-&amp;gt;ns == ns)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; container_of(pnr, struct pid,&lt;br/&gt;                    numbers[ns-&amp;gt;level]);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过pid号查找 &lt;code&gt;struct pid&lt;/code&gt; 结构时，首先会把进程pid号和当前进程的 &lt;code&gt;pid命名空间&lt;/code&gt; 传入到 &lt;code&gt;find_pid_ns()&lt;/code&gt; 函数，而在 &lt;code&gt;find_pid_ns()&lt;/code&gt; 函数中通过全局pid哈希表来快速查找对应的 &lt;code&gt;struct pid&lt;/code&gt; 结构。获取到 &lt;code&gt;struct pid&lt;/code&gt; 结构后就可以很容易地获取到进程对应的进程描述符，例如可以通过 &lt;code&gt;pid_task()&lt;/code&gt; 函数来获取 &lt;code&gt;struct pid&lt;/code&gt; 结构对应进程描述符，由于代码比较简单，这里就不再分析了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a88b3969972adb4e9f02e096971c026b</guid>
<title>除了这点技术，其它什么也不会啊</title>
<link>https://toutiao.io/k/x4pf7co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;长按二维码向我转账&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;人生如梦，一樽还酹江月&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b723b8a358da80861d6d41e89ff3eee6</guid>
<title>学姐说：模型部署优化的学习路线是什么？</title>
<link>https://toutiao.io/k/d0axppb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;知友问：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我现在只会 Python，每天工作就是写脚本处理数据、训练模型，但是没什么工程能力，我想往模型部署优化、算法落地这个方向发展，请问该怎么学习与规划？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;模型部署优化这个方向其实比较宽泛。&lt;/span&gt;&lt;span&gt;从模型完成训练，到最终将模型部署到实际硬件上，整个流程中会涉及到很多不&lt;/span&gt;&lt;span&gt;同层面的工作，每一个环节对技术点的要求也不尽相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;部署的流程大致可以分为&lt;/span&gt;&lt;span&gt;以&lt;/span&gt;&lt;span&gt;下几个环节：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;390&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.6981776765375854&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xNm29D5VjSiaLibKKt1kCoH8n7fCmQcmIicYwqdoBic0b2Hrs6QaSlFUfcCV3weecWmzCuhF9aJ9niaLGqoxN3jeSUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一、模型转换 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;从训练框架得到模型后，根据需求转换到相应的模型格式。&lt;/span&gt;&lt;span&gt;模型格式的选择通常是根据公司业务端 SDK 的需求，通常为 caffe 模型或 onnx 模型，以方便模型在不同的框架之间适配。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;该环节的工作需要对相应的训练框架以及 caffe/onnx 等模型格式有所了解。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常用的 Pytorch 和 TensorFlow 等框架都有十分成熟的社区和对应的博客或教程；&lt;/span&gt;&lt;span&gt;caffe 和 onnx 模型格式也有很多可参考和学习的公开文档。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;即使没找到有可参考的文章时，好在二者都是开源的，依然可以通过对源码和样例代码的阅读来寻找答案。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、模型优化 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;此处的模型优化是指与后端无关的通用优化，比如常量折叠&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;算数优化&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;依赖优化&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;函数优化&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;算子融合&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;模型信息简化等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;部分训练框架会在训练模型导出时就包含部分上述优化过程，同时如果模型格式进行了转换操作，不同&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;IR&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;表示之间的差异可能会引入一&lt;/span&gt;&lt;span&gt;些冗余或可优化的计算，因此在模型转换后通常也会进行一部分的模型优化操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;该环节的工作需要对计算图的执行流程、各个&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;op&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;的计算定义、程序运行性能模型有一定了解，才能知道如果进行模型优化，&lt;/span&gt;&lt;span&gt;如何&lt;/span&gt;&lt;span&gt;保证优化后的模型具有更好的性能。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;了解&lt;/span&gt;&lt;span&gt;得&lt;/span&gt;&lt;span&gt;越深入，越可以挖掘到更多的模型潜在性能。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三、模型压缩 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;广义上来讲，模型压缩也属于模型优化的一部分。模型压缩本身也包括很多种方法，比如剪枝&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;蒸馏&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;量化等等。&lt;/span&gt;&lt;span&gt;模型压缩的根本目的是希望获得一个较小的模型，减少存储需求的同时降低计算量，从而达到加速的目的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;该环节的工作需要对压缩算法本身&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;模型涉及到的算法任务及模型结构设计&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;硬件平台计算流程三个方面都有一定的了解。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当因模型压缩操作导致模型精度下降时，对模型算法的了解，和该模型在硬件上的计算细节有足够的了解，才能分析出精度下降的原因，并给出针对性的解决方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;对于模型压缩更重要的往往是工程经验&lt;/strong&gt;，&lt;/span&gt;&lt;span&gt;因为在不同的硬件后端上部署相同的模型时，&lt;/span&gt;&lt;span&gt;由于&lt;/span&gt;&lt;span&gt;硬件计算的差异性，对精度的影响往往也不尽相同，这方面只有通过&lt;/span&gt;&lt;span&gt;积累&lt;/span&gt;&lt;span&gt;工程经验来不断提升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;PPL &lt;/span&gt;&lt;span&gt;也在逐步开源自己的模型压缩工具链，并对上述提到的模型算法、压缩算法&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;硬件平台适配等方面的知识进行介绍&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、模型部署&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;模&lt;/span&gt;&lt;span&gt;型部署是整个过程中最复杂的环节。从工程上讲，主要的核心任务是模型打包&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;模型加密，并进行&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;SDK&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;封装。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一个实际的产品中，往往会用到多个模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;模型打包是指将模型涉及到的前后处理，以及多个模型整合到一起，并加入一些其他描述性文件。&lt;/span&gt;&lt;span&gt;模型打包的格式和模型加密的方法与具体的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;SDK&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;相关。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在该环节中主要涉及到的技能与&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;SDK&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;开发更为紧密。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从功能上讲，对部署最后的性能影响最大的肯定是&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;SDK&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;中包含的后端库，即实际运行模型的推理库。&lt;/span&gt;&lt;span&gt;开发一个高性能推理库所需要的技能点就要更为广泛&lt;/span&gt;&lt;span&gt;，并且&lt;/span&gt;&lt;span&gt;专业。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并行计算的编程思想在不同的平台上是通用的，但不同的硬件架构的有着各自的特点，推理库的开发思路也不尽相同，这也就要求对开发后端的架构体系有着一定的了解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体到不同架构的编程学习，建议参考当前各大厂开源的推理库来进一步学习&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;💡&lt;/span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;尝试一下：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzNDI2NjUwMw==&amp;amp;mid=2247484238&amp;amp;idx=1&amp;amp;sn=660e6eb4c142c1ac89d5178b0ba88fce&amp;amp;chksm=c2be90a6f5c919b00f23d3c41822ab9d0879061f644dd8871e23d71b3b52b4c22027965efca8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从 0 到 1，使用 OpenPPL 实现一个 AI 推理应用&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;👨‍💻&lt;strong&gt; 加入我们：&lt;/strong&gt;《&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzNDI2NjUwMw==&amp;amp;mid=2247484096&amp;amp;idx=1&amp;amp;sn=c762744049a82b70788530d46720db33&amp;amp;chksm=c2be9128f5c9183ec70ca565faf5af1d10c3e57d2f2625ad3aff8865798a5e41770d71355539&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;OpenPPL 招人啦！&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;⭐️ 欢迎 star &lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🔗 &lt;/span&gt;&lt;span&gt;https://github.co&lt;/span&gt;&lt;span&gt;m/openppl-public&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;加入 OpenPPL 交流群，参与技术大咖讨论！&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xNm29D5VjSia2C0sakZtE9vK0icBhTC8tfpTzNmiaCaNt7WxFhUdvBvicJkrLMV8aGVg89ToClEnP2sPpG3b0HEIbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;472&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;QQ 群：627853444&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkzNDI2NjUwMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xNm29D5VjSia2C0sakZtE9vK0icBhTC8tfN7WWicQJKKKmJ0gTAZ9nD6NNuftngo1Panc3aSOEoMxTSmzpl0I2J3A/0?wx_fmt=png&quot; data-nickname=&quot;OpenPPL&quot; data-alias=&quot;OpenPPL_AI&quot; data-signature=&quot;开源高性能深度学习推理引擎&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;👇🏻 点击「&lt;span&gt;阅读原文&lt;/span&gt;」查看 OpenPPL 项目详情&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>