<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>60b3cf17fdd6bc836be3442a65bd0f56</guid>
<title>面试侃集合：SynchronousQueue 非公平模式篇</title>
<link>https://toutiao.io/k/6qaznpz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官：好了，你也休息了十分钟了，咱们接着往下聊聊&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;&lt;span&gt;&lt;strong&gt;的非公平模式吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：好的，有了前面公平模式的基础，非公平模式理解起来就非常简单了。公平模式下，&lt;code&gt;SynchronousQueue&lt;/code&gt;底层使用的是&lt;code&gt;TransferQueue&lt;/code&gt;，是一个先进先出的队列，而非公平模式与它不同，底层采用了后进先出的&lt;code&gt;TransferStack&lt;/code&gt;栈来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们还是先写一个例子来看看效果，首先创建3个线程使用&lt;code&gt;put&lt;/code&gt;方法向&lt;code&gt;SynchronousQueue&lt;/code&gt;中插入数据，结束后再使用3个线程调用&lt;code&gt;take&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SynchronousQueue&amp;lt;Integer&amp;gt; queue=&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;&amp;gt;(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PutThread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;        queue.put(i);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;putThread &quot;&lt;/span&gt;+i+&lt;span&gt;&quot; end&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TakeThread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;takeThread take: &quot;&lt;/span&gt;+queue.take());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;=&lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; PutThread(i)).start();&lt;br/&gt;    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;=&lt;span&gt;3&lt;/span&gt; ; i++) {&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TakeThread()).start();&lt;br/&gt;    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的代码，查看结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;takeThread take: 3&lt;br/&gt;putThread 3 end&lt;br/&gt;takeThread take: 2&lt;br/&gt;putThread 2 end&lt;br/&gt;takeThread take: 1&lt;br/&gt;putThread 1 end&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，生产者线程在执行完&lt;code&gt;put&lt;/code&gt;后会进行阻塞，直到有消费者线程调用&lt;code&gt;take&lt;/code&gt;方法取走了数据，才会唤醒被阻塞的线程。并且，数据的出队与入队顺序是相反的，即非公平模式下采用的是后进先出的顺序。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5769230769230769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicZPgs85CvrDAaic1e9lLsu2WQVdV1LiaMMAm2xr94wn4BR8d96RQNMQTvKYJBJujZ5ibIafRff97Y2UQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;780&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：就是把结构从队列换成了栈，真就这么简单？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：并不是，包括底层节点以及出入栈的逻辑都做了相应的改变。我们先看节点，在之前的公平模式中队列的节点是&lt;code&gt;QNode&lt;/code&gt;，非公平模式下栈中节点是&lt;code&gt;SNode&lt;/code&gt;，定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;volatile&lt;/span&gt; SNode next; &lt;span&gt;// 指向下一个节点的指针&lt;/span&gt;&lt;br/&gt;&lt;span&gt;volatile&lt;/span&gt; SNode match; &lt;span&gt;// 存放和它进行匹配的节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;volatile&lt;/span&gt; Thread waiter;  &lt;span&gt;// 保存阻塞的线程&lt;/span&gt;&lt;br/&gt;Object item;                &lt;br/&gt;&lt;span&gt;int&lt;/span&gt; mode;&lt;br/&gt;SNode(Object item) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.item = item;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;code&gt;QNode&lt;/code&gt;类似，如果是生产者构建的节点，那么&lt;code&gt;item&lt;/code&gt;非空，如果是消费者产生的节点，那么&lt;code&gt;item&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;。此外还有一个&lt;code&gt;mode&lt;/code&gt;属性用来表示节点的状态，它使用&lt;code&gt;TransferStack&lt;/code&gt;中定义的3个常量来表示不同状态：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; REQUEST    = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//消费者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DATA       = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//生产者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FULFILLING = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;//匹配中状态&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TransferStack&lt;/code&gt;中没有携带参数的构造函数，使用一个&lt;code&gt;head&lt;/code&gt;节点来标记栈顶节点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;volatile&lt;/span&gt; SNode head; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;官：基本结构就讲到这吧，还是老规矩，先从入队操作开始分析吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：当栈为空、或栈顶元素的类型与自己相同时，会先创建一个&lt;code&gt;SNode&lt;/code&gt;节点，并将它的&lt;code&gt;next&lt;/code&gt;节点指向当前栈顶的&lt;code&gt;head&lt;/code&gt;，然后将&lt;code&gt;head&lt;/code&gt;指针指向自己。这个过程中通过使用&lt;code&gt;CAS&lt;/code&gt;保证线程安全，如果失败则退出，在循环中采取自旋的方式不断进行尝试，直到节点入栈成功。用一张图来表示两个线程同时入栈的场景：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5294117647058824&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicYZQbCIceB84uU3ia5L6FR35GMoHBVZjkD1VXNCeHJa4xY3IPKIO3gPqicaZHAwtnBLjjHTaQG5LJmQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当节点完成入栈后，调用&lt;code&gt;awaitFulfill&lt;/code&gt;方法，等待匹配的操作的到来。在这一过程中，会使节点对应的线程进行自旋或挂起操作，直到匹配操作的节点将自己唤醒，或被其他线程中断、等待超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当入栈后的节点是栈顶节点，或者节点的类型为&lt;code&gt;FULFILLING&lt;/code&gt;匹配状态时，那么可能会马上完成匹配，因此先进行自旋，当超过自旋次数上限后再挂起。而如果节点在自旋过程中，有新的节点压入栈顶，会将非栈顶节点剩余的自旋次数直接清零，挂起线程避免浪费资源。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46511627906976744&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicYZQbCIceB84uU3ia5L6FR35dXUaZ5fS3MpCSIEMcZpfrny4JVJfaeSuZWaCkAviaibhoZ9VPFPkwOdw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试官&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：你上面也说了，挂起的线程有可能会超时或者被中断，这时候应该怎么处理？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：当这两种情况出现时，&lt;code&gt;SNode&lt;/code&gt;会将&lt;code&gt;match&lt;/code&gt;属性设为自身，退出&lt;code&gt;awaitFulfill&lt;/code&gt;方法，然后调用&lt;code&gt;clean&lt;/code&gt;方法将对应的节点清理出栈。具体情形可分为两种情况。先说简单的情况，如果清理的是栈顶节点，那么直接将&lt;code&gt;head&lt;/code&gt;节点指向它的&lt;code&gt;next&lt;/code&gt;节点，即将当前栈顶节点弹出即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;官：那么如果要删除的节点不是栈顶的节点呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：如果清理的不是栈顶节点，会稍微有一些麻烦。因为栈的底层是一个单向的链表结构，所以需要从栈顶&lt;code&gt;head&lt;/code&gt;节点开始遍历，遍历到被删除节点的后继节点为止。所以在清除工作开始前，先使用了一个&lt;code&gt;past&lt;/code&gt;节点标记需要删除节点的下一个节点，作为结束遍历的标记。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后创建一个标记节点&lt;code&gt;p&lt;/code&gt;，初始时指向&lt;code&gt;head&lt;/code&gt;节点，开始循环，如果&lt;code&gt;p&lt;/code&gt;的&lt;code&gt;next&lt;/code&gt;节点不是需要被删除的节点，那么就将&lt;code&gt;p&lt;/code&gt;向后移一个位置，直到找到这个需要被删除的中断或超时的节点，然后将&lt;code&gt;p&lt;/code&gt;的&lt;code&gt;next&lt;/code&gt;指向这个删除节点的&lt;code&gt;next&lt;/code&gt;节点，在逻辑上完成链表中节点的删除。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5263157894736842&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicYZQbCIceB84uU3ia5L6FR35D3F5qQic6NV8Flc4OlSpO4keGS082aSibQFXGHGEmxyrMnZHIgYXJ6tA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;760&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：单一类型节点的入栈应该说完了吧，接下来说说不同类型节点间是如何实现的匹配操作吧？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：好的，那我们先回顾一点上面的知识，前面说过每个节点有一个&lt;code&gt;mode&lt;/code&gt;属性代表它的模式，&lt;code&gt;REQUEST&lt;/code&gt;表示它是消费者，&lt;code&gt;DATA&lt;/code&gt;表示是生产者，&lt;code&gt;FULFILLING&lt;/code&gt;表明正处于匹配中的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个新的线程调用方法时，先判断它的类型&lt;code&gt;mode&lt;/code&gt;是什么，如果和当前栈顶&lt;code&gt;head&lt;/code&gt;节点类型不同，且&lt;code&gt;head&lt;/code&gt;节点的状态不为匹配中时，将它的状态设置为&lt;code&gt;FULFILLING|mode&lt;/code&gt;，压入栈中。然后将尝试匹配新的&lt;code&gt;head&lt;/code&gt;节点和它的&lt;code&gt;next&lt;/code&gt;节点，如果匹配成功，会将&lt;code&gt;next&lt;/code&gt;节点的&lt;code&gt;match&lt;/code&gt;属性设置为&lt;code&gt;head&lt;/code&gt;节点，唤醒挂起的&lt;code&gt;next&lt;/code&gt;节点中的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完成匹配后，当前头节点对应的线程会协助推进&lt;code&gt;head&lt;/code&gt;节点，将&lt;code&gt;head&lt;/code&gt;指向&lt;code&gt;next&lt;/code&gt;节点的下一个节点，即完成了栈顶两节点的出栈。最终消费者线程会返回匹配的生产者节点中的&lt;code&gt;item&lt;/code&gt;数据值，而生产者线程也会结束运行退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以栈中当前节点为&lt;code&gt;DATA&lt;/code&gt;类型，新节点为&lt;code&gt;REQUEST&lt;/code&gt;类型画一张图，来直观的感受一下上面的流程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6578947368421053&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zpom4BeZSicYZQbCIceB84uU3ia5L6FR35BSMfGZn1fY3N4WwvYicrv22kyalwEKZMia3zQ93U4AmoKEdXLicMpdRrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;760&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面试&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;官：总算是讲完了，能对&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;&lt;span&gt;&lt;strong&gt;做一个简单的总结吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：&lt;code&gt;SynchronousQueue&lt;/code&gt;基于底层结构，实现了线程配对通信这一机制。在它的公平模式下使用的是先进先出（&lt;code&gt;FIFO&lt;/code&gt;）的队列，非公平模式下使用的是后进先出（&lt;code&gt;LIFO&lt;/code&gt;）的栈，并且&lt;code&gt;SynchronousQueue&lt;/code&gt;没有使用&lt;code&gt;synchronized&lt;/code&gt;或&lt;code&gt;ReentrantLock&lt;/code&gt;，而是使用了大量的&lt;code&gt;CAS&lt;/code&gt;操作来保证并发操作。可能我们在平常的工作中使用场景不是很多，但是在线程池的设计中使用了&lt;code&gt;SynchronousQueue&lt;/code&gt;，还是有很重要的应用场景的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;试官：讲的还行，不过刚才这些和公平模式听起来感觉区别不大啊，没有什么技术含量。这样吧，你明天过来我们加试一场，我再给你打分。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hydra：（溜了溜了，还是找家别的靠谱公司吧……）&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>502e1fe3903c7242c9ed7197fa7b25e5</guid>
<title>微服务拆分之道</title>
<link>https://toutiao.io/k/mr1knwm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>abc21f85c5937e6e9e01deba01cdd708</guid>
<title>一文理解 Java 中的 SPI 机制</title>
<link>https://toutiao.io/k/3xscqep</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-source-line=&quot;1&quot;&gt;SPI机制简介&lt;/h2&gt;&lt;p data-source-line=&quot;2&quot;&gt;服务提供者接口（Service Provider Interface，简写为SPI）是JDK内置的一种服务提供发现机制。可以用来加载框架扩展和替换组件，主要是被框架的开发人员使用。在java.util.ServiceLoader的文档里有比较详细的介绍。&lt;/p&gt;&lt;p data-source-line=&quot;4&quot;&gt;系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案、xml解析模块、jdbc模块的方案等。面向对象的设计推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则：如果需要替换组建的一种实现，就需要修改框架的代码。SPI机制正是解决这个问题。&lt;/p&gt;&lt;p data-source-line=&quot;6&quot;&gt;Java中SPI机制主要思想是将装配的控制权移到程序之外，是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制，有点类似Spring的IOC机制。在模块化设计中这个机制尤其重要，其核心思想就是解耦。&lt;/p&gt;&lt;p data-source-line=&quot;8&quot;&gt;&lt;img data-ratio=&quot;0.3325102880658436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFYjzqMgxlkGkLulWnWyZc05RVNgGhXADDtUqEOHnYexXgBPtYm53oLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1215&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;10&quot;&gt;SPI的接口是Java核心库的一部分，是由引导类加载器(Bootstrap Classloader)来加载的。SPI的实现类是由系统类加载器(System ClassLoader)来加载的。&lt;/p&gt;&lt;p data-source-line=&quot;12&quot;&gt;引导类加载器在加载时是无法找到SPI的实现类的，因为双亲委派模型中规定，引导类加载器BootstrapClassloader无法委派系统类加载器AppClassLoader来加载。该如何解决此问题？&lt;/p&gt;&lt;p data-source-line=&quot;14&quot;&gt;线程上下文类加载由此诞生，它的出现也破坏了类加载器的双亲委派模型，使得程序可以进行逆向类加载。有关这部分知识在最后补充说明。&lt;/p&gt;&lt;h2 data-source-line=&quot;16&quot;&gt;应用场景&lt;/h2&gt;&lt;p data-source-line=&quot;18&quot;&gt;Java提供了很多SPI，允许第三方为这些接口提供实现。&lt;/p&gt;&lt;p data-source-line=&quot;20&quot;&gt;常见的SPI使用场景：&lt;/p&gt;&lt;ol data-source-line=&quot;21&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;JDBC加载不同类型的数据库驱动。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring中大量使用了SPI。可以在spring.factories中加上我们自定义的自动配置类，事件监听器或初始化器等。&lt;br/&gt;3.1 对servlet3.0规范。&lt;br/&gt;3.2 对ServletContainerInitializer的实现。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Dubbo里面有很多个组件，每个组件在框架中都是以接口的形成抽象出来。具体的实现又分很多种，在程序执行时根据用户的配置来按需取接口的实现。如果Dubbo的某个内置实现不符合业务需求，那么只需要利用其SPI机制将新的业务实现替换掉Dubbo的实现即可。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;28&quot;&gt;这些SPI的接口是由Java核心库来提供，而SPI的实现则是作为Java应用所依赖的jar包被包含进类路径（CLASSPATH）中。例如：JDBC的实现mysql就是通过Maven被依赖进来。&lt;/p&gt;&lt;h2 data-source-line=&quot;30&quot;&gt;SPI具体约定&lt;/h2&gt;&lt;p data-source-line=&quot;32&quot;&gt;Java SPI的具体约定：当服务的提供者，提供了服务接口的某种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能实现服务接口与实现的解耦。&lt;/p&gt;&lt;h2 data-source-line=&quot;34&quot;&gt;Java SPI机制的缺点&lt;/h2&gt;&lt;ol data-source-line=&quot;36&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多个并发多线程使用ServiceLoader类的实例是不安全的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展如果依赖其他的扩展，做不到自动注入和装配。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不提供类似于Spring的IOC和AOP功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;42&quot;&gt;针对以上的不足点，在生产环境的SPI机制选择时，可以考虑使用dubbo实现的SPI机制。感兴趣的同学可以自行查看，或等博客的后续更新。&lt;/p&gt;&lt;h3 data-source-line=&quot;44&quot;&gt;SPI实例&lt;/h3&gt;&lt;p data-source-line=&quot;46&quot;&gt;下面用一个简单的代码实例，演示SPI的使用方法。&lt;/p&gt;&lt;ol data-source-line=&quot;48&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;代码编写&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;50&quot;&gt;定义需要的接口，然后编码接口的实现类。&lt;/p&gt;&lt;p data-source-line=&quot;52&quot;&gt;&lt;img data-ratio=&quot;0.4209714726291442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFyTgqQkEkeJc8TfUg3qS4RPYLRQjvDunfvgkxpzoREvoaAM9rWPQeyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1297&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;54&quot;&gt;&lt;img data-ratio=&quot;0.39067854694996573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFJ3uGYFpY8I4bvoepPX0OmJFwE10GV7liaYCdSia7xIoWgedANTtMwv5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1459&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;56&quot;&gt;&lt;img data-ratio=&quot;0.326875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFJUSprdkOANhHvM6GHxIyxZNbWAhGX1vzeWydHfFVJS8U7XEPniba3Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; data-source-line=&quot;58&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;增加配置文件&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;60&quot;&gt;在项目的\src\main\resources\下创建\META-INF\services目录，并增加一个配置文件，这个文件必须以接口的全限定类名保持一致，例如：com.xiaohui.spi.HelloService。然后在配置文件中写入具体实现类的全限定类名，如有多个则换行写入。&lt;/p&gt;&lt;p data-source-line=&quot;62&quot;&gt;&lt;img data-ratio=&quot;0.45432497978981407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTF4krriaTicibRCKZLk0CC88zAsbTeiaxwtXla2avwgPJw7KDCXK8PXplpww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1237&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; data-source-line=&quot;64&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;使用JDK来载入&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;66&quot;&gt;使用JDK提供的ServiceLoader.load()来加载配置文件中的描述信息，完成类加载操作。&lt;/p&gt;&lt;p data-source-line=&quot;68&quot;&gt;&lt;img data-ratio=&quot;0.5680044593088072&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTFwwbTtRiaQOoH74icoe6Q0P4XE1NiaUjiaVT0Wkkcb4VawoyFMkr0UZZCdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1794&quot;/&gt;&lt;/p&gt;&lt;h2 data-source-line=&quot;70&quot;&gt;补充说明SPI加载&lt;/h2&gt;&lt;p data-source-line=&quot;72&quot;&gt;有关双亲委派的讲解，请查看博客《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247483853&amp;amp;idx=1&amp;amp;sn=e3c145cde37b4e08348a10de39682089&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Java类加载及对象创建过程详解&lt;/a&gt;》&lt;/p&gt;&lt;h3 data-source-line=&quot;74&quot;&gt;为什么需要破坏双亲委派？&lt;/h3&gt;&lt;p data-source-line=&quot;76&quot;&gt;在某些情况下父类加载器需要委托子类加载器去加载class文件。受到双亲委派加载范围的限制，父类加载器无法加载到需要的文件。&lt;/p&gt;&lt;h3 data-source-line=&quot;78&quot;&gt;如何破坏双亲委派？&lt;/h3&gt;&lt;p data-source-line=&quot;80&quot;&gt;双亲委派模型并不是一个强制性的约束模型，而是java设计者推荐给开发者的类加载器实现方式，在java项目中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过三次较大规模的“被破坏”情况。&lt;/p&gt;&lt;p data-source-line=&quot;82&quot;&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2发布之前。由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在 的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。&lt;/p&gt;&lt;p data-source-line=&quot;84&quot;&gt;双亲委派模型的第二次“被破坏”是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。&lt;/p&gt;&lt;p data-source-line=&quot;86&quot;&gt;为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。使用这个线程上下文类加载器去加载所需要的代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。&lt;/p&gt;&lt;p data-source-line=&quot;88&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。&lt;/p&gt;&lt;h3 data-source-line=&quot;90&quot;&gt;破坏双亲委派的举例&lt;/h3&gt;&lt;p data-source-line=&quot;92&quot;&gt;以tomcat为例，讲解如何破坏双亲委派，属于上述讲解的第二次破坏。&lt;/p&gt;&lt;p data-source-line=&quot;94&quot;&gt;&lt;img data-ratio=&quot;1.764525993883792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FCcQCUsqaSExkBFHia0CdTF9iaYgpiaMZlyVbdicSaWGwycbDkCXzXTdibNLPWIRb0hjPCcFLFxkeOiaLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;327&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;96&quot;&gt;如果有10个Web应用程序都用到了spring的话，可以把Spring的jar包放到common或shared目录下让这些程序共享。Spring的作用是管理每个web应用程序的bean，getBean时自然要能访问到应用程序的类，而用户的程序是放在/WebApp/WEB-INF目录中的（由WebAppClassLoader加载），那么在CommonClassLoader或SharedClassLoader中的Spring容器如何去加载并不在其加载范围的用户程序（/WebApp/WEB-INF/）中的Class呢？&lt;/p&gt;&lt;p data-source-line=&quot;98&quot;&gt;Spring统统使用线程上下文加载器(ContextClassLoade)来加载类，无需理会被放在哪里。ContextClassLoader默认存放了WebAppClassLoader的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作。&lt;/p&gt;&lt;p data-source-line=&quot;100&quot;&gt;参考：&lt;/p&gt;&lt;ol data-source-line=&quot;101&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;《深入理解java虚拟机》&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2383409fb4dfa2884d58ba550b970fd9</guid>
<title>Spark 中如何使用矩阵运算间接实现 i2i</title>
<link>https://toutiao.io/k/jo10x1d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.背景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前小编在计算两两用户的item重合度，根据item重合度去评估两个用户之间的相似度，根据条件进行过滤之后大概有3000个用户，但每个用户对应的item量参差不齐，有上百万的，有几千的，这样在去构建笛卡尔积的时候，进行item数据关联，得到的用户集就会特别大，spark运行的时候就会很慢，而且会出现很严重的数据倾斜。这个时候了解到了spark支持的数据类型，看到了CoordinateMatrix，然后深究其原理，便看到了这篇文章，经过整理形成了此文。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文出自「xingoo」在原文的基础上加以小编自己的理解形成的学习笔记，希望对读者有帮助。原文链接：Spark MLlib 之 大规模数据集的相似度计算原理探索&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.Spark支持的数据类型&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档地址：https://spark.apache.org/docs/latest/mllib-data-types.html&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Local Vector（本地向量）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地向量是从0开始的下标和double类型的数据组成，存储在本地机器上，所以称为Local Vector。它支持两种形式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Dense （密集的向量）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sparse （稀疏的向量）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一个向量[1.0,0.0,3.0]，用Dense表示为：[1.0,0.0,3.0]，用Sparse表示为：(3,[0,2],[1.0,3.0])，其中3为向量的长度，[0,2]表示元素[1.0,3.0]的位置，可见sparse形式下0.0是不存储的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.apache.spark.mllib.linalg.&lt;span&gt;Vectors&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; denseVector = &lt;span&gt;Vectors&lt;/span&gt;.dense(&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; sparseVector1 = &lt;span&gt;Vectors&lt;/span&gt;.sparse(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;),&lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; sparseVector2 = &lt;span&gt;Vectors&lt;/span&gt;.sparse(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;Seq&lt;/span&gt;((&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;),(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;)))&lt;br/&gt;&lt;br/&gt;println(&lt;span&gt;s&quot;DenseVector is : &lt;span&gt;$denseVector&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;println(&lt;span&gt;s&quot;DenseVector to Sparse is : &lt;span&gt;${denseVector.toSparse}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;println(&lt;span&gt;s&quot;sparseVector1 is : &lt;span&gt;$sparseVector1&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;println(&lt;span&gt;s&quot;sparseVector1 to Dense is : &lt;span&gt;${sparseVector1.toDense}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;println(&lt;span&gt;s&quot;sparseVector2 is : &lt;span&gt;$sparseVector2&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;println(&lt;span&gt;s&quot;sparseVector2 to Dense is : &lt;span&gt;${sparseVector2.toDense}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;DenseVector&lt;/span&gt; is : [&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;DenseVector&lt;/span&gt; to &lt;span&gt;Sparse&lt;/span&gt; is : (&lt;span&gt;3&lt;/span&gt;,[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;sparseVector1 is : (&lt;span&gt;3&lt;/span&gt;,[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;])&lt;br/&gt;sparseVector1 to &lt;span&gt;Dense&lt;/span&gt; is : [&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;sparseVector2 is : (&lt;span&gt;3&lt;/span&gt;,[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;],[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;])&lt;br/&gt;sparseVector2 to &lt;span&gt;Dense&lt;/span&gt; is : [&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Labeled point（带标签的点）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;labeled point由本地向量组成，既可以是dense向量，也可以是sparse向量。在mllib中常用于监督类算法，使用double类型来保存该类型的数据，因为也可以用于回归和分类算法。例如二分类，label可以是0（负例）或1（正例），对于多分类，label可以是0，1，2...&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.apache.spark.mllib.linalg.&lt;span&gt;Vectors&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.apache.spark.mllib.regression.&lt;span&gt;LabeledPoint&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; pos = &lt;span&gt;LabeledPoint&lt;/span&gt;(&lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;Vectors&lt;/span&gt;.dense(&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; neg = &lt;span&gt;LabeledPoint&lt;/span&gt;(&lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;Vectors&lt;/span&gt;.sparse(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;3.0&lt;/span&gt;)))&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;sparse data&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稀疏数据存储是非常普遍的现象，mllib支持读取libsvm格式的数据，其数据格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;label index1:value1,index2:value2 ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其读取方式包括：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.apache.spark.mllib.util.&lt;span&gt;MLUtils&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// method 1&lt;/span&gt;&lt;br/&gt;spark.read.format(&lt;span&gt;&quot;libsvm&quot;&lt;/span&gt;) .load(&lt;span&gt;&quot;libsvm data path&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// method 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MLUtils&lt;/span&gt;.loadLibSVMFile(spark.sparkContext, &lt;span&gt;&quot;libsvm data path&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 Local Matrix（本地矩阵）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;local matrix由行下标，列索引和double类型的值组成，存储在本地机器上，mllib支持密集矩阵和稀疏矩阵，其存储是按照列进行存储的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如下面的为密集矩阵:&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;\begin{pmatrix}&amp;#10;1.0 &amp;amp; 2.0 \\ &amp;#10;3.0 &amp;amp; 4.0 \\ &amp;#10;5.0 &amp;amp; 6.0&amp;#10;\end{pmatrix}&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -2150 5306 3800&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mrow&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;239B&quot; d=&quot;M837 1154Q843 1148 843 1145Q843 1141 818 1106T753 1002T667 841T574 604T494 299Q417 -84 417 -609Q417 -641 416 -647T411 -654Q409 -655 366 -655Q299 -655 297 -654Q292 -652 292 -643T291 -583Q293 -400 304 -242T347 110T432 470T574 813T785 1136Q787 1139 790 1142T794 1147T796 1150T799 1152T802 1153T807 1154T813 1154H819H837Z&quot; transform=&quot;translate(0, 996)&quot;/&gt;&lt;path data-c=&quot;239D&quot; d=&quot;M843 -635Q843 -638 837 -644H820Q801 -644 800 -643Q792 -635 785 -626Q684 -503 605 -363T473 -75T385 216T330 518T302 809T291 1093Q291 1144 291 1153T296 1164Q298 1165 366 1165Q409 1165 411 1164Q415 1163 416 1157T417 1119Q417 529 517 109T833 -617Q843 -631 843 -635Z&quot; transform=&quot;translate(0, -1006)&quot;/&gt;&lt;svg y=&quot;59&quot; x=&quot;0&quot; viewbox=&quot;0 86.3 875 382&quot;&gt;&lt;path data-c=&quot;239C&quot; d=&quot;M413 -9Q412 -9 407 -9T388 -10T354 -10Q300 -10 297 -9Q294 -8 293 -5Q291 5 291 127V300Q291 602 292 605L296 609Q298 610 366 610Q382 610 392 610T407 610T412 609Q416 609 416 592T417 473V127Q417 -9 413 -9Z&quot; transform=&quot;scale(1, 0.924)&quot;/&gt;&lt;/svg&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mtable&quot; transform=&quot;translate(875, 0)&quot;&gt;&lt;g data-mml-node=&quot;mtr&quot; transform=&quot;translate(0, 1400)&quot;&gt;&lt;g data-mml-node=&quot;mtd&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mtd&quot; transform=&quot;translate(2278, 0)&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mtr&quot;&gt;&lt;g data-mml-node=&quot;mtd&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mtd&quot; transform=&quot;translate(2278, 0)&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;34&quot; d=&quot;M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mtr&quot; transform=&quot;translate(0, -1400)&quot;&gt;&lt;g data-mml-node=&quot;mtd&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;35&quot; d=&quot;M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mtd&quot; transform=&quot;translate(2278, 0)&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;36&quot; d=&quot;M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4431, 0)&quot;&gt;&lt;path data-c=&quot;239E&quot; d=&quot;M31 1143Q31 1154 49 1154H59Q72 1154 75 1152T89 1136Q190 1013 269 873T401 585T489 294T544 -8T572 -299T583 -583Q583 -634 583 -643T577 -654Q575 -655 508 -655Q465 -655 463 -654Q459 -653 458 -647T457 -609Q457 -58 371 340T100 1037Q87 1059 61 1098T31 1143Z&quot; transform=&quot;translate(0, 996)&quot;/&gt;&lt;path data-c=&quot;23A0&quot; d=&quot;M56 -644H50Q31 -644 31 -635Q31 -632 37 -622Q69 -579 100 -527Q286 -228 371 170T457 1119Q457 1161 462 1164Q464 1165 520 1165Q575 1165 577 1164Q582 1162 582 1153T583 1093Q581 910 570 752T527 400T442 40T300 -303T89 -626Q78 -640 75 -642T61 -644H56Z&quot; transform=&quot;translate(0, -1006)&quot;/&gt;&lt;svg y=&quot;59&quot; x=&quot;0&quot; viewbox=&quot;0 86.3 875 382&quot;&gt;&lt;path data-c=&quot;239F&quot; d=&quot;M579 -9Q578 -9 573 -9T554 -10T520 -10Q466 -10 463 -9Q460 -8 459 -5Q457 5 457 127V300Q457 602 458 605L462 609Q464 610 532 610Q548 610 558 610T573 610T578 609Q582 609 582 592T583 473V127Q583 -9 579 -9Z&quot; transform=&quot;scale(1, 0.924)&quot;/&gt;&lt;/svg&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过数组存储的形式为：[1.0, 3.0, 5.0, 2.0, 4.0, 6.0]，矩阵大小为[3，2]&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Create a dense matrix ((1.0, 2.0), (3.0, 4.0), (5.0, 6.0))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; denseMatrix = &lt;span&gt;Matrices&lt;/span&gt;.dense(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;3.0&lt;/span&gt;,&lt;span&gt;5.0&lt;/span&gt;,&lt;span&gt;2.0&lt;/span&gt;,&lt;span&gt;4.0&lt;/span&gt;,&lt;span&gt;6.0&lt;/span&gt;))&lt;br/&gt;println(&lt;span&gt;s&quot;denseMatrix is : &lt;span&gt;$denseMatrix&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Create a sparse matrix ((9.0, 0.0), (0.0, 8.0), (0.0, 6.0))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; sparseMatrix = &lt;span&gt;Matrices&lt;/span&gt;.sparse(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),&lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),&lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;))&lt;br/&gt;println(&lt;span&gt;s&quot;sparseMatrix is : &lt;span&gt;$sparseMatrix&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：稀疏矩阵解释，首先指定矩阵是3行2列，Array(0, 1, 3)是指，第0个非零元素在第一列，第一第二个非零元素在第二列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Array(0, 2, 1)是指，第一个非零元素在第0行，第二个非零元素在第2行，第三个非零元素在第1行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处设计比较好，假设100个元素分两列，不需要把每个元素所在列都标出来，只需要记录3个数字即可。Array(9, 6, 8)表示按顺序存储非零元素.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Array(0,1,3)比较难理解，可以参考以下文章：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://www.cnblogs.com/lyy-blog/p/9288701.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.tuicool.com/articles/A3emmqis&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 Distributed Matrix（分布式矩阵）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个分布式矩阵由下标和double类型的数据组成，不过分布式的矩阵的下标不是int类型，而是long类型，数据保存在一个或多个rdd中，选择一个正确的格式去存储分布式矩阵是非常重要的。分布式矩阵转换成不同的格式需要一个全局的shuffle(global shuffle)，而全局shuffle的代价会非常高。到目前为止，Spark MLlib中已经实现了三种分布式矩阵。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最基本的分布式矩阵是RowMatrix，它是一个行式的分布式矩阵，没有行索引。比如一系列特征向量的集合。RowMatrix由一个RDD代表所有的行，每一行是一个本地向量。假设一个RowMatrix的列数不是特别巨大，那么一个简单的本地向量能够与driver进行联系，并且数据可以在单个节点上保存或使用。IndexedRowMatrix与RowMatrix类似但是有行索引，行索引可以用来区分行并且进行连接等操作。CoordinateMatrix是一个以协同列表（coordinate list)格式存储数据的分布式矩阵，数据以RDD形式存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：因为我们需要缓存矩阵的大小，所以分布式矩阵的RDDs格式是需要确定的，使用非确定RDDs的话会报错。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4.1 Row Matrix&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RowMatrix它是一个行式的分布式矩阵，没有行索引。比如一系列特征向量的集合。RowMatrix由一个RDD代表所有的行，每一行是一个本地向量。因为每一行代表一个本地向量，所以它的列数被限制在Integer.max的范围内，在实际应用中不会太大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个RowMatrix可以由一个RDD[Vector]的实例创建。因此我们可以计算统计信息或者进行分解。QR分解（QR decomposition）是A=QR，其中Q是一个矩阵，R是一个上三角矩阵。对sigular value decomposition（SVD）和principal component analysis（PCA）,可以去参考降维的部分。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Row Matrix&lt;/span&gt;&lt;br/&gt;println(&lt;span&gt;&quot;Row Matrix ...&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; arr = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;Vectors&lt;/span&gt;.dense(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),&lt;span&gt;Vectors&lt;/span&gt;.dense(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; rows = spark.sparkContext.parallelize(arr)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; mat: &lt;span&gt;RowMatrix&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;RowMatrix&lt;/span&gt;(rows)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; m = mat.numRows()&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; n = mat.numCols()&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; qrResult = mat.tallSkinnyQR(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;println(&lt;span&gt;s&quot;m is: &lt;span&gt;$m&lt;/span&gt;，n is &lt;span&gt;$n&lt;/span&gt;，\nqrResult is :&quot;&lt;/span&gt;)&lt;br/&gt;qrResult.&lt;span&gt;Q&lt;/span&gt;.rows.foreach(println)&lt;br/&gt;println()&lt;br/&gt;qrResult.&lt;span&gt;R&lt;/span&gt;.rowIter.foreach(println)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Row&lt;/span&gt; &lt;span&gt;Matrix&lt;/span&gt; ...&lt;br/&gt;m is: &lt;span&gt;2&lt;/span&gt;，n is &lt;span&gt;2&lt;/span&gt;，&lt;br/&gt;qrResult is :&lt;br/&gt;[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4.2 IndexedRowMatrix&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IndexedRowMatrix与RowMatrix类似，但是它有行索引。由一个行索引RDD表示，索引每一行由一个long型行索引和一个本地向量组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个IndexedRowMatrix可以由RDD[IndexedRow]的实例来生成，IndexedRow是一个（Long, Vector)的封装。去掉行索引，IndexedRowMatrix能够转换成RowMatrix。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// IndexedRowMatrix&lt;/span&gt;&lt;br/&gt;println(&lt;span&gt;&quot;Indexed Row Matrix ...&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; arr2 = &lt;span&gt;Array&lt;/span&gt;(&lt;br/&gt;        &lt;span&gt;IndexedRow&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;Vectors&lt;/span&gt;.dense(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;)),&lt;br/&gt;        &lt;span&gt;IndexedRow&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;Vectors&lt;/span&gt;.dense(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;    )&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; rows2: &lt;span&gt;RDD&lt;/span&gt;[&lt;span&gt;IndexedRow&lt;/span&gt;] = spark.sparkContext.parallelize(arr2)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; mat2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IndexedRowMatrix&lt;/span&gt;(rows2)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; m2 = mat2.numRows()&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; n2 = mat2.numCols()&lt;br/&gt;&lt;span&gt;// 去掉行索引，转换成RowMatrix&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; qrResult2 = mat2.toRowMatrix().tallSkinnyQR(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;println(&lt;span&gt;s&quot;m2 is: &lt;span&gt;$m2&lt;/span&gt;，n2 is &lt;span&gt;$n2&lt;/span&gt;，\nqrResult2 is :&quot;&lt;/span&gt;)&lt;br/&gt;qrResult2.&lt;span&gt;Q&lt;/span&gt;.rows.foreach(println)&lt;br/&gt;println()&lt;br/&gt;qrResult2.&lt;span&gt;R&lt;/span&gt;.rowIter.foreach(println)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Indexed&lt;/span&gt; &lt;span&gt;Row&lt;/span&gt; &lt;span&gt;Matrix&lt;/span&gt; ...&lt;br/&gt;m2 is: &lt;span&gt;2&lt;/span&gt;，n2 is &lt;span&gt;2&lt;/span&gt;，&lt;br/&gt;qrResult2 is :&lt;br/&gt;[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4.3 CoordinateMatrix&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CoordinateMatrix是一个分布式矩阵，其实体集合是一个RDD，每一个是一个三元组(i:Long, j:Long, value:Double）。其中i是行索引，j是列索引，value是实体的值。当矩阵的维度很大并且是稀疏矩阵时，才使用CoordinateMatrix。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个CoordinateMatrix可以通过一个RDD[MatrixEntry]的实例来创建，MatrixEntry是一个(Long, Long, Double)的封装。CoordinateMatrix可以通过调用toIndexedRowMatrix转换成一个IndexedRowMatrix。CoordinateMatrix的其他降维方法暂时还不支持（Spark-1.6.2)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// CoordinateMatrix&lt;/span&gt;&lt;br/&gt;println(&lt;span&gt;&quot;Coordinate Matrix ...&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; arr3 = &lt;span&gt;Array&lt;/span&gt;(&lt;br/&gt;    &lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; entries = spark.sparkContext.parallelize(arr3)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; mat3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CoordinateMatrix&lt;/span&gt;(entries)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; m3 = mat.numRows()&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; n3 = mat.numCols()&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; qrResult3 = mat3.toIndexedRowMatrix().toRowMatrix().tallSkinnyQR(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;println(&lt;span&gt;s&quot;m3 is: &lt;span&gt;$m3&lt;/span&gt;，n3 is &lt;span&gt;$n3&lt;/span&gt;，\nqrResult3 is :&quot;&lt;/span&gt;)&lt;br/&gt;qrResult3.&lt;span&gt;Q&lt;/span&gt;.rows.foreach(println)&lt;br/&gt;println()&lt;br/&gt;qrResult3.&lt;span&gt;R&lt;/span&gt;.rowIter.foreach(println)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Coordinate&lt;/span&gt; &lt;span&gt;Matrix&lt;/span&gt; ...&lt;br/&gt;m3 is: &lt;span&gt;2&lt;/span&gt;，n3 is &lt;span&gt;2&lt;/span&gt;，&lt;br/&gt;rowMat3 is :&lt;br/&gt;[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;1.0&lt;/span&gt;,&lt;span&gt;0.0&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;0.0&lt;/span&gt;,&lt;span&gt;1.0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4.4 BlockMatrix&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个BlockMatrix是一个分布式的矩阵，由一个MatrixBlocks的RDD组成。MatrixBlock是一个三元组((Int, Int), Matrix),其中(Int, Int)是block的索引，Matrix是一个在指定位置上的维度为rowsPerBlock * colsPerBlock的子矩阵。BlockMatrix支持与另一个BlockMatrix对象的add和multiply操作。BlockMatrix提供了一个帮助方法validate，这个方法可以用于检测该`BlockMatrix·是否正确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过IndexedRowMatrix或者CoordinateMatrix调用toBlockMatrix快速得到BlockMatrix对象。默认情况下toBlockMatrix方法会得到一个1024 x 1024的BlockMatrix。使用时可以通过手动传递维度值来设置维度，toBlockMatrix(rowsPerBlock, colsPerBlock)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// BlockMatrix&lt;/span&gt;&lt;br/&gt;println(&lt;span&gt;&quot;Block Matrix ...&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; arr4 = &lt;span&gt;Array&lt;/span&gt;(&lt;br/&gt;    &lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; entries4: &lt;span&gt;RDD&lt;/span&gt;[&lt;span&gt;MatrixEntry&lt;/span&gt;] = spark.sparkContext.parallelize(arr4)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; coordMat: &lt;span&gt;CoordinateMatrix&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CoordinateMatrix&lt;/span&gt;(entries4)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; matA: &lt;span&gt;BlockMatrix&lt;/span&gt; = coordMat.toBlockMatrix().cache()&lt;br/&gt;&lt;span&gt;// 检测BlockMatrix格式是否正确，错误的话会抛出异常，正确的话无其他影响&lt;/span&gt;&lt;br/&gt;matA.validate()&lt;br/&gt;matA.blocks.foreach(println)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; m4 = matA.numRowBlocks&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; n4 = matA.numColBlocks&lt;br/&gt;println(&lt;span&gt;s&quot;m4 is: &lt;span&gt;$m4&lt;/span&gt;，n4 is &lt;span&gt;$n4&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 计算A^T * A.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; ata = matA.transpose.multiply(matA)&lt;br/&gt;ata.blocks.foreach(println)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Block&lt;/span&gt; &lt;span&gt;Matrix&lt;/span&gt; ...&lt;br/&gt;((&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),&lt;span&gt;2&lt;/span&gt; x &lt;span&gt;2&lt;/span&gt; &lt;span&gt;CSCMatrix&lt;/span&gt;&lt;br/&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;1.0&lt;/span&gt;&lt;br/&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;1.0&lt;/span&gt;)&lt;br/&gt;m4 is: &lt;span&gt;1&lt;/span&gt;，n4 is &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;((&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),&lt;span&gt;1.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;1.0&lt;/span&gt;  )&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.相似度计算原理探索&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是ICF基于物品的协同过滤、UCF基于用户的协同过滤、基于内容的推荐，最基本的环节都是计算相似度。如果样本特征维度很高或者&amp;lt;user, item, score&amp;gt;的维度很大，都会导致无法直接计算。设想一下100w*100w的二维矩阵，计算相似度怎么算？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spark中RowMatrix提供了一种并行计算相似度的思路，下面就来看看其中的奥妙吧！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 相似度计算&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相似度有很多种，每一种适合的场景都不太一样。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;欧氏距离，在几何中最简单的计算方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;夹角余弦，通过方向计算相似度，通常在用户对商品评分、NLP等场景使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;杰卡德距离，在不考虑每一样的具体值时使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;皮尔森系数，与夹角余弦类似，但是可以去中心化。比如评分时，有人倾向于打高分，有人倾向于打低分，他们的最后效果在皮尔森中是一样的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;曼哈顿距离，一般在路径规划、地图类中常用，比如A*算法中使用曼哈顿来作为每一步代价值的一部分（F=G+H, G是从当前点移动到下一个点的距离，H是距离目标点的距离，这个H就可以用曼哈顿距离表示）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6080178173719376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsInicjSDeTgmYiaCQRFxzUWaUGZEsdQE6IxVjvZic2ibEAMYE8DE4bReO3UvUicbeb5SGkzcCVgAObdQfEZhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;449&quot;/&gt; &lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两个向量(x1,y1)和(x2,y2)计算夹角的余弦值就是两个向量方向的相似度，其公式为：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;cos(\theta )=\frac { a\cdot b }{ ||a||\ast ||b|| } \\ =\quad \frac { { x }_{ 1 }\ast { x }_{ 2 }\quad +\quad { y }_{ 1 }\ast y_{ 2 } }{ \sqrt { { x }_{ 1 }^{ 2 }+{ x }_{ 2 }^{ 2 } } \ast \sqrt { { y }_{ 1 }^{ 2 }+{ y }_{ 2 }^{ 2 } }  }&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/O1dAhMERUwVszWEXH1neppxKaJm9nrXyCCfV5NvduLicX5fErSdPB02TrLLAPv3IB2YCqIZcEAYyOpUZVvAtXibzCoDVF8cIXA/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;||a||&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -749.5 1641 999&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;7C&quot; d=&quot;M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(278, 0)&quot;&gt;&lt;path data-c=&quot;7C&quot; d=&quot;M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(556, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1085, 0)&quot;&gt;&lt;path data-c=&quot;7C&quot; d=&quot;M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1363, 0)&quot;&gt;&lt;path data-c=&quot;7C&quot; d=&quot;M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;表示&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;a&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -441 529 451&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;的模，即每一项的平方和再开方。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 公式拆解&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果向量不只是两维，而是n维呢？比如有两个向量：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个向量：&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;({x}_{1}, {x}_{2}, {x}_{3}, ..., {x}_{n})&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 7863.6 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(572, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1364.6, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(1809.2, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(572, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2784.8, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(3229.4, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(572, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4205, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4649.7, 0)&quot;&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5094.3, 0)&quot;&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5539, 0)&quot;&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5983.7, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(6428.3, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(572, -150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7474.6, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个向量：&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;({y}_{1}, {y}_{2}, {y}_{3}, ..., {y}_{n})&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 7535.6 1005.9&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(490, -240.4) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1282.6, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(1727.2, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(490, -240.4) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2620.8, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(3065.4, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(490, -240.4) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3959, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4403.7, 0)&quot;&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4848.3, 0)&quot;&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5293, 0)&quot;&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5737.7, 0)&quot;&gt;&lt;path data-c=&quot;2C&quot; d=&quot;M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(6182.3, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(490, -240.4) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7146.6, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们的相似度计算方法套用上面的公式为：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;cos(\theta )\quad =\quad \frac { \sum _{ i=1 }^{ n }{ ({ x }_{ i }\ast { y }_{ i }) }  }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  } \ast \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  } \\ =\quad \frac { { x }_{ 1 }\ast { y }_{ 1 }+{ x }_{ 2 }\ast { y }_{ 2 }+...+{ x }_{ n }\ast { y }_{ n } }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  } \ast \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  } \\ =\quad \frac { { x }_{ 1 }\ast { y }_{ 1 } }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  } \ast \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  } +\frac { { x }_{ 2 }\ast { y }_{ 2 } }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  } \ast \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  } +...+\frac { { x }_{ n }\ast { y }_{ n } }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  } \ast \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  } \\ =\quad \frac { { x }_{ 1 } }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  }  } \ast \frac { { y }_{ 1 } }{ \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  } +\frac { { x }_{ 2 } }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  }  } \ast \frac { { y }_{ 2 } }{ \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  } +...+\frac { { x }_{ n } }{ \sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  }  } \ast \frac { { y }_{ n } }{ \sqrt { \sum _{ i=1 }^{ n }{ y_{ i }^{ 2 } }  }  }&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/O1dAhMERUwVszWEXH1neppxKaJm9nrXyMJtN1rVPMgusCoonicOFdquqzIZoUgFicoZmpA9uOSibQW7bAorHBicF9lBNMYdDs7f2/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的公式就可以发现，夹角余弦可以拆解成每一项与另一项对应位置的乘积x1∗y1，再除以每个向量自己的&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;\sqrt { \sum _{ i=1 }^{ n }{ { x }_{ i }^{ 2 } }  }&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -1853 3642.2 3099&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msqrt&quot;&gt;&lt;g transform=&quot;translate(1056, 0)&quot;&gt;&lt;g data-mml-node=&quot;munderover&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2211&quot; d=&quot;M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(148.2, -1087.9) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;69&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(345, 0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1123, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(509.9, 1150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(1610.7, 0)&quot;&gt;&lt;g data-mml-node=&quot;msubsup&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(572, 413) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(572, -247) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;69&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(0, 0)&quot;&gt;&lt;path data-c=&quot;E001&quot; d=&quot;M702 589Q706 601 718 605H1061Q1076 597 1076 585Q1076 572 1061 565H742V0Q734 -14 724 -14H722H720Q708 -14 702 0V589Z&quot; transform=&quot;translate(0, 1188)&quot;/&gt;&lt;path data-c=&quot;23B7&quot; d=&quot;M742 -871Q740 -873 737 -876T733 -880T730 -882T724 -884T714 -885H702L222 569L180 484Q138 399 137 399Q131 404 124 412L111 425L265 736L702 -586V168L703 922Q713 935 722 935Q734 935 742 920V-871Z&quot; transform=&quot;translate(0, -360.9)&quot;/&gt;&lt;svg y=&quot;474.1&quot; x=&quot;0&quot; viewbox=&quot;0 173.7 1056 800&quot;&gt;&lt;path data-c=&quot;E000&quot; d=&quot;M722 -14H720Q708 -14 702 0V306L703 612Q713 625 722 625Q734 625 742 610V0Q734 -14 724 -14H722Z&quot; transform=&quot;scale(1, 1.878)&quot;/&gt;&lt;/svg&gt;&lt;/g&gt;&lt;rect x=&quot;1056&quot; y=&quot;1733&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 矩阵并行&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画个图看看，首先创建下面的矩阵：&lt;/p&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3190045248868778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsInicjSDeTgmYiaCQRFxzUWaUGZExCNGYgQkvrfwVbtWzNM89pYCjtwfTW2icbaPDzdaqFTpVSib5JLa1DTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;442&quot;/&gt;&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，矩阵里面都是一列代表一个向量....上面是创建矩阵时的三元组，如果在spark中想要创建matrix，可以这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; df = spark.createDataFrame(&lt;span&gt;Seq&lt;/span&gt;(&lt;br/&gt;      (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;),&lt;br/&gt;      (&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4.0&lt;/span&gt;)&lt;br/&gt;    ))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; matrix = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CoordinateMatrix&lt;/span&gt;(df.map(row =&amp;gt; &lt;span&gt;MatrixEntry&lt;/span&gt;(row.getAs[&lt;span&gt;Integer&lt;/span&gt;](&lt;span&gt;0&lt;/span&gt;).toLong, row.getAs[&lt;span&gt;Integer&lt;/span&gt;](&lt;span&gt;1&lt;/span&gt;).toLong, row.getAs[&lt;span&gt;Double&lt;/span&gt;](&lt;span&gt;2&lt;/span&gt;))).toJavaRDD)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后计算每一个向量的normL2，即平方和开根号。&lt;/p&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsInicjSDeTgmYiaCQRFxzUWaUGZEt7icLEvaXqXibAkQzpnavXrObPz9iaj3ibXQosibWjdAIxO0x841GOibsdZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以第一个和第二个向量计算为例，第一个向量为(1,1,1,1)，第二个向量为(2,2,1,1)，每一项除以对应的normL2，得到后面的两个向量：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;0.5*0.63+0.5*0.63+0.5*0.31+0.5*0.31 \approx 0.94&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/O1dAhMERUwVszWEXH1neppxKaJm9nrXy81CLu1qZU4QDyB2n3dvdto24XK09ibD8C0718kt3OXLyLSFHl3UhwjKViakBBrqwSic/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个向量最终的相似度为0.94。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在Spark如何快速并行处理呢？通过上面的例子，可以看到两个向量的相似度，需要把每一维度乘积后相加，但是一个向量一般都是跨RDD保存的，所以可以先计算所有向量的第一维，得出结果&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;(向量1的第1维，向量2的第1维，value)\\&amp;#10;(向量1的第2维，向量2的第2维，value)\\&amp;#10;...\\&amp;#10;(向量1的第n维，向量2的第n维，value)\\&amp;#10;(向量1的第1维，向量3的第1维，value)\\&amp;#10;..\\&amp;#10;(向量1的第n维，向量3的第n维，value)\\&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/O1dAhMERUwVszWEXH1neppxKaJm9nrXyLO1aDgGdZ8GbRpM4GpglL5ozyianmESlujAxgPuU8kk15zHce04QEbD5OaAAJibQeG/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后对做一次reduceByKey累加结果即可.....&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 阅读源码&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先创建dataframe形成matrix：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; org.apache.spark.mllib.linalg.distributed.{&lt;span&gt;CoordinateMatrix&lt;/span&gt;, &lt;span&gt;MatrixEntry&lt;/span&gt;}&lt;span&gt;import&lt;/span&gt; org.apache.spark.sql.&lt;span&gt;SparkSessionobject&lt;/span&gt; &lt;span&gt;MatrixSimTest&lt;/span&gt; {  &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;(args: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;]): &lt;span&gt;Unit&lt;/span&gt; = {    &lt;span&gt;// 创建dataframe，转换成matrix    val spark = SparkSession.builder().master(&quot;local[*]&quot;).appName(&quot;sim&quot;).getOrCreate()    spark.sparkContext.setLogLevel(&quot;WARN&quot;)    import spark.implicits._    val df = spark.createDataFrame(Seq(      (0, 0, 1.0),      (1, 0, 1.0),      (2, 0, 1.0),      (3, 0, 1.0),      (0, 1, 2.0),      (1, 1, 2.0),      (2, 1, 1.0),      (3, 1, 1.0),      (0, 2, 3.0),      (1, 2, 3.0),      (2, 2, 3.0),      (0, 3, 1.0),      (1, 3, 1.0),      (3, 3, 4.0)    ))    val matrix = new CoordinateMatrix(df.map(row =&amp;gt; MatrixEntry(row.getAs[Integer](0).toLong, row.getAs[Integer](1).toLong, row.getAs[Double](2))).toJavaRDD)    // 调用sim方法    val x = matrix.toRowMatrix().columnSimilarities()    // 得到相似度结果    x.entries.collect().foreach(println)  }}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得到的结果为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0.7071067811865476&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0.8660254037844386&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0.2721655269759087&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0.9486832980505139&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0.9128709291752768&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;MatrixEntry&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0.596284793999944&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接进入columnSimilarities方法看看是怎么个流程吧！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;columnSimilarities&lt;/span&gt;&lt;/span&gt;(): &lt;span&gt;CoordinateMatrix&lt;/span&gt; = {&lt;br/&gt;  columnSimilarities(&lt;span&gt;0.0&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部调用了带阈值的相似度方法，这里的阈值是指相似度小于该值时，输出结果时，会自动过滤掉。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;columnSimilarities&lt;/span&gt;&lt;/span&gt;(threshold: &lt;span&gt;Double&lt;/span&gt;): &lt;span&gt;CoordinateMatrix&lt;/span&gt; = {&lt;br/&gt;  &lt;span&gt;//检查参数...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; gamma = &lt;span&gt;if&lt;/span&gt; (threshold &amp;lt; &lt;span&gt;1e-6&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;Double&lt;/span&gt;.&lt;span&gt;PositiveInfinity&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt; * math.log(numCols()) / threshold&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt; columnSimilaritiesDIMSUM(computeColumnSummaryStatistics().normL2.toArray, gamma)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的gamma用于采样，具体的做法咱们来继续看源码。然后看一下computeColumnSummaryStatistics().normL2.toArray这个方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;computeColumnSummaryStatistics&lt;/span&gt;&lt;/span&gt;(): &lt;span&gt;MultivariateStatisticalSummary&lt;/span&gt; = {&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; summary = rows.treeAggregate(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;MultivariateOnlineSummarizer&lt;/span&gt;)(&lt;br/&gt;    (aggregator, data) =&amp;gt; aggregator.add(data),&lt;br/&gt;    (aggregator1, aggregator2) =&amp;gt; aggregator1.merge(aggregator2))&lt;br/&gt;  updateNumRows(summary.count)&lt;br/&gt;  summary&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前有介绍这个treeAggregate是一种带“预reduce”的map-reduce，返回的summary，里面帮我们统计了每一个向量的很多指标，比如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;currMean    为 每一个向量的平均值&lt;br/&gt;currM2      为 每个向量的每一维的平方和&lt;br/&gt;currL1      为 每个向量的绝对值的和&lt;br/&gt;currMax     为 每个向量的最大值&lt;br/&gt;currMin     为 每个向量的最小值&lt;br/&gt;nnz         为 每个向量的非&lt;span&gt;0&lt;/span&gt;个数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们只需要currM2，它是每个向量的平方和。summary调用的normL2方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;normL2&lt;/span&gt;&lt;/span&gt;: &lt;span&gt;Vector&lt;/span&gt; = {&lt;br/&gt;  require(totalWeightSum &amp;gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;s&quot;Nothing has been added to this summarizer.&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; realMagnitude = &lt;span&gt;Array&lt;/span&gt;.ofDim[&lt;span&gt;Double&lt;/span&gt;](n)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; len = currM2.length&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (i &amp;lt; len) {&lt;br/&gt;    realMagnitude(i) = math.sqrt(currM2(i))&lt;br/&gt;    i += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;Vectors&lt;/span&gt;.dense(realMagnitude)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这步就是对平方和开个根号，这样就求出来了每个向量的分母部分。下面就是最关键的地方了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt;[mllib] &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;columnSimilaritiesDIMSUM&lt;/span&gt;&lt;/span&gt;(&lt;br/&gt;      colMags: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;Double&lt;/span&gt;],&lt;br/&gt;      gamma: &lt;span&gt;Double&lt;/span&gt;): &lt;span&gt;CoordinateMatrix&lt;/span&gt; = {&lt;br/&gt;    &lt;span&gt;// 一些参数校验&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 对gamma进行开方&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; sg = math.sqrt(gamma) &lt;span&gt;// sqrt(gamma) used many times&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 这里把前面算的平方根的值设置一个默认值，因为如果为0，除0会报异常，所以设置为1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; colMagsCorrected = colMags.map(x =&amp;gt; &lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;1.0&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; x)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 把抽样概率数组 和 平方根数组进行广播&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; sc = rows.context&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; pBV = sc.broadcast(colMagsCorrected.map(c =&amp;gt; sg / c))&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; qBV = sc.broadcast(colMagsCorrected.map(c =&amp;gt; math.min(sg, c)))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 遍历每一行，计算每个向量该维的乘积，形成三元组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; sims = rows.mapPartitionsWithIndex { (indx, iter) =&amp;gt;&lt;br/&gt;      &lt;span&gt;val&lt;/span&gt; p = pBV.value&lt;br/&gt;      &lt;span&gt;val&lt;/span&gt; q = qBV.value&lt;br/&gt;      &lt;span&gt;// 获得随机值&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;val&lt;/span&gt; rand = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;XORShiftRandom&lt;/span&gt;(indx)&lt;br/&gt;      &lt;span&gt;val&lt;/span&gt; scaled = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;Double&lt;/span&gt;](p.size)&lt;br/&gt;      iter.flatMap { row =&amp;gt;&lt;br/&gt;        row &lt;span&gt;match&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;case&lt;/span&gt; &lt;span&gt;SparseVector&lt;/span&gt;(size, indices, values) =&amp;gt;&lt;br/&gt;            &lt;span&gt;// 如果是稀疏向量，遍历向量的每一维，除以平方根&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;val&lt;/span&gt; nnz = indices.size&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (k &amp;lt; nnz) {&lt;br/&gt;              scaled(k) = values(k) / q(indices(k))&lt;br/&gt;              k += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 遍历向量数组，计算每一个数值与其他数值的乘机。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 比如向量(1, 2, 0 ,1)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 得到的结果为 (0,1,value)(0,3,value)(2,3,value)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;Iterator&lt;/span&gt;.tabulate (nnz) { k =&amp;gt;&lt;br/&gt;              &lt;span&gt;val&lt;/span&gt; buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ListBuffer&lt;/span&gt;[((&lt;span&gt;Int&lt;/span&gt;, &lt;span&gt;Int&lt;/span&gt;), &lt;span&gt;Double&lt;/span&gt;)]()&lt;br/&gt;              &lt;span&gt;val&lt;/span&gt; i = indices(k)&lt;br/&gt;              &lt;span&gt;val&lt;/span&gt; iVal = scaled(k)&lt;br/&gt;              &lt;span&gt;// 判断当前列是否符合采样范围，如果小于采样值，就忽略&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; (iVal != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; rand.nextDouble() &amp;lt; p(i)) {&lt;br/&gt;                &lt;span&gt;var&lt;/span&gt; l = k + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (l &amp;lt; nnz) {&lt;br/&gt;                  &lt;span&gt;val&lt;/span&gt; j = indices(l)&lt;br/&gt;                  &lt;span&gt;val&lt;/span&gt; jVal = scaled(l)&lt;br/&gt;                  &lt;span&gt;if&lt;/span&gt; (jVal != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; rand.nextDouble() &amp;lt; p(j)) {&lt;br/&gt;                    &lt;span&gt;// 计算每一维与其他维的值&lt;/span&gt;&lt;br/&gt;                    buf += (((i, j), iVal * jVal))&lt;br/&gt;                  }&lt;br/&gt;                  l += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;              }&lt;br/&gt;              buf&lt;br/&gt;            }.flatten&lt;br/&gt;          &lt;span&gt;case&lt;/span&gt; &lt;span&gt;DenseVector&lt;/span&gt;(values) =&amp;gt;&lt;br/&gt;            &lt;span&gt;// 跟稀疏同理&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;val&lt;/span&gt; n = values.size&lt;br/&gt;            &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (i &amp;lt; n) {&lt;br/&gt;              scaled(i) = values(i) / q(i)&lt;br/&gt;              i += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;Iterator&lt;/span&gt;.tabulate (n) { i =&amp;gt;&lt;br/&gt;              &lt;span&gt;val&lt;/span&gt; buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ListBuffer&lt;/span&gt;[((&lt;span&gt;Int&lt;/span&gt;, &lt;span&gt;Int&lt;/span&gt;), &lt;span&gt;Double&lt;/span&gt;)]()&lt;br/&gt;              &lt;span&gt;val&lt;/span&gt; iVal = scaled(i)&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; (iVal != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; rand.nextDouble() &amp;lt; p(i)) {&lt;br/&gt;                &lt;span&gt;var&lt;/span&gt; j = i + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (j &amp;lt; n) {&lt;br/&gt;                  &lt;span&gt;val&lt;/span&gt; jVal = scaled(j)&lt;br/&gt;                  &lt;span&gt;if&lt;/span&gt; (jVal != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; rand.nextDouble() &amp;lt; p(j)) {&lt;br/&gt;                    buf += (((i, j), iVal * jVal))&lt;br/&gt;                  }&lt;br/&gt;                  j += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;              }&lt;br/&gt;              buf&lt;br/&gt;            }.flatten&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    &lt;span&gt;// 最后再执行一个reduceBykey，累加所有的值，就是i和j的相似度&lt;/span&gt;&lt;br/&gt;    }.reduceByKey(_ + _).map { &lt;span&gt;case&lt;/span&gt; ((i, j), sim) =&amp;gt;&lt;br/&gt;      &lt;span&gt;MatrixEntry&lt;/span&gt;(i.toLong, j.toLong, sim)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CoordinateMatrix&lt;/span&gt;(sims, numCols(), numCols())&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样把所有向量的平方和广播后，每一行都可以在不同的节点并行处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结来说，Spark提供的这个计算相似度的方法有两点优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过拆解公式，使得每一行独立计算，加快速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供采样方案，以采样方式抽样固定的特征维度计算相似度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过杰卡德目前并不能使用这种方法来计算，因为杰卡德中间有一项需要对向量求dot，这种方式就不适合了；如果杰卡德想要快速计算，可以去参考LSH局部敏感哈希算法，这里就不详细说明了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.Spark实现Item相似度计算&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用的数据集是MovieLens，计算Item的相似度，为用户推荐部分没有实现，不过也比较简单，感兴趣的用户可以自己试着实现一下看看。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 加载数据 (userid, itemid, score) =&amp;gt; (string, long, double)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; dataPath = &lt;span&gt;&quot;data/ml-100k/ua.base&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; dataTemp: &lt;span&gt;RDD&lt;/span&gt;[(&lt;span&gt;String&lt;/span&gt;, (&lt;span&gt;Long&lt;/span&gt;, &lt;span&gt;Double&lt;/span&gt;))] = spark.sparkContext.textFile(dataPath).map(_.split(&lt;span&gt;&quot;\t&quot;&lt;/span&gt;)).map(l =&amp;gt; (l(&lt;span&gt;0&lt;/span&gt;), (l(&lt;span&gt;1&lt;/span&gt;).toLong, l(&lt;span&gt;2&lt;/span&gt;).toDouble)))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 理论为上userid 可能为 设备id等字符串，所以进行编码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; userIndex: &lt;span&gt;RDD&lt;/span&gt;[(&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Long&lt;/span&gt;)] = dataTemp.map(_._1).distinct().zipWithIndex()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// (userid index, itemid, score)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; data:&lt;span&gt;RDD&lt;/span&gt;[(&lt;span&gt;Long&lt;/span&gt;, &lt;span&gt;Long&lt;/span&gt;, &lt;span&gt;Double&lt;/span&gt;)] = dataTemp.leftOuterJoin(userIndex).filter(_._2._2.nonEmpty)&lt;br/&gt;    .map(l =&amp;gt; (l._2._2.get, l._2._1._1, l._2._1._2))&lt;br/&gt;    .persist(&lt;span&gt;StorageLevel&lt;/span&gt;.&lt;span&gt;MEMORY_AND_DISK&lt;/span&gt;)&lt;br/&gt;println(&lt;span&gt;s&quot;使用的数据条数为：&lt;span&gt;${data.count()}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;data.take(&lt;span&gt;3&lt;/span&gt;).foreach(l =&amp;gt; println(l))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; matrix = data.map(_ &lt;span&gt;match&lt;/span&gt; { &lt;span&gt;case&lt;/span&gt; (uuid, spuid, rate) =&amp;gt; &lt;span&gt;MatrixEntry&lt;/span&gt;(uuid, spuid, rate) })&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// new CoordinateMatrix(matrix) 除了传入一个rdd之外&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 还有另外两个参数，rows 和 cols，如果不传的话默认是i，j中的最大值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; topicSims: &lt;span&gt;CoordinateMatrix&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;CoordinateMatrix&lt;/span&gt;(matrix)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// toRowMatrix() 调用的是 toIndexedRowMatrix().toRowMatrix()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; itemSim: &lt;span&gt;CoordinateMatrix&lt;/span&gt; = topicSims.toRowMatrix().columnSimilarities()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; itemSimRDD = itemSim.entries.union(itemSim.entries.map(m =&amp;gt; &lt;span&gt;MatrixEntry&lt;/span&gt;(m.j, m.i, m.value)))&lt;br/&gt;&lt;br/&gt;println(&lt;span&gt;&quot;生成计算结果 ...&quot;&lt;/span&gt;)&lt;br/&gt;itemSimRDD.map(f =&amp;gt; (f.i.toLong, f.j.toLong, f.value)).take(&lt;span&gt;10&lt;/span&gt;).foreach(l =&amp;gt; println(l))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Over！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd2508dbd06110abd730f8820c6363f4</guid>
<title>[推荐] Golang 内存管理分析</title>
<link>https://toutiao.io/k/5za3e5u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1. 目录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 由一个问题展开&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 名字说明&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4. 内存怎么采样？&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;4.1 编译期间逃逸分析&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.2 采样的简单实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.3 内存采样的时机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.4 内存采样的入口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.5 内存采样的信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4.6 golang的类型反射&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;5. 内存分配&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;5.1 C语言你分配和释放内存怎么做？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.2 内存分配设计考虑的几个问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5.3 golang的内存分配&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;6. 内存回收&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;6.1 golang协程抢占执行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.2 STW是怎么回事？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.3 垃圾回收要求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.4 golang版本迭代历史&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.5 GC触发条件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.6 三色定义&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.7 GC流程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.8 写屏障&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.9 内存可见性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6.10 注意问题&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 目录&lt;strong/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 由一个问题展开&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang从语言级别，就提供了完整的采样和分析的机制。大家经常使用 pprof 分析内存占用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5359477124183006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DIlBNOZ88iaCnvgTgGLTF9HbeHX7WCJS22BYiajN5aXVWj6qzGLuf2EXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不清楚怎么实现？不清楚怎么看指标？不清楚 flat，cum的区别？我们就从这个问题展开。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 名字说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存分析的时候，有四个输入选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;alloc_objects : 历史总分配的累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_space ：历史总分配累计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inuse_objects：当前正在使用的对象数&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;堆上分配出来，业务正在使用的，也包括业务没有使用但是还没有垃圾回收掉的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;inuse_space：当前正在使用的内存&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个输出选项：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat：平坦分配，非累加&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum：累加&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面说的对象是什么概念？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经常使用内存分析，这个内存分析是否是精确的？性能消耗大不大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为啥显示的是堆栈？不是说分配的对象吗？为啥不直接显示分配的对象结构名？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 内存怎么采样？&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 编译期间逃逸分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明下，golang pprof是分析从堆上分配的内存。golang的内存在堆上，还是在栈上？这个不是我们决定的，就算你调用new这个关键字，也不一定是在堆上分配。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.29850746268656714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwtPSLRiaQhRoe92zpicanF5zAKlECXHeME4ZKqAwfOHSZicz1zJu5cfvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;402&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21794871794871795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DwB356SekRQGzKxIMD16Kropp3P1q4TH9picsL6VPF3UwSM1NY3yn7eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逃逸分析是golang的一个非常重要的一个点。&lt;/span&gt;&lt;span&gt;对于内存分配，垃圾回收的设计都有非常重要的影响。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 采样的简单实现&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采样的实现非常简单。简单描述流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用一个公共变量用来记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配内存的时候，加alloc size，加alloc对象数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;释放内存的时候，加free size，加free对象数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;累计分配：就是alloc
当前在用 inuse：就是 &lt;code&gt;alloc-free&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8091603053435115&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjOF71fW6Fln0WUH6ulvHYPkYGomUPHPOUicXY7dutDSQn8opHbVfTdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 内存采样的时机&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;采样的时机说3个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分配堆上内存的时候，累计分配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回收器释放堆上内存的时候，累计释放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每512KB打点采样&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是注意一点：并不是每一次分配内存都会被采样。也就是说这里其实是有个权衡的。现在是每满512KB才会采样一次。这里的考虑是性能和采样效果的权衡。因为采样是要耗费性能的，是要取堆栈的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;怎么理解？举个例子&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想情况下（不考虑其他任何影响）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4197247706422018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dv7xia7VVEaaxR0V7ZASiagO7tuibSQTI8TwD3JeXqdFUQOXITx6qbr9ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有人会想，这样岂不是会漏掉了很多内存？统计还能用来排查问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是性能和效果的一个考虑，一般来讲，我们是用pprof分析内存占用的时候，在整个golang程序跑起来后，时时刻刻都在分配释放内存，每累计分配512KB，打点一次。虽然会漏掉一些内存分配释放，但是对每个结构都是公平的。如果有一个内存泄露分配行为，那么累计下来一定会被抓住的，并且是非常容易被抓住。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4 内存采样的入口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存采样的入口，这个非常简单理解。肯定是一个在分配内存的函数位置，一个是释放内存的位置。这里要特意提下上下文环境。因为golang是垃圾回收类型的语言，内存分配是完全交由golang自己管理，自己不能管理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个入口函数：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个是配套使用的采样打点函数。而且一定是配套的。简单说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mProf_Malloc 是由业务程序行为（赋值器）触发的，分配内存嘛。比如你new了一个对象，这个对象在堆上，那么会调用 &lt;code&gt;mallocgc&lt;/code&gt; 分配内存，如果到了采样点，那么会调用 &lt;code&gt;mProf_Malloc&lt;/code&gt; 采样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mProf_Free 是回收器在确定并且将要回收内存的时候调用的。是垃圾回收过程的一环。并且还要注意一点，只有打过点的（mProf_Malloc计数过的对象，会有一个特殊处理），才会配套使用mProf_Free。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不是说，任意给一个内存地址给你。你都知道这个是业务类型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5 内存采样的信息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里问你的是，golang采样是采样啥？类型信息？这里也说过一点，内存这里和类型系统是没啥关系的。这里采样的是分配栈，也就是分配路径。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.5.1 flat，cum 分别是怎么来的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个例子：&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9725490196078431&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfG9con5dbDHuPsyiaUFqnA9qEMNoNfPWuus2C0e6DEtq2KcibB9nKUmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以先猜下，我们看alloc_space。这个内存会是怎么累计到的。实际统计如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3450087565674256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiapKxudCtticZGcDvZy4vFrYO4RB8yeQSak92CgqdiaSOf9gvacMcicqbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和大家猜的一样吗？这些是怎么看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先说几个结论：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;flat统计到的，就是这个函数实际分配的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cum是累计的，包含自己分配的，也包含路过的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cum和flat不相同的时候，代表这个函数除了自己分配内存，自己内部调用的别的函数也在分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重点提示：这个要理解这个，首先要知道，内存采样的是什么，内存采样的是分配栈。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解释说明&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图中140M我们当150M看哈，这里采样少了第一次，细节原因可以看代码，这里提一下，不做阐述。）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;main函数里，A函数调用了5次，B函数 5次，C函数5次。其中B会调用A，C会调用B。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用一次A会分配10M内存，调用一次B会分配20M，调用一次C会分配30M。总累计分配内存是300M&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A函数实际调用次数是 15次；这个和flat的值是一致的：150M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;(A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B -&amp;gt; A) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;B函数函数实际调用10次；这个和flat的值也是一致的：100M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;B * 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;(C -&amp;gt; B) * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;C函数5次：这个和flat的值是一致的：50M&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;C * 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;main函数300M，也是一致的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图示&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8029925187032418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DfIOOpsV7U94sIWrGM8vhXBQMq9SgljYRHPwx5PKZicaqMDEahawGeqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住一句话：采样是记录分配堆栈，而不是类型信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.6 golang的类型反射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考几个问题：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;任意给一个内存地址给你，能知道这个对象类型吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang的反射到底是怎么回事？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说结论：golang里面，内存块是没有携带对象类型信息的，这个跟C是一样的。但是golang又有反射，golang的反射一定要基于interface使用。这个要仔细理解下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为，golang里面interface的结构变量，是会记录type类型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律一：&lt;/strong&gt;反射一定是基于接口的。是从接口到反射类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反射定律二：&lt;/strong&gt;反射一定是基于接口的。是从反射类型到接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是那句话，golang的反射一定是依赖接口类型的，一定是经过接口倒腾过的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44385026737967914&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DR1Tyicnbtesda7qV9SViavDJ0siaWEe1AtzTb5a3tRWnJqdlvzwQTAmAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;374&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当前接口这个类型对应了两个内部结构：&lt;code&gt;struct iface&lt;/code&gt;，&lt;code&gt;struct eface&lt;/code&gt;，这两个结构都是会存储type类型。以后的一切都是基于这个类型的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 内存分配&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 C语言你分配和释放内存怎么做？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考一个问题，在C语言里，我们分配内存：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配内存的时候，传入大小，拿到一个指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ptr = malloc(1024);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放内存的时候，直接传入ptr，没有任何其他参数：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;free (ptr);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放的时候，怎么确定释放哪些位置？如果要你自己实现，有很多简单的思路，说一个最简单的：分配的时候，不止分配1024字节，还分配了其他的信息，带head了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3878048780487804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpWk8icmdLTf4ddR3pOjLzymKAEC6icv2V9NtG32IAicz0ic9qUH9K8Z1BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种分配方式有什么问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开销大，在通用的内存分配器中，很多场景下，有可能meta信息比自身还要大。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 内存分配设计考虑的几个问题&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;局部性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外部碎片率&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 golang的内存分配&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang大方向的考虑就是基于局部性和碎片率来考虑的。使用的是和tcmalloc一致的设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 整体设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，内存块是不带类型信息的。像我们在C语言里面，有时候实现的简单的内存池，在不考虑一些开销的时候，会把业务类型放到meta信息里，为的是排查问题方便。golang内存管理作为一个通用模块，不会这么搞。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1.1 地址空间设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，你查golang的资料，会看到这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16575449569976544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Deia6DHht4QwS4kE9VUW6yHlvY6Iwl2bnYf4iaK6p35KdicwL6ejnnmQmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这张图有几个信息比较重要&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么spans区域是512M，bitmap区是16G，arena是512G？先不要纠结值，我们先说这个比例关系：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spans区域，一个指针大小（8Byte）对应arena的一个page（8KB），倍数是1024&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap区域，一个字节（8bit）对应arena的32Bytes，倍数是32倍&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;我们给用户分配的内存就是arena区域的内存，spans区，bitmap区均为其他用途的元数据信息。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;bitmap这个实现我们这次不谈，不同通过这个你得知道一点：并不是所有的内存空间都会扫描一把，是有挑选判断的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spans区域是一般用来根据一个内存地址查询mspan结构的。调用函数：spanOf。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap是用来辅助垃圾回收用的区域。有这个bitmap信息可以提高回收效率和精度。注意一点，这个不是标识object是否分配的位图，标识是否分配object的问题是&lt;code&gt;mspan.allocBits&lt;/code&gt;结构。这个可以理解为提高垃圾回收效率的实现。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意几个点：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;很多文章都提到golang内存512GB这个事情。512GB说的是内存虚拟地址空间的限制，是最大能力，是最大的规划利用。golang之前最大可以使用的内存地址空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang1.11 之后已经没有512GB的限制了。基本上和系统的虚拟地址空间一致&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个比例还是一样的，1：1024，1：32&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;就算golang1.11之前，也不是说golang的程序上来就向系统申请这么大块虚拟地址。也是每64M的申请，管理对象单元是heapArea结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;三个区域看着连续结在一起，但是其实不是连续的地址。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实际的实现中都是以64M（heapArena）的小单位进行的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 抽象对象概念&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4629981024667932&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4D6IqsF5vpIumCKMxwOhDB4A4dQeakqdwOZRt95gicXbqVY09K56bYiaJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;物理偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;heapArena：堆上物理空间管理的一个小单元，64M一个。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;page：物理内存最小单位，8KB一个。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑偏向概念&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;span：span为内存分配的一个管理单元。span内按照固定大小size划分，相同的size划分为同一类。一个span管理一个连续的page。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;object：内存分配的最小单元。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;管理结构层次概念&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache：每个M上的，管理内存用的。我们都知道GMP架构，每个M都有自己的内存cache管理，这样是为了局部性。只是一个cache管理。mcentral：mheap结构所有，也只是一个cache管理，但是是为所有人服务的。mheap：是真正负责分配和释放物理内存的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 局部性的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思路很简单，就是设计成局部性的一个层次设计。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.1 mcache&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcache由于只归属自己的M，span一旦在这个结构管理下，其他人是不可见，不会去操作的。只有这个m会操作。所以自然就不需要加锁。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.2 mcentral&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mcentral是所有人可见的。所以操作自然要互斥，这个的作用也是一个cache的统一管理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3.3 mheap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是负责真实内存分配和释放的的一个结构。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 针对碎片率的设计&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang的内存设计目标：碎片率平均12.5%左右。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7231726283048211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DRE53brYCleJl6622uSwAsh9QFwu9GBhezQMxT19GDEibhB4OibnrKQNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tail wast实际是浪费的外部碎片&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。一个page 8KB，8字节刚好对齐。外部碎片为0.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;max waste说的是最大的内部碎片率&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;怎么算的？每一个放进该span的对象大小都是最小值的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比如说，第一种size，8字节。最小的对象是1字节，浪费7字节，最大碎片率为 1-1/8 = 87.5%&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么的出来的这些值？经验值吧，可能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 内存回收&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 golang协程抢占执行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，golang没有真正的抢占。golang调度单位为协程，所谓抢占，也就是强行剥夺执行权。但是有一点，golang本质上是非抢占的，不像操作系统那样，有时钟中断和时间片的概念。golang虽然里面是有一个抢占的概念，但是注意了，这个抢占是建议性质的抢占，也就是说，如果有协程不听话，那是没有办法的，实现抢占的效果是要对方协程自己配合的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话：系统想让某个goroutine自己放弃执行权，会给这个协程设置一个魔数，协程在切调度，或者其他时机检查到了的时候，会感知到这一个行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当前的抢占实现是：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;给这个协程设置一个的魔数(stackguard)。每个函数的入口会比较当前栈寄存器值和stackguard值来决定是否触发morestack函数。（这是一个抢占调度点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协程调用函数的时候，会检查是否需要栈扩容。如果被设置了抢占标示，那么就会首先调用到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用newstack，在newstack里面判断是否是特殊值，这种特殊值，目的不在于扩容，而在于让出调度。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在golang里面，只要有函数调用，就会有感知抢占的时机。stw就是基于这个实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考一个问题：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一个猥琐的函数：非常耗时，一直在做cpu操作，并且完全没有函数调用。这种情况下，golang是没有一点办法的。那么这种情况会影响到整个程序的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们平时写函数，一定要短小精悍，功能拆分合理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 STW是怎么回事？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;STW：stop the world，也就是说暂停说由协程的调度和执行。stw是怎么实现？stw的基础就是上面提到的抢占实现。stw调用的目的是为了让整个程序（赋值器停止），那么就需要剥夺每一个协程的执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;stw在垃圾回收的几个关键操作里是需要的，比如开启垃圾回收，需要stw，做好准备工作。如果stw的时候，出现了猥琐的函数，那么会导致整个系统的能力降低。因为大家都在等你一个人。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 垃圾回收要求&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正确性：绝对不能回收正在使用的的内存对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存活性：一轮回收过程一定是有边界，可结束的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 golang版本迭代历史&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;go 1.3 以前，使用是标记-清扫的方式，整个过程需要stw&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.3 版本分离了标记和清扫操作，标记过程stw，清扫过程并发执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.5 版本在标记过程中，使用三色标记法。回收过程分为四个阶段，其中，标记和清扫都并发执行的，但标记阶段的前后需要stw一定时间来做gc的准备工作和栈的re-scan。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go 1.8 版本引入了混合写屏障机制，避免了对栈的re-scan，极大的减少了stw的时间。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 GC触发条件&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;gcTriggerHeap 当分配的内存达到一定值就触发GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerTime 当一定时间没有执行过GC就触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gcTriggerCycle 要求启动新一轮的GC，一启动则跳过，手动触发GC的runtime.GC( )会使用这个条件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6 三色定义&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.1 强三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象不允许指向白色对象。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.6.2 弱三色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑色对象可以指向白色对象，但是前提是，该白色对象一定是处于灰色保护链中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.7 GC流程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里不详细阐述了。贴一张go1.8之前的图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DzW1eHrJBFC877UblYFvicerpibx33hDrxmbKq41EQEwSmaYlmGAJOiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当下GC大概分为四个阶段：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GC准备阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标记结束阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清理阶段&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8 写屏障&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果标记和回收不用和应用程序并发，在标记和回收整个过程直接stw，那么就简单了。golang为了提供低时延，就必须让赋值器和回收器并发起来。但是在并发的过程中，赋值器和回收器对于引用树的理解就会出现不一致，这里就一定要配合写屏障技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写屏障技术，是动态捕捉写操作，维持回收正确性的技术。写屏障就是一段 hook 代码，编译期间生成，运行期间跟进情况会调用到 hook 的代码段，也就是写屏障的代码；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面系统整体的讨论下写屏障的技术。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.1 插入写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Dijkstra &#x27;78）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 无脑保护插入的新值&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是另外一个通用的屏障技术。这个维护的是强三色不变式来保证正确性，保证黑色对象一定不能指向白色对象。golang使用的是这个屏障，插入屏障。按照道理，是几乎完全不需要stw的。但是golang有一个处理，由于栈上面使用屏障会导致处理非常复杂，并且开销会非常大。所以当前golang只针对堆上的写操作做了屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就会带来一个问题：所以当一轮扫描完了之后，在标记结束的阶段，还需要重新扫描一遍goroutine栈，并且栈引用到的所有对象也要扫描。因为goroutine有可能直接指向了白色对象。在扫描goroutine栈过程中，需要stw。这个也是go1.8以前的一个非常大的延迟来源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆上路径赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上对象赋值的时候，插入写屏障，保护强三色不变式&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36728395061728397&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DF11J33eLfia9xy4ayicqjFhKiaUlolbJiaeSBEggF7OkOHa0HvHUyHehGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除的时候，没啥问题&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36699239956568946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DHmRyWF8d4hV8kyIj0nc9lwcNiawRWBOVuBhPwYvXKTbr1hhwQFHyueg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈上对象赋值：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step3：栈上对象赋值的时候，没有写屏障。白色对象直接被黑色对象引用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3575240128068303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DUfO37E2nVSWzicziaqGdTkrxencx5GPpEDUjBwg5UGGLZO1Mc1q4s7Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step4：删除灰色保护路径。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.393018018018018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DpgtnqHS2v5Hq1qG9RAI8CicMpJicZz4EluZJJA6EiaibOfGj3LnauQQO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以才需要在mark terminato阶段，重新扫描栈。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.2 删除写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Yuasa &#x27;90）&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer ( slot, ptr ):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 删除之前，保护原先白色或者灰色指向的数据块&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if ( isGery ( slot )  || isWhite ( slot ) )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是通用的一种写屏障技术。golang并没有实现，而是实现了插入写屏障。原因就在于：这个在垃圾回收之前，必须做一个快照扫描，这个就会对用户时延有比较严重的影响。下面详述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主要流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在标记之前，需要打一个引用关系的快照。所以，这个对于栈内存很大的时候，影响越大。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要完整的快照，只需要在扫描堆对象之前，确保所有的栈对象是黑色的。引用都是灰色的，这样就保证了一个前提：所有可达的对象都处于灰色保护状态中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对栈快照扫描需要stw，去扫描栈对象。这个时候，是需要暂停所有的用户程序。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;扫描堆对象的时候，可以和应用程序并发的。此后根一直保持黑色（黑色赋值器），不用再扫描栈。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象被删除的时候，删除写屏障会捕捉到。置灰。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面的伪代码显示有条件，其实第一版的时候是没有条件的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里加上条件是为了回收精度：当上游之前是白色或者灰色才需要把这个置灰色。如果是黑？那么一定是处于灰色保护状态，因为这个是前提（理解这个非常重要）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到灰色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表演示&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始扫描快照后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37760702524698136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLicOrYWuDIic3rNQPtJNmbCx5iaevmMaKcic3DUeuW0iapotAibnGhUx2kWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1: 赋值。这里赋值是允许的，虽然是破坏了强三色不变式。但是还是符合弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.324&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DAVAO12ru4MZXSHGTcNgNxFOJuSf4EbrS36FKict4EUW6fKDoqicd6ZcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除。这里就拦截了，必须置灰色。保证弱三色不变式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3452502553626149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DGHKQZBgNYAQtHye4aA4F385MLcBPqrylWt0SQr03fEzF38hatbAgJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;979&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;回收精度：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障的精度比插入写屏障的精度更低。删除的即使是最后一个指针，也会保留到下一轮，属于一个浮动垃圾。这个比插入屏障精度还低。因为，对于插入屏障所保留的对象，回收器至少可以确定曾在其中执行了某些回收相关的操作（获取或写入对象的引用），但删除屏障所保留的对象却不一定被赋值器操作过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么需要打快照？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除写屏障，又叫快照屏障增量技术（或者说，一定要配合这个来做）。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，是需要stw，针对扫描整个栈根打做一遍扫描。相当于一个快照。这个过程扫描之后，就能保证当前（时刻）所有可达的对象都处于灰色保护状态，满足弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，赋值器和回收器就可以并发。但是并发有可能会破坏导致弱三色不变式。这个时候，就需要删除写屏障来时刻保护白色对象。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang为啥没有用这个？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个是精度问题，这个精度要比插入写屏障低；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考虑goroutine可能非常多，不适合上来就stw，扫描所有的内存栈。这个适合小内存的场景。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;思考一个问题：这个和混合写屏障有没有区别？还是有区别的，这里是要锁整个栈，混合写屏障是并发的，每次只需要锁单个栈。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.3 混合写屏障&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障是结合插入屏障和删除屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;伪代码：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer (slot, ptr) :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 保护原来的（被删除的）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade ( *slot )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if current stack is grey:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 如果对象为灰色，则还需要保护新指向的对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade ( ptr )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（开始的时候，stw扫描栈，得到黑色对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang实际情况：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码如上。但是这里提出来一点，golang根本不是和伪代码说的这样。没有做条件判断，所以现在的回收精度很低。这个算是一个TodoList。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0122591943957968&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DVkeCnpYkTS4rfhJmYmicZyYMbNKtGj55dWLSzwWU2LcNiaLO0clJRsJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：使用了混合屏障，还是针对堆上的，栈上对象写入还是没有barrier。golang之前只使用插入屏障，关键在于栈对象没有，导致栈上黑对象可能指向白对象。所以要rescan。因为如果不rescan，而且又破坏了弱三色不变式（没有处于灰色保护链中），那么就丢数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障，就是结合删除屏障，保护这一个前提，代价就是进一步降低回收精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图表示例：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合屏障就是要解决：&lt;strong&gt;栈指向白色对象，stw重新扫描栈的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：赋值白对象到黑对象引用，这个不会阻止这个，也不会有写屏障。就是一个正常的赋值。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个时候黑色指向了白色对象。破坏了强三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是这个白色对象还处于灰色状态保护下。符合弱三色不变式。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35441527446300713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DiaujllHfur23qsTtVYRv3WHS75iaic25pzYkVf6Y3RC0dCdz7eqIcyANg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1676&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：删除指针的时候，意图破坏弱三色不变式的时候，写屏障就会把这个对象置灰色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36830102622576966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DjkltfZP8Er69jfV4hLtmMUwCtPusQvgfqCvyZzar1xzvezSxm3icfXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题一：如果有个还会想？由于栈上没有写屏障，这个删除的对象式根指向的呢？如果存在以下场景?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step1：堆上的白色对象引用赋值给黑色栈对象。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3645955451348183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DMmViaDZLmjTrlLcRAv9W2daNtHXMX8ic6rXMH0PGGe5ysALjgD4Kib28g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1706&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;step2：如果删除指针，岂不是连弱三色不变式也破坏了？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36874236874236876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DhOuzeeiacib7etGBg8pQib4xSmycRjsA8UEhHAFWUTF6xiazYyOZbz3yFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个怎么办呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：其实根本就不可能出现这个场景的引用图。第一个图就不会出现。因为虽然没有stw，但是扫描某个g的时候，这个g是暂停的。相当于这个g栈是一个快照状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;混合写屏障的栈，要么全黑，要么全白（单个栈）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个暂停g这个是怎么做到的？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;扫描的时候，会设置一个 _Gscan 状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;casgstatus的时候，保证循环等待这个状态完成。之前是直接吃cpu的，后面做了一个优化，加了一个yield，5us的间隔。&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;关于这段代码的改动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DOvKRyxEOkc0JLVLU9v2sp4bJyXcia4nkxbJmB8H1taXYdSZ0ibYhmFwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题二：如果是多个栈呢，那么就不是原子的快照了。比如下图？那么就可能导致这种情况。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8549528301886793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DLQ3JtedhgaOYWEnicYmxlvFQ4k79eXIJVl1z4icMicGN5icx2YcN28aGPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说A和前面的黑色对象不属于同一个g栈。那么是否可能会导致这种场景出现？分析下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个场景是有这么一个白色对象，先只被G2栈根引用到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前G1已经被扫描完，G2还没有扫描。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把这个白色对象赋值给G1栈的黑色对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个时候把G2对白色对象的引用删掉，这样岂不是会出现黑色白色对象，且为唯一指针？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：这里的关键在于第三步。G1的栈对象接受赋值，这个并不是凭空来的。那么一定是G1自己找来的，可达的对象。这个是一个前提。所以，如果能接受这样的赋值，那么这个白色对象一定是处于G1栈的灰色保护下，因为G1一定是可访问这个对象的。否则，根本就不能完成这个赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;混合写屏障的场景，白色对象处于灰色保护下，但是只由堆上的灰色对象保护。注意理解这点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;屏障生成示例：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4738562091503268&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4Dcziamq5dlDp6dHsPIkOjDJ0Dh0kSGsQl5QCOmSdu1D4tB2icgZfqUicIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;写堆上内容，才会在编译期间生成写屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈上的写，不会有写屏障。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runtime.gcWriteBarrier :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5614457831325301&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DqC3Km4voNU8PgnVaDYvicLfrKgGzpiavSBrp9HNZSPMw7icAic9DRsq5ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算出wbBuf的next位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;record ptr&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ptr指针放到wbBuf队列中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;把 &lt;code&gt;*(slot)&lt;/code&gt; 存到wbBuf队列中 ( 置灰色，flush了就是灰色 )&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shade( *slot )&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列没有满&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;那么就赋值写（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）; 则返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;如果队列满了，那么跳到flush&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;wbBufFlush就是把wbBufFlush里的元属flush到灰色队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用完了 runtime.wbBufFlush 处理之后，返回赋值ret（&lt;code&gt;*(slot) = ptr&lt;/code&gt;）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看起来，就不存在 判断stack是否为灰色的条件？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.8.4 其他屏障&lt;span/&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer(slot, ptr):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(*slot)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(ptr)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这种无条件的屏障更加容易理解，直接把目标和源都置灰色保护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;heap上没有黑色到白色的指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一有可能出现黑色到白色的引用 只可能出现在 被扫描了的stack&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦 stack 被扫描过了，只有一种办法能得到白色对象指针（white pointer）：通过transfer一个可达（reachable）对象&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;删除屏障和混合写屏障，保护了&lt;code&gt;shade(*slot)&lt;/code&gt;这个指针，就保护了一条路径：这个来路一定是灰色的，下游的白色都会收到保护。并且，我们知道，栈上得到的白色指针一定是可达的，那么一定是有堆上灰色对象保护的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;任何一个白色对象（被黑色栈对象指向的）一定是被堆上灰色对象保护可达的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种屏障会导致比较多的屏障，两倍。所以针对这个考虑权衡，会加一个stack条件判断，就是我们看到的混合屏障的样子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.9 内存可见性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提一下golang的内存可见性。在c里面，如果是在多线程环境，并发操作一些变量，需要考虑一些可见性的问题。比如赋值一个变量，这个线程还有可能在寄存器里没有刷下去，或者编译器帮你优化到寄存器中，不去内存读。所以有一个volatile关键字，强制去内存读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang是否有这个内存可见性的问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话，golang里面，只要你保证顺序性，那么内存一致性就没有问题。具体可以搜索happen-before的机制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10 注意问题&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.1 千万不要尝试绕过golang的类型系统&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千万不要尝试绕过golang的类型系统。golang官方在提到uintptr类型的时候，都说不要产生uintptr的临时变量，因为很有可能会导致gc的错误回收（这个做过一个简单的验证，1.13本的uintptr类型是不作为指针标记的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个极端的例子，如果你new了一个对象，然后把这个对象的地址保存在8个不连续的byte类型里，那就等着coredump吧。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.10.2 在golang里按照c的思路实现一个内存池很容易踩到巨坑。&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在你分配一个大内存出来（1G的[ ]byte类型空间）。这是一个大内存块。并且golang没有任何标识这个地方标识指针。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 分配一个大内存数组（1GB），数组元素是byte。那么自然每个元素都是不含指针的。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;begin := make([]byte, 1024*1024*1024)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.14094650205761317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChMH72wGNKyybnZHVcgYBy4DTv0cf8PLNFgtWxhvpiaEY2voibYpX6iaA4r9ibwNibL5A0qtygnhjqO5oGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么扫描是不会扫描这个内部的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存池分配器接口：&lt;code&gt;func (ac *Allocator) Alloc (size int) unsafe.Pointer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来分配对象，使用可能会导致莫名其妙的内存错误。假设用来分配对象T：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;golang&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type T struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    s *S&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t := (*T) (ac.Alloc(sizeT))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;t.s = &amp;amp;S{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T对象是从一个大数组里划出来的，垃圾回收其实并不知道T这个对象。不过只要1G内存池本身不被回收，T对象还是安全的。但是T里面的S，是golang走类型系统分配出来的，就会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设发生垃圾回收了，GC会认为这个内存空间是一个Byte数组，而不会扫描，那么t.s指向的对象认为未被任何对象引用到，它会被清理掉。最后t.s就成了一个悬挂指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;golang里面实现内存分配器，适用处理两种情况：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种是用于分配对象里面不包含其他引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种，包含的引用对象也在这个分配器里&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，没必要自己搞通用内存池。一旦绕过了golang的类型系统，就会出现坑。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>