<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d72e318487d132076cd450672afbf2b</guid>
<title>2022春节贺岁档电影开分，水门桥不理想，四海崩了！用Python一探究竟</title>
<link>https://toutiao.io/k/877cd6d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管受到疫情影响，部分地区被迫关闭了电影院，但从大年初一中国影史第二单日总票房的数据来看，2022 年春节期间大家的观影热情还是十分高涨的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大年初一上映当天，从票房数据来看，《长津湖之水门桥》一马当先，《四海》《这个杀手不太冷静》《奇迹·笨小孩》你追我赶，动画片《熊出没》表现强势，《狙击手》令人遗憾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.902687673772011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ozNacoHjicGBv5GWSAUWzUcDsPcwLNdFhJf9YOU3VTBib67xh8fYb9qHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，几部真人电影豆瓣已经开分了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32421875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2opOvlOiabnvTV7V4pFT65gBINUefyz5co2fLwp7mtMs8eDtqosJHTHrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们用 Python 爬取这几部豆瓣开分的电影评论，爬取的具体分析过程这里就不说了，不了解的可以参考一下：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247484101&amp;amp;idx=1&amp;amp;sn=2367e5f51ca00e35717d8ab7340c5aad&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;豆瓣影评爬取参考&lt;/a&gt;，主要实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spider&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    url = &lt;span&gt;&#x27;https://accounts.douban.com/j/mobile/login/basic&#x27;&lt;/span&gt;&lt;br/&gt;    headers = {&lt;span&gt;&quot;User-Agent&quot;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&#x27;&lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;# 龙岭迷窟网址，为了动态翻页，start 后加了格式化数字，短评页面有 20 条数据，每页增加 20 条&lt;/span&gt;&lt;br/&gt;    url_comment = &lt;span&gt;&#x27;https://movie.douban.com/subject/35215390/comments?start=%d&amp;amp;limit=20&amp;amp;sort=new_score&amp;amp;status=P&#x27;&lt;/span&gt;&lt;br/&gt;    data = {&lt;br/&gt;        &lt;span&gt;&#x27;ck&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;用户名&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;password&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;密码&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;remember&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;false&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;ticket&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    session = requests.session()&lt;br/&gt;    session.post(url=url, headers=headers, data=data)&lt;br/&gt;    &lt;span&gt;# 初始化 4 个 list 分别存用户名、评星、时间、评论文字&lt;/span&gt;&lt;br/&gt;    users = []&lt;br/&gt;    stars = []&lt;br/&gt;    times = []&lt;br/&gt;    content = []&lt;br/&gt;    &lt;span&gt;# 抓取 500 条，每页 20 条，这也是豆瓣给的上限&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;):&lt;br/&gt;        &lt;span&gt;# 获取 HTML&lt;/span&gt;&lt;br/&gt;        data = session.get(url_comment % i, headers=headers)&lt;br/&gt;        &lt;span&gt;# 状态码 200 表是成功&lt;/span&gt;&lt;br/&gt;        print(&lt;span&gt;&#x27;第&#x27;&lt;/span&gt;, i, &lt;span&gt;&#x27;页&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;状态码：&#x27;&lt;/span&gt;,data.status_code)&lt;br/&gt;        &lt;span&gt;# 暂停 0-1 秒时间，防止IP被封&lt;/span&gt;&lt;br/&gt;        time.sleep(random.random())&lt;br/&gt;        &lt;span&gt;# 解析 HTML&lt;/span&gt;&lt;br/&gt;        selector = etree.HTML(data.text)&lt;br/&gt;        &lt;span&gt;# 用 xpath 获取单页所有评论&lt;/span&gt;&lt;br/&gt;        comments = selector.xpath(&lt;span&gt;&#x27;//div[@class=&quot;comment&quot;]&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 遍历所有评论，获取详细信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; comment &lt;span&gt;in&lt;/span&gt; comments:&lt;br/&gt;            &lt;span&gt;# 获取用户名&lt;/span&gt;&lt;br/&gt;            user = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/a/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取评星&lt;/span&gt;&lt;br/&gt;            star = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[2]/@class&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取时间&lt;/span&gt;&lt;br/&gt;            date_time = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[3]/@title&#x27;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;# 有的时间为空，需要判断下&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; len(date_time) != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                date_time = date_time[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;                date_time = date_time[:&lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                date_time = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 获取评论文字&lt;/span&gt;&lt;br/&gt;            comment_text = comment.xpath(&lt;span&gt;&#x27;.//p/span/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;].strip()&lt;br/&gt;            &lt;span&gt;# 添加所有信息到列表&lt;/span&gt;&lt;br/&gt;            users.append(user)&lt;br/&gt;            stars.append(star)&lt;br/&gt;            times.append(date_time)&lt;br/&gt;            content.append(comment_text)&lt;br/&gt;    &lt;span&gt;# 用字典包装&lt;/span&gt;&lt;br/&gt;    comment_dic = {&lt;span&gt;&#x27;user&#x27;&lt;/span&gt;: users, &lt;span&gt;&#x27;star&#x27;&lt;/span&gt;: stars, &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;: times, &lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;: content}&lt;br/&gt;    &lt;span&gt;# 转换成 DataFrame 格式&lt;/span&gt;&lt;br/&gt;    comment_df = pd.DataFrame(comment_dic)&lt;br/&gt;    &lt;span&gt;# 保存数据&lt;/span&gt;&lt;br/&gt;    comment_df.to_csv(&lt;span&gt;&#x27;data.csv&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了评论数据，我们再通过词云直观的感受一下，主要代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;df = pd.read_csv(&lt;span&gt;&quot;comment.csv&quot;&lt;/span&gt;, index_col = &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;cts_list = df[&lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;].values.tolist()&lt;br/&gt;cts_str =&lt;span&gt;&quot;&quot;&lt;/span&gt;.join([str(i).replace(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;).replace(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; cts_list])&lt;br/&gt;stop_words = []&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; open(&lt;span&gt;&#x27;stop_words.txt&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;r&#x27;&lt;/span&gt;, encoding=&lt;span&gt;&#x27;utf-8&#x27;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; f:&lt;br/&gt;    lines = f.readlines()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines:&lt;br/&gt;        stop_words.append(line.strip())&lt;br/&gt;&lt;span&gt;# jieba 分词&lt;/span&gt;&lt;br/&gt;word_list = jieba.cut(cts_str)&lt;br/&gt;words = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; word_list:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; word &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; stop_words:&lt;br/&gt;        words.append(word)&lt;br/&gt;cts_str = &lt;span&gt;&#x27;，&#x27;&lt;/span&gt;.join(words)&lt;br/&gt;print(cts_str)&lt;br/&gt;stylecloud.gen_stylecloud(text=cts_str, max_words=&lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;                          collocations=&lt;span&gt;False&lt;/span&gt;,&lt;br/&gt;                          font_path=&lt;span&gt;&quot;SIMLI.TTF&quot;&lt;/span&gt;,&lt;br/&gt;                          icon_name=&lt;span&gt;&quot;fas fa-arrow-circle-right&quot;&lt;/span&gt;,&lt;br/&gt;                          size=&lt;span&gt;800&lt;/span&gt;,&lt;br/&gt;                          output_name=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;Image(filename=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看《四海》，《四海》的口碑为什么没有纵横四海？看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oakEHR4kNg4GhTmaNibeNj1myqrop4wor1HgjWHAQMylrjWhRxFCpFaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看《这个杀手不太冷静》，作为一部喜剧片，豆瓣这个评分还算可以，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oJhxrv81ibiapiaGNd9vw8Z7LHJZNow1BRoJb56TotK16Pw38G9OqrRHDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《长津湖之水门桥》，目前评分是低于第一部的，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oicHZecIeGxqlTd7KYaOylx4297QdeLJonpTpdufHO6EablaZGZ1rMeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《奇迹·笨小孩》，评分和票房都算是中规中矩，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oc2zJS8V2YoDfCUaP3pkBibFSEkgkOLUcRz8OeMN9oKLBpNtN3mTDY6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《狙击手》，国师父女指导，票房不佳，评分暂列第一，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ok6LupiaY4Svw5VY3zET2Q2w8J3UJ4cUOnstKLrmCiczicTYd5tzGI3RpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码已经打包整理好了，有需要的小伙伴可以在公众号&lt;strong&gt;Python数据分析之美&lt;/strong&gt;后台回复&lt;strong&gt;m2022&lt;/strong&gt;直接获取~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a2ecfd101c9a8b157a7eded7768cf07</guid>
<title>腾讯课堂 H5 直播间点赞动效实现</title>
<link>https://toutiao.io/k/s9wmei7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金签约作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;职业规划&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;可视化低代码&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;strong&gt;趣谈前端&lt;/strong&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;进群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入前端交流群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以前在看微信视频号直播的时候，经常点击右下角的点赞按钮。看着它的数字慢慢从一位数变成五位数，还是挺有氛围感的。特别是长按的时候，有个手机震动的反馈，很带感。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.14375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnZAVNKXV6pohRgZHxYe68hicnejt0jqiaJQ4Dr9FLdJFJicb199s9RcOrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;320&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然之前很好奇这些飘动的点赞动效是怎么实现的，但没有特别去钻研。直到前阵子投入腾讯课堂 H5 直播间的需求，需要自己去实现一个这样的效果时，才开始摸索。&lt;/p&gt;&lt;p&gt;先看看最后的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnNYSbDhHmnWxASR45B7zGmFbnRjsiaolyCEXj9trb2XI35UzMNlibbZpg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;256&quot;/&gt;&lt;/p&gt;&lt;p&gt;相比视频号的点赞动效，轨迹复杂了很多。可以看到课堂直播间的这一段点赞动效，大概分为这么三个阶段：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从无到有，在上升过程中&lt;strong&gt;放大&lt;/strong&gt;成正常大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上升过程中&lt;strong&gt;左右摇曳&lt;/strong&gt;，且&lt;strong&gt;摇曳的幅度随机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;左右摇曳上升的过程中，&lt;strong&gt;渐隐并缩小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;在动手之前，我先想到了使用 &lt;strong&gt;CSS animation&lt;/strong&gt; 去实现这种运动轨迹。在完成之后，又用 &lt;strong&gt;Canvas&lt;/strong&gt; 重构了一版，优化了性能。&lt;/p&gt;&lt;p&gt;接下来我们分别来看看这两种实现方式。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2. CSS 实现点赞动效&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;2.1 轨迹分析&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于点赞动画是在一个二维平面上的，我们可以将它的运动轨迹拆分为 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 上的两段。&lt;/p&gt;&lt;p&gt;在 &lt;strong&gt;y 轴&lt;/strong&gt; 上非常简单，我们的点赞图标会做一段&lt;span&gt;垂直上升的&lt;/span&gt;匀速运动，从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而 &lt;strong&gt;x 轴&lt;/strong&gt; 上是左右摇曳的，用数学的角度说，是一段简谐运动。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5864485981308412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn2ZYgnv2KkzoW2WoNHFD5PSDsaAiabyfxA6qK8MwRfyWWL1U0Ab8M0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/p&gt;&lt;p&gt;但用 css 实现的时候，其实不用这么精细。为了简化计算，我们可以用几个关键帧来串联这段运动轨迹，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    最左&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    最右&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.2 轨迹设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以设计一段相同的上升轨迹，以及几段不同的左右摇曳轨迹。&lt;/p&gt;&lt;p&gt;上升轨迹很简单，&lt;span&gt;同时&lt;/span&gt;我们还可以加上透明度（opacity）、大小（transform）的变化，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_y {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;5%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1.5&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;80%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;var&lt;/span&gt;(--cntHeight);&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.8&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，--cntHeight 指的是容器的高度。也就是说，我们通过让 margin-bottom 不断增大，来控制点赞图标从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而对于横向运动的轨迹，为了增加运动轨迹的多样性，我们&lt;span&gt;可&lt;/span&gt;&lt;span&gt;以设计多段&lt;/span&gt;左右摇曳的轨迹，比如说一段 “中间 -&amp;gt; 最左 -&amp;gt; 中间 -&amp;gt; 最右” 的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_1 {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    // 中间&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    // 最左&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    // 最右&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里同样使用 margin 来控制图标的左右移动。类似的，我们还可以设计几段别的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 任意轨迹&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_2 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  33% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;// 随机位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;6px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 简谐反向&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_3 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  25% {&lt;br/&gt;    &lt;span&gt;// 最右&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  75% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们把 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 的轨迹（@keyframes）结合起来，并设置一个随机的动画时间，比如说：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;3&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$j&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;.bl_&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;}_#{&lt;span&gt;$j&lt;/span&gt;} {&lt;br/&gt;      &lt;span&gt;animation&lt;/span&gt;: bubble_y calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards,&lt;br/&gt;        bubble_swing_#{&lt;span&gt;$i&lt;/span&gt;} calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里生成了 3 * 2 = 6 种不同的轨迹。针对这类重复的选择器，用 SCSS 中的循环语法，可以少写很多代码。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.3 随机选择图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们每次点赞会出现不同的图标，于是这里设计了一系列选择器给不同的图标，让它们呈现不同的图片。首先我们要准备一张雪碧图，保持所有图标的大小一致，然后同样使用 SCSS 的循环语法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;0&lt;/span&gt; through &lt;span&gt;7&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;.b&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;} {&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: url(&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;) calc(#{&lt;span&gt;$i&lt;/span&gt;} * -&lt;span&gt;24px&lt;/span&gt;) &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像上面生成了 8 个选择器，我们在程序执行时就可以随机给图标赋予一个选择器。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.4 生成一个点赞图标&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;CSS 的部分差不多了，我们现在来看 JS 是怎么执行的。我们需要有一个容器 div，让它来装载要生成的点赞图标。以及一个按钮来绑定点击事件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const cacheRef = useRef&amp;lt;LikeCache&amp;gt;({&lt;br/&gt;    bubbleCnt: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    likeIcon: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    bubbleIndex: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    timer: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    cacheRef.current.bubbleCnt = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-bubble-cnt&#x27;&lt;/span&gt;);&lt;br/&gt;    cacheRef.current.likeIcon = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-icon&#x27;&lt;/span&gt;);&lt;br/&gt;}, []);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在点击事件中，生成一个新的 div 元素，并为它设置 className。接着将它 append 到容器下，最后在一段时间后销毁这个点赞图标元素。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 添加 bubble&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; addBubble = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { bubbleCnt } = cacheRef.current;&lt;br/&gt;&lt;br/&gt;  cacheRef.current.bubbleIndex %= maxBubble;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; d = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 图片类 b0 - b7&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 随机动画类 bl_1_1 - bl_3_2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; swing = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;3&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; speed = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  d.className = &lt;span&gt;`like-bubble b&lt;span&gt;${cacheRef.current.bubbleIndex}&lt;/span&gt; bl_&lt;span&gt;${swing}&lt;/span&gt;_&lt;span&gt;${speed}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  bubbleCnt?.appendChild(d);&lt;br/&gt;  cacheRef.current.bubbleIndex++;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 动画结束后销毁元素&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    bubbleCnt?.removeChild(d);&lt;br/&gt;  }, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，我们就实现得差不多了。不过，我们还可以给点击的图标加点动画，让它有一个被按压后弹起的效果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { timer, likeIcon } = cacheRef.current;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!likeIcon) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (timer) {&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 删除并重新添加类，需要延迟添加&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.add(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  }, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;  cacheRef.current.timer = &lt;span&gt;window&lt;/span&gt;.setTimeout(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer!);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }, &lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  addBubble();&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.5 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最后来看看效果吧！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKMM9EDicGnPXbFbLpMNpr4JMGcT53f2hbKZjW68KbtSACvXxibu3gI3g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;3. Canvas 实现点赞动效&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;我们都知道 Canvas 的绘制更流畅一些，能够带来更好的体验。但苦于编码比较复杂，也有一定的学习成本，实现起来要比 CSS 复杂不少。&lt;/p&gt;&lt;p&gt;接下来我们看看基于 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 的点赞动效实现。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.1 画布创建&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先我们读取一个 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 元素的 id，并通过 getContext 获取它的上下文。除此之外，还传入了一个 canvasScale，指的是画布放大的比例，这个在之后会用到：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;constructor&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;canvasId: string, canvasScale: number&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; canvas = &lt;span&gt;document&lt;/span&gt;.getElementById(canvasId) &lt;span&gt;&lt;strong&gt;as&lt;/strong&gt;&lt;/span&gt; HTMLCanvasElement;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context = canvas.getContext(&lt;span&gt;&#x27;2d&#x27;&lt;/span&gt;)!;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.width = canvas.width;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.height = canvas.height;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.canvasScale = canvasScale;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.img = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loadImages();&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.2 预加载图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 constructor 这里，我们还通过 loadImages 这个函数，预加载了雪碧图：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;/span&gt; likeSprites &lt;span&gt;&lt;strong&gt;from&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 预加载图片&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;loadImages = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; p = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve: (image: HTMLImageElement) =&amp;gt; &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; img = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt; Image();&lt;br/&gt;    img.onerror = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.onload = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.src = likeSprites;&lt;br/&gt;  });&lt;br/&gt;  p.then(&lt;span&gt;(&lt;span&gt;img&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (img &amp;amp;&amp;amp; img.width &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.img = img;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// error(&#x27;[live-connect]预加载喜欢动效图片失败&#x27;);&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.3 轨迹拆解&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;同样的，我们需要从 Canvas 的视角来拆解点赞图标的运动轨迹。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;y 轴&lt;/strong&gt; 的运动和 CSS 一样，我们知道起始位置和终止位置就可以得出。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;x 轴&lt;/strong&gt; 的运动可以好好推敲。由于 Canvas 是逐帧绘制的，我们可以模拟出一个比较逼真的简谐运动。这里要来讲一讲大家耳熟能详的初中数学了，下面是我们要使用的一条正弦函数的公式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;y = A sin(Bx + C) + D&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;振幅是 &lt;strong&gt;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;周期是 &lt;strong&gt;2π/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;相移是 &lt;strong&gt;−C/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;垂直移位是 &lt;strong&gt;D&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;套入点赞动效：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的振幅 A。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的周期，即 B 是随机的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 C = 0，即相移为 0。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 D = 0，即不需要垂直移位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;y = A sinBx。&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.4 横竖位移计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;确定位移轨迹之后，我们先定义一些常量，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/** 图片显示宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片原始宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; SOURCE_IMAGE_WIDTH = &lt;span&gt;144&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片数量 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMG_NUM = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 放大阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; ENLARGE_STAGE = &lt;span&gt;0.1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 收缩渐隐阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; FADE_OUT_STAGE = &lt;span&gt;0.8&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先我们可以设计 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 两个方向上的位移计算函数，函数参数 progress 是 0 到 1 之间的数值，表示一个过程量（0 -&amp;gt; 1）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 起始位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; basicX = &lt;span&gt;this&lt;/span&gt;.width / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦频率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; frequency = random(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦振幅&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; amplitude = random(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;) * (random(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取横向位移（x轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateX = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大期间，不进行摇摆位移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX + amplitude * &lt;span&gt;Math&lt;/span&gt;.sin(frequency * (progress - ENLARGE_STAGE));&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取竖向位移（y轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateY = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt; + (&lt;span&gt;this&lt;/span&gt;.height - IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt;) * (&lt;span&gt;1&lt;/span&gt; - progress);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.5 大小和透明度计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;要绘制的图标大小怎么控制呢？在 Canvas 中，其实就是计算一个 scale，表示放缩的比例。&lt;/p&gt;&lt;p&gt;我们根据放大/收缩阶段的过程常量和 progress 变量来调节它的大小。起始阶段先线性放大至 1，最后阶段再线性缩小至 0。&lt;/p&gt;&lt;p&gt;透明度同理，在消失之前都是返回 1，其余时刻线性缩小。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取放缩比例&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getScale = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; r = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大&lt;/span&gt;&lt;br/&gt;    r = progress / ENLARGE_STAGE;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;// 缩小&lt;/span&gt;&lt;br/&gt;    r = (&lt;span&gt;1&lt;/span&gt; - progress) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; r;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取透明度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getAlpha = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; - (progress - FADE_OUT_STAGE) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.6 Canvas 绘制&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;绘制时，我们先挑选一张图片。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 按顺序读取图片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { curImgIndex } = &lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 更新顺序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex = ++&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex % IMG_NUM;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.1 画布元素清晰度&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;接下来需要用到我们之前提到的 canvasScale 了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; newWidth = IMAGE_WIDTH * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么这里要乘以一个 canvasScale 呢？因为 Canvas 是&lt;strong&gt;位图模式&lt;/strong&gt;的，它会根据设备的 &lt;strong&gt;dpi&lt;/strong&gt; 来渲染图片。&lt;/p&gt;&lt;p&gt;首先先介绍一下高分屏的概念：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;高分屏：在同样大小的屏幕面积上显示更多的像素点，也就是更多的可视信息。常见的就是 SXGA（1400 * 1050），UXGA（1600 * 1200）。1024 * 768 分辨率的屏幕叫普通屏，也就是 XGA 的屏幕，这个分辨率以上的屏幕叫高分屏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在高分屏上，每平方英寸会有更多的像素。原来在普通屏上绘制的 1 个像素，为了适应高分屏，被迫放大，变成了 4 个像素或者更多。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以想象成，一张清晰度正常的普通图片为了布满整个背景被强行放大 n 倍，所以看起来模糊了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7434869739478958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnbPNrjWlfSpuw7eSdysHUzPsroUKbjBBCf0f6Ik4MAkF99lOAqf1gRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了解决这个问题，就需要我们将绘制的图片放大。同时还要控制 Canvas 画布在 CSS 中的宽高。做到绘制内容变大的同时，画布依然呈现原来的大小。这样一来，图片就会因为绘制了更多的内容，而在高分屏上变得清晰且细腻。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.6.2 绘制元素&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;绘制我们用到了 drawImage。在调用它之前，我们需要&lt;span&gt;根据计算出的 translateX 和 translateY，&lt;/span&gt;&lt;span&gt;调&lt;/span&gt;&lt;span&gt;整绘制的起&lt;/span&gt;&lt;span&gt;点&lt;/span&gt;。并且调整放缩比例和透明度，即 &lt;code&gt;context.scale()&lt;/code&gt; 和 &lt;code&gt;context.globalAlpha&lt;/code&gt;。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 动画过程 0 -&amp;gt; 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt;= &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  context.save();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; scale = getScale(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateX = getTranslateX(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateY = getTranslateY(progress);&lt;br/&gt;  context.translate(translateX, translateY);&lt;br/&gt;  context.scale(scale, scale);&lt;br/&gt;  context.globalAlpha = getAlpha(progress);&lt;br/&gt;  context.drawImage(&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.img!,&lt;br/&gt;    SOURCE_IMAGE_WIDTH * curImgIndex,&lt;br/&gt;    &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    newWidth,&lt;br/&gt;    newWidth,&lt;br/&gt;  );&lt;br/&gt;  context.restore();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.3 创建绘制实例&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们用一个 start 函数来生成点赞动画，每当调用它时，都会创建一个 render 方法，并塞入一个 renderList。renderList 中存放的就是当前所有点赞图标的绘制任务。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;start = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; render = &lt;span&gt;this&lt;/span&gt;.createRender();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; duration = random(&lt;span&gt;2100&lt;/span&gt;, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!render) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.renderList.push({&lt;br/&gt;    render,&lt;br/&gt;    duration,&lt;br/&gt;    &lt;span&gt;timestamp&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;.now(),&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.scanning) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.4 实时绘制&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;知道了需要绘制哪些对象之后，就需要通过下面的 scan 方法，让 Canvas 在每一帧都去绘制内容。&lt;/p&gt;&lt;p&gt;每次绘制分为这么几个过程：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清空画布为透明。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从绘制列表中取出一个点赞图标的 render 方法，并调用它。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假如它返回了 true，代表点赞图标已经完整经历了整个动效的过程，需要将它从绘制列表中剔除出去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重复 2、3 过程，直至列表中没有任务需要执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用 scan 方法自身，等待下一帧重新调用 scan 绘制内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;scan = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context.clearRect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.width, &lt;span&gt;this&lt;/span&gt;.height);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; { length } = &lt;span&gt;this&lt;/span&gt;.renderList;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (index &amp;lt; length) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; child = &lt;span&gt;this&lt;/span&gt;.renderList[index];&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!child || !child.render || child.render.call(&lt;span&gt;null&lt;/span&gt;, (&lt;span&gt;Date&lt;/span&gt;.now() - child.timestamp) / child.duration)) {&lt;br/&gt;      &lt;span&gt;// 结束了，删除该动画&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.renderList.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;      length--;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      index++;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.7 调用&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;接下来我们只需要在点击的时候，调用一下 &lt;code&gt;start&lt;/code&gt; 方法即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  cacheRef.current.LikeAni?.start?.();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-wrap&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)}&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;canvas&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{CANVAS_ID}&lt;/span&gt; &lt;span&gt;width&lt;/span&gt;=&lt;span&gt;{CANVAS_WIDTH}&lt;/span&gt; &lt;span&gt;height&lt;/span&gt;=&lt;span&gt;{CANVAS_HEIGHT}&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-bubble-cnt&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-icon-cnt&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)} &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{onClick}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;i&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在直播场景下，还有很多不同的触发方式。除了自己点击，我们还可以接受来自其他用户的反馈（网络请求）来触发&lt;span&gt; &lt;/span&gt;&lt;code&gt;start&lt;/code&gt;&lt;span&gt; 方法&lt;/span&gt;。或者根据在线人数，多次调用 &lt;code&gt;start&lt;/code&gt; 方法来生成一定数量的点赞图标。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.8 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnYP7LBJLR62gxgcnGSICWb4VWTXCy1PFJEvticiaLXO5TWh19eA5M2xZQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;4. 性能比较&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以下内容是在 MacBook Pro 16 的屏幕上测试的。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.1 Frame Rendering Stats&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中，有两个小功能可以来观察我们绘制的性能情况：&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;这两个功能，可以在 chrome devtools 中使用快捷键 Command + Shift + P，呼起命令搜索的 Panel 来搜索到。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们可以看到高亮区域在频繁闪动，以及 GPU 内存的使用比率较高，这是因为 CSS 的实现方式是不断生成新的元素（并在随后销毁），会消耗更多的内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn61PuKHuVcJY64I0ciaw5Yib7aKR0QeczWS6w7Vov2EtcKhruOHEXIuAw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;相反，Canvas 是集中在画布上绘制并输出的，不会反复创建和销毁元素。会比 CSS 的实现更加流畅，性能更好一点。&lt;/p&gt;&lt;p&gt;除了流畅以外，Canvas 还能够放大画布和画布元素，这也是一个非常重要的优势。这意味着 Canvas 能够绘制出更清晰的内容，生成出来的点赞图标更加细腻。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CneXgmLZDgbvcd17KZ2etPibicNN9GTMoSaib6cFxiaHuCRAlrB4tkvuibrLw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.2 Performance&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中切换到 Performance 面板，还可以观察动画绘制过程中，页面的一些性能指标。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;CSS 的实现之所以看起比较卡顿，主要是因为绘制任务太频繁。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1705790297339593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnUB3NiciafG8nmTuKibbRQ4OKZVeJicHbvMxclwKsmicZ6k6jQwumiaFCb9Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;p&gt;具体到每一帧，我们可以观察到 LayoutShift 的警告。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.50431654676259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cnh2hVHf4azOrrBKM4A1mHibNyeGI0x6ad3ze5OtdPuPBZuBQ5ogzfYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了 LS（Layout Shift）。&lt;strong&gt;改变了起始位置的元素被认为是不稳定元素&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Canvas 实现的性能情况看起来就比较正常，即使绘制清晰一些的图片也不在话下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0332409972299168&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKibqyoXGwzYP3IPzDj3bfosticSBNhal4Nr1rrz5HjibvRDqsJ1kHT5iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;5. 相关&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;实现参考：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fantiter%2Fpraise-animation&amp;amp;title=&quot; href=&quot;&quot;&gt;https://github.com/antiter/praise-animation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;更多推荐&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个在看 你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8&quot; data-type=&quot;png&quot; data-w=&quot;50&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ImtD1PjRzRibmwqBpXL6icIKqbwdwwR26NfB89hJ09AJCorfLHxNdGlIIKr02IiajJ3O6t3qzXFXcJZ1lUxUnibTIA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b796d9b52880f42c972215177fad7684</guid>
<title>网易云音乐广告CTR预估模型演进过程</title>
<link>https://toutiao.io/k/ajdmqsp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&amp;quot;shifu_c_008&amp;quot;)&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文先介绍了效果广告的基本原理，然后以云音乐广告系统从浅层模型到深度模型的演进为主线，介绍了广告算法团队在算法优化过程中遇到的问题、思考和解决的过程。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告是云音乐的重要收入来源之一，最近两年云音乐广告平台在深度（机器）学习技术上做了很大的投入，期间也遇到了许多问题，也取得了一些不错的成果。本文将以模型演进为主线，重点介绍遇到的问题、思考和解决问题的过程，希望能为其他同学在类似的算法场景下提供一些参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告系统最典型的机器学习应用场景是广告点击率（CTR）预估，另外在广告主需要考核成本的时候还会用到转化率（CVR）预估，其中也有大量的深度学习实践，考虑到篇幅，本文聚焦在CTR预估，以后再单独介绍CVR的相关实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;云音乐广告系统的特点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告作为互联网的主要商业模式之一，是各大互联网公司的重要业务。云音乐广告平台是国内第一个专注于基于音频流量变现的广告平台，有一些自己的特点，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些基本特点决定了算法模型的选择、优化等基本面，后续会穿插着提到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;广告系统为什么需要CTR预估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 广告主和媒体的博弈问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我前面提到广告点击率（CTR）预估是典型的机器学习应用场景，但为什么需要CTR预估呢，为了解释清楚这个问题，需要先了解效果广告的机制。效果广告要的是直接转化率，这一点跟品牌广告不同，品牌广告主要打品牌知名度，比如汽车广告，房产广告等，广告主不指望用户看完这个广告之后立刻去买一辆车子或者房子，而是先让用户熟悉这个品牌。而效果广告则希望用户看完广告之后立刻去成交，例如淘宝上的商品搜索广告，百度搜索广告等，都以转化为目的。效果广告的主要博弈方是广告主和媒体方，扩展一下也包含了广告平台、用户等参与方，但为了简化问题我们只考虑最主要的部分，双方的利益如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5308464849354376&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmdjGiazJ8nRH7oc0GJEvQE5Gp2ZtxmPaz7nsbOGsxb2c1qCV1raxibEtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告主最关注ROI，希望用最低的成本拿到自己的目标用户，底线是不能长期做亏本生意。媒体方则希望提高点击率（按点击率计费时，点击越多收入越多）、通过竞争提升单次点击价格，关注的是流量变现价值的最大化。这两方的诉求目标是矛盾的，解决办法是引入经济学的拍卖机制，然后用计算机程序来实现自动竞价，把经济学和计算机科学结合起来解决这个博弈问题，下面详细介绍一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. GFP vs GSP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家应该在电视里面看过拍卖的场景，比如拍卖某个古董时，从低价开始喊，然后不断加价，直到没人再加为止，这时候锤子一敲就成交了，这个模式叫做英式拍卖，这种公开叫价的形式叫明拍。还有一种叫暗拍，情况类似于每个竞买人把自己的价格写好，等全部交上去后按价格的高低排序，价格最高者得。如果是第一价格模式则按第一价格支付，按第二价格模式则出价最高的人按照第二名的价格支付。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8515901060070671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmAmA1pVhdQgicYIibj2dUftsLYLHYIIjEZ4har8Gq2w3D76c8YCZGNrQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;283&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;GFP（Generalized First Price）广义第一价格模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期的互联网产品，比如Yahoo和MSN采用的是GFP，广告主针对某个关键词出价，价高者得且按自己的出价支付。早期百度的竞价排名也是类似的规则。但这种模式最大的问题是系统收入非常不稳定，竞买人需要频繁修改出价以拿到流量或者希望以更低的价格拿到流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;GSP（Generalized Second Price）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2002年Google在Adwords业务中采用了GSP机制，即出价最高者按照第二名的出价来支付。GSP模式由于看不到其他人的出价，可以鼓励广告主按照自己认为的真实价值来出价，鼓励“讲真话”。并且排序时还引入了质量得分，通常是pCTR，即预估的广告点击率，然后按照Price * pCTR排序，这样可以惩罚广告质量差的广告。用Bid来表示出价，则按eCPM排序的规则为：eCPM = Bid * pCTR * 1000 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于在竞拍的过程中，不可能所有参与竞买的广告都能得到曝光，并且不同的人对于不同的广告点击率也不一样，所以CTR不能使用历史统计值，而且即使有历史统计值也解决不了新广告的问题，因此CTR只能预估，但如何预估呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 经济学+机器学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器学习为CTR预估找到了一个解决方案：利用机器学习的回归技术来预测点击概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以用一个公式来表示，点击概率 p = f(user features, context features, ad features)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样一来，就比较完美地平衡了广告主和媒体方的利益：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精准投放保障广告主的ROI；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拍卖机制保障媒体方流量价值的最大化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在这过程中，CTR预估扮演着非常关键的桥梁作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmkPOsa6w3fAA3wmcImJIPkmAvJ5vKSuicWTNW01jPObH5V76ThNT7JuA/640?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1034&quot; data-cropy1=&quot;57.245674740484425&quot; data-cropy2=&quot;441.86505190311414&quot; data-ratio=&quot;0.3723404255319149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFD4WZWX2suEpzLbicav7RhBNGtkKjib7OvRauYs4pXyhDbXPqAMz8BbWjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;浅层学习CTR预估模型优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业界早期阶段，在2012年以前，几乎主流公司都使用LR模型来预估CTR。LR有很多优点，比如简单、易于并行化、可解释性强。比较适合处理广告场景高维、稀疏的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6869565217391305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmuORuRmM9Y8YmoPfpqNJzIPmVNgiaY1XpwyswVeIibrcmD4E0NCntOQnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（利用sigmoid函数映射点击概率）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云音乐广告系统最初采用的是LR模型，至今也还作为基线在跑着。后来尝试了FM，以及LR+GBDT，FM+GBDT，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmrejoJ6aaRYQhZWj3CVVUIbmkFkk8TiaiajJKhZHYr5xPXiaPs2oCR2RGA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;572&quot; data-cropy1=&quot;37&quot; data-cropy2=&quot;502&quot; data-ratio=&quot;0.8111888111888111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDpO5mibLkbAvdNPjvuRibWkpaJibCzficxQIia1h63CRHyWibibh4Mw7OViaPQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LR模型阶段打下了很多基础，做了很多数据和特征工程的事情，避免Garbage in, garbage out，争取达到效果的上限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 数据采样&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）样本正确选取问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最开始，各个广告位的历史数据是放在一起训练的，最终训练出一个模型。启动画也包含其中，并且数据量占了很大比例，但启动画有一个很大的问题，就是误点率很高，误点数据基本上是随机分布，没办法体现出用户的真实意图，很多数据都是噪声，严重影响模型的准确性。因此需要去除不能真实反应用户意图的场景数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，最初的版本iOS和Android双端数据也是放在一起训练的，但通过一段时间的运行发现，双端的广告主数据几乎完全不一样，基本上可以看做是两个数据集，并且在同样的广告位，其CTR和CVR的表现也有显著差异。所以需要拆分不同的数据分布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，对于训练样本的选择来说，我们把开机画数据拆了出去，同时iOS和Android分端训练，这样一来，模型效果得到了大幅提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AB实验中，iOS端eCPM提升了11.12%，Android端eCPM提升了10.50%，全流量后效果表现一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）样本不平衡问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们的CTR场景，尤其是CVR场景，正负样本比例相差非常大。CTR正负样本比例大约从1:1000至1:100，CVR从曝光到转化则是1:10000，甚至更低。在模型的训练过程中，正样本变成了小概率事件，很容易被模型当作噪声而忽略了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在CTR模型中，把正样本上采样了10倍，效果上Android端AUC提升1.02%，iOS端AUC提升0.75% 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对CVR模型（深度模型）的训练数据，我们对负样本降采样10倍，AUC提升了1.06%，线上效果也表现显著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）其它的样本问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过优化，离线AUC提高了1.4%， eCPM相对基线提高了3.73% 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 特征组合&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们有一个CASE分析工具，可以分析不同权重对结果的影响程度。我们发现模型并没有学出用户侧与广告侧的匹配关系，主要依靠单特征在影响pCTR打分。尽管做了一些人工特征组合，比如广告主+年龄，但由于太稀疏没有学出来。很自然我们想用FM模型来尝试一下自动特征组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）尝试FM&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FM引入了隐向量，为每一个特征学习一个隐权重向量。在做特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。与直接特征组合（用POLY2模型的方式）需要该组合的所有特征同时存在才更新参数不同，对训练数据中没有出现的组合FM也能够学到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1788793103448276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmUf265CiaDCua9CwFXJmqcfWIKibQdE4UxQmvE97WvW0Gibo1KicrFuzorQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例来说：用直接特征组合时，只有当广告主为“潭州教育”且“用户年龄为20岁”时才会更新该组合特征的参数（否则其中一个为0，则相乘后也为0），但这种组合太稀疏，基本上训练不充分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FM由于使用两个特征向量的内积来表示权重，比如广告主（潭州教育）的特征向量为v_i，年龄为20岁的特征向量为v_j，权重w=向量积&amp;lt;v_i,v_j&amp;gt;，只要出现了广告主（潭州教育）或年龄为20岁的样本，都可以共享更新相应的特征向量。解决了稀疏特征组合的问题。FM的不足是只有二阶特征组合，非线性表达能力依然不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;效果：线下AUC提升0.75%，但线上效果不稳定，因此只做了小流量上线，不符合全流量的标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们推断了效果不理想的原因：一是我们的特征中，连续特征很多，将其离散化取决于经验，因此即使做了二阶交叉，解决的可能不是关键问题；第二，云音乐的广告推荐场景属于弱个性化推荐场景。相对来说云音乐的歌曲推荐属于强个性化推荐，淘宝的商品推荐也属于强个性化推荐，不仅拥有足够的样本数据做训练，每个人的偏好也相对更明显。而个人对广告的喜爱与否并不是那么明显（有时候说喜欢广告，不如说不那么讨厌的广告）。在这种场景下，二阶特征组合的记忆力并不算太好，基于这种推断，我们自然开始尝试GBDT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）尝试GBDT&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GBDT的引入带来了如下优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7710144927536232&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmbZGaCY194NJezduD7Q16G93VtMtdnu7LA4unk6D1oOhmcsqQmWPicoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LR+GBDT模型相比基线LR模型，AUC绝对值提升1.03%，相对提升1.71%，效果非常显著。线上CTR和eCPM提升稳定，符合全流量标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之后我们又尝试了FM+GBDT，但效果不如LR+GBDT。浅层学习阶段，最终LR+GBDT胜出，成为了效果最好的模型。我们的推测原因是：弱个性化场景下需要有深度记忆功能。LR处理了稀疏特征记忆能力，GBDT处理好了深度组合特征以及连续特征的记忆能力，这正是我们音频流量广告场景（结合我们的广告主特点）所适合的。我们这个思路会持续到深度学习阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如喜欢听儿童歌曲的用户，年龄可能在25岁以上，并且可能喜欢购买化妆品，可能是年轻的妈妈们。喜欢听英文歌曲的用户，也许是爱好英文歌曲，也许正在锻炼自己的听力，喜欢点击英语培训广告，需要多种特征组合起来才能更精确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;人类行为可预测的认知 – 个人理论总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人类行为有93%是可预测的，这是美国东北大学科学家的一项研究结论。我认为这一基本原则是很多优化工作的指导基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 个体人格相对稳定，才能用历史预测未来&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人类行为可预测是因为人格的相对稳定性，人格包含性格、气质、能力、兴趣、爱好等成分，是由先天的遗传和后天的环境因素共同决定的。招聘面试也是采用了这个原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 人类具有共同的行为模式，可以用群体预测个体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此原理引出了协同过滤算法，即利用某种共同兴趣或共同经历的群体行为来预测个体的行为。比如大多数读过笑傲江湖和神雕侠侣的人，都读过倚天屠龙记，假如有某个人读了笑傲江湖和神雕侠侣，我们可以推断他很大概率会喜欢倚天屠龙记。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做算法上的任何优化，都应该遵循这两个基本原则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;深度模型演进和优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度模型的引入，一方面是由于业界已经有很多公司成功把深度学习应用到了CTR预估，并取得了效果；其实更重要的原因是延续LR+GBDT的优化思路，需要持续做，上面提到了用LR处理稀疏特征记忆，用GBDT处理深度组合特征和连续特征记忆，自然会想到Wide&amp;amp;Deep模型，即使用Wide的记忆能力，以及Deep的泛化能力。我们从Wide&amp;amp;Deep切入深度学习，并且做了很多尝试。如图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVm1gITTTcDCe376bXJicSiaibmgOEMx1gjUk584kEKPrvL0OAFnnHW4ut6A/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;306&quot; data-cropy1=&quot;41&quot; data-cropy2=&quot;784&quot; data-ratio=&quot;2.4248366013071894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDpV2Ek9hT9BvlPbibTibCqCF4toLVk2aEAdwhIJGqlIS7fjsfAGOlLSKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;306&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Wide&amp;amp;Deep、DeepFM、DCN都没有全流量，第一个全流量的深度模型是DCN+Wide，目前（2020年10月）正在跑的是DICN+Wide。下面介绍一下这些模型的特点和问题，以及做的优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. Wide&amp;amp;Deep&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在讲Wide&amp;amp;Deep之前，我先讲一下业界早期尝试将深度学习应用于广告CTR预估的情况。业界早期的时候，使用的是纯DNN模型（MLP），但无论怎么优化都很难超越LR+GBDT，主要原因是广告场景有大量的长尾稀疏数据，DNN采用Embedding的方式训练不出来，后来尝试了很多方法把DNN和LR以及其它浅层模型融合起来，融合之后的效果才超过了LR，比如采用LR训练后的权重参数，或者进一步将FM的隐向量作为Embedding输入等。Wide&amp;amp;Deep就是在这种情况下作为一种融合方案之一，由Google在2016年发布出来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVms5ZGbomY20FTqEicr49Hbu4CicnoPZ9e8u6cOLsKQLKltZnxicvmHrnNw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;522&quot; data-cropy1=&quot;42&quot; data-cropy2=&quot;350&quot; data-ratio=&quot;0.5919540229885057&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDvHKp5ynOxk8zIUHnxE1jFn26RRTS20r8QVTuDDozkXAGTaA0uIgYZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;522&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;W&amp;amp;D通过将浅层模型和深层模型联合训练，融合了浅层模型的记忆能力和深层模型的泛化能力。通过Wide侧较好地解决了长尾数据的拟合，弥补了纯DNN的不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过理论归理论，有没有效果还要看实际场景，我们最开始W&amp;amp;D的效果始终没有赶上LR，后来做了一些特征优化，比如连续特征同时做离散化处理，用全连接代替Wide和Deep融合时直接相加，最后的效果只是与LR模型打平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们根据浅层学习时的经验，认为是Deep侧对特征交叉训练不够，纯DNN模型只是隐性交叉，并且是稀疏的场景，隐性交叉需要足够的样本和足够多的训练时间。因此后续的思路是需要在Deep侧做特征交叉方面的尝试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于是第一个深度模型，也让我们体会到了，并不是所有深度模型的效果都会优于浅层模型，尤其是做过良好特征工程的LR模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. DeepFM&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本来顺着上面的思路应该优化Deep侧，但由于根据以往的经验，DeepFM模型的效果可能还不错，我们还尝试了DeepFM模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.49550898203592814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmiaiapPMlgGQHISttlcfgxiaJtIWStCS5uu259tejwQPTZSZ2ia7JpzokDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化了特征、正则项、模型层数和embedding size等调优，最终效果与基线LR的AUC相差千分位，依然不好，与浅层模型时单独尝试FM的效果表现一致，这坚定了我们往优化Deep侧的方向去尝试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. DCN&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DCN的引入主要是为了解决纯DNN没有特征显式交叉的问题，它在Wide&amp;amp;Deep的基础上，把Wide侧改成了Cross Network，示意如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.978343949044586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVm4DmfiabLhnCNwPLQQKLicoyCoyHy2zia5UhEgzA0QeSUaQ6JIoTic1NInQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该模型的核心是Cross Network，设计用来高效地进行特征交叉，公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.11826086956521739&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmib2TE4CJocfhiaUGAmQiaTcHZJHrickaZIVF1K6nQBMQY1b954xbhr0icFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;xl表示第l层的cross layer输出，wl是参数，bl是偏置，都是列向量。其实是应用了残差网络的思想，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3806646525679758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmLhvgWD6A25VuicpIf1lV1NabvicoV4bU1A5o0r9FALrgJhIbHmQDeg3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样模型就能够高效地学习到高阶的非线性特征组合了。DCN的效果：离线AUC比LR高0.69%，线上eCPM提升幅度稳定达到3%，达到了上线标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们观察到的现象是当特征显性高阶交叉时效果就会更好，与LR采用GBDT组合特征时效果会更好的表现是一致的。应该是挖掘出了音乐场景下深层次的关系。后来我们还在DCN上面引入了Attention机制，也取得了一定的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. DCIN+Wide&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顺着前面的优化思路，DCN已经解决了特征深度交叉，以及泛化的功能，DIN解决了用户短期兴趣问题，这些解决的都是头部数据的问题，这些数据有一定的量来训练，而广告场景的长尾数据问题依然没有解决。因此我们很自然地把Wide侧增加了进去，模型示意图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8576388888888888&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmGfqHZDLh89946DHKibQqM26LHTWiaaLECluIHpxD78IfqSM7t0vZq1YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Wide的加入，使得长尾数据的记忆能力得到了一定的加强，线下AUC和线上效果都有一定的提升，虽然提升量不算太大，但为人工特征工程提供了可能。这是我们现在的线上模型（2020年10月）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍一些我们对深度模型做的优化点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 激活函数的优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在优化DeepFM的过程中，最初Deep模型的隐藏层激活函数用的是ReLU，但我们发现Deep侧不起作用，进一步发现隐藏层的很多输出为0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24742268041237114&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmAZuarfAXfoLf0srUcicmVutvIOhWicEDupPkKWsYqc9VZHmtkZXlxicYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;388&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从ReLU函数的定义可以知道，负梯度时该ReLU单元会被置为0，这是它单侧抑制的能力。但由于我们的数据特点，ReLU的这个特点变成了局限，在训练过程中导致大量神经元不可逆死亡，进而使大量参数无法更新，从而训练过程失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来我们把激活函数换成了PReLU，公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23834196891191708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmZHR6U20T2RsBnqlf8x40QrrTSoXzA2fzJURvhLIqZVKzxXnVgwaSNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;386&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当x小于0时，用了一个很小的正数a实现一个斜率为a的线性函数ax，这样既实现了单侧抑制功能，又不至于导致大量神经元不可逆死亡。a可以作为网络中的参数通过训练更新。当a=0时，PReLU退化成ReLU；如果a是一个固定值，则PReLU退化成Leaky ReLU（LReLU）。BP更新a时，采用的是带动量的更新方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.294478527607362&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmd2koSXia6cIkyoiaSO8SyicxyysZ85sDT6gO6cxljOGUhPHhEqoDibrn5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ReLU和PreLU的函数曲线图对比如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4236111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmkKw3KYc7M5jUiaVfFUwAMU0iaAhFwSEvyKrkr3Tk28gpvCZWOYibicAiaibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用PReLU作为激活函数之后，解决了神经元死亡的问题，AUC提升了千分之五。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 递减学习率和Batch size的优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们使用adam优化器，学习率初始值设置为 a，之后每n步降低0.96，AUC提升了千分之二。我们的Batch size设置为10000，比起很多公司的CTR场景设置来说偏大，主要是由于我们很多场景的CTR是千分位，需要考虑每个batch里有一定数据的正样本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8775894538606404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmP0rGNSOzZ0lHib3A44JThfN2qUD34j6s6qjWZLq8kYU3Ik7lvZRiazgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图看到，太高的学习率会导致不收敛或者震荡，太低的学习率则收敛速度太慢，递降的学习率一开始比较大可以让模型快速收敛，后面逐步减少则可以精确收敛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 缺失值处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于我们的数据稀疏，很多属性和特征的覆盖率不高，经常会存在样本中域缺失的情况。我们给缺失的域一个单独的Embedding向量，使缺失值不对该域其他的Embedding向量产生影响。处理流程如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; x1缺失:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  x’= w1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  x’= w2 * x1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;x’作为Embedding向量输入模型。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8. 深度模型时代，特征工程依然重要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度模型时代并非不需要特征工程了，尽量理论上说DNN能够拟合任意函数，但那只是理论上的，前提是有稠密的数据、充足的样本、足够长的训练时间。而现实中上述条件可能一项都不具备，因此在如何让模型更有效率训练这个问题上，需要考虑不同数据的特点，比如图像处理需要用CNN，时序处理用RNN，广告及推荐场景可能用DeepFM，DCN，DIN等，都是在采用更适合的模型来做“特征工程”，找到适合自己数据特征的交叉方式来提升训练的有效性。另外在对长尾数据的处理方面，依然把浅层模型融合进来，把之前有效的人工组合特征工程继续用上。深层浅层学习结合起来提升效果，目前看起来还比较有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;优化建议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在算法改进的过程中遇到了非常多的问题，上面只是列了其中的一部分。我认为最重要的是做事方法，正确的方法可以少走弯路，对此我有三点建议：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抓住本源。采用的数据要能真实反应用户的意图，并且数据一定要正确，这是所有后续工作的基础。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;围绕解决业务问题去思考和创新。别人的方法只能参考，每个业务的特点不同，数据分布肯定也不一样，必须要针对自己的业务和数据特点做优化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;看细节。从细节中去找问题和找改进点，CASE分析很重要，否则容易高来高去不接地气。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易有数为云音乐广告变现业务提供一站式机器学习平台服务，欢迎点击“阅读原文”了解产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101582&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;作者简介&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;322:369&quot;&gt;&lt;span&gt;Neil，网易云音乐营收技术负责人，曾任百度国际移动广告平台技术负责人，十多年互联网行业经验，专注于广告算法和后端系统架构。获北京大学学士学位，马里兰大学硕士学位。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNTUxNTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOV4Bfic2e5zqTMCl0XxmMuVq1XpDOBrbXicVB4KmrEXglsWcnMREoQXfX24sscdvQIR74ic3SiciaLoMFA/0?wx_fmt=png&quot; data-nickname=&quot;网易有数&quot; data-alias=&quot;Youdata_Netease&quot; data-signature=&quot;网易有数是网易数帆旗下大数据技术与服务品牌，以“数据价值”为导向，聚焦于企业 “看数”、“管数”、“用数”等业务场景，提供全链路大数据技术及产品服务，致力于盘活企业数据生产力，加速实现数字化转型。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100003451&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sYBGQlzfEOXECeWKgyIia3c7bom7Ir4rh4qI4XdxuRW4lyHudFyglytmLrOM4yYOWs3XNqqj0XlXTEw8icZ2Eb1Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;317:401&quot;&gt;分享，点赞，在看，安排一下？&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf6476749b90914467a68c15b695a10a</guid>
<title>Tomcat 组成与工作原理总结</title>
<link>https://toutiao.io/k/tdvlczo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5714285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQu3qlibIteeibJp5av7tFicuiaFA8Ofh1rXZOGJQiboaCibAQ5nJXpCfiat2vg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;开源的 Java Web 应用服务器，实现了 Java EE(Java Platform Enterprise Edition)的部 分技术规范，比如 Java Servlet、Java Server Page、JSTL、Java WebSocket。Java EE 是 Sun 公 司为企业级应用推出的标准平台，定义了一系列用于企业级开发的技术规范，除了上述的之外，还有 EJB、Java Mail、JPA、JTA、JMS 等，而这些都依赖具体容器的实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44140625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQ1vGsq8iaNqsM7HGbbOq72q7BiabRDz6eQOSzb2Vjiba5CMWbY3SyBgQxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图对比了 Java EE 容器的实现情况，Tomcat 和 Jetty 都只提供了 Java Web 容器必需的 Servlet 和 JSP 规范，开发者要想实现其他的功能，需要自己依赖其他开源实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Glassfish 是由 sun 公司推出，Java EE 最新规范出来之后，首先会在 Glassfish 上进行实 现，所以是研究 Java EE 最新技术的首选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常见的情况是使用 Tomcat 作为 Java Web 服务器，使用 Spring 提供的开箱即用的强大 的功能，并依赖其他开源库来完成负责的业务功能实现。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能。&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/YunaiV/ruoyi-vue-pro&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Tomcat 组成如下图&lt;/strong&gt; ： 主要有 Container 和 Connector 以及相关组件构成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8586762075134168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQ5lAPalhjYYOsIia3l533Fvvx1ohaWmGkehm7yKNXQv6GibBAduiaRZF6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1118&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Server&lt;/strong&gt; ：指的就是整个 Tomcat 服 务器，包含多组服务，负责管理和 启动各个 Service，同时监听 8005 端口发过来的 shutdown 命令，用 于关闭整个容器 ；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Service&lt;/strong&gt; ：Tomcat 封装的、对外提 供完整的、基于组件的 web 服务， 包含 Connectors、Container 两个 核心组件，以及多个功能组件，各 个 Service 之间是独立的，但是共享 同一 JVM 的资源 ；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Connector&lt;/strong&gt; ：Tomcat 与外部世界的连接器，监听固定端口接收外部请求，传递给 Container，并 将 Container 处理的结果返回给外部；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Container&lt;/strong&gt; ：Catalina，Servlet 容器，内部有多层容器组成，用于管理 Servlet 生命周期，调用 servlet 相关方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Loader&lt;/strong&gt; ：封装了 Java ClassLoader，用于 Container 加载类文件； Realm：Tomcat 中为 web 应用程序提供访问认证和角色管理的机制；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JMX&lt;/strong&gt; ：Java SE 中定义技术规范，是一个为应用程序、设备、系统等植入管理功能的框架，通过 JMX 可以远程监控 Tomcat 的运行状态；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Jasper&lt;/strong&gt; ：Tomcat 的 Jsp 解析引擎，用于将 Jsp 转换成 Java 文件，并编译成 class 文件。 Session：负责管理和创建 session，以及 Session 的持久化(可自定义)，支持 session 的集 群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Pipeline&lt;/strong&gt; ：在容器中充当管道的作用，管道中可以设置各种 valve(阀门)，请求和响应在经由管 道中各个阀门处理，提供了一种灵活可配置的处理请求和响应的机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Naming&lt;/strong&gt; ：命名服务，JNDI， Java 命名和目录接口，是一组在 Java 应用中访问命名和目录服务的 API。命名服务将名称和对象联系起来，使得我们可以用名称访问对象，目录服务也是一种命名 服务，对象不但有名称，还有属性。Tomcat 中可以使用 JNDI 定义数据源、配置信息，用于开发 与部署的分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Container组成&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7966804979253111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQ1HalMZTUMdJTfK3dEibpHcdIsKc1c4EVbWRenAdHicUrCGsEZdza1fiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1205&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Engine：Servlet 的顶层容器，包含一 个或多个 Host 子容器； Host：虚拟主机，负责 web 应用的部 署和 Context 的创建； Context：Web 应用上下文，包含多个 Wrapper，负责 web 配置的解析、管 理所有的 Web 资源； Wrapper：最底层的容器，是对 Servlet 的封装，负责 Servlet 实例的创 建、执行和销毁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;生命周期管理&lt;/strong&gt; Tomcat 为了方便管理组件和容器的生命周期，定义了从创建、启动、到停止、销毁共 12 中状态，tomcat 生命周期管理了内部状态变化的规则控制，组件和容器只需实现相应的生命周期 方法即可完成各生命周期内的操作(initInternal、startInternal、stopInternal、 destroyInternal)；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如执行初始化操作时，会判断当前状态是否 New，如果不是则抛出生命周期异常；是的 话则设置当前状态为 Initializing，并执行 initInternal 方法，由子类实现，方法执行成功则设置当 前状态为 Initialized，执行失败则设置为 Failed 状态；&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.471875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQHQcqM3JbibyJ1B173iafAY7K7JfGCER4Kr3SRXxnILfJGgNxtErw4NZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat 的生命周期管理引入了事件机制，在组件或容器的生命周期状态发生变化时会通 知事件监听器，监听器通过判断事件的类型来进行相应的操作。 事件监听器的添加可以在 server.xml 文件中进行配置;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat 各类容器的配置过程就是通过添加 listener 的方式来进行的，从而达到配置逻辑与 容器的解耦。如 EngineConfig、HostConfig、ContextConfig。 EngineConfig：主要打印启动和停止日志 HostConfig：主要处理部署应用，解析应用 META-INF/context.xml 并创建应用的 Context ContextConfig：主要解析并合并 web.xml，扫描应用的各类 web 资源 (filter、servlet、listener)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.653125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQpAQmJU03ccACsR0pry1AfDyq8iaiaQBXiboyceOMTtXqMFAJF6MZB56Vw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Tomcat 的启动过程&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQ4gT594Q4kcAfSwDmh2QnMgfyyicmjDmHMIiboleZ6icQcSBK8jNcRwLOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1250&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动从 Tomcat 提供的 start.sh 脚本开始，shell 脚本会调用 Bootstrap 的 main 方法，实际 调用了 Catalina 相应的 load、start 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;load 方法会通过 Digester 进行 config/server.xml 的解析，在解析的过程中会根据 xml 中的关系 和配置信息来创建容器，并设置相关的属性。接着 Catalina 会调用 StandardServer 的 init 和 start 方法进行容器的初始化和启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照 xml 的配置关系，server 的子元素是 service，service 的子元素是顶层容器 Engine，每层容器有持有自己的子容器，而这些元素都实现了生命周期管理 的各个方法，因此就很容易的完成整个容器的启动、关闭等生命周期的管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StandardServer 完成 init 和 start 方法调用后，会一直监听来自 8005 端口(可配置)，如果接收 到 shutdown 命令，则会退出循环监听，执行后续的 stop 和 destroy 方法，完成 Tomcat 容器的 关闭。同时也会调用 JVM 的 Runtime.getRuntime()﴿.addShutdownHook 方法，在虚拟机意外退 出的时候来关闭容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有容器都是继承自 ContainerBase，基类中封装了容器中的重复工作，负责启动容器相关的组 件 Loader、Logger、Manager、Cluster、Pipeline，启动子容器(线程池并发启动子容器，通过 线程池 submit 多个线程，调用后返回 Future 对象，线程内部启动子容器，接着调用 Future 对象 的 get 方法来等待执行结果)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Future&amp;lt;Void&amp;gt;&amp;gt; results = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Future&amp;lt;Void&amp;gt;&amp;gt;();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; children.length; i++) {&lt;br/&gt;    results.add(startStopExecutor.submit(&lt;span&gt;new&lt;/span&gt; StartChild(children[i])));&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; fail = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (Future&amp;lt;Void&amp;gt; result ： results) {&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        result.get();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        log.error(sm.getString(&lt;span&gt;&quot;containerBase.threadedStartFailed&quot;&lt;/span&gt;)， e);&lt;br/&gt;        fail = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Web 应用的部署方式&lt;/strong&gt; 注：catalina.home：安装目录;catalina.base：工作目录;默认值 user.dir&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Server.xml 配置 Host 元素，指定 appBase 属性，默认$catalina.base/webapps/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server.xml 配置 Context 元素，指定 docBase，元素，指定 web 应用的路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义配置：在$catalina.base/EngineName/HostName/XXX.xml 配置 Context 元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HostConfig 监听了 StandardHost 容器的事件，在 start 方法中解析上述配置文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;扫描 appbase 路径下的所有文件夹和 war 包，解析各个应用的 META-INF/context.xml，并 创建 StandardContext，并将 Context 加入到 Host 的子容器中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解析$catalina.base/EngineName/HostName/下的所有 Context 配置，找到相应 web 应 用的位置，解析各个应用的 META-INF/context.xml，并创建 StandardContext，并将 Context 加入到 Host 的子容器中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HostConfig 并没有实际解析 Context.xml，而是在 ContextConfig 中进行的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HostConfig 中会定期检查 watched 资源文件(context.xml 配置文件)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ContextConfig 解析 context.xml 顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先解析全局的配置 config/context.xml&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后解析 Host 的默认配置 EngineName/HostName/context.xml.default&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后解析应用的 META-INF/context.xml&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ContextConfig 解析 web.xml 顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先解析全局的配置 config/web.xml&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后解析 Host 的默认配置 EngineName/HostName/web.xml.default 接着解析应用的 MEB-INF/web.xml&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扫描应用 WEB-INF/lib/下的 jar 文件，解析其中的 META-INF/web-fragment.xml 最后合并 xml 封装成 WebXml，并设置 Context&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;扫描 web 应用和 jar 中的注解(Filter、Listener、Servlet)就是上述步骤中进行的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容器的定期执行：backgroundProcess，由 ContainerBase 来实现的，并且只有在顶层容器 中才会开启线程。(backgroundProcessorDelay=10 标志位来控制)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**Servlet 生命周期 **&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8184143222506394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQvKjdN7JLiacVwBY72C6nWo1sAx6a5vh8iakB9sLCTZMr6cooOC8BrWGg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1173&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Servlet 是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请求到达 server 端，server 根据 url 映射到相应的 Servlet&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断 Servlet 实例是否存在，不存在则加载和实例化 Servlet 并调用 init 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server 分别创建 Request 和 Response 对象，调用 Servlet 实例的 service 方法(service 方法 内部会根据 http 请求方法类型调用相应的 doXXX 方法)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;doXXX 方法内为业务逻辑实现，从 Request 对象获取请求参数，处理完毕之后将结果通过 response 对象返回给调用方&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当 Server 不再需要 Servlet 时(一般当 Server 关闭时)，Server 调用 Servlet 的 destroy() 方 法。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;load on startup&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当值为 0 或者大于 0 时，表示容器在应用启动时就加载这个 servlet; 当是一个负数时或者没有指定时，则指示容器在该 servlet 被选择时才加载; 正数的值越小，启动该 servlet 的优先级越高;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;single thread model&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次访问 servlet，新建 servlet 实体对象，但并不能保证线程安全，同时 tomcat 会限制 servlet 的实例数目 最佳实践：不要使用该模型，servlet 中不要有全局变量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**请求处理过程  **&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0777957860615883&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQkabbyXMAbtfVj6EMicfGQKiagDCPz0ZMgbBLbN7TYy3a187pG7QjicGiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;617&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据 server.xml 配置的指定的 connector 以及端口监听 http、或者 ajp 请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求到来时建立连接,解析请求参数,创建 Request 和 Response 对象,调用顶层容器 pipeline 的 invoke 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容器之间层层调用,最终调用业务 servlet 的 service 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Connector 将 response 流中的数据写到 socket 中&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**Pipeline 与 Valve  **&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41802492809204217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQsN1QiaIue058RP5F88JItKRia03dlSoEMmbxlT9fwFA7jQE5w1NiaBH8g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1043&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pipeline 可以理解为现实中的管道,Valve 为管道中的阀门,Request 和 Response 对象在管道中 经过各个阀门的处理和控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个容器的管道中都有一个必不可少的 basic valve,其他的都是可选的,basic valve 在管道中最 后调用,同时负责调用子容器的第一个 valve。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Valve 中主要的三个方法:setNext、getNext、invoke;valve 之间的关系是单向链式结构,本身 invoke 方法中会调用下一个 valve 的 invoke 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各层容器对应的 basic valve 分别是 StandardEngineValve、StandardHostValve、 StandardContextValve、StandardWrapperValve。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba 。&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/YunaiV/onemall&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8455445544554455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQicnD2oT2JwG2vmwUADOpyD3Q8200x4t2ib8LJfBK38wLBRexB99b2egQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;505&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JSP 生命周期&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编译阶段:servlet 容器编译 servlet 源文 件,生成 servlet 类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化阶段:加载与 JSP 对应的 servlet 类, 创建其实例,并调用它的初始化方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行阶段:调用与 JSP 对应的 servlet 实例的 服务方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;销毁阶段:调用与 JSP 对应的 servlet 实例的 销毁方法,然后销毁 servlet 实例&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JSP元素&lt;/strong&gt; 代码片段： &amp;lt;% 代码片段 %&amp;gt; JSP声明： &amp;lt;%! declaration; [ declaration; ]+ ... %&amp;gt; JSP表达式：&amp;lt;%= 表达式 %&amp;gt; JSP注释： &amp;lt;%-- 注释 --%&amp;gt; JSP指令：    &amp;lt;%@ directive attribute=“value” %&amp;gt; JSP行为：    &amp;lt;jsp:action_name attribute=“value” /&amp;gt; HTML元素： html/head/body/div/p/… JSP隐式对象：request、response、out、session、application、config、 pageContext、page、Exception&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**JSP 元素说明 ** 代码片段:包含任意量的 Java 语句、变量、方法或表达式; JSP 声明:一个声明语句可以声明一个或多个变量、方法,供后面的 Java 代码使用; JSP 表达式:输出 Java 表达式的值,String 形式; JSP 注释:为代码作注释以及将某段代码注释掉 JSP 指令:用来设置与整个 JSP 页面相关的属性, &amp;lt;%@ page ... %&amp;gt;定义页面的依赖属性,比如 language、contentType、errorPage、 isErrorPage、import、isThreadSafe、session 等等 &amp;lt;%@ include ... %&amp;gt;包含其他的 JSP 文件、HTML 文件或文本文件,是该 JSP 文件的一部分,会 被同时编译执行 &amp;lt;%@ taglib ... %&amp;gt;引入标签库的定义,可以是自定义标签 JSP 行为:jsp:include、jsp:useBean、jsp:setProperty、jsp:getProperty、jsp:forward&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Jsp 解析过程&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4744744744744745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQHZ29dRp9uHlza6r0d1Xtx4mtufpS2wnNDTnvue6NUceNs1wsPticwLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;666&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;代码片段:在_jspService()方法内直接输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSP 声明: 在 servlet 类中进行输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSP 表达式:在_jspService()方法内直接输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSP 注释:直接忽略,不输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSP 指令:根据不同指令进行区分,include:对引入的文件进行解析;page 相关的属性会做为 JSP 的属性,影响的是解析和请求处理时的行为&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSP 行为:不同的行为有不同的处理方式,jsp:useBean 为例,会从 pageContext 根据 scope 的 类别获取 bean 对象,如果没有会创建 bean,同时存到相应 scope 的 pageContext 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTML:在_jspService()方法内直接输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JSP 隐式对象:在_jspService()方法会进行声明,只能在方法中使用;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3991769547325103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQ2oT3ZHib3dmHyKmh3XZg0hELl3v2BG7VuuVp7cibNUibgzrWeqQrut1bg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;729&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Http:HTTP 是超文本传输协议,是客户端浏览器或其他程序与 Web 服务器之间的应用层通信协 议 AJP:Apache JServ 协议(AJP)是一种二进制协议,专门代理从 Web 服务器到位于后端的应用 程序服务器的入站请求 &lt;strong&gt;阻塞 IO&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5341246290801187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQZvjv6UUFzoy4VNghjTvxeRfLGCU3b6XaRT4qJiaVzXKQyGsMnpe2iaqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;674&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非阻塞 IO&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5786350148367952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQocdTvDq28icCMMYuMkwxicNURSOGyg0qvpcM1f6uZAzFQP4ibg2Am0JAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;674&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;** IO多路复用**&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5578330893118595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQ7XbXwrkPlrFzh9ztiacpYOibiaJ3qVoCR3BZ6ib06Cicw69MgTYJ4sBDaEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;683&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞与非阻塞的区别在于进行读操作和写操作的系统调用时，如果此时内核态没有数据可读或者没有缓冲空间可写时，是否阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IO多路复用的好处在于可同时监听多个socket的可读和可写事件，这样就能使得应用可以同时监听多个socket，释放了应用线程资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Tomcat各类Connector对比&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQArF1miaVZBbK5hpRbgC5ooE5dovxibT7TKkEjwlfMhC7yJiboUsDfnBww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Connector的实现模式有三种，分别是BIO、NIO、APR，可以在server.xml中指定。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JIO：用java.io编写的TCP模块，阻塞IO&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NIO：用java.nio编写的TCP模块，非阻塞IO，（IO多路复用）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;APR：全称Apache Portable Runtime，使用JNI的方式来进行读取文件以及进行网络传输&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Portable Runtime是一个高度可移植的库，它是Apache HTTP Server 2.x的核心。 APR具有许多用途，包括访问高级IO功能（如sendfile，epoll和OpenSSL），操作系统级功能（随机数生成，系统状态等）和本地进程处理（共享内存，NT管道和Unix套接字）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表格中字段含义说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Support Polling：是否支持基于IO多路复用的socket事件轮询&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Polling Size：轮询的最大连接数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Wait for next Request：在等待下一个请求时，处理线程是否释放，BIO是没有释放的，所以在keep-alive=true的情况下处理的并发连接数有限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Read Request Headers：由于request header数据较少，可以由容器提前解析完毕，不需要阻塞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Read Request Body：读取request body的数据是应用业务逻辑的事情，同时Servlet的限制，是需要阻塞读取的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Write Response：跟读取request body的逻辑类似，同样需要阻塞写&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;NIO处理相关类&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8121827411167513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQn0l87GcLGiaqlz93H7xdYia50zvSknGfRx3uiawHkpT8qrlxCybbfiaNuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1182&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Acceptor线程负责接收连接，调用accept方法阻塞接收建立的连接，并对socket进行封装成PollerEvent，指定注册的事件为op_read，并放入到EventQueue队列中，PollerEvent的run方法逻辑的是将Selector注册到socket的指定事件；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Poller线程从EventQueue获取PollerEvent，并执行PollerEvent的run方法，调用Selector的select方法，如果有可读的Socket则创建Http11NioProcessor，放入到线程池中执行；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CoyoteAdapter是Connector到Container的适配器，Http11NioProcessor调用其提供的service方法，内部创建Request和Response对象，并调用最顶层容器的Pipeline中的第一个Valve的invoke方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mapper主要处理http url 到servlet的映射规则的解析，对外提供map方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;NIO Connector主要参数&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5265625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQdz0rCYv8JzeXDYYxLml0BicUaN2koicrgY76xTop1q9Od6OQ2Yce9wicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Comet是一种用于web的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求 在WebSocket出来之前，如果不使用comet，只能通过浏览器端轮询Server来模拟实现服务器端推送。 Comet支持servlet异步处理IO，当连接上数据可读时触发事件，并异步写数据(阻塞)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQABIZZYX8Ruianp8aIl0IbTNDe6kdLbLhialEpQEyLEEpojwA5jFU3HXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat要实现Comet，只需继承HttpServlet同时，实现CometProcessor接口&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Begin：新的请求连接接入调用，可进行与Request和Response相关的对象初始化操作，并保存response对象，用于后续写入数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Read：请求连接有数据可读时调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;End：当数据可用时，如果读取到文件结束或者response被关闭时则被调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Error：在连接上发生异常时调用，数据读取异常、连接断开、处理异常、socket超时&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Note：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Read：在post请求有数据，但在begin事件中没有处理，则会调用read，如果read没有读取数据，在会触发Error回调，关闭socket&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;End：当socket超时，并且response被关闭时也会调用；server被关闭时调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Error：除了socket超时不会关闭socket，其他都会关闭socket&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;End和Error时间触发时应关闭当前comet会话，即调用CometEvent的close方法 Note：在事件触发时要做好线程安全的操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6133333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQ6vyVLibTuNqUDaK6ojTibeSp6zYW1XG66CaibSwYxbbbQsVVvFHtiaQt2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，Servlet 接收到请求之后，request数据解析；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着，调用业务接口的某些方法，以完成业务处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，根据处理的结果提交响应，Servlet 线程结束&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6182634730538922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXOLJ6WcmdH1UBmrQ6eXnoQGKGcgJP4Zp4cQmSvmhladSzoLPgnSqlDPoVfbN5md9kbTA4ibS1JsbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;668&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步处理流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端发送一个请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Servlet容器分配一个线程来处理容器中的一个servlet&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;servlet调用request.startAsync()，保存AsyncContext, 然后返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任何方式存在的容器线程都将退出，但是response仍然保持开放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务线程使用保存的AsyncContext来完成响应（线程池）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到响应&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么web应用中支持异步？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推出异步，主要是针对那些比较耗时的请求：比如一次缓慢的数据库查询，一次外部REST API调用, 或者是其他一些I/O密集型操作。这种耗时的请求会很快的耗光Servlet容器的线程池，继而影响可扩展性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Note：从客户端的角度来看，request仍然像任何其他的HTTP的request-response交互一样，只是耗费了更长的时间而已&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;异步事件监听&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;onStartAsync：Request调用startAsync方法时触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;onComplete：syncContext调用complete方法时触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;onError：处理请求的过程出现异常时触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;onTimeout：socket超时触发&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Note : onError/ onTimeout触发后，会紧接着回调onComplete onComplete 执行后，就不可再操作request和response&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>