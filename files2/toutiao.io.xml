<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d9cdbd1757227d485b5314f963f0b9de</guid>
<title>时间轮在 Kafka 的实践</title>
<link>https://toutiao.io/k/441cqn5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;562&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;562&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzF6ARFqaicYjickTxiaPM701eKEspL7tj7A4xonqVVkpDfA12KVmDDPE8icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot; data-style=&quot;padding: 10px; display: inline-block; width: 558px; border-width: 1px; border-style: solid; border-color: transparent; background-color: rgb(239, 239, 239); border-radius: 0px;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;section data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;p data-darkmode-bgcolor-15906711670635=&quot;rgb(52, 52, 52)&quot; data-darkmode-original-bgcolor-15906711670635=&quot;rgb(239, 239, 239)&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;桔妹导读：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;时间轮是一个应用场景很广的组件，在很多高性能中间件中都有它的身影，如Netty、Quartz、Akka，当然也包括Kafka，本文主要介绍时间轮在kafka的应用和实战，从核心源码和设计的角度对时间轮进行深入的讲解 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从2个面试题说起，第一个问题：&lt;strong&gt;如果一台机器上有10w个定时任务，如何做到高效触发？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体场景是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一个APP实时消息通道系统，对每个用户会维护一个APP到服务器的TCP连接，用来实时收发消息，对这个TCP连接，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; 其中，单机TCP同时在线量约在10w级别，keepalive请求包较分散大概30s一次，吞吐量约在3000qps。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;怎么做？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常用方案使用time定时任务，每秒扫描一次所有连接的集合Map&amp;lt;uid, last_packet_time&amp;gt;，把连接时间（每次有新的请求更新对应连接的连接时间）比当前时间的差值大30s的连接找出来处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一种方案，使用环形队列法：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;382&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6606498194945848&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFyHiaiaWIPMkRLgqmsN5VzQsHuYdCHiadPl2dunDHicSlewT7ma4pWBNJBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三个重要的数据结构：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;30s超时，就创建一个index从0到30的环形队列（本质是个数组）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;环上每一个slot是一个Set&amp;lt;uid&amp;gt;，任务集合&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同时还有一个Map&amp;lt;uid, index&amp;gt;，记录uid落在环上的哪个slot里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样当有某用户uid有请求包到达时：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从Map结构中，查找出这个uid存储在哪一个slot里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从这个slot的Set结构中，删除这个uid&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将uid重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的&lt;/span&gt;&lt;span&gt;上一个&lt;/span&gt;&lt;span&gt;slot，因为这个slot，会被timer在30s之后扫描到&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新Map，这个uid对应slot的index值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;哪些元素会被超时掉呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Current Index每秒种移动一个slot，这个slot对应的Set&amp;lt;uid&amp;gt;中所有uid都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两种方案对比：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案一每次都要轮询所有数据，而方案二使用环形队列只需要轮询这一刻需要过期的数据，如果没有数据过期则没有数据要处理，并且是批量超时，并且由于是环形结构更加节约空间，这很适合高性能场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个问题：&lt;strong&gt;在开发过程中有延迟一定时间的任务要执行，怎么做？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果不重复造轮子的话，我们的选择当然是延迟队列或者Timer。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;延迟队列和在Timer中增 加延时任务采用数组表示的最小堆的数据结构实现，每次放入新元素和移除队首元素时间复杂度为O(nlog(n))。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;时间轮&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方案二所采用的环形队列，就是时间轮的底层数据结构，它能够让需要处理的数据（任务的抽象）集中，在Kafka中存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等。Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.1 时间轮的数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考下图，Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务TimerTask。在Kafka源码中对这个TimeTaskList是用一个名称为buckets的数组表示的，所以后面介绍中可能TimerTaskList也会被称为bucket。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;312&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.54&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFpdDDKO9Iib8RQIRQ3JMaZoqNfC7VDYJZTtUy2UOaXVFtDicNGsC0Btqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;span&gt;图二&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对上图的几个名词简单解释下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;tickMs：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;时间轮由多个时间格组成，每个时间格就是tickMs，它代表当前时间轮的基本时间跨度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;wheelSize：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;代表每一层时间轮的格数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;interval：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当前时间轮的总体时间跨度，interval=tickMs × wheelSize&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;startMs：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;构造当层时间轮时候的当前时间，第一层的时间轮的startMs是TimeUnit.NANOSECONDS.toMillis(nanoseconds()),上层时间轮的startMs为下层时间轮的currentTime。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;currentTime：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;表示时间轮当前所处的时间，currentTime是tickMs的整数倍（通过currentTime=startMs - (startMs % tickMs来保正currentTime一定是tickMs的整数倍），这个运算类比钟表中分钟里65秒分钟指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.2 时间轮中的任务存放&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.3 时间轮的升降级&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;513&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.9129332206255283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFXzdeg3QUgdoJ26RtYQpibFsFK0IXhico9xicPsZDvRnYcicqul57P0tP0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1183&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;图三&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考上图，复用之前的案例，第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;刚才提到的350ms的任务，不会插入到第一层时间轮，会插入到interval=20*20的第二层时间轮中，具体插入到时间轮的哪个bucket呢？先用350/tickMs(20)=virtualId(17)，然后virtualId(17) %wheelSize (20) = 17，所以350会放在第17个bucket。如果此时有一个450ms后执行的任务，那么会放在第三层时间轮中，按照刚才的计算公式，会放在第0个bucket。第0个bucket里会包含&lt;/span&gt;&lt;span&gt;[400,800)ms&lt;/span&gt;&lt;span&gt;的任务。&lt;/span&gt;&lt;span&gt;随着时间流逝，当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到层级时间轮中，那么此时50ms的任务根据公式会放入第二个时间轮的第2个bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，此时距离任务执行还有10ms，同样将10ms的任务提交到层级时间轮，此时会加入到第一层时间轮的第10个bucket，所以再经过10ms后，此任务到期，最终执行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整个时间轮的升级降级操作是不是很类似于我们的时钟？ 第一层时间轮tickMs=1s, wheelSize=60，interval=1min，此为秒钟；第二层tickMs=1min，wheelSize=60，interval=1hour，此为分钟；第三层tickMs=1hour，wheelSize为12，interval为12hours，此为时钟。而钟表的指针就对应程序中的currentTime，这个后面分析代码时候会讲到（对这个的理解也是时间轮理解的重点和难点）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2.4 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;任务添加和驱动时间轮滚动核心流程图&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;322&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;409&quot; data-ratio=&quot;0.5736994219653179&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFeEWic4vjFkWp5Sng55EQSXoSZIIA9yIlKezQgWkiaT7bRuAHrNWq1J6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图四&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;2.5 重点代码介绍&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是往SystenTimer中添加一个任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; def &lt;span class=&quot;code-snippet__title&quot;&gt;addTimerTaskEntry&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;timerTaskEntry: TimerTaskEntry&lt;/span&gt;): Unit&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timingWheel.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timerTaskEntry.cancelled)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      taskExecutor.submit(timerTaskEntry.timerTask)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;timingWheel添加任务，递归添加直到添加该任务进合适的时间轮的bucket中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;def &lt;span class=&quot;code-snippet__title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;timerTaskEntry: TimerTaskEntry&lt;/span&gt;): Boolean&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  val expiration = timerTaskEntry.expirationMs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timerTaskEntry.cancelled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + tickMs) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + interval) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    val virtualId = expiration / tickMs&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    val bucket = buckets((virtualId % wheelSize.toLong).toInt)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    bucket.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket.setExpiration(virtualId * tickMs)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      queue.offer(bucket)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) addOverflowWheel()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    overflowWheel.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本层级时间轮里添加上一层时间轮里的过程，注意的是在下一层时间轮的interval为上一层时间轮的tickMs。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;code-snippet__function&quot;&gt;def &lt;span class=&quot;code-snippet__title&quot;&gt;addOverflowWheel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;synchronized&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      overflowWheel = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TimingWheel(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tickMs = interval,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        wheelSize = wheelSize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        startMs = currentTime,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        taskCounter = taskCounter,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        queue&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;驱动时间轮滚动过程：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意这里会存在一个递归，一直驱动时间轮的指针滚动直到时间不足于驱动上层的时间轮滚动。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;def advanceClock(timeMs: &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt;): &lt;span class=&quot;code-snippet__built_in&quot;&gt;Unit&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeMs &amp;gt;= currentTime + tickMs) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    currentTime = timeMs - (timeMs % tickMs)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (overflowWheel != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) overflowWheel.advanceClock(currentTime)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;驱动源：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;code-snippet__keyword&quot;&gt;val&lt;/span&gt; reinsert = (timerTaskEntry: TimerTaskEntry) =&amp;gt; addTimerTaskEntry(timerTaskEntry)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;def advanceClock(timeoutMs: &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt;): &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    writeLock.lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timingWheel.advanceClock(bucket.getExpiration())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.flush(reinsert)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket = delayQueue.poll()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      writeLock.unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3. &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.0734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBtFvdK9icOj3ibAXa8W3tqZ2lQDEaA5XcCDJ5cVIic2221PzXcw0oo69kvia8ojgPZnEV4jPxZURBln4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;562&quot; data-backh=&quot;41&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;通过以上工作，滴滴Presto逐渐接入公司各大数据平台，并成为了公司首选Ad-Hoc查询引擎及Hive SQL加速引擎，下图可以看到某产品接入后的性能提升：\n&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;但是如果看最近一个月的CPU使用率会发现，平均CPU使用率比较低，且波峰在白天10~18点，晚上基本上没有查询，CPU使用率不到5%。如下图所示：&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;]]&quot;&gt;kafka的延迟队列使用时间轮实现，能够支持大量任务的高效触发，但是在kafka延迟队列实现方案里还是看到了delayQueue的影子，使用delayQueue是对时间轮里面的bucket放入延迟队列，以此来推动时间轮滚动，但是基于将插入和删除操作则放入时间轮中，将这些操作的时间复杂度都降为O(1)，提升效率。Kafka对性能的极致追求让它把最合适的组件放在最适合的位置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;本文作者&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/h3&gt;&lt;h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;106&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;106&quot; data-ratio=&quot;0.18946188340807174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFSfRy6bcPNkSCjLkT4a5KRa0Rh1n8icXoTBmxqDdEibibXiaK5vI6zfCliag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;通过以上工作，滴滴Presto逐渐接入公司各大数据平台，并成为了公司首选Ad-Hoc查询引擎及Hive SQL加速引擎，下图可以看到某产品接入后的性能提升：\n&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;但是如果看最近一个月的CPU使用率会发现，平均CPU使用率比较低，且波峰在白天10~18点，晚上基本上没有查询，CPU使用率不到5%。如下图所示：&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;]]&quot;&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;所以，解决晚上资源浪费问题是我们今后需要解决的难题。&amp;quot;,&amp;quot;0:\&amp;quot;%23333333\&amp;quot;&amp;quot;],[20,&amp;quot;\n同时，为了不与开源社区脱节，我们打算升级PrestoDB 0.215到PrestoSQL 340版本，届时会把我们的Presto on Druid代码开源出来，回馈社区。&amp;quot;]]&quot;&gt;滴滴车险团队架构师，负责车险核心系统的架构和设计，十年互联网研发架构经验，其中五年中间件与基础架构经验，对高并发，高可用以及分布式应用的架构设计有丰富的实战经验，尤其对分布式消息队列，分布式流程编排引擎、分布式数据库中间件有较深入的研究，热爱技术，崇尚开源，是Kafka、RocketMQ、Conductor等多个知名开源项目的源码贡献者。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;团队招聘&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;对于低重要度的特征，最终做了删除，从而降低模型大小。例如我们发现方位角的重要度在实际模型训练中不如角变量。推测方位角本身的不连续性（0 = 2pi）可能对模型训练是一种干扰。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;对于异常值，做了基本的数据清洗，如无效的速度值，无效的方位角；对于不足的GPS序列长度，用0进行填充（但需要额外注意起点属性）等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3. 模型选择、训练与效果&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;DNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：只需要相对简单的算法实现，引入较小的模型库。然而GPS轨迹数据具有典型的时间序列特征，在4万样本下，应用利用DNN模型调参优化后，训练结果准确率最高达到91%。Bad case中存在大量时间不敏感的情形，最典型的情形就是——轨迹由差转优时，判定结果未能及时转变为高质量。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;CNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：这里可以尝试两种实现方式，一种是通过生成bitmap进行识别，然而GPS跨度不确定性较高，方向性不易表达，在实现上具有一定困难。第二种将序列化数据转化为二维数组，C模型能够识别出前后时间戳之间的变化特征，但并不能保留更长的时间的变化特征。最终训练出的准确率在93%左右。另外，CNN模型应用在移动端有一个明显的缺点，即模型尺寸一般较大。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;LSTM（&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;长短期记忆网络&amp;quot;],[20,&amp;quot;）&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：一种特殊的RNN模型，相比前述模型对轨迹质量序列判定有明显优势。在轨迹质量由好转差，或由差转好的识别上具有非常高的灵敏度，使用128个unit能够达到97%的准确率。缺点是LSTM模型训练速度相对较慢，算法库实现相对复杂。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;最终我们选择了使用LSTM模型。使用LSTM的训练结果，准确率大幅提升。在剩余3%的错误样例中，很多轨迹在形态上表现出较高的真实性，但却无法同路网进行匹配。理论上通过引入路网属性能够上带来准确率的进一步提升，然而这种数据的耦合脱离了轨迹质量判定的初衷——服务于偏航引擎专家系统，而非直接用于偏航判定。对此我们将会在最后进行更详细的介绍。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3&amp;quot;],[20,&amp;quot;4. 移动端性能优化&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;模型推算性能对于移动端尤为重要。偏航场景下，GPS更新频繁，选择在必要的时候进行模型推算能够避免不必要的计算开销。通常我们会计算当前GPS点与规划路线的偏离度，只有偏离度大于阈值时才会进行轨迹质量判定。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;基于深度学习的专家系统探索&amp;quot;,&amp;quot;27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;轨迹质量模型作为偏航判定的重要依据，能够以较小的代价移植到移动端。如果不考虑前端性能及数据限制，我们完全可以定义整个偏航判定问题，训练相应的偏航模型。然而偏航场景种类繁多，过于复杂，训练出一套通用的偏航模型需要大量的数据，充足的路网信息，和较大的模型存储，这对于移动端而言不太现实。  &amp;quot;]]&quot;&gt;&lt;span&gt;滴滴车险团队基于滴滴近百万辆车和海量数据，通过线上化、科技化、数据化的手段，达到车险的降赔付、降发生，降保费，为乘客、司机、以及车队、合作伙伴提供方便快捷高效的车险金融服务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-shimo-docs=&quot;[[20,&amp;quot;对于低重要度的特征，最终做了删除，从而降低模型大小。例如我们发现方位角的重要度在实际模型训练中不如角变量。推测方位角本身的不连续性（0 = 2pi）可能对模型训练是一种干扰。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;对于异常值，做了基本的数据清洗，如无效的速度值，无效的方位角；对于不足的GPS序列长度，用0进行填充（但需要额外注意起点属性）等。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;3. 模型选择、训练与效果&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;DNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：只需要相对简单的算法实现，引入较小的模型库。然而GPS轨迹数据具有典型的时间序列特征，在4万样本下，应用利用DNN模型调参优化后，训练结果准确率最高达到91%。Bad case中存在大量时间不敏感的情形，最典型的情形就是——轨迹由差转优时，判定结果未能及时转变为高质量。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;CNN&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：这里可以尝试两种实现方式，一种是通过生成bitmap进行识别，然而GPS跨度不确定性较高，方向性不易表达，在实现上具有一定困难。第二种将序列化数据转化为二维数组，C模型能够识别出前后时间戳之间的变化特征，但并不能保留更长的时间的变化特征。最终训练出的准确率在93%左右。另外，CNN模型应用在移动端有一个明显的缺点，即模型尺寸一般较大。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;LSTM（&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;长短期记忆网络&amp;quot;],[20,&amp;quot;）&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;：一种特殊的RNN模型，相比前述模型对轨迹质量序列判定有明显优势。在轨迹质量由好转差，或由差转好的识别上具有非常高的灵敏度，使用128个unit能够达到97%的准确率。缺点是LSTM模型训练速度相对较慢，算法库实现相对复杂。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;最终我们选择了使用LSTM模型。使用LSTM的训练结果，准确率大幅提升。在剩余3%的错误样例中，很多轨迹在形态上表现出较高的真实性，但却无法同路网进行匹配。理论上通过引入路网属性能够上带来准确率的进一步提升，然而这种数据的耦合脱离了轨迹质量判定的初衷——服务于偏航引擎专家系统，而非直接用于偏航判定。对此我们将会在最后进行更详细的介绍。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3&amp;quot;],[20,&amp;quot;4. 移动端性能优化&amp;quot;,&amp;quot;8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;模型推算性能对于移动端尤为重要。偏航场景下，GPS更新频繁，选择在必要的时候进行模型推算能够避免不必要的计算开销。通常我们会计算当前GPS点与规划路线的偏离度，只有偏离度大于阈值时才会进行轨迹质量判定。&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;7:3|text-indent:\&amp;quot;1\&amp;quot;&amp;quot;],[20,&amp;quot;基于深度学习的专家系统探索&amp;quot;,&amp;quot;27:\&amp;quot;14\&amp;quot;|8:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;32:2&amp;quot;],[20,&amp;quot;轨迹质量模型作为偏航判定的重要依据，能够以较小的代价移植到移动端。如果不考虑前端性能及数据限制，我们完全可以定义整个偏航判定问题，训练相应的偏航模型。然而偏航场景种类繁多，过于复杂，训练出一套通用的偏航模型需要大量的数据，充足的路网信息，和较大的模型存储，这对于移动端而言不太现实。  &amp;quot;]]&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;团队长期招聘&lt;span&gt;java高级工程师和技术专家，&lt;/span&gt;欢迎有兴趣的小伙伴加入，可投递简历至 diditech@didiglobal.com，邮件请邮件主题请命名为「姓名-应聘部门-应聘方向」。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;135&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;135&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFBFcH3cDkw5qRpibVy97GUiaCUicPhRyTg6LpWp2CFHhKZSYuQnmhyZzBnnRxJ4EuWwvI3HTgqibQ7Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;256&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;扫码了解更多岗位&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;▬&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247512436&amp;amp;idx=1&amp;amp;sn=1fea750185b0ec4a5c5e000db7e773e1&amp;amp;chksm=fc29dfd3cb5e56c5e8d07d13a755a3434cfd61af38a161bfde4be7eaf28b56fda65644da6971&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBG8fiaH5DpcXl4gX9dSJhFzFUvNyoeeVzZpUV1iao6ZywZNm1lvQfoWJiaYJF1rICaHKIACfRhLLoIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247507588&amp;amp;idx=1&amp;amp;sn=a4cc88ed4a14007f5d39da9e7c0e6d02&amp;amp;chksm=fc29b023cb5e393522bc096473e6ff4a5b2045bb591dd62609a6cbae7a2727991c6d82d628e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHraEAV6GKpIj4dQOQNs9ggIppJ4Jhjb2ic2K75ZnPYjTCBicrmiaEgQtH17Ks8E8uk0QeojUDD9whibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1ODEzNjI2NA==&amp;amp;mid=2247493821&amp;amp;idx=1&amp;amp;sn=c3fa1e6733cf9f2b173793adeb0139b3&amp;amp;chksm=fc29861acb5e0f0c5bb5bf02d4e0cafc68cd19232643be1cb798a05bd4a60e65d8705281a0ac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBFPvfKQEIHKT8V3yZSGBZQtHgjI7CoApEqXV3uRhYFH383kdxwNSsfOUib2NViciaJeYHtJk1CvZdVGA/640?wx_fmt=png&quot; data-backw=&quot;562&quot; data-backh=&quot;112&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;内容编辑&lt;span&gt; | Charlotte&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;联系我们 | DiDiTech@didiglobal.com&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre ng-bind-html=&quot;message.MMActualContent&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;162&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.28888888888888886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1wBZCGiaYqBHCquJeOibVaFwqqC4iadSqFxSJRyP1G2V6ZB0tXzfDbHQmq5LXdiawGrVAfTs5INmjsvxOnH4dU8how/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e7583dd9be89f5f5fba1fc84d1163778</guid>
<title>虚拟机系列：JVM 执行引擎和垃圾回收</title>
<link>https://toutiao.io/k/hvkhrg3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、执行引擎&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;应用程序经过编译，转换为字节码文件，字节码加载到内存空间并不能直接在操作系统上执行，执行引擎作为Java虚拟机核心的组成部分，作用就是将字节码指令解释/编译为对应系统平台上的本地机器指令。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5483091787439613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkF0HEywSdsRSgvDxV4diavy7YbsJQia0icz5zdKVn5gk8ABZz50g1DK9BWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解释器&lt;/strong&gt;：虚拟机启动时会根据预定义对字节码采用逐行解释的方式执行，将每条字节码文件中的内容解释为对应系统平台的本地机器指令执行；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JIT编译器&lt;/strong&gt;：虚拟机将源代码编译成本地机器平台相关的机器语言，并且寻找热点高频执行的代码将其放入元空间中，即元空间中存放的JIT缓存代码；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;：对于没有任何引用的对象标记为垃圾，会被回收释放内存空间。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、垃圾对象标记&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、引用计数法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;每个对象保存一个整型引用计数器，用来记录对象被引用的次数，当该对象被一个对象引用时，计数器加1，当失去一个引用时，计数器减1；引用计数算法就是通过判断对象的引用数量来决定对象是否可以被当做垃圾对象回收掉。&lt;/p&gt;&lt;p&gt;虽然引用计数法效率高，但是当两个对象互相引用时会导致这两个对象一直不会被回收，这是一个致命的缺陷。所以JVM并没有采用该标记算法。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、可达性分析算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;可达性分析算法是基于对象到根对象的引用链是否可达来判断对象是否可以被回收；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5601503759398496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFoM8fjGPeOZlPOxKjaYVcGOr2Uey3NUmWfAicD5aWRn8B0rvjsib7vOSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;p&gt;运行程序把所有的引用关系链看作一张图，通过GC-Roots根对象对象集合作为起始点，从每个根节点向下不断搜索被根对象集合所连接的对象是否可达，搜索路径称为引用链（Reference-Chain），如果对象到GC-Roots没有任何引用链存在，则说明此对象是不可用的，&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虚拟机栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;元空间中类静态属性引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;元空间中常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;本地方法栈中Native方法引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相对于引用计数法算法，可达性分析算法则避免了循环引用导致的问题，同样具备执行高效的特点，也是JVM采用的标记算法。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、垃圾回收机制&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、标记清除算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;标记-清除算法分为标记和清除两个阶段：&lt;/p&gt;&lt;p&gt;标记阶段：从根对象集合进行扫描，对存活的对象对象标记；清除阶段：再次扫描发现未被标记的对象并进行回收；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6045548654244306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFFpW6FtSSehTaneZfhZpzGw06aibXRkLft1D81v9yibDYf9sic5oZZNDQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;该算法效率不高，进行垃圾回收需要暂停应用程序，同时会产生大量内存碎片，后续程序运行过程中分配内存占用较大的对象时，会有连续内存不够情况，容易触发再一次垃圾收集动作。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、标记整理算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;标记整理算法的标记过程类似标记清除算法，第一阶段：标记出垃圾对象；第二阶段：让所有存活的对象都向内存区一端移动；第三阶段：直接清理掉边界端以外的内存，类似于磁盘整理的过程；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6024844720496895&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFNDibrfWCXKSibSXq25VRUhGeOG3KJeynygI8AiaRn7vJZn7qfZnh8bZVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;该垃圾回收算法效率不高，对象移动过程需要暂停应用程序，适用于对象存活率高的场景（老年代）。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、复制算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块，当使用的这块的内存用完，就将还存活着的对象复制到另外一块空闲内存上，然后使用过的内存空间一次清理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5762195121951219&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFOSUplgql9BJicPM6eER4DpdcPB0UV5ZcAYSf7H3gdhHbhxEDlw0XkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;&lt;p&gt;该算法实现简单，运行效率高，但是内存空间严重浪费，适用于对象存活率低的场景，比如新生代。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、分代收集算法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;当前市场上几乎所有的虚拟机都采用该回收算法，分代收集算法根据年轻代和老年代的各自特点采用不同的算法机制，不同内存区域中对象生命周期也不同，因此对堆内存不同区域采用不同的回收策略可以提高垃圾回收执行效率。通常情况新生代对象存活率低，回收频繁，就采用复制算法；老年代存对象生命周期长，活率高，就用标记清除算法或者标记整理算法。&lt;/p&gt;&lt;p&gt;Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5061728395061729&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvArrrqwmibM8HOXIoQDsTfkFDEOIGxVhjiccicDhYKEomRazWMb0KKkjynpPCW3ImzB3pBNx53dTUoeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;新生代&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常情况下，新创建的对象实例首先都是放在新生代空间中，所以追求快速的回收掉垃圾对象，一般情况下，新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0，survivor1)区，对象实例大部分在Eden区中生成；&lt;/p&gt;&lt;p&gt;垃圾回收时先把eden区存活对象复制到S0区，然后清空eden区，当S0区也满时，再将eden区和S0区存活对象复制到S1区，然后清空eden和S0区，之后交换S0区和S1区的角色，当S1区无法存放eden区和S0区的存活对象时，就将存活对象直接存移到老年代区，当老年代区也满了，触发一次FullGC，即新生代、老年代都进行回收。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;老年代&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;老年代区存放一些生命周期较长的对象，对象实例在新生代中经历了多次垃圾回收仍然存活的对象，会被移动到老年代区中。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e29096b02ce4d9b40752328c0cb35b6</guid>
<title>如何制作 Sketch 插件</title>
<link>https://toutiao.io/k/xjsgd30</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cont&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t011270038e64a675be.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sketch 是近些年比较流行的 UI 设计软件，它比起之前常用的 Illustrator 或者 Photoshop 比较好的地方在于小巧功能简单但足够，同时对 Mac 的触摸板支持更加友好。另外它的插件系统也要比 Adobe 更加友好，大量的插件帮助我们解决协同和效率上的问题。&lt;/p&gt;
&lt;p&gt;Sketch 插件最大的好处在于可以直接使用 JavaScript 进行开发，并提供了许多配套的开发工具。下面我就以帮助设计师同学快速插入占位图的插件 Placeholder 为例，带大家一步一步的了解如何进行 Sketch 插件开发。&lt;/p&gt;
&lt;p&gt;在进行插件开发之前，我们需要了解一些基础的知识。Sketch 是一套原生 Objective-C 开发的软件，它之所以能支持使用 JS 开发，是因为它使用 &lt;a href=&quot;https://github.com/ccgus/CocoaScript&quot;&gt;CocoaScript&lt;/a&gt; 作为插件的开发语言。它就像是一座桥（Bridge），能让我们在插件中写 OC 和 JS，然后 Sketch 将基础方法进行了封装，实现了一套 &lt;a href=&quot;https://developer.sketch.com/plugins/javascript-api&quot;&gt;JavaScript API&lt;/a&gt;，这样我们就能使用 JS 开发 Sketch 插件了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 关于如何开发插件，官方提供了一份入门教程&lt;a href=&quot;https://developer.sketch.com/plugins/create-a-plugin&quot;&gt;《Create a plugin》&lt;/a&gt;，在阅读下文之前，也可以花 2~3min 先看看这篇官方教程，内容比较简短。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;&lt;a id=&quot;toc-7ae&quot; class=&quot;anchor&quot; href=&quot;#toc-7ae&quot;/&gt;需求整理&lt;/h2&gt;
&lt;p&gt;在进行插件开发之前，我们捋一捋我们需要实现的功能。&lt;a href=&quot;http://placeimg.com/&quot;&gt;http://placeimg.com/&lt;/a&gt; 是一个专门用来生成占位图的网站，我们将利用该网站提供的服务制作一个生成指定大小的占位图并插入到 Sketch 画板中的功能。插件会提供一个面板，可以让使用者输入尺寸、分类等可选项，同时提供插入按钮，点击后会在画板插入一张图片图层。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-fea&quot; class=&quot;anchor&quot; href=&quot;#toc-fea&quot;/&gt;使用 skpm 初始化项目&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;skpm&lt;/code&gt; 是 Sketch 官方提供的插件管理工具，类比于 Node.js 中的 &lt;code&gt;npm&lt;/code&gt;。它集插件的创建、开发、构建、发布等多项功能于一体，我们在很多场景都需要使用它。安装的话比较简单，直接使用 &lt;code&gt;npm&lt;/code&gt; 全局安装即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-cmake&quot;&gt;npm &lt;span class=&quot;hljs-keyword&quot;&gt;install&lt;/span&gt; -g skpm&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按照官方教程，安装完毕之后我们就可以使用 &lt;code&gt;skpm create&lt;/code&gt; 命令来初始化项目目录了。当然 &lt;code&gt;skpm&lt;/code&gt; 是支持基于模板初始化的，官方仓库也列举了一些&lt;a href=&quot;https://github.com/skpm/skpm#create-a-new-plugin&quot;&gt;模板&lt;/a&gt;，我们可以使用 &lt;code&gt;--temlate&lt;/code&gt; 来指定模板进行初始化。不过处于教学的目的，我这里就还是使用官方默认的模板创建了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  ~ skpm create sketch-placeimg
✔ Done!


To get started, cd into the new directory:
  cd sketch-placeimg

To start a development live-reload build:
  npm run start

To build the plugin:
  npm run build

To publish the plugin:
  skpm publish&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;skpm&lt;/code&gt; 内部会使用 &lt;code&gt;webpack&lt;/code&gt; 进行打包编译，运行 &lt;code&gt;npm run build&lt;/code&gt; 会生成 &lt;code&gt;sketch-placeimg.sketchplugin&lt;/code&gt; 目录，该目录就是最终的插件目录。双击该目录，或者将该目录拖拽到 Sketch 界面上就成功安装插件了。和 &lt;code&gt;webpack --watch&lt;/code&gt; 类似，运行 &lt;code&gt;npm run watch&lt;/code&gt; 的话对监听文件变化实时编译，在开发中非常有帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 不要使用 &lt;code&gt;npm start&lt;/code&gt; 进行开发，它携带的 &lt;code&gt;--run&lt;/code&gt; 命令会使得&lt;a href=&quot;https://github.com/skpm/skpm/issues/266&quot;&gt;构建速度特别慢&lt;/a&gt;。虽然它带 Live Reload 功能会很方便，但在官方未修复该问题前还是不建议大家使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id=&quot;toc-be7&quot; class=&quot;anchor&quot; href=&quot;#toc-be7&quot;/&gt;项目结构入门&lt;/h2&gt;
&lt;p&gt;创建好的模板目录结构如下，为了帮助大家理解，我们来简单的介绍下这些目录和文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-css&quot;&gt;.
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;README&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.md&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;assets&lt;/span&gt;
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;icon&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.png&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;sketch-assets&lt;/span&gt;
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;icon&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.sketch&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;sketch-placeimg&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.sketchplugin&lt;/span&gt;
│   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;Contents&lt;/span&gt;
│       ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;Resources&lt;/span&gt;
│       │   └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;icon&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.png&lt;/span&gt;
│       └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;Sketch&lt;/span&gt;
│           ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;manifest&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.json&lt;/span&gt;
│           ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;my-command&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.js&lt;/span&gt;
│           └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;my-command&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.js&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.map&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;node_modules&lt;/span&gt;
├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.json&lt;/span&gt;
└── &lt;span class=&quot;hljs-selector-tag&quot;&gt;src&lt;/span&gt;
    ├── &lt;span class=&quot;hljs-selector-tag&quot;&gt;manifest&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.json&lt;/span&gt;
    └── &lt;span class=&quot;hljs-selector-tag&quot;&gt;my-command&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.js&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a id=&quot;toc-b9c&quot; class=&quot;anchor&quot; href=&quot;#toc-b9c&quot;/&gt;package.json&lt;/h3&gt;
&lt;p&gt;和大多数 JS 项目一样，&lt;code&gt;skpm&lt;/code&gt; 创建的项目中也会有 &lt;code&gt;package.json&lt;/code&gt; 文件。该文件除了像之前一样记录了项目的依赖和快捷命令之外，还增加了 &lt;code&gt;skpm&lt;/code&gt; 字段用来对 &lt;code&gt;skpm&lt;/code&gt; 进行配置，默认的值如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  ...
  &quot;skpm&quot;: {
    &quot;name&quot;: &quot;sketch-placeimg&quot;,
    &quot;manifest&quot;: &quot;src/manifest.json&quot;,
    &quot;main&quot;: &quot;sketch-placeimg.sketchplugin&quot;,
    &quot;assets&quot;: [
      &quot;assets/**/*&quot;
    ],
    &quot;sketch-assets-file&quot;: &quot;sketch-assets/icons.sketch&quot;
  },
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指定了该插件的名称为 &lt;code&gt;sketch-placeimg&lt;/code&gt;，插件的 &lt;code&gt;manifest&lt;/code&gt; 文件为 &lt;code&gt;src/manifest.json&lt;/code&gt;。&lt;code&gt;main&lt;/code&gt; 表示的是最终生成的插件目录名称。&lt;code&gt;assets&lt;/code&gt; 则表示的插件依赖的图片等相关素材，在编译的时候会将命中该配置的文件拷贝到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;toc-4b1&quot; class=&quot;anchor&quot; href=&quot;#toc-4b1&quot;/&gt;manifest.json&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;manifest.json&lt;/code&gt; 这个文件大家可以理解为是 Sketch 插件的 &lt;code&gt;package.json&lt;/code&gt; 文件。我们来看看默认生成的 &lt;code&gt;manifest.json&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/sketch-hq/SketchAPI/develop/docs/sketch-plugin-manifest-schema.json&quot;,
  &quot;icon&quot;: &quot;icon.png&quot;,
  &quot;commands&quot;: [
    {
      &quot;name&quot;: &quot;my-command&quot;,
      &quot;identifier&quot;: &quot;sketch-placeimg.my-command-identifier&quot;,
      &quot;script&quot;: &quot;./my-command.js&quot;
    }
  ],
  &quot;menu&quot;: {
    &quot;title&quot;: &quot;sketch-placeimg&quot;,
    &quot;items&quot;: [
      &quot;sketch-placeimg.my-command-identifier&quot;
    ]
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到 &lt;code&gt;$schema&lt;/code&gt; 就有 JSON Schema 那味了，它对应的 JSON 文件地址告诉我们可以在里面配置那些字段。其实最重要的其实就是上面列出来的 &lt;code&gt;commands&lt;/code&gt; 和 &lt;code&gt;menu&lt;/code&gt; 两个字段。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;commands&lt;/code&gt; 标记了插件有哪些命令，这里只有一个命令，命令的名称（name）是 &lt;code&gt;my-command&lt;/code&gt;，该命令的 ID（identifier）为 &lt;code&gt;sketch-placeimg.my-command-identifier&lt;/code&gt;，对应的执行脚本为 &lt;code&gt;./my-command.js&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;menu&lt;/code&gt; 则标记了该插件的导航菜单配置，比如示例这里它指定了该插件在插件菜单中的名称（title）为 &lt;code&gt;sketch-placeimg&lt;/code&gt;，并拥有一个子菜单，对应的是 ID 为&lt;code&gt;sketch-placeimg.my-command-identifier&lt;/code&gt;的命令。通过这个 ID，菜单的行为就和执行脚本关联起来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t01d7d195029cdc4203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;toc-1f1&quot; class=&quot;anchor&quot; href=&quot;#toc-1f1&quot;/&gt;appcast.xml&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;manifest.json&lt;/code&gt; 默认的示例中有两个比较重要的字段没有配置，那就是 &lt;code&gt;version&lt;/code&gt; 和 &lt;code&gt;appcast&lt;/code&gt;。&lt;code&gt;version&lt;/code&gt; 很明显就是用来表示当前插件的版本的。而 &lt;code&gt;appcast&lt;/code&gt; 它的值是一个 XML 的 URL 地址，该 XML 里面包含了该插件所有的版本以及该版本对应的下载地址。Sketch 会将 &lt;code&gt;version&lt;/code&gt; 对应的版本和 &lt;code&gt;appcast&lt;/code&gt; 对应的 XML 进行对比，如果发现有新的版本了，会使用该版本对应的下载地址下载插件，执行在线更新插件。一个 &lt;code&gt;appcast.xml&lt;/code&gt; 文件大概是这样的格式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rss&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:sparkle&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.andymatuschak.org/xml-namespaces/sparkle&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:dc&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://purl.org/dc/elements/1.1/&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;2.0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;channel&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;enclosure&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;url&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://github.com/lizheming/sketch-placeimg/releases/download/v0.1.1/sketch-placeimg.sketchplugin.zip&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;sparkle:version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.1.1&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;enclosure&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;url&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://github.com/lizheming/sketch-placeimg/releases/download/v0.1.0/sketch-placeimg.sketchplugin.zip&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;sparkle:version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;channel&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rss&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是通过 &lt;code&gt;skpm publish&lt;/code&gt; 命令去发布插件的话，会自动在根目录生成一个 &lt;code&gt;.appcast.xml&lt;/code&gt; 文件。当然按照官方文档 &lt;a href=&quot;https://developer.sketch.com/plugins/update-a-plugin&quot;&gt;《Update a plugin》&lt;/a&gt; 所说，你也可以手动生成。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;resource&quot; class=&quot;anchor&quot; href=&quot;#resource&quot;/&gt;resource&lt;/h3&gt;
&lt;p&gt;从上面的内容我们可以知道，&lt;code&gt;skpm&lt;/code&gt; 会通过 &lt;code&gt;package.json&lt;/code&gt; 中指定的 &lt;code&gt;manifest&lt;/code&gt; 文件读取所有 &lt;code&gt;commands&lt;/code&gt; 对应的 &lt;code&gt;script&lt;/code&gt; 文件作为编译入口文件，将这些文档编译打包输出到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Sketch&lt;/code&gt; 目录。所有的 &lt;code&gt;assets&lt;/code&gt; 配置对应的文件会拷贝到  &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录中。最终完成插件的生成。&lt;/p&gt;
&lt;p&gt;换句话来说只想要走 &lt;code&gt;webpack&lt;/code&gt; 打包编译的话就必须是插件的命令才行。如果有一些依赖的非插件类资源，比如插件嵌入的 HTML 页面依赖的 JS 文件想要走编译的话，就需要使用 &lt;code&gt;resource&lt;/code&gt; 这个配置了。&lt;code&gt;resource&lt;/code&gt; 配置中配置的文件会走 &lt;code&gt;webpack&lt;/code&gt; 的编译打包，并输出到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录中。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-0e6&quot; class=&quot;anchor&quot; href=&quot;#toc-0e6&quot;/&gt;插件开发&lt;/h2&gt;
&lt;p&gt;一些基本原理了解清楚之后我们就可以进行插件的开发了。首先我们需要用户点击插件菜单之后打开一个面板，该面板可以配置尺寸、分类等基础信息。&lt;/p&gt;
&lt;p&gt;Sketch 插件中我们可以使用原生写法进行面板的开发，但是这样写起 UI 来说比较麻烦，而且对前端同学来说入门比较高。所以一般大家都会采用 WebView 加载网页的形式进行开发。原理基本上等同于移动端采用 WebView 加载网页一样，客户端调用 WebView 方法加载网页，通过实例的 &lt;code&gt;webContents.executeJavaScript()&lt;/code&gt;方法进行插件到网页的通信，而网页中则使用被重定义的 &lt;code&gt;window.postMessage&lt;/code&gt; 与插件进行通信。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;sketch-module-web-view&quot; class=&quot;anchor&quot; href=&quot;#sketch-module-web-view&quot;/&gt;sketch-module-web-view&lt;/h3&gt;
&lt;p&gt;想要在插件中加载网页，需要安装 Sketch 封装好的 &lt;code&gt;sketch-module-web-view&lt;/code&gt; 插件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-sql&quot;&gt;npm &lt;span class=&quot;hljs-keyword&quot;&gt;install&lt;/span&gt; sketch-&lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt;-web-&lt;span class=&quot;hljs-keyword&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--save-dev&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// src/my-command.js
import BrowserWindow from &#x27;sketch-module-web-view&#x27;;
export default function() {
  const browserWindow = new BrowserWindow({
    width: 510,
    height: 270,
    resizable: false,
    movable: false,
    alwaysOnTop: true,
    maximizable: false,
    minimizable: false
  });
  browserWindow.loadURL(require(&#x27;../resources/webview.html&#x27;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你做完这些你会发现点击插件菜单后什么都没有发生，这是因为还需要更改一下配置。大家可以看到我们最后是使用了 &lt;code&gt;require()&lt;/code&gt; 引入了一个 HTML 文件，而官方默认的模板是没有提供 HTML 引入的支持的，所以我们需要为 HTML 文件增加对应的 webpack loader。&lt;/p&gt;
&lt;p&gt;我们这里需要的是 &lt;code&gt;html-loader&lt;/code&gt; 和 &lt;code&gt;@skpm/extract-loader&lt;/code&gt; 两款 Loader。前者是用来解析处理 HTML 中存在的包括 &lt;code&gt;&amp;lt;link /&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;img /&amp;gt;&lt;/code&gt; 之类的 HTML 代码中可能存在的资源关联情况。而后者则是用来将 HTML 文件拷贝到 &lt;code&gt;&amp;lt;main&amp;gt;/Contents/Resources&lt;/code&gt; 目录并返回对应的 &lt;code&gt;file:///&lt;/code&gt; 格式的文件路径 URL，用来在插件中进行关联。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-sql&quot;&gt;npm &lt;span class=&quot;hljs-keyword&quot;&gt;install&lt;/span&gt; html-loader @skpm/&lt;span class=&quot;hljs-keyword&quot;&gt;extract&lt;/span&gt;-loader &lt;span class=&quot;hljs-comment&quot;&gt;--save-dev&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sketch 插件官方为我们自定义 webpack 配置也预留好了入口，在项目根目录中创建 &lt;code&gt;webpack.skpm.config.js&lt;/code&gt; 文件，它导出的方法接收的参数中第一个则是插件最终的 webpack 配置，我们直接在这基础上进行修改即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// webpack.skpm.config.js
module.exports = function (config, entry) {
  config.module.rules.push({
    test: /\.html$/,
    use: [
      { loader: &quot;@skpm/extract-loader&quot; },
      {
        loader: &quot;html-loader&quot;,
        options: {
          attributes: {
            list: [
              { tag: &#x27;img&#x27;, attribute: &#x27;src&#x27;, type: &#x27;src&#x27; },
              { tag: &#x27;link&#x27;, attribute: &#x27;href&#x27;, type: &#x27;src&#x27; }
            ]
          }
        }
      }
    ]
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;code&gt;html-loader&lt;/code&gt; 插件在新版里对配置格式做了一些修改，所以之前很多老的教程中的配置都会报错。当然如果你有更多的插件需求也可以按照这个流程往配置对象中添加。之后我们再执行 &lt;code&gt;npm run watch&lt;/code&gt;，点击菜单就可以看到我们预期的页面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t018d066fdf4976461a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 官方是提供了一套带有 &lt;code&gt;sketch-module-web-view&lt;/code&gt; 模块的模板的，这里只是为了能更清楚的给大家解释清楚插件的原理和流程所以和他家一步一步的进行说明。真实的开发场景中建议大家直接使用以下命令进行快速初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;skpm create &amp;lt;plugin-name&amp;gt; --template=skpm/with-webview&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id=&quot;toc-cdc&quot; class=&quot;anchor&quot; href=&quot;#toc-cdc&quot;/&gt;React 的集成&lt;/h3&gt;
&lt;p&gt;面板这块我准备使用 React 进行开发，主要是有 &lt;a href=&quot;http://reactdesktop.js.org/&quot;&gt;React Desktoop&lt;/a&gt; 这个 React 组件，能够很好的在 Web 中模拟 Mac OSX 的 UI 风格（虽然也就几个表单没什么好模拟的就是了）。&lt;/p&gt;
&lt;p&gt;令人开心的是 &lt;code&gt;skpm&lt;/code&gt; 默认的 webpack 配置已经增加了 React 的支持，所以我们不需要额外的增加 webpack 的配置，只需要把 React 相关的依赖安装好就可以进行开发了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install react react-dom react-desktop --save-dev&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;增加 &lt;code&gt;webview.js&lt;/code&gt; 入口文件。由于该文件需要走 webpack 编译，但是又不是插件命令的执行文件，所以我们需要像上文说的，将入口文件加入到 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;skpm.resources&lt;/code&gt; 配置中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lang-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// package.json&lt;/span&gt;
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;skpm&quot;&lt;/span&gt;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;resources&quot;&lt;/span&gt;: [
      &lt;span class=&quot;hljs-string&quot;&gt;&quot;resources/webview.js&quot;&lt;/span&gt;
    ]
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// resources/webview.js&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;react&#x27;&lt;/span&gt;;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ReactDOM &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;react-dom&#x27;&lt;/span&gt;;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;App&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;/&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Hello World!&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hr&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    via: &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;em&lt;/span&gt;&amp;gt;&lt;/span&gt;@lizheming&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;em&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;)
}

ReactDOM.render(&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;App&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;hljs-string&quot;&gt;&#x27;app&#x27;&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;webview.html&lt;/code&gt; 也需要改造一下，引入 JS 入口文件。这里需要注意一下 &lt;code&gt;../resource_webview.js&lt;/code&gt; 这个引用文件地址，这是 JS 入口文件编译后最终的文件地址。主要是因为 HTML 文件最终会生成到 &lt;code&gt;&amp;lt;name&amp;gt;.sketchplugin/Resources/_webpack_resources&lt;/code&gt; 目录下，而 JS 入口文件会将 &lt;code&gt;/&lt;/code&gt; 分隔符替换成 &lt;code&gt;_&lt;/code&gt; 分隔符，生成在 &lt;code&gt;&amp;lt;name&amp;gt;.sketchplugin/Resources&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;PlaceIMG&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;../resources_webview.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/skpm/skpm/blob/master/packages/builder/src/utils/resourceLoader.js#L7-L21&quot;&gt;HTML 文件生成到 &lt;code&gt;_webpack_resources&lt;/code&gt; 配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/skpm/skpm/blob/master/packages/builder/src/utils/webpackConfig.js#L163-L169&quot;&gt;JS 入口文件生成到 &lt;code&gt;Resource&lt;/code&gt; 目录配置&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id=&quot;toc-416&quot; class=&quot;anchor&quot; href=&quot;#toc-416&quot;/&gt;面板开发&lt;/h3&gt;
&lt;p&gt;流程打通了之后接下来我们可以专心进行面板的开发了。面板开发这块就不多描述了，无非就是前段页面的编写而已，最后插件面板大概是长这样子的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p2.ssl.qhimgs4.com/t01d9753783666f4713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-_-||嗯，其实我就是想和大家讲下流程硬上 React 的…&lt;/p&gt;
&lt;p&gt;选择完毕点击插入后，调用 &lt;code&gt;postMessage()&lt;/code&gt; 方法将最终的配置传递给插件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//resources/webview.js
import React, {useReducer} from &#x27;react&#x27;;

function App() {
  const [{width, height, category, filter}, dispatch] = useReducer(
    (state, {type, ...payload}) =&amp;gt; ({...state, ...payload}),
    {width: undefind, height: undefined, category: &#x27;any&#x27;, filter: &#x27;none&#x27;}
  );
  const onInsert = _ =&amp;gt; postMessage(&#x27;insert&#x27;, width, height, category, filter);
  return (
    &amp;lt;button onClick={onInsert}&amp;gt;插入&amp;lt;/button&amp;gt;
  );
}&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; Web 原生的 &lt;code&gt;postMessage()&lt;/code&gt; 方法的语法为 &lt;code&gt;postMessage(message, targetOrigin, [transfer])&lt;/code&gt;。事件名称和事件参数都应该序列化之后通过 &lt;code&gt;message&lt;/code&gt; 参数传入。&lt;/p&gt;
&lt;p&gt;Sketch 插件中的 &lt;code&gt;postMessage()&lt;/code&gt; 方法是注入方法，它对原生的方法进行了复写，所以参数格式上会与原生的不一样。注入方法的实现可参见 &lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/lib/inject-client-messaging.js&quot;&gt;&lt;code&gt;sketch-module-web-view&lt;/code&gt; 代码&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在插件中，我们监听 &lt;code&gt;insert&lt;/code&gt; 事件，获取到用户选择的配置之后给生成图片图层插入到画板中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//src/my-command.js
import sketch, { Image, Rectangle } from &#x27;sketch/dom&#x27;;
import BrowserWindow from &#x27;sketch-module-web-view&#x27;;

export default function() {
  const browserWindow = new BrowserWindow({...});
  browserWindow.webContents.on(&#x27;insert&#x27;, function(width, height, category, filter) {
    const url = &#x27;https://placeimg.com/&#x27; + [width, height, category, filter].join(&#x27;/&#x27;);
    new Image({
      image:  NSURL.URLWithString(url),
      parent: getSelectedArtboard(),
      frame: new Rectangle(0, 0, width, height),
    });
    return browserWindow.close();
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id=&quot;toc-a30&quot; class=&quot;anchor&quot; href=&quot;#toc-a30&quot;/&gt;插件发布&lt;/h2&gt;
&lt;p&gt;最终我们的插件的主体功能就开发完毕了。下面我们就可以进行插件的发布了。我们可以直接使用 &lt;code&gt;skpm publish&lt;/code&gt; 进行发布，它需要你通过 &lt;code&gt;skpm publish --repo-url&lt;/code&gt; 或者是 &lt;code&gt;package.json&lt;/code&gt; 中的 &lt;code&gt;repository&lt;/code&gt; 字段为插件指定 Github 仓库地址。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/settings/tokens&quot;&gt;Personal Access Token&lt;/a&gt; 页面为 skpm 申请新的 Token，记得勾选上 &lt;code&gt;repo&lt;/code&gt; 操作的权限。使用 &lt;code&gt;skpm login &amp;lt;token&amp;gt;&lt;/code&gt; 进行登录之后，skpm 就获得了操作项目的权限。&lt;/p&gt;
&lt;p&gt;最后通过 &lt;code&gt;skpm publish &amp;lt;version&amp;gt;&lt;/code&gt; 就可以成功发布了。如前文所说，发布后会在项目目录创建 &lt;code&gt;.appcast.xml&lt;/code&gt; 文件，同时会发布一条对应版本的 Release 记录，提供插件的 zip 包下载地址。执行完 publish 操作后，如果发现你的插件还没有在&lt;a href=&quot;https://github.com/sketchplugins/plugin-directory&quot;&gt;插件中心仓库&lt;/a&gt;中列出来，还会询问你是否提交个 PR 把自己的插件增加上。&lt;/p&gt;
&lt;p&gt;当然如果你的插件不方便发布到 Github 上，也可以使用前文所说的手工发布，执行 &lt;code&gt;skpm build&lt;/code&gt; 后对生成的 &lt;code&gt;&amp;lt;name&amp;gt;.sketchplugin&lt;/code&gt; 目录进行打包即可。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;toc-688&quot; class=&quot;anchor&quot; href=&quot;#toc-688&quot;/&gt;插件调试&lt;/h2&gt;
&lt;p&gt;上文的示例插件比较简单，所以没有使用特别多的调试手段。在官方教程&lt;a href=&quot;https://developer.sketch.com/plugins/debugging&quot;&gt;《Debug a plugin》&lt;/a&gt;中描述了多种可以进行调试的方式。用的比较多的还是日志调试方式，可以使用系统的 &lt;code&gt;Console.app&lt;/code&gt; 查看日志，也可以使用 &lt;code&gt;skpm log -f&lt;/code&gt; 插件日志。&lt;/p&gt;
&lt;p&gt;文档里说的大部分是插件的调试，WebView 内的前端代码调试会更简单一点。WebView 窗体右键审查元素即可使用 Safari 的开发者工具进行调试了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 插件本身的代码本质是客户端代码，WebView 本质是前端代码，所以两者的调试和日志输出位置都是有区别的，这里要注意区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id=&quot;toc-7a0&quot; class=&quot;anchor&quot; href=&quot;#toc-7a0&quot;/&gt;后记&lt;/h2&gt;
&lt;p&gt;以上就是开发 Sketch 的一些基础知识和简单流程，其它的就是多去看一下 &lt;a href=&quot;https://developer.sketch.com/reference/api/&quot;&gt;Sketch API&lt;/a&gt; 文档了。不过在实际的使用中 Sketch 的这套 JavaScript API 并不是非常完美，部分功能可能还暂时需要使用原生 API 区别。这时候可以多 Google 一下，能找到很多前人的实现，节省自己的工作量。&lt;/p&gt;
&lt;p&gt;本文主要是介绍了一套 JavaScript API + WebView 的偏前端的开发方式，代码我都已经放到 Github 上 &lt;a href=&quot;https://github.com/lizheming/sketch-placeimg&quot;&gt;https://github.com/lizheming/sketch-placeimg&lt;/a&gt;，大家可以自行查阅和下载。除了这种方式之外，我们也可以使用 OC + WebView 甚至是纯 OC 客户端的方式去开发插件。使用纯客户端开发的话性能会比 JavaScript API 的形式好一点，但是对于不了解 OC 开发的前端同学来说上手难度还是比较高的。&lt;/p&gt;
&lt;p&gt;除了 Sketch 之外，Figma 也是一款非常棒的 UI 设计软件。它基于 Web 开发，天生跨平台，更提供了更加易用的协作模式，解决 UI 开发中的多人协作问题。感兴趣的同学也可以去了解一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28325423&quot;&gt;《Sketch插件开发总结》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ee3a901966fe023e7699dda06f92296</guid>
<title>如何一步步 get 大厂前端 offer，或许你可以参考这份成长经历</title>
<link>https://toutiao.io/k/ekbitqq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;之前在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484495&amp;amp;idx=1&amp;amp;sn=3039d0ddfe1c93e945b2ee1f63516053&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《前端菜鸟的阿里实习百日之旅》&quot; data-linktype=&quot;2&quot;&gt;《前端菜鸟的阿里实习百日之旅》&lt;/a&gt;一文中，我的好友「承和」分享了一些作为前端开发实习生的感悟，文章发出后，很多人在后台询问能不能谈谈前端的学习路径，以及作为一个萌新如何拿到大厂的前端 offer。的确，秋招已过去大半，下一波待就业的应届生们也可以开始考虑实习和春招了，为此，本文以 Q&amp;amp;A 形式邀请了他来讲述他是如何一步步 get 大厂的前端 offer，希望他的成长经历可以为正在准备的人带来一些启发。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwljH29T5mBzM4zCItp8VItFBDq4zyibJ617GGF6FI6TM4MJaGgVOAiauicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Q：初来乍到，先做个简单的自我介绍吧&lt;/h3&gt;&lt;p&gt;「01 二进制」的读者，你们好，我是承和，目前是一名计算机专业的研三学生，就读于杭州电子科技大学，本科就读于马爸爸的母校，也就是杭州师范大学。在此次秋招中，很幸运的拿到了阿里，字节，拼多多等公司的 Offer，希望我的成长经历能对你们有所启发。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwl4Nc3avnKHah39Dqia2ician2SPh5XiapN4xCqUCVuibQOsmAwQ7y6qOUibgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;320&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Q：能不能简单说说你这些年的前端学习经历呢？&lt;/h3&gt;&lt;p&gt;说起前端，其实我最早接触的是 iOS 客户端开发。在我大二的时候，苹果发布了最新的开发语言 Swift，恰巧在当时，我在编程上的启蒙老师所在的实验室正在招新，听说加入还会分配 MacBook，于是我马上联系了他。就这样我顺理成章的白嫖到了一台 MacBook Air 笔记本，而当时分配到的任务是开发一款 App，也正是从这个任务开始，我走上了软件开发这条不归路。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6648648648648648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlYx297k6fTEpJhACmno3mlmHc5JRJJJwWKschVMiayhua6ic55Cssb0Lg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;555&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;后来实验室为了减少开发和维护的成本，导师让我学习有关跨平台应用开发技术，也正是从那时起，我逐渐接触到前端开发。在学习过程中，我发现，相对于客户端，前端开发有更广的发展空间，再加上当时客户端的就业形势是&lt;strong&gt;&quot;49 年入国军&quot;&lt;/strong&gt;，因此，毅然决然地选择了前端开发。&lt;/p&gt;&lt;p&gt;再后来，读研期间，学习了点深度学习的相关知识，发现这玩意儿极其烧脑，加上国内学术圈又相当浮躁，多数研究生基本都是为了发论文而发论文，很少有能实际落地应用到工程之中的。加之现在算法岗 hc 非常少，大厂的算法岗几乎是神仙打架，想着肯定是没办法靠算法吃饭了，所以又重新投入到了前端的怀抱中，从 0 开始学起，好好沉淀自己的前端技术。&lt;/p&gt;&lt;h3&gt;Q：你这也算是有了几年开发经验的老鸟了，要不简单谈谈你是如何学习前端技术的？&lt;/h3&gt;&lt;p&gt;我个人认为，学习编程就和练武一样，学习任何一门技术都是&lt;strong&gt;修炼内功&lt;/strong&gt;和&lt;strong&gt;学习招式&lt;/strong&gt;的过程。内功指的就是基础，就前端领域而言，也就是我们常说的前端三板斧：&lt;strong&gt;HTML、CSS 和 JS&lt;/strong&gt;。我们可以根据网上较流行的知识图谱或者一个面试宝典，进行初步的学习。若想要深刻了解的话，便要通过阅读大量相关的专业书籍来加强理解（后面我也会推荐一些，此处没有广告，可放心食用）。&lt;/p&gt;&lt;p&gt;招式指的便是各种&lt;strong&gt;前端框架&lt;/strong&gt;，这些框架帮助我们封装了底层对于 dom 的操作等，使我们能够专注于业务代码的编写。现如今国内 Vue 和 React 大行其道，但是作为 JS 革命性的框架之一，jQuery 我们自然不能忘记，该框架非常适合前端入门者进行学习。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6646153846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlJlqX4oIO3kLNTbZq1UyYrziaGfeAEwB9LYHRdxCr4RVPaGibecu7MVXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1625&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于框架的学习大致可以分为以下 3 个步骤 👇：&lt;/p&gt;&lt;p&gt;第一步，学会&lt;strong&gt;招式的使用，&lt;/strong&gt;你要学会怎么用它，知道这个框架究竟解决了哪些问题，这些资料最好的获取方式便是官网，例如 React 官网，便清楚的说明了 React 的用途，在开发中大多数遇到的问题也能在 React 官网上找到解决方法。&lt;/p&gt;&lt;p&gt;第二步便是用框架做一个项目，在编写项目的过程中，你会遇到很多&quot;稀奇古怪&quot;的问题，通过解决这些问题，可以加深你对框架的理解。&lt;/p&gt;&lt;p&gt;第三步要做到知其然知其所以然，在熟练掌握框架的使用后，去学习它的源码，去看一些源码解析或者大佬的直播课，最好是自己手动实现一个类似于 React 的 diff 算法。&lt;/p&gt;&lt;h3&gt;Q：在学习的过程中，有什么需要注意的呢？&lt;/h3&gt;&lt;p&gt;在学习过程中你会接触到非常多的知识点，难免会产生焦虑，这时候要做的就是定义一个边界，做到对另一个知识点的探索&lt;strong&gt;适可而止&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;例如，在利用 React 脚手架的开发过程当中，我们会接触到 Webpack，我们可以先用脚手架中 Webpack 默认配置来进行项目开发，去了解 Webpack 的功能和大致打包流程，来做到对 Webpack 的整体认识，在后续进行项目优化时，可以尝试对默认配置进行修改，通过熟读 Webpack 官网，了解针对 Webpack，我们有哪些优化手段，并且付诸于实践，在工程当中加深自己对于框架和工具的理解。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlz41kjQtatIKVdNvIJh7XxzF92l6hFkUe9CXW1ksR0A7GwiclT5uRjbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上述是如何学习一个前端框架的简单例子。我们有时候会感叹，这么多的知识点，我们如何来进行学习，这也是国内技术面试的现状：&lt;strong&gt;面试造火箭，工作拧螺丝&lt;/strong&gt;。在准备面试的过程当中，我们可以通过一个面试宝典或知识点的总结来系统的学习前端，随后其余教程和专业书籍加深你对知识点的理解，根据人类的遗忘周期，大概会在第二至第三天会忘掉大部分第一天学习的知识，因此，通过反复学习，反复理解，&lt;strong&gt;达到内功和招式的相互影响，最终修炼成功！&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;Q：作为一个 Offer 收割机，关于前端面试你有什么想说的呢？&lt;/h3&gt;&lt;p&gt;正如上文提到的，国内现在的技术面试基本是“面试造火箭，工作拧螺丝“，在准备面试过程当中，要求我们既有较广的知识面，又需要在一个领域有比较深入地研究。比如面试官会非常感兴趣问 React 源码相关的一些问题，这可能在我们的工作过程当中基本接触不到，因为一般的大厂都有自己的组件库和针对自己的业务，会对市面上较流行的脚手架工具都做一层封装，大部分的开发人员都属于”搬砖“的角色，也就是完成特定的任务即可。所以，这时候就会用人问了，明明是工作中不常用的知识点，为什么面试官就喜欢问呢？&lt;/p&gt;&lt;p&gt;个人看来，问源码能考察一位同学对该项技术是否有思考和热情，因为框架的使用基本每一个人都会，然而对于源码的阅读和理解，有助于更深层次的去理解框架，在开发中遇到一些问题时，也能够更加快速的去定位问题，有相应的方法去解决。将来在做业务的技术选型时，因为你知道各个框架的利弊，所以能够更加快速的做出决策和进行开发。这也就是面试官喜欢考察源码的原因，在原有的广度基础上，来查看我们的知识点深度究竟在哪里。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6670784434836319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlvuBlQnawyxUz3FkCVX1eeEy81lGrib53ottb2JiaNGFPJFg8DKpBLh7w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1619&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Q：简单分享一下你的面经吧&lt;/h3&gt;&lt;p&gt;面试一般分为三个部分，自我介绍，面试官提问，和同学提问。其中第一部分和第三部分我们需要进行详细的准备，自我介绍准备一分钟左右时长即可，对于应届生来说，可能没有太多的项目经验，我们可以介绍下自己学习前端的过程和相对比较擅长的技术栈，有目的性的来引导面试官问对应的问题。面试官基本也会挑你简历上写的知识点来问，这时候就要求我们对简历上的每一个知识点都要做到胸有成竹，在写该知识点的时候，可以模拟下面试官可能会问些什么问题，对知识点进行总结和有逻辑性的表达，在回答过程当中也可以合理的“埋坑”，引导面试官往自己擅长的知识点上问。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6642066420664207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlVjO3dW89pRrEx39C49WVCWuf5E6pJtU3aLTm7xZiaiaY38sQf7aicZfnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1626&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;举一个较简单的例子，浏览器中输入 URL 究竟发生了什么，你回答了相关步骤中有一步为浏览器根据返回的状态码进行判断再进行后续操作。那么接下来面试官可能会问你你了解到的状态码有哪些。你经过准备也知道这个知识点，便能自信的回答。在最后一个环节反向提问的过程中，可以针对职位相对应的技术栈和相关的业务，或者此次面试过程中有什么不足点，有什么建议进行提问，有时高质量的提问也能提升面试官的印象分。在面试后我们要进行及时的复盘和总结，例如每一个提问知识点的及时记录，对于在此次面试过程中发挥不好的地方，及时想出对应的方法总结，有利于在下次面试中更充分的发挥自己的实力。&lt;/p&gt;&lt;h3&gt;Q：要不推荐一些资料呗？&lt;/h3&gt;&lt;p&gt;下面是我个人推荐的较好的学习资料，既有书籍也有博客等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;HTML：基本概念和常用标签的掌握，h5 新标签和新特性。html 语义化等。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;CSS：《CSS 世界》(从流的概念来讲解) ,flex 布局(阮一峰教程)。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;JS:《JavaScript 高级程序设计第 4 版》(红宝书反复看) 《你不知道的 JS》《javascript 语言精髓与编程实践》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;ES6:菜鸟教程 ES6(大致浏览新特性) 《阮一峰 ES6 标准入门》(api 细节查看)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Typescript:ts 官网，&lt;span&gt;一文学会 TypeScript 的 82% 常用知识点（上）&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Vuejs:vue 官网(建议花 2-3 天完完整整的看下来)， 《剖析 vuejs 运行机制》(染陌大佬编写) &lt;span&gt;逐行分析 vue 源码&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;React:react 官网，《深入浅出 react 技术栈》，&lt;span&gt;React 技术揭秘&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Webpack:webpack 官网，《深入浅出 webpack》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Node:nodejs 菜鸟教程(快速上手),《深入浅出 nodejs》(掌握 node 的事件循环和垃圾回收算法，有精力可以研究 v8 源码)。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;计算机网络：《图解 HTTP》(反复看)，《计算机网络》(谢希仁著)&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;数据结构：《算法》(书名就叫算法，虽然是 java 写的，但也能看得懂)。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;设计模式：《javascript 设计模式与开发实践》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;知识点总结和面试宝典：&lt;span&gt;个人秋招经验总结(前端方向)&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt; &lt;span&gt;前端面试与进阶指南&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;子弈大佬的面经: &lt;span&gt;个人前端资源汇集（持续更新）&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt; &lt;span&gt;面试分享：两年工作经验成功面试阿里 P6 总结&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.3326226012793176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwllTZObIf1Pic0biaqNDjmDzaAh6bwuzJkE9zKiclGYscK8p2WkEX4gyLqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;469&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;最后&lt;/h3&gt;&lt;p&gt;这便是简单的一些前端学习和面试经验的分享，希望对你的前端学习和面试都有一定的帮助。欢迎各位读者留言讨论，也欢迎添加我的微信，进一步的交流和分享前端经验，预祝小伙伴们都有自己满意的 offer！&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1558506325456781314&quot; data-bizuin=&quot;Mzg2ODAyNTgyMQ==&quot; data-title=&quot;对于前端学习，你有什么想说的想问的吗？&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.3371104815864023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybzUgfoTYVhuOGlhzvGrmSwlZaiaicmBYDtPNzTbRUFb2kgRQkd55SqeGZJg0gmjdJHSWh0xOJgrMTyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;353&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 一文学会 TypeScript 的 82% 常用知识点（上）: &lt;em&gt;https://www.cnblogs.com/sexintercourse/p/11961086.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 逐行分析 vue 源码: &lt;em&gt;https://www.bbsmax.com/A/lk5aPaE4J1/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; React 技术揭秘: &lt;em&gt;https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 个人秋招经验总结(前端方向): &lt;em&gt;https://www.nowcoder.com/discuss/258810?type=post&amp;amp;order=time&amp;amp;pos=&amp;amp;page=3&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; 前端面试与进阶指南: &lt;em&gt;https://www.cxymsg.com/guide/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; 个人前端资源汇集（持续更新）: &lt;em&gt;https://juejin.im/post/6844904116590739469&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; 面试分享：两年工作经验成功面试阿里 P6 总结: &lt;em&gt;https://juejin.im/post/6844903928442667015&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c1b46c537261473cd39d096100a2f0d</guid>
<title>浅谈 MySQL 并发控制：隔离级别、锁与 MVCC</title>
<link>https://toutiao.io/k/y63nj77</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;如果数据库中的事务都是串行执行的，这种方式可以保障事务的执行不会出现异常和错误，但带来的问题是串行执行会带来性能瓶颈；而事务并发执行，如果不加以控制则会引发诸多问题，包括死锁、更新丢失等等。这就需要我们在性能和安全之间做出合理的权衡，使用适当的并发控制机制保障并发事务的执行。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;并发事务带来的问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;首先我们先来了解一下并发事务会带来哪些问题。并发事务访问相同记录大致可归纳为以下3种情况：&lt;/p&gt;&lt;h5&gt;&lt;span&gt;读-读&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;因为读取记录并不会对记录造成任何影响，所以同个事务并发读取同一记录也就不存在任何安全问题，所以允许这种操作。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;写-写&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;如果允许并发事务都读取同一记录，并相继基于旧值对这一记录做出修改，那么就会出现前一个事务所做的修改被后面事务的修改覆盖，即出现&lt;strong&gt;提交覆盖&lt;/strong&gt;的问题。&lt;/p&gt;&lt;p&gt;另外一种情况，并发事务相继对同一记录做出修改，其中一个事务提交之后之后另一个事务发生回滚，这样就会出现已提交的修改因为回滚而丢失的问题，即&lt;strong&gt;回滚覆盖&lt;/strong&gt;问题。&lt;/p&gt;&lt;p&gt;这两种问题都造成丢失更新，其中回滚覆盖称为&lt;strong&gt;第一类丢失更新&lt;/strong&gt;问题，提交覆盖称为&lt;strong&gt;第二类丢失更新&lt;/strong&gt;问题。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;写-读&lt;/strong&gt;或&lt;strong&gt;读-写&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这种情况较为复杂，也最容易出现问题。&lt;/p&gt;&lt;p&gt;如果一个事务读取了另一个事务尚未提交的修改记录，那么就出现了&lt;strong&gt;脏读&lt;/strong&gt;的问题；&lt;/p&gt;&lt;p&gt;如果我们加以控制使得一个事务只能读取其他已提交事务的修改的数据，那么这个事务在另一事务提交修改前后读取到的数据是不一样的，这就意味着发生了&lt;strong&gt;不可重复读&lt;/strong&gt;；&lt;/p&gt;&lt;p&gt;如果一个事务根据一些条件查询到一些记录，之后另一事务向表中插入了一些记录，原先的事务以相同条件再次查询时发现得到的结果跟第一次查询得到的结果不一致，这就意味着发生了&lt;strong&gt;幻读&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;事务的隔离级别&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;对于以上提到的并发事务执行过程中可能出现的问题，其严重性也是不一样的，我们可以按照问题的严重程度排个序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;丢失更新 &amp;gt; 脏读 &amp;gt; 不可重复读 &amp;gt; 幻读&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此如果我们可以容忍一些严重程度较轻的问题，我们就能获取一些性能上的提升。于是便有了事务的四种隔离级别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;读未提交（&lt;code&gt;Read Uncommitted&lt;/code&gt;）：允许读取未提交的记录，会发生脏读、不可重复读、幻读；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读已提交（&lt;code&gt;Read Committed&lt;/code&gt;）：只允许读物已提交的记录，不会发生脏读，但会出现重复读、幻读；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可重复读（&lt;code&gt;Repeatable Read&lt;/code&gt;）：不会发生脏读和不可重复读的问题，但会发生幻读问题；但&lt;code&gt;MySQL&lt;/code&gt;在此隔离级别下利用&lt;strong&gt;MVCC&lt;/strong&gt;或者&lt;strong&gt;间隙锁&lt;/strong&gt;可以禁止幻读问题的发生；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可串行化（&lt;code&gt;Serializable&lt;/code&gt;）：即事务串行执行，以上各种问题自然也就都不会发生。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;值得注意的是以上四种隔离级别都不会出现回滚覆盖的问题，但是提交覆盖的问题对于&lt;code&gt;MySQL&lt;/code&gt;来说，在&lt;code&gt;Read Uncommitted&lt;/code&gt;、&lt;code&gt;Read Committed&lt;/code&gt;以及&lt;code&gt;Repeatable Read&lt;/code&gt;这三种隔离级别下都会发生（标准的&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别不允许出现提交覆盖的问题），需要额外加锁来避免此问题。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;隔离级别的实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SQL&lt;/code&gt;规范定义了以上四种隔离级别，但是并没有给出如何实现四种隔离级别，因此不同数据库的实现方式和使用方式也并不相同。而&lt;code&gt;SQL&lt;/code&gt;隔离级别的标准是依据基于锁的实现方式来制定的，因为有必要先了解一下传统的基于锁的隔离级别是如何实现的。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;传统隔离级别的实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;既然说到传统的隔离级别是基于锁实现的，我们先来了解一下锁。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;传统的锁有两种：&lt;/p&gt;&lt;p&gt;需要注意的是，加了共享锁的记录，其他事务也可以获得该记录的共享锁，但是无法获取该记录的排他锁，即&lt;code&gt;S锁&lt;/code&gt;和&lt;code&gt;S锁&lt;/code&gt;是兼容的，&lt;code&gt;S锁&lt;/code&gt;和&lt;code&gt;X锁&lt;/code&gt;是不兼容的；而加了排他锁的记录，其他事务既无法获取该记录的共享锁也无法获取排他锁，即&lt;code&gt;X锁&lt;/code&gt;和&lt;code&gt;X锁&lt;/code&gt;也是不兼容的。&lt;/p&gt;&lt;p&gt;另外，刚刚说到事务对一条记录进行读操作时，需要先获取该记录的&lt;code&gt;S锁&lt;/code&gt;，但有时事务在读取记录时需要阻止其他事务访问该记录，这时就需要获取该记录的&lt;code&gt;X锁&lt;/code&gt;。以&lt;code&gt;MySQL&lt;/code&gt;为例，有以下两种锁定读的方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;LOCK&lt;/span&gt; &lt;span&gt;IN&lt;/span&gt; &lt;span&gt;SHARE&lt;/span&gt; &lt;span&gt;MODE&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果事务执行了该语句，则会在读取的记录上加&lt;code&gt;S锁&lt;/code&gt;，这样就允许其他事务也能获取到该记录的&lt;code&gt;S锁&lt;/code&gt;；而如果其他事务需要获取该记录的&lt;code&gt;X锁&lt;/code&gt;，那么就需要等待当前事务提交后释放掉&lt;code&gt;S锁&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果事务执行了该语句，则会在读取的记录上加&lt;code&gt;X锁&lt;/code&gt;，这样其他事务想要获取该记录的&lt;code&gt;S锁&lt;/code&gt;或&lt;code&gt;X锁&lt;/code&gt;，那么需要等待当前事务提交后释放掉&lt;code&gt;X锁&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于锁的粒度而言，锁又可以分为两种：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;行锁：只锁住某一行记录，其他行的记录不受影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;表锁：锁住整个表，所有对于该表的操作都会受影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;&lt;span&gt;基于锁实现隔离级别&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;在基于锁的实现方式下，四种隔离级别的区别就在于加锁方式的区别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;读未提交&lt;/strong&gt;：读操作不加锁，读读，读写，写读并行；写操作加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;读已提交&lt;/strong&gt;：读操作加&lt;code&gt;S锁&lt;/code&gt;，写操作加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放；读操作不会阻塞其他事务读或写，写操作会阻塞其他事务写和读，因此可以防止脏读问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可重复读&lt;/strong&gt;：读操作加&lt;code&gt;S锁&lt;/code&gt;且直到事务提交后才释放，写操作加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放；读操作不会阻塞其他事务读但会阻塞其他事务写，写操作会阻塞其他事务读和写，因此可以防止脏读、不可重复读。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;串行化&lt;/strong&gt;：读操作和写操作都加&lt;code&gt;X锁&lt;/code&gt;且直到事务提交后才释放，粒度为表锁，也就是严格串行。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里面有一些细节值得注意：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果锁获取之后直到事务提交后才释放，这种锁称为&lt;strong&gt;长锁&lt;/strong&gt;；如果锁在操作完成之后就被释放，这种锁称为&lt;strong&gt;短锁&lt;/strong&gt;。例如，在读已提交隔离级别下，读操作所加&lt;code&gt;S锁&lt;/code&gt;为短锁，写操作所加&lt;code&gt;X锁&lt;/code&gt;为长锁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于可重复读和串行化隔离级别，读操作所加&lt;code&gt;S锁&lt;/code&gt;和写操作所加&lt;code&gt;X锁&lt;/code&gt;均为长锁，即事务获取锁之后直到事务提交后才能释放，这种把获取锁和释放锁分为两个不同的阶段的协议称为&lt;strong&gt;两阶段锁&lt;/strong&gt;协议（&lt;code&gt;2-phase locking&lt;/code&gt;）。两阶段锁协议规定在加锁阶段，一个事务可以获得锁但是不能释放锁；而在解锁阶段事务只可以释放锁，并不能获得新的锁。两阶段锁协议能够保证事务串行化执行，解决事务并发问题，但也会导致死锁发生的概率大大提升。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;MySQL隔离级别的实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;不同数据库对于&lt;code&gt;SQL&lt;/code&gt;标准中规定的隔离级别支持是不一样的，数据库引擎实现隔离级别的方式虽然都在尽可能地贴近标准的隔离级别规范，但和标准的预期还是有些不一样的地方。&lt;/p&gt;&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;（&lt;code&gt;InnoDB&lt;/code&gt;）支持的4种隔离级别，与标准的各级隔离级别允许出现的问题有些出入，比如&lt;code&gt;MySQL&lt;/code&gt;在可重复读隔离级别下可以防止幻读的问题出现，但也会出现提交覆盖的问题。&lt;/p&gt;&lt;p&gt;相对于传统隔离级别基于锁的实现方式，&lt;code&gt;MySQL&lt;/code&gt; 是通过&lt;code&gt;MVCC&lt;/code&gt;（多版本并发控制）来实现读-写并发控制，又是通过两阶段锁来实现写-写并发控制的。&lt;code&gt;MVCC&lt;/code&gt;是一种无锁方案，用以解决事务&lt;strong&gt;读-写&lt;/strong&gt;并发的问题，能够极大提升&lt;strong&gt;读-写&lt;/strong&gt;并发操作的性能。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;MVCC的实现原理&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;为了方便描述，首先我们创建一个表&lt;code&gt;book&lt;/code&gt;，就三个字段，分别是主键&lt;code&gt;book_id&lt;/code&gt;, 名称&lt;code&gt;book_name&lt;/code&gt;, 库存&lt;code&gt;stock&lt;/code&gt;。然后向表中插入一些数据：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; book &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&#x27;数据结构&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; book &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&#x27;C++指南&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; book &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;精通Java&#x27;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6&gt;&lt;span&gt;版本链&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;对于使用&lt;code&gt;InnoDB&lt;/code&gt;存储引擎的表，其聚簇索引记录中包含了两个重要的隐藏列：&lt;/p&gt;&lt;p&gt;如果在一个事务中多次对记录进行修改，则每次修改都会生成&lt;code&gt;undo&lt;/code&gt;日志，并且这些&lt;code&gt;undo&lt;/code&gt;日志通过&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;指针串联成一个版本链，版本链的头结点是该记录最新的值，尾结点是事务开始时的初始值。&lt;/p&gt;&lt;p&gt;例如，我们在表&lt;code&gt;book&lt;/code&gt;中做以下修改：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么&lt;code&gt;id=1&lt;/code&gt;的记录此时的版本链就如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4383561643835616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuYtAlzCDFxLnoZ812xQ2xUpibS68ez6St6ZR7vpibIlKCIwJIOU5ur4gtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2044&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h6&gt;&lt;span&gt;ReadView&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;对于使用&lt;code&gt;Read Uncommitted&lt;/code&gt;隔离级别的事务来说，只需要读取版本链上最新版本的记录即可；对于使用&lt;code&gt;Serializable&lt;/code&gt;隔离级别的事务来说，&lt;code&gt;InnoDB&lt;/code&gt;使用加锁的方式来访问记录。而&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下，版本链中哪个版本是能被当前事务读取的。于是&lt;code&gt;ReadView&lt;/code&gt;的概念被提出以解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ReadView&lt;/code&gt;相当于某个时刻表记录的一个快照，在这个快照中我们能获取到与当前记录相关的事务中，哪些事务是已提交的&lt;strong&gt;稳定事务&lt;/strong&gt;，哪些是&lt;strong&gt;正在活跃的事务&lt;/strong&gt;，哪些是&lt;strong&gt;生成快照之后才开启的事务&lt;/strong&gt;。由此我们就能根据&lt;strong&gt;可见性比较算法&lt;/strong&gt;判断出版本链中能被读取的最新版本记录。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可见性比较算法&lt;/strong&gt;是基于事务ID的比较算法。首先我们需要知道的一个事实是：事务&lt;code&gt;id&lt;/code&gt;是递增分配的。从&lt;code&gt;ReadView&lt;/code&gt;中我们能获取到生成快照时刻系统中活跃的事务中最小和最大的事务&lt;code&gt;id&lt;/code&gt;（最大的事务&lt;code&gt;id&lt;/code&gt;实际上是系统中将要分配给下一个事务的&lt;code&gt;id&lt;/code&gt;值），这样我们就得到了一个活跃事务&lt;code&gt;id&lt;/code&gt;的范围，我们可称之为&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;。那么小于这个范围的事务id对应的事务都是已提交的稳定事务，大于这个范围的事务都是在快照生成之后才开启的事务，而在&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;范围内的事务中除了正在活跃的事务，也都是已提交的稳定事务。&lt;/p&gt;&lt;p&gt;有了以上信息之后，我们顺着版本链从头结点开始查找最新的可被读取的版本记录：&lt;/p&gt;&lt;p&gt;1、首先判断版本记录的&lt;code&gt;DB_TRX_ID&lt;/code&gt;字段与生成&lt;code&gt;ReadView&lt;/code&gt;的事务对应的事务ID是否相等。如果相等，那就说明该版本的记录是在当前事务中生成的，自然也就能够被当前事务读取；否则进行第2步。&lt;/p&gt;&lt;p&gt;2、如果版本记录的&lt;code&gt;DB_TRX_ID&lt;/code&gt;字段小于范围&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;，表明该版本记录是已提交事务修改的记录，即对当前事务可见；否则进行下一步。&lt;/p&gt;&lt;p&gt;3、如果版本记录的&lt;code&gt;DB_TRX_ID&lt;/code&gt;字段位于范围&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;内，如果该事务ID对应的不是活跃事务，表明该版本记录是已提交事务修改的记录，即对当前事务可见；如果该事务ID对应的是活跃事务，那么对当前事务不可见，则读取版本链中下一个版本记录，重复以上步骤，直到找到对当前事务可见的版本。&lt;/p&gt;&lt;p&gt;如果某个版本记录经过以上步骤判断确定其对当前事务可见，则查询结果返回此版本记录；否则读取下一个版本记录继续按照上述步骤进行判断，直到版本链的尾结点。如果遍历完版本链没有找到对当前事务可见的版本，则查询结果为空。&lt;/p&gt;&lt;p&gt;在&lt;code&gt;MySQL&lt;/code&gt;中，&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下的区别就是它们生成&lt;code&gt;ReadView&lt;/code&gt;的时机不同。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;MVCC实现不同隔离级别&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;之前说到&lt;code&gt;ReadView&lt;/code&gt;的机制只在&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下生效，所以只有这两种隔离级别才有&lt;code&gt;MVCC&lt;/code&gt;。&lt;br/&gt;在&lt;code&gt;Read Committed&lt;/code&gt;隔离级别下，每次读取数据时都会生成&lt;code&gt;ReadView&lt;/code&gt;；而在&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下只会在事务首次读取数据时生成&lt;code&gt;ReadView&lt;/code&gt;，之后的读操作都会沿用此&lt;code&gt;ReadView&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;下面我们通过例子来看看&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下&lt;code&gt;MVCC&lt;/code&gt;的不同表现。我们继续以表&lt;code&gt;book&lt;/code&gt;为例进行演示。&lt;/p&gt;&lt;h6&gt;&lt;span&gt;Read Committed隔离级别分析&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;假设在&lt;code&gt;Read Committed&lt;/code&gt;隔离级别下，有如下事务在执行，事务&lt;code&gt;id&lt;/code&gt;为10：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 10&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时该事务尚未提交，&lt;code&gt;id&lt;/code&gt;为2的记录版本链如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.46105919003115264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuYmGAoJjSufxTH6LV6d6ca6pnreEw10aiaUBDHapUDH54BEaYS6koNKvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1926&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然后我们开启一个事务对&lt;code&gt;id&lt;/code&gt;为2的记录进行查询：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当执行&lt;code&gt;SELECT&lt;/code&gt;语句时会生成一个&lt;code&gt;ReadView&lt;/code&gt;，该&lt;code&gt;ReadView&lt;/code&gt;中的&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;为&lt;code&gt;[10, 11)&lt;/code&gt;，当前事务ID&lt;code&gt;creator_trx_id&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;（因为事务中当执行写操作时才会分配一个单独的事务&lt;code&gt;id&lt;/code&gt;，否则事务&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;）。按照我们之前所述&lt;code&gt;ReadView&lt;/code&gt;的工作原理，我们查询到的版本记录为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;|  100  |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们将事务&lt;code&gt;id&lt;/code&gt;为10的事务提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 10&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COMMIT&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时开启执行另一事务&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;11&lt;/code&gt;的事务，但不提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 11&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;400&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时&lt;code&gt;id&lt;/code&gt;为2的记录版本链如下图所示：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5665280665280665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuYOhXhvSGf0Swr9TI6EibvRqxGBvJBwxnGNBXfjqMv1LaSUCYd6KxKmmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1924&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然后我们回到刚才的查询事务中再次查询&lt;code&gt;id&lt;/code&gt;为2的记录：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 未提交&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 已提交&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当第二次执行&lt;code&gt;SELECT&lt;/code&gt;语句时会再次生成一个&lt;code&gt;ReadView&lt;/code&gt;，该&lt;code&gt;ReadView&lt;/code&gt;中的&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;为&lt;code&gt;[11, 12)&lt;/code&gt;，当前事务ID&lt;code&gt;creator_trx_id&lt;/code&gt;依然为&lt;code&gt;0&lt;/code&gt;。按照&lt;code&gt;ReadView&lt;/code&gt;的工作原理进行分析，我们查询到的版本记录为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;| 300   |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上述分析可以发现，因为每次执行查询语句都会生成新的&lt;code&gt;ReadView&lt;/code&gt;，所以在&lt;code&gt;Read Committed&lt;/code&gt;隔离级别下的事务读取到的是查询时刻表中已提交事务修改之后的数据。&lt;/p&gt;&lt;h6&gt;&lt;span&gt;Repeatable Read隔离级别分析&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;我们在&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下重复上面的事务操作：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 20&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时该事务尚未提交，然后我们开启一个事务对&lt;code&gt;id&lt;/code&gt;为2的记录进行查询：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当事务第一次执行&lt;code&gt;SELECT&lt;/code&gt;语句时会生成一个&lt;code&gt;ReadView&lt;/code&gt;，该&lt;code&gt;ReadView&lt;/code&gt;中的&lt;code&gt;ACTIVE_TRX_ID_RANGE&lt;/code&gt;为&lt;code&gt;[10, 11)&lt;/code&gt;，当前事务ID&lt;code&gt;creator_trx_id&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;。根据&lt;code&gt;ReadView&lt;/code&gt;的工作原理，我们查询到的版本记录为&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;|  100  |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们将事务&lt;code&gt;id&lt;/code&gt;为20的事务提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 20&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;200&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;300&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;COMMIT&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时开启执行另一事务&lt;code&gt;id&lt;/code&gt;为21的事务，但不提交：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;; // 开启Transaction 21&lt;br/&gt;&lt;br/&gt;&lt;span&gt;UPDATE&lt;/span&gt; book &lt;span&gt;SET&lt;/span&gt; stock = &lt;span&gt;400&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们回到刚才的查询事务中再次查询&lt;code&gt;id&lt;/code&gt;为2的记录：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 未提交&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; book &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;; // 此时Transaction 10 已提交&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当第二次执行&lt;code&gt;SELECT&lt;/code&gt;语句时不会生成新的&lt;code&gt;ReadView&lt;/code&gt;，依然会使用第一次查询时生成&lt;code&gt;ReadView&lt;/code&gt;。因此我们查询到的版本记录跟第一次查询到的结果是一样的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| book_id  |&lt;/span&gt; book_name &lt;span&gt;| stock |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;span&gt;| 2        |&lt;/span&gt; C++指南    &lt;span&gt;|  100  |&lt;/span&gt;&lt;br/&gt;+----------+-----------+-------+&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上述分析可以发现，因为在&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下的事务只会在第一次执行查询时生成&lt;code&gt;ReadView&lt;/code&gt;，该事务中后续的查询操作都会沿用这个&lt;code&gt;ReadView&lt;/code&gt;，因此此隔离级别下一个事务中多次执行同样的查询，其结果都是一样的，这样就实现了可重复读。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;快照读和当前读&lt;/span&gt;&lt;/h5&gt;&lt;h6&gt;&lt;span&gt;快照读&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;在&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下，普通的&lt;code&gt;SELECT&lt;/code&gt;查询都是读取&lt;code&gt;MVCC&lt;/code&gt;版本链中的一个版本，相当于读取一个快照，因此称为&lt;strong&gt;快照读&lt;/strong&gt;。这种读取方式不会加锁，因此读操作时非阻塞的，因此也叫&lt;strong&gt;非阻塞读&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;在标准的&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下读操作会加&lt;code&gt;S锁&lt;/code&gt;，直到事务结束，因此可以阻止其他事务的写操作；但在&lt;code&gt;MySQL&lt;/code&gt;的&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下读操作没有加锁，不会阻止其他事务对相同记录的写操作，因此在后续进行写操作时就有可能写入基于版本链中的旧数据计算得到的结果，这就导致了提交覆盖的问题。想要避免此问题，就需要另外加锁来实现。&lt;/p&gt;&lt;h6&gt;&lt;span&gt;当前读&lt;/span&gt;&lt;/h6&gt;&lt;p&gt;之前提到&lt;code&gt;MySQL&lt;/code&gt;有两种锁定读的方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;LOCK&lt;/span&gt; &lt;span&gt;IN&lt;/span&gt; &lt;span&gt;SHARE&lt;/span&gt; &lt;span&gt;MODE&lt;/span&gt;; // 读取时对记录加S锁，直到事务结束&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; ... &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;; // 读取时对记录加X锁，直到事务结束&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种读取方式读取的是记录的当前最新版本，称为&lt;strong&gt;当前读&lt;/strong&gt;。另外对于&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;操作，也是需要先读取记录，获取记录的&lt;code&gt;X锁&lt;/code&gt;，这个过程也是一个当前读。由于需要对记录进行加锁，会阻塞其他事务的写操作，因此也叫&lt;strong&gt;加锁读&lt;/strong&gt;或&lt;strong&gt;阻塞读&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当前读不仅会对当前记录加&lt;strong&gt;行记录锁&lt;/strong&gt;，还会对查询范围空间的数据加&lt;strong&gt;间隙锁&lt;/strong&gt;（&lt;code&gt;GAP LOCK&lt;/code&gt;），因此可以阻止幻读问题的出现。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;本文介绍了事务的多种并发问题，以及用以避免不同程度问题的隔离级别，并较为详细描述了传统隔离级别的实现方式以及&lt;code&gt;MySQL&lt;/code&gt;隔离级别的实现方式。但数据库的并发机制较为复杂，本文也只是做了大致的描述和介绍，很多细节还需要读者自己查询相关资料进行更细致的了解。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;1、MySQL-InnoDB-MVCC多版本并发控制&lt;/p&gt;&lt;p&gt;2、MySQL 是怎样运行的：从根儿上理解 MySQL&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;长&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4905&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;211&quot; data-ratio=&quot;0.470314318975553&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r8E7jgUqWLABp0Re143hguzibQBM57GuY6GFz2LJcTdP49elictV9qiaQGwjeas67Y3NibWSRJV49ouulgcyu3uA2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1718&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;长&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4905&quot;&gt;长&lt;/span&gt;&lt;span data-raw-text=&quot;按&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4906&quot;&gt;按&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4907&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4908&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4909&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;↑&quot; data-textnode-index=&quot;126&quot; data-index=&quot;4910&quot;&gt;↑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4911&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4912&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;『&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4913&quot;&gt;『比特瓦尔登&lt;/span&gt;&lt;span data-raw-text=&quot;』&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4920&quot;&gt;』&lt;/span&gt;&lt;span data-raw-text=&quot;公&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4921&quot;&gt;公&lt;/span&gt;&lt;span data-raw-text=&quot;众&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4922&quot;&gt;众&lt;/span&gt;&lt;span data-raw-text=&quot;号&quot; data-textnode-index=&quot;127&quot; data-index=&quot;4923&quot;&gt;号&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>