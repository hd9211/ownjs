<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c70d98262225ce5b5538991e4e8edf26</guid>
<title>深入 Spring Boot（十四）：jar/war 打包解决方案</title>
<link>https://toutiao.io/k/f0lsq51</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;最近有位网友通过公众号找到我咨询一个SpringBoot项目打包的问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2935185185185185&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gDHRjEowjKRhFfHXAr8FVAyPoXQyKFtPs0VESkXQIXDqK0UE55Aiawc7wZnSLxiaJjgRXn605dyiachjGicTEXxEOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这位朋友说网络上有很多重复、不可用的技术文章，这个倒是事实，更糟糕的一些自媒体为了流量抄来抄去，增加我们查找解决方案的时间成本，我也尝试去搜索了一下“SpringBoot打包”，结果不尽人意，所以，总结了这篇打包解决方案。&lt;/p&gt;&lt;p&gt;基于SpringBoot开发的项目代码可以打包成可执行jar，也可以打包成war，这个视不同需求而定，下面以SpringBoot2.4.0版本为例，分别列举了不同使用方式下的jar和war打包操作。&lt;/p&gt;&lt;h2&gt;构建可执行jar包&lt;/h2&gt;&lt;p&gt;SpringBoot推荐将应用系统构建成可执行jar包，使用内置应用服务器运行项目代码。&lt;/p&gt;&lt;h3&gt;继承spring-boot-starter-parent&lt;/h3&gt;&lt;p&gt;如果项目配置了pom继承spring-boot-starter-parent，就像下面这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.springframework.boot&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;spring-boot-starter-parent&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.4.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;此时要把项目代码打包成jar，需要在pom中配置packaging=jar，就是下面这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;接着，使用finalName标签配置最终jar包的名字，然后配置spring-boot-maven-plugin插件，例如如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;finalName&amp;gt;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&amp;lt;/finalName&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.springframework.boot&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上就是pom中的配置了，接下来执行jar打包操作，如果使用IDEA图形化工具打包，双击执行Maven窗口下Lifecycle中的package，即执行打jar包。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7543478260869565&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKRhFfHXAr8FVAyPoXQyKFtPhicxiaRsibIpL2etZNq42K0dZjDNHQNiaL5we4SNzscOFvXcnK28MksRtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果想通过执行mvn指令打jar，需要cd到源码根目录，即pom.xml所在的目录，然后执行mvn clean package，即执行打jar包。&lt;/p&gt;&lt;h3&gt;不继承spring-boot-starter-parent&lt;/h3&gt;&lt;p&gt;如果项目pom文件没有继承spring-boot-starter-parent，要想将项目代码构建成可执行jar包，同样需要在pom中配置packaging=jar，就是下面这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;接着，使用finalName标签配置最终jar包的名字，然后配置spring-boot-maven-plugin插件，这里不一样的是需要配置goal=repackage，例如如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;finalName&amp;gt;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&amp;lt;/finalName&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.springframework.boot&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.4.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                        &lt;/span&gt;&lt;span&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                            &lt;/span&gt;&lt;span&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;&lt;span&gt;repackage&lt;/span&gt;&lt;span&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                        &lt;/span&gt;&lt;span&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上就是pom中的配置了，接下来执行jar打包操作，如果使用IDEA图形化工具打包，双击执行Maven窗口下Lifecycle中的package，即执行打jar包；如果想通过执行mvn指令打jar，需要cd到源码根目录，即pom.xml所在的目录，然后执行mvn clean package，即执行打jar包。&lt;/p&gt;&lt;h2&gt;构建可部署war包&lt;/h2&gt;&lt;p&gt;如果需要将项目代码构建成war包，可参考如下两个不同的方式。不过需要注意，对于web应用，SpringBoot2.4使用Servlet3，所以war包需要部署在支持Servlet3的应用服务器上，例如tomcat8.0及以上版本。&lt;/p&gt;&lt;h3&gt;继承spring-boot-starter-parent&lt;/h3&gt;&lt;p&gt;如果配置了项目pom继承spring-boot-starter-parent，就像下面这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.springframework.boot&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;spring-boot-starter-parent&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.4.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;此时要把项目代码打包成jar，需要在pom中配置packaging=war，就是下面这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;&lt;span&gt;war&lt;/span&gt;&lt;span&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;接着，使用finalName标签配置最终war包的名字，然后配置spring-boot-maven-plugin插件，例如如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;finalName&amp;gt;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&amp;lt;/finalName&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.springframework.boot&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上就是pom中的配置了，接下来执行war打包操作，如果使用IDEA图形化工具打包，双击执行Maven窗口下Lifecycle中的package，即执行打war包；如果想通过执行mvn指令打war，需要cd到源码根目录，即pom.xml所在的目录，然后执行mvn clean package，即执行打war包。&lt;/p&gt;&lt;h3&gt;不继承spring-boot-starter-parent&lt;/h3&gt;&lt;p&gt;如果项目pom文件没有继承spring-boot-starter-parent，要想将项目代码构建成war包，同样需要在pom中配置packaging=war，就是下面这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;&lt;span&gt;war&lt;/span&gt;&lt;span&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;接着，使用finalName标签配置最终war包的名字，然后配置构建war包需要使用到的插件，spring-boot-maven-plugin中同样需要配置goal=repackage，例如如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;finalName&amp;gt;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&amp;lt;/finalName&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-antrun-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-assembly-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.3.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-clean-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.1.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-compiler-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.8.1&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-dependency-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.1.2&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-deploy-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.8.2&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-enforcer-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.0.0-M3&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-failsafe-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.22.2&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-help-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.2.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-install-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.5.2&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-invoker-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.2.1&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-jar-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.2.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-javadoc-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.2.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-resources-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.2.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-shade-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.2.4&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-source-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.2.1&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-surefire-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.22.2&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.apache.maven.plugins&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;maven-war-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;3.3.1&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span&gt;org.springframework.boot&lt;/span&gt;&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span&gt;2.4.0&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                        &lt;/span&gt;&lt;span&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;&lt;span&gt;repackage&lt;/span&gt;&lt;span&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;以上配置中的插件版本号参考自SpringBoot2.4.0中的spring-boot-dependencies-2.4.0.pom，它是spring-boot-starter-parent的父文件。&lt;/p&gt;&lt;p&gt;以上就是pom中的配置了，接下来执行war打包操作，如果使用IDEA图形化工具打包，双击执行Maven窗口下Lifecycle中的package，即执行打war包；如果想通过执行mvn指令打war，需要cd到源码根目录，即pom.xml所在的目录，然后执行mvn clean package，即执行打war包。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;从上述操作可以看到，是否继承spring-boot-starter-parent，打包配置还是有些不同的。因为spring-boot-starter-parent pom.xml中已经帮我们管理好了打包需要用到的spring-boot-maven-plugin插件和它需要依赖的其它插件，所以通过继承可以直接使用spring-boot-maven-plugin。有时，我们的项目有自己的parent pom.xml，此时没有继承spring-boot-starter-parent，那么如果还要想使用spring-boot-maven-plugin插件，就需要自定义管理它所依赖的maven插件。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484878&amp;amp;idx=1&amp;amp;sn=daee4e4702b0d3a44daf8599501d72e8&amp;amp;chksm=e9bf5750dec8de4656a9aaf85ada2ca8042921c8e52b57c494cc9af52e615e19fb101a485103&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Java开发人员必知的常用类库，这些你都知道吗？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484871&amp;amp;idx=1&amp;amp;sn=74ede98f0281459c8ded84bd5178caa0&amp;amp;chksm=e9bf5759dec8de4fa24d29ada560d50e73dd35264a02fdd85aab44c4a931af8f1f6e47d1b683&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;聊一聊Redis官方置顶推荐的Java客户端Redisson&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484828&amp;amp;idx=1&amp;amp;sn=bbdfbbed2c5e97dd58386df08fc011db&amp;amp;chksm=e9bf5702dec8de14016f5468ee387d8b326cdec0eca0013e8b5b95d945897f64a6cb817793d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;我画了25张图展示线程池工作原理和实现原理，原创干货，建议先收藏再阅读&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=a67f151b04967d149c2b60ed648e5dbf&amp;amp;chksm=e9bf57c5dec8ded33ccfc6cd269c4736eec528b8e6ab4cc6c2beb11deb744e7f78d7b61ec72b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Spring框架你敢写精通，面试官就敢问@Autowired注解的实现原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484742&amp;amp;idx=1&amp;amp;sn=54e9e3e9de14d3681a8d426d90f5d687&amp;amp;chksm=e9bf57d8dec8decec68531bd74f92a6dba3fb4e74564c27fa9933ece75290d27ffa317a4a8ae&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;面试被问为什么使用Spring Boot？答案好像没那么简单&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484730&amp;amp;idx=1&amp;amp;sn=dd043e8eb2fbf4ca7df266aabed45443&amp;amp;chksm=e9bf57a4dec8deb2e7162250c559dd4d2189681f6e08b37da371d04867698a26b9be062fc24b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Spring声明式事务处理的实现原理，来自面试官的穷追拷问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484712&amp;amp;idx=1&amp;amp;sn=982a0801e878700b42b48f7fae3e5f30&amp;amp;chksm=e9bf57b6dec8dea04544c551c8206897f66efb81f49532b65df4ff878ad284c261b48ad9e3dd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;没使用加号拼接字符串，面试官竟然问我为什么&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484707&amp;amp;idx=1&amp;amp;sn=3eea7537f43fcf0cd646d9bc64fd657f&amp;amp;chksm=e9bf57bddec8deab4ffea25c68197d82c1b46ba58ad0963c9fc0ee6d79f9c47c29660875187f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;面试官一步一步的套路你，为什么SimpleDateFormat不是线程安全的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484701&amp;amp;idx=1&amp;amp;sn=67ba3d2cedbd7a475371acfc474210e1&amp;amp;chksm=e9bf5783dec8de95e76115bc1fbd14401f8b41030d7aa5ebd42894eba56f138fd03f153718a4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;都说ThreadLocal被面试官问烂了，可为什么面试官还是喜欢继续问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484696&amp;amp;idx=1&amp;amp;sn=54c8b5ad9373d88564032c8bc4bc0926&amp;amp;chksm=e9bf5786dec8de90506632f193789cc088165985e35320a5e2a64f6a1230f5d74c9118a811af&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Java注解是如何玩转的，面试官和我聊了半个小时&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学之多，而后知之少&lt;/strong&gt;&lt;span&gt;！朋友们点【在看】是我持续更新的最大动力!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-type=&quot;png&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKSxTAD3licFmGltOsliao1ZVHCicnRtbiarMjXCkm2y0FjRlsJ596O4ibOAoOib1XWGhXlYX8x0wYXIPfxg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e685de8cdcaef211fc9bc153a85a669</guid>
<title>Java 对象属性复制组件：Mapstruct 的项目改造指南</title>
<link>https://toutiao.io/k/ilsr2zz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;本文介绍下Java对象属性复制组件（MapStruct），以及项目中引入遇到的坑。&lt;/p&gt;&lt;h2 data-source-line=&quot;3&quot;&gt;1. 问题背景&lt;/h2&gt;&lt;p data-source-line=&quot;5&quot;&gt;日常编程中，经常会碰到对象属性复制的场景，就比如下面这样一个常见的三层MVC架构。&lt;/p&gt;&lt;p data-source-line=&quot;7&quot;&gt;&lt;img data-ratio=&quot;1.4133333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OqTAl3WTC7FiaMvicf6yicWRFbUluDfickJybRUZkic6YmjK3fWCQhupdXpFicsMUHjaHIgpRicp6icGTr8uAiaoMN9jY5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;9&quot;&gt;前端请求通过VO对象接收，并通过DTO对象进行流转，最后转换成DO对象与数据库DAO层进行交互，反之亦然。&lt;/p&gt;&lt;p data-source-line=&quot;11&quot;&gt;当业务简单的时候，可以通过手动编码getter/setter函数来复制对象属性。但是当业务变的复杂，对象属性变得很多，那么手写复制属性代码不仅十分繁琐，非常耗时间，并且还可能容易出错。&lt;/p&gt;&lt;p data-source-line=&quot;13&quot;&gt;为了解决这个痛点，在项目初期，小辉项目的解决方法是随手写的转换工具函数：根据变量名进行反射，对基础类型和枚举的变量进行赋值。&lt;/p&gt;&lt;p data-source-line=&quot;15&quot;&gt;总结下目前该工具函数的优缺点：&lt;/p&gt;&lt;p data-source-line=&quot;17&quot;&gt;优点：&lt;/p&gt;&lt;ol data-source-line=&quot;19&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;开发效率高，随时想要转换的时候，传入源对象以及指定class，调用下函数即可。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;21&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-source-line=&quot;22&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;项目中大量的反射会严重影响代码执行效率&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由于使用了反射，所以成员变量的使用被追踪就很麻烦&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;转换失败只有在运行中报错才会发现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于嵌套对象字段的情况无能为力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;只能对基础类型进行复制&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对字段名不一致的属性无法赋值&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-source-line=&quot;29&quot;&gt;2. 开源组件选择&lt;/h2&gt;&lt;p data-source-line=&quot;31&quot;&gt;那如果想要更强大的功能，有哪些开源组件可以选择呢？&lt;/p&gt;&lt;p data-source-line=&quot;33&quot;&gt;下面小辉收集并盘点下相关开源组件的特点。&lt;/p&gt;&lt;h3 data-source-line=&quot;35&quot;&gt;1. Apache BeanUtils&lt;/h3&gt;&lt;ol data-source-line=&quot;37&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;底层原理运用反射。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;嵌套对象字段，将会与源对象使用同一对象，即使用浅拷贝。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;字段名不一致的属性无法被复制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;类型不一致的字段，将会进行默认类型转化。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;42&quot;&gt;2. Spring BeanUtils：&lt;/h3&gt;&lt;ol data-source-line=&quot;43&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;底层原理同样运用反射，但相比Apache BeanUtils减少了反射校验，同时增加了缓存，所以提升了转换速度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;嵌套对象字段，将会与源对象使用同一对象，即使用浅拷贝。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;字段名不一致，属性无法复制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;类型不一致的字段，将会进行默认类型转化。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;48&quot;&gt;3. Cglib BeanCopier&lt;/h3&gt;&lt;ol data-source-line=&quot;49&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;字节码技术动态生成一个代理类，代理类实现get和set方法。生成代理类过程存在一定开销，但是一旦生成，我们可以缓存起来重复使用。相比前两个更好用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;嵌套对象字段，将会与源对象使用同一对象，即使用浅拷贝。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;字段名不一致，属性无法复制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;类型不一致的字段，将会进行默认类型转化。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;54&quot;&gt;4. Dozer&lt;/h3&gt;&lt;ol data-source-line=&quot;55&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运用反射。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;嵌套对象字段，不会与源对象使用同一对象，即深拷贝。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;默认支持类型不一致(基本类型/包装类型)转换。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过配置字段名的映射关系，不一样字段的属性也被复制。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-source-line=&quot;60&quot;&gt;5. orika&lt;/h3&gt;&lt;ol data-source-line=&quot;61&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;底层其使用了javassist生成字段属性的映射的字节码，然后直接动态加载执行字节码文件，相比于使用反射的工具类，速度上会快很多。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持深拷贝。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;默认支持类型不一致(基本类型/包装类型)转换。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过配置字段名的映射关系，不一样字段的属性也被复制。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;66&quot;&gt;上面介绍的这些工具类，不管使用反射，还是使用字节码技术，这些都需要在代码运行期间动态执行，所以相对于手写硬编码这种方式，上面这些工具类执行速度都会慢很多。&lt;/p&gt;&lt;p data-source-line=&quot;68&quot;&gt;而MapStruct与上面五个组件原理都不同。&lt;/p&gt;&lt;blockquote data-source-line=&quot;70&quot;&gt;&lt;p&gt;以上提到的属性无法复制，都是在不使用手动写Convert函数的情况下进行讨论的&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-source-line=&quot;72&quot;&gt;3. MapStruct&lt;/h2&gt;&lt;h3 data-source-line=&quot;74&quot;&gt;1. 为什么选择MapStruct&lt;/h3&gt;&lt;p data-source-line=&quot;76&quot;&gt;接下来就要介绍MapStruct 这个工具类，这个工具类之所以运行速度与硬编码差不多，这是因为MapStruct在编译期间就生成属性复制的代码，运行期间就无需使用反射或者字节码技术，从而确保了高性能。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43478260869565216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OqTAl3WTC7FiaMvicf6yicWRFbUluDfickJyLzjNibhfgBr3ZicN9OllB0CUx2PVCAYw7lHgjOvNK5IX2hOdkgpyiamfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot;/&gt;&lt;/p&gt;&lt;p data-source-line=&quot;78&quot;&gt;另外，由于编译期间就生成了代码，所以如果有任何问题，编译期间就可以提前暴露，这对于开发人员来讲就可以提前解决问题，而不用等到代码应用上线了，运行之后才发现错误。&lt;/p&gt;&lt;p data-source-line=&quot;80&quot;&gt;所以，为了克服项目中当前函数的被提到的五个缺点，笔者引入了MapStruct。&lt;/p&gt;&lt;h3 data-source-line=&quot;82&quot;&gt;2. 如何引入MapStruct&lt;/h3&gt;&lt;p data-source-line=&quot;84&quot;&gt;只需要引入MapStruct的依赖，同时由于MapStruct需要在编译器期间生成代码，所以我们需要maven-compiler-plugin插件中配置。&lt;/p&gt;&lt;p data-source-line=&quot;86&quot;&gt;如果项目中没有用到lombok，下面的lombok相关配置可以删除；如果用到lombok，由于MapStruct和Lombok都会在编译期间生成代码，为解决冲突使用如下配置即可。&lt;/p&gt;&lt;pre data-source-line=&quot;88&quot;&gt;&lt;code&gt;&lt;span&gt;// pom.xml&lt;/span&gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.MapStruct&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;MapStruct&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;&lt;span&gt;1.4&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;.Final&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-source-line=&quot;96&quot;&gt;&lt;code&gt;// pom.xml&lt;br/&gt;// &lt;span&gt;为了防止&lt;/span&gt;lombok&lt;span&gt;和&lt;/span&gt;MapStruct&lt;span&gt;的冲突，在&lt;/span&gt;pom.xml&lt;span&gt;加入如下配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;build&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;$&lt;span&gt;{plugin.compiler.version}&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;source&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/source&amp;gt;&lt;/span&gt;             &lt;br/&gt;                &lt;span&gt;&amp;lt;target&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;annotationProcessorPaths&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;path&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.MapStruct&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;MapStruct-processor&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;$&lt;span&gt;{MapStruct.version}&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;/path&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;path&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.projectlombok&lt;span&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lombok&lt;span&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;version&amp;gt;&lt;/span&gt;$&lt;span&gt;{lombok.version}&lt;/span&gt;&lt;span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;/path&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;!-- other annotation processors --&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;/annotationProcessorPaths&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-source-line=&quot;127&quot;&gt;3. MapStruct的常见使用方法&lt;/h3&gt;&lt;p data-source-line=&quot;129&quot;&gt;使用MapStruct很简单，只需要创建一个mapper文件，然后在需要使用转换的地方，注入调用即可。&lt;/p&gt;&lt;p data-source-line=&quot;131&quot;&gt;下面列举了两个文件，涵盖项目中绝大多数的mapper文件写法。&lt;/p&gt;&lt;p data-source-line=&quot;133&quot;&gt;DO转成DTO的mapper：&lt;/p&gt;&lt;pre data-source-line=&quot;134&quot;&gt;&lt;code&gt;/**&lt;br/&gt; * componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;&lt;span&gt;：表明该类是一个&lt;/span&gt; spring &lt;span&gt;组件&lt;/span&gt;,&lt;span&gt;之后调用处只需要使用&lt;/span&gt;@Autowired&lt;span&gt;，即可引入该类实例&lt;/span&gt;&lt;br/&gt; * NullValuePropertyMappingStrategy.IGNORE&lt;span&gt;：如果遇到旧对象属性为&lt;/span&gt;null&lt;span&gt;，则跳过该属性赋值给新对象&lt;/span&gt;&lt;br/&gt; */&lt;br/&gt;@Mapper(componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;, nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)&lt;br/&gt;public interface UserTransMapper {&lt;br/&gt;    /**&lt;br/&gt;     * &lt;span&gt;这个对象可用于非&lt;/span&gt;Spring&lt;span&gt;环境下获取当前对象实例。如果在&lt;/span&gt;Spring&lt;span&gt;环境下，该行代码可删除&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    UserTransMapper INSTANCE = Mappers.getMapper(UserTransMapper.class);&lt;br/&gt;    &lt;br/&gt;    /**&lt;br/&gt;     * &lt;span&gt;将&lt;/span&gt;Userinfo&lt;span&gt;对象中非&lt;/span&gt;null&lt;span&gt;的属性转化为&lt;/span&gt;UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;的对象&lt;/span&gt;&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;Info &lt;span&gt;从数据库读取的用户信息&lt;/span&gt;&lt;br/&gt;     * @return&lt;br/&gt;     */&lt;br/&gt;    UserD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;Info2userD&lt;span&gt;to&lt;/span&gt;(UserInfo &lt;span&gt;user&lt;/span&gt;Info);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * &lt;span&gt;将&lt;/span&gt;Userinfo&lt;span&gt;对象中非&lt;/span&gt;null&lt;span&gt;的属性更新到&lt;/span&gt;UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;的对象&lt;/span&gt;&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;Info &lt;span&gt;从数据库读取的用户信息&lt;/span&gt;&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt; &lt;span&gt;用户信息的&lt;/span&gt;dto&lt;br/&gt;     * &lt;span&gt;如果改&lt;/span&gt;void&lt;span&gt;为&lt;/span&gt;UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;，则函数会返回更新后的&lt;/span&gt;UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    void updateUserInfo2userD&lt;span&gt;to&lt;/span&gt;(UserInfo &lt;span&gt;user&lt;/span&gt;Info, @MappingTarget UserD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * &lt;span&gt;将&lt;/span&gt;UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;对象中非&lt;/span&gt;null&lt;span&gt;的属性转化为&lt;/span&gt;LoginEventD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;的对象&lt;/span&gt;&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt; &lt;span&gt;用户信息的&lt;/span&gt;dto&lt;br/&gt;     * @return LoginEventD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;继承&lt;/span&gt;UserD&lt;span&gt;to&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    LoginEventD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;Dto2loginEventD&lt;span&gt;to&lt;/span&gt;(UserD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-source-line=&quot;169&quot;&gt;DTO转成VO的mapper：&lt;/p&gt;&lt;pre data-source-line=&quot;170&quot;&gt;&lt;code&gt;@Mapper(componentModel = &lt;span&gt;&quot;spring&quot;&lt;/span&gt;, nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)&lt;br/&gt;public interface UserTransMapper {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;对象中非&lt;/span&gt;null&lt;span&gt;的属性转化为&lt;/span&gt;UserInfoVo&lt;span&gt;的对象&lt;/span&gt;&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt; &lt;span&gt;用户信息的&lt;/span&gt;dto&lt;br/&gt;     * @return UserInfoVo&lt;span&gt;继承与&lt;/span&gt;UserBaseInfoVo&lt;span&gt;，都是用了&lt;/span&gt;@Data&lt;span&gt;，没有异常报错。&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    UserInfoVo &lt;span&gt;user&lt;/span&gt;Dto2userVo(UserD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * &lt;span&gt;直接写嵌套&lt;/span&gt;List&lt;span&gt;等集合类，同样可以生效&lt;/span&gt;&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt;List&lt;br/&gt;     * @return&lt;br/&gt;     */&lt;br/&gt;    List&lt;span&gt;&amp;lt;UserInfoVo&amp;gt;&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;Dto2userVo(List&lt;span&gt;&amp;lt;UserDto&amp;gt;&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt;List);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * &lt;span&gt;如果&lt;/span&gt;UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;存在成员变量是类&lt;/span&gt;UserSubD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;，而&lt;/span&gt;UserInfoVo&lt;span&gt;存在成员变量是类&lt;/span&gt;UserSubVo&lt;span&gt;，想在上面转化的同时，让这两个成员变量进行赋值，只需要定义下面的函数即可。&lt;/span&gt;&lt;br/&gt;     *&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;SubD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;用户信息的&lt;/span&gt;dto&lt;span&gt;中的成员变量，类型为&lt;/span&gt;UserSubD&lt;span&gt;to&lt;/span&gt;&lt;br/&gt;     * @return&lt;br/&gt;     */&lt;br/&gt;    UserSubVo &lt;span&gt;user&lt;/span&gt;SubDto2userSubVo(UserSubD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;SubD&lt;span&gt;to&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * UserD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;对象和&lt;/span&gt;FollowInfoD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;对象中非&lt;/span&gt;null&lt;span&gt;的属性转化为&lt;/span&gt;UserInfoVo&lt;span&gt;的对象&lt;/span&gt;&lt;br/&gt;     * @param &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt; &lt;span&gt;用户信息的&lt;/span&gt;dto&lt;br/&gt;     * @param followInfoD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;关注粉丝的&lt;/span&gt;dto&lt;br/&gt;     * @param hn &lt;span&gt;房子数量&lt;/span&gt;&lt;br/&gt;     * @return&lt;br/&gt;     */&lt;br/&gt;    @Mappings({&lt;br/&gt;            @Mapping(source = &lt;span&gt;&quot;userDto.regionId&quot;&lt;/span&gt;,target = &lt;span&gt;&quot;regionId&quot;&lt;/span&gt;),&lt;br/&gt;            @Mapping(source = &lt;span&gt;&quot;followInfoDto.price&quot;&lt;/span&gt;, target = &lt;span&gt;&quot;price&quot;&lt;/span&gt;, numberFormat = &lt;span&gt;&quot;0.00&quot;&lt;/span&gt;),&lt;br/&gt;            @Mapping(source = &lt;span&gt;&quot;hn&quot;&lt;/span&gt;,target = &lt;span&gt;&quot;houseNumber&quot;&lt;/span&gt;)&lt;br/&gt;    })&lt;br/&gt;    /**&lt;br/&gt;     * @Mapping&lt;span&gt;也就是手动映射字段的操作，使用简单，读者可自行研究&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    UserInfoVo &lt;span&gt;user&lt;/span&gt;Dto2userVo(UserD&lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;D&lt;span&gt;to&lt;/span&gt;, FollowInfoD&lt;span&gt;to&lt;/span&gt; followInfoD&lt;span&gt;to&lt;/span&gt;, Integer hn);&lt;br/&gt;    /**&lt;br/&gt;     * &lt;span&gt;假设从映射&lt;/span&gt;Person&lt;span&gt;到&lt;/span&gt;PersonD&lt;span&gt;to&lt;/span&gt;&lt;span&gt;需要一些&lt;/span&gt;MapStruct&lt;span&gt;无法生成的特殊逻辑，可以定义一个&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;br/&gt;     */&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt; PersonD&lt;span&gt;to&lt;/span&gt; personToPersonD&lt;span&gt;to&lt;/span&gt;(Person person) {&lt;br/&gt;        // &lt;span&gt;手动写映射逻辑&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-source-line=&quot;222&quot;&gt;4. 项目改造与踩坑提示&lt;/h2&gt;&lt;p data-source-line=&quot;224&quot;&gt;这次改造中相关依赖的版本：&lt;/p&gt;&lt;ol data-source-line=&quot;226&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;lombok版本1.16.22，改造时升级为1.18.12&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;项目原有依赖fastjson版本1.2.62&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;引入MapStruct版本为1.4.1.Final&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;230&quot;&gt;说明：&lt;/p&gt;&lt;ol data-source-line=&quot;232&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;之所以要升级lombok版本，是因为上面UserDto对象转化为LoginEventDto对象时，原有项目只在UserDto上添加@Builder，但是继承类LoginEventDto无法继承@Builder，导致MapStruct实例化的时候实例一个UserDto对象。&lt;br/&gt;解决方法：在继承层次结构的所有类(即LoginEventDto和UserDto)都需要使用@SuperBuilder可以，（类UserDto的@Builder要去掉）但这个@SuperBuilder只在更高的lombok版本才有，所以才升级了lombok版本。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;项目中使用了fastjson，因此业务代码中出现很多处需要反射调用无参构造函数。但在上面一步升级lombok的过程中，lombok对于@Builder的实现出现了一些修改：在1.16.22的生成代码中，是存在private级别的无参构造函数；而在1.18.12的生成代码中，并没有私有无参构造函数，从而导致了业务代码大量出现缺少默认构造函数的报错。&lt;br/&gt;解决方法：@Builder注解跟构造函数之间的冲突很常见。最佳实践是：在所有使用@Builder或者@SupserBuilder的类，增加@NoArgsConstructor和@AllArgsConstructor。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;237&quot;&gt;虽然本文极力推荐MapStruct，但如果是老项目的话，尤其是大项目的话，还是考虑下改造后的测试成本。本人在第一次引入的时候，过于自信，在父pom引入MapStruct并提升了lombok版本，直接导致开发环境的微服务集体报错。后来改为在单个微服务实验，并且放在开发环境长期观察（主要这个改动影响测试覆盖面太大，也不想让QA为了技术优化来加班），之后才敢放到生产。&lt;/p&gt;&lt;p data-source-line=&quot;239&quot;&gt;当然如果是新项目，非常推荐尝试下MapStruct。&lt;/p&gt;&lt;h2 data-source-line=&quot;241&quot;&gt;5. Q&amp;amp;A&lt;/h2&gt;&lt;ol data-source-line=&quot;243&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在项目引入MapStruct时，有人会提出现在反射的性能消耗已经很低了，Spring、Mybatis等各种框架中大量使用反射，为什么还要使用MapStruct这种编译期生成代码的组件？&lt;br/&gt;主要有如下考虑：&lt;br/&gt;1.反射本身的性能损耗还是很大的，但由于开源库对反射进行了缓存等优化处理，才减少反射对性能损耗的影响。然而，相比调用MapStruct生成的方法，优化后的性能还是差很多。&lt;br/&gt;2.开源库使用反射是为了通用性考虑，但在具体的业务场景，对象之间的转换是很确定的。&lt;br/&gt;3.MapStruct组件本身使用很简单（看完这篇博客之后，可以解决大部分应用场景）。同时， MapStruct组件还能处理一些反射无法处理或者更加灵活解决一些应用问题。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-source-line=&quot;250&quot;&gt;参考&lt;/p&gt;&lt;ol data-source-line=&quot;252&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;https://github.com/MapStruct/MapStruct-examples&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;http://www.kailing.pub/MapStruct1.3/index.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://mapstruct.org/documentation/stable/reference/html/&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f66a3f23378a5d8950b46f58567ef57b</guid>
<title>[译] 云原生世界中的数据包标记 (packet mark) (LPC, 2020)</title>
<link>https://toutiao.io/k/45emgnz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot;&gt;
  
  &lt;h1 class=&quot;postTitle&quot;&gt;[译] 云原生世界中的数据包标记（packet mark）(LPC, 2020)&lt;/h1&gt;
  &lt;p class=&quot;meta&quot;&gt;Published at 2020-12-17 | Last Update 2020-12-17&lt;/p&gt;

  
  
  &lt;h3 id=&quot;译者序&quot;&gt;译者序&lt;/h3&gt;

&lt;p&gt;本文翻译自 2020 年 Joe Stringer 在 Linux Plumbers Conference 的一篇分享:
&lt;a href=&quot;https://www.linuxplumbersconf.org/event/7/contributions/683/attachments/554/979/lpc20-pkt-mark-slides.pdf&quot;&gt;Packet Mark In a Cloud Native World&lt;/a&gt;。
探讨一个在网络和安全领域&lt;strong&gt;非常重要但又讨论甚少的主题&lt;/strong&gt;：skb mark。&lt;/p&gt;

&lt;p&gt;skb mark 是打在&lt;strong&gt;内核数据包&lt;/strong&gt;（skb ）上的&lt;strong&gt;数字标记&lt;/strong&gt;，例如，可能是一个 16bit 或
32bit 整数表示。这个 mark &lt;strong&gt;只存在于每台主机内部&lt;/strong&gt;，当包从网卡发出去之后，这个信息
就丢失了 —— 也就是说，它并&lt;strong&gt;没有存储在任何 packet header 中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;skb mark 用于传递状态信息。在主机的网络处理路径上，网络应用（network
applications）可以在一个地方给包打上 mark，稍后在另一个地方根据 mark 值对包进行相
应操作，据此可以实现 NAT、QoS、LoadBalancing 等功能。&lt;/p&gt;

&lt;p&gt;这里的一个问题是：&lt;strong&gt;mark 是一个开放空间&lt;/strong&gt;，目前还没有任何行业规范，因此&lt;strong&gt;任何应用
可以往里面写入任何值&lt;/strong&gt; —— 只要稍后它自己能正确解读就行了，但每个 skb 的 mark 只有一
份。显而易见，&lt;strong&gt;当主机内同时运行了多个网络应用并且它们都在使用 skb mark 时&lt;/strong&gt;（例
如，kube-proxy + Cilium），就有可能发生冲突，导致包被莫名其妙地转发、丢弃或
修改等问题，因为它们彼此并不感知对方的 mark 语义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;



&lt;p&gt;以下是译文。&lt;/p&gt;

&lt;hr/&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/google-results.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;准备这次分享时，我产生了一个疑问是：&lt;strong&gt;互联网是如何连接到一起的&lt;/strong&gt;（how is the
internet held together）？比如，是靠胶带（duct tape）吗？—— 这当然是开玩笑。&lt;/p&gt;

&lt;p&gt;今天讨论的主题 —— skb &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mark&lt;/code&gt; —— 要比胶带严肃的多。另外，本文将聚焦在云原生（
cloud native）领域，因为过去 2~5 年这一领域出现了很多新的网络插件（software
plugins），正是它们在控制着现在的网络。&lt;/p&gt;

&lt;h1 id=&quot;1-背景&quot;&gt;1 背景&lt;/h1&gt;

&lt;h2 id=&quot;11-linux-世界中的-mark&quot;&gt;1.1 Linux 世界中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mark&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;mark 在不同子系统中有不同的叫法，例如，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fw_mark&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;我不确定这是 firewall mark 还是 forwarding mark 的缩写。
  &lt;strong&gt;iptables 和内核路由层&lt;/strong&gt;（routing layer）会用到这个 mark。&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// include/linux/skbuff.h，代码来自 Kernel 4.19，下同。译注&lt;/span&gt;
    
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sk_buff&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;__u32&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;__u32&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;reserved_tailroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ct_mark&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;连接跟踪（conntrack）的 mark&lt;/strong&gt;，这个 mark 并没有打在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt; 上，但使
  用方式是类似的：先将信息存到 mark，到了用的地方再取出来，根据 mark 状态
  进行相应处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb_mark&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;OVS 里面的一个 mark&lt;/strong&gt;，虽然和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt; 不是一个东西，但二者是强关联的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SO_MARK&lt;/code&gt;（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include/uapi/asm-generic/socket.h&lt;/code&gt;）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;用户空间 socket 层的 mark&lt;/strong&gt;。应用层可以用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setsockopt()&lt;/code&gt; 将某些信息传递到
  netfilter 和 tc 之类的子系统中。后面会看到使用案例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xfrm_mark&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;来自&lt;strong&gt;变换子系统&lt;/strong&gt;（transform subsystem）。&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// include/uapi/linux/xfrm.h&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xfrm_mark&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;__u32&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* value */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;__u32&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* mask */&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pkt_mark&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;OVS 字段&lt;/strong&gt;，引入的目的是对 OVS &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb_mark&lt;/code&gt; 做通用化，因为后者用于 Linux，而
  OVS 可能运行在非 Linux 机器上。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;12-mark-有什么用&quot;&gt;1.2 mark 有什么用？&lt;/h2&gt;

&lt;p&gt;说了这么多，那这些 mark 到底有什么用？ —— 如果不设置，那它们就没什么用。&lt;/p&gt;

&lt;p&gt;换句话说，&lt;strong&gt;mark 能发挥多少作用、完成哪些功能 ，全看应用怎么用它&lt;/strong&gt;。
比如当需要编程控制内核的处理行为时，就会和这些 mark 打交道。很多黑科技就源于此。&lt;/p&gt;

&lt;h2 id=&quot;13-mark-注册中心&quot;&gt;1.3 mark 注册中心&lt;/h2&gt;

&lt;p&gt;如果你开发了一个网络软件，流量收发都没问题。但设置了某些 mark 位之后，
流量就莫名其妙地在某些地方消失了，就像进入了黑洞，或者诸如此类的一些事情。
这很可能是机器上运行的其他软件也在用 mark，和你的冲突了。&lt;/p&gt;

&lt;p&gt;不幸的是，&lt;strong&gt;当前并没有一个权威机构能告诉你，哪些软件在使用 mark，以及它们是如何
使用的&lt;/strong&gt;。因此，想要在自己的应用中设置 mark 字段时，如何通知到外界，以及如何确保
不会与别人的 mark 冲突，就是一件很困难的事情，因为没有一个中心式的注册中心在管理
这些 mark —— 直到大约一个月之前，Dave 发了下面这条推文：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/mark-repo.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Dave 创建了这个 github repo，但注意，这里并不是教大家如何使用 mark，这也不是一个
决策机构，而&lt;strong&gt;只是一份文档，记录大家正在使用的 mark&lt;/strong&gt;。如果你在用自己的 mark 方
案，强烈建议你记录到到这个 repo。&lt;/p&gt;

&lt;h2 id=&quot;14-cilium-网络&quot;&gt;1.4 Cilium 网络&lt;/h2&gt;

&lt;p&gt;我来自 Cilium 团队，Cilium 是一个云原生网络方案，提供了众多的网络、可观测性和安全能力：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/cilium-intro.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们会用到 mark，比如处理 kube-proxy + Cilium 的兼容问题。&lt;/p&gt;

&lt;h2 id=&quot;15-众多-cncf-网络插件&quot;&gt;1.5 众多 CNCF 网络插件&lt;/h2&gt;

&lt;p&gt;为了准备这次分享，我还潜入云原生领域进行了诸多探索。下图是一些 CNCF 云原生网络插
件，它们多少都用到了 mark。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/network-plugins.png&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;想了解具体的某个插件是如何使用 mark 的，可以找到它的源码，然后搜索 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mark&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里的一个考虑是：不同网络插件提供的功能可能是&lt;strong&gt;可叠加&lt;/strong&gt;的。
举个例子，如果你已经在用 flannel，然后又想用 Cilium 的可观测性和安全能力，那就可
以同时运行这两种网络插件 —— 显然，这里的&lt;strong&gt;前提&lt;/strong&gt;是：Cilium 和 flannel 要对内核如
何处理包有一致的理解，这样才能确保 Cilium 沿某个路径转发包时，它们不会被丢弃（
drop）。要做到这一点，Cilium 就需要理解包括 flannel 在内的一些组件是如何设置和使
用 mark 的。&lt;/p&gt;

&lt;p&gt;下面我们就来看一些 mark 的典型使用场景。&lt;/p&gt;

&lt;h1 id=&quot;2-使用案例&quot;&gt;2 使用案例&lt;/h1&gt;

&lt;p&gt;这里整理了 7 个使用案例。我们会看到它们要完成各自的功能，分别需要使用 mark 中
的几个比特位。&lt;/p&gt;

&lt;h2 id=&quot;21-网络策略network-policy&quot;&gt;2.1 网络策略（network policy）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/2-1.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一个场景是网络安全策略，这是 K8s 不可或缺的组成部分。&lt;/p&gt;

&lt;p&gt;这种场景用一个比特位就够了，可以表示两个值：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;drop：白名单模式，默认全部 drop，显式配置 allow 列表&lt;/li&gt;
  &lt;li&gt;allow：黑名单模式，默认全部 allow，显式配置 drop 列表&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;默认-drop-模式&quot;&gt;默认 drop 模式&lt;/h3&gt;

&lt;p&gt;默认情况下，&lt;strong&gt;K8s 会自带一条 iptables 规则，drop 掉没有显式放行（allow）的流量&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工作机制&lt;/strong&gt;比较简单：&lt;/p&gt;

&lt;p&gt;首先，在一条 iptables chain 中给经过的包打上一个 drop 标记（占用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt; 中一个比特就够了），&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;k8s node&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; nat &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt;
...
Chain KUBE-MARK-DROP &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0 references&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target     prot opt &lt;span class=&quot;nb&quot;&gt;source     &lt;/span&gt;destination
MARK       all  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere   anywhere     MARK or 0x8000 &lt;span class=&quot;c&quot;&gt;# 所有经过这条规则的包执行：skb-&amp;gt;mark |= 0x8000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;稍后在另一条 chain 中检查这个标志位，如果仍然处于置位状态，就丢弃这个包：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;k8s node&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;iptables &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt;
Chain INPUT &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;policy ACCEPT&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target         prot opt &lt;span class=&quot;nb&quot;&gt;source               &lt;/span&gt;destination
KUBE-FIREWALL  all  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere  &lt;span class=&quot;c&quot;&gt;# 如果这条规则前面没有其他规则，就会跳转到下面的 KUBE-FIREWALL &lt;/span&gt;

...

Chain KUBE-FIREWALL &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2 references&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
target     prot opt &lt;span class=&quot;nb&quot;&gt;source               &lt;/span&gt;destination
DROP       all  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;  anywhere             anywhere      &lt;span class=&quot;c&quot;&gt;# /* drop marked packets */ mark match 0x8000/0x8000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;默认-allow-模式&quot;&gt;默认 allow 模式&lt;/h3&gt;

&lt;p&gt;这是白名单模式的变种：先给每个包打上允许通行（allow）标记，也是占用一个比特，稍
后再通过检查 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt; 有没有置位来决定是否放行。&lt;/p&gt;

&lt;p&gt;另一个类似的场景是&lt;strong&gt;加解密&lt;/strong&gt;：
对需要加密的流量设置某些 mark，然后在执行加密的地方做检查，对设置了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt; 的执行加密，没有设置的不执行。&lt;/p&gt;

&lt;h3 id=&quot;通用处理模式&quot;&gt;通用处理模式&lt;/h3&gt;

&lt;p&gt;总结起来，这些场景的使用模式都是类似的：&lt;strong&gt;通过 packet mark 和 iptables 规则实现复杂的流量路径控制&lt;/strong&gt;，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在某个地方设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt;，&lt;/li&gt;
  &lt;li&gt;在后面的一些地方检查 mark，然后根据匹配到的规则执行相应的操作，例如放行（allow）或者丢弃（drop），&lt;/li&gt;
  &lt;li&gt;在设置 mark 和解释 mark （前两步）之间，能够实现一些自己的处理逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;典型场景：netfilter -&amp;gt; netfilter 流量过滤。&lt;/p&gt;

&lt;h2 id=&quot;22-透明加密transparent-encryption&quot;&gt;2.2 透明加密（transparent encryption）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/2-2.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;加解密需要两个比特：一个加密标志位，一个解密标志位。&lt;/p&gt;



&lt;p&gt;典型场景：{ eBPF, netfilter } -&amp;gt; xfrm&lt;/p&gt;

&lt;h2 id=&quot;23-virtual-ip-servicednat&quot;&gt;2.3 Virtual IP Service（DNAT）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/2-3.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这种 Service 会有一个 VIP 作为入口，然后通过 DNAT 负载均衡到后端实例（backends）。&lt;/p&gt;

&lt;p&gt;典型情况下，完成这个功能需要一或两个比特，设置之后来表示需要对这些包做 DNAT。但
严格来说，这不是唯一的实现方式。你也可以自己写一些逻辑来匹配目的 IP 和端口，然后
对匹配到的包执行 DNAT。&lt;/p&gt;

&lt;p&gt;如果内核版本较老，那我们基于 eBPF 的 Service 实现可能会受限，此时就需
要与其他软件协同工作才能提供完整的 Service 功能。&lt;/p&gt;

&lt;p&gt;我遇到过的一个场景是 OVS bridge（OVS -&amp;gt; routing -&amp;gt; OVS）。OVS 会设置一些 mark，
然后传给内核的策略路由模块，内核做策略路由之后再重新转发回 OVS，在 OVS 完成最终的
DNAT。&lt;/p&gt;

&lt;p&gt;我遇到的最复杂的场景可能是 kube-router，我们会将 Service 信息写入内核，kube-router 会查看 Service
列表，提取三元组哈希成 30bit 写入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-mark&lt;/code&gt;，稍后内核里的 IPVS 再根据规则匹配这
些 mark 做某些负载均衡。&lt;/p&gt;

&lt;p&gt;典型场景：{ eBPF, netfilter } -&amp;gt; netfilter&lt;/p&gt;

&lt;h2 id=&quot;24-ip-masquerade动态-snat&quot;&gt;2.4 IP Masquerade（动态 SNAT）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/2-4.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;和前面 Service/DNAT 类似，这里是设置某些比特位来做 SNAT。例如在前面某个地方设置 mark，
稍后在 IPVS 里检查这个 mark，然后通过 IP masquerade 做某些形式的负载均衡。&lt;/p&gt;

&lt;p&gt;两个变种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置一个比特位，表示不要做 SNAT（1 bit, skip SNAT）。&lt;/p&gt;

    &lt;p&gt;网络插件负责配置容器的网络连通性。但容器能否被集群外（或公网）访问就因插件
 而异了。如果想让应用被公网访问，就需要通过某种方式配置一个公网 IP 地址。
 这里讨论的就是这种场景。&lt;/p&gt;

    &lt;p&gt;典型情况下，此时仍然只需要一个 bit，表明&lt;strong&gt;不要对设置了 mark 的包做 SNAT（非公
 网流量）&lt;/strong&gt;；没有设置 mark 包需要做 masquerade/SNAT，这些是公网流量。&lt;/p&gt;

    &lt;p&gt;具体到 Cilium CNI plugin，可以在创建 pod 时声明&lt;strong&gt;带哪些 label 的 pod 在出集群时（
 egress）应当使用哪个特定的 源 IP 地址&lt;/strong&gt;。例如，一台 node 上运行了三个应用的
 pod，这些 pod 访问公网时，可以分别使用不同的 src ip 做 SNAT 到公网。&lt;/p&gt;

    &lt;p&gt;上面的场景中，&lt;strong&gt;连接都是主动从 node 发起的&lt;/strong&gt;，例如，node 内的应用主动访问公
 网。实际中还有很多的连接是&lt;strong&gt;从外部发起的，目的端是 node 内的应用&lt;/strong&gt;。例如，来
 自 VPN 的访问 node 内应用的流量。&lt;/p&gt;

    &lt;p&gt;这种情况下，如果将流量转发到本机协议栈网络，可以给它们打上一个 mark，表示要
 做 SNAT。这样响应流量也会经过这个 node，然后沿着反向路径回到 VPN 客户端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用 32bit，选择用哪个 SRC IP 做 SNAT/Masquerade。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;典型场景：{eBPF, OVS, netfilter} -&amp;gt; netfilter&lt;/p&gt;

&lt;h2 id=&quot;25-multi-homing&quot;&gt;2.5 Multi-homing&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/2-5.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;非对称路径&quot;&gt;非对称路径&lt;/h3&gt;

&lt;p&gt;这种场景在 AWS 环境中最常见。&lt;/p&gt;

&lt;p&gt;背景信息：每个 AWS node（EC2）都有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个 primary 设备，提供了到外部的网络连通性，&lt;strong&gt;node 默认路由走这里&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;多个 secondary 设备（&lt;strong&gt;node 默认路由不经过它们&lt;/strong&gt;），每个设备上有多个独立的 IP 地
址，典型情况下是 8 个。在 node 上部署容器时，会从这些 secondary IP 地址中选择
一个来用。当 8 个地址用完之后，可以再分配一个 secondary device attach 到 EC2
（所以每个 EC2 都有多个网络）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当&lt;strong&gt;容器访问另一台 node 上的容器时&lt;/strong&gt;，流量需要发送到对端容器所占用的那个 secondary 设备上。
这里会用到&lt;strong&gt;源路由&lt;/strong&gt;（source routing），也叫&lt;strong&gt;策略路由&lt;/strong&gt;（policy routing）。
默认情况下，策略路由的工作方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先匹配包的 SRC IP，选择对应的路由表，&lt;/li&gt;
  &lt;li&gt;然后在该路由表中再按 DST IP 匹配路由，&lt;/li&gt;
  &lt;li&gt;对于我们这里的场景，最终会匹配到经过某条 secondary device 的路由，然后通过这
个 secondary interface 将包发送出去。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当实现 Service 或类似功能时，对于接收端 node，主要有两种类型的流量：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 secondary device 进来的、目的是本机容器的外部流量。也就是上面我们提到的流
量（Pod-to-Pod 流量）；&lt;/li&gt;
  &lt;li&gt;从 primary device 进来的、目的是本机容器的流量（例如 NodePort Service 流量）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于第二种，不做特殊处理就会有问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求能正常从 primary device 进来，然后转发给容器，被容器正确处理，至此这里都没问题，&lt;/li&gt;
  &lt;li&gt;但从上面的分析可知，如果没有额外处理，响应流量会从 secondary 设备发送到其所在
的网络。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;导致的问题是：来的路径和回去的路径不一致（非对称路径），回包会被丢弃。&lt;/p&gt;

&lt;p&gt;这里就是&lt;strong&gt;最经典地会用到 mark 的地方&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当流量从 primary 设备进来时，设置一个比特位，记录在连接跟踪的 mark（conntrack mark）中。&lt;/li&gt;
  &lt;li&gt;当响应从 pod 发出时，查询连接跟踪记录。如果设置了这个 mark，就表明这个包需要从
主设备路由出去。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样就解决了非对称路径的问题。&lt;/p&gt;

&lt;h3 id=&quot;管理网与业务网分离socket-mark&quot;&gt;管理网与业务网分离：socket mark&lt;/h3&gt;

&lt;p&gt;另一个是 VPN 场景，每台 node 上可能会跑一个 management agent，负责配
置 VPN 网络。&lt;/p&gt;

&lt;p&gt;这种情况下，肯定不能将管理网本身的流量也放到 VPN 网络。&lt;strong&gt;此时就可以用到 socket
mark&lt;/strong&gt;。这个状态会&lt;strong&gt;传递给路由层&lt;/strong&gt;，在路由决策时使用。&lt;/p&gt;

&lt;p&gt;这样做到了管理流量和 VPN 流量的分离。&lt;/p&gt;

&lt;p&gt;典型：{ socket, netfilter } -&amp;gt; routing&lt;/p&gt;

&lt;h2 id=&quot;26-应用身份application-identity&quot;&gt;2.6 应用身份（application identity）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/2-6.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Application identity （应用身份）用于网络层的访问控制。&lt;/p&gt;

&lt;p&gt;在 Cilium 中，&lt;strong&gt;每个 endpoint 都对应一个 identity&lt;/strong&gt;（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N:1&lt;/code&gt;），表示这个容器的安全
身份。Identity 主要用来实现 network policy，占用的比特数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一般用 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;16bit&lt;/code&gt; 表示&lt;/strong&gt;（业界惯例），Cilium &lt;strong&gt;单集群&lt;/strong&gt;时也是这样，&lt;/li&gt;
  &lt;li&gt;如果需要&lt;strong&gt;跨集群/多集群&lt;/strong&gt;做安全策略，那这个 identity 会扩展到 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;24bit&lt;/code&gt;&lt;/strong&gt;，多出来的 8bit 表示 cluster ID。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以在出向（egress）和入向（ingress）做安全控制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 pod 想访问其他服务，可以在它的出向（egress）做策略，设置能访问和不能访问
哪些资源。如果没有设置任何策略，就会使用&lt;strong&gt;默认的 allow all 策略&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;在接收端 pod 的入向（ingress）也可以做策略控制，过滤哪些源过来的允许访问，哪些不允许。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里比较好的一点是：可以&lt;strong&gt;将 identity 以 mark 的方式打在每个包上&lt;/strong&gt;，这样看到
identity 就知道了包的来源，因此安全策略的实现就可以变得简单：从包上提取 identity
和 IP、port 等信息，去查找有没有对应的放行策略就行了。&lt;/p&gt;

&lt;p&gt;当与别的系统集成时，这里会变得更有意思。例如有个叫
&lt;a href=&quot;https://www.cni.dev/plugins/meta/portmap/&quot;&gt;portmap&lt;/a&gt; 的 CNI 插件，可以做 CNI
chaining，感兴趣可以去看看。集成时最大的问题是，无法保证在打标（mark）和检查
mark 之间会发生什么事情。&lt;/p&gt;

&lt;p&gt;典型路径：{ eBPF, netfilter } -&amp;gt; routing -&amp;gt; eBPF&lt;/p&gt;

&lt;h2 id=&quot;27-服务代理service-proxy&quot;&gt;2.7 服务代理（service proxy）&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/img/packet-mark/2-7.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里的最后一个案例是服务代理（service proxy）。&lt;/p&gt;

&lt;p&gt;Proxy 会终结来自客户端的请求，然后将其重定向到本机协议栈，随后请求被监听在本机协
议栈的服务（service）收起。&lt;/p&gt;

&lt;p&gt;根据具体场景的不同，需要使用至少一个比特位：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1 bit, route locally&lt;/p&gt;

    &lt;p&gt;设置了这个比特位，就表示在本机做路由转发。&lt;/p&gt;

    &lt;p&gt;我见过的大部分 service proxy 实际上只需要一个比特，但在实现上，有些却占用了整改 mark（16bit）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;16 bit tproxy port towards proxy&lt;/p&gt;

    &lt;p&gt;在老内核上，Cilium 会通过 mark 传递一个 16bit 的 tproxy port（从 eBPF 传递给
  Netfilter 子系统），以此指定用哪个代理来转发流量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;16+ bit Identity from proxy&lt;/p&gt;

    &lt;p&gt;还可以通过 proxy 传递 identity。
  这样就能够在处理 flow 的整个过程中保存这份状态（retain that state）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;典型路径：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;eBPF -&amp;gt; { netfilter, routing }&lt;/li&gt;
  &lt;li&gt;netfilter -&amp;gt; routing&lt;/li&gt;
  &lt;li&gt;socket -&amp;gt; { eBPF, netfilter },&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-思考建议和挑战&quot;&gt;3 思考、建议和挑战&lt;/h1&gt;

&lt;p&gt;这里讨论一些使用 mark 时的挑战，以及如何与其他网络应用互操作（interoperate），
因为多个网络应用可能在同时对内核网络栈进行编程（programming the stack）。&lt;/p&gt;

&lt;h2 id=&quot;31-mark-使用方案设计&quot;&gt;3.1 mark 使用方案设计&lt;/h2&gt;

&lt;p&gt;首先理解最简单问题：如果要开发一个会设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt; 的网络应用，那
&lt;strong&gt;如何分配 mark 中的每个比特？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;比特位方式：每个 bit 都有特定的语义。&lt;/p&gt;

    &lt;p&gt;例如 32bit mark 能提供 32 个功能，每个功能都可以独立打开或关闭。
 因此，当有多个应用时，就可以说应用 A 使用这个比特，应用 B 使用另一个比特，合
 理地分配这些比特空间。&lt;/p&gt;

    &lt;p&gt;这种方式的一个问题是：&lt;strong&gt;最多只能提供 32 种功能&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Full mark 方式：将 mark 作为一个整形值。&lt;/p&gt;

    &lt;p&gt;这样可以用到整个整形变量的空间，能提供的功能比前一种多的多。例如 32bit 
 可以提供 42 亿个不同的值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据我的观察，很多的软件在实现中都只使用了一个 bit，如果想做一些更疯狂和有趣的事
情，那需要将扩充到 32bit，然后在子系统之间传递这些信息。&lt;/p&gt;

&lt;h2 id=&quot;32-比特位重载&quot;&gt;3.2 比特位重载&lt;/h2&gt;

&lt;p&gt;如果你需要 60 个功能，那显然应该用 4 个比特位来编码这些功能，而不是使用 60 个独
立的比特位。但这种方式也有明显的限制：每个功能无法独立打开或关闭。因此用哪种方式
，取决于你想和哪个子系统集成。&lt;/p&gt;

&lt;p&gt;解决这个问题的另一种方式是：&lt;strong&gt;重载（overload）某些比特位&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;例如，同样是最低 4bit，在 ingress 和 egress 上下文中，分别表示不同的含义。&lt;/li&gt;
  &lt;li&gt;又如，根据包的地址范围来解释 mark 的含义，到某些地址范围的包，这些比特表示一种
意思；到其他地址范围的，表示另一种意思。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这显然带来了一些有趣的挑战。一旦开始 overload 这些 marks，理论上总能构建出
能与其他软件互操作的软件。&lt;/p&gt;

&lt;p&gt;这个过程中，找到从哪里开始下手是很重要的。这就是我开始注意到前面提到的那些网络软
件的原因之一：因为&lt;strong&gt;所有这些工作最后都是与人打交道&lt;/strong&gt;。例如，
iptables 设置了第 15bit 表示 drop 的事实，意味着&lt;strong&gt;其他所有插件都要遵守
这些语义&lt;/strong&gt;，并且其他人要避免使用这个 bit。这样当多个不同的网络插件或软件需要协
同工作来提供一组互补或增强的功能时，它们才不会彼此冲突。即，&lt;strong&gt;不同插件或软件之间要
对比特位的语义有一致的理解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对于 Cilium 来说，这是由我们的用户驱动的，如果用户已经使用了某些插件，并且希望在
这个插件之外同时运行 Cilium，我们就只能从寻求与这些插件的兼容开始。&lt;/p&gt;

&lt;h2 id=&quot;33-发布和遵守-mark-方案&quot;&gt;3.3 发布和遵守 mark 方案&lt;/h2&gt;

&lt;p&gt;那么，我们该如何共享自己的使用方案呢？即，在与其他插件一起运行时，哪个比特位表示
什么意思，这些比特位提供哪些功能。&lt;/p&gt;

&lt;p&gt;从网络应用角度来说，这里很重要的一点是：&lt;strong&gt;理清自己的功能，以及协同工作的他软件的
功能&lt;/strong&gt;。例如，如果用户同时运行了 Cilium CNI 和另一个 CNI 插件，后者也提供了加
密功能；那从 Cilium 的角度来说，我们就无需开启自己的加密功能，让底层插件来做就行了
。&lt;/p&gt;

&lt;p&gt;从现实的角度来说，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;让开发者遵守这些规范、理解它们是如何工作的，是一件有成本的事情；&lt;/li&gt;
  &lt;li&gt;从复杂度的角度来说，如何管理和部署也是一件很有挑战的事情，因为更多的软件或插件
意味着更有可能出错，排障也会更加困难。本文主要关注在如何分配比特，如何定义语
义，如何与其他应用共享互操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;34-深入理解网络栈&quot;&gt;3.4 深入理解网络栈&lt;/h2&gt;

&lt;p&gt;需要说明的是，在实际中，mark 并不是唯一软件的集成点（integration point）。&lt;/p&gt;

&lt;p&gt;不同的插件可能都会插入 iptables 规则，匹配特定的目的地址、源地址等；甚至还可能
用 mark 来做新的策略路由，应用在不同的领域。&lt;/p&gt;

&lt;p&gt;所以，如果你真要实现一个功能，能用到的信息其实不止是 32bit 的 mark，还可以用包头
中的字段、连接跟踪中的状态（conntrack status）等等。因此最终，你会坐下来研究网络
栈流程图，理解你的包是如何穿过 TC、eBPF 和 Netfilter 等的。&lt;/p&gt;

&lt;p&gt;此外，还需要理解不同的软件、它们各自的机制，以及包经过这些不同的子系统时的不同路
径，这会因你启用的功能以及包的源和目的地址等而异。例如，这里最常见的场景之一是：
请求流量是正常的，但响应流量却在某个地方消失了，最终发现是因 multi-home 问题被路
由到了不同的设备。&lt;/p&gt;

&lt;h2 id=&quot;35-少即是多&quot;&gt;3.5 少即是多&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果有更多的 bit 可用，你会用来做什么&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;对于 Cilium 来说，我们正在积极探索&lt;strong&gt;用 eBPF 统一子系统之间的协作方式&lt;/strong&gt;，
这样就可以避免在 eBPF 和 Netfilter、Conntrack 等子系统之间传递大量元数据了。
如果能原生地在 eBPF 中实现处理逻辑，那就能使用 eBPF 领域的标准工具，
进而就能推理出包的转发路径等等，从而减少 mark 的使用。在这种方式下，和其他
软件集成就会轻松很多，因为我们并没有占用这些 mark。&lt;/p&gt;

&lt;p&gt;当然，这并不是说只有 eBPF 能统一子系统之间的协作，你用 OVS、Netfilter 等等方式，
理论上也能统一。&lt;/p&gt;

&lt;p&gt;另一个经常会讨论到的问题是：我们&lt;strong&gt;能否扩展 mark 空间&lt;/strong&gt;？直接扩展 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skb-&amp;gt;mark&lt;/code&gt; 字
段我认为是太可能的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相比之下，添加一个 skb mark extension 之类的新字段，用这个字段做一些事情还是有
可能的，这样就有更多的通用比特（generic bits）来做事情。&lt;/li&gt;
  &lt;li&gt;另一种方式是：将某些使用场景规范化。从通用空间中将某些 bits 拿出来，单独作为某
些场景的专用比特，定义它们的语义，这样它们之间的互操作就方便多了。但这种方式
会消耗一部分 mark 空间，留给其他网络应用的 mark 空间会变得更小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-总结&quot;&gt;4 总结&lt;/h1&gt;

&lt;p&gt;最后总结，packet mark 是一种非常强大的机制，使我们能&lt;strong&gt;在不同子系统之间传递各种状态信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;另外，如何定义 mark 的语义，用户有很大的灵活性。当然，反面是如果你的软件想要
和其他网络软件协同工作，那必须事前约定，大家使用的 mark 不能有冲突，
并且彼此还要理解对方的语义（例子：kube-proxy + Cilium 场景）。
这显然会带来很多的不确定性，当你试图实现某些新功能时，可能就会发现这个 mark 对我
来说很有用，但会不会和别的软件冲突，只有等实际部署到真实环境之后可能才会发现。很
可能直到这时你才会发现：原来这个 mark 已经被某个软件使用了、它的使用方式是这样的
、等等。&lt;/p&gt;

&lt;p&gt;因此，我希望前面提到的 mark registry 能帮我们解决这个问题，希望大家将自己在用的
mark 以文档的方式集中到那个 repo。这也算是一个起点，由此我们就能知道，哪些应用的
mark 方式是和我的有冲突的。然后就能深入这个特定项目的源码，来看能否解决这些冲突
。&lt;/p&gt;

&lt;p&gt;另外应该知道，mark 能提供的功能数，以及相应的场景数，要远远多于 mark 的比特数。
关键在于你需要多少功能。&lt;/p&gt;

&lt;h1 id=&quot;5-相关链接&quot;&gt;5 相关链接&lt;/h1&gt;

&lt;h2 id=&quot;cilium&quot;&gt;Cilium&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;https://cilium.io&lt;/li&gt;
  &lt;li&gt;https://cilium.io/slack&lt;/li&gt;
  &lt;li&gt;https://github.com/cilium/cilium&lt;/li&gt;
  &lt;li&gt;https://twitter.com/ciliumproject&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mark-registry&quot;&gt;Mark registry&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;https://github.com/fwmark/registry&lt;/li&gt;
&lt;/ol&gt;


  
  
&lt;/div&gt;


          

      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ec9fd277ff36c74945431455339462c</guid>
<title>寒门难出贵子，我当程序员让爸妈在老家长脸了</title>
<link>https://toutiao.io/k/cdq2vu4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;全文7千字，预计耗时17分钟，手机充好电&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写公众号两个半月了，一直忙着积累技术、输出技术文章，经读者朋友们的提醒才发现似乎还没有好好介绍过自己，那就趁着2020年的尾声好好复盘一次，也算是给自己每个成长阶段一个交代吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一名程序员，没有过多且复杂的过往，兜兜转转的经历都是围绕着&lt;strong&gt;编程&lt;/strong&gt;这条主线，我想从事这一行业的朋友看完后会有很多相同的感受。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去不过去，未来不会来，看清自己才能走的更远！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;走进编程，初识 C 语言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的老家是在一个十八线县城下的农村，还是贫困县，都说贫困县贫困县，贫困人看不到未来的天。出生、成长在这样的地方，初中高中阶段不是说喜不喜欢编程，而是根本没有接触编程的条件。很多亲戚夸我读书读的好，考上了大学，可没有人知道，那个时候读书是我眼睛里看得到的唯一一条路，我能怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本科也不是特别好的大学，渣渣本罢了。来到大学后学的第一门语言是 C，使用的教材是谭浩强教授编写的，这本书在我读书时有多火呢，如果非要有个比喻，那就如同现在奶茶界的茶颜悦色。至于使用时的效果如何，那，还是不细细说了，懂的人自然懂（害），有兴趣的可以在留言区讨论，期待看到你们饱含文采的年少趣事。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0DXico66g2icYPR8KpvohOm8yHl5KibuHn0kRS9e9ba5wxVfo7onCv1bRLQ/640?wx_fmt=jpeg&quot; data-cropx1=&quot;46&quot; data-cropx2=&quot;256&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;300&quot; data-ratio=&quot;1.4285714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0Dib5b5SXII8YS066E17MPU4fxLwAyiatAlUtJmIG0LhCMy3IblqaJWOiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;210&quot;/&gt;&lt;figcaption&gt;经典教材&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;铛铛铛，手持宝书，我的码农生涯也就徐徐拉开帷幕。大部分人学习这本书应该是为了考过计算机二级，毫不脱俗的我当然也不会是那个例外（我怎么就不能成为码农里面清新还脱俗的那个呢，流下不争气的眼泪）。那我到底有没有编程天赋呢？想什么呢，我总不能自己夸自己骨骼惊奇、天赋异禀吧。不过，嘿嘿，我的C语言老师倒说我有那么一点点资质呢（昂起骄傲的小下巴）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空余时间大家都在打游戏的时候，我拿着我的联想破电脑，按照教材一个字母一个字母对着敲（你们是不是也干过）。当黑色的框框上出现编译错误时，你知道那种心情吧，天啦噜我是对着书敲的啊，为什么会报错，是老天对我不公？是因为我长的丑？还是天降大任先劳其筋骨？原来是少写了一个分号，想太多。凭借我对编程的执着，期末考试 C 语言考了98分（满分100），为什么记这么清楚，因为老师当着全班同学面夸我了，其他同学都担心挂科而我考了第一名。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;从计算机二级到四级，一路升级打怪&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机二级是理工科同学必考的科目，学校还拿这个当做毕业的条件之一。作为被 C 语言老师认证过的编程小王子，我当时暗暗立下了一个目标：这个考试必须要拿下，并且是一次性拿下，多考几次很丢脸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机二级是有笔试和上机编程，我从书店买了一本五年高考三年模拟，好像买错了，换了一本历年真题（笑）。从高考过来的，刷题我行啊，就这样轻轻松松过了笔试。上级编程怎么练习的，我把 leetcode都刷完了，嘿哈开玩笑的，当时没有 leetcode，记得当时买书附带有个光盘照着上面练就完事了，不出意外果然一次性通过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当大多数人止步计算机二级的时候，我在想：考过这个就很牛逼了？通过网上一顿查，原来还有计算机三级、计算机四级，四级最高。不行，我要当最靓的仔，直接考四级吧，一步到达巅峰。大家应该能猜到结果了，被老师认证过的编程小王子，一次性考过四级自然不在话下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0DG1c7yQTqVUWqOic5vlB0SdrPK9jic5QktrRCSmiaNx1wzibBIfSuuJt1EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;figcaption&gt;计算机四级证书&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样，我的大一编程之路是在考试。实事证明我当时还是太年轻了，计算机二级和四级并没有什么卵用，这不还躺着吃灰呢。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;原来 Java 这么好玩&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习完C 语言大部分的人接着就会去学习 C++，在当时我以为 C++ 就是比 C 多了两个+号，应该就是增强版而已，C 语言我都已经快考满分了，还学这个干嘛，这不是浪费编程小王子的时间么（没经过社会的毒打）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正在徘徊之际，学院有个创新团队正在招新，这个团队做的事情我当时不是太懂，只知道里面有很多编程大牛，优秀的人都想加入。但是要想进入这个团队，必须得通过一项认证考试，英文缩写叫：OCJP(Oracle Certified Java Programmer)，这个认证是 Oracle 官方全球通用的，考试题目全英文，考试费用好像是两三百刀，折合人民币一千多块钱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我心里暗暗窃喜：又是考试，问题不大。回想起那段学习的日子，真的很幸福，白天上专业课，晚上找个小教室，创新团队的学长学姐会给我们培训讲课。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几个月的时间，我把 Java 的大部分特性都学完了：面向对象基本特征，封装、继承、多态，访问控制符，基本数据类型、引用类型，异常，泛型，序列化，IO等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时学那些东西就是为了通过 OCJP 考试，结果大家又猜到了，一举拿下认证，顺利进入创新团队学习。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6466666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0DYhkpdFicbFdsRr2mSUHicOoj1HYNu8fibkiaUx6Libd9GhfpYWVSqAAWJNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;figcaption&gt;OCJP 证书&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在回想起来，我现在的 Java 基础就是当时为了准备考试学习的，这个基础就是大家经常说的 JavaSE，很庆幸我、没有走歪路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;跟着马士兵老师做项目&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要知道进入创新团队之前我的编程之路都是在不断考试，这种喜悦很短暂，拿到证扔在一旁索然无味，简单来说就是没有成就感。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来到这里一段时间，我发现大家做的项目都是 xxx 管理系统，还带界面的，要知道一直在黑窗口运行程序的人看到能展现界面的程序是多么兴奋，我顿时来劲了，我我我要快速加入项目组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我只有 JavaSE 的基础，问了学姐之后，学姐给我甩了一堆马士兵老师的视频和资料，是的，就是网上流传的马士兵老师手摸（把）手教程。网上博客标题经常会看到：手把手教你学习……，这个鼻祖就是马士兵老师了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0D518rtJzxfe6D2ReKJqRFqdSUkTr8WanAjnlOlkTrI2bC3SQicCwia9Qw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;马老师手把手教程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;马士兵讲课真他娘的幽默，看学习视频比玩游戏还刺激，经常晚上看到眼皮睁不开了才去睡。你要问我学啥技术这么痴迷，是 JSP，你没有听错就是那个 JSP，当时用这个技术实现了系统的登录注册模块，相信很多人都是从这个开始的。技术发展非常快，随着前后端分离、架构服务化，这种老掉牙的技术只能进历史博物馆了，如果网上还有博客推荐你学习 JSP，你大可关掉页面，这是在害你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习了 JSP，后面继续学习了 MVC，这是我学习的第一个设计模式，虽然技术日新月异，但是 MVC 经典的设计模式思想还是被大多数框架采用了，比如大名鼎鼎的 Spring 全家桶。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java的设计人员应该很牛逼对吧，但是他们也走过弯路，特别是在 JavaEE（Java 企业级开发）中，设计出了一套非常难用的框架或者标准，你想写个 Java Web 的 Hello Word 可能光配置文件要搞几天，于是一大波有追求的开发人员看不下去了，纷纷揭竿而起开发了一堆著名的框架，比如赫赫有名的 Struts 框架，用过这个框架的人应该都知道，用来写 JavaWeb 实在是太舒适了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时JavaWeb有个组合叫 SSH，即：struts+spring+hibernate三剑客，struts 主要负责 MVC 的 V 和 C。这个组合有多火呢，就跟当年 SHE 三姐妹 一样火，当时流传着：学好 SSH 框架，找工作不会怕。由于 struts 框架天天曝严重漏洞，或者是因为 spring 太强了，一代枭雄逐渐落幕，如果网上还有人推荐你学这个，答应我骂他两句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;放到今天来看，Java 企业级开发经历了多轮技术迭代，但是本质没有变，抓着根了再新的框架也能触类旁通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，回到我在创新团队的那段时间，学完马士兵的视频后我做了几个 xxx 管理系统，在当时也都成功上线了。我经常指着某个系统跟学妹吹牛说：你看这个系统多牛逼，这里面的 xxx 模块是我开发的，学妹一脸崇拜的样子：学长你真牛！&lt;span&gt;然&lt;/span&gt;&lt;span&gt;后就没有然后，你们想多了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;也想考个研究生&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创新团队做项目的时间过的飞快，这也是我技术进步最快的一段时间，好像都是古老的技术，嘿哈~ 但是我掌握了学习一门新技术的方法，这个是受益终生的，技术日新月异，但是学习的方法论是不会变的。接受新东西，学习新技能是程序员们必备的素质，大家在平时要对新技术保持敏感，多学一点总不会错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大三下的时候，我突然发现身边的人都在准备考研究生或者考公务员，我又彷徨了，人生的路何去何从？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在咨询了几个学长学姐后我毅然决定了：那就考研吧。并且我做了一个勇敢的选择：要来就来一票大的，我要考华科的研究生。我现在也不知道当时哪来的信心，对了忘了交代我本科是双非的，对于一个双非的学生考研直接选择985高校，勇气可佳啊。我猜想可能是编程给我的勇气和自信吧。至于为什么是华科，理由很简单：因为我是湖北的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0DoHpibfoOuQqDVHWiaLVHG5wLmCyLqgeVt3LjTHYgr1zbgUTEIU9sHL5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;录取通知书&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考研的过程非常艰辛，几度都想放弃，每次想放弃的时候都会找几篇鸡汤帖子鼓励自己，一定要坚持。凭借自己的努力和坚持，最终还是如愿了。虽然现在说这个结果语气是轻飘飘的，实际上过程很困难，这个以后再找个时间详细展开。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;去深圳流浪吧&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过完年之后，很多同学都在准备春招，而我在顺利搞完研究生复试完后，突然觉得生活很枯燥，一个人经历过捶打突然又没有目标了，那种空虚感你们应该能感受到吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;”我们去深圳看看吧“，一位同学提议。说走就走，我们花了三天时间简单准备。因为没有钱我们三个人买了绿皮火车票，硬座，我记得是九十多块钱，给家里打了一个电话后就踏上了南下的路。摇摇晃晃十几个小时终于到了，下了火车我记得非常清楚那是罗湖火车站，并且一个巨大的广告牌写着：来了就是深圳人。后面事实证明深圳还是不欢迎我的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0DZhuv0qF590lWk6UrG43nXC5dcfyehh8wickP0AFiaBREEupYuJLK4yKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;深圳罗湖火车站&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个同学的亲戚在宝安区，就这样我们倒腾了几趟公交车终于到了宝安区，简单吃个饭之后打算先安顿下来。找了中介带我们看房子，看了几间房子之后我们发现，深圳的房子居然都没有家具，里面空空如也，在深圳租过房的人都知道。我们每个人也就带着千把块钱，还要购置家具，太难了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中介问我们几个人住，我们谎称两个人，另外一个同学不住这里。合同签好了，中介要求押一付三，也就是一次要付四个月的房租，这又一次难住了我们，跟他好说歹说，终于靠一副无辜的学生脸让他答应先押一付一了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们三个大男人挤在了一间屋子里，没有家具怎么办？当然没有钱买，简单买了几床被子、几个洗脸盆和拖把，把被子铺在地上将就睡了。好在初春的深圳已经不是很冷了，对于几个血气方刚的年轻人问题不大。现在回忆起那场面确实有点心酸，异乡打工人真难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安顿下来后，每天吃饭加房租花销很大，所以我们需要赶紧找工作。在网上一顿搜索，我们决定去罗湖人才市场碰碰运气。我有Java 开发经验所以准备找一份编程的工作，另外两个同学没啥技能只能找一些学生辅导的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较搞笑的是我两个同学跟用人单位接触后，用人单位说带他们去看看环境，然后把他们拉上面包车了。他们走了一会我收到了一条短信：我坐的车牌号是粤B xxxxx，如果晚上之前还没回来帮我们报警。看到这条短信我是既紧张又觉得好笑，怎么跟电视剧演的一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同学走后，我一个人走向 IT职业相关的招聘单位，用人单位没有与我过多交谈，让我留下简历就可以了。投了十几份简历后有点饿了就坐公交车回租住的地方了，回了后给同学打了电话，他们确认安全，我紧张的心也就放下了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同学去的地方是一个比较好的培训学校，但是由于经验不足都面试失败了。而我呢，投了十几份简历等了几天依旧没有消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经历了几天的痛打，同学们都打退堂鼓了，他们家里打电话说哪个舅舅哪个亲戚可以安排到 xxx 局工作，自然他们撑不住买了车票准备回去。而我呢？我家里是一个十八线的农村，家境一般也无背景，我能怎么办。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个同学坐火车回家了，我没有去送他们，因为我看不起他们，才几天时间，就遇到了一点挫折就纷纷退缩了，太懦弱了。但说实话我也很脆弱，也希望有依靠，心里不是滋味，为什么同学们的爸妈都可以帮他们搞到 xxx 局，却没人帮我，当天晚上我给我爸打了电话说：为什么你不管我，我同学都回家进 xxx 局了。老爸沉默了，没有反驳我，只说了一句：你要是撑不住就回来。这一晚上，我一个大男人在深圳哭了，哭的撕心裂肺的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来几天我给以前的学长打了几个电话，从他们那里我才知道可以在网上投简历，请原谅我这么土，因为我之前根本没想着要去找工作，我一直以为找工作需要去人才市场，不然我也不会匆匆跑到深圳来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我去楼下找了一间网吧，打开智联招聘网站，刷刷刷海投了几十份简历。网上的效率真高，当天下午我就接到面试电话，预约第二天去现场面试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试很顺利，过了一天就给我发 offer 了，工资真是低的可怜，我还是接了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0DCHAKQuGg9zxt74u30YaNK6NaFAX7Yq4b80lZTIzMicUIOQItzDjfiaaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;第一份 offer&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;突然厌倦编程，考个公务员吧&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;租住的地方在宝安区，工作的地方在南山区，每天光上下班通勤就花费了几个小时。到了下班时间我发现同事们居然都不回家，还喊我去吃饭，这时我明白了默认晚上要加班，请原谅我当年不懂 IT 行业的规矩，以为跟电视里一样到点就下班。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这期间我作为一个试用期员工，对业务也不熟悉，技术又菜，每天晚上只好坐在工位学习。加上导师开始催毕业论文了，我一般就晚上在公司写，周末就去网吧写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的日子也就持续了两周，我开始怀疑人生了，我适合编程吗？后面读完研也是这样的生活吗？太苦了，每天晚上加班到很晚，晚上回到租的房子没有一个人，还得睡地上，第二天早上还要去挤公交。一周下来除了跟同事说几句话我总共还没说过超10句话，这个城市太陌生了，太冷漠了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一天晚上我在想，同学们都去 xxx 局了，我也可以考公务员，真羡慕那种朝九晚五的生活，在县城里待着买房压力也不大，跟家里挨着还近，还能约朋友周末吃个饭喝个酒。想到这里我又暗暗下了决定：离职，回家准备公务员考试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去公司跟领导提了想法，由于是试用期也没什么要交接的，一天就办好了流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在离开深圳前我还去看了大海，去了大小梅沙，走在海滨栈道上，我的心情很愉悦，感觉生活又燃起了希望。处理好租住的房子，扔掉被子和盆，我买了张绿皮火车票回到学校了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我爸知道我的想法后，几度劝我长点志气，眼光放长远点，一辈子窝在一个小县城有什么出息。华科是985名校多少人努力都没考上，你要是这样放弃掉以后会后悔的。在我耳边唠叨多了，我也在想是不是我真的没出息？其实我是厌倦那种生活，想安安稳稳过着朝九晚五正常人的生活而已，空余时间可以干自己喜欢做的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是已经报名了，填的岗位是老家县城的一个职位，那就去裸考吧。说是裸考，之前我也是了解过，考试主要是行测和申论，行测就是选择题，申论就是阅读理解写作文。考完之后我本来已经放弃了，但是笔试居然通过了，岗位招一个人，按照1：3的人进入面试，我刚好排在第三名。可能这就是命吧，哎~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我考上没有？显然没有，不然也不会在这码字（嘿哈）。考试前的一天我回到老家准备面试，到晚上整理东西的时候才发现身份证放学校没有带回来，去学校拿？很晚了，没有车来不及。办个临时的？来不及，第二天早上就开始面试。索性放弃算了，反正面试我也没准备，再说我是第三名翻盘的可能性不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样我的公务员梦碎了，历史的车轮又把我往编程路上拽。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;学生生涯最快乐的一段时光&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;9月份顺利入学，研究生也算是学生，所以我把我的身份锁定在学生而不是社会打工人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在以前的学生生涯我受够了管束，所以这次选导师我挑了一个没什么项目的导师，这也给我后面出去实习铺好了路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;研究生的课程很少，没有导师的管束，我又开始放飞自己了，没课的时候睡到自然醒，把以前没看的美剧、电影、动漫全部看完了，下午去打羽毛球，晚上去光谷步行街玩耍，周末骑山地车到处逛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在回想起来研一真的是我学生生涯中最快乐的一段时光。读小学那时候太小也不知道什么是快乐，读初中要努力学习考高中，读高中要努力考好大学，读大学我基本都是在学编程，也拿过国奖。只有研一我才真正放飞了自我。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了在学校玩，我还去了很多地方游玩：北京故宫、长城，上海外滩，杭州西湖，苏州园林，舟山东极岛，香港等，国外也去浪了一次：泰国七天游。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.3333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EoYOJAfcty2EMiad21mCPc0Dv9WdvceMvN07vFgbPTlTcKNuD5h9Ny3tfndon8YqeC9CjnL4Q1d4Sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;figcaption&gt;第一次出国旅游&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正所谓乐极生悲，研一太浪了导致我后面找实习和工作不断被毒打。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;我觉得我又行了&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;研二我就开始找实习了，刚开始不断被毒打，后面慢慢找到套路，拿到了很多 offer：网易、百度、华为、美团、斗鱼、某些国企。我居然成为了 offer 收割机，这部分留在后面单独开一讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于工作这部分我也打算放在后面一篇写，主要会涉及我在这些大厂实习和工作的趣事，以及后面我为什么会换工作，希望这些经历能给你的职业生涯带来帮助和启发。后面预计非常精彩，期待不~v~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;程序员高薪职业让爸妈在老家长脸了&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要问我工作后给家里带来的最大变化是什么？我可能要回答你是：&lt;strong&gt;面子&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面已经讲过我家是十八线县城下面的一个农村，家那边能出一个大学生可能都是大喜事，过去村的人问我爸：你儿子在哪里上班啊？我爸洋溢着微笑：华为（百度），虽然我已经从这些公司离职了。但是提起这些我爸还是很骄傲，我想这就是我给他们带来的精神上的财富吧。这就是”面子“的力量，让他们在同龄人的对比中长了脸。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于说到高薪，程序员确实赚的比较多，这是时代给的红利，不要以为是因为自己的努力，985高校的自动化机械专业的应届生薪资比程序员差远了。如果要算时薪，你去问问土木的同学加不加班。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我爸在外面跟别人说我的薪资时，村里的人都一脸惊讶：吹牛吧。反正我认为这就是酸了吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写到深夜了，写累了……&lt;/p&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;最后回答几个问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从大学到研究生到现在的工作，虽然中间有过波折，几度想放弃编程这条路，但是还是坚持下来了，我想把我的经验固化下来帮助到更多的人。至于说写公众号赚钱，至少我现在不会靠这个，未来怎么样不好说，毕竟赚钱不是一件丢人的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实是对我自己的鞭策，因为我不爱笑，也不是真正意义上的架构师，所以我取名叫”爱笑的架构师“，希望未来能笑对生活，努力成为被业界认可的架构师。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是我真正的名字，算是个笔名吧，我的名字中有一个”雷“，然后”架“是指架构师的意思，有点自恋，哈哈。后面也许会换个名字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面安排，等我先去烫个头发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为看文章的人都不分享点赞，说的就是你，三连安排一下（转发、点赞、在看）。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a230d0f515fd02aeb75838addbbf9b05</guid>
<title>从 Context 源码实现谈 React 性能优化</title>
<link>https://toutiao.io/k/l71evv1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;学完这篇文章，你会收获：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;了解&lt;code&gt;Context&lt;/code&gt;的实现原理&lt;br/&gt; &lt;/li&gt;&lt;li&gt;源码层面掌握&lt;code&gt;React&lt;/code&gt;组件的&lt;code&gt;render&lt;/code&gt;时机，从而写出高性能的&lt;code&gt;React&lt;/code&gt;组件&lt;br/&gt; &lt;/li&gt;&lt;li&gt;源码层面了解&lt;code&gt;shouldComponentUpdate&lt;/code&gt;、&lt;code&gt;React.memo&lt;/code&gt;、&lt;code&gt;PureComponent&lt;/code&gt;等性能优化手段的实现&lt;br/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我会尽量将文章写的通俗易懂。但是，要完全理解文章内容，需要你掌握这些前置知识：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;Fiber&lt;/code&gt;架构的大体工作流程&lt;br/&gt; &lt;/li&gt;&lt;li&gt;&lt;code&gt;优先级&lt;/code&gt;与&lt;code&gt;更新&lt;/code&gt;在&lt;code&gt;React&lt;/code&gt;源码中的意义&lt;br/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果你还不具备前置知识，可以先阅读&lt;b&gt;React技术揭秘[1]&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;组件render的时机&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Context&lt;/code&gt;的实现与组件的&lt;code&gt;render&lt;/code&gt;息息相关。在讲解其实现前，我们先来了解&lt;code&gt;render&lt;/code&gt;的时机。&lt;/p&gt;&lt;p&gt;换句话说，&lt;code&gt;组件&lt;/code&gt;在什么时候&lt;code&gt;render&lt;/code&gt;？&lt;/p&gt;&lt;p&gt;这个问题的答案，已经在&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU0MDg4NDY2Mg%3D%3D%26mid%3D2247484376%26idx%3D1%26sn%3D0edb7c9857ba4603dfc410d5aaafe878%26chksm%3Dfb332801cc44a1173f705fa67ff5d3ea2788ed1df6765e9760b0936375b7acf38d5503f73f9a%26token%3D583298442%26lang%3Dzh_CN%23rd&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;React组件到底什么时候render啊 &lt;/a&gt;&lt;/b&gt;聊过。在这里再概括下：&lt;/p&gt;&lt;p&gt;在&lt;code&gt;React&lt;/code&gt;中，每当触发&lt;code&gt;更新&lt;/code&gt;（比如调用&lt;code&gt;this.setState&lt;/code&gt;、&lt;code&gt;useState&lt;/code&gt;），会为组件创建对应的&lt;code&gt;fiber&lt;/code&gt;节点。&lt;/p&gt;&lt;p&gt;&lt;code&gt;fiber&lt;/code&gt;节点互相链接形成一棵&lt;code&gt;Fiber&lt;/code&gt;树。&lt;/p&gt;&lt;p&gt;有2种方式创建&lt;code&gt;fiber&lt;/code&gt;节点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;bailout&lt;/code&gt;，即复用前一次更新该组件对应的&lt;code&gt;fiber&lt;/code&gt;节点作为本次更新的&lt;code&gt;fiber&lt;/code&gt;节点。&lt;br/&gt; &lt;/li&gt;&lt;li&gt;&lt;code&gt;render&lt;/code&gt;，经过diff算法后生成一个新&lt;code&gt;fiber&lt;/code&gt;节点。组件的&lt;code&gt;render&lt;/code&gt;（比如&lt;code&gt;ClassComponent&lt;/code&gt;的&lt;code&gt;render&lt;/code&gt;方法调用、&lt;code&gt;FunctionComponent&lt;/code&gt;的执行）就发生在这一步。&lt;br/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;经常有同学问：&lt;code&gt;React&lt;/code&gt;每次更新都会重新生成一棵&lt;code&gt;Fiber&lt;/code&gt;树，性能不会差么？&lt;/p&gt;&lt;p&gt;&lt;code&gt;React&lt;/code&gt;性能确实不算很棒。但如你所见，&lt;code&gt;Fiber&lt;/code&gt;树生成过程中并不是所有组件都会&lt;code&gt;render&lt;/code&gt;，有些满足优化条件的组件会走&lt;code&gt;bailout&lt;/code&gt;逻辑。&lt;/p&gt;&lt;p&gt;比如，对于如下Demo：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function Son() {
  console.log(&#x27;child render!&#x27;);
  return &amp;lt;div&amp;gt;Son&amp;lt;/div&amp;gt;;
}


function Parent(props) {
  const [count, setCount] = React.useState(0);

  return (
    &amp;lt;div onClick={() =&amp;gt; {setCount(count + 1)}}&amp;gt;
      count:{count}
      {props.children}
    &amp;lt;/div&amp;gt;
  );
}


function App() {
  return (
    &amp;lt;Parent&amp;gt;
      &amp;lt;Son/&amp;gt;
    &amp;lt;/Parent&amp;gt;
  );
}

const rootEl = document.querySelector(&quot;#root&quot;);
ReactDOM.render(&amp;lt;App/&amp;gt;, rootEl);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;在线Demo地址[2]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;点击&lt;code&gt;Parent&lt;/code&gt;组件的&lt;code&gt;div&lt;/code&gt;子组件，触发更新，但是&lt;code&gt;child render!&lt;/code&gt;并不会打印。&lt;/p&gt;&lt;p&gt;这是因为&lt;code&gt;Son&lt;/code&gt;组件会进入&lt;code&gt;bailout&lt;/code&gt;逻辑。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;bailout的条件&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;要进入&lt;code&gt;bailout&lt;/code&gt;逻辑，需&lt;b&gt;同时&lt;/b&gt;满足4个条件：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;oldProps === newProps&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;即本次更新的&lt;code&gt;props&lt;/code&gt;全等于上次更新的&lt;code&gt;props&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意这里是&lt;b&gt;全等比较&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们知道组件&lt;code&gt;render&lt;/code&gt;会返回&lt;code&gt;JSX&lt;/code&gt;，&lt;code&gt;JSX&lt;/code&gt;是&lt;code&gt;React.createElement&lt;/code&gt;的语法糖。&lt;/p&gt;&lt;p&gt;所以&lt;code&gt;render&lt;/code&gt;的返回结果实际上是&lt;code&gt;React.createElement&lt;/code&gt;的执行结果，即一个包含&lt;code&gt;props&lt;/code&gt;属性的对象。&lt;/p&gt;&lt;p&gt;即使本次更新与上次更新&lt;code&gt;props&lt;/code&gt;中每一项参数都没有变化，但是本次更新是&lt;code&gt;React.createElement&lt;/code&gt;的执行结果，是一个全新的&lt;code&gt;props&lt;/code&gt;引用，所以&lt;code&gt;oldProps !== newProps&lt;/code&gt;。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;context value&lt;/code&gt;没有变化&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们知道在当前&lt;code&gt;React&lt;/code&gt;版本中，同时存在新老两种&lt;code&gt;context&lt;/code&gt;，这里指老版本&lt;code&gt;context&lt;/code&gt;。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;workInProgress.type === current.type&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;更新前后&lt;code&gt;fiber.type&lt;/code&gt;不变，比如&lt;code&gt;div&lt;/code&gt;没变为&lt;code&gt;p&lt;/code&gt;。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;!includesSomeLane(renderLanes, updateLanes) ？&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当前&lt;code&gt;fiber&lt;/code&gt;上是否存在&lt;code&gt;更新&lt;/code&gt;，如果存在那么&lt;code&gt;更新&lt;/code&gt;的&lt;code&gt;优先级&lt;/code&gt;是否和本次整棵&lt;code&gt;Fiber&lt;/code&gt;树调度的&lt;code&gt;优先级&lt;/code&gt;一致？&lt;/p&gt;&lt;p&gt;如果一致代表该组件上存在更新，需要走&lt;code&gt;render&lt;/code&gt;逻辑。&lt;/p&gt;&lt;p&gt;&lt;code&gt;bailout&lt;/code&gt;的优化还不止如此。如果一棵&lt;code&gt;fiber&lt;/code&gt;子树所有节点都没有更新，即使所有子孙&lt;code&gt;fiber&lt;/code&gt;都走&lt;code&gt;bailout&lt;/code&gt;逻辑，还是有遍历的成本。&lt;/p&gt;&lt;p&gt;所以，在&lt;code&gt;bailout&lt;/code&gt;中，会检查该&lt;code&gt;fiber&lt;/code&gt;的所有子孙&lt;code&gt;fiber&lt;/code&gt;是否满足条件4（该检查时间复杂度&lt;code&gt;O(1)&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;如果所有子孙&lt;code&gt;fiber&lt;/code&gt;本次都没有更新需要执行，则&lt;code&gt;bailout&lt;/code&gt;会直接返回&lt;code&gt;null&lt;/code&gt;。整棵子树都被跳过。&lt;/p&gt;&lt;p&gt;不会&lt;code&gt;bailout&lt;/code&gt;也不会&lt;code&gt;render&lt;/code&gt;，就像不存在一样。对应的DOM不会产生任何变化。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;老Context API的实现&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在我们大体了解了&lt;code&gt;render&lt;/code&gt;的时机。有了这个概念，就能理解&lt;code&gt;Context&lt;/code&gt;API是如何实现的，以及为什么被重构。&lt;/p&gt;&lt;p&gt;我们先看被废弃的老&lt;code&gt;Context&lt;/code&gt;API的实现。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Fiber&lt;/code&gt;树的生成过程是通过遍历实现的可中断&lt;b&gt;递归&lt;/b&gt;，所以分为&lt;b&gt;递&lt;/b&gt;和&lt;b&gt;归&lt;/b&gt;2个阶段。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Context&lt;/code&gt;对应数据会保存在栈中。&lt;/p&gt;&lt;p&gt;在&lt;b&gt;递&lt;/b&gt;阶段，&lt;code&gt;Context&lt;/code&gt;不断入栈。所以&lt;code&gt;Concumer&lt;/code&gt;可以通过&lt;code&gt;Context栈&lt;/code&gt;向上找到对应的&lt;code&gt;context value&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在&lt;b&gt;归&lt;/b&gt;阶段，&lt;code&gt;Context&lt;/code&gt;不断出栈。&lt;/p&gt;&lt;p&gt;那么老&lt;code&gt;Context&lt;/code&gt;API为什么被废弃呢？因为他没法和&lt;code&gt;shouldComponentUpdate&lt;/code&gt;或&lt;code&gt;Memo&lt;/code&gt;等性能优化手段配合。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;shouldComponentUpdate的实现&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;要探究更深层的原因，我们需要了解&lt;code&gt;shouldComponentUpdate&lt;/code&gt;的原理，后文简称其为&lt;code&gt;SCU&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;使用&lt;code&gt;SCU&lt;/code&gt;是为了减少不必要的&lt;code&gt;render&lt;/code&gt;，换句话说：让本该&lt;code&gt;render&lt;/code&gt;的组件走&lt;code&gt;bailout&lt;/code&gt;逻辑。&lt;/p&gt;&lt;p&gt;刚才我们介绍了&lt;code&gt;bailout&lt;/code&gt;需要满足的条件。那么&lt;code&gt;SCU&lt;/code&gt;是作用于这4个条件的哪个呢？&lt;/p&gt;&lt;p&gt;显然是第一条：&lt;code&gt;oldProps === newProps&lt;/code&gt;&lt;/p&gt;&lt;p&gt;当使用&lt;code&gt;shouldComponentUpdate&lt;/code&gt;，这个组件&lt;code&gt;bailout&lt;/code&gt;的条件会产生变化：&lt;/p&gt;&lt;p&gt;-- &lt;code&gt;oldProps === newProps&lt;/code&gt;&lt;/p&gt;&lt;p&gt;++ &lt;code&gt;SCU === false&lt;/code&gt;&lt;/p&gt;&lt;p&gt;同理，使用&lt;code&gt;PureComponenet&lt;/code&gt;和&lt;code&gt;React.memo&lt;/code&gt;时，&lt;code&gt;bailout&lt;/code&gt;的条件也会产生变化：&lt;/p&gt;&lt;p&gt;-- &lt;code&gt;oldProps === newProps&lt;/code&gt;&lt;/p&gt;&lt;p&gt;++ &lt;code&gt;浅比较oldProps与newsProps相等&lt;/code&gt;&lt;/p&gt;&lt;p&gt;回到老&lt;code&gt;Context&lt;/code&gt;API。&lt;/p&gt;&lt;p&gt;当这些性能优化手段：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使组件命中&lt;code&gt;bailout&lt;/code&gt;逻辑&lt;br/&gt; &lt;/li&gt;&lt;li&gt;同时如果组件的子树都满足&lt;code&gt;bailout&lt;/code&gt;的条件4&lt;br/&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么该&lt;code&gt;fiber&lt;/code&gt;子树不会再继续遍历生成。&lt;/p&gt;&lt;p&gt;换言之，不会再经历&lt;code&gt;Context&lt;/code&gt;的入栈、出栈。&lt;/p&gt;&lt;p&gt;这种情况下，即使&lt;code&gt;context value&lt;/code&gt;变化，子孙组件也没法检测到。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;新Context API的实现&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;知道老&lt;code&gt;Context&lt;/code&gt;API的缺陷，我们再来看新&lt;code&gt;Context&lt;/code&gt;API是如何实现的。&lt;/p&gt;&lt;p&gt;当通过：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;ctx = React.createContext();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建&lt;code&gt;context&lt;/code&gt;实例后，需要使用&lt;code&gt;Provider&lt;/code&gt;提供&lt;code&gt;value&lt;/code&gt;，使用&lt;code&gt;Consumer&lt;/code&gt;或&lt;code&gt;useContext&lt;/code&gt;订阅&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;ctx = React.createContext();

const NumProvider = ({children}) =&amp;gt; {
  const [num, add] = useState(0);

  return (
    &amp;lt;Ctx.Provider value={num}&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; add(num + 1)}&amp;gt;add&amp;lt;/button&amp;gt;
      {children}
    &amp;lt;/Ctx.Provider&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const Child = () =&amp;gt; {
  const {num} = useContext(Ctx);
  return &amp;lt;p&amp;gt;{num}&amp;lt;/p&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当遍历组件生成对应&lt;code&gt;fiber&lt;/code&gt;时，遍历到&lt;code&gt;Ctx.Provider&lt;/code&gt;组件，&lt;code&gt;Ctx.Provider&lt;/code&gt;内部会判断&lt;code&gt;context value&lt;/code&gt;是否变化。&lt;/p&gt;&lt;p&gt;如果&lt;code&gt;context value&lt;/code&gt;变化，&lt;code&gt;Ctx.Provider&lt;/code&gt;内部会执行一次向下深度优先遍历子树的操作，寻找与该&lt;code&gt;Provider&lt;/code&gt;配套的&lt;code&gt;Consumer&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在上文的例子中会最终找到&lt;code&gt;useContext(Ctx)&lt;/code&gt;的&lt;code&gt;Child&lt;/code&gt;组件对应的&lt;code&gt;fiber&lt;/code&gt;，&lt;b&gt;并为该&lt;code&gt;fiber&lt;/code&gt;触发一次更新。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;注意这里的实现非常巧妙：&lt;/p&gt;&lt;p&gt;一般&lt;code&gt;更新&lt;/code&gt;是由组件调用触发更新的方法产生。比如上文的&lt;code&gt;NumProvider&lt;/code&gt;组件，点击&lt;code&gt;button&lt;/code&gt;调用&lt;code&gt;add&lt;/code&gt;会触发一次&lt;code&gt;更新&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;触发&lt;code&gt;更新&lt;/code&gt;的本质是为了让组件创建对应&lt;code&gt;fiber&lt;/code&gt;时不满足&lt;code&gt;bailout&lt;/code&gt;条件4：&lt;/p&gt;&lt;p&gt;&lt;code&gt;!includesSomeLane(renderLanes, updateLanes) ？&lt;/code&gt;&lt;/p&gt;&lt;p&gt;从而进入&lt;code&gt;render&lt;/code&gt;逻辑。&lt;/p&gt;&lt;p&gt;在这里，&lt;code&gt;Ctx.Provider&lt;/code&gt;中&lt;code&gt;context value&lt;/code&gt;变化，&lt;code&gt;Ctx.Provider&lt;/code&gt;向下找到消费&lt;code&gt;context value&lt;/code&gt;的组件&lt;code&gt;Child&lt;/code&gt;，为其&lt;code&gt;fiber&lt;/code&gt;触发一次更新。&lt;/p&gt;&lt;p&gt;则&lt;code&gt;Child&lt;/code&gt;对应&lt;code&gt;fiber&lt;/code&gt;就不满足条件4。&lt;/p&gt;&lt;p&gt;这就解决了老&lt;code&gt;Context&lt;/code&gt;API的问题：&lt;/p&gt;&lt;p&gt;由于&lt;code&gt;Child&lt;/code&gt;对应&lt;code&gt;fiber&lt;/code&gt;不满足条件4，所以从&lt;code&gt;Ctx.Provider&lt;/code&gt;到&lt;code&gt;Child&lt;/code&gt;，这棵子树没法满足：&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;!! &lt;/i&gt;子树中所有子孙节点都满足条件4&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;所以即使遍历中途有组件进入&lt;code&gt;bailout&lt;/code&gt;逻辑，也不会返回&lt;code&gt;null&lt;/code&gt;，即不会无视这棵子树的遍历。&lt;/p&gt;&lt;p&gt;最终遍历进行到&lt;code&gt;Child&lt;/code&gt;，由于其不满足条件4，会进入&lt;code&gt;render&lt;/code&gt;逻辑，调用组件对应函数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;const Child = () =&amp;gt; {
  const {num} = useContext(Ctx);
  return &amp;lt;p&amp;gt;{num}&amp;lt;/p&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在函数调用中会调用&lt;code&gt;useContext&lt;/code&gt;从&lt;code&gt;Context&lt;/code&gt;栈中找到对应更新后的&lt;code&gt;context value&lt;/code&gt;并返回。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;React&lt;/code&gt;性能一大关键在于：减少不必要的&lt;code&gt;render&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;从上文我们看到，本质就是让组件满足4个条件，从而进入&lt;code&gt;bailout&lt;/code&gt;逻辑。&lt;/p&gt;&lt;p&gt;而&lt;code&gt;Context&lt;/code&gt;API本质是让&lt;code&gt;Consumer&lt;/code&gt;组件不满足条件4。&lt;/p&gt;&lt;p&gt;我们也知道了，&lt;code&gt;React&lt;/code&gt;虽然每次都会遍历整棵树，但会有&lt;code&gt;bailout&lt;/code&gt;的优化逻辑，不是所有组件都会&lt;code&gt;render&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;极端情况下，甚至某些子树会被跳过遍历（&lt;code&gt;bailout&lt;/code&gt;返回&lt;code&gt;null&lt;/code&gt;）。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;参考资料&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;[1] &lt;/p&gt;&lt;p&gt;React技术揭秘: &lt;i&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//react.iamkasong.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;react.iamkasong.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;[2] &lt;/p&gt;&lt;p&gt;在线Demo地址: &lt;i&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//codesandbox.io/s/quirky-chaplygin-5bx67%3Ffile%3D/src/App.js&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;codesandbox.io/s/quirky&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;-chaplygin-5bx67?file=/src/App.js&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>