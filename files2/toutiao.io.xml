<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b7efbe6b98edc47e9a626d671c05b365</guid>
<title>单例模式，真不简单</title>
<link>https://toutiao.io/k/v6oak4s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式无论在我们面试，还是日常工作中，都会面对的问题。但很多单例模式的细节，值得我们深入探索一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章透过单例模式，串联了多方面基础知识，非常值得一读。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100006861&quot; data-ratio=&quot;0.9048582995951417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEML7uGjLRAu2ocfCvVvm0NhHPNAo9RnSQSmIbpibBK4y11WPics2GlSfOoX21PHIEKU35XNiccHhJ8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 什么是单例模式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;单例模式&lt;/code&gt;是一种非常常用的软件设计模式，它定义是单例对象的类&lt;code&gt;只能允许一个实例存在&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类负责创建自己的对象，同时确保只有一个对象被创建。一般常用在工具类的实现或创建对象需要消耗资源的业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单例模式的特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;类构造器私有&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持有自己类的引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对外提供获取实例的静态方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先用一个简单示例了解一下单例模式的用法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(SimpleSingleton.getInstance().hashCode());&lt;br/&gt;        System.out.println(SimpleSingleton.getInstance().hashCode());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1639705018&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1639705018&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到两次获取SimpleSingleton实例的hashCode是一样的，说明两次调用获取到的是同一个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能很多朋友平时工作当中都是这么用的，但我要说这段代码是有问题的，你会相信吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不信，我们一起往下看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 饿汉和懒汉模式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍单例模式的时候，必须要先介绍它的两种非常著名的实现方式：&lt;code&gt;饿汉模式&lt;/code&gt; 和 &lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 饿汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例在初始化的时候就已经建好了，不管你有没有用到，先建好了再说。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;饿汉模式，其实还有一个变种：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;       INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用静态代码块的方式实例化INSTANCE对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用饿汉模式的好处是：&lt;code&gt;没有线程安全的问题&lt;/code&gt;，但带来的坏处也很明显。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始就实例化对象了，如果实例化过程非常耗时，并且最后这个对象没有被使用，不是白白造成资源浪费吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真是啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候你也许会想到，不用提前实例化对象，在真正使用的时候再实例化不就可以了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我接下来要介绍的：&lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 懒汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton2();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯，不错不错。但这段代码还是有问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.3 synchronized关键字&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码有什么问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：假如有多个线程中都调用了getInstance方法，那么都走到 if (INSTANCE == null) 判断时，可能同时成立，因为INSTANCE初始化时默认值是null。这样会导致多个线程中同时创建INSTANCE对象，即INSTANCE对象被创建了多次，违背了只创建一个INSTANCE对象的初衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，要如何改进呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：最简单的办法就是使用&lt;code&gt;synchronized&lt;/code&gt;关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改进后的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton3 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton3 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton3();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(SimpleSingleton3.getInstance().hashCode());&lt;br/&gt;        System.out.println(SimpleSingleton3.getInstance().hashCode());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在getInstance方法上加&lt;code&gt;synchronized&lt;/code&gt;关键字，保证在并发的情况下，只有一个线程能创建INSTANCE对象的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样总可以了吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：不好意思，还是有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有什么问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用synchronized关键字会消耗getInstance方法的性能，我们应该判断当INSTANCE为空时才加锁，如果不为空不应该加锁，需要直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要使用下面要说的双重检查锁了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.4 饿汉和懒汉模式的区别&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;but，在介绍双重检查锁之前，先插播一个朋友们可能比较关心的话题：饿汉模式 和 懒汉模式 各有什么优缺点？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;饿汉模式&lt;/code&gt;：优点是没有线程安全的问题，缺点是浪费内存空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;懒汉模式&lt;/code&gt;：优点是没有内存空间浪费的问题，缺点是如果控制不好，实际上不是单例的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，下面可以安心的看看双重检查锁，是如何保证性能的，同时又保证单例的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 双重检查锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重检查锁顾名思义会检查两次：在加锁之前检查一次是否为空，加锁之后再检查一次是否为空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，它是如何实现单例的呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 如何实现单例？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton4&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在加锁之前判断是否为空，可以确保INSTANCE不为空的情况下，不用加锁，可以直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么在加锁之后，还需要判断INSTANCE是否为空呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：是为了防止在多线程并发的情况下，只会实例化一个对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：线程a和线程b同时调用getInstance方法，假如同时判断INSTANCE都为空，这时会同时进行抢锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如线程a先抢到锁，开始执行synchronized关键字包含的代码，此时线程b处于等待状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程a创建完新实例了，释放锁了，此时线程b拿到锁，进入synchronized关键字包含的代码，如果没有再判断一次INSTANCE是否为空，则可能会重复创建实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以需要在synchronized前后两次判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要以为这样就完了，还有问题呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 volatile关键字&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码还有啥问题？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//1&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;                  INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;              }&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getInstance方法的这段代码，我是按1、2、3、4、5这种顺序写的，希望也按这个顺序执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是java虚拟机实际上会做一些优化，对一些代码指令进行重排。重排之后的顺序可能就变成了：1、3、2、4、5，这样在多线程的情况下同样会创建多次实例。重排之后的代码可能如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//1&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;                INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来如此，那有什么办法可以解决呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：可以在定义INSTANCE是加上&lt;code&gt;volatile&lt;/code&gt;关键字。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton7&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton7 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton7&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton7 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton7&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton7();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;volatile&lt;/code&gt;关键字可以保证多个线程的可见性，但是不能保证原子性。同时它也能禁止指令重排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重检查锁的机制既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的单例模式之外，还有没有其他的单例模式？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 静态内部类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态内部类顾名思义是通过静态的内部类来实现单例模式的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，它是如何实现单例的呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 如何实现单例模式？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton5&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton5&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton5 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Inner.INSTANCE;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Inner&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton5 INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton5();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到在SimpleSingleton5类中定义了一个静态的内部类Inner。在SimpleSingleton5类的getInstance方法中，返回的是内部类Inner的实例INSTANCE对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有在程序第一次调用getInstance方法时，虚拟机才加载Inner并实例化INSTANCE对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java内部机制保证了，只有一个线程可以获得对象锁，其他的线程必须等待，保证对象的唯一性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 反射漏洞&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码看似完美，但还是有漏洞。如果其他人使用&lt;code&gt;反射&lt;/code&gt;，依然能够通过类的无参构造方式创建对象。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Class&amp;lt;SimpleSingleton5&amp;gt; simpleSingleton5Class = SimpleSingleton5&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    SimpleSingleton5 newInstance = simpleSingleton5Class.newInstance();&lt;br/&gt;    System.out.println(newInstance == SimpleSingleton5.getInstance());&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InstantiationException e) {&lt;br/&gt;    e.printStackTrace();&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (IllegalAccessException e) {&lt;br/&gt;    e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码打印结果是false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此看出，通过反射创建的对象，跟通过getInstance方法获取的对象，并非同一个对象，也就是说，这个漏洞会导致SimpleSingleton5非单例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，要如何防止这个漏洞呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：这就需要在无参构造方式中判断，如果非空，则抛出异常了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton5&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton5&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(Inner.INSTANCE != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;           &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;不能支持重复实例化&quot;&lt;/span&gt;);&lt;br/&gt;       }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton5 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Inner.INSTANCE;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Inner&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton5 INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton5();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时，你认为这种静态内部类，实现单例模式的方法，已经完美了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我要告诉你的是，你错了，还有漏洞。。。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.3 反序列化漏洞&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，java中的类通过实现&lt;code&gt;Serializable&lt;/code&gt;接口，可以实现序列化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以把类的对象先保存到内存，或者某个文件当中。后面在某个时刻，再恢复成原始对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton5&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton5&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (Inner.INSTANCE != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;不能支持重复实例化&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton5 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Inner.INSTANCE;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Inner&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton5 INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton5();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeFile&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FileOutputStream fos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        ObjectOutputStream oos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            SimpleSingleton5 simpleSingleton5 = SimpleSingleton5.getInstance();&lt;br/&gt;            fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;));&lt;br/&gt;            oos = &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(fos);&lt;br/&gt;            oos.writeObject(simpleSingleton5);&lt;br/&gt;            System.out.println(simpleSingleton5.hashCode());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (FileNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (oos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    oos.close();&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    fos.close();&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FileInputStream fis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        ObjectInputStream ois = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;));&lt;br/&gt;            ois = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(fis);&lt;br/&gt;            SimpleSingleton5 myObject = (SimpleSingleton5) ois.readObject();&lt;br/&gt;&lt;br/&gt;            System.out.println(myObject.hashCode());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (FileNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ois != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    ois.close();&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    fis.close();&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        writeFile();&lt;br/&gt;        readFile();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行之后，发现序列化和反序列化后对象的hashCode不一样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;189568618&lt;/span&gt;&lt;br/&gt;&lt;span&gt;793589513&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明，反序列化时创建了一个新对象，打破了单例模式对象唯一性的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：重新readResolve方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的实例中，增加如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Object &lt;span&gt;readResolve&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ObjectStreamException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Inner.INSTANCE;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;290658609&lt;/span&gt;&lt;br/&gt;&lt;span&gt;290658609&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到序列化和反序列化实例对象的hashCode相同了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做法很简单，只需要在readResolve方法中，每次都返回唯一的Inner.INSTANCE对象即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序在反序列化获取对象时，会去寻找readResolve()方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果该方法不存在，则直接返回新对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果该方法存在，则按该方法的内容返回对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果我们之前没有实例化单例对象，则会返回null。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，到这来终于把坑都踩完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是费了不少劲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，我偷偷告诉你一句，其实还有更简单的方法，哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;纳尼。。。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 枚举&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在java中枚举就是天然的单例，每一个实例只有一个对象，这是java底层内部机制保证的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的用法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;  SimpleSingleton7 {&lt;br/&gt;    INSTANCE;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;doSamething&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在调用的地方：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton7Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SimpleSingleton7.INSTANCE.doSamething();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在枚举中实例对象INSTANCE是唯一的，所以它是天然的单例模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，在枚举对象唯一性的这个特性，还能创建其他的单例对象，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;  SimpleSingleton7 {&lt;br/&gt;    INSTANCE;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Student instance;&lt;br/&gt;    &lt;br/&gt;    SimpleSingleton7() {&lt;br/&gt;       instance = &lt;span&gt;new&lt;/span&gt; Student();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Student &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jvm保证了枚举是天然的单例，并且不存在线程安全问题，此外，还支持序列化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java大神Joshua Bloch的经典书籍《Effective Java》中说过：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;单元素的枚举类型已经成为实现Singleton的最佳方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 多例模式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们之前聊过的单例模式，都只会产生一个实例。但它其实还有一个变种，也就是我们接下来要聊的：&lt;code&gt;多例模式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多例模式顾名思义，它允许创建多个实例。但它的初衷是为了控制实例的个数，其他的跟单例模式差不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleMultiPattern&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleMultiPattern INSTANCE1 = &lt;span&gt;new&lt;/span&gt; SimpleMultiPattern();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleMultiPattern INSTANCE2 = &lt;span&gt;new&lt;/span&gt; SimpleMultiPattern();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleMultiPattern&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleMultiPattern &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; type)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(type == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; INSTANCE1;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE2;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了看起来更直观，我把一些额外的安全相关代码去掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些朋友可能会说：既然多例模式也是为了控制实例数量，那我们常见的&lt;code&gt;池技术&lt;/code&gt;，比如：数据库连接池，是不是通过多例模式实现的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：不，它是通过&lt;code&gt;享元模式&lt;/code&gt;实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，多例模式和享元模式有什么区别？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多例模式：跟单例模式一样，纯粹是为了控制实例数量，使用这种模式的类，通常是作为程序某个模块的入口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;享元模式：它的侧重点是对象之间的衔接。它把动态的、会变化的状态剥离出来，共享不变的东西。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 真实使用场景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，跟大家一起聊聊，单例模式的一些使用场景。我们主要看看在java的框架中，是如何使用单例模式，给有需要的朋友一个参考。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.1 Runtime&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk提供了&lt;code&gt;Runtime&lt;/code&gt;类，我们可以通过这个类获取系统的运行状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如可以通过它获取cpu核数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; availableProcessors = Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Runtime&lt;/code&gt;类的关键代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Runtime&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Runtime currentRuntime = &lt;span&gt;new&lt;/span&gt; Runtime();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Runtime &lt;span&gt;getRuntime&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; currentRuntime;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Runtime&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的代码我们可以看出，这是一个单例模式，并且是饿汉模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但根据文章之前讲过的一些理论知识，你会发现Runtime类的这种单例模式实现方式，显然不太好。实例对象既没用&lt;code&gt;final&lt;/code&gt;关键字修饰，也没考虑对象实例化的性能消耗问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过它的优点是实现起来非常简单。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.2 NamespaceHandlerResolver&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring提供的DefaultNamespaceHandlerResolver是为需要初始化默认命名空间处理器，是为了方便后面做标签解析用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的关键代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Nullable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; handlerMappings;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; &lt;span&gt;getHandlerMappings&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Map&amp;lt;String, Object&amp;gt; handlerMappings = &lt;span&gt;this&lt;/span&gt;.handlerMappings;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (handlerMappings == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;    handlerMappings = &lt;span&gt;this&lt;/span&gt;.handlerMappings;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (handlerMappings == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (logger.isDebugEnabled()) {&lt;br/&gt;      logger.debug(&lt;span&gt;&quot;Loading NamespaceHandler mappings from [&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.handlerMappingsLocation + &lt;span&gt;&quot;]&quot;&lt;/span&gt;);&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      Properties mappings =&lt;br/&gt;        PropertiesLoaderUtils.loadAllProperties(&lt;span&gt;this&lt;/span&gt;.handlerMappingsLocation, &lt;span&gt;this&lt;/span&gt;.classLoader);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (logger.isDebugEnabled()) {&lt;br/&gt;       logger.debug(&lt;span&gt;&quot;Loaded NamespaceHandler mappings: &quot;&lt;/span&gt; + mappings);&lt;br/&gt;      }&lt;br/&gt;      handlerMappings = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(mappings.size());&lt;br/&gt;      CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.handlerMappings = handlerMappings;&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;catch&lt;/span&gt; (IOException ex) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;br/&gt;        &lt;span&gt;&quot;Unable to load NamespaceHandler mappings from location [&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.handlerMappingsLocation + &lt;span&gt;&quot;]&quot;&lt;/span&gt;, ex);&lt;br/&gt;     }&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; handlerMappings;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到它使用了双重检测锁，并且还定义了一个局部变量handlerMappings，这是非常高明之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用局部变量相对于不使用局部变量，可以提高性能。主要是由于 volatile 变量创建对象时需要禁止指令重排序，需要一些额外的操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.3 LogFactory&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mybatis提供&lt;code&gt;LogFactory&lt;/code&gt;类是为了创建日志对象，根据引入的jar包，决定使用哪种方式打印日志。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MARKER = &lt;span&gt;&quot;MYBATIS&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Constructor&amp;lt;? extends Log&amp;gt; logConstructor;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;    tryImplementation(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        useSlf4jLogging();&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    tryImplementation(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        useCommonsLogging();&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    tryImplementation(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        useLog4J2Logging();&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    tryImplementation(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        useLog4JLogging();&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    tryImplementation(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        useJdkLogging();&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    tryImplementation(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        useNoLogging();&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;LogFactory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// disable construction&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log &lt;span&gt;getLog&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; aClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; getLog(aClass.getName());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log &lt;span&gt;getLog&lt;/span&gt;&lt;span&gt;(String logger)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; logConstructor.newInstance(logger);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogException(&lt;span&gt;&quot;Error creating logger for logger &quot;&lt;/span&gt; + logger + &lt;span&gt;&quot;.  Cause: &quot;&lt;/span&gt; + t, t);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useCustomLogging&lt;/span&gt;&lt;span&gt;(Class&amp;lt;? extends Log&amp;gt; clazz)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(clazz);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useSlf4jLogging&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useCommonsLogging&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useLog4JLogging&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(org.apache.ibatis.logging.log4j.Log4jImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useLog4J2Logging&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(org.apache.ibatis.logging.log4j2.Log4j2Impl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useJdkLogging&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useStdOutLogging&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(org.apache.ibatis.logging.stdout.StdOutImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;useNoLogging&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    setImplementation(org.apache.ibatis.logging.nologging.NoLoggingImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;tryImplementation&lt;/span&gt;&lt;span&gt;(Runnable runnable)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (logConstructor == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        runnable.run();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;        &lt;span&gt;// ignore&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setImplementation&lt;/span&gt;&lt;span&gt;(Class&amp;lt;? extends Log&amp;gt; implClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      Constructor&amp;lt;? extends Log&amp;gt; candidate = implClass.getConstructor(String&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;      Log log = candidate.newInstance(LogFactory&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;Logging initialized using &#x27;&quot;&lt;/span&gt; + implClass + &lt;span&gt;&quot;&#x27; adapter.&quot;&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;      logConstructor = candidate;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogException(&lt;span&gt;&quot;Error setting Log implementation.  Cause: &quot;&lt;/span&gt; + t, t);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码非常经典，但它却是一个不走寻常路的单例模式。因为它创建的实例对象，可能存在多种情况，根据引入不同的jar包，加载不同的类创建实例对象。如果有一个创建成功，则用它作为整个类的实例对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个非常巧妙的地方是：使用了很多tryImplementation方法，方便后面进行扩展。不然要写很多，又臭又长的if...else判断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，它跟常规的单例模式的区别是，LogFactory类中定义的实例对象是Log类型，并且getLog方法返回的参数类型也是Log，不是LogFactory。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的一点是：getLog方法中是通过构造器的newInstance方法创建的实例对象，每次请求getLog方法都会返回一个新的实例，它其实是一个多例模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.4 ErrorContext&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mybatis提供&lt;code&gt;ErrorContext&lt;/code&gt;类记录了错误信息的上下文，方便后续处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么它是如何实现单例模式的呢？关键代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ErrorContext&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;ErrorContext&amp;gt; LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;ErrorContext&amp;gt;();&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;ErrorContext&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ErrorContext &lt;span&gt;instance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ErrorContext context = LOCAL.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (context == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      context = &lt;span&gt;new&lt;/span&gt; ErrorContext();&lt;br/&gt;      LOCAL.set(context);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; context;&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，ErrorContext跟传统的单例模式不一样，它改良了一下。它使用了饿汉模式，并且使用&lt;code&gt;ThreadLocal&lt;/code&gt;，保证每个线程中的实例对象是单例的。这样看来，ErrorContext类创建的对象不是唯一的，它其实也是多例模式的一种。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.5 spring的单例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前在spring中要定义一个bean，需要在xml文件中做如下配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;bean id=&lt;span&gt;&quot;test&quot;&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;com.susan.Test&quot;&lt;/span&gt; init-method=&lt;span&gt;&quot;init&quot;&lt;/span&gt; scope=&lt;span&gt;&quot;singleton&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在bean标签上有个&lt;code&gt;scope&lt;/code&gt;属性，我们可以通过指定该属性控制bean实例是单例的，还是多例的。如果值为&lt;code&gt;singleton&lt;/code&gt;，代表是单例的。当然如果该参数不指定，默认也是单例的。如果值为&lt;code&gt;prototype&lt;/code&gt;，则代表是多例的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spring的&lt;code&gt;AbstractBeanFactory&lt;/code&gt;类的&lt;code&gt;doGetBean&lt;/code&gt;方法中，有这样一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (mbd.isSingleton()) {&lt;br/&gt;    sharedInstance = getSingleton(beanName, () -&amp;gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; createBean(beanName, mbd, args);&lt;br/&gt;  });&lt;br/&gt;  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mbd.isPrototype()) {&lt;br/&gt;    Object prototypeInstance = createBean(beanName, mbd, args);&lt;br/&gt;    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    ....&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码我为了好演示，看起来更清晰，我特地简化过的。它的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断如果scope是singleton，则调用getSingleton方法获取实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果scope是prototype，则直接创建bean实例，每次会创建一个新实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果scope是其他值，则允许我们自定bean的创建过程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中getSingleton方法主要代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getSingleton&lt;/span&gt;&lt;span&gt;(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Assert.notNull(beanName, &lt;span&gt;&quot;Bean name must not be null&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.singletonObjects) {&lt;br/&gt;   Object singletonObject = &lt;span&gt;this&lt;/span&gt;.singletonObjects.get(beanName);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (singletonObject == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;          singletonObject = singletonFactory.getObject();&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (newSingleton) {&lt;br/&gt;           addSingleton(beanName, singletonObject);&lt;br/&gt;        }&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; singletonObject;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个关键的singletonObjects对象，其实是一个ConcurrentHashMap集合：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; singletonObjects = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span&gt;256&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getSingleton方法的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据beanName先从singletonObjects集合中获取bean实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果bean实例不为空，则直接返回该实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果bean实例为空，则通过getObject方法创建bean实例，然后通过addSingleton方法，将该bean实例添加到singletonObjects集合中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下次再通过beanName从singletonObjects集合中，就能获取到bean实例了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里spring是通过ConcurrentHashMap集合来保证对象的唯一性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后留给大家几个小问题思考一下：&lt;/p&gt;&lt;section&gt;1. 多例模式 和 多对象模式有什么区别？&lt;/section&gt;&lt;section&gt;2. java框架中有些单例模式用的不规范，我要参考不？&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. spring的单例，只是结果是单例的，但完全没有遵循单例模式的固有写法，它也算是单例模式吗？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎大家给我留言，说出你心中的答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;码字不易，如果读了文章有些收获的话，请帮我点赞一下，谢谢你的支持和鼓励。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bcf0bfc50ec9339e180c03eaec9eb5b0</guid>
<title>Sentinel-Go 源码系列（一）：开篇</title>
<link>https://toutiao.io/k/u1baj7t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好呀，打算写一个 Go 语言组件源码分析系列，一是为了能学习下 Go 语言，看下别人是怎么写 Go 的，二是也掌握一个组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次选择了 Sentinel-Go，一是对 Java 版本的 Sentinel 算是有一些了解，也在生产上落地过，二是感觉他的代码应该不会太复杂（仅仅是感觉），三是在云原生越来越热的趋势下，用 Go 实现的限流降级容错应该是比较通用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码阅读本身是枯燥的，我尽量用容易理解的语言来描述，希望大家也多支持我的文章，点个&lt;code&gt;赞&lt;/code&gt;、&lt;code&gt;在看&lt;/code&gt;和&lt;code&gt;关注&lt;/code&gt;就是对我最大的支持。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Sentinel 简介&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 是阿里2018年开源的项目，最初是 Java 版本，截止目前有 17.6k 的star，项目地址为&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/alibaba/Sentinel/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2020年又开源了 Go 的版本，目的是朝云原生方向演进，截止目前 1.7k star，项目地址为&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/alibaba/sentinel-golang&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Sentinel 的作用&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面简介中也说了，Sentinel 是微服务时代保障稳定的神兵利器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：电商系统中用户浏览商品详情页，通常会通过 RPC 调用多个微服务，查询商品信息的同时还会查询用户的信息，也会展示优惠信息，通常下拉列表还会展示推荐，广告等信息，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001896&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Ticftz7y7SOF5oqza3fWrhjuquhd33BicicYEsDibR6mHNEqZ0glYOZlnuCnzO35ubicyolibfzswzb09w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果流量较大时，CouponService 容量不足，或者某种原因导致 RecomService 不可用，此时 AggrService 会被拖死，导致商品详情服务不可用，但仔细想想这些服务不是那么重要，可以进行限流或者直接降级（不再调用），总比直接服务不用要好吧&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又或者流量实在太高，ProductService 也顶不住了，那是否可以采取限流措施，保住部分用户的请求是正常的，也比全部不可用要好&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题，Sentinel 都能解决&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Sentinel 提供的能力&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 将要保护的对象（可以是某个服务或一段代码）抽象为资源，通过动态下发的规则，对资源进行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这两个主要功能又有很多的玩法，比如限流是针对QPS还是并发数，控制的效果是直接拒绝还是排队等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然 Sentinel 也提供一个开箱即用的 Dashboard，可扩展配中心进行下发规则，展示监控指标，调用关系链等等&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快速开始&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;源码阅读环境准备&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fork 源码到自己仓库，便于增加注释&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拉取源码到本地&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;git clone git@github.com:lkxiaolou/sentinel-golang.git&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;导入 IDE，由于我既要写 Java 又要写 Go，所以用 IntelliJ IDEA 比较方便，只要装一个 Go plugin 就可以了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;导入后，一般 IDE 会自动下载依赖，如果没有自动下载，试试执行（ Go 安装就不说了）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;go mod download&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目录结构介绍&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sentinel-golang&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;api：对外暴露的接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;core：核心实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;example：使用例子&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exporter：Prometheus的exporter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ext：扩展接口，主要是动态规则配置中心扩展接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;logging：日志模块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pkg：第三方插件的实现，比如各个组件适用 Sentinel 的 adapter，以及 Sentinel 对接各种第三方配置中心的扩展实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tests：测试类代码，包括单元测试、benchmark&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;util：工具类&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;样例跑通&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 /example 目录下新建 mytests 目录，并创建一个 quick_start.go 文件，按照官网给出的例子，先用最简单的默认方式初始化&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err := sentinel.InitDefault(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 初始化失败&lt;/span&gt;&lt;br/&gt; &lt;span&gt;panic&lt;/span&gt;(err.Error())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再用写死的方式加载规则&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 资源名&lt;/span&gt;&lt;br/&gt;resource := &lt;span&gt;&quot;test-resource&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 加载流控规则，写死&lt;/span&gt;&lt;br/&gt;_, err := flow.LoadRules([]*flow.Rule{&lt;br/&gt; {&lt;br/&gt;  Resource: resource,&lt;br/&gt;  &lt;span&gt;// Threshold + StatIntervalInMs 可组合出多长时间限制通过多少请求，这里相当于限制为 10 qps&lt;/span&gt;&lt;br/&gt;  Threshold: &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;  StatIntervalInMs: &lt;span&gt;1000&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 暂时不用关注这些参数&lt;/span&gt;&lt;br/&gt;  TokenCalculateStrategy: flow.Direct,&lt;br/&gt;  ControlBehavior: flow.Reject,&lt;br/&gt; },&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后写测试代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 修改这个看看效果吧&lt;/span&gt;&lt;br/&gt;currency := &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; currency; i++ {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  e, b := sentinel.Entry(resource, sentinel.WithTrafficType(base.Inbound))&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; b != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 被流控&lt;/span&gt;&lt;br/&gt;   fmt.Printf(&lt;span&gt;&quot;blocked %s \n&quot;&lt;/span&gt;, b.BlockMsg())&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 通过&lt;/span&gt;&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;pass...&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;// 通过后必须调用Exit&lt;/span&gt;&lt;br/&gt;   e.Exit()&lt;br/&gt;  }&lt;br/&gt; }()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里限制了 10 qps，我们用 100 个协程并发测试跑一下，刚好通过10个请求&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001897&quot; data-ratio=&quot;0.4325153374233129&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Ticftz7y7SOF5oqza3fWrhjzGw3wCPtYA1VIicDJ9rLvK8CAWZAdImpcFYsRZGD58PfwibibztKNHLUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1956&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码已上传到我的仓库&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/lkxiaolou/sentinel-golang/tree/master/example/mytests&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了 Sentinel 的和它能解决的问题，以及源码阅读的一些准备工作，并跑通了一个最简单的例子，见识到了 Sentinel 限流的效果，本文先到这里，我们下一节见。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100001895&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0Ticftz7y7SOF5oqza3fWrhjsXzftCP4Me5ObsKcVFcVX7rGJibmX1VWVdqBsRa03kOxick6WhHjbh2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a95cf42aa0ea5992a55a8261706d1bcf</guid>
<title>从 DDD 到 PaaS 化再到一站式部署：通天塔后端通用版发展之路</title>
<link>https://toutiao.io/k/y2rictc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;105273&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;105273&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;通用版的背景和目标&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;通天塔是一个面向京东运营和商家的活动搭建平台，提供了丰富和强大的模板，平台用户可基于模板自由搭建活动页面。通天塔支持无线和PC页面的搭建，提供的3种搭建方式：模块搭建、自定义开发（H5）、RN开发，站内活动支持原生，搭建一次可以同步到各端（app、pc、一号店、WQ、小程序等）。除了搭建页面，通天塔还支持以下功能：看数据、分享、首焦报名、复制、转移、AB测试等。&lt;/p&gt;&lt;p&gt;随着京东和通天塔业务的发展，我们需要支持的站点越来越多，包括主站、国际站（泰国站、印尼站）、商业化站点（商羚、北汽、数智农批、宜宾站）等等，&lt;/p&gt;&lt;p&gt;面临的挑战也越来越多：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;通天塔需要支持的每个站点相互独立，意味着每个站点都有一套对应的代码和中间件资源等，硬件成本高，维护成本高。主站和其他站点代码不能复用，部分业务功能迁移困难&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个站点都有其个性化需求，对开发资源的要求越来越高，复杂度随站点数量增加呈线性增长&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由于初期代码架构设计不合理，导致系统功能大而全，加入新功能所引入的复杂性不断提升&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;站点扩展性差，每次新增站点都要从头开始开发，上线时间较长&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通天塔后端团队经过数年的逐步探索，摸索出了一条可扩展、高可用、可维护、部署灵活、多租户支持的通用版架构之路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014437&quot; data-ratio=&quot;0.5125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2P9R282hjVHA3eG6Lx5mhfZOyzIGDCoicBe73lgiakJIDibeqh4P5eLHhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;105273&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;通用版改造历程&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;372:310&quot;&gt;&lt;strong&gt;DDD（领域驱动设计）&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，我们尝试解决代码架构设计不合理，代码复用、迁移困难的问题。矛盾的根源在于通天塔后端一直采用传统的SOA架构，它存在这些问题：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;臃肿的service层&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分层后文件的随意组装方式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术导向分层，导致业务分离，不能快速定位。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;分布式微服务的出现有利于解决这一难题，但微服务也不是适合所有的系统，而且也会有许多问题：微服务的粒度应该多大呀？微服务到底应该如何拆分和设计呢？微服务的边界应该在哪里？&lt;/p&gt;&lt;p&gt;很久以来都没有一套系统的理论和方法可以指导微服务的拆分。综合来看，微服务拆分困境产生的根本原因就是不知道业务或者微服务的边界到底在什么地方。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。&lt;/p&gt;&lt;p&gt;领域驱动设计是一种以业务为导向的软件设计方法和思路。我们在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，而领域驱动设计的核心就在于建立正确的领域驱动模型。从过程上来说，我们从以前的业务模型和技术模型分开的设计流程转变为统一的领域模型设计流程，这就是业务研发模式的转变。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014438&quot; data-ratio=&quot;0.440625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2K3d5c4jLCUMYbS8HDyL8oYOGXHH4OoiamibZAXQOFehazkPKXZy8lCEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以babel-extension为例：DDD的实现过程如下&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014439&quot; data-ratio=&quot;0.5576923076923077&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2GEJJUh6ialFrSIpNHwaTql8mTU8JlWGAwOQWV591bxx2EbF7ic0ev7xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一步，定义业务边界。基于对通天塔业务的理解，我们将原先较混乱的业务子域划分模型转换为基于DDD的限界上下文划分模型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014440&quot; data-ratio=&quot;1.2101105845181674&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw24fooXxlJOlOG4Ml02xmtz7WHyfBdDAg942GNL3mh4R5gQoxjHyJZxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二步，选定系统架构。这里我们选择菱形对称架构。&lt;/p&gt;&lt;p&gt;菱形对称架构（Diamond Symmetry Architecture）模式脱胎于六边形架构与分层架构，它以领域为核心对限界上下文的关注点进行划分，建立了由内部领域模型与外部网关组成的内外分层架构，以菱形的对称结构清晰展现了限界上下文的内部结构，指导着限界上下文的协作关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014441&quot; data-ratio=&quot;0.42579505300353354&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2RhIv6B8dpEXeeMOicwEwiaRroTiaZq9p8ia9CQYysxCsS8YXhReGQLcsSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;引入菱形对称架构有助于促进团队对限界上下文与上下文映射的一致理解，并促成团队形成统一的代码模型。&lt;/p&gt;&lt;p&gt;第三步，基于菱形对称架构建模落地。以下是代码结构展示&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014442&quot; data-ratio=&quot;1.0588235294117647&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2y4W39tZJStTekEVIxEAoSACsVLZMZv6VxOaHryqKgAGSA5NjlWppIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;优势：&lt;/p&gt;&lt;p&gt;1、结构更清晰&lt;/p&gt;&lt;p&gt;代码结构清晰，能分别体现来自不同方向的请求。形成的对称结构更加清晰地体现了业务逻辑、技术功能与外部环境之间的边界。&lt;/p&gt;&lt;p&gt;2、能更好地响应变化&lt;/p&gt;&lt;p&gt;更加清晰地展现上下文映射模式之间的差异，凸显了防腐层与开放主机服务的重要性，能更好地响应限界上下文协作关系的变化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;PaaS化改造&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来，我们需要解决站点个性化需求多，扩展性差的问题。对于某些各站点有差异，变动频繁但本身逻辑不复杂的功能，按以往的方式我们需要：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;新增站点时需要在代码中加入站点判断和新逻辑，导致代码臃肿&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改某个站点的功能时需要修改代码重新部署发布，效率低下&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所有第三方需求最终都由通天塔团队进行开发，工作量巨大&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;Paas化改造能很好地帮助我们应对这一场景。京东中台使用平台化的技术思维和技术手段梳理，识别，沉淀，复用企业的业务核心能力。中台搭建清晰易懂的业务领域服务模型，前台可高效率集成这些模型来满足业务场景，同时通过中台提供的扩展点进行个性化的能力扩展，灵活定制业务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一步，明确业务身份。&lt;/p&gt;&lt;p&gt;业务分为水平业务与垂直业务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014443&quot; data-ratio=&quot;0.7581453634085213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2GS0ibJ5KhzFTqW9cz1f6IGcrkD5ljmVlticaW91HsT1J9BicTY1KL6Z3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;798&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时，通过业务身份矩阵可以明确自己的业务身份。我们的业务身份是营销域/通提投/通天塔。&lt;/p&gt;&lt;p&gt;第二步，需求结构化，扩展点展现与需求绑定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014444&quot; data-ratio=&quot;0.42153589315525875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw27vQBiboQ8gQYfBTeyXfMWiaIoxV8M0ID8VzdHT5W7uCDUeUickOicLbkvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1198&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三步，扩展点的开发与上线。&lt;/p&gt;&lt;p&gt;提交需求（价值预估）——排期开发（价值PK）——上线运营（价值验证）——需求调整（价值调整）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014445&quot; data-ratio=&quot;0.32207578253706753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2aH5LEmtgyUuz0AE1N1bacPkWIvNbzPtUJ3hzBtibf7Y3TIMfwgWE6Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1214&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于各站点的定制化需求较多，而Paas支持由通天塔定义扩展点，第三方实现，因此可以解放我们的研发能力，邀请第三方完善扩展点，共建领域能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;通用版本建设&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了解决通天塔多站点存在差异、每个站点都需要维护一套对应的代码的问题，我们建设了通用版本的代码，将核心且共有的功能抽取出来，再将每个站点独有的功能分成子包，按需引用，通过maven来治理。同时，利用SPI+配置文件相结合的方案，抽离了中间件与代码的耦合，保证了通用版本不依赖某一特定中间件即可运行，提高了系统的可移植性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014446&quot; data-ratio=&quot;0.7241379310344828&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2ly7lmDHRePj23UoEvPPvMnF4rHWKt3jIWhyakW3wbZezelJJjG57Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对一些特定的业务场景，通天塔后端选择了最优的架构来进一步提升效率、节约资源。比如在商羚、数智农批两个商业化项目的设计上，由于不像国际站一样有天然的环境隔离，也不像北汽站一样必须独立部署，通用版在设计上选择了“上游独立部署、通投同时支持”的策略，用一套通天塔应用在不独立部署的情况下，同时支持多个业务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014447&quot; data-ratio=&quot;0.50390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2nEKfEHV3EGSsGRW2dXrV0uu0QHia1mAWnDuKvF4XAxEGRGHhic2S0ssA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于不同的站点，通用版采用逻辑上的隔离（账号租户、项目租户隔离）而非物理上的隔离（重新申请资源部署），灵活应对了新业务，避免了资源浪费，大大提升了上线速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;358:296&quot;&gt;&lt;strong&gt;iPaaS和开放共建能力&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，为了彻底解决独立新站点构建完整运营体系效率低、交付慢的问题，我们对通提投的技术和业务能力进行全面地抽象、提炼和标准化，推出了一套可极速构建完整运营体系的一站式解决方案——iPaaS（京东零售前台研发标准）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014448&quot; data-ratio=&quot;0.5136406396989652&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2j84pgUEuIdW2iaUsNAxicw1j06ibjvCOhtTHeSD2Ht5dsO1vxQhNFkAlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1063&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;iPaaS基于前台研发构建完整营销运营体系为视角抽象和设计出整个iPaaS体系，包含5大能力：&lt;/p&gt;&lt;p&gt;1，设计前端协同：通过整合和拉通从夸克、Relay设计平台到大前端平台，建立高效的设计前端一体化协作流程和机制&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2，大前端标准化：提供一站式的前端产品构建云平台，赋能前端开发者实现从设计、编码、调试、上线、升级和运营的全生命周期的产品支撑&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3，模板共享体系：通过大前端技术开放体系赋能开发者和ISV，不断开发跨业务、跨App复用的模板和组件，并持续沉淀到模板共享体系，越来越多的优质模板赋予业务更强的运营能力，开发者的技术和成果实现最大化价值共享和变现，形成开发者不断被激励、模板越来越多、业务的运营能力越来越强的良性生态圈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4，能力聚合服务体系：通过平台级的营销运营能力和标准化的中后台管理系统解决方案，帮助业务快速构建运营体系，结合Low Code技术开放体系（低代码能力接入和编排、FaaS能力加工、PaaS能力共建）赋能开发者快速满足业务的定制化场景和需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;5， 立体智能质量体系：把立体智能质量监控能力植入到每一个iPaaS能力和环节中，形成iPaaS能力和监控高度融合的一体化体系，为iPaaS完整体系的高质量、稳定和安全运行保驾护航。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IPaaS体系接入通用版后，不仅可以帮助新站点极速构建完整营销运营体系，而且将极大帮助通天塔应对海量定制需求，这里通过几个例子说明。&lt;/p&gt;&lt;p&gt;例如，大前端共建平台，即ihub.jd.com，基于iPaaS标准建设，面向开发者提供包含h5、iOS、安卓等端的跨端楼层开发管理能力。即当系统现有模板无法满足诉求时，业务或开发者可通过ihub平台开发并管理代码楼层模板，开发出来的楼层可以被采销、运营、商家等使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014449&quot; data-ratio=&quot;0.6963636363636364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2ZEacYSJTXNoYJVGYSzVBbYVUoUJZbwFu358WKD7gYkVQt3go5VBx4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如，能力聚合服务体系通过lambda函数平台对能力进行扩展，承接上层无状态业务逻辑，比如入参封装、字段过滤、图片加工处理类需求，无需应用发布，加速并简化开发，实现需求快速交付。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014450&quot; data-ratio=&quot;0.471608832807571&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2kxEApLow4GVJicQCPePZOLMWfVabUNIFMIQJdV0H7EbyyDBBOq94Vlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;5&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;332:303&quot;&gt;&lt;strong&gt;中间件解耦&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过，即使有了以上条件，新站点还需要具备京东云技术基础设施，也就是京东IaaS和PaaS。未来，技术商业化将成为京东增长的新曲线，将会催生越来越多的商业化赛道和项目，通用版体系解耦京东TPaaS势在必行。所以未来通用版的方向是进行彻底的解耦JD TPaaS改造，通过标准技术API+技术适配层来隔离&amp;amp;适配底层技术。&lt;/p&gt;&lt;p&gt;为了满足以上需求，通用版使用SPI+配置文件相结合的方案，用SPI的特性实现灵活扩展，用读配置文件的方式实现灵活切换实现，同时具体落地方面主要为增加适配层以及额外的实现，对原有的实现逻辑改动相对较小，安全性较高。&lt;/p&gt;&lt;p&gt;基础设施适配主要改造位置和整体架构的关系：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014451&quot; data-ratio=&quot;0.57109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2ktwuUGc9f8dVR47KwWc0QKuNfpds6XSIVBpmhkRUmL69RPI4aJicO8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;SPI+配置实现基础设施解耦架构图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014452&quot; data-ratio=&quot;0.7360248447204969&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2v3QSicy6hxRERQPqFPP7ORGViabITzor2ib0VKJxKAQ4fAsRQo7ibCoiafw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;6&quot;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;371:308&quot;&gt;&lt;strong&gt;项目部署一站式解决方案&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以往每个新站点都需要一套对应的中间件资源和镜像版本，需要开发者手动去走流程申请，然后将资源地址（如redis url、mysql用户名、密码等）填充到代码的配置文件中，进行调试和修改。由于通用版应用数量较多、涉及的中间件数量也较多，这对开发者造成了一定的困扰，使得开发者要将很多精力投入到这种重复的工作中去，而且熟悉资源的申请、配置文件的修改调试也需要一定的上手成本。综上所述，一套项目部署一站式解决方案——京东零售云交付平台，应运而生。&lt;/p&gt;&lt;p&gt;部署流程：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014453&quot; data-ratio=&quot;0.43137254901960786&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2peAmia9urwR0ZjjicYYAutYo3gc8wRhQ9bSwUc3w03LMuIqqRNHichBxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;发布方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014454&quot; data-ratio=&quot;0.42109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2zsAUbYcwLYfoHibussLvbicYMK8mibVqsXZB0iaxPJmeZekx33PqfvCDsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通用版在接入京东零售云交付平台后，研发人员可以在线申请应用资源依赖，&lt;/p&gt;&lt;p&gt;维护不同客户的应用、镜像版本。每当需要扩展新站点的时候，只需选择对应新站点的环境即可发布。真正做到一次配置，处处部署。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终的通用版部署流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014455&quot; data-ratio=&quot;0.541002277904328&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2FzKA8r7ur7TtmMGrIOCGArk8YtD3Y29CRUET9peBHzlKlBSKAQQjGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;7&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;379:310&quot;&gt;&lt;strong&gt;成果&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;京东通提投团队经过对通用版的一系列探索、改造历程，目前已取得一定的成果，主要体现在已建立的独立站点上。从泰国站、印尼站开始，经历了产品规划、方案设计、中间件申请、代码编写、联调提测等等过程，新的独立站点上线时间达到4个月左右。随着我们逐步摸索通用版改造方案，到最新的数智农批站点，仅需1.5个月即可完成上线，累积速度提升达到了70%以上，这其中省掉了很多重复工作的时间，让开发人员将精力集中到了站点新业务逻辑上面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014456&quot; data-ratio=&quot;0.5178777393310265&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2niaeeQUXoq87Bw3axa6GQenXO6FFDcIiaGKiaZxRfNmuvAv7jiatOZlKMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;867&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;105273&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;未来的方向&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;云原生&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;系统有了通用版能力后，我们发现在响应新的站点和商业化项目过程中最大的工作量和难题是如何快速移植、部署整体平台体系到客户环境，可能是公有云、私有云，甚至混合云，这就需要我们依据云原生技术设计出一套可以快速部署完整通用版到不同客户云环境的能力，且体系可以做到稳定和一致性的方式运行。以下是我们初步设计的方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100014457&quot; data-ratio=&quot;0.43217665615141954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenFibuTF0FMscMlypfibXdhRAw2Y3n4U1HFMDy74wUicLwsDrjR3b9aFibXrg9ouUibr5kibib3fqxq7MFxunA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应用通过接入云原生服务可以天然获得可观测性、高可用、容错性、自愈等能力，从而构建韧性应用。同时云原生的架构原则也同样在我们开发者在开发和设计软件架构时起到非常好的指导作用，包括服务化、弹性、可观察性、韧性、自动化、零信任等原则，帮助我们更好的建设系统的高可用基础能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86412&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;作者团队：&lt;/span&gt;&lt;span&gt;平台研发章钦、方正栋、朱志国&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5e6c5bf7001ebd62b58dbeaddd63906</guid>
<title>再谈 TCP 拥塞控制</title>
<link>https://toutiao.io/k/1rzyidu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;12&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;来自公众号：&lt;span&gt;后端研究所&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;1.拥塞控制简史&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;来看下维基百科对TCP/IP协议栈的一些介绍，笔者做了少量的修改来确保语句通顺：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;互联网协议套件是一个网络通信模型以及整个网络传输协议家族，由于该协议簇包含两个核心协议：TCP（传输控制协议）和IP（网际协议），因此常被通称为&lt;span&gt;TCP/IP协议族&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;span&gt; &lt;/span&gt;&lt;p&gt;TCP/IP协议对于数据应该如何封装、定址、传输、路由以及在目的地如何接收等基本过程都加以标准化。它将通信过程&lt;span&gt;抽象化为四个层次&lt;/span&gt;，并采取协议堆栈的方式分别实现出不同通信协议，实际使用的四层结构是七层OSI模型的简化。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;我们可以看到TCP/IP协议栈是一个简化的分层模型，是互联网世界连接一切的基石，一起来看一张&lt;/span&gt;&lt;span&gt;七层模型vs四层模型&lt;/span&gt;&lt;span&gt;的简图：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999213&quot; data-ratio=&quot;0.6981519507186859&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0yACFrqcHYTLO9WUbVhtNAu3kmSo8h504FHVYeVgCicticLD2FDmQVicaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大约在1988年之前TCP/IP是没有拥塞控制的，但是随着网络接入规模的发展之前仅有的端到端窗口控制已经无法满足要求，在1986年引发大规模网络瘫痪，此时就要提到一个重量级人物：&lt;/span&gt;&lt;span&gt;Van Jacobson范·雅各布森&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这位力挽狂澜的人物入选了&lt;/span&gt;&lt;strong&gt;&lt;span&gt;计算机名人堂Internet Hall of Fame&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，Van Jacobson大神提出并设计实施了TCP/IP拥塞控制，解决了当时最大的问题，来简单看下Van Jacobson的维基百科简介(&lt;/span&gt;&lt;span&gt;&lt;strong&gt;笔者做了部分删减&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;)：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;范·雅各布森Van Jacobson是目前作为&lt;/span&gt;&lt;span&gt;互联网技术基础的TCP/IP协议栈的主要起草者&lt;/span&gt;&lt;span&gt;，他以其&lt;/span&gt;&lt;span&gt;在网络性能的提升和优化的开创性成就而闻名&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2006年8月，他加入了帕洛阿尔托研究中心担任研究员，并在位于相邻的施乐建筑群的Packet Design公司担任首席科学家。在此之前，他曾是思科系统公司首席科学家，并在位于劳伦斯伯克利国家实验室的网络研究小组任领导者。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;范·雅各布森因为在提高IP网络性能提升和优化所作的工作而为人们所知，&lt;/span&gt;&lt;span&gt;1988到1989年间，他重新设计了TCP/IP的流控制算法（Jacobson算法）&lt;/span&gt;&lt;span&gt;，他因设计了RFC 1144中的TCP/IP头压缩协议即范·雅各布森TCP/IP头压缩协议而广为人知。此外他也曾与他人合作设计了一些被广泛使用的网络诊断工具，如&lt;/span&gt;&lt;span&gt;traceroute&lt;/span&gt;&lt;span&gt;，pathchar以及&lt;/span&gt;&lt;span&gt;tcpdump&lt;/span&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;范·雅各布森于&lt;/span&gt;&lt;span&gt;2012年4月入选第一批计算机名人堂，计算机名人堂简介：https://www.internethalloffame.org/inductees/van-jacobson&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;如图为Van Jacobson计算机名人堂的简介：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999214&quot; data-ratio=&quot;1.0596205962059622&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIot1gQ7IGBbibztcQ2920lXkLeeFDl4MibJfP51p2nJianvC7icxIYSGUkeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;738&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者找了&lt;span&gt;Van Jacobson&lt;/span&gt;和Michael J. Karels在1988年11月发布的关于拥塞避免和控制的论文，总计25页，感兴趣的读者可以查阅：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;https://ee.lbl.gov/papers/congavoid.pdf&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;我们常用的tracetoute和tcpdump也是van-jacobson大神的杰作，作为互联网时代的受益者不由得对这些互联网发展早期做出巨大贡献的开拓者、创新者、变革者心生赞叹和敬意。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.流量控制和拥塞控制&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;TCP是一种面向连接的、可靠的、全双工传输协议，前辈们写了很多复杂的算法为其保驾护航，其中有一组像&lt;/span&gt;&lt;strong&gt;&lt;span&gt;海尔兄弟一样&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的算法：&lt;/span&gt;&lt;span&gt;流量控制和拥塞控制&lt;/span&gt;&lt;span&gt;，这也是我们今天的主角。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999211&quot; data-ratio=&quot;0.7460063897763578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH05QlHBhUfxXeN49kvMcnEGclYH1eQ1OJhZYPpymwmS4SfoLrxAbzCOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.1 流量控制简介&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;流量控制和拥塞控制从汉语字面上并不能很好的区分，本质上这一对算法既有区别也有联系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维基百科对于&lt;/span&gt;&lt;span&gt;流量控制Flow Control&lt;/span&gt;&lt;span&gt;的说明：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;In data communications, flow control is the process of managing the rate of data transmission between two nodes to prevent a fast sender from overwhelming a slow receiver. &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;It provides a mechanism for the receiver to control the transmission speed, so that the receiving node is not overwhelmed with data from transmitting node.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;翻译一下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;在数据通信中，流量控制是管理两个节点之间数据传输速率的过程，以防止快速发送方压倒慢速接收方。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;它为接收机提供了一种控制传输速度的机制，这样接收节点就不会被来自发送节点的数据淹没。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;可以看到流量控制是通信双方之间约定数据量的一种机制，具体来说是借助于TCP协议的确认ACK机制和窗口协议来完成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;窗口分为&lt;/span&gt;&lt;span&gt;固定窗口和可变窗口&lt;/span&gt;&lt;span&gt;，可变窗口也就是&lt;/span&gt;&lt;span&gt;滑动窗口&lt;/span&gt;&lt;span&gt;，简单来说就是通信双方根据接收方的接收情况动态告诉发送端可以发送的数据量，从而实现发送方和接收方的数据&lt;/span&gt;&lt;span&gt;收发能力匹配&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个过程非常容易捕捉，使用&lt;/span&gt;&lt;span&gt;wireshark在电脑上抓或者tcpdump在服务器&lt;/span&gt;&lt;span&gt;上抓都可以看到，大白在自己电脑上用wireshark抓了一条：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999212&quot; data-ratio=&quot;0.6434210526315789&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0KJqEic1V3Z6iam8Ju6J9GWOQ7FibDpVsOgKtEHqGA7giaw8KqrLQgXTvPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们以两个主机交互来简单理解流量控制过程：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.37850467289719625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0Vib96PWdiayoVL3vt6dTia2ibPeKSndYibicVibAlzjokBib3UIBqPdGFlHFQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot; data-fileid=&quot;502999210&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接收方回复报文头部解释：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999218&quot; data-ratio=&quot;0.7160356347438753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0JsCDtNZibC9AASXshY5Zmr9PFcfRyUuqEydzPWZic1PrYvAibV33y8p0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;图中RcvBuffer是接收区总大小，buffered data是当前已经占用的数据，而free buffer space是当前剩余的空间，rwnd的就是free buffer space区域的字节数。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;HostB把当前的rwnd值放入报文头部的接收窗口receive window字段中，以此通知HostA自己还有多少可用空间， 而HostA则将未确认的数据量控制在rwnd值的范围内，从而避免HostB的接收缓存溢出。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;可见&lt;/span&gt;&lt;span&gt;流量控制是端到端微观层面的数据策略&lt;/span&gt;&lt;span&gt;，双方在数据通信的过程中并不关心链路带宽情况，只关心通信双方的接收发送缓冲区的空间大小，可以说是个&lt;/span&gt;&lt;span&gt;速率流量匹配策略&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流量控制就像现实生活中物流领域中A和B两个仓库，A往B运送货物时只关心仓库B的剩余空间来调整自己的发货量，而不关心高速是否拥堵。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.2 拥塞控制的必要性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前面我们提到了微观层面点到点的流量控制，但是我们不由地思考一个问题：&lt;/span&gt;&lt;span&gt;只有流量控制够吗？答案是否定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还需要一个宏观层面的控去避免网络链路的拥堵，否则再好的端到端流量控制算法也面临&lt;/span&gt;&lt;span&gt;丢包、乱序、重传&lt;/span&gt;&lt;span&gt;问题，只能造成恶性循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999215&quot; data-ratio=&quot;0.42441054091539526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0rHLRXk7JAYy8KYug8qgwHib2NTXOyPTq2HzMPEkzrVg2jmzMXgPiaQJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们从一个更高的角度去看&lt;/span&gt;&lt;span&gt;大量TCP连接复用网络链路&lt;/span&gt;&lt;span&gt;的通信过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999216&quot; data-ratio=&quot;0.7414050822122571&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gVfr2dlRsiciaFP85icESibib6zpxLva1vXOKticfzH2N6OUKd0uxUEywmVsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以拥塞控制和每一条端到端的连接关系非常大，这就是流量控制和拥塞控制的深层次联系，所谓每一条连接都顺畅那么整个复杂的网络链路也很大程度是通畅的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999219&quot; data-ratio=&quot;0.49047619047619045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0FlegVJhvC3uVhpLhYzL7kRnIlXWIicN1XmZ8vStakxBKhkfG3YXJ6aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在展开拥塞控制之前我们先考虑几个问题：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;TCP连接的发送方在向对端发送数据的过程中，需要根据当前的网络状况来调整发送速率，所以感知能力很关键。&lt;/section&gt;&lt;section&gt;在TCP连接的发送方一般是&lt;span&gt;基于丢包&lt;/span&gt;来判断当前网络是否发生拥塞，丢包可以由&lt;span&gt;重传超时RTO和重复确认&lt;/span&gt;来做判断。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999217&quot; data-ratio=&quot;0.5222841225626741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51g1b20eDwj9E49hPBdaebBIVRYsxia8aCjo83eqnFicMxUfszicAvgZo5Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;/section&gt;&lt;section&gt;诚然拥塞影响很大，但是一直低速发包对带宽利用率很低也是很不明智的做法，因此要充分利用带宽就不能过低过高发送数据，而是保持在一个动态稳定的速率来提高带宽利用率，这个还是比较难的，&lt;span&gt;就像茫茫黑夜去躲避障碍物&lt;/span&gt;。&lt;/section&gt;&lt;section&gt;拥塞发生时我们需要有一套应对措施来防止拥塞恶化并且恢复连接流量，这也是拥塞控制算法的精要所在。&lt;/section&gt;&lt;h2&gt;&lt;span&gt;3.理解拥塞控制&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;看到一篇文章说到&lt;/span&gt;&lt;span&gt;TCP 传输层拥塞控制算法并不是简单的计算机网络的概念，也属于控制论范畴&lt;/span&gt;&lt;span&gt;，感觉这个观点很道理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TCP拥塞控制算法的目的可以简单概括为：&lt;/span&gt;&lt;span&gt;公平竞争、充分利用网络带宽、降低网络延时、优化用户体验，&lt;/span&gt;&lt;span&gt;然而就目前而言要实现这些目标就难免有&lt;/span&gt;&lt;span&gt;权衡和取舍。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在理解拥塞控制算法之前我们需要明确一个核心的思想：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;闻道有先后 术业有专攻&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，笔者觉得这是一个非常重要的共识问题，把A踩在泥土里，把B吹捧到天上去，都不是很好的做法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际的网络环境十分复杂并且变化很快，&lt;/span&gt;&lt;span&gt;并没有哪个拥塞控制算法可以全部搞定，每一种算法都有自己的特定和适用领域&lt;/span&gt;&lt;span&gt;，每种算法都是对几个关键点的权衡，在无法兼得的条件下有的算法选择带宽利用率，有的算法选择通信延时等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在明确这个&lt;strong&gt;共识问题&lt;/strong&gt;之后，我们对待各个拥塞控制算法的态度要&lt;/span&gt;&lt;span&gt;平和一些，不要偏激&lt;/span&gt;&lt;span&gt;地认为谁就是最好，几十年前的网络状况和现在是截然不同的，&lt;/span&gt;&lt;span&gt;我们永远都是站在巨人的肩膀之上的，这也是科学和文明进步的推动力&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统拥塞控制算法并&lt;/span&gt;&lt;span&gt;不是一蹴而就&lt;/span&gt;&lt;span&gt;的，&lt;/span&gt;&lt;span&gt;复杂的网络环境和用户的高要求推动着拥塞控制算法的优化和迭代&lt;/span&gt;&lt;span&gt;，我们看下&lt;strong&gt;基于丢包策略&lt;/strong&gt;的传统拥塞控制算法的几个迭代版本，如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999224&quot; data-ratio=&quot;0.37299338999055714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoqpYh7el2Jxng4Ir7cCyPmiaBMuqHYDBbsNjWLNOwM1dIvBMds2ZC6MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时还有一类算法是&lt;strong&gt;基于RTT延时策略&lt;/strong&gt;来进行控制的，但是这类算法在发包速率上可能&lt;/span&gt;&lt;span&gt;不够激进&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;竞&lt;/span&gt;&lt;span&gt;争性能不如其他算法&lt;/span&gt;&lt;span&gt;，因此在共享网络带宽时&lt;/span&gt;&lt;span&gt;有失公平性&lt;/span&gt;&lt;span&gt;，但是算法速率曲线却是很&lt;/span&gt;&lt;span&gt;平滑&lt;/span&gt;&lt;span&gt;，我们暂且把这类算法当做&lt;/span&gt;&lt;span&gt;君子&lt;/span&gt;&lt;span&gt;吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999220&quot; data-ratio=&quot;0.4484304932735426&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIo6Yyb3iaI4aIqxALaDAOO9ricmSqMJRWyAZXX51IayLgpvhpClpncjnAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中比较有名的Vegas算法是大约在1995年由亚利桑那大学的研究人员拉里·彼得森和劳伦斯·布拉科夫提出，这个新的TCP拥塞算法以内华达州最大的城市拉斯维加斯命名，后成为TCP Vegas算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于基于RTT的TCP Vegas算法的详细介绍可以查阅文档&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;文档对Vegas算法和New Reno做了一些对比，我们从直观图形上可以看到Vegas算法更加&lt;/span&gt;&lt;span&gt;平滑&lt;/span&gt;&lt;span&gt;，相反New Reno则表现除了较大的波动呈&lt;/span&gt;&lt;span&gt;锯齿状&lt;/span&gt;&lt;span&gt;，如图所示：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999222&quot; data-ratio=&quot;0.5253664036076663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoucj9g0iaroZdKPpm84B7T3rWa0cXzBMqHaibT9hCvjqRDu6NuMntEKWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;887&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上还有更细粒度的分类，由于不是今天的重点，就不再深入展开了，当前使用的拥塞控制算法还是基于丢包Loss-Based作为主流。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.1 拥塞窗口cwnd&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;从流量控制可以知道接收方在header中给出了rwnd接收窗口大小，发送方不能自顾自地按照接收方的rwnd限制来发送数据，因为网络链路是复用的，需要考虑当前链路情况来确定数据量，这也是我们要提的另外一个变量cwnd，笔者找了一个关于rwnd和cwnd的英文解释：&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;Congestion Window (cwnd) is a TCP state variable that limits the amount of data the TCP can send into the network before receiving an ACK. &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;The Receiver Window (rwnd) is a variable that advertises the amount of data that the destination side can receive. &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Together, the two variables are used to regulate data flow in TCP connections, minimize congestion, and improve network performance.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;笔者在rfc5681文档中也看到cwnd的定义：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16338582677165353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gxSQEHy181HmKIBsSibXLv5qpEvcjVskUCmfrcL8ribHTmfaibLNVXRfWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot; data-fileid=&quot;502999221&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个解释指出了cwnd是在发送方维护的，cwnd和rwnd并不冲突，发送方需要结合rwnd和cwnd两个变量来发送数据，如图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999223&quot; data-ratio=&quot;0.8203017832647462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gGPrSOWYar5DlPw4Uhdibf7jFgtFlRAicWn5u5W1sYhDKicER3jHGqrEUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cwnd的大小和MSS最大数据段有直接关系，MSS是TCP报文段中的数据字段的最大长度，即MSS=TCP报文段长度-TCP首部长度。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2 拥塞控制基本策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;拥塞控制是一个动态的过程&lt;/span&gt;，它既要提高带宽利用率发送尽量多的数据又要避免网络拥堵丢包RTT增大等问题，基于这种高要求并不是单一策略可以搞定的，因此TCP的拥塞控制策略实际上是&lt;span&gt;分阶段分策略的综合过程&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999225&quot; data-ratio=&quot;0.42254901960784313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51giaa2fVVYynDUwDeX5KkKmRrebbvBZOpAHCfFysuZfGIof5dE6a8c1PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;有的版本的TCP算法不一定没有快速恢复阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图为典型的包含4个策略的拥塞控制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;297&quot; data-backw=&quot;578&quot; data-fileid=&quot;502999228&quot; data-ratio=&quot;0.513677811550152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51g5hBL8IaeCPuZAUVke9gTEU8CzuQV8o64mice9uwBKVU7e9227gfO6yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;/p&gt;&lt;p&gt;如图为发生超时重传RTO时的过程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999227&quot; data-ratio=&quot;0.5806938159879337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gPjFWGZBk2qzRRx35ZicYtprQTMHRibbxrcC1WEH07s5aHAicTnCeicsiahA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.3 TCP拥塞控制算法常见版本&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;实际上TCP算法有很多版本，每个版本存在一些差异，在这里简单看一下维基百科的介绍：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;TCP+算法名的命名方式最早出现在Kevin Fall和Sally Floyd1996年发布的论文中。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;这两个算法代号取自太浩湖Lake Tahoe和里诺市，两者算法大致一致，对于丢包事件判断都是以重传超时retransmission timeout和重复确认为条件，但是对于重复确认的处理两者有所不同，对于&lt;span&gt;超时重传RTO情况两个算法都是将拥塞窗口降为1个MSS&lt;/span&gt;，然后进入慢启动阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;TCP Tahoe算法&lt;/span&gt;：如果收到三次重复确认即第四次收到相同确认号的分段确认，并且分段对应包无负载分段和无改变接收窗口的话，Tahoe算法则进入快速重传，将慢启动阈值改为当前拥塞窗口的一半，将拥塞窗口降为1个MSS，并重新进入慢启动阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;TCP Reno算法&lt;/span&gt;：如果收到三次重复确认，Reno算法则进入快速重传只将拥塞窗口减半来跳过慢启动阶段，将慢启动阈值设为当前新的拥塞窗口值，进入一个称为快速恢复的新设计阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;TCP New Reno是对TCP Reno中快速恢复阶段的重传进行改善的一种改进算法，New Reno在低错误率时运行效率和选择确认SACK相当，在高错误率仍优于Reno。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;TCP BIC旨在优化高速高延迟网络的拥塞控制，其拥塞窗口算法使用二分搜索算法尝试找到能长时间保持拥塞窗口最大值，&lt;span&gt;Linux内核在2.6.8至2.6.18使用该算法作为默认TCP拥塞算法&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;CUBIC则是比BIC更温和和系统化的分支版本，其使用三次函数代替二分算法作为其拥塞窗口算法，并且使用函数拐点作为拥塞窗口的设置值，&lt;span&gt;Linux内核在2.6.19后使用该算法作为默认TCP拥塞算法&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;TCP PRR是旨在恢复期间提高发送数据的准确性，该算法确保恢复后的拥塞窗口大小尽可能接近慢启动阈值。在Google进行的测试中，能将平均延迟降低3~10%恢复超时减少5%，&lt;span&gt;PRR算法后作为Linux内核3.2版本默认拥塞算法&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;&lt;span&gt;TCP BBR是由Google设计于2016年发布的拥塞算法&lt;/span&gt;，该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Google在YouTube上应用该算法，将全球平均的YouTube网络吞吐量提高了4%，&lt;span&gt;BBR&lt;/span&gt;&lt;span&gt;之后移植入Linux内核4.9版本&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;3.4 拥塞控制过程详解&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们以典型&lt;span&gt;慢启动、拥塞避免、快速重传、快速恢复&lt;/span&gt;四个过程进行阐述。&lt;/p&gt;&lt;p&gt;慢启动就是对于刚启动的网络连接，发送速度不是一步到位而是试探性增长，具体来说：连接最初建立时发送方初始化拥塞窗口cwnd为m，之后发送方在一个RTT内&lt;span&gt;每收到一个ACK数据包时cwnd线性自增1&lt;/span&gt;，发送方&lt;span&gt;每经过一个RTT时间，cwnd=cwnd*2&lt;/span&gt;指数增长，经过一段时间增长直到cwnd达到慢启动阈值ssthresh。&lt;/p&gt;&lt;p&gt;之后cwnd不再呈指数增长从而进入拥塞避免阶段(注cwnd增长的单位是MSS)，当然如果在慢启动阶段还未到达阈值ssthresh而出现丢包时进入快速重传等阶段，需要注意的是&lt;span&gt;如果网络状况良好RTT时间很短，那么慢启动阶段将很快到达一个比较高的发送速率&lt;/span&gt;，所以将&lt;span&gt;慢启动理解为试探启动&lt;/span&gt;更形象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999229&quot; data-ratio=&quot;0.9506172839506173&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gwNeVoDrtKc4ztKiaJnYv3bckNZL4nfw2nH98iayrpXKl6RMWTHarqYwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;648&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;当慢启动阶段cwnd的值到达ssthresh时就不再疯狂增长，进入更加理性的线性阶段直至发送丢包，本次的阈值ssthresh是上一次发生丢包时cwnd的1/2，因此这是一个承上启下的过程。&lt;/p&gt;&lt;p&gt;本次发送丢包时仍然会调整ssthresh的值，具体拥塞避免增长过程：&lt;span&gt;发送方每收到一个ACK数据包时将cwnd=cwnd+1/cwnd，每经过一个RTT将cwnd自增1&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;TCP作为一个可靠的协议面临的很大的问题就是丢包，丢包就要重传因此发送方需要根据接收方回复的ACK来确认是否丢包了，并且发送方在发送数据之后启动定时器，如图所示：&lt;/p&gt;&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999226&quot; data-ratio=&quot;0.9181446111869032&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gyu1WibX54jVEVtCgaNp8ia8Vl8Emxbo5KQgOUgrOZoQq23QwqbOY3Vqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;p&gt;RTO是随着复杂网络环境而动态变化的，在拥塞控制中发生超时重传将会极大拉低cwnd，如果网络状况并没有那么多糟糕，&lt;span&gt;偶尔出现网络抖动造成丢包或者阻塞也非常常见&lt;/span&gt;，因此触发的慢启动将降低通信性能，故出现了快速重传机制。&lt;/p&gt;&lt;p&gt;所谓&lt;span&gt;快速重传时相比超时重传而言的&lt;/span&gt;，重发等待时间会降低并且后续尽量避免慢启动，来保证性能损失在最小的程度，如图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999230&quot; data-ratio=&quot;0.8612191958495461&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51geyvmD1oNxXzBjIjicibDUMvSnEW6GfhhEbJq8SIwc9mqctz94pib2MvVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;771&quot;/&gt;&lt;/p&gt;&lt;p&gt;快速重传和超时重传的区别在于cwnd在发生拥塞时的取值，&lt;span&gt;超时重传会将cwnd修改为最初的值，也就是慢启动的值，快速重传将cwnd减半，二者都将ssthresh设置为cwnd的一半&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;从二者的区别可以看到，快速重传更加主动，有利于保证链路的传输性能，但是有研究表明3个ACK的机制同样存在问题，本文就不做深入阐述了，感兴趣的读者可以自主查阅。&lt;/p&gt;&lt;p&gt;快速重传是基于对网络状况没有那么糟糕的假设，因此在实际网络确实还算好的时候，快速重传还是很有用的，在很差的网络环境很多算法都很难保证效率的。&lt;/p&gt;&lt;section&gt;在快速重传之后就会进入快速恢复阶段，此时的cwnd为上次发生拥塞时的cwnd的1/2，之后cwnd再线性增加重复之前的过程。&lt;/section&gt;&lt;h2&gt;&lt;span&gt;4.弱网环境的AIMD特性&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我们知道在网络链路中连接的数量是&lt;/span&gt;&lt;span&gt;动态变化且数量巨大的&lt;/span&gt;&lt;span&gt;，每一条连接都面临着一个黑盒子式的网络环境，这并不像我们平时出行时看看地图就知道哪里堵了，为了维护一个好的网络环境，每一条连接都需要遵守一些约定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果连接端都无所顾忌地发生数据包，那么网络链路很快就到了瓶颈了，数据通信完全无法保障，所以要到达一个&lt;/span&gt;&lt;span&gt;稳定高效的网络环境&lt;/span&gt;&lt;span&gt;还是需要费很大心思的，这其中有两个重要的概念：&lt;/span&gt;&lt;span&gt;公平性和收敛性&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说来惭愧笔者在网络上找了很多资料去理解TCP拥塞控制的&lt;/span&gt;&lt;span&gt;公平性和收敛性&lt;/span&gt;&lt;span&gt;，但是仍然没有获得一个很好的权威解释，所以只能结合一些资料和自身的理解去阐述所谓的公平性和收敛性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者认为公平性是相对于网络链路中的所有连接而言的，这些共享链路的连接启动和结束的时间不同，在实际的交互过程中每条连接占有带宽的机会是均等的，并且由于带宽限制连接双方通信的数据量是动态调整并且近似收敛于某个值，也就是呈现一个锯齿状或者更加平滑的波动曲线，对于基于丢包的拥塞控制算法而言&lt;/span&gt;&lt;strong&gt;&lt;span&gt;AIMD线性增乘性减&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;策略起了关键控制作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们来重点看下AIMD特性，先来贴一张经典的图，直观看AIMD的过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999233&quot; data-ratio=&quot;0.39344262295081966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoh9zic4x7tMaCvtKf3mBFkEtTFp9oD5icA1E2icqSGxicvvsia0CcyJ9IZHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;看看维基百科对于AIMD的定义：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;span&gt;additive-increase/multiplicative-decrease&lt;/span&gt;(AIMD) algorithm is a &lt;span&gt;feedback control algorithm&lt;/span&gt; best known for its use in TCP congestion control.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;AIMD combines &lt;span&gt;linear growth&lt;/span&gt; of the congestion window with an &lt;span&gt;exponential reduction&lt;/span&gt; when congestion is detected.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Multiple flows using AIMD congestion control will &lt;span&gt;eventually converge&lt;/span&gt; to use equal amounts of a shared link.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;The related schemes of multiplicative-increase/multiplicative-decrease (MIMD) and additive-increase/additive-decrease (AIAD) do not reach stability.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;简单翻译一下：线性增加乘性减少算法是一个&lt;/span&gt;&lt;span&gt;反馈控制算法&lt;/span&gt;&lt;span&gt;，因其在TCP拥塞控制中的使用而广为人知，&lt;/span&gt;&lt;span&gt;AIMD将线性增加拥塞窗口和拥塞时乘性减少窗口相结合&lt;/span&gt;&lt;span&gt;，基于AIMD的多个连接理想状态下会达到&lt;/span&gt;&lt;span&gt;最终收敛&lt;/span&gt;&lt;span&gt;，共享相同数量的网络带宽，与其相关的&lt;/span&gt;&lt;span&gt;乘性增乘性减MIMD策略&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;增性加增性减少AIAD&lt;/span&gt;&lt;span&gt;都&lt;/span&gt;&lt;span&gt;无法保证稳定性&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AIMD相比MIMD和AIAD在连接进入拥塞避免阶段使用试探线性加策略而不是乘性加策略&lt;/span&gt;&lt;span&gt;更加安全&lt;/span&gt;&lt;span&gt;，在探测丢包时则大幅度乘性减少到1/2这样对于缓解拥塞会有比较好的效果&lt;/span&gt;&lt;span&gt;更加快速&lt;/span&gt;&lt;span&gt;，相反如果探测到丢包时采用线性减少AD可能拥塞持续的时间会更长，总体来说AIMD算是一个比较简单实用的工程版本的反馈控制，也具备可&lt;/span&gt;&lt;span&gt;工程收敛性&lt;/span&gt;&lt;span&gt;，因而被广泛实用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间拉回20多年前，在&lt;/span&gt;&lt;span&gt;互联网早期&lt;/span&gt;&lt;span&gt;几乎所有的设备都是通过&lt;/span&gt;&lt;span&gt;有线网络&lt;/span&gt;&lt;span&gt;进行连接通信的，这也是拥塞控制在设计之后一直都起到不错作用的重要因素，有线连接的&lt;/span&gt;&lt;span&gt;网络稳定性比较好&lt;/span&gt;&lt;span&gt;，因此把丢包作为网络拥堵的一个特征也很正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再拉回到现在，从2010年之后&lt;/span&gt;&lt;span&gt;移动互联网&lt;/span&gt;&lt;span&gt;蓬勃发展，移动终端的持有量已经可以称为海量，无线网络的引入让网络环境变得更加复杂，因此&lt;/span&gt;&lt;span&gt;不稳定丢包变得更加频繁&lt;/span&gt;&lt;span&gt;，但是这时的&lt;/span&gt;&lt;span&gt;丢包就不一定是网络拥堵&lt;/span&gt;&lt;span&gt;造成的了，因为整个数据包经过多重路由、交换机、基站等基础通信设备每个环节都可能发生异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在弱网环境下，尤其是移动互联网中之前的&lt;/span&gt;&lt;span&gt;基于AIMD的拥塞控制策略可能会由于丢包的出现而大幅降低网络吞吐量&lt;/span&gt;&lt;span&gt;，从而对网络带宽的利用率也大大下降，这时我们采用&lt;/span&gt;&lt;span&gt;更加激进的控制策略&lt;/span&gt;&lt;span&gt;，或许可以获得更好的效果和用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;恶意丢包&lt;/span&gt;&lt;span&gt;的情况下，基于AIMD的拥塞控制确实就相当于被限速了，因为AIMD确实有些&lt;/span&gt;&lt;span&gt;保守谨慎&lt;/span&gt;&lt;span&gt;了，这个其实也很好理解的哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道在移动网络环境下是由终端以无线形式和附近的基站交互数据，之后数据传输至核心网，最后落到具体的服务器所在的有线网络，其中最后一公里的区域属于高延时场景，有线网络属于低延时高带宽场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在国外有相关实验证明弱网环境下RTT的变化对于使用传统拥塞控制算法下网络吞吐量的影响，数据和曲线如图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999231&quot; data-ratio=&quot;0.3291338582677165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoWUJwqykfZT3KMQICRl3ib66KTeOTmkx2zibY7V1icThr66lZafbn8w2kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999234&quot; data-ratio=&quot;0.5945945945945946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIo4T7iaC5r5B7jWb2NtRBXnmcdkDRzgRvkp6hsoUTZ2wOhpByDpdGPCtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;实验含义&lt;/strong&gt;：RTT的增大影响了比如CUBIC这类拥塞控制算法的慢启动等阶段，我们知道慢启动阶段&lt;span&gt;每经过1个RTT周期拥塞窗口cwnd将加倍&lt;/span&gt;，但是更大的RTT就意味着发送方以很低的速率发送数据，更多的时间是空闲的，发包的加速度极大将低了，所以整个吞吐量就下降很明显。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看下实验者的原文表述：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The delay before acknowledgment packets are received (= latency) will &lt;span&gt;have an impact on how fast the TCP congestion window increases&lt;/span&gt; (hence the throughput). &lt;/p&gt;&lt;p&gt;When latency is high, it means that &lt;span&gt;the sender spends more time idle (not sending any new packets)&lt;/span&gt;, which reduces how fast throughput grows.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;5.BBR算法基本原理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;BBR算法是个&lt;span&gt;主动的闭环反馈系统&lt;/span&gt;，通俗来说就是根据带宽和RTT延时来不断动态探索寻找合适的发送速率和发送量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看下维基百科对BBR算法的说明和资料：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;相关文献：&lt;span&gt;https://queue.acm.org/detail.cfm?id=3022184&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;TCP BBR(&lt;span&gt;Bottleneck Bandwidth and Round-trip propagation time&lt;/span&gt;)是由Google设计，并于2016年发布的拥塞算法，以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而&lt;span&gt;BBR基于模型主动探测&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;该算法使用网络最近出站数据分组当时的&lt;span&gt;最大带宽&lt;/span&gt;和&lt;span&gt;往返时间&lt;/span&gt;来创建网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;该算法认为随着网络接口控制器逐渐进入千兆速度时，&lt;span&gt;分组丢失不应该被认为是识别拥塞的主要决定因素&lt;/span&gt;，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法例如CUBIC。Google在YouTube上应用该算法，将全球平均的YouTube网络吞吐量提高了4%，在一些国家超过了14%。BBR之后&lt;span&gt;移植入Linux内核4.9版本&lt;/span&gt;，并且对于QUIC可用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;5.1 基于丢包反馈策略可能在的问题&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;基于丢包反馈属于&lt;span&gt;被动式机制&lt;/span&gt;，根源在于这些拥塞控制算法依据是否出现丢包事件来判断网络拥塞做减窗调整，这样就可能会出现一些问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;丢包即拥塞&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;现实中网络环境很复杂会存在错误丢包，很多算法无法很好区分拥塞丢包和错误丢包，因此在存在一定错误丢包的前提下在某些网络场景中并不能充分利用带宽。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;缓冲区膨胀问题BufferBloat&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;网络连接中路由器、交换机、核心网设备等等为了平滑网络波动而存在缓冲区，这些缓存区就像输液管的膨胀部分让数据更加平稳，但是Loss-Based策略在最初就像网络中发生数据类似于灌水，此时是将Buffer全部算在内的，一旦buffer满了，就可能出现RTT增加丢包等问题，就相当于有的容量本不该算在其中，但是策略是基于包含Buffer进行预测的，特别地在深缓冲区网络就会出现一些问题。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;网络负载高但无丢包事件&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;假设网络中的负载已经很高了，只要没有丢包事件出现，算法就不会主动减窗降低发送速率，这种情况下虽然充分利用了网络带宽，同时由于一直没有丢包事件出现发送方仍然在加窗，表现出了较强的网络带宽侵略性，加重了网络负载压力。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;高负载丢包&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;高负载无丢包情况下算法一直加窗，这样可以预测丢包事件可能很快就出现了，一旦丢包出现窗口将呈现乘性减少，由高位发送速率迅速降低会造成整个网络的瞬时抖动性，总体呈现较大的锯齿状波动。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;低负载高延时丢包&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在某些弱网环境下RTT会增加甚至出现非拥塞引起丢包，此时基于丢包反馈的拥塞算法的窗口会比较小，对带宽的利用率很低，吞吐量下降很明显，但是实际上网络负载并不高，所以在弱网环境下效果并不是非常理想。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;5.2 TCP BBR算法基本原理&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前面我们提到了一些Loss-Based算法存在的问题，TCP BBR算法是一种&lt;/span&gt;&lt;span&gt;主动式机制&lt;/span&gt;&lt;span&gt;，简单来说BBR算法不再基于丢包判断并且也不再使用AIMD线性增乘性减策略来维护拥塞窗口，而是分别采样估计极大带宽和极小延时，并用二者乘积作为发送窗口，并且BBR引入了Pacing Rate限制数据发送速率，配合cwnd使用来降低冲击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.1 一些术语&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;BDP&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;BDP是&lt;/span&gt;&lt;span&gt;Bandwidth-Delay Product&lt;/span&gt;&lt;span&gt;的缩写，可以翻译为&lt;/span&gt;&lt;span&gt;带宽延时积&lt;/span&gt;&lt;span&gt;，我们知道带宽的单位是bps(bit per second)，延时的单位是s，这样BDP的量纲单位就是bit，从而我们知道BDP就是衡量一段时间内链路的数据量的指标。这个可以形象理解为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;水管灌水&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;问题，&lt;/span&gt;&lt;span&gt;带宽就是水管的水流速度立方米/s，延时就是灌水时间单位s，二者乘积我们就可以知道当前水管内存储的水量&lt;/span&gt;&lt;span&gt;了，这是BBR算法的一个关键指标，来看一张&lt;/span&gt;&lt;span&gt;陶辉大神文章&lt;/span&gt;&lt;span&gt;中的图以及一些&lt;/span&gt;&lt;span&gt;网络场景中的BDP计算&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999232&quot; data-ratio=&quot;0.8405466970387244&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiahOd3lPQgCnImemQQylP81QiaEUDU9uuSIIRPcTozWQvSarSZmDEZyWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;439&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.2 带宽和延时的测量&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;BBR算法的一些思想在之前的基于延时的拥塞控制算法中也有出现，其中必有有名的是TCP WestWood算法。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;TCP Westwood改良自New Reno，不同于以往其他拥塞控制算法使用丢失来测量，其通过对确认包测量来确定一个合适的发送速度，并以此调整拥塞窗口和慢启动阈值。其改良了慢启动阶段算法为敏捷探测和设计了一种持续探测拥塞窗口的方法来控制进入敏捷探测，使链接尽可能地使用更多的带宽。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;TCP WestWood算法也是基于带宽和延时乘积进行设计的，但是带宽和延时两个指标无法同时测量，因为这两个值是有些矛盾的极值，要测量最大带宽就要发送最大的数据量但是此时的RTT可能会很大，如果要测量最小的RTT那么久意味着数据量非常少最大带宽就无法获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TCP BBR算法采用&lt;/span&gt;&lt;span&gt;交替采样测量两个指标&lt;/span&gt;&lt;span&gt;，取一段时间内的带宽极大值和延时极小值作为估计值，具体的实现本文就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.3 发送速率和RTT曲线&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;前面提到了BBR算法核心是寻找BDP最优工作点，在相关论文中给出了一张组合的曲线图，我们一起来看下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999236&quot; data-ratio=&quot;1.3318649045521291&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiarUUyiaS2QyCplCFaQhsx2B3BWUz9h3b8K5vtaW65vfO51dB6s9b3lsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.曲线图示说明：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;这张图是由两个图组合而成，目前是展示[&lt;/span&gt;&lt;span&gt;数据发送速率vs网络数据&lt;/span&gt;&lt;span&gt;]和[&lt;/span&gt;&lt;span&gt;RTTvs网络数据]&lt;/span&gt;&lt;span&gt;的关系&lt;/span&gt;&lt;span&gt;，横轴是网络数据数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两个纵轴从上到下分别为RTT和发送速率，并且整个过程分为了3个阶段：&lt;/span&gt;&lt;span&gt;应用限制阶段、带宽限制阶段、缓冲区限制阶段&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.曲线过程说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;app limit应用限制阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在这个阶段是应用程序开始发送数据，目前网络通畅RTT基本保持固定且很小，发送速率与RTT成反比，因此发送速率也是线性增加的，可以简单认为这个阶段有效带宽并没有达到上限，RTT是几乎固定的没有明显增长。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;band limit带宽限制阶段&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;随着发送速率提高，网络中的数据包越来越多开始占用链路Buffer，此时RTT开始增加发送速率不再上升，有效带宽开始出现瓶颈，但是此时链路中的缓存区并没有占满，因此数据还在增加，RTT也开始增加。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;buffer limit缓冲区限制阶段&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;随着链路中的Buffer被占满，开始出现丢包，这也是探测到的最大带宽，这个节点BDP+BufferSize也是基于丢包的控制策略的作用点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;3.一些看法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网上有一些资料都提及到了这张图，其中的一些解释也并不算非常清晰，结合这些资料和自己的认识，笔者认为在网络链路的缓存区没有被使用时RTT为最小延时MinRTT，在网络链路缓冲区被占满时出现最大带宽MaxBW(链路带宽+链路缓存)，但是此时的MaxBW和MinRTT并不是最优的而是水位比较高的水平，有数据表明按照2ln2的增益计算此时为3BDP，&lt;/span&gt;&lt;span&gt;整个过程中MinRTT和MaxBW是分开探测的，因为这二者是不能同时被测量的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.4 BBR算法的主要过程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;BBR算法和CUBIC算法类似，也同样有几个过程：&lt;/span&gt;&lt;span&gt;StartUp、Drain、Probe_BW、Probe_RTT，来看下这几个状态的迁移情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999235&quot; data-ratio=&quot;1.0029850746268656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaXzsdKUuA6tfmR8FsQGbl2ic6R4JxibXhvLLCgAKCG5efop4BniaMjYiaBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;StartUp慢启动阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;BBR的慢启动阶段类似于CUBIC的慢启动，同样是进行探测式加速区别在于BBR的慢启动使用2ln2的增益加速，过程中即使发生丢包也不会引起速率的降低，而是依据返回的确认数据包来判断带宽增长，直到带宽不再增长时就停止慢启动而进入下一个阶段，需要注意的是在寻找最大带宽的过程中产生了多余的2BDP的数据量，关于这块可以看下英文原文的解释：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;To handle Internet link bandwidths spanning 12 orders of magnitude, Startup implements a binary search for BtlBw by using a gain of 2/ln2 to double the sending rate while delivery rate is increasing. This discovers BtlBw in log2BDP RTTs but creates up to 2BDP excess queue in the process.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Drain排空阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;排空阶段是为了把慢启动结束时多余的2BDP的数据量清空，此阶段发送速率开始下降，也就是单位时间发送的数据包数量在下降，直到未确认的数据包数量&amp;lt;BDP时认为已经排空，也可以认为是RTT不再下降为止，排空阶段结束。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ProbeBW带宽探测阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;经过慢启动和排空之后，目前发送方进入稳定状态进行数据的发送，由于网络带宽的变化要比RTT更为频繁，因此ProbeBW阶段也是BBR的主要阶段，在探测期中增加发包速率如果数据包ACK并没有受影响那么就继续增加，探测到带宽降低时也进行发包速率下降。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ProbeRTT延时探测阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;前面三个过程在运行时都可能进入ProbeRTT阶段，当某个设定时间内都没有更新最小延时状态下开始降低数据包发送量，试图探测到更小的MinRTT，探测完成之后再根据最新数据来确定进入慢启动还是ProbeBW阶段。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;我&lt;/span&gt;&lt;span&gt;们来看一下这四个过程的示意图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999238&quot; data-ratio=&quot;0.878234398782344&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiagVP4g575v25OZHvpyzsGf0VzicE7lOoRoSBFtCcqXjkkTMy7WGKUN1A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;曲线说明&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;这两个坐标给出了10Mbps和40msRTT的网络环境下CUBIC和BBR的一个对比过程，在上面的图中蓝色表示接收者，红色表示CUBIC，绿色表示BBR，在下面的图中给出了对应上图过程中的RTT波动情况，红色代表CUBIC，绿色代表BBR。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5.3 TCP-BBR算法效果&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;有一些文章认为BBR有鲜明的特点，把拥塞控制算法分为BBR之前和BBR之后，可见BBR还是有一定影响，但是&lt;/span&gt;&lt;span&gt;BBR算法也不是银弹&lt;/span&gt;&lt;span&gt;，不过可以先看看BBR算法在谷歌推动下的一些应用效果，其中包括&lt;/span&gt;&lt;span&gt;吞吐量、RTT、丢包率影响&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999237&quot; data-ratio=&quot;0.5726872246696035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaXdGY3SNFyOGsGWGicMqicabV9SVpIWch8NrtzE9oMzfJfVr0kIWZWvSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999239&quot; data-ratio=&quot;0.6067746686303387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaB4Ev09wu4ZliavL6X6ibTIQDqSlSRBAsnfGic5cA81fEh1icaZjEQjF21g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;502999240&quot; data-ratio=&quot;0.41853932584269665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaycd5HSmfubJWyp9wmQRe8wsQwa006fu5WLAvL3SFy2qJNz96tqL0VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图中我们可以看到在YouTube应用BBR算法之后，就吞吐量普遍有4%左右的提升，特别地在日本的提升达到14%，RTT的下降更为明显平均降低33%，其中IN(印度地区)达到50%以上，在丢包率测试中BBR并不想CUBIC那么敏感，在丢包率达到5%是吞吐量才开始明显下降。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;6.参考文献&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://cloud.tencent.com/developer/article/1369617&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://cloud.tencent.com/developer/article/1383232&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://queue.acm.org/detail.cfm?id=3022184&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/63888741&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;span&gt;--- EOF ---&lt;/span&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxNTcyNzAyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/NW4iaKVI4GNOJHFfxs3Dq0jLTT7riaETbUFsDsjYiaOftPu1tdHm0icq8sgibZo5ZEiaHGbLLxSVrd3B5psBZVwVCdHQ/0?wx_fmt=png&quot; data-nickname=&quot;运维&quot; data-alias=&quot;Operation1024&quot; data-signature=&quot;分享网络管理、网络运维、运维规划、运维开发、Python运维、Linux运维等知识，推广围绕DevOps理念的自动化运维、精益运维、智能运维等优秀实践，让运维工程师更加专注于自动化。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5d9a0a898cb45cb198b6ae822b083b1</guid>
<title>给 MVC 三层架构加一层 Manager 层</title>
<link>https://toutiao.io/k/kcftpfu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MVC三层架构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在刚刚成为程序员的时候，就会被前辈们 “教育” 说系统的设计要遵循 &lt;span&gt;MVC（Model-View-Controller）&lt;/span&gt;架构。它将整体的系统分成了 Model（模型），View（视图）和 Controller（控制器）三个层次，也就是将用户视图和业务处理隔离开，并且通过控制器连接起来，很好地实现了表现和逻辑的解耦，是一种标准的软件分层架构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100013168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jvOvUyny8Mtj1Vib6s4gUs1RfqlNJTriae4ljJq3T3mEpiah4ia83SnsBibicOgiayrnHiafiaVxmMIoMo2Pg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;MVC三层架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVC分层架构是架构上最简单的一种分层方式。为了遵循这种分层架构我们在构建项目时往往会建立这样三个目录：controller、service 和 dao，它们分别对应了表现层、逻辑层还有数据访问层。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100013166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jvOvUyny8Mtj1Vib6s4gUs1IjT46f1NE7WpaD7n3tGtRvY2SFFJtQFBjHFeCR4l5BNdQ7awzcgyCw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;三层架构示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每层的作用如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Controller层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Service层：主要是处理业务逻辑和事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Dao层：负责与底层数据库MySQL，Oracle等进行数据交互&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是随着我们的业务逻辑越来复杂，代码写的越来越多，这种简单的三层架构的问题也越来越明显。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MVC架构弊端&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的MVC分层有以下几个很明显的问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Service层代码臃肿&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Service层很容易出现大事务，事务嵌套，导致问题很多，而且极难排查&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dao层参杂业务逻辑&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dao层sql语句复杂，关联查询比较多&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我们参考《alibaba java开发手册》，在Service层之下再独立出一个通用业务处理层（Manager层）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100013167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jvOvUyny8Mtj1Vib6s4gUs1490ZdUQhAqnv0TezMoO9KESYZnK80Au2VKrbTwhfMr0G7ZF3n6lIKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Manager层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个分层架构中主要增加了 Manager 层，它与 Service 层的关系是：Manager 层提供原子的服务接口，Service 层负责依据业务逻辑来编排原子接口。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Manager层的特征&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《alibaba java开发手册》中是这样描述Manager层的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;Manager 层：通用业务处理层，它有如下特征：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与 DAO 层交互，对多个 DAO 的组合复用。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际开发中我们可以这样使用Manager层&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;复杂业务，service提供数据给Manager层，负责业务编排，然后把事务下沉到Manager层，Manager层不允许相互调用，不会出现事务嵌套。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;专注于不带业务sql语言，也可以在manager层进行通用业务的dao层封装。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;避免复杂的join查询，数据库压力比java大很多，所以要严格控制好sql，所以可以在manager层进行拆分，比如复杂查询。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然对于简单的业务，可以不使用Manager层。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Manager层使用案例&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们举个例子说明一下Manager层的使用场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你有一个用户系统，他有一个获取用户信息的接口，它调用逻辑Service层的 &lt;code&gt;getUser&lt;/code&gt; 方法，&lt;code&gt;getUser&lt;/code&gt;方法又和 &lt;code&gt;User DB&lt;/code&gt; 交互获取数据。如下图左边展示部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，产品提出一个需求，在 APP 中展示用户信息的时候，如果用户不存在，那么要自动给用户创建一个用户。同时，要做一个 HTML5 的页面，HTML5 页面要保留之前的逻辑，也就是不需要创建用户。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100013169&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jvOvUyny8Mtj1Vib6s4gUs1ztmLjskmCic0TtQe2oTwQck1v88IhYNZxwOCvRRwibbqbHulh2VZr87w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时按照传统的三层架构，逻辑层的边界就变得不清晰，表现层也承担了一部分的业务逻辑，因为我们往往会在表现层Controller中增加业务逻辑处理，将获取用户和创建用户接口编排起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而添加Manager层以后，Manager 层提供创建用户和获取用户信息的接口，而 Service 层负责将这两个接口组装起来。这样就把原先散布在表现层的业务逻辑都统一到了 Service 层，每一层的边界就非常清晰了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们看一段实际代码说明一下Service层与Manager层如何进行区分？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = Throwable&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;span&gt;upOrDown&lt;/span&gt;(&lt;span&gt;Long&lt;/span&gt; &lt;span&gt;departmentId&lt;/span&gt;, &lt;span&gt;Long&lt;/span&gt; &lt;span&gt;swapId&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 验证 1&lt;/span&gt;&lt;br/&gt;  DepartmentEntity departmentEntity = departmentDao.selectById(departmentId);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (departmentEntity == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Result.error(&lt;span&gt;&quot;部门xxx不存在&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 验证 2&lt;/span&gt;&lt;br/&gt;  DepartmentEntity swapEntity = departmentDao.selectById(swapId);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (swapEntity == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Result.error(&lt;span&gt;&quot;部门xxx不存在&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 验证 3&lt;/span&gt;&lt;br/&gt;  Long count = employeeDao.countByDepartmentId(departmentId);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (count != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; count &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Result.error(&lt;span&gt;&quot;员工不存在&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 操作数据库 4&lt;/span&gt;&lt;br/&gt;  Long departmentSort = departmentEntity.getSort();&lt;br/&gt;  departmentEntity.setSort(swapEntity.getSort());&lt;br/&gt;  departmentDao.updateById(departmentEntity);&lt;br/&gt;  swapEntity.setSort(departmentSort);&lt;br/&gt;  departmentDao.updateById(swapEntity);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Result.OK(&lt;span&gt;&quot;success&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码在我们在我们采用三层架构时经常会遇到，&lt;span&gt;那么它有什么问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码是典型的长事务问题（&lt;em&gt;类似的还有调用第三方接口&lt;/em&gt;），前三步都是使用 connection 进行验证操作，但是由于方法上有@Transactional 注解，所以这三个验证都是使用的同一个 connection。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若对于复杂业务、复杂的验证逻辑，会导致整个验证过程始终占用该 connection 连接，占用时间可能会很长，直至方法结束，connection 才会交还给数据库连接池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂业务的不可预计的情况，长时间占用同一个 connection 连接不是好的事情，应该尽量缩短占用时间。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;&lt;em&gt;说明：对于@Transactional 注解，当 spring 遇到该注解时，会自动从数据库连接池中获取 connection，并开启事务然后绑定到 ThreadLocal 上，如果业务并没有进入到最终的 操作数据库环节，那么就没有必要获取连接并开启事务，应该直接将 connection 返回给数据库连接池，供其他使用。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们在加入Manager层以后可以这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DepartmentService.&lt;span&gt;java&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Result&amp;lt;String&amp;gt; &lt;span&gt;upOrDown&lt;/span&gt;&lt;span&gt;(Long departmentId, Long swapId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 验证 1&lt;/span&gt;&lt;br/&gt;  DepartmentEntity departmentEntity = departmentDao.selectById(departmentId);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (departmentEntity == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Result.error(&lt;span&gt;&quot;部门xxx不存在&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 验证 2&lt;/span&gt;&lt;br/&gt;  DepartmentEntity swapEntity = departmentDao.selectById(swapId);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (swapEntity == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Result.error(&lt;span&gt;&quot;部门xxx不存在&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 验证 3&lt;/span&gt;&lt;br/&gt;  Long count = employeeDao.countByDepartmentId(departmentId);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (count != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; count &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Result.error(&lt;span&gt;&quot;员工不存在&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 操作数据库 4&lt;/span&gt;&lt;br/&gt;  departmentManager.upOrDown(departmentSort,swapEntity);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Result.OK(&lt;span&gt;&quot;success&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DepartmentManager.java&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = Throwable&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;upOrDown&lt;/span&gt;(&lt;span&gt;DepartmentEntity&lt;/span&gt; &lt;span&gt;departmentEntity&lt;/span&gt; ,&lt;span&gt;DepartmentEntity&lt;/span&gt; &lt;span&gt;swapEntity&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  Long departmentSort = departmentEntity.getSort();&lt;br/&gt;  departmentEntity.setSort(swapEntity.getSort());&lt;br/&gt;  departmentDao.updateById(departmentEntity);&lt;br/&gt;  swapEntity.setSort(departmentSort);&lt;br/&gt;  departmentDao.updateById(swapEntity);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将数据在 service 层准备好，然后传递给 manager 层，由 manager 层添加&lt;code&gt;@Transactional&lt;/code&gt;事务注解进行数据库操作。&lt;/p&gt;&lt;hr/&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好了，今天的文章就到这里了，看完对你有没有收获呢？欢迎留言评论！&lt;/span&gt;&lt;span&gt;最后，&lt;/span&gt;&lt;span&gt;我是飘渺Jam，一名写代码的架构师，做架构的程序员，期待您的转发与关注，当然也可以通过下方二维码添加我的个人微信 &lt;/span&gt;&lt;span&gt;，咱们一起聊技术！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100013200&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4iaaq1LHN5nmBoW0HpH70QAzKz7kqcXajmMbhLkK7rc6CRLcKhybrXOkejBIMwTr56xxbGiameeNPEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&amp;lt; END &amp;gt;&lt;/span&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p data-darkmode-bgcolor-162350995814910=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-162350995814910=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-162350995814910=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-162350995814910=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;margin-top: 15px; margin-bottom: 10px; padding-left: 8px; max-width: 100%; min-height: 1em; color: rgb(63, 63, 63); font-size: 16px; letter-spacing: 0.544px; text-align: left; white-space: normal; background-color: rgb(255, 255, 255); word-spacing: 2px; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__74&quot;&gt;&lt;strong data-darkmode-bgcolor-162350995814910=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-162350995814910=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-162350995814910=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-162350995814910=&quot;#fff|rgb(63, 63, 63)&quot;&gt;往期精选：&lt;/strong&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-162350995814910=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-162350995814910=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-162350995814910=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-162350995814910=&quot;#fff|rgb(63, 63, 63)&quot; data-style=&quot;margin-top: 15px; margin-bottom: 10px; padding-left: 8px; max-width: 100%; min-height: 1em; color: rgb(63, 63, 63); font-size: 16px; letter-spacing: 0.544px; text-align: left; white-space: normal; background-color: rgb(255, 255, 255); word-spacing: 2px; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__74&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;amp;mid=2247496457&amp;amp;idx=1&amp;amp;sn=f5ba01dba3c7e142a7265a8e096da916&amp;amp;chksm=9ad3e948ada4605ed8617224ae1c0ab5ff846edace414485fb548b28138eb9ac70f57d50d497&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;慎入警告！某架构师去面试，被问到如何设计海量商品数据的存储？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;慎入警告！某架构师去面试，被问到如何设计海量商品数据的存储？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>