<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b49a42eff0c1692872c7c746729f4c65</guid>
<title>万字入门推荐系统</title>
<link>https://toutiao.io/k/84f5zio</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近一周我、强子、Y哥三人，根据自身如何入门推荐系统，再结合三人分别在腾讯做广告推荐、字节做视频推荐、百度做信息流推荐的经历，整理出了这份万字入门推荐系统。内容十分详细，涵盖了推荐系统基础、进阶、实战的全部知识点，并且每一块都给出了我们自己看过且觉得高质量的参考资料，所以不管你是科班还是非科班，按照这条路线走下去，找到推荐系统相关工作是完全没问题的。&lt;span&gt;因为内容过于全面详细，即便你不从事推荐系统方向，只要是从事程序员，看完这篇文章也能有所收获。&lt;/span&gt;&lt;span&gt;不过要先强调一下，如果是没有基础且时间充足的同学，可以按部就班的学，如果有一定基础或时间紧张，那就直接看核心知识。&lt;/span&gt;&lt;span&gt;其中『 机器学习、深度学习、推荐算法理论知识、推荐系统实战项目 』这四块是核心知识，像数学、计算机基础可以等到你需要的时候再反过头来学习。&lt;/span&gt;&lt;span&gt;在核心知识中也有次重点，要学会有的放矢，哪些知识是次重点，我都会在后面一一说明。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文框架目录如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000174&quot; data-ratio=&quot;0.9549071618037135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SFQibCRMrWdac6xDrAC922L4OI9NoYndjQI0Ocwbrp1Wj8BLMuCe9qUuMAojjXuGKyLFjHQuBytAZUWjKCmakrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1131&quot;/&gt;&lt;figcaption&gt;万字入门推荐系统&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数学&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是微积分、线性代数、概率论这三门课。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微积分&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，机器学习需要得到一个函数（模型，或者说假设）来预测未来的数据。既然是函数，那自然就离不开微积分了。微积分为我们研究函数的性质提供了理论依据，同时它也是学习概率论、最优化方法等后续课程的基础，是整个高等数学的基石。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点掌握&lt;strong&gt;函数的求导法则（特别是链式法则），以及泰勒公式&lt;/strong&gt;。这对后续的梯度下降法，牛顿法，拟牛顿法等优化算法的推导至关重要！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;线性代数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;机器学习算法的输入、输出、中间结果通常为向量、矩阵、张量。这些都属于线性代数里的知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点掌握向量、矩阵含义及其数学运算公式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概率论&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于机器学习来说，概率论是一种重要的工具。如果将机器学习算法的输入、输出看作随机变量/向量，则可以用概率论的观点对问题进行建模。使用概率论的一个好处是可以对不确定性进行建模，这对于某些问题是非常有必要的。另外，它还可以挖掘变量之间的概率依赖关系，实现因果推理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点掌握常见概率分布、概率公式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数学好是入门机器学习的优势，但并非关键。因为数学知识量太庞大了，花太多时间在其上，容易打击学习积极性。另外做算法一般分两种：&lt;strong&gt;理论模型和实际应用&lt;/strong&gt;，前者的行业title是算法研究员，主要发paper、提出新的模型或者优化方法，所以对于数学能力要求很高。后者的行业title是算法工程师，致力于把模型应用于数据上，攫取商业价值，对于数学能力要求并不高。往往大部分人都属于后者，我个人也是后者。&lt;strong&gt;熟悉不同算法的应用场景、掌握模型落地工程技术&lt;/strong&gt;，才是我们更应该投入精力的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;《DeepLearning》，又名「花书」，被誉为深度学习领域圣经。它前面有必备数学知识的介绍，讲得挺不错的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B站搜索微积分、线性代数、概率论关键词，会有很多教学视频，随便选取时长较短的看看即可。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;计算机基础&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机基础包含数据结构与算法、计算机组成原理、操作系统、计算机网络、数据库、五大课程。其中数据结构与算法是面试必考内容，大家都会花时间好好学。但是另外4门课，开发岗面试中一定会问，算法岗却很少会问，再加上很多做算法的人是转行过来，非计算机科班出身，大学期间没有上过此类专业课。所以很多做算法的人计算机基础比较薄弱。但是在我看来计算机基础是很重要的。一是能提高我们计算机素养，二是增加工程代码理解能力。所以后面我会针对这四门课程，出一个面向算法工程师的系列文章，做到让大家对这些课程重点知识有个了解，同时又不会陷入细枝末节。这里先给大家做个大概讲解：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据结构与算法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据结构包含：&lt;strong&gt;数组、链表、栈、队列、树、散列表、图&lt;/strong&gt;。数据结构本质是描述数据与数据之间的关系&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法包含：&lt;strong&gt;排序、查找、五大经典算法（动态规划、回溯、分支界限、分治、贪心）&lt;/strong&gt;。计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举。算法设计的本质无非就是先思考「如何穷举」，然后再追求「如何聪明地穷举」。「聪明的穷举」分为两部分：「去掉重复的穷举」、「去掉不必要的穷举」。比如，备忘录法，用数组保存求过的结果，用空间换时间，这就是去掉重复的穷举；动态规划根据最优子结构，使当前问题只与某几个子问题有关，从而大大减少问题分解次数，这就是去掉不必要穷举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;《剑指offer》，准备过面试的人应该都知道这本书。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《大话数据结构》通俗易懂。剩下的就是多刷LeetCode，多看别人的题解。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;计算机组成原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲解计算机组成结构。主要由CPU（运算器、控制器），存储器（内存、外存），IO设备（输入、输出设备），总线这几部分构成。如果把计算机比作人，那么&lt;strong&gt;CPU是人的大脑，负责控制全身和运算；内存是人的记忆，负责临时存储；外存是人的笔记本，负责永久存储；输入设备是耳朵或眼睛或嘴巴，负责接收外部的信息存入内存；输出设备是你的脸部（表情）或者屁股，负责输出处理后的结果；以上所有的设备都通过总线连接，总线相当于人的神经&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;操作系统&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是应用程序与硬件之间的管家：对下管理计算机硬件资源（CPU、存储器、IO设备）、对上管理应用程序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000171&quot; data-ratio=&quot;0.7893700787401575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SFQibCRMrWdac6xDrAC922L4OI9NoYndjdgNTU6ibxNmHwADicqWIupmKq04bZMj3qcIXf5icIBbMoNMCSUo1rxsjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核（kernel）是直接控制硬件的。比如：内核控制硬件有1000种方式，导致直接调内核去操作硬件很麻烦，于是就封装内核，向外提供了易于调用的接口，比如：桌面系统、shell等。这些接口对非编程人员用户还是不友好，于是编程人员用编程语言再对这些接口在进行封装，就产生了应用程序。本质是封装的思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们学的编程语言到最后都是在调用操作系统内核API。所以这也是为什么所有的语言都有不同操作系统版本，因为每个操作系统的内核API是不同的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;《深入理解计算机系统》，配套视频：https://www.bilibili.com/video/BV1cD4y1D7uR&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《鸟哥的Linux私房菜》，Linux是最常用的服务器系统，也是我们工作中最常接触的。熟悉Linux常用命令很有必要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;计算机网络&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多教材都是从五层模型（物理层、数据链路层、网络层、传输层、应用层）讲解。其实这样讲是比较晦涩难懂的，因为很多东西我们都没接触过，很陌生。好的办法是通过人类的语言系统进行类比。计算机网络是计算机的语言系统，与人类语言系统的本质是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人类语言系统构成：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;词汇&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;声带+耳朵&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传播介质：空气&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以此类比到计算机网络：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据：计算机之间传输的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通信协议：决定数据的排列方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网卡：数据发射器与接收器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传播介质：光纤、网线、WIFI&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外还有人的身份证相当于Mac地址，家庭地址相当于IP地址等等。计算机网络中的许多概念都可以用生活中人类是如何通信的进行类比。人类通信我们是非常熟悉的，所以非常有助于我们理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;《计算机网络自顶向下方法》这本书相比于其他计算机网络书籍较通俗易懂，学习起来应该不太费劲。这本书重点章节是第2、3、4、5、6章，其他章节可以跳过。配套视频：https://www.bilibili.com/video/BV1mb4y1d7K7&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;谢希仁的《计算机网络》，是国内很有名的教材。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库就是我们存储数据的工具。数据如何存储与读取，直接决定了整个系统的效率。常用的关系型数据库是MySQL，非关系型数据库是Redis&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;《SQL必知必会》，快速掌握常用的SQL语法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一天学会 MySQL 数据库：https://www.bilibili.com/video/BV1Vt411z7wy&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;机器学习&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人工智能、机器学习、深度学习关系如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000172&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SFQibCRMrWdac6xDrAC922L4OI9NoYndjeGGmtBb0GkHDapb5xibf29gKz4ia064kavB1n68niaTeXWmw7faHLgPrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般说机器学习都是指除了深度学习以外的机器学习，也称为传统机器学习。虽然近几年深度学习越来越火，但是很多领域还是在使用机器学习，并且学好机器学习，对于AI算法基础和知识广度都有很大提高。这里可以先给大家罗列一些必备的基础知识:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要知道一些基础的术语和概念，比如有监督与无监督，训练集，验证集与测试集，经验误差与泛化误差，方差与偏差，过拟合与欠拟合等，再比如比较重要的一些模型性能度量方法(混淆矩阵，精确率，召回率，auc，roc等)， 再比如经典的评估方法(留出，交叉验证，自助等)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次是经典的模型。机器学习模型非常多，全部掌握不现实，我给大家罗列几个经典，也是面试中常考的模型：&lt;strong&gt;逻辑回归、SVM、树模型、集成学习、朴素贝叶斯、K-Means聚类、PCA&lt;/strong&gt;。（EM、最大熵、概率图这些考的少，能了解是加分项）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在学习过程中，各个模型是相互联系的，不要孤立去分析单个模型。比如：逻辑回归，我认为是最基础、也最重要的模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000170&quot; data-ratio=&quot;0.4148148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SFQibCRMrWdac6xDrAC922L4OI9NoYndjrJUwKSq3ZGH6vrg4EsibGNicq6icZ0PlrH5uajWwB4C8D2GlDDqLWnVBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;逻辑回归=线性回归+sigmoid激活函数，从而将回归问题转换为分类问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑回归+矩阵分解，构成了推荐算法中常用的FM模型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑回归+softmax，从而将二分类问题转化为多分类问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑回归还可以看做单层神经网络，相当于最简单的深度学习模型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过逻辑回归由点及面，就能演化出如此多模型。再比如树模型。我们把以决策树为基础的一系列模型统称为树模型，也是AI比赛中最常用的模型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;决策树经历了三次改进，ID3、C4.5、CART，主要区别在于一个根据信息增益划分特征、一个根据信息增益率、一个根据基尼指数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随机森林=决策树+Bagging集成学习&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GBDT=决策树+AdaBoost集成学习&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XGB是陈天奇2014年提出，相当于GBDT的工程改进版，在实用性和准确度上有很大提升。比如：使用泰勒二阶展开近似损失函数，支持处理缺失值、在特性粒度上并行计算等等特性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LGB是微软2016年提出，对XGB进行了改进，使用单边梯度采样算法减少不必要的样本；在寻找最优分割点时采用直方图算法使计算代价更小；支持类别特征...&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CGB是Yandex2017年提出，对类别特征进行了更完美的支持。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以学习模型，要由点及面，层层递进。这样不仅方便理解，也有利于归纳总结，同时还能锻炼搭建知识体系的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于上面这些知识，整理一个系列帮助大家由点及面打通这块知识，文章已写了五篇，后面会陆续放出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为最好的实战方式就是参加AI比赛。这个过程中不仅能与高手同台竞技，如果获奖还能拿到不菲的奖金（很多比赛奖金都是10万以上）与荣誉。我之前参加了很多比赛，拿过冠军和多个top 10。对于我个人能力提升与找工作都有很大帮助。这里推荐三个公众号：kaggle竞赛宝典、Coggle数据科学、第一次打比赛。他们会发布新比赛的通知与过往比赛的解决方案，非常值得学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再就是书籍：《机器学习算法竞赛实战》这本书是Datawhale成员，top级竞赛选手鱼佬写的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是一个机器学习小白，那么推荐两个入门视频， 吴恩达或者李宏毅的ML视频（B站上都有），先快速过一遍，了解机器学习是什么。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有了一定的机器学习基础，就需要去进阶。建议是看书与高质量文章。推荐两本书：周志华的《机器学习》、李航的《统计学习方法》这两本书，可以好好先研究一本，注意这里是研究，一本通了，另一本也就差不多。如果发现看一遍很难看懂，这是正常现象，随着后面实践经历慢慢变多，再看一遍，会有很多新的感悟。再就是公众号：Datawhale，里面有很多高质量文章。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：学习过程中一定要跟着实战，否则知识很难真正理解。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;深度学习&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面也提到了，深度学习本属于机器学习，但是鉴于其发展迅速、应用越来越广泛，所以单独拿出来说。深度学习每年新模型、新技术层出不穷，一味追求新技术不可取，要先打好基础。比如：对于一个简单的全连接神经网络，包含&lt;strong&gt;训练算法&lt;/strong&gt;（正向传播、反向传播），&lt;strong&gt;激活函数&lt;/strong&gt;（sigmoid、ReLU、Maxout、softmax等），&lt;strong&gt;正则化&lt;/strong&gt;（L1和L2、Dropout、提前早停等），&lt;strong&gt;优化算法&lt;/strong&gt;（随机梯度下降、Momentum、Adagrad、Adam等）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掌握了基础后，再根据自身领域学习相关的模型。大部分人找工作属于这三个领域：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算机视觉（CV）：卷积神经网络（CNN）及其改进。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自然语言处理（NLP）：循环神经网络（RNN）及其改进，Transformer、Bert等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推荐算法：Embeding、Wide &amp;amp; Deep及其改进。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟练使用TensorFlow或pytorch去实现训练模型。通过官网的一些demo就可以快速的掌握一个深度学习框架的基本用法，然后在实际的应用中再去了解一些框架的高级用法，这个不需要花太多的时间单独学习，应该边用边学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;积累模型调参经验&lt;/strong&gt;，比如学习率，batchsize, 优化器对模型的影响，使用tensorboard可视化训练过程的曲线，通过曲线分析训练过程的相关问题，然后再调参或者调解网络结构，在实践的过程中要有意识的去总结一些经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;李沐《动手学深度学习》https://zh-v2.d2l.ai/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;邱锡鹏《神经网络与深度学习》https://nndl.github.io/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;吴恩达《深度学习》https://www.bilibili.com/video/BV1FT4y1E74V&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《DeepLearning》，又名「花书」，被誉为深度学习领域圣经。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TensorFlow、pytorch官网是最好的参考资料。如果英语不好，那么可以看看下面的资料：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Pytorch学习笔记：https://blog.csdn.net/wuzhongqiang/category_10024538.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《30天吃掉那只TensorFlow2》：https://github.com/lyhue1991/eat_tensorflow2_in_30_days&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《20天吃掉那只Pytorch》：https://github.com/lyhue1991/eat_pytorch_in_20_days&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PyTorch深度学习快速入门教程：https://www.bilibili.com/video/BV1hE411t7RN&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据挖掘与分析&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟练使用相关工具包：numpy、pandas、matplotlib（seabron是matplotlib的简化版）、Scikit-Learn。完成数据的可视化、分析以及特征工程。工具包的学习建议边用边学，可以先看一些中文教程整体了解一下工具包的使用。在具体使用的时候，如果忘记了可以去对应工具包的官网查看详细的文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了熟悉数据分析工具以外，其实更需要的是数据分析的方法，我觉得最好的学习方式就是看开源竞赛的方案，因为在开源方案中，作者会写很多他们分析问题的思路，以及对可视化结果给出的他们认为的正确观点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;英文教程首推官网，中文教程推荐Datawhale的开源项目&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;numpy中文教程：https://github.com/datawhalechina/powerful-numpy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pandas中文教程（这份文档可能比官方文档还适合学习）：https://github.com/datawhalechina/joyful-pandas&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;matplotlib中文教程：https://github.com/datawhalechina/fantastic-matplotlib&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;《Hands-on-Machine-Learning-with-Scikit-Learn》用sklearn工具实现各种机器学习模型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大数据&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际工业场景中，我们面临的都是海量数据，也就是所谓的大数据。再用上面提到的MySQL数据库、numpy、pandas等工具是不行的。这个时候就需要专业的大数据处理工具：Hadoop、Spark生态。有的同学想从这些生态的基本原理学起， 如果有时间，知其所以然是好的，但往往我们需要兼顾算法和大数据，时间并不是很充足，所以建议大数据这块可以先掌握到会用的层次，当做工具即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的：首先是Hive查询，也就是用HQL进行一些表数据的基础查询，这个和SQL有些类似，另外一个，就是sparkSQL以及spark的DataFrame， 这些相关操作常用来做数据分析和处理，处理完毕之后，写回到Hive表里面。其次，遇到复杂的处理逻辑，就需要写原生spark脚本去跑数据了。关于这块知识，后面也会整理一篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块实操性特别强，所以建议先看视频，跟着视频一步步来：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;尚硅谷大数据Hadoop 3.x：https://www.bilibili.com/video/BV1Qp4y1n7EN&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尚硅谷大数据Spark教程从入门到精通：https://www.bilibili.com/video/BV11A411L7CK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推荐系统算法基础+综合项目实战：https://www.bilibili.com/video/BV1qK4y1479r&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐算法理论知识&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终于到了核心部分。再次强调一下，上面的知识不要求全掌握，既不需要，也不现实。如果为了快速入门，掌握机器学习、深度学习基础后就可以直接进入这一节了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际的工业推荐系统中，一般会有四个环节：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000173&quot; data-ratio=&quot;0.53125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SFQibCRMrWdac6xDrAC922L4OI9NoYndjMebmV3erKlSUmcmKzF8LUrr3yb5dxxUOECtAcLibjGfSEjrUnO9lFyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我梳理了这四个环节中用到的主流技术，整理成了如下导图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000175&quot; data-ratio=&quot;0.8619313647246608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SFQibCRMrWdac6xDrAC922L4OI9NoYndjAuKomJQOlvJo8fh3dKJocyRosnE13h6xODNWH6zcNEYV5fD6DxpyBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1253&quot;/&gt;&lt;figcaption&gt;热追推荐算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图就是整个推荐算法的核心内容。这里先放出这个导图，一是让大家对推荐算法有个整体框架，二是告诉大家后续文章的内容：打算通过解读论文的形式，结合自身在工作中接触的工业场景，把里面的模型和知识点一一为大家解读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个系列我取名：&quot;热追&quot;推荐算法。主要包括以下四个部分：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;召回粗排&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;召回的目的是根据用户部分特征，从海量物品库快速找到小部分用户感兴趣的物品交给精排，重点是强调快。主要有两大类召回方式，一类是策略规则，一类是监督模型+embedding。其中策略规则，往往和业务场景是强相关，不同的场景会有不同的召回方式，对于这种&quot;特异性&quot;较强的知识，会放到后期讲。目前打算先讲解普适的方法，就是模型+embedding。上图梳理出了目前给用户和物品打embedding的主流方法， 比如FM系列（FM,FFM等）， 用户行为序列，基于图和知识图谱系列，经典双塔系列等。这些方法看似很多很复杂，其实本质上还是给用户和物品打embedding而已，只不过考虑的角度方式不同。这一块的内容，几乎每个模型都对应着经典paper，所以会采用解读论文的方式给大家分享。在解读的过程中，对于一些重要模型，会进行代码复现，并应用到一些真实的实践任务中。至于粗排，有时候召回环节返回的物品数量还是太多，怕精排速度跟不上，所以可以在召回和精排之间加一个粗排环节，通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序，在保证一定精准的前提下，进一步减少往后传送的物品数量，粗排往往是可选的。因此粗排用到的很多技术与召回重合，所以先暂且归并到召回里，等后面把整体的基础知识都补充完毕了，再看情况要不要展开这块。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;精排&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;精排阶段使用你能想到的任何特征，可以上你能承受速度极限的复杂模型，尽可能精准地对物品进行个性化排序，强调准确性。这一块关键技术主要分为三大块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CTR预估：LR、FM家族、自动特征交叉的DNN家族。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多任务学习（Multi-Task Learning，也称为多目标学习）。多任务是很常见的，比如视频推荐中，用户喜欢、收藏、评论。而不同的任务可能会互相冲突，互相影响，造成模型学习起来十分困难。所以这一块是重难点，也是很多大公司的研究重点，更是未来的一大发展趋势。但好在这里每个模型或者技术有对应paper，所以和召回一样，这里依然可以利用解读paper的方式，把这些模型和技术娓娓道来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排序打分公式融合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;重排&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到上面的两块是核心，这块没有详细的展开整理，并且这块和业务场景策略强相关，很依赖工作经验，目前了解的也不是很多。后续先解读几篇重排模型的经典论文，等学习了相关技术，再来不断完善这块。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;冷启动&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冷启动问题是指对于新用户和新商品，他们没有历史交互数据，无法分析历史喜好，这个时候我们应该如何做推荐。冷启动技术会穿插到召回或者重排中，有时也会和上面推荐系统做成并行的两路，专门应对冷启动场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;参考资料：&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先当然是后续自己写的文章啦哈哈哈。主要是因为搞算法的人学习模型都是参考论文，这也是为什么我后面分享这一块内容都是以解读论文的形式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一定要推荐一本书籍的话，我选王喆的《深度学习推荐系统》。这本书高屋建瓴的介绍了推荐系统整体架构，发展历史以及未来趋势，还有各种推荐模型的演化之路，很适合前期用来当做科普。但是具体的模型并没有深入讲解，还是得自己去看论文解读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再就是一些我认为很优秀的开源项目：&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强子整理的 https://github.com/zhongqiangwu960812/AI-RecommenderSystem&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我的另一个好友潜心整理，star已过千 https://github.com/ZiyaoGeng/Recommender-System-with-TF2.0&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐系统实战项目&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论一定要与实践结合，否则就是空中楼阁。为此我们打造了一个新闻推荐项目：基于我们之前的开源项目（fun-rec：https://github.com/datawhalechina/fun-rec）做了一个完整升级。实现了从前端、后端、数据库、推荐模型等整个流程。项目规划图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100000176&quot; data-ratio=&quot;0.8059701492537313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SFQibCRMrWdac6xDrAC922L4OI9NoYndjE1niazQx6IzYib6p3dGzv9kZhrLm5Fo4x1biamibHRNcVjqeia6Cqz4UEvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1340&quot;/&gt;&lt;figcaption&gt;新闻推荐系统&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阶段一&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;物料池的构建：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Mysql基础及python调用（简介、安装、简单的命令行基础、python如何调用mysql数据（增删改查，排序））&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MongoDB基础及python调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis基础及python调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Scrapy基础及新闻爬取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新闻画像构建（存入MongoDB）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端展示：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Vue简介及基本使用（对于我们做推荐算法的，了解一些前后端交互之类的就够了）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前后端如何交互&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户注册界面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新闻展示（内容、时间、点赞次数，收藏次数）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以保留用户的行为（user_id, news_id, action(点赞、收藏、阅读)，time）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阶段二&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了前端及物料池后，就需要设计简单的冷启动规则来收集用户的行为数据以及用户的基本属性特征。这一部分数据可能需要参加开源学习的同学来一起帮忙完善这个数据集，这样数据才是有意义的。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;收集数据&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在服务器上部署数据收集的系统（新闻数据+用户行为数据）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;冷启动策略&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;冷启动&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户侧&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物品侧&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统侧&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阶段三&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段就是推荐算法大展身手的地方啦。我们可以把上一节学到的推荐算法，在这里尽情尝试，吹拉弹唱任你挑选。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;离线评估指标&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多路召回&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;特征工程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;规则类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模型类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;召回评估&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排序&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DeepFM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排序评估&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;规则+重排&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;阶段四&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是一些运营类知识，保证系统的高可用性&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;推荐服务，前后端交互（flask）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务调度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统部署&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;规范类修改&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结束语&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文作为推荐系统的开篇，不仅讲解了入门推荐系统所需前置知识、基础、进阶、实战等全部知识点，还为后续推荐算法理论知识与实战项目定下计划。希望大家多多关注交流，我会按时更新后续系列文章。&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100112071&quot; data-ratio=&quot;0.40555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vI9nYe94fsGxu3P5YibTO899okS0X9WaLmQCtia4U8Eu1xWCz9t8Qtq9PH6T1bTcxibiaCIkGzAxpeRkRFYqibVmwSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整理不易，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;赞&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;三连&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;↓&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf1d49263ff02de45441e452bd96df81</guid>
<title>答应我，别再用 print 调试代码了，好么？</title>
<link>https://toutiao.io/k/78q70gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;相信很多程序员在调试代码时，都用过 print。代码少还好说，如果是大型项目，面对众多 print 的输出结果，可能要头大了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-939f47d35ae026794855c7cc9faaa52c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;643&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-939f47d35ae026794855c7cc9faaa52c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;643&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-939f47d35ae026794855c7cc9faaa52c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-939f47d35ae026794855c7cc9faaa52c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;今天推荐一个 GitHub 热门开源项目：&lt;b&gt;PySnooper&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;2019 年 4 月 23 日，该项目推出的第一天就收获 2000+ Star，登上了 GitHub 日榜第一位，如今有近 15k Star。Python 开发者应该会喜欢的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-55452cfad8357d16084ec29c9f94cb59_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;912&quot; data-rawheight=&quot;278&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-55452cfad8357d16084ec29c9f94cb59_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;912&quot; data-rawheight=&quot;278&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-55452cfad8357d16084ec29c9f94cb59_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-55452cfad8357d16084ec29c9f94cb59_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/cool-RR/PySnooper&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/cool-RR/PySn&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ooper&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;PySnooper 是个什么东西？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;如果你写的 Python 代码不能按如期那样运行，你会绞尽脑汁想为啥出错了。虽然你希望有支持断点的成熟调试器，但或许你现在不想去设置这样的调试器。&lt;/p&gt;&lt;p&gt;你想知道哪些行代码是正常运行，哪些行不正常。据说大多数人会在可疑位置使用 print 输出语句。&lt;/p&gt;&lt;p&gt;其实 PySnooper 的作用有点类似，你不用小心翼翼地用 print 输出，只需在想调试的函数中引入一个装饰器。然后得到函数的详细日志，包括运行了哪些行、何时运行，以及何时更改了局部变量。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;为什么 PySnooper 能从其他智能调试工具中脱颖而出？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;因为你可以在不需要进行任何设置的情况下将其用于糟糕的、庞大的企业代码库中。只需打开装饰器（如下示例所示），并将输出重定向到一个专用的日志文件，将日志文件路径指定为第一个参数。&lt;/p&gt;&lt;blockquote&gt; PS：如果无法访问 stderr，那可以将输出重定向到指定文件，比如 ：&lt;code&gt;@pysnooper.snoop(&#x27;/my/log/file.log&#x27;)&lt;/code&gt;&lt;br/&gt; &lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;使用范例&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;范例是一个把数字转成二进制的函数。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import pysnooper

@pysnooper.snoop()
def number_to_bits(number):
    if number:
        bits = []
        while number:
            number, remainder = divmod(number, 2)
            bits.insert(0, remainder)
        return bits
    else:
        return [0]

number_to_bits(6)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;输出结果&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Starting var:.. number = 6
21:14:32.099769 call         3 @pysnooper.snoop()
21:14:32.099769 line         5     if number:
21:14:32.099769 line         6         bits = []
New var:....... bits = []
21:14:32.099769 line         7         while number:
21:14:32.099769 line         8             number, remainder = divmod(number, 2)
New var:....... remainder = 0
Modified var:.. number = 3
21:14:32.099769 line         9             bits.insert(0, remainder)
Modified var:.. bits = [0]
21:14:32.099769 line         7         while number:
21:14:32.099769 line         8             number, remainder = divmod(number, 2)
Modified var:.. number = 1
Modified var:.. remainder = 1
21:14:32.099769 line         9             bits.insert(0, remainder)
Modified var:.. bits = [1, 0]
21:14:32.099769 line         7         while number:
21:14:32.099769 line         8             number, remainder = divmod(number, 2)
Modified var:.. number = 0
21:14:32.099769 line         9             bits.insert(0, remainder)
Modified var:.. bits = [1, 1, 0]
21:14:32.099769 line         7         while number:
21:14:32.099769 line        10         return bits
21:14:32.099769 return      10         return bits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你不想追踪整个函数，那可以用 &lt;code&gt;with&lt;/code&gt; 块包装你想追踪的那部分，如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import pysnooper
import random

def foo():
    lst = []
    for i in range(10):
        lst.append(random.randrange(1, 1000))

    with pysnooper.snoop():
        lower = min(lst)
        upper = max(lst)
        mid = (lower + upper) / 2
        print(lower, mid, upper)

foo()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;输出结果&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;New var:....... i = 9
New var:....... lst = [681, 267, 74, 832, 284, 678, ...]
09:37:35.881721 line        10         lower = min(lst)
New var:....... lower = 74
09:37:35.882137 line        11         upper = max(lst)
New var:....... upper = 832
09:37:35.882304 line        12         mid = (lower + upper) / 2
74 453.0 832
New var:....... mid = 453.0
09:37:35.882486 line        13         print(lower, mid, upper)
Elapsed time: 00:00:00.000344
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;如何安装？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;最佳方式：pip&lt;/p&gt;&lt;p&gt;其他方式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Conda：&lt;code&gt;$ conda install -c conda-forge pysnooper&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Arch Linux：&lt;code&gt;$ yay -S python-pysnooper&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Fedora Linux：&lt;code&gt;dnf install python3-pysnooper&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>65d28ea6b96212c2788799bf8b12bc2b</guid>
<title>如何设计出完美的动画技术架构？</title>
<link>https://toutiao.io/k/ikanpmp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动画在前端领域中的作用是提升用户体验、吸引用户注意力。&lt;/span&gt;&lt;span&gt;在互联网行业中，它也是一个永久的热点话题。&lt;/span&gt;&lt;span&gt;一般在电商平台或者娱乐类项目（快手、拼多多、淘宝、腾讯视频、抖音等）中会出现很多的动画场景。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么通过本文，大家可以提高哪些方面的认知呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前端人员实现动画的技术有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每种动画的实现技术有什么特点，适合什么样的场景？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拿到需求稿或者动画demo的时候，如何选择最合适的技术栈？（选择合适的技术栈在任何时候都是对程序员非常重要的一个考验）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;制作一系列的动画，各岗位的人该如何配合，每个人分别做什么&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快手今年在业内比较成功的项目——春节系列项目&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005152&quot; data-ratio=&quot;0.559375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjAc02h6FzwmFvpc2OfmhkguUGqoRXLVx6W24ckMZvJTd4NXxy9uVmEw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;640&quot;/&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100005176&quot; data-ratio=&quot;0.482&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRj784whC70M60SBtFHWMRiaMRGWabupeF1lNSjwHXib6bGpwBxx0YjnFBQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100005177&quot; data-ratio=&quot;0.4828767123287671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjacorTpGqJT41hTC1F3YzlUyiciaklBaEq1ypo3bIuXdhEgh4ZIbX8CYw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;584&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个系列的项目动画元素非常多，但是每个地方都需要根据动画的特点去选择最合适的技术去实现才能达到性能以及展示的最高标准，才能演绎出最高级的动画。那么研发人员和设计人员在接到需求的时候就要去合作沟通去设计出最完美的动画技术架构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前期考虑&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;兼容性、稳定性、体积、性能、用户设备（低端机测试）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;技术栈&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;APNG、css Animation、SVG、Lottie、Canvas、WebGL、cocos、webp、TransparentVideo ... ...&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;APNG&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005150&quot; data-ratio=&quot;0.48&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjeQcTVicBN9zGmeCic422eULkM7wick7wKt3lXXc9L9h1FSG9DI7Eib5sZQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005151&quot; data-ratio=&quot;0.48&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRj0dwWw5ZapmlJXkn8NfzPcP75Fj6l9vNIia9hd5MiaRiafJ0kA7hQ4uC3A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005155&quot; data-ratio=&quot;2.0093457943925235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjqWYksiaR16YEaPib6ePCxbt63ZLRTcwkGlibEWU2Qk0PM3wT675wvna4A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;428&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;apng动画传送门&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍：全称Animated PNG，诞生于2004年。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特征：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持透明动画的png（本质也是位图），是png的一个拓展。所以在不支持apng的设备上时，能降级显示一个png静图。虽然gif和apng都是动图，但是apng的画质比gif好很多，需要由设计师来产出（下图为 gif图 和 apng图 对比）。前端这边的使用方法和用其他格式的图片一样，可以直接作为图片插入到网页中去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005157&quot; data-ratio=&quot;0.590625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjzq1Cvdw2gEeqIwBAe1da4m9l2bkldZNkplkwy1qTp7VT72klM5HPxw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）24位真彩色（gif是8位色，这里的位可以理解为2的多少次方，8位色就是2的8次方，即256种颜色，也就是说gif最多可以展示256种颜色，所以gif的色阶过渡会比apng差很多），&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）8位alpha透明通道（gif格式不支持alpha通道，即不支持半透明，但是我们都知道位图中图形边缘的那部分像素是半透明的，如下图，所以gif因为不支持半透明，图的边缘会有锯齿）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005153&quot; data-ratio=&quot;0.720626631853786&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjRq6OF5s192uljvmBRBssqbWPXphQ9HPu4N0Kv0FNm5PQ7DOFV9LyTg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;766&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个图像的每个像素都有 RGB（红色、绿色、蓝色） 三个通道，后来又出现了一个通道alpha通道。一个使用32个比特存储的位图，每8个比特表示红(8)、绿(8)、蓝(8)、alpha(8) 通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下，alpha通道就可以表示256（2的8次方）级的半透明度，就可以把透明度控制得比较顺滑，而gif没有alpha通道，所以它只能展示为透明或者不透明，就没有控制半透明度的余地。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005154&quot; data-ratio=&quot;0.8545953360768176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjic0f3Sz0BNlJ2sH3DHGbHicIzVlwK8BlZ9pbpU8sg5qwe6fs4RZ4LdkQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;729&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：兼容性暂时不是很好，但是现在有一些工具会支持制作 Animated PNG 图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;css Animation&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端人员应该都会比较熟悉CSS Animation。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家深入地去了解CSS，你会发现：万物皆可CSS。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005156&quot; data-ratio=&quot;0.5516666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjd008asiaCib4T5FdbXH068AE6RG7ldtUsv2fU2z2zPrhSW73Y89SRAfw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：浏览器对CSS3动画做了很多优化，比如专门新建一个图层用来跑动画、强制硬件加速。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：可以从头到尾完成动画，但是比较难以在动画过程中按照我们的意愿去做交互控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以一起试做这个小demo感受下CSS Animation的编写特点，肚皮抖动的效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005160&quot; data-ratio=&quot;1.2126436781609196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRj3ItUtF01wibc9WKT9O8awvMKVx4iaYEcyDmVPbGIoyGuFOQdYPEfYgPw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;348&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;div class=&lt;span&gt;&quot;belly&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;                                     /* 第一步：画个肚皮 */  &lt;br/&gt;&lt;br/&gt;.belly {                              /* 第二步：给DOM元素选择器里设置属性animation */&lt;br/&gt;    width: 80px;&lt;br/&gt;    height: 90px;&lt;br/&gt;    position: absolute;&lt;br/&gt;    background: &lt;span&gt;#eeeeee;&lt;/span&gt;&lt;br/&gt;    border-radius: 10% 20% 40% 40%;&lt;br/&gt;    animation: wave2 0.08s infinite alternate;}                                    &lt;br/&gt;&lt;br/&gt;@keyframes wave2 {                       /* 第三步：写@keyframes + 动画名 描述动画 */&lt;br/&gt;  from {&lt;br/&gt;    top: 76px;&lt;br/&gt;    left: 8px;&lt;br/&gt;    border-radius: 10% 20% 40% 60%;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  to {&lt;br/&gt;    top: 74px;&lt;br/&gt;    left: 12px;&lt;br/&gt;    border-radius: 10% 20% 30% 30%;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前比较成熟的css动画库：&lt;span&gt;Animate.css&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;灵感爆棚的CSS动画博主：&lt;span&gt;chokcoco&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适合调试css动画的在线编辑工具：&lt;span&gt;CodePen&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SVG动画&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005162&quot; data-ratio=&quot;2.1555555555555554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjYgMVfTfhic7PP8ViblNYjBaj6IzM1NkOhBtzwbnKoVUIUUK5QZyhulkQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;180&quot;/&gt;                                               &lt;img data-fileid=&quot;100005161&quot; data-ratio=&quot;2.172222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjgbMXTVicTkhBAVsfhK1E6RvuBQyR5EL03MKOxqe7ia5G0Mp6RmLG75TA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;180&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图所示的动画需要用多种技术栈去实现，还需要用JavaScript去控制发光块旋转的生命周期（旋转前期、旋转倒计时阶段、旋转到最后一格等）以及在固定的卡点及时做数据的清除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部分代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;svg&amp;gt;&lt;br/&gt;    &amp;lt;clipPath id=&lt;span&gt;&quot;svgTextPath&quot;&lt;/span&gt;&amp;gt;            /* 这里可以定义不规则形状的动画容器（带阴影的魔盒外形）*/&lt;br/&gt;        &amp;lt;path class=&lt;span&gt;&quot;box&quot;&lt;/span&gt; d=&lt;span&gt;&quot;...&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;    &amp;lt;/clipPath&amp;gt;&lt;br/&gt;&amp;lt;/svg&amp;gt;&lt;br/&gt;&lt;br/&gt;.out-motion {&lt;br/&gt;    clip-path: url(&lt;span&gt;#svgTextPath);        /* 在有动画的元素上 做个剪切蒙版，镂空的部分就是刚刚的svg图形 *、&lt;/span&gt;&lt;br/&gt;    ... ...&lt;br/&gt;&lt;br/&gt;    .inner-light {&lt;br/&gt;        will-change: transform;&lt;br/&gt;        animation: sun 4s linear infinite;&lt;br/&gt;        ... ...&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：svg描述的形状可以完全自定义，也就是说我们可以任意地凹这个动画容器的造型，就像烧纸陶瓷那样（亏我想得出来）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005158&quot; data-ratio=&quot;0.916243654822335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjP0MlS0H8xIAS1AwPww9hb19exQoWG0CVLD6nAv1u0biapqW4UJuen7A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;394&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以先描述形状，再在里面添加animate元素来制作动画：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;rect x=&lt;span&gt;&quot;10&quot;&lt;/span&gt; y=&lt;span&gt;&quot;10&quot;&lt;/span&gt; width=&lt;span&gt;&quot;200&quot;&lt;/span&gt; height=&lt;span&gt;&quot;20&quot;&lt;/span&gt; stroke=&lt;span&gt;&quot;black&quot;&lt;/span&gt; fill=&lt;span&gt;&quot;none&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;animate&lt;br/&gt;    attributeName=&lt;span&gt;&quot;width&quot;&lt;/span&gt;&lt;br/&gt;    attributeType=&lt;span&gt;&quot;XML&quot;&lt;/span&gt;&lt;br/&gt;    from=&lt;span&gt;&quot;200&quot;&lt;/span&gt; to=&lt;span&gt;&quot;20&quot;&lt;/span&gt;&lt;br/&gt;    begin=&lt;span&gt;&quot;0s&quot;&lt;/span&gt; dur=&lt;span&gt;&quot;5s&quot;&lt;/span&gt;&lt;br/&gt;    fill=&lt;span&gt;&quot;freeze&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&amp;lt;/rect&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特征：&lt;br/&gt;(1) 矢量图，可伸缩，在不同的平台或者媒体下表现良好，无锯齿无模糊。&lt;br/&gt;(2) 其DOM结构可以被其特定语法或者Javascript控制,从而轻松的实现动画。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;位图和矢量图&lt;img data-fileid=&quot;100005159&quot; data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjBD7C9scj78JAPgr7ErlJKQ8hPArLBAOEdWBso474JTS1JU3Eh2ic19w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1728&quot;/&gt;&lt;br/&gt;位图：如左图，由一个格子一个格子组成，每个格子里只有一种颜色，很多个单色的格子拼接成的一个图片（这里的一个格子就是一个像素）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;矢量图：如右图，由二维坐标通过连线形成的图片，所以无论它图片的面积多大，它都没有锯齿，因为它相当于是通过数学公式算出坐标然后连接起来的图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Lottie&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100005178&quot; data-ratio=&quot;0.526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjqRjnqIzBStswZ2TSFNrg4eMSOB3IEnMHyS5EfOdC7xu7kDLS0ic8Vng/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Lottie官网&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用方式：设计师在AE上完成动画后，通过AE的插件BodyMovin导出一个json文件给到前端，前端再拿这个json文件去做渲染（具体的使用细节可以看下Lottie的官网）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005163&quot; data-ratio=&quot;0.7558441558441559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjia3zVpzUib2LLuE89etOKOfFYCojGBoR7QjVuep4HntSNKvC9lWLKRuA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;770&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：动效柔和、过渡自然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：插件BodyMovin待完善，有部分 AE 效果无法导出。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Echarts动画&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道Echarts是图标库，但是它其实可以做动画。我们在文章的开头说，动画的技术选型要结合具体场景和需求，这确实需要我们脑袋里要有个储存库。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100005179&quot; data-ratio=&quot;0.905&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjbZTeRBuSlUf4TR2rAGRyETa3hNa4FffKGIwsOqffOgibvDNPPxB8hMg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们要做一个风控用户的展示页面，每个用户都有一个风险值，需要在动画中展示这个风险用户的风险程度（即处理此风险用户的急迫程度），我们就可以使用echart中的liquid水球图（即数字越大，水流越湍急）。图表不仅可以做数据的可视化，也可以展示情绪的可视化，因为最终看这个页面的人还是想要快速地感知两个东西：一个是情绪，另一个是已经量化好的东西。这样展示可以最大化地产生共情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;liquild水球图代码示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const liquidChart= echarts.init(document.getElementById(&lt;span&gt;&quot;liquidChart&quot;&lt;/span&gt;));&lt;br/&gt;const liquidOpt = {&lt;br/&gt;    series: [{&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;liquidFill&#x27;&lt;/span&gt;,&lt;br/&gt;        radius: &lt;span&gt;&#x27;95%&#x27;&lt;/span&gt;,&lt;br/&gt;        label: {&lt;br/&gt;            show: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        shape: &lt;span&gt;&#x27;path://M367.855,428.202c-3.674-1.385-7.452-1.966-11.146-1.794c0.659-2.922,0.844-5.85,0.58-8.719 c-0.937-10.407-7.663-19.864-18.063-23.834c-10.697-4.043-22.298-1.168-29.902,6.403c3.015,0.026,6.074,0.594,9.035,1.728 c13.626,5.151,20.465,20.379,15.32,34.004c-1.905,5.02-5.177,9.115-9.22,12.05c-6.951,4.992-16.19,6.536-24.777,3.271 c-13.625-5.137-20.471-20.371-15.32-34.004c0.673-1.768,1.523-3.423,2.526-4.992h-0.014c0,0,0,0,0,0.014 c4.386-6.853,8.145-14.279,11.146-22.187c23.294-61.505-7.689-130.278-69.215-153.579c-61.532-23.293-130.279,7.69-153.579,69.202 c-6.371,16.785-8.679,34.097-7.426,50.901c0.026,0.554,0.079,1.121,0.132,1.688c4.973,57.107,41.767,109.148,98.945,130.793 c58.162,22.008,121.303,6.529,162.839-34.465c7.103-6.893,17.826-9.444,27.679-5.719c11.858,4.491,18.565,16.6,16.719,28.643 c4.438-3.126,8.033-7.564,10.117-13.045C389.751,449.992,382.411,433.709,367.855,428.202z&#x27;&lt;/span&gt;,&lt;br/&gt;        /* 这里可以用svg设置自定义的形状（水流容器的形状）,也有一些预设选项如矩形rect、钻石菱形diamond */&lt;br/&gt;        amplitude: 0,   /* 波的振幅 */&lt;br/&gt;        waveAnimation: &lt;span&gt;false&lt;/span&gt;,    /* 水波动画 */&lt;br/&gt;        outline: {&lt;br/&gt;            show: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        backgroundStyle: {&lt;br/&gt;            borderColor: &lt;span&gt;&#x27;#156ACF&#x27;&lt;/span&gt;,&lt;br/&gt;            borderWidth: 1,&lt;br/&gt;            shadowColor: &lt;span&gt;&#x27;rgba(0, 0, 0, 0.4)&#x27;&lt;/span&gt;,&lt;br/&gt;            shadowBlur: 20&lt;br/&gt;        },&lt;br/&gt;        data: [0.6, {&lt;br/&gt;            value: 0.5,&lt;br/&gt;            direction: &lt;span&gt;&#x27;left&#x27;&lt;/span&gt;,&lt;br/&gt;            itemStyle: {&lt;br/&gt;                normal: {&lt;br/&gt;                    color: &lt;span&gt;&#x27;red&#x27;&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }, 0.4, 0.3]&lt;br/&gt;        /* 这个数组里有几个元素，就有几层水波，每层水波可以设置自己的属性 */&lt;br/&gt;    }]&lt;br/&gt;};&lt;br/&gt;liquidChart.setOption(liquidOpt);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Canvas&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：擅长做像素处理，动态渲染和大数据量绘制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：画布较大时候性能较低，依赖于像素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特点：注重&lt;strong&gt;描绘动画&lt;/strong&gt;的感觉，像在白色的画布上用笔&lt;strong&gt;自由地画出&lt;/strong&gt;东西的感觉。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100005180&quot; data-ratio=&quot;0.6580645161290323&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjEfic6U5rDTM4zrUZeaNGCe57QSygnhyBqv6dawGQjN0KBZkKDH7RgicA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用场景：刮刮乐、汽车表盘、绘制图表（百度Echarts就是基于html Canvas的图标库）、小游戏。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;webGL&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005164&quot; data-ratio=&quot;0.5453125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjnbemw9mtcU3gQqIV6giaHrUWJne1qWdxv9aDDO2ZRBibUFJTu7wrwf7A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;640&quot;/&gt;&lt;br/&gt;基于html5 webGL的3d科幻风机&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100005169&quot; data-ratio=&quot;0.4734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/SMw0rcHsoNIcMvuAm6MLtNINzgj0ibvRjILzibYQE9IulXHrzR6QulBVOJVJhK09h8HKz2IicU04aUmcCU8J4Y2SQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;br/&gt;&lt;strong&gt;1.&lt;/strong&gt; 擅长做数据可视化；&lt;br/&gt;&lt;strong&gt;2.&lt;/strong&gt; 利用底层的图形硬件加速功能进行的图形渲染，所以它可以流畅地展示3D场景和模型；&lt;br/&gt;&lt;strong&gt;3.&lt;/strong&gt; 和它比较相似的Flash是需要浏览器下载插件的，但是webGL不需要下载插件就可以直接看；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：入门比较困难，它的语言风格比较像C++，前端人员可能有一定的学习成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍：三维动图渲染技术，本质是JavaScript API。如果用最通（庸）俗（俗）的话来讲就是：创建一个着色器，然后把数据data传到GPU，然后GPU在根据两边传来的内容输出成动画。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1. 初始化&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2. 编译着色器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shader = gl.createShader(gl.VERTEX_SHADER);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shader = gl.createShader(gl.FRAGMENT_SHADER);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3. 将输入的数据传到GPU&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const buffer = gl.createBuffer();&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;gl.bindBuffer(gl.ARRAY_BUFFER, buffer);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;gl.bufferData(gl.ARRAY_BUFFER, positionsData, gl.STATIC_DRAW);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4. 绘制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;gl.clear(gl.COLOR_BUFFER_BIT);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;gl.drawArrays(gl.TRIANGLES, 0, 3);&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然现在前端涉及的知识面很广，实现动画的技术不仅仅局限于以上这几种，而且未来也会有更多新技术的出现。但是每当一个新的技术出来的时候，我们还是要保持独立思考的能力以及自己的批判思维，切记不能盲目跟风。大部分情况下，作为一名前端，技术栈的选择还是要从性能和用户的角度出发。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;引用：&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1. &lt;span&gt;快手春节活动设计背后的故事&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;https://gw.alicdn.com/imgextra/i1/O1CN01304wnF1oY8SgVUetS_!!6000000005236-54-tps-206-285.apng?getAvatar=1: &lt;em&gt;https://link.juejin.cn?target=https%3A%2F%2Fgw.alicdn.com%2Fimgextra%2Fi1%2FO1CN01304wnF1oY8SgVUetS_!!6000000005236-54-tps-206-285.apng%3FgetAvatar%3D1&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;https://animate.style/: &lt;em&gt;https://link.juejin.cn?target=https%3A%2F%2Fanimate.style%2F&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;https://juejin.cn/user/2330620350437678: &lt;em&gt;https://juejin.cn/user/2330620350437678&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;https://codepen.io/: &lt;em&gt;https://link.juejin.cn?target=https%3A%2F%2Fcodepen.io%2F&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;https://lottiefiles.com/: &lt;em&gt;https://link.juejin.cn?target=https%3A%2F%2Flottiefiles.com%2F&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;https://www.zcool.com.cn/article/ZMTI1MzY5Mg==.html: &lt;em&gt;https://link.juejin.cn?target=https%3A%2F%2Fwww.zcool.com.cn%2Farticle%2FZMTI1MzY5Mg%3D%3D.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40adfc84736fc50c8f60ebede0cc7c7e</guid>
<title>Modern.js: Hello, World!</title>
<link>https://toutiao.io/k/99x82s5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;h2 id=&quot;h_426707646_0&quot; data-into-catalog-status=&quot;&quot;&gt;概要&lt;/h2&gt;&lt;blockquote&gt;7月，字节跳动 Web Infra 做过一次主题为&lt;a href=&quot;https://zhuanlan.zhihu.com/p/386607009&quot; class=&quot;internal&quot;&gt;《迈入现代 Web 开发（字节跳动的现代 Web 开发实践）》&lt;/a&gt;的分享，在分享中我们梳理了「传统前端技术栈」的典型组成部分，展示了其中每个部分都存在的瓶颈问题。也介绍了在这些问题的驱动下，业界正在发生从「传统 Web 开发范式」到「现代 Web 开发范式」的「范式转移」。在这个分享的最后预告了 Modern.js 开源项目。&lt;br/&gt;&lt;br/&gt;10 月 27-28 日的&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//conf.juejin.cn/xdc2021&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;稀土开发者大会&lt;/a&gt;上，字节跳动 Web Infra &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/ysO6aaRn2hpEnxWYz5tIMw&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;正式发起 Modern.js 开源项目&lt;/a&gt;。&lt;br/&gt;&lt;br/&gt;本文是宋振伟同学跟我一起准备的专场分享内容，也是第一次介绍 Modern.js。&lt;br/&gt;&lt;br/&gt;第一部分先介绍了业界和字节内部的前端开发、Web 开发在发生哪些影响深远的变革，从这些变革的角度，展示了基于 Modern.js 的现代 Web 开发。  &lt;br/&gt;&lt;br/&gt;这些变革包括： &lt;br/&gt;&lt;b&gt;- 更多「前端开发者」成为「应用开发者 / 产品开发者」&lt;/b&gt; &lt;br/&gt;先讨论了什么根本因素在驱动这种转变，&quot;Frontend Focused&quot; 的意义，指出服务器端开发门槛不断降低的长期趋势、原有基建的缺陷，用 Modern.js 演示了「一体化、无服务器化的全栈开发」、「以客户端为中心的 Web 开发」。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 从「前后端分离」到「前后端一体化」 &lt;/b&gt;&lt;br/&gt;分析了「前后端分离」产生的两种前端项目，为什么其中一种是「假分离」，另一种「不完整」，用 Modern.js 演示了「前后端一体化」在哪些地方带来改变。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- Meta Framework 取代传统「前端三剑客」 &lt;/b&gt;&lt;br/&gt;分析了四代「前端三剑客」，以及每一代都被下一代的成员「吞并」的规律，结合字节内部的真实案例，讲解了 Meta Framework 的角色。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 形成基于「前端技术」的成熟 GUI 软件研发体系 &lt;/b&gt;&lt;br/&gt;先明确了「前端技术」的定义， 结合 Modern.js 的功能和设计，讨论了如何实现「充分抽象」，才能解决 DX 和 UX 的矛盾。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 智能化、平台化、低码化 &lt;/b&gt;&lt;br/&gt;&lt;br/&gt;接下来第二部分系统介绍 Modern.js 的六大要素，包括： &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 普及：现代 Web 开发范式 &lt;/b&gt;&lt;br/&gt;回顾了这种范式的 9 大主要特征。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 核心：现代 Web 应用（MWA） &lt;/b&gt;&lt;br/&gt;从 Universal App、一体化、应用架构、Runtime API 这四个角度来了解 MWA。 &lt;br/&gt;在应用架构部分介绍了 Modern.js 中 Model 的设计和背景。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 内置：前端工程最佳实践 &lt;/b&gt;&lt;br/&gt;列举了几个典型的最佳实践，包括 Post-Webpack Era 的新工具趋势、Modern.js 的 Unbundled 开发，Modern.js 推荐的「CSS 三剑客」，Modern.js 微前端项目跟直接使用 Garfish 的微前端项目对比、模块工程方案和 Monorepo 工程方案中的最佳实践。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 包含：Web 开发全流程 &lt;/b&gt;&lt;br/&gt;演示了 Modern.js 在「编码」环节的微生成器功能、在「调试环节」的微前端调试。 &lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 提供：工程标准体系 &lt;/b&gt;&lt;br/&gt;&lt;br/&gt;&lt;b&gt;- 鼓励：定制工程方案  &lt;/b&gt;&lt;br/&gt;&lt;br/&gt;末尾介绍了除已经发布的开源项目，还有哪些对现代 Web 开发者有帮助的事情在发起和推进中。也介绍了 Modern.js 当前高优的社区计划。&lt;/blockquote&gt;&lt;h2 id=&quot;h_426707646_1&quot; data-into-catalog-status=&quot;&quot;&gt;分享实录&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fe5832dd1fddc0f5771dc771da5f384e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-fe5832dd1fddc0f5771dc771da5f384e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-fe5832dd1fddc0f5771dc771da5f384e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-fe5832dd1fddc0f5771dc771da5f384e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;大家好，我是来自&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/5ght8dZtTaOdhwAaxNetmA&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;字节跳动 Web Infra&lt;/a&gt; 的宋振伟，在字节跳动，我们部门负责打造和发展「Web 技术中台」和「前端研发体系」。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a8beb64ff947b9a89753f0f9fc3506d1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a8beb64ff947b9a89753f0f9fc3506d1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a8beb64ff947b9a89753f0f9fc3506d1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a8beb64ff947b9a89753f0f9fc3506d1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt; 今年7月，我们做过一次主题是&lt;a href=&quot;https://zhuanlan.zhihu.com/p/386607009&quot; class=&quot;internal&quot;&gt;《&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/386607009&quot; class=&quot;internal&quot;&gt;字节跳动的现代 Web 开发实践》&lt;/a&gt;的分享，在分享中我们梳理了「传统前端技术栈」的典型组成部分，展示了其中每个部分都存在的瓶颈问题。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d8c6553369af6218d93f062cb42125e7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d8c6553369af6218d93f062cb42125e7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d8c6553369af6218d93f062cb42125e7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d8c6553369af6218d93f062cb42125e7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;也介绍了在这些问题的驱动下，业界正在发生从「传统 Web 开发范式」到「现代 Web 开发范式」的「范式转移」。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-543a80e12ab418c5c3ee676dbf7c3699_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-543a80e12ab418c5c3ee676dbf7c3699_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-543a80e12ab418c5c3ee676dbf7c3699_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-543a80e12ab418c5c3ee676dbf7c3699_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在这个分享的最后也预告了 Modern.js 开源项目。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7477415d73d44ea2481de9e36cbbdc79_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-7477415d73d44ea2481de9e36cbbdc79_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-7477415d73d44ea2481de9e36cbbdc79_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7477415d73d44ea2481de9e36cbbdc79_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//conf.juejin.cn/xdc2021&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;昨天上午的主题演讲&lt;/a&gt;中，字节跳动正式发布了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//modernjs.dev/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Modern.js&lt;/a&gt;。今天的专场分享，我想结合字节内部的变革和实践，介绍基于 Modern.js 的现代 Web 开发，和所带来的实际效果。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_2&quot; data-into-catalog-status=&quot;&quot;&gt;议程&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-29b0597efce85a3994aecada6e0e9cf7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-29b0597efce85a3994aecada6e0e9cf7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-29b0597efce85a3994aecada6e0e9cf7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-29b0597efce85a3994aecada6e0e9cf7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;今天的分享可以分成三个部分。 &lt;/p&gt;&lt;p&gt;昨天的主题演讲有说到，整个业界和字节内部的前端开发、Web 开发，都在发生着影响深远的变革，我们首先从这些变革的角度，看下基于 Modern.js 的现代 Web 开发是什么样子，有什么区别。 &lt;/p&gt;&lt;p&gt;然后，我们整体看下 Modern.js 有哪些要素和收益。 &lt;/p&gt;&lt;p&gt;最后再看下除了已经发布的开源项目，还有哪些对现代 Web 开发者有帮助的事情在发起和推进中。 &lt;/p&gt;&lt;p&gt;我们先来看第一部分「现代 Web 开发」 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_3&quot; data-into-catalog-status=&quot;&quot;&gt;一、基于 Modern.js 的现代 Web 开发 &lt;/h2&gt;&lt;h2 id=&quot;h_426707646_4&quot; data-into-catalog-status=&quot;&quot;&gt;1.1 更多「前端开发者」成为「应用开发者 / 产品开发者」 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f6a0ea5dbfe5f35efed55f4fd3fac46c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f6a0ea5dbfe5f35efed55f4fd3fac46c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f6a0ea5dbfe5f35efed55f4fd3fac46c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f6a0ea5dbfe5f35efed55f4fd3fac46c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以从这五个方面的变革，来展示「现代 Web 开发」是什么样子。 &lt;/p&gt;&lt;p&gt;这五个变革之间是承前启后的关系。首先最根本的推动力，不是来自技术侧，不是前端开发者一厢情愿的发展自己主观的技术偏好，而是在互联网和 IT 行业、市场需求、用户产品这一侧的大趋势，需要更多「前端开发者」成为「应用开发者」或「产品开发者」，鼓励和倒逼着技术领域，不断产生更有利于这种需求的技术形态和基础设施。 &lt;/p&gt;&lt;p&gt;当传统技术范式遇到瓶颈，不再能进一步适应需求，就会发生「范式转移」，出现从一开始就针对这种需求重新设计的、新一代的技术范式。 &lt;/p&gt;&lt;p&gt;这种转变推动前端技术领域出现了「从分离到一体化」、新一代「前端三剑客」的变革。 &lt;/p&gt;&lt;p&gt;这种变革带来的新一代技术标准和基础设施，开始形成完全基于「前端技术」的成熟 GUI 软件研发体系，并且进一步朝着平台化、低码化的方向发展。  &lt;/p&gt;&lt;h2 id=&quot;h_426707646_5&quot; data-into-catalog-status=&quot;&quot;&gt;1.1.1 &quot;Frontend Focused&quot; 的意义 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-13ed9146c49268d2589b6b94f700f600_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-13ed9146c49268d2589b6b94f700f600_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-13ed9146c49268d2589b6b94f700f600_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-13ed9146c49268d2589b6b94f700f600_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们刚才一直在说「前端」，「前端」这个概念似乎一直是只有开发者才关心的技术细节，但最近几年，却变成了商业领域、投资机构也都很关心的事情，全球市场上涌现出越来越多的新一代云平台和研发工具产品，多数都涉及前端研发特有的需求和模式，其中还有很多像 Vercel 这样明确「专注于前端」的产品。 &lt;/p&gt;&lt;p&gt;就像幻灯片上这张图，云计算和研发产品最初是从最接近机器的底层开始发展，从虚拟化，到容器编排，到基于容器技术的各种平台化、服务化的研发工具形态，这个阶段是后端技术主导的，整个趋势是越来越向上层发展，越来越接近市场和商业价值最终所在的地方——也就是面向用户的产品，因此必然会发展到前端技术主导的抽象层，让应用开发和产品开发能更专注于用户需求，而越来越不需要关心服务器端的复杂性和专业技术细节。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fa1020c6de6d50f221da177f51c7e84b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-fa1020c6de6d50f221da177f51c7e84b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-fa1020c6de6d50f221da177f51c7e84b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-fa1020c6de6d50f221da177f51c7e84b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;所以市场需求会趋向于推动应用开发方式往「专注于前端」的方向的发展，专注于前端就是专注于用户，而专注于用户是多数企业、产品的根本利益所在 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_6&quot; data-into-catalog-status=&quot;&quot;&gt;1.1.2 最大的开发者群体 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9c0698bf465f8134db43a0991679b823_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-9c0698bf465f8134db43a0991679b823_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-9c0698bf465f8134db43a0991679b823_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9c0698bf465f8134db43a0991679b823_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另一方面，从进入移动互联网时代开始就不断大幅增加的应用开发需求，现在不但没减弱，反而还在加强，比如幻灯片上 IDC 的预测，要满足这么庞大的应用开发需求，传统开发方式和人才储备是很不够的，需要让尽可能多的开发者能独立、完整的开发这些应用，而前端技术栈的开发者，正是最大的开发者群体和技术社区。 &lt;/p&gt;&lt;p&gt;所以在用户、产品、市场这一侧，一直有趋势和压力，需要更多「前端开发者」成为「应用开发者」或「产品开发者」，鼓励和倒逼着技术领域，不断产生更有利于这种需求的技术形态和基础设施。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_7&quot; data-into-catalog-status=&quot;&quot;&gt;1.1.3 服务器端开发门槛不断降低 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6836eecdc3ca8b648358b510349ead16_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-6836eecdc3ca8b648358b510349ead16_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-6836eecdc3ca8b648358b510349ead16_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6836eecdc3ca8b648358b510349ead16_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在这种客观趋势的推动下，基于 Web 技术的应用开发中，服务器端的占比和门槛一直在不断下降，国内大厂的中台建设，提供了大量不跟特定客户端捆绑、专注于数据需求和底层业务逻辑的 API，让产品开发更聚焦在上层的客户端业务逻辑。还有 BaaS 和基于云函数的后端云 Serverless，也进一步降低服务器端的门槛，让前端开发者能更独立的、端到端的完成产品开发。 &lt;/p&gt;&lt;p&gt; 但要进一步降低门槛，提高效率，这些基础设施的一个缺陷就暴露出来，就是他们都把应用依赖的 API，放在应用项目之外维护，跟前端研发是割裂的。 &lt;/p&gt;&lt;p&gt;还有一个缺陷是它们不解决 API 之外的服务器端需求，比如路由、SSR 等。 &lt;/p&gt;&lt;p&gt;有一个字节内部的典型例子，前端开发者在自己实现的 SSR 项目中，始终用 HTTP 方式请求外网域名的 API 来获取数据，导致 SSR 频繁超时，HTML 响应慢严重影响用户体验。可以给前端开发者做培训，让他们具备足够的服务器端开发思维和知识，知道要在 SSR 环节切换成内网的请求方式，还要考虑缓存机制等，但更根本的解决方法是屏蔽这种服务器端问题和实现细节，自动处理这些问题。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_8&quot; data-into-catalog-status=&quot;&quot;&gt;1.1.4 一体化、无服务器化的全栈开发 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-14c3bc42ab0e26fe070e3fec06689f95_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-14c3bc42ab0e26fe070e3fec06689f95_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-14c3bc42ab0e26fe070e3fec06689f95_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-14c3bc42ab0e26fe070e3fec06689f95_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;因此服务器端门槛不断降低的趋势，自然会发展到「一体化、无服务器化的做全栈开发」的阶段，让前端开发者直接开发 「接近纯前端的项目」而不是 「Node.js 框架项目」，感觉就像没有服务器一样。 &lt;/p&gt;&lt;p&gt;幻灯片上是这次分享中第一个 Modern.js 的 demo， 左侧是一个 Modern.js 应用项目的完整目录结构，src/ 目录下的应用主体，可以像调用普通函数文件一样访问 api/ 目录下的 BFF 函数，不需要了解网络细节，Modern.js 会自动基于 BFF 函数的路径、参数等自动生成 REST API，在 CSR 过程中自动请求。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-82379dd4268f2f17b4c6c02ed44af2d0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-82379dd4268f2f17b4c6c02ed44af2d0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-82379dd4268f2f17b4c6c02ed44af2d0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-82379dd4268f2f17b4c6c02ed44af2d0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来我们在 package.json 的 modernConfig 配置里启用 SSR、「差异化分发」和「自动 Polyfill」，可以看到这些功能不用增加代码逻辑，只需要静态开关配置。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3adf5a642a884aa75f3cdf3fb1b6f4c7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3adf5a642a884aa75f3cdf3fb1b6f4c7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3adf5a642a884aa75f3cdf3fb1b6f4c7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3adf5a642a884aa75f3cdf3fb1b6f4c7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;构建后，幻灯片左侧可以看到产物里的 HTML 和 JS 都有 es6 和 es5 两个版本，用户访问时应用的时候，Modern.js 的 Web Server 会根据浏览器 UA 选择分发 es6 版本还是 es5 版本，也就是「差异化分发」。 &lt;/p&gt;&lt;p&gt;右边上面的图是现代浏览器的访问结果，不会返回任何 polyfill 代码， 下面的图是低版本浏览器的访问结果， Web Server 会自动提供这个 UA 需要的 polyfill 代码。 &lt;/p&gt;&lt;p&gt;可以看到 Modern.js 不但支持一体化的开发 BFF，也满足 BFF 之外的服务器端需求，尽可能自动利用自带的 web server 去做性能优化和提供产品级的兼容性，同时开发体验仍然是无服务器化的 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9e14b14bd3396e870b430c6aa7e108fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9e14b14bd3396e870b430c6aa7e108fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9e14b14bd3396e870b430c6aa7e108fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9e14b14bd3396e870b430c6aa7e108fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之前我们启用了 SSR, 左侧图上高亮的 HTML 片段，已经包含了通过 BFF 请求到的数据，会根据应用运行的方式自动选择最高效的请求方式。 &lt;/p&gt;&lt;p&gt;这种自动优化不会阻碍开发者对技术细节的掌控，右边这张图展示了 BFF 函数也会生成标准的 REST API，可以手动调用。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_9&quot; data-into-catalog-status=&quot;&quot;&gt;1.1.5 以客户端为中心的 Web 开发 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b5249012c574f3255382f412a11ecaf6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b5249012c574f3255382f412a11ecaf6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b5249012c574f3255382f412a11ecaf6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b5249012c574f3255382f412a11ecaf6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这种一体化、无服务器化的全栈开发进一步发展，自然会得到一种客户端为中心的 Web 开发方式。 &lt;/p&gt;&lt;p&gt;比如在传统 Web 开发中，要实现常见的权限识别和重定向，除了前端页面的逻辑，还需要在服务器端的路由中，添加实现跳转的业务逻辑。比如图上，在访问 home 页面的时候根据 cookie 的值决定要不要重定向到登陆页面。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2f7695a2a09edc0083d8c27fda990928_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2f7695a2a09edc0083d8c27fda990928_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2f7695a2a09edc0083d8c27fda990928_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2f7695a2a09edc0083d8c27fda990928_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;同样的需求，在以客户端为中心的 Web 开发方式中，可以一体化的在客户端代码里实现，比如前面已经启用 SSR 的 Modern.js 项目，只需要添加 Redirect 组件，就可以实现和刚才完全相同的权限识别和重定向效果，访问页面时会根据 cookie 决定要不要返回 302 状态码。整个实现过程是客户端思维的。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-782305c4bc469b006c8f78f0968dcc25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-782305c4bc469b006c8f78f0968dcc25_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-782305c4bc469b006c8f78f0968dcc25_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-782305c4bc469b006c8f78f0968dcc25_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以客户端为中心，不代表不能掌控服务器端，不能直接写服务器端业务逻辑。 &lt;/p&gt;&lt;p&gt;如果已经习惯 Node.js 框架的开发方式，可以 server 目录的钩子文件里，对框架自带的 Web Server 添加自定义逻辑，比如自由添加中间件，可以在这个局部，用自己熟悉的传统 Web 开发方式实现权限识别和重定向。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_10&quot; data-into-catalog-status=&quot;&quot;&gt;1.2 从「前后端分离」到「前后端一体化」 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f22a142d0e282c80167167948b40598_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-0f22a142d0e282c80167167948b40598_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-0f22a142d0e282c80167167948b40598_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0f22a142d0e282c80167167948b40598_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Web 项目的技术栈也在转变，相当于是先发展出「前后端分离」，然后又用新方式回归了 「前后端一体化」 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_11&quot; data-into-catalog-status=&quot;&quot;&gt;1.2.1 「前后端分离」 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d93853c99c4f58da4542f9b1b19aaeed_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-d93853c99c4f58da4542f9b1b19aaeed_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-d93853c99c4f58da4542f9b1b19aaeed_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d93853c99c4f58da4542f9b1b19aaeed_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以前的 Web 开发就像图上这个 Ruby on Rails 项目，图中粉色的前端代码，「寄居」在图中绿色的后端 Web 框架项目中的，前端和后端会互相干扰互相拖累，做工程建设也比较麻烦。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e67af9bc516ca0a41b0d6d113c51f5ed_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e67af9bc516ca0a41b0d6d113c51f5ed_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e67af9bc516ca0a41b0d6d113c51f5ed_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e67af9bc516ca0a41b0d6d113c51f5ed_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之后 Web 开发普遍转变到「前后端分离」的模式，分离后的前端项目和后端项目，都倾向特定的类型。 &lt;/p&gt;&lt;p&gt;后端项目不倾向包含 Web 的功能，而这时的前端项目可以归纳为两种类型。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c2f5aee71c331732c4c83605f0bd4a89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c2f5aee71c331732c4c83605f0bd4a89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c2f5aee71c331732c4c83605f0bd4a89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c2f5aee71c331732c4c83605f0bd4a89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;MERN 这种项目类型相当于又回到了分离前的状态，整个项目是基于 Node.js 框架的，前端被嵌在里面。这种结果其实反映出「前后端分离」实现的更多是分工上的分离，而不是技术架构上的分离，在技术架构上仍然没有摆脱以服务器端框架为中心的 Web 开发。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-925bd0f77bbdd67a771374c96a33f676_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-925bd0f77bbdd67a771374c96a33f676_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-925bd0f77bbdd67a771374c96a33f676_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-925bd0f77bbdd67a771374c96a33f676_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从 MERN 项目的结构可以看到，它不但是假分离，而且也不算一体化，React 代表的前端部分和 Node.js 框架代表的后端部分，在项目里是泾渭分明的，没有真正融合到一起去。 &lt;/p&gt;&lt;p&gt;使用 Node.js 框架的项目，多数属于这个类型。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-637dcfd06d5643c0ff36dd39f7afd448_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-637dcfd06d5643c0ff36dd39f7afd448_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-637dcfd06d5643c0ff36dd39f7afd448_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-637dcfd06d5643c0ff36dd39f7afd448_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;「前后端分离」模式中另一种前端项目类型，我们称作「老一代 JAMstack」，这种类型没有假分离问题，就是纯粹的前端项目。可以实现 SPA 和 MPA，也能基于编译工具实现 SSG（静态网站生成）。靠静态托管来运行，鼓励在 CSR 中调用 API 满足动态的应用需求。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8daef08c2906c5a0205d479bf87a5836_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-8daef08c2906c5a0205d479bf87a5836_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-8daef08c2906c5a0205d479bf87a5836_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8daef08c2906c5a0205d479bf87a5836_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;「老一代 JAMstack」最大的问题是，虽然分离成了独立的项目，却不足以承担完整的应用开发，只能产出静态文件，依靠外部的 Web 服务器去运行，无法实现 SSR，三大组成部分里的 API，也需要在项目之外，用云函数、独立后端项目等方式来实现，不能跟着项目一起迭代。 &lt;/p&gt;&lt;p&gt;用 CRA 或直接用 webpack 搭建的项目，多数属于这个类型。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_12&quot; data-into-catalog-status=&quot;&quot;&gt;1.2.2「前后端一体化」 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cd01ca0046e8af2f325bae9a83b1e49c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-cd01ca0046e8af2f325bae9a83b1e49c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-cd01ca0046e8af2f325bae9a83b1e49c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cd01ca0046e8af2f325bae9a83b1e49c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在前面说的需要更多「前端开发者」成为「应用开发者」的背景下，新一代的 JAMstack 项目用「客户端为中心」的「前后端一体化」方式，解决了上面说的问题 &lt;/p&gt;&lt;p&gt;新一代 JAMstack 的三大组成部分虽然没变，对应的内容却有很大变化，JS 部分更加函数化和组件化、以 JS 为中心，HTML 可以完全不在项目中出现，自动生成。BFF API 变成项目自包含。和之前简单的静态托管相比，基于前端 Serverless 平台可以实现 SSR、SPR 等动态能力，即使是静态页面，也可以获得很多好处，比如前面展示的 「差异化分发」。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7c98fd76f2faa702d6ece1e2a4264cd1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-7c98fd76f2faa702d6ece1e2a4264cd1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-7c98fd76f2faa702d6ece1e2a4264cd1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7c98fd76f2faa702d6ece1e2a4264cd1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;图上是用 Modern.js 的 demo 来展示新一代 JAMstack 项目。在开发中只需要聚焦在 JS 代码上，不论是 SPA 还是 MPA，HTML 都是自动生成的。不论是 SSR 渲染的代码，还是 API 逻辑，构建之后按照规范输出到 dist 下的不同目录，构建产物规范是 Serverless 友好的，支持把 Web、SSR、BFF 等拆分成不同服务器。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5a369e9d97a1235fc70e533faf439e34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5a369e9d97a1235fc70e533faf439e34_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5a369e9d97a1235fc70e533faf439e34_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5a369e9d97a1235fc70e533faf439e34_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面提到 Modern.js 倾向于 JS 为中心、自动生成 HTML。但不阻碍开发者自己掌控 HTML。图上是 Modern.js 渲染 HTML 的默认模板。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4d826801874c0d8389777b711ebdb385_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4d826801874c0d8389777b711ebdb385_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4d826801874c0d8389777b711ebdb385_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4d826801874c0d8389777b711ebdb385_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;一体化 BFF 的调用，在前面的例子演示过，这里可以看到 BFF 函数的文件路径是有约定的，可以实现任意设计的 REST API。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-004c1531fa36d3cf5216793a40c75059_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-004c1531fa36d3cf5216793a40c75059_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-004c1531fa36d3cf5216793a40c75059_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-004c1531fa36d3cf5216793a40c75059_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;构建产物会针对 BFF、Web、SSR 分别生成独立可运行的 Server，这是对前端 Serverless 平台更友好的，Serverless 平台可以自主选择让 BFF、Web、SSR 用不同方式在独立进程中运行，不会互相干扰。比如在 SSR 环节遇到 app 代码的的内存泄露导致 SSR 超时，Web Server 不受影响，可以自动降级到 CSR 模式，返回静态的 HTML 给用户作为兜底，用户的 HTML 请求始终不会超时或挂掉。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d019c27f453b2294576330b947180a90_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d019c27f453b2294576330b947180a90_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d019c27f453b2294576330b947180a90_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d019c27f453b2294576330b947180a90_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;对于 SSR，同样可以前后端一体化的开发，图里高亮的 useLoader 函数中的代码，同时适用于 SSR 和 CSR，如果这个 Loader 在 SSR 中已经预加载，CSR 就会自动跳过，否则会执行。  &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4ee30aa6eae1b9f5234cc820aaed4faf_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4ee30aa6eae1b9f5234cc820aaed4faf_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4ee30aa6eae1b9f5234cc820aaed4faf_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4ee30aa6eae1b9f5234cc820aaed4faf_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;SPR 相当于有缓存机制的 SSR，在 Modern.js 里也可以一体化的开发，只要使用这个预渲染组件。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65a7fb4d31b03c6951acd0f0de448d4d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a7fb4d31b03c6951acd0f0de448d4d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-65a7fb4d31b03c6951acd0f0de448d4d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-65a7fb4d31b03c6951acd0f0de448d4d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;SSG 实际上就是在编译时运行的 SSR，在 Modern.js 里只要配置 SSG 路由，就会自动启用这种编译逻辑，给路由生成静态 HTML。CSR、SSR、SSG 都是用同一份代码。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_13&quot; data-into-catalog-status=&quot;&quot;&gt;1.3 新一代「前端三剑客」和 Meta Framework &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b9e8d2814ea498cd03efc6a52e9be7c9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b9e8d2814ea498cd03efc6a52e9be7c9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b9e8d2814ea498cd03efc6a52e9be7c9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b9e8d2814ea498cd03efc6a52e9be7c9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;除了在技术栈层面向「前后端一体化」转变，在工程层面，传统的「前端三剑客」也在转变成元框架这种新的工程基建。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_14&quot; data-into-catalog-status=&quot;&quot;&gt;1.3.1  传统「前端三剑客」 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b56d2adebdbf2bdc79a6f61c42cb2f6a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b56d2adebdbf2bdc79a6f61c42cb2f6a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b56d2adebdbf2bdc79a6f61c42cb2f6a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b56d2adebdbf2bdc79a6f61c42cb2f6a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;先来回顾下传统的「前端三剑客」，第 1 代和第 2 代如图上所示，也被大家熟知。而第 3 代「前端三剑客」由视图框架、Node.js 命令行、Node.js 框架三个方向组成。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a7bf4ddbf205079fbcf38dfe5181bafb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-a7bf4ddbf205079fbcf38dfe5181bafb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-a7bf4ddbf205079fbcf38dfe5181bafb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a7bf4ddbf205079fbcf38dfe5181bafb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其中 Node.js 命令行代表了工程化，其中最典型的是像 Webpack 这样的打包工具，以及 Babel、PostCSS 这样的编译工具。 &lt;/p&gt;&lt;p&gt;视图框架和 Node.js 框架很好理解，就是之前讨论的 MERN 项目中的前端和后端部分 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_15&quot; data-into-catalog-status=&quot;&quot;&gt;1.3.2  第 4 代「前端三剑客」 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a346137fffe471c8098a59eefaf93413_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-a346137fffe471c8098a59eefaf93413_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-a346137fffe471c8098a59eefaf93413_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a346137fffe471c8098a59eefaf93413_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;随着现代 Web 开发范式的发展，第4代「前端三剑客」的轮廓已经越来越明显，由元框架、前端 PaaS、低代码三个方向组成。其中低代码方向在昨天晚上稀土大会的低码专场已经介绍过，而 Modern.js 就属于元框架这个方向。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ecf40d691225548f1d97407bf95a2982_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-ecf40d691225548f1d97407bf95a2982_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-ecf40d691225548f1d97407bf95a2982_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ecf40d691225548f1d97407bf95a2982_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从这张图可以清楚的看到，每一代前端三剑客中，都有一个方向，把上一代前端三剑客完整包含在自己里面，变成不需要太关心的底层，让自己取代他们成为前端开发的新地基。 &lt;/p&gt;&lt;p&gt;第 3 代中的视图框架，就扮演这样的角色，把第二代的 HTML、CSS、JS 封装在自己里面，而第 4 代中的元框架，又对视图框架、Node.js 框架、Node.js 命令行做了整合和抽象，成为前端开发和工程建设性起点，元框架扮演了过去 Webpack、React 扮演的角色 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-028ecaa0538066edb993ae2e3d8c0b4d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-028ecaa0538066edb993ae2e3d8c0b4d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-028ecaa0538066edb993ae2e3d8c0b4d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-028ecaa0538066edb993ae2e3d8c0b4d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这张 JS 框架的 S 曲线图，也能体现这种转变。在左边这个时期，发展的前沿、开发的起点，都是 React、Vue、Svelte 这样的视图框架，新的视图框架项目也层出不穷。现在已进入右边这个时期，前沿收敛到基于 React 发展更上层的元框架。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b9eb53173670b8c1e9672501f2c6baf4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b9eb53173670b8c1e9672501f2c6baf4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b9eb53173670b8c1e9672501f2c6baf4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b9eb53173670b8c1e9672501f2c6baf4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 作为现代 Web 工程体系，是由元框架组成的，提供三大工程类型，鼓励开发者基于工程类型建设自己的业务工程方案。 &lt;/p&gt;&lt;p&gt;以字节内部的「火山引擎子应用工程方案」为例，初始化的目录结构没有什么变化，只在配置中默认加载了自己的框架插件，插件中通过 server 提供的 hook 修改渲染后的 HTML ，在原来的 HTML 上套了层壳，也就是右下角截图中火山引擎统一的顶栏和左侧导航栏。 &lt;/p&gt;&lt;p&gt;这样建设出来的工程方案，既能满足垂直场景的需求或自己的偏好，又能保持跟三大工程类型的兼容，自动获得 Modern.js 的能力和收益 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_16&quot; data-into-catalog-status=&quot;&quot;&gt;1.4 基于「前端技术」的成熟 GUI 软件研发体系 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-925105a1e165fd578a869f119a77c555_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-925105a1e165fd578a869f119a77c555_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-925105a1e165fd578a869f119a77c555_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-925105a1e165fd578a869f119a77c555_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在「前端开发者」成为「应用开发者」的大背景下，技术栈、工程基建的发展，开始形成基于「前端技术」的成熟 GUI 软件研发体系。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_17&quot; data-into-catalog-status=&quot;&quot;&gt;1.4.1  什么是「前端技术」 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-47f123577b41259d0db6a80738b846a3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-47f123577b41259d0db6a80738b846a3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-47f123577b41259d0db6a80738b846a3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-47f123577b41259d0db6a80738b846a3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;先明确一下我们一直说的前端技术，不是指做 UI 的技术，而是由 Web 原生语言、Web Runtime、Web 技术生态组成的技术栈，不是只在浏览器里才有前端技术，而是有 Web Runtime、有 Web 语言的地方，就有前端技术  &lt;/p&gt;&lt;h2 id=&quot;h_426707646_18&quot; data-into-catalog-status=&quot;&quot;&gt;1.4.2  DX 和 UX 同样重要  &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c16c66c9af4b349dc98d5a8e20f41819_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c16c66c9af4b349dc98d5a8e20f41819_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c16c66c9af4b349dc98d5a8e20f41819_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c16c66c9af4b349dc98d5a8e20f41819_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;传统前端开发不是成熟的软件研发体系，缺乏足够的抽象和基建，导致 DX 和 UX 始终存在矛盾，此消彼涨。以往的产品开发中，习惯更重视 UX，这有两方面的原因，一来是因为产品是由产品主导，因此更重视 UX， 不会过多关注开发者体验，再就是缺乏足够的抽象和基建，导致 DX 和 UX 之间必须牺牲一个。 &lt;/p&gt;&lt;p&gt;在新一代更成熟的研发体系的支持下，已经可以实现 DX 和 UX 的同时最大化了，也从「更重视 UX」转变为「DX 优先」的方式 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-497f4fd8bd6259ad36d240dbb601e111_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-497f4fd8bd6259ad36d240dbb601e111_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-497f4fd8bd6259ad36d240dbb601e111_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-497f4fd8bd6259ad36d240dbb601e111_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;要实现 DX 和 UX 的同时最大化，需要充分的抽象。比如前面提到的 Modern.js 的这个例子，项目里只有三个文件，就具备全面的能力，包括自动 Polyfill、差异化分发、SSR 等，既具备产品级的 UX，有保持了 DX 的简单、开箱即用等 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_19&quot; data-into-catalog-status=&quot;&quot;&gt;1.4.3  充分抽象 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2ebac7ebcf189f284169a95d81053a70_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2ebac7ebcf189f284169a95d81053a70_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2ebac7ebcf189f284169a95d81053a70_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2ebac7ebcf189f284169a95d81053a70_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;要实现充分抽象，需要让项目从基于「库、工具」发展成基于「框架」，这两者的区别在图上表现的比较好。蓝底白边部分是项目开发者自己写的代码。左边是传统前端项目，由开发者手写整个应用，把库和工具当做积木来组装，填补项目里的空白。而右边是 Modern.js 项目，整个应用是框架本身，开发者手写的代码，是按照框架的要求填充到框架预留的位置上 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30530efc665905685cd309533369b2cf_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-30530efc665905685cd309533369b2cf_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-30530efc665905685cd309533369b2cf_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-30530efc665905685cd309533369b2cf_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;要实现充分抽象，也需要在尽可能多的环节实现最大化的抽象，图上体现了 Modern.js 除了像常规的框架一样，在运行时和编译时做抽象，也会在 IDE 编写代码的环节，和部署产物的环节，引入最大化的抽象 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c83ba78539f4968e7a7b72d1ac21c270_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c83ba78539f4968e7a7b72d1ac21c270_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c83ba78539f4968e7a7b72d1ac21c270_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c83ba78539f4968e7a7b72d1ac21c270_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;要实现充分抽象，也需要解决前端模板的问题，Modern.js 把各种研发场景、项目类型，收敛和标准化成了始终固定的三个工程类型，其中「应用」工程方案，也就是 MWA，支持所有需要部署和运行的项目，「模块」工程方案支持所有需要实现代码复用的项目 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_20&quot; data-into-catalog-status=&quot;&quot;&gt;1.5 智能化、平台化、低码化 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7bac453602d6486ad88c92289d1b96d5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-7bac453602d6486ad88c92289d1b96d5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-7bac453602d6486ad88c92289d1b96d5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7bac453602d6486ad88c92289d1b96d5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 代表的现代 Web 开发，也在继续朝着智能化、平台化、低码化的方向发展 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7812a8332be2bdd8f09e2400f2e6e572_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7812a8332be2bdd8f09e2400f2e6e572_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7812a8332be2bdd8f09e2400f2e6e572_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7812a8332be2bdd8f09e2400f2e6e572_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;智能化方面，当前可用的功能，是用 Modern.js 的初始化工具创建的项目，会开箱即用的在 VSCode 里做好配置，启用几千条规则组成的 ESLint 全量规则集，加上按最佳实践内置在 ESLint 里的 Prettier，期望尽可能多自动修正问题，而不是仅仅提示问题。也追求尽可能多的让 IDE 负责生成真正的源码，让开发者手写的代码变成跟 IDE 沟通的语言 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a0cd7d464423c4972df34a7ede34ce47_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-a0cd7d464423c4972df34a7ede34ce47_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-a0cd7d464423c4972df34a7ede34ce47_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a0cd7d464423c4972df34a7ede34ce47_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在平台化方面，Modern.js 的目标之一就是形成「工程标准」，让各种前端 PaaS 平台可以围绕标准实现高级能力，比如图上粉色部分列出的产品级 Web Server、差异化分发、SSR 兜底、ESR、微前端等，都需要结合代码层面的工程标准。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1f02fb03d20d264f1bdba868871d18af_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f02fb03d20d264f1bdba868871d18af_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1f02fb03d20d264f1bdba868871d18af_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1f02fb03d20d264f1bdba868871d18af_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;除了部署运行环节方面的平台，有了工程标准之后，研发环节也可以引入更多低码提效。 &lt;/p&gt;&lt;p&gt;目前我们内部使用的研发平台，可以直接在图形界面上简单操作完成 项目的创建、开发、部署。图上右侧可以看到图形界面上展示了当前项目的的状态: 入口数量、项目配置等，蓝色框内添加应用的入口，一键从 「单入口」 转变为 「多入口」 。右侧在 Web IDE 中也能看到 src 目录结构下的变化。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8e7260a746d5e52a9eb494f57d5a65ff_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-8e7260a746d5e52a9eb494f57d5a65ff_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-8e7260a746d5e52a9eb494f57d5a65ff_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8e7260a746d5e52a9eb494f57d5a65ff_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;低码化有两个方向，一个是刚才说的跟研发工具结合，另一个就是研发从某些工作中解脱出来的低码搭建，昨天的低代码专题中有介绍 &lt;/p&gt;&lt;p&gt;总结 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7a3ac8ff330689765e2a7b8d4ef59df6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7a3ac8ff330689765e2a7b8d4ef59df6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7a3ac8ff330689765e2a7b8d4ef59df6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7a3ac8ff330689765e2a7b8d4ef59df6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;到目前为止，我们从这些变革的角度，展示了很多 Modern.js 的 demo 和效果 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_21&quot; data-into-catalog-status=&quot;&quot;&gt;二、Modern.js 的六大要素 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9c1f5b9da5cccb89b1b36e7989f01131_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9c1f5b9da5cccb89b1b36e7989f01131_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9c1f5b9da5cccb89b1b36e7989f01131_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9c1f5b9da5cccb89b1b36e7989f01131_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来我们系统的看一下 Modern.js 是什么，Modern.js 提供了什么。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_22&quot; data-into-catalog-status=&quot;&quot;&gt;2.1 普及：现代 Web 开发范式 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-72e0a9c9304954ac854475f1ed041bac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-72e0a9c9304954ac854475f1ed041bac_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-72e0a9c9304954ac854475f1ed041bac_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-72e0a9c9304954ac854475f1ed041bac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以用这六大要素来说明 Modern.js 。 &lt;/p&gt;&lt;p&gt;首先这个项目是希望能推动现代 Web 开发范式的普及，发展完整的现代 Web 工程体系，突破应用开发效率的瓶颈。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-306763a8894139bbbb02376762432315_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-306763a8894139bbbb02376762432315_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-306763a8894139bbbb02376762432315_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-306763a8894139bbbb02376762432315_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面讨论「现代 Web 开发」的时候，已经展示过这种范式的 9 大主要特征。 &lt;/p&gt;&lt;p&gt;其中 Serverless 范式、平台化、低码化这三个特征，在当前版本的 Modern.js 里还没什么体现，需要后续会跟一些平台配合提供。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_23&quot; data-into-catalog-status=&quot;&quot;&gt;2.2 核心：现代 Web 应用（MWA） &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5a746483f604a62c1bf437a55ca074a4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5a746483f604a62c1bf437a55ca074a4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5a746483f604a62c1bf437a55ca074a4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5a746483f604a62c1bf437a55ca074a4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;继续看第二个要素。Modern.js 三大工程类型中最核心的就是 「现代 Web 应用」，简称 MWA，或直接叫「应用」 。&lt;/p&gt;&lt;h2 id=&quot;h_426707646_24&quot; data-into-catalog-status=&quot;&quot;&gt;2.2.1 从 Universal JS 到 Universal App &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-62a9b06f078b664baa36424b04caef79_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-62a9b06f078b664baa36424b04caef79_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-62a9b06f078b664baa36424b04caef79_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-62a9b06f078b664baa36424b04caef79_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面提到过，「应用」工程方案支持所有需要部署和运行的项目，把这些项目收敛成用同一套框架、同一套约定、同一套模板、同一套架构、一套 API 来开发。 &lt;/p&gt;&lt;p&gt;反过来，我们也可以从 Universal App、一体化、应用架构、Runtime API 这四个角度来了解 MWA。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-52af6762762bab8148e9389a075376a7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-52af6762762bab8148e9389a075376a7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-52af6762762bab8148e9389a075376a7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-52af6762762bab8148e9389a075376a7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Universal JS 指同一份 JS 代码，既能在浏览器端运行，也能在服务器端运行。Universal App 是它的进一步发展，同一份 App 代码可以在不同环节运行，也可以用不同的模式来运行。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c8128743c6c99270e4b469477dd75fb4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c8128743c6c99270e4b469477dd75fb4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c8128743c6c99270e4b469477dd75fb4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c8128743c6c99270e4b469477dd75fb4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先是常见的 MPA 和 SPA 的需求，本质上是「服务器端路由」和「客户端路由」的需求。 &lt;/p&gt;&lt;p&gt;在 Modern.js 里它们可以随意组合。 &lt;/p&gt;&lt;p&gt;我们之前的例子都是单入口应用，只需要把 App.tsx 组件、pages 目录这样的入口标识放到 src 的子目录里，就能将单入口应用变成多入口的 MPA。会基于入口名称，自动生成服务器端路由，比如图上的 admin-app 和 landing-page 两个入口的 URL。 &lt;/p&gt;&lt;p&gt;admin-app 和 landing-page  也分别都是 SPA，根据入口标识不同，一个使用基于组件的客户端路由，一个使用基于文件系统的客户端路由。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6ed8c023bde594c07f7e698ea937f39d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-6ed8c023bde594c07f7e698ea937f39d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-6ed8c023bde594c07f7e698ea937f39d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-6ed8c023bde594c07f7e698ea937f39d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然后是 MWA 中的「动静一体」 &lt;/p&gt;&lt;p&gt;之前演示过，一个静态的 CSR 项目如何直接开启 SSR、SPR、SSG 功能。 &lt;/p&gt;&lt;p&gt;Modern.js 也支持 CSR 和 SSR/SSG 混用，比如图上右侧红色高亮部分会在服务端被渲染到 HTML 中，蓝色区域的日期时间，在 CSR 阶段动态展示在页面上。也就是整体 SSR + 局部 CSR。 &lt;/p&gt;&lt;p&gt;整体 CSR + 局部 SSR的能力后续会加入。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-45656056b9ef492d925828cae2c7cd05_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-45656056b9ef492d925828cae2c7cd05_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-45656056b9ef492d925828cae2c7cd05_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-45656056b9ef492d925828cae2c7cd05_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在 BFF 支持方面，Modern.js 中还提供了类型友好的方式，可以通过 Type Schema 实现运行时自动校验接口的参数和返回值。比如右下角请求时，参数 text 类型为 number 时，response 中会自动提示相应的错误。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9794858c7153ab027c46e2576c4b13b9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9794858c7153ab027c46e2576c4b13b9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9794858c7153ab027c46e2576c4b13b9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9794858c7153ab027c46e2576c4b13b9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 还支持不同类型应用的开发和运行。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-626e5ec5ee053f66a52f708f7d8ac2f2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-626e5ec5ee053f66a52f708f7d8ac2f2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-626e5ec5ee053f66a52f708f7d8ac2f2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-626e5ec5ee053f66a52f708f7d8ac2f2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 原生支持微前端，底层解决方案是 Web Infra 之前开源的 Garfish 微前端解决方案。一个 MWA 可以随时变成微前端主应用，在配置中指定子应用列表的加载地址，Modern.js 就会自动在 Web Server 中预加载子应用数据，注入到运行时。在 Runtime API 的帮助下，可以像普通 React 组件一样使用子应用。 &lt;/p&gt;&lt;p&gt;MWA 也可以分别作为独立的 Web 和微前端子应用的运行和部署。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-53b6cf3b528112b60d009533cf1ac462_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-53b6cf3b528112b60d009533cf1ac462_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-53b6cf3b528112b60d009533cf1ac462_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-53b6cf3b528112b60d009533cf1ac462_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;MWA 在启用 Electron 支持之后，能作为桌面应用来运行，项目里会新增 electron 目录用于写主进程相关代码。 除了开箱即用的 Electron 构建等能力，也提供运行时 API 支持 Electron 的常见需求和最佳实践，进一步提升开发效率。&lt;/p&gt;&lt;h2 id=&quot;h_426707646_25&quot; data-into-catalog-status=&quot;&quot;&gt;2.2.2 前后端一体化 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-93b89822a5c94bf1399ad649e820c5a9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-93b89822a5c94bf1399ad649e820c5a9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-93b89822a5c94bf1399ad649e820c5a9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-93b89822a5c94bf1399ad649e820c5a9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二个看待 MWA 的角度是 「前后端一体化」 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-45834d2d2eb1cd0e69fb676ec1b571cb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-45834d2d2eb1cd0e69fb676ec1b571cb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-45834d2d2eb1cd0e69fb676ec1b571cb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-45834d2d2eb1cd0e69fb676ec1b571cb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之前已经演示过 BFF 函数，api/ 目录下每个文件就是 BFF 路由，当服务器端逻辑更重的时候，可以加入 Node.js 框架元素，目前支持了 4 种框架，还可以自己开发 Modern.js 插件支持更多框架。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7bae8dd2ce2ace2b3f986c81080bd4f6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7bae8dd2ce2ace2b3f986c81080bd4f6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7bae8dd2ce2ace2b3f986c81080bd4f6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7bae8dd2ce2ace2b3f986c81080bd4f6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面提到过：以客户端为中心，不代表不能掌控服务器端，不能直接写服务器端业务逻辑。 &lt;/p&gt;&lt;p&gt;比如之前演示过的火山引擎子应用，除了通过框架插件来实现，我们也可以在项目里创建 server 目录和钩子文件，添加修改 HTML 渲染结果的逻辑。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8133def222cd16b853ade107facfabf9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8133def222cd16b853ade107facfabf9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8133def222cd16b853ade107facfabf9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8133def222cd16b853ade107facfabf9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在只有 src 目录，或有 api 目录的情况下，MWA 类似 JAMstack 项目。 &lt;/p&gt;&lt;p&gt;如果增加了 server 等钩子文件，MWA 就能像传统 Node.js App 一样直接写服务器端业务逻辑，使用 Node.js 框架插件、中间件等。 &lt;/p&gt;&lt;p&gt;如果删掉 src 目录，MWA 就是一个纯 REST API 的项目。 &lt;/p&gt;&lt;p&gt;我们把这三种模式之间随意迁移的能力，称作「三位一体」&lt;/p&gt;&lt;h2 id=&quot;h_426707646_26&quot; data-into-catalog-status=&quot;&quot;&gt;2.2.3 应用架构 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-31fc11f7950038ea3621a11a9c3953ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-31fc11f7950038ea3621a11a9c3953ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-31fc11f7950038ea3621a11a9c3953ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-31fc11f7950038ea3621a11a9c3953ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来，我们从「应用架构」的角度看看 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-90940f7f88503d2078e943f76ba5fe87_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-90940f7f88503d2078e943f76ba5fe87_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-90940f7f88503d2078e943f76ba5fe87_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-90940f7f88503d2078e943f76ba5fe87_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;传统 Web 开发中的应用架构，等同于服务器端应用架构，前端部分的架构要么缺失，要么需要项目开发者自己摸索、搭建，缺乏 API 支持和一致的抽象，难以跨项目复用业务逻辑 。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e6bb1eeec7a7fc5a32da57d9c582f17a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e6bb1eeec7a7fc5a32da57d9c582f17a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e6bb1eeec7a7fc5a32da57d9c582f17a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e6bb1eeec7a7fc5a32da57d9c582f17a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如上图，MWA 提供的开箱即用的、客户端为中心的应用架构，可以通过标准化的 Runtime API，轻易实现 React 开发中缺少的 Model 层和 Controller 层。Model 作为封装 UI 无关业务逻辑的积木，跟 UI 组件一样可以复用和组装。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e1c31785e657bd81237801c53e7dd4c0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e1c31785e657bd81237801c53e7dd4c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e1c31785e657bd81237801c53e7dd4c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e1c31785e657bd81237801c53e7dd4c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之前 Web Infra 举办的 React 核心开发者在线访谈里，Redux 作者 Dan 提到，状态管理最重要的是理解状态的类型，根据需要处理的状态是什么种类，来选择对应的方案。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bfb32a8a769c9f9aa1040f4951bc0717_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfb32a8a769c9f9aa1040f4951bc0717_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-bfb32a8a769c9f9aa1040f4951bc0717_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bfb32a8a769c9f9aa1040f4951bc0717_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;常见的状态管理方案，都有适合的状态类型和场景，很多时候需要混合使用，而不是一把锤子锤所有钉子，要么所有状态都放到全局应用状态里，要么所有状态都在局部状态里。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dbb0ef774c9714f34ee07dd4e97bb01f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-dbb0ef774c9714f34ee07dd4e97bb01f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-dbb0ef774c9714f34ee07dd4e97bb01f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-dbb0ef774c9714f34ee07dd4e97bb01f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;很多开发者不用 Redux，是因为 Redux 本身只能算底层 API，需要手动创建和维护 store，业务逻辑被 reducer，action 等分散在不同的地方，提高了维护成本。其实 Redux 社区一直有解决方案，比如 Ducks Modular 设计模式会把业务逻辑聚集在一起，Redux 官方支持的主流库 RTK 也为解决这样的问题而生。 &lt;/p&gt;&lt;p&gt;Modern.js 的 Model 基于 Redux 进一步提高抽象程度，保留了 Redux 在不可变数据、数据流等方面的收益，对整个 Redux 生态兼容，让使用和不使用 Redux 的开发者都能受益。支持多种状态类型，也支持不同的 Model 写法&lt;/p&gt;&lt;h2 id=&quot;h_426707646_27&quot; data-into-catalog-status=&quot;&quot;&gt;2.2.4 Runtime API 标准库 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-50b8f3cd60f9504aff4aa057801f2702_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-50b8f3cd60f9504aff4aa057801f2702_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-50b8f3cd60f9504aff4aa057801f2702_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-50b8f3cd60f9504aff4aa057801f2702_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后看下 MWA 的 Runtime API 标准库。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4f7e1787301755d882d75bff8a8d7859_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f7e1787301755d882d75bff8a8d7859_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4f7e1787301755d882d75bff8a8d7859_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4f7e1787301755d882d75bff8a8d7859_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;相当于「应用」层级的基础 API，不止能在 MWA 里使用，在 Modern.js 的模块工程方案里，同样可以使用这些 API，开发可复用的业务组件，支持独立调试和测试。 &lt;/p&gt;&lt;p&gt;图中最上面蓝色方块是业务开发中常用的 API，比如 useLoader，useModel 等 API。中间绿色部分就是前面提到的定制 web server、BFF 函数需要用到的 API，最底层的插件 API，是整个框架的基础，框架里所有的包都是用插件 API 来实现的，也可以用插件 API 来扩展框架、定制工程方案。粉色部分包括很多重要的工具 API，比如 useLocalModel。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0d253953e000072d38704f141557ca62_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0d253953e000072d38704f141557ca62_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0d253953e000072d38704f141557ca62_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0d253953e000072d38704f141557ca62_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当应用中的组件需要拆分成独立的模块复用时，实现中用到的 Runtime API  还能正常调试、测试吗，答案是肯定的，这套 API 相当于「应用」领域的 API 标准库，不止能在 MWA 里使用，在 Modern.js 的「模块」工程方案里，同样可以使用这些 API，开发可复用的业务组件，支持独立调试和测试。上图右侧是模块工程的目录结构。左侧 TableList 组件中使用了 useLoader API，调试时只需要提供对应的 story 文件，模块工程方案支持我们在 Storybook 可视化测试以及单元测试中测试使用了 Runtime API 的组件。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_28&quot; data-into-catalog-status=&quot;&quot;&gt;2.3 内置：前端工程最佳实践 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-afa124f91e410eecc888218036864a92_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-afa124f91e410eecc888218036864a92_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-afa124f91e410eecc888218036864a92_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-afa124f91e410eecc888218036864a92_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;对于第三个要素，简单列举几个 Modernjs 内置的前端工程最佳实践 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_29&quot; data-into-catalog-status=&quot;&quot;&gt;2.3.1 Post-Webpack Era &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d23e006e139aec32c130bb51f8fc5e78_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d23e006e139aec32c130bb51f8fc5e78_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d23e006e139aec32c130bb51f8fc5e78_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d23e006e139aec32c130bb51f8fc5e78_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;传统前端工程建设都是基于 Webpack 的配置封装， Webpack 配置复杂和编译缓慢的问题，大家应该都有比较深的感受， 但是从去年开始业界涌现很多新的工具，完全不涉及 Webpack，比如 Snowpack、 Vite、wmr 等，有人把它称为 JS 第三纪元。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4850f42e5217e8d9ba806fdf1d4d361b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4850f42e5217e8d9ba806fdf1d4d361b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4850f42e5217e8d9ba806fdf1d4d361b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4850f42e5217e8d9ba806fdf1d4d361b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从第三纪元开始 esbuild、swc 这种编译打包工具使用非 JS 的系统编程语言开发，显著提高编译速度。编译时间的缩减也意味着不打包，按需编译的 ESM 场景可以实现， &lt;/p&gt;&lt;p&gt;Snowpack、Vite 这样的工具，就是在 esbuild 的基础上实现的、开发者体验优先的、不打包的开发调试模式。在 Modern.js 中不打包的模式目前已经被用于公共库的构建、业务项目的开发调试等真实场景。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-40bafe10b2e1d9a9f183a5300148bcc6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-40bafe10b2e1d9a9f183a5300148bcc6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-40bafe10b2e1d9a9f183a5300148bcc6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-40bafe10b2e1d9a9f183a5300148bcc6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 中也内置类似 Snowpack、Vite 的不打包开发调试模式，图中左侧启用该功能之后，运行效果就像图中右侧那样，开发服务器在秒级启动。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0acd82c32168557c386c10be8b79a16e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0acd82c32168557c386c10be8b79a16e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0acd82c32168557c386c10be8b79a16e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0acd82c32168557c386c10be8b79a16e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为什么可以做到速度这么快？主要是因为业务代码只有在请求时使用 esbuild 按需编译，第三方依赖自动从 Goofy PDN 加载已经预编译好的产物。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_30&quot; data-into-catalog-status=&quot;&quot;&gt;2.3.2 CSS 最佳实践 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d2b64f897cc9ed5be3b1a4af1a445ea1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-d2b64f897cc9ed5be3b1a4af1a445ea1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-d2b64f897cc9ed5be3b1a4af1a445ea1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d2b64f897cc9ed5be3b1a4af1a445ea1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在 CSS 开发方面，Modern.js 默认推荐图上「CSS 三剑客」搭配使用，有需要也可以开启 LESS/SASS 等预处理器和 CSS Modules 支持。&lt;/p&gt;&lt;h2 id=&quot;h_426707646_31&quot; data-into-catalog-status=&quot;&quot;&gt;2.3.3 默认零配置、样板文件最小化 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-72f4e1889753f075f01c32f284f9abe5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-72f4e1889753f075f01c32f284f9abe5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-72f4e1889753f075f01c32f284f9abe5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-72f4e1889753f075f01c32f284f9abe5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;和以前把功能作为样板文件塞到项目里相比，现代 Web 开发范式下的最佳实践是默认零配置的，同时样板文件尽可能简洁最小化。之前我们也通过例子看到 Modern.js 项目手动创建非常简单，只需要应用根组件和 package.json。 &lt;/p&gt;&lt;p&gt;跟直接使用 Garfish 开发微前端主应用的项目做对比， 上图可以看到直接使用 Garifish 的项目，需要手动运行 Garfish 框架、处理公用模块、路由等逻辑。除了运行时，还需要编译环节自定义一大堆配置。直接使用还是有一定的成本。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d5215b9eb13164d856e2387b30c88d7f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d5215b9eb13164d856e2387b30c88d7f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d5215b9eb13164d856e2387b30c88d7f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d5215b9eb13164d856e2387b30c88d7f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之前的例子已经说过，在 Modern.js 中使用微前端，只需要在 web 应用的基础上启用微前端功能，提供子应用列表即可，每个子应用加载后就是组件，路由可以自己灵活组织。&lt;/p&gt;&lt;h2 id=&quot;h_426707646_32&quot; data-into-catalog-status=&quot;&quot;&gt;2.3.4 构建产物规范 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3dbaecbffd151ad33a622bd94b3ab2f4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3dbaecbffd151ad33a622bd94b3ab2f4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3dbaecbffd151ad33a622bd94b3ab2f4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3dbaecbffd151ad33a622bd94b3ab2f4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 的模块工程方案，会并行编译出多种符合社区主流规范的构建产物 &lt;/p&gt;&lt;p&gt;模块的编译也是不打包的，更容易引入速度更快的工具比如 esbuild、swc 等。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_33&quot; data-into-catalog-status=&quot;&quot;&gt;2.3.5 Monorepo 工程方案 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-482e4e516d49a5ae43b544c846dac907_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-482e4e516d49a5ae43b544c846dac907_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-482e4e516d49a5ae43b544c846dac907_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-482e4e516d49a5ae43b544c846dac907_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;应用和库如果分散在不同项目中开发的话，通过 npm link 调试也比较麻烦，业界的主流方案通过 Monorepo 管理多个子项目， Modern.js 本身就是基于 pnpm monorepo 开发的，同时也将这部分最佳实践收敛到 monorepo 工程方案，默认使用 pnpm 进行包管理， 左侧是它的目录结构， apps 对应的是 MWA 应用 、features/packages 对应是可复用的模块。 &lt;/p&gt;&lt;p&gt;右侧内部模块指的是不会发布到 npm、仅在当前仓库下复用的库。它本身不需要构建，同仓库下的应用直接使用它的源码即可。 monorepo 我们也提供了 new 命令，可以选择创建应用或者模块。&lt;/p&gt;&lt;h2 id=&quot;h_426707646_34&quot; data-into-catalog-status=&quot;&quot;&gt;2.3.6 更多 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-96f69335fad1405fde05d3d92e21451f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-96f69335fad1405fde05d3d92e21451f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-96f69335fad1405fde05d3d92e21451f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-96f69335fad1405fde05d3d92e21451f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;除了上面提到的一些最佳实践，Modern.js 还提供了单元测试、集成测试、Visual Testing 等、ESlint 全量规则集等最佳实践。这里不一一展开介绍。可以查阅 Modern.js 文档进一步了解。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_35&quot; data-into-catalog-status=&quot;&quot;&gt;2.4 包含：Web 开发全流程 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b2a38a82702137ae059816ec585221ea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b2a38a82702137ae059816ec585221ea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b2a38a82702137ae059816ec585221ea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b2a38a82702137ae059816ec585221ea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 不只是在上述运行时、构建、调试等方面提供了支持，它本身就覆盖了 Web 开发的全流程。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-576d0a934570e01df86e68281646168e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-576d0a934570e01df86e68281646168e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-576d0a934570e01df86e68281646168e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-576d0a934570e01df86e68281646168e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在编码环节，可以通过微生成器启用某个功能或者添加入口，从 SPA 迁移到 MPA。和前面提到的通过研发平台 「低码提效」类似，还可以像图上那样在项目目录下执行 new 命令选择要启用的功能。这个命令会自动重构我们的代码。 &lt;/p&gt;&lt;p&gt;通过微生成器按需自动启用的方式，可以放心的将一些功能作为插件提供，也可以控制 Modern.js 初始化项目的体积。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d49c69b4a27c4ab930595e414933a05d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-d49c69b4a27c4ab930595e414933a05d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-d49c69b4a27c4ab930595e414933a05d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d49c69b4a27c4ab930595e414933a05d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在微前端子应用开发时，通常情况下主应用已经部署上线了，这时候开发子应用就需要结合线上的主应用一起调试，解决方式之一是通过全局代理子应用 JS 到本地，比较麻烦。 &lt;/p&gt;&lt;p&gt;在 Modern.js 中，只需要主应用像图中右下角那样启用 DEBUG 模式，之后打开主应用线上链接，在 header 中设置需要开发的子应用信息，server 会自动替换注入到 html 中的子应用列表数据。这样也就可以让线上主应用加载本地子应用。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b08b76f0c54d6060997eea26b4bf2413_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b08b76f0c54d6060997eea26b4bf2413_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b08b76f0c54d6060997eea26b4bf2413_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b08b76f0c54d6060997eea26b4bf2413_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在运行环节，传统的 Web 开发模式，通常没有提供生产环境运行项目的方式，MWA 项目本身自带产品级的 Server，自己就能产品级的运行自己，比如图上的自动 Polyfill 服务。之前也提过，结合 serverless 平台，可以自动做一些优化，也可以在本地运行模拟生产环境的效果。 &lt;/p&gt;&lt;h2 id=&quot;h_426707646_36&quot; data-into-catalog-status=&quot;&quot;&gt;2.5 提供：工程标准体系 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d39f24648924f257dedcff496122ad01_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-d39f24648924f257dedcff496122ad01_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-d39f24648924f257dedcff496122ad01_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d39f24648924f257dedcff496122ad01_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 不只是一个现代 Web 应用开发框架，而是提供了整套的现代 Web 工程体系。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e552e81ca8487fd14ba56f00d08fa536_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e552e81ca8487fd14ba56f00d08fa536_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e552e81ca8487fd14ba56f00d08fa536_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e552e81ca8487fd14ba56f00d08fa536_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前面已经介绍过，我们将前端开发中涉及的场景收敛到 3 种：应用、模块和 monorepo。 &lt;/p&gt;&lt;p&gt;不仅解决了业务模板数量爆炸的问题。融合后的工程类型，比如 MWA 不是多个场景简单叠加，导致工程变的大而全，通过抽象可以做到很轻量，也能更容易交付一些之前不好实现的功能。&lt;/p&gt;&lt;h2 id=&quot;h_426707646_37&quot; data-into-catalog-status=&quot;&quot;&gt;2.6 鼓励：定制工程方案 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5721ca4f215c7b787f26fe7d8b5139f6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-5721ca4f215c7b787f26fe7d8b5139f6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-5721ca4f215c7b787f26fe7d8b5139f6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5721ca4f215c7b787f26fe7d8b5139f6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 鼓励业务结合自身场景定制垂直的工程方案。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d622d11348af2d6dd2f5d6ec7123eb16_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-d622d11348af2d6dd2f5d6ec7123eb16_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-d622d11348af2d6dd2f5d6ec7123eb16_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d622d11348af2d6dd2f5d6ec7123eb16_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;就像前面提到的火山引擎例子一样，封装插件、微生成器、定制出自己的业务工程方案。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-df3edce57b085ac0fcd09011cd309c1a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-df3edce57b085ac0fcd09011cd309c1a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-df3edce57b085ac0fcd09011cd309c1a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-df3edce57b085ac0fcd09011cd309c1a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;关于 Modern.js 六大要素的更多解释和例子，可以到 Modern.js 官网进一步查阅。&lt;/p&gt;&lt;h2 id=&quot;h_426707646_38&quot; data-into-catalog-status=&quot;&quot;&gt;三、Modern.js 社区和现代 Web 研发体系 &lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-87aafb7f8a9b33e7386334a6c101b0e8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-87aafb7f8a9b33e7386334a6c101b0e8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-87aafb7f8a9b33e7386334a6c101b0e8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-87aafb7f8a9b33e7386334a6c101b0e8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后我们一起看下除了已经发布的开源项目，还有哪些对现代 Web 开发者有帮助的事情在发起和推进中。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7f815fab92f7f0b52a11d161c5d45599_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-7f815fab92f7f0b52a11d161c5d45599_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-7f815fab92f7f0b52a11d161c5d45599_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7f815fab92f7f0b52a11d161c5d45599_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Modern.js 开源项目现在是刚起步的状态，昨天上线的官网，以及最新发的 1.0 版，都是公测状态，还需要更多意见、测试和实践，希望大家多参与社区建设。 &lt;/p&gt;&lt;p&gt;Modern.js 的起点是字节内部的现代 Web 工程体系项目，现在大部分代码已经完全转到 Github 上开发，工作流还在建设中。 &lt;/p&gt;&lt;p&gt;双月计划、每周计划、缺陷管理等，也都会全面转到 Github 上公开推进。 &lt;/p&gt;&lt;p&gt;当前版本还没有包含 Roadmap 上一些重要功能，计划以每周发版的节奏，把这些功能补上。 &lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1895b46546187f0d3e669a4f32f5e560_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-1895b46546187f0d3e669a4f32f5e560_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-1895b46546187f0d3e669a4f32f5e560_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-1895b46546187f0d3e669a4f32f5e560_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;昨天的分享介绍了 「现代 Web 研发体系」中的其他部分，这些部分也都算是 Modern.js 的重要功能，后续会陆续对外开放，欢迎大家关注。 &lt;/p&gt;&lt;p&gt;最后，屏幕上右下角二维码是 Modern.js 官网的地址，可以在官网上通过快速上手和实战教程了解更多 Modernjs 的细节使用部分。 &lt;/p&gt;&lt;p&gt;谢谢大家。  &lt;/p&gt;&lt;p&gt;官网：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//modernjs.dev/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;modernjs.dev/&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; &lt;/p&gt;&lt;p&gt;Github: &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/modern-js-dev/modern.js&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/modern-js-de&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;v/modern.js&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c3f50b1a2f257e954e4b24b58281d68</guid>
<title>无需 Dockerfile 的镜像构建：BuildPack vs Dockerfile</title>
<link>https://toutiao.io/k/4zi9xn3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt;内容稍长，算是迟交的作业吧。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5OTg2MTM0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxdtJ2OCKT1wGtCS0hhfm2qr9mAUR2IdaDxWY7PcU4OuHGMztkvSKZ14hsO5F0gjMbAanvYdZa63Ew/0?wx_fmt=png&quot; data-nickname=&quot;云原生指北&quot; data-alias=&quot;sevenfeet&quot; data-signature=&quot;专注于基础架构、云原生，分享 Kubernetes、容器、DevOps 等前沿技术、工具。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;过去的工作中，我们使用微服务、容器化以及服务编排构建了技术平台。为了提升开发团队的研发效率，我们同时还提供了 CICD 平台，用来将代码快速的部署到 Openshift（企业级的 Kubernetes） 集群。&lt;/p&gt;&lt;p&gt;部署的第一步就是应用程序的容器化，持续集成的交付物从以往的 jar 包、webpack 等变成了容器镜像。容器化将软件代码和所需的所有组件（库、框架、运行环境）打包到一起，进而可以在任何环境任何基础架构上一致地运行，并与其他应用“隔离”。&lt;/p&gt;&lt;p&gt;我们的代码需要从源码到编译到最终可运行的镜像，甚至部署，这一切在 CICD 的流水线中完成。最初，我们在每个代码仓库中都加入了三个文件，也通过项目生成器（类似 Spring Initializer）在新项目中注入：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Jenkinsfile.groovy：用来定义 Jenkins 的 Pipeline，针对不同的语言还会有多种版本&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Manifest YAML：用于定义 Kubernetes 资源，也就是工作负载及其运行的相关描述&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Dockerfile：用于构建对象&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个三个文件也需要在工作中不断的演进，起初项目较少（十几个）的时候我们基础团队还可以去各个代码仓库去维护升级。随着项目爆发式的增长，维护的成本越来越高。我们对 CICD 平台进行了迭代，将“Jenkinsfile.groovy”和 “manifest YAML”从项目中移出，变更较少的 Dockerfile 就保留了下来。&lt;/p&gt;&lt;p&gt;随着平台的演进，我们需要考虑将这唯一的“钉子户” Dockerfile 与代码解耦，必要的时候也需要对 Dockerfile 进行升级。因此调研了一下 buildpacks，就有了今天的这篇文章。&lt;/p&gt;&lt;h2&gt;什么是 Dockerfile&lt;/h2&gt;&lt;p&gt;Docker 通过读取 Dockerfile 中的说明自动构建镜像。Dockerfile 是一个文本文件，包含了由 Docker 可以执行用于构建镜像的指令。我们拿之前用于&lt;span&gt;测试 Tekton 的 Java 项目&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;的 Dockerfile 为例：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;FROM openjdk&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;jdk&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;alpine&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;RUN mkdir &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;WORKDIR &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;COPY target&lt;/span&gt;&lt;span&gt;/*.jar /app/app.jar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ENTRYPOINT &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;sh&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;-c&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;java -Xmx128m -Xms64m -jar app.jar&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;镜像分层&lt;/h3&gt;&lt;p&gt;你可能会听过 Docker 镜像包含了多个层。每个层与 Dockerfile 中的每个命令对应，比如 &lt;code&gt;RUN&lt;/code&gt;、&lt;code&gt;COPY&lt;/code&gt;、&lt;code&gt;ADD&lt;/code&gt;。某些特定的指令会创建一个新的层，在镜像构建过程中，假如某些层没有发生变化，就会从缓存中获取。&lt;/p&gt;&lt;p&gt;在下面的 Buildpack 中也同样通过镜像分层和 cache 来加速镜像的构建。&lt;/p&gt;&lt;h2&gt;什么是 Buildpack&lt;/h2&gt;&lt;p&gt;&lt;span&gt;BuildPack&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt; 是一个程序，它能将源代码转换成容器镜像的并可以在任意云环境中运行。通常 buildpack 封装了单一语言的生态工具链。适用于 Java、Ruby、Go、NodeJs、Python 等。&lt;/p&gt;&lt;figure&gt;&lt;img data-fileid=&quot;100000878&quot; data-ratio=&quot;0.37948717948717947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxeTg2ast3EHcy1ic3S8CgE7XdfgRrlv6ibKibmvaNicrhVofNaoxrFBzTgicBAO8a2PF9vYKWrJ8nFiaF3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3120&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;buildpacks.io&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Builder 是什么？&lt;/h3&gt;&lt;p&gt;一些 buildpacks 按顺序组合之后就是 &lt;strong&gt;builder&lt;/strong&gt;，除了 buildpacks， builder 中还加入了 &lt;span&gt;生命周期&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt; 和 stack 容器镜像。&lt;/p&gt;&lt;figure&gt;&lt;img data-fileid=&quot;100000876&quot; data-ratio=&quot;0.2689697717458359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxeTg2ast3EHcy1ic3S8CgE7X2g2dsiakBQAqonxdj6ibscKETrHtGarIQCOIxMgcdcDx3zBn8688I6zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3242&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;stack 容器镜像由两个镜像组成：用于运行 buildpack 的镜像 build image，以及构建应用镜像的基础镜像 run image。如上图，就是 builder 中的运行环境。&lt;/p&gt;&lt;h3&gt;Buildpack 的工作方式&lt;/h3&gt;&lt;figure&gt;&lt;img data-fileid=&quot;100000877&quot; data-ratio=&quot;0.39878048780487807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxeTg2ast3EHcy1ic3S8CgE7XRE0oF30uY5iarJUsfJfshZwV1LoWtPzgouESoJozJ8uzam0Pz72CJEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3280&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;how buildpack works&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;每个 buildpack 运行时都包含了两个阶段：&lt;/p&gt;&lt;figure&gt;&lt;img data-fileid=&quot;100000875&quot; data-ratio=&quot;0.35992023928215355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxeTg2ast3EHcy1ic3S8CgE7XkIpbicCEsfhQS5aqQJ47CfHwFl8JYsSdR2ibib02njXbuRKo7CzCYjsqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2006&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;phases&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;1. 检测阶段&lt;/h4&gt;&lt;p&gt;通过检查源代码中的某些特定文件/数据，来判断当前 buildpack 是否适用。如果适用，就会进入构建阶段；否则就会退出。比如：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Java maven 的 buildpack 会检查源码中是否有 &lt;code&gt;pom.xml&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Python 的 buildpack 会检查源码中是否有 &lt;code&gt;requirements.txt&lt;/code&gt; 或者 &lt;code&gt;setup.py&lt;/code&gt; 文件&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Node buildpack 会查找 &lt;code&gt;package-lock.json&lt;/code&gt; 文件。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;2. 构建阶段&lt;/h4&gt;&lt;p&gt;在构建阶段会进行如下操作：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;设置构建环境和运行时环境&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;下载依赖并编译源码（假如需要的话）&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;设置正确的 entrypoint 和启动脚本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;比如：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Java maven buildpack 在检查到有 &lt;code&gt;pom.xml&lt;/code&gt; 文件之后，会执行 &lt;code&gt;mvn clean install -DskipTests&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Python buildpack 检查到有 &lt;code&gt;requrements.txt&lt;/code&gt; 之后，会执行 &lt;code&gt;pip install -r requrements.txt&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Node build pack 检查到有 &lt;code&gt;package-lock.json&lt;/code&gt; 后执行 &lt;code&gt;npm install&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;BuildPack 上手&lt;/h2&gt;&lt;p&gt;那到底如何在没有 Dockerfile 的情况下使用 builderpack 构建镜像的。看了上面这些，大家基本上也都能了解到这个核心就在 buildpack 的编写和使用的。&lt;/p&gt;&lt;p&gt;其实现在有很多开源的 buildpack 可以用，没有特定定制的情况下无需自己手动编写。比如下面的几个大厂开源并维护的 Buildpacks：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Heroku Buildpacks&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Google Buildpacks&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Paketo&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;但是正式详细介绍开源的 buildpacks 之前，我们还是通过自己创建 buildpack 的方式来深入了解 Buildpacks 的工作方式。测试项目呢，我们还是用&lt;span&gt;测试 Tekton 的 Java 项目&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;下面所有的内容都提交到了 &lt;span&gt;Github&lt;sup&gt;[8]&lt;/sup&gt;&lt;/span&gt; 上，可以访问：https://github.com/addozhang/buildpacks-sample 获取相关代码。&lt;/p&gt;&lt;p&gt;最终的目录&lt;code&gt;buildpacks-sample&lt;/code&gt;结构如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; builders&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; builder&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; buildpacks&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; buildpack&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; bin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; build&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; detect&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; buildpack&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; stacks&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; build&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Dockerfile&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; build&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; run&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Dockerfile&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;创建 buildpack&lt;/h3&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;pack buildpack &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; examples&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;maven \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                         &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;api &lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                         &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;path buildpack&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;maven \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                         &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;version &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                         &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;stacks io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;buildpacks&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;samples&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;stacks&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;bionic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;看下生成的 &lt;code&gt;buildpack-maven&lt;/code&gt; 目录：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;buildpack&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; bin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;├──&lt;/span&gt;&lt;span&gt; build&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;│&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; detect&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;└──&lt;/span&gt;&lt;span&gt; buildpack&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;各个文件中都是默认的初试数据，并没有什么用处。需要添加些内容：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;bin/detect&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#!/usr/bin/env bash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;f pom&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;xml &lt;/span&gt;&lt;span&gt;]];&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;plan_path&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;cat &lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;${plan_path}&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span&gt;EOL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt;provides&lt;/span&gt;&lt;span&gt;]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;jdk&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt;requires&lt;/span&gt;&lt;span&gt;]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;jdk&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;EOL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;bin/build&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;#!/usr/bin/env bash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;euo pipefail&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;layers_dir&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;$1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;env_dir&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;$2/env&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;plan_path&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;$3&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;m2_layer_dir&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;${layers_dir}/maven_m2&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;d $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;m2_layer_dir&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;]];&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  mkdir &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;p $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;m2_layer_dir&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  echo &lt;/span&gt;&lt;span&gt;&quot;cache = true&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;m2_layer_dir&lt;/span&gt;&lt;span&gt;}.&lt;/span&gt;&lt;span&gt;toml&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ln &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;s $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;m2_layer_dir&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; $HOME&lt;/span&gt;&lt;span&gt;/.&lt;/span&gt;&lt;span&gt;m2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;echo &lt;/span&gt;&lt;span&gt;&quot;---&amp;gt; Running Maven&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;mvn clean install &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;B &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;DskipTests&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;target_dir&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;target&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; jar_file &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; $&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;find &lt;/span&gt;&lt;span&gt;&quot;$target_dir&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;maxdepth &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;&quot;*.jar&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;type f&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  cat &lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;${layers_dir}/launch.toml&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span&gt;EOL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt;processes&lt;/span&gt;&lt;span&gt;]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;type &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;web&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;command &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;java -jar ${jar_file}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;EOL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;done&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;buildpack.toml&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;api &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;0.5&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;buildpack&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;examples/maven&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  version &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;0.0.1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt;stacks&lt;/span&gt;&lt;span&gt;]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;com.atbug.buildpacks.example.stacks.maven&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;创建 stack&lt;/h3&gt;&lt;p&gt;构建 Maven 项目，首选需要 Java 和 Maven 的环境，我们使用 &lt;code&gt;maven:3.5.4-jdk-8-slim&lt;/code&gt; 作为 build image 的 base 镜像。应用的运行时需要 Java 环境即可，因此使用 &lt;code&gt;openjdk:8-jdk-slim&lt;/code&gt;作为 run image 的 base 镜像。&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;stacks&lt;/code&gt; 目录中分别创建 &lt;code&gt;build&lt;/code&gt; 和 &lt;code&gt;run&lt;/code&gt; 两个目录：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;build/Dockerfile&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;FROM maven&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;jdk&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;slim&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ARG cnb_uid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ARG cnb_gid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ARG stack_id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ENV CNB_STACK_ID&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;stack_id&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;LABEL io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;buildpacks&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;stack_id&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ENV CNB_USER_ID&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;cnb_uid&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ENV CNB_GROUP_ID&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;cnb_gid&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# Install packages that we want to make available at both build and run time&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;RUN apt&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; update &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  apt&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; install &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;y xz&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;utils ca&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;certificates &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  rm &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;rf &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;lib&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;apt&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;lists&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# Create user and group&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;RUN groupadd cnb &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;gid $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;cnb_gid&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  useradd &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;uid $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;cnb_uid&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;gid $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;cnb_gid&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;m &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;s &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;bin&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;bash cnb&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;USER $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;CNB_USER_ID&lt;/span&gt;&lt;span&gt;}:&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;CNB_GROUP_ID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;run/Dockerfile&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;FROM openjdk&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;jdk&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;slim&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ARG stack_id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ARG cnb_uid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ARG cnb_gid&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;LABEL io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;buildpacks&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;${stack_id}&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;USER $&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;cnb_uid&lt;/span&gt;&lt;span&gt;}:&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;cnb_gid&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;然后使用如下命令构建出两个镜像：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;export&lt;/span&gt;&lt;span&gt; STACK_ID&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;com&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;atbug&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;buildpacks&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;example&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;stacks&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;docker build &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;arg stack_id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;STACK_ID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;t addozhang&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;samples&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;buildpacks&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;latest &lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;docker build &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;arg stack_id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;STACK_ID&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;t addozhang&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;samples&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;buildpacks&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;latest &lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;创建 Builder&lt;/h3&gt;&lt;p&gt;有了 buildpack 和 stack 之后就是创建 Builder 了，首先创建 &lt;code&gt;builder.toml&lt;/code&gt; 文件，并添加如下内容：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;toml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt;buildpacks&lt;/span&gt;&lt;span&gt;]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;examples/maven&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;version &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;0.0.1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;uri &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;../buildpacks/buildpack-maven&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[[&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;examples/maven&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;version &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;0.0.1&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;stack&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;com.atbug.buildpacks.example.stacks.maven&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;addozhang/samples-buildpacks-stack-run:latest&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;addozhang/samples-buildpacks-stack-build:latest&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;然后执行命令，&lt;strong&gt;注意这里我们使用了 &lt;code&gt;--pull-policy if-not-present&lt;/code&gt; 参数，就不需要将 stack 的两个镜像推送到镜像仓库了&lt;/strong&gt;：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;pack builder create example&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;builder&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;latest &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;config &lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;builder&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toml &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;pull&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;policy &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;present&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;测试&lt;/h3&gt;&lt;p&gt;有了 builder 之后，我们就可以使用创建好的 builder 来构建镜像了。&lt;/p&gt;&lt;p&gt;这里同样加上了 &lt;code&gt;--pull-policy if-not-present&lt;/code&gt; 参数来使用本地的 builder 镜像：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# 目录 buildpacks-sample  与 tekton-test 同级，并在 buildpacks-sample  中执行如下命令&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;pack build addozhang&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;test &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;builder example&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;builder&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;latest &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;pull&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;policy &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;present &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;path &lt;/span&gt;&lt;span&gt;../&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;如果看到类似如下内容，就说明镜像构建成功了（第一次构建镜像由于需要下载 maven 依赖耗时可能会比较久，后续就会很快，可以执行两次验证下）：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;===&amp;gt;&lt;/span&gt;&lt;span&gt; EXPORTING&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Adding&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; app layer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Reusing&lt;/span&gt;&lt;span&gt; layer &lt;/span&gt;&lt;span&gt;&#x27;launcher&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Reusing&lt;/span&gt;&lt;span&gt; layer &lt;/span&gt;&lt;span&gt;&#x27;config&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Reusing&lt;/span&gt;&lt;span&gt; layer &lt;/span&gt;&lt;span&gt;&#x27;process-types&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Adding&lt;/span&gt;&lt;span&gt; label &lt;/span&gt;&lt;span&gt;&#x27;io.buildpacks.lifecycle.metadata&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Adding&lt;/span&gt;&lt;span&gt; label &lt;/span&gt;&lt;span&gt;&#x27;io.buildpacks.build.metadata&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Adding&lt;/span&gt;&lt;span&gt; label &lt;/span&gt;&lt;span&gt;&#x27;io.buildpacks.project.metadata&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Setting&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; process type &lt;/span&gt;&lt;span&gt;&#x27;web&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Saving&lt;/span&gt;&lt;span&gt; addozhang&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Images&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0d5ac1158bc0&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;       addozhang&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;exporter&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Adding&lt;/span&gt;&lt;span&gt; cache layer &lt;/span&gt;&lt;span&gt;&#x27;examples/maven:maven_m2&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Successfully&lt;/span&gt;&lt;span&gt; built image addozhang&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动容器，会看到 spring boot 应用正常启动：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;docker run &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;rm addozhang&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tekton&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;latest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;   ____          _            __ _ _&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;\\ &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt; ___&lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;_ __ _ _&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;_ __  __ _ \ \ \ \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;\___ &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;_ | &#x27;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&#x27;&lt;/span&gt;&lt;span&gt;_ \/ _&lt;/span&gt;&lt;span&gt;`&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; \ \ \ \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; \\&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;  ___&lt;/span&gt;&lt;span&gt;)|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;)|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&#x27;  |____| .__|_| |_|_| |_\__, | / / / /&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;=========|&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;|==============|&lt;/span&gt;&lt;span&gt;___&lt;/span&gt;&lt;span&gt;/=/&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Boot&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;RELEASE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;其实现在有很多开源的 buildpack 可以用，没有特定定制的情况下无需自己手动编写。比如下面的几个大厂开源并维护的 Buildpacks：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Heroku Buildpacks&lt;sup&gt;[9]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Google Buildpacks&lt;sup&gt;[10]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Paketo&lt;sup&gt;[11]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上面几个 buildpacks 库内容比较全面，实现上会有些许不同。比如 Heroku 的执行阶段使用 Shell 脚本，而 Paketo 使用 Golang。后者的扩展性较强，由 Cloud Foundry 基金会支持，并拥有由 VMware 赞助的全职核心开发团队。这些小型模块化的 buildpack，可以通过组合扩展使用不同的场景。&lt;/p&gt;&lt;p&gt;当然还是那句话，自己上手写一个会更容易理解 Buildpack 的工作方式。&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 测试 Tekton 的 Java 项目: &lt;em&gt;https://github.com/addozhang/tekton-test&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; BuildPack: &lt;em&gt;https://buildpacks.io/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 生命周期: &lt;em&gt;https://buildpacks.io/docs/concepts/components/lifecycle/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; Heroku Buildpacks: &lt;em&gt;https://github.com/heroku/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; Google Buildpacks: &lt;em&gt;https://github.com/GoogleCloudPlatform/buildpacks&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; Paketo: &lt;em&gt;https://github.com/paketo-buildpacks&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; 测试 Tekton 的 Java 项目: &lt;em&gt;https://github.com/addozhang/tekton-test&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[8]&lt;/code&gt; Github: &lt;em&gt;https://github.com/addozhang/buildpacks-sample&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[9]&lt;/code&gt; Heroku Buildpacks: &lt;em&gt;https://github.com/heroku/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[10]&lt;/code&gt; Google Buildpacks: &lt;em&gt;https://github.com/GoogleCloudPlatform/buildpacks&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[11]&lt;/code&gt; Paketo: &lt;em&gt;https://github.com/paketo-buildpacks&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>