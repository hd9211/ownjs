<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2dbe2bbce25d2e272509fee0f92abdc7</guid>
<title>我用 Python 找出了删除我微信的所有人并将他们自动化删除了</title>
<link>https://toutiao.io/k/km6796s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知你是否遇到过在微信上给通讯录中的某个人发消息，结果出现了这一幕：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5393442622950819&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUEofIiaJOoFnzPxNQISYMianWC7URLglsC5kG8ww0zRGSpiaSJMu0fDCag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时一直认为自己的心里素质过硬，不过遇到这种情况 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUmegARtxyFceBDF1IybLjfuMia8jQQAicK76QBwSU15iaFe8A0ib4DThvQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我缓了半个钟头（半分钟&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUA5AXj0kKLmjia6S76ez1XDOCd3hC6rfG5lFKcGGmo42FQ19uc9UaFVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;）之后，缓缓拿出了手机，打开微信，找到通讯录中的 &lt;code&gt;ABC&lt;/code&gt;，默默地按下了删除按钮，此刻的我心如止水 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUEz2cg23CJj4kuFTLiaVl68QVrXLgpZzWGqRs1y5icHYFGjO0NfSzDXQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们回到正题，为了避免再次出现上述情况，我决定把微信通讯录中删除了自己的人全部找出来并且删除，之前我已经在网上了解到检查自己的微信是否被删比较好的方式就是转账，通过转账我们可以实现无痕检测。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUmJP38Ax2oy5VXhVvgWHoeo23gsDd2DC7XrIP3ibicQEzxmaQcyHhN3og/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们通过两张图片直观的看一下微信被删前后给别人转账的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.231696014828545&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUWWUteBlBtP9qt6IzaicsrCQBjpia279uZtOcRiasGlk7ttGJFuZ9dNRZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4308263695450325&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUyicAh82FR82iaqDgGXwcXJzpyH2DbasUagtuDuYibSORFNfILNccNYRvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在已经知道了检测方式，正在我准备挨个检测时，无意识的滑动了微信通讯录列表，100、200 ... 500 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUVTtnU04L7DEGLeOQ6GLCr6fQLTTKFI9Zrow84rbTjnsBd7TonWnnSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我去！什么时候加了这么多人，滑动列表的同时我顺势扫了一眼微信名字：A卖保险、B办理信用卡、C游泳健身、D卖保健品 ... 此刻我知道了微信通讯录中有这么多人的玄机，但是有个问题，这么多人我挨个手动执行转账还不累屎了 ...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果手动执行的方式行不通，那么可以通过编程的方式自动化执行吗？想到这里我陷入了沉思 ...&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUqU2ibC4Bbv2tWmTBRe603cFjEjUQ1hLlHLD7qSxvQpEViczZicNjfFqvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然我脑中闪了一下（不是抽筋哈&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUA5AXj0kKLmjia6S76ez1XDOCd3hC6rfG5lFKcGGmo42FQ19uc9UaFVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;），思绪渐明，前几天我不是写了一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;吗？用这个应该就可以实现，编程实现的基本思路如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取微信通讯录列表中每个人的名字（备注）并记录，这个是不会有重复的，因为即使在之前加好友时有重复的，自己也会在备注时给改了&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;遍历获取到的通讯录列表，分别对每一个人执行转账操作，如果检测到是删除自己的人就对其执行删除操作，如果检测到不是删除自己的人则继续检测下一个人，依次往复循环&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因之前在模拟器上测试 Appium 模拟微信转账可能有点问题，因此本文使用真机实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单介绍一下真机环境，下面一起来看一下相应步骤。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从桌角下取出我的小米5s手机（MIUI10.2、Android8.0.0），擦擦灰尘后用数据线将其连到自己的电脑上&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;手机充了一会电之后开机，打开微信登录自己的微信号&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在手机中依次执行（点击）：设置-&amp;gt;我的设备-&amp;gt;全部参数-&amp;gt;MIUI版本（多次点击，开启开发者模式）-&amp;gt;返回设置列表-&amp;gt;更多设置-&amp;gt;开发者选项-&amp;gt;开启开发者选项并分别开启：USB调试、USB安装、USB调试（安全设置）选项，如图所示：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.32&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUeBJd34FS9A2Ld3nASuuEucwRm4EOLpRG66qyiaMrODu4xIG7v2J3ibuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1075&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;此时手机上会弹出USB的用途弹框，我们选择传输文件（MTP）即可，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7477656405163853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUoyfUXCwQtW63uNHuMibBAicv2pllDZEk7b5b023b89uVCrcGH3OOvpLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1007&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在电脑 CMD 中执行 &lt;code&gt;adb devices&lt;/code&gt; 命令，看是否能找到自己的手机，比如下图所示就是成功的结果了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.32605042016806723&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUSpJibeO78zk01dzoJCLibbX8DcDCQWFwSxsP8bV1PV5aPNjT02TKqcvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在上面步骤中你可能出现找不到手机的情况，通常这种情况是驱动问题，这里介绍一种简单的处理方式：下载一个驱动精灵，安装启动之后点击驱动管理，之后安装相应驱动即可解决，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUicMaWJkWvkdN86ODfoTgVrviao9Xdz6ibib86iaDnHsQPsM0zylLKGNvsdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.396875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoUdM7P4ibtpw3CsMGw4LheUB1HibicYTzhoZYELcS5zVaJbDbGL6wVkbCV7uNLp6lPt9ibVrmXGRU4uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的一系列操作，我们已经处理好了真机环境了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Appium 的环境本文就不说了，如果不清楚的话，可以看一下：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们开始手动敲代码，如果对 Appium 基本代码操作不了解的话，还是可以去看一下我之前写的这篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247495223&amp;amp;idx=1&amp;amp;sn=3d81982be5f081daa0dab83be7167dc2&amp;amp;chksm=fd3b1c8bca4c959d4a4230bdf4a909905b0516ba64a56d5c2ff2072bbd3760fef2b1893956f0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Python + Appium 自动化操作微信入门&lt;/strong&gt;&lt;/a&gt;，真机与模拟器的使用基本一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下相应参数配置，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;desired_caps = {&lt;br/&gt;    &lt;span&gt;&quot;platformName&quot;&lt;/span&gt;: &lt;span&gt;&quot;Android&quot;&lt;/span&gt;, &lt;span&gt;# 系统&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;platformVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;8.0.0&quot;&lt;/span&gt;, &lt;span&gt;# 系统本号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;deviceName&quot;&lt;/span&gt;: &lt;span&gt;&quot;m5s&quot;&lt;/span&gt;, &lt;span&gt;# 设备名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;appPackage&quot;&lt;/span&gt;: &lt;span&gt;&quot;com.tencent.mm&quot;&lt;/span&gt;, &lt;span&gt;# 包名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;appActivity&quot;&lt;/span&gt;: &lt;span&gt;&quot;.ui.LauncherUI&quot;&lt;/span&gt;, &lt;span&gt;# app 启动时主 Activity&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;unicodeKeyboard&#x27;&lt;/span&gt;: &lt;span&gt;True&lt;/span&gt;, &lt;span&gt;# 使用自带输入法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;noReset&#x27;&lt;/span&gt;: &lt;span&gt;True&lt;/span&gt; &lt;span&gt;# 保留 session 信息，可以避免重新登录&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看一下如何获取微信通讯录名字（备注）列表？代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 获取通讯录列表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_address_list&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn_&#x27;&lt;/span&gt;)[&lt;span&gt;1&lt;/span&gt;].click()&lt;br/&gt;    &lt;span&gt;# 获取昵称（备注）&lt;/span&gt;&lt;br/&gt;    address_list = driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/dy5&#x27;&lt;/span&gt;)&lt;br/&gt;    remarks = []&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; address &lt;span&gt;in&lt;/span&gt; address_list:&lt;br/&gt;        remark = address.get_attribute(&lt;span&gt;&quot;content-desc&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 排除自己和微信官方号&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; remark != &lt;span&gt;&quot;自己的微信名&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;&quot;微信&quot;&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; remark:&lt;br/&gt;            remarks.append(remark)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; remarks&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取到了微信通讯录列表之后，我们就可以对其进行遍历检测了，下面看一下如何实现检测自己的微信是否被删，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 判断是否被删&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;is_delete&lt;/span&gt;&lt;span&gt;(remark, count)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; count == &lt;span&gt;&quot;1&quot;&lt;/span&gt;:&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击微信搜索框&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn1&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(remark)&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    print(&lt;span&gt;&#x27;点击搜索到的好友&#x27;&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/tm&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;# 转账&lt;/span&gt;&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/aks&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_elements_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/pa&#x27;&lt;/span&gt;)[&lt;span&gt;5&lt;/span&gt;].click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cx_&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cxi&#x27;&lt;/span&gt;).click()&lt;br/&gt;    time.sleep(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;# 判断是否被删&lt;/span&gt;&lt;br/&gt;    is_exist = is_element_exist(&lt;span&gt;&#x27;com.tencent.mm:id/jh&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; is_exist &lt;span&gt;is&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; remark&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述方法中，如果检测到是删了自己微信的人就返回那个人的微信名（备注），然后我们将这些人记录起来；如果检测到不是删除自己微信的人就返回 False。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述过程执行完了之后，我们就可以获取到所有删了自己微信的人了，接下来我们就可以将这些人都从自己微信通讯录中删除了，删除实现的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 删除把自己删除的人&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_person&lt;/span&gt;&lt;span&gt;(nicks)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; inx, val &lt;span&gt;in&lt;/span&gt; enumerate(nicks):&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; inx == &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(val)&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;            time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;            print(&lt;span&gt;&#x27;点击微信搜索框&#x27;&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cn1&#x27;&lt;/span&gt;).click()&lt;br/&gt;            print(&lt;span&gt;&#x27;在搜索框输入搜索信息&#x27;&lt;/span&gt;)&lt;br/&gt;            time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;            driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/bhn&#x27;&lt;/span&gt;).send_keys(val)&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击搜索到的人&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/tm&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击聊天对话框右上角...&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cj&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击头像&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/f3y&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击联系人右上角...&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/cj&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击删除按钮&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/g6f&#x27;&lt;/span&gt;).click()&lt;br/&gt;        time.sleep(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;        print(&lt;span&gt;&#x27;点击弹出框中的删除&#x27;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_id(&lt;span&gt;&#x27;com.tencent.mm:id/doz&#x27;&lt;/span&gt;).click()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们就利用 Python + Appium 实现了自动化找出微信中删除自己的人并将其删除的工作了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码在公号 &lt;span&gt;Python小二&lt;/span&gt; 后台回复 &lt;span&gt;201108&lt;/span&gt; 获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原创不易，如果觉得有一些帮助，希望大家给个在看或转发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>574bc471af56d4ad463856ccd92b64bb</guid>
<title>Go 设计模式（二十四）：总结</title>
<link>https://toutiao.io/k/ch4mr21</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot; id=&quot;post-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;原本预计是在十月底更新完毕这个系列，到今天是 11-05，晚了几天，不过也还好，这是第一次这么密集的去更新博客上的内容，更多的是以笔记的形式来呈现，加上这篇一共 24 篇文章差不多两个半月的时间，平均每周输出两篇，感觉还是不错。后续可能会视情况不定期的更新一些实战内容，也有可能没有。接下来下一个系列应该是数据结构与算法，包含对 Go 中一些底层数据和标准库包的学习，例如 slice, sort 等等。&lt;/p&gt;&lt;p&gt;话说回来，回头再看学习设计模式我们究竟需要学习一些什么？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;写 Go 需要使用到设计模式么？&lt;ul&gt;&lt;li&gt;需要，但是切记请勿使用其他语言的方式来写 Go&lt;/li&gt;&lt;li&gt;如果看过之前的一些文章，就会发现类似 JAVA 的这些面向对象语言中的某些设计模式的写法在 Go 中会十分的别扭&lt;/li&gt;&lt;li&gt;但是 Go 不需要设计模式么？不是的，设计模式的思想是想通的，并且我们一直都在使用，例如我们常见的对象创建方式 &lt;code&gt;NewXXX&lt;/code&gt; 这其实就是一个简单工厂&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;设计模式学习的重点是什么？&lt;ul&gt;&lt;li&gt;设计原则，以及设计模式的使用场景和优缺点，实现相对来说还没有那么重要&lt;/li&gt;&lt;li&gt;如果是常见的设计模式是武术招式，那么设计原则就是内功心法，没有内功心法那么招式套路也就是花架子&lt;/li&gt;&lt;li&gt;熟练掌握不同设计模式的使用场景可以帮助我们学会见招拆招，灵活应用而不是只会套路&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;最后设计模式不是银弹，不要拿着 🔨 就觉得哪里都像是钉子，不要过早优化，持续重构才是正道&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;/&gt;设计原则&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;同时这也是 Code Review 的重要标准之一&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1604555465270-6b839dae-3cc4-43e8-bcad-b46ee314f0f7.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;/&gt;设计模式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1604555469082-5a1887e1-5640-4895-a018-8541ba78139e.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;Go-设计模式&quot;&gt;&lt;a href=&quot;#Go-设计模式&quot; class=&quot;headerlink&quot; title=&quot;Go 设计模式&quot;/&gt;Go 设计模式&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;单例模式包含饿汉式和懒汉式两种实现&lt;/li&gt;&lt;li&gt;工厂模式包含简单工厂、工厂方法、抽象工厂、DI 容器&lt;/li&gt;&lt;li&gt;代理模式包含静态代理、动态代理（采用 go generate 模拟）&lt;/li&gt;&lt;li&gt;观察者模式包含观察者模式、eventbus&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7aa41646c166b0f7c5ef5981733e54c2</guid>
<title>深入理解 Java 线程池</title>
<link>https://toutiao.io/k/dwlr0t4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;在开发过程中，合理地使用线程池能够带来至少以下几个好处。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;：当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须了解其实现原理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码解耦&lt;/strong&gt;：比如生产者消费者模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;线程池实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;当提交一个新任务到线程池时，线程池的处理流程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤也需要获取全局锁）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果创建新线程将使当前运行的线程数超出maximumPoolSize，该任务将被拒绝，并调用相应的拒绝策略来处理（RejectedExecutionHandler.rejectedExecution()方法，线程池默认的饱和策略是AbortPolicy，也就是抛异常）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;线程池任务 拒绝策略包括 &lt;strong&gt;抛异常&lt;/strong&gt;、&lt;strong&gt;直接丢弃&lt;/strong&gt;、&lt;strong&gt;丢弃队列中最老的任务&lt;/strong&gt;、&lt;strong&gt;将任务分发给调用线程处理&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;线程池的创建&lt;/strong&gt;：通过ThreadPoolExecutor来创建一个线程池。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, timeUnit, runnableTaskQueue, handler);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;创建一个线程池时需要输入以下几个参数：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到线程池的线程数等于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;- ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PriorityBlockingQueue：一个具有优先级的无界阻塞队列。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;线程的状态&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在HotSpot VM线程模型中，Java线程被一对一映射到本地系统线程，Java线程启动时会创建一个本地系统线程；当Java线程终止时，这个本地系统线程也会被回收。操作系统调度所有线程并把它们分配给可用的CPU。&lt;/p&gt;&lt;p&gt;thread运行周期中，有以下6种状态，在 java.lang.Thread.State 中有详细定义和说明：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Thread类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; State {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 刚创建尚未运行&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    NEW,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 可运行状态，该状态表示正在JVM中处于运行状态，不过有可能是在等待其他资源，比如CPU时间片，IO等待&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    RUNNABLE,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 阻塞状态表示等待monitor锁（阻塞在等待monitor锁或者在调用Object.wait方法后重新进入synchronized块时阻塞）&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    BLOCKED,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 等待状态，发生在调用Object.wait、Thread.join (with no timeout)、LockSupport.park&lt;br/&gt;     * 表示当前线程在等待另一个线程执行某种动作，比如Object.notify()、Object.notifyAll()，Thread.join表示等待线程执行完成&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 超时等待，发生在调用Thread.sleep、Object.wait、Thread.join (in timeout)、LockSupport.parkNanos、LockSupport.parkUntil&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TIMED_WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     *线程已执行完成，终止状态&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TERMINATED;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;线程池操作&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;向线程池提交任务，可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;threadsPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，通过future的get()方法来获取返回值，future的get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务还没有执行完。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Future&amp;lt;Object&amp;gt; future = executor.submit(harReturnValuetask);&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    Object s = future.get();&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;    &lt;span&gt;// 处理中断异常&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;    &lt;span&gt;// 处理无法执行任务异常&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 关闭线程池&lt;/span&gt;&lt;br/&gt;    executor.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;合理配置线程池&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;要想合理配置线程池，必须先分析任务的特点，可以从以下几个角度分析：&lt;/p&gt;&lt;p&gt;性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能少的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置多一点线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。&lt;/p&gt;&lt;p&gt;优先级不同的任务可以使用优先级队列&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;来处理。它可以让优先级高的任务先执行。执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;线程池中线程数量未达到coreSize时，这些线程处于什么状态？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这些线程处于RUNNING或者WAITING，RUNNING表示线程处于运行当中，WAITING表示线程阻塞等待在阻塞队列上。当一个task submit给线程池时，如果当前线程池线程数量还未达到coreSize时，会创建线程执行task，否则将任务提交给阻塞队列，然后触发线程执行。（从submit内部调用的代码也可以看出来）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6526548672566371&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMuep0rdzx1icxm1xSShebibnUTtV5vgZuDcGZPI1YGmJ4pRibHzPACoAQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;452&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9209932279909706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMuiaHusXfjPicW0JIqs8xkXp0evETFvalz2o8LAEw4C67LfNA5HXWP78A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，ScheduledThreadPoolExecutor和ThreadPoolExecutor的区别是，ThreadPoolExecutor获取任务时是从BlockingQueue中获取的，而ScheduledThreadPoolExecutor是从DelayedWorkQueue中获取的（注意，DelayedWorkQueue是BlockingQueue的实现类）。&lt;/p&gt;&lt;p&gt;ScheduledThreadPoolExecutor把待调度的任务（ScheduledFutureTask）放到一个DelayQueue中，其中ScheduledFutureTask主要包含3个成员变量：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4896810506566604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMHvAQwOJa0NIatEG7QhsuroP3iaEnEKosbM0QCywCibaK5u60obbsaQCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;533&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;sequenceNumber：任务被添加到ScheduledThreadPoolExecutor中的序号；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;time：任务将要被执行的具体时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;period：任务执行的间隔周期。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中，DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的ScheduledFutureTask进行排序，具体的排序比较算法实现如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.604989604989605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMoBzhvMx0xbu7cXpjyWBXMiaqBRgmib83YVl2NFUic1MrlqhH62Ds6TMzpHric45AGc9DGJCV8JsYZxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;&lt;p&gt;ScheduledFutureTask在DelayQueue中被保存在一个PriorityQueue（基于数组实现的优先队列，类似于堆排序中的优先队列）中，在往数组中添加/移除元素时，会调用siftDown/siftUp来进行元素的重排序，保证元素的优先级顺序。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DelayedWorkQueue&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&amp;lt;&lt;span&gt;Runnable&lt;/span&gt;&amp;gt;&lt;br/&gt;    &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span&gt;Runnable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt;[] queue =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt;[INITIAL_CAPACITY];&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Thread leader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition available = lock.newCondition();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从DelayQueue获取任务的主要逻辑就在take()方法中，首选获取lock，然后获取queue[0]，如果为null则await等待任务的来临，如果非null查看任务是否到期，是的话就执行该任务，否则再次await等待。这里有一个leader变量，用来表示当前进行awaitNanos等待的线程，如果leader非null，表示已经有其他线程在进行awaitNanos等待，自己await等待，否则自己进行awaitNanos等待。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// DelayedWorkQueue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; RunnableScheduledFuture&amp;lt;?&amp;gt; take() &lt;span&gt;throws&lt;/span&gt; InterruptedException {&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;this&lt;/span&gt;.lock;&lt;br/&gt;    lock.lockInterruptibly();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            RunnableScheduledFuture&amp;lt;?&amp;gt; first = queue[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                available.await();&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; delay = first.getDelay(NANOSECONDS);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (delay &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; finishPoll(first);&lt;br/&gt;                first = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// don&#x27;t retain ref while waiting&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (leader != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    available.await();&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    Thread thisThread = Thread.currentThread();&lt;br/&gt;                    leader = thisThread;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        available.awaitNanos(delay);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (leader == thisThread)&lt;br/&gt;                            leader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leader == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; queue[&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            available.signal();&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取到任务之后，就会执行task的run()方法了，即ScheduledFutureTask.run()：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; periodic = isPeriodic();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!canRunInCurrentRunState(periodic))&lt;br/&gt;        cancel(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!periodic)&lt;br/&gt;        ScheduledFutureTask.&lt;span&gt;super&lt;/span&gt;.run();&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ScheduledFutureTask.&lt;span&gt;super&lt;/span&gt;.runAndReset()) {&lt;br/&gt;        setNextRunTime();&lt;br/&gt;        reExecutePeriodic(outerTask);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7185f385817be0ab117714f321551cda</guid>
<title>人生是一个回环：我的十年安全工作总结</title>
<link>https://toutiao.io/k/41asxjm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;span lang=&quot;EN-US&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5462962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kYREiceLybrhgkMKyuu37uUVDzG87Djz0ZOiba8GWhwy50bd2TnMiciaxhDukaC2PLhjia0OiaxawY2oK9JibKtA9F8fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;“大家好！&lt;/span&gt;&lt;span&gt;我是李雪琴……”，自去年起，那个北大毕业的“最土”女生火了。&lt;/span&gt;&lt;span&gt;近期，听到她在脱口秀大会讲她妈妈的“哲学”理论：&lt;/span&gt;&lt;span&gt;宇宙也有终点，终点在人生的起点；&lt;/span&gt;&lt;span&gt;看到她先从“人生的起点”来北京赴学，再回到“人生的起点”，这次又离开起点出来闯荡。&lt;/span&gt;&lt;span&gt;心里颇有感触，在“宇宙终点”之前，显然她的脚步还远没有停止。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;我的人生回环&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;大家好！我是叶猛，我又回到了北京，跟北京说声：“嗨！”。这次我用了自己的真名字。在这个名字之前，我还有一长串的昵称或称呼：梦晔、Monyer、梦之光芒、猛子、小叶、叶队、叶帅、叶师傅、叶支、猛队……，这些称呼伴随着我前十年工作生涯的各个阶段。梦晔是我的笔名，是我姓名的倒序，在那个年少轻狂且心中“文意纵横”的时代，看到老舍把自己的姓拆开做字，便有学有样起了这个笔名。Monyer是从梦晔的发音造出来的英文昵称，从高中起一直用到现在。梦之光芒是从梦晔拓展出来的中文昵称，因为“晔”就是光芒的意思。这个中文昵称先是从05年起作为《黑客防线》的投稿笔名，后是作为百度空间的博客名一直到空间关闭。猛子这个昵称主要是刚毕业后在B公司工作，大哥大姐们的亲切称呼；小叶是后来特招到某省公安厅后，领导们的“爱称”；叶队是在公安厅任某科室支队长后，兄弟单位及合作伙伴的称呼；叶师傅、叶帅是省厅同事间的敬称和戏称；叶支、猛队是来到Q公司后，组建起国内顶级实战攻防红队，大家的敬称。关于我的称呼曾有过很有意思的事情，曾有不少人认识网上的Monyer还加了QQ好友，也认识现实中的叶队，但却不知道这是一个人。所以今天我用我的真名字为自己代言，也算是第一个回环吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;听到宇宙的终点是人生的起点，我不禁莞尔，因为我也感觉人生是一个回环。称谓上的回环暂且不论，最近十年我又进行着另两个回环：一是从网络安全的甲方到监管方，再到乙方，又回到了甲方的回环；二是从沈阳到北京，到回沈阳，又回到北京的回环。我爱人说：你看你，兜兜转转，又转回去了。我说不然，虽然又转回去了，但能力变了、眼界变了、境遇也变了。如果用一个恰当的比较，这不是一个简单的循环，而是一个如同莫比乌斯带般的回环，虽然转了整整一圈，但已经站在了环的另外一面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近在和不少老板聊天时，都谈到了我的网络安全从业经历，也因此有了更多的感触。回顾是为了沉淀和畅想，总结是为了把握未来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的职业生涯从不同角度来看，算是既简单又惊奇。简单的原因是十余年工作经历全部是跟网络安全相关的，并且一共也只有3个东家。惊奇的原因则是恰好这3个东家覆盖了整个安全届的角色划分：甲方、监管和乙方，而且朋友同事听到我离开消息后，是一个比一个惊奇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？离开北京大公司回辽宁了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？公安厅支队长都不干了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么？要抛家弃子回北京了？……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0462016881386051&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kYREiceLybrhgkMKyuu37uUVDzG87Djz0OH4icfUY9ibxSfXCdVCByKL80PA3hYJAp54q5L4AVCmX5E49BRxvp75g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2251&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（当别人告诉我，我的离职上了热门讨论，让大家震惊了一下，我还有些忍俊不禁。）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;甲方时代：安全是为业务服务的&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我甲方的工作经验，那就是：“安全是为业务服务的”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实去B公司是有着偶然因素和侥幸成分的。在去之前A公司曾邀请我去面试，不过去跟导员请假没有申请下来，就作罢了。等B公司找到我时，恰逢暑假，遂商定好只做暑期实习生。不过实习期间，所在团队给我很大触动，那是一个高效、团结、热情、专业的团队，值得我继续实习下去。于是我跟学院做了申请，整个大四都是在B公司度过的，顺利拿到Offer，毕业后的两年也一直在B公司。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我所在部门是当时处于创业状态下的电商团队，职位最开始是渗透测试工程师，主要是代码和业务层面的安全工作，前期一直是我一个人。那时敏捷开发还在尝试阶段，DevOps更是影儿都没有。系统还是版本制，上线时需要在半夜进行，停服维护。期间比较有意思的事儿是协助架构师做MVC 2.0框架设计，通过框架和系统架构天然防御常见漏洞，当然现在很多开源的MVC框架也都内置了安全防护功能。后来11年部门拆分，便到了基础平台架构部，负责公司产品线的安全测试、代码审计以及安全内训工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在工作中也慢慢发现，随着安全从业者能力的提升，在掌握更多安全知识和理念的过程中，很容易陷入脱离业务过度防御的误区。有时安全人员会有种系统到处都是漏洞无从下手的感觉，甚至认为系统功能的本身就是漏洞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Feature还是Bug这是一个问题！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这有点像我之前在知乎上回答的一个问题：某公司的安全人员认为手机验证码一定要是6位以上的，产品经理认为从易用性角度上一定要是4位的，于是就闹了很多矛盾。然而4位的验证码就一定不安全么？就没有更好的解决办法么？想当年支付密码必须要数字+大小写字母+特殊字符，要大于10位以上。而现如今，几乎所有支付应用的密码全部是6位纯数字，那么安全性是提升了，还是下降了呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全是为业务服务的。脱离了业务本身去谈安全是没意义的，过度强调安全而忽视了业务可用性也是无稽之谈。不考虑系统架构和网络运行情况，生搬硬套各种先进安全理念和安全框架，会浪费大量资源又达不到预期效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，这并不是说安全要无限制地为业务让路，而是说安全人员要时刻思考如何在尽量保证业务的前提下，去维护系统安全，要考虑安全与业务共生的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;皮之不存，毛将焉附？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;监管时代：技术是达成目标的一种手段&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我在网络监管单位的工作经验，那么就是：“技术是达成目标的一种手段”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当时一些客观原因和机缘巧合，使我于11年底通过公务员特殊人才招募通道来到某省公安厅网安总队工作，一直到18年初离职为止。由于敏感性原因，工作内容暂且不谈。但这些年个人的成长和进步还是蛮大的，最重要的是在做人上有了长足的提高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用技术去辅助公安工作，可以起到四两拨千斤的效果。我举个的例子：譬如某舆情事件，领导的想法是通过统计分析得出关键线索。但统计分析的前提是数据的获取、处理、存储、分析和展示。随着事件的持续性发展，如果纯人工去做，那么投入成本会是时间线性增加的，甚至会出现人工分析赶不上事态发展速度的情况。而通过程序去做，则可以在更短的时间内获得更好的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是不是说技术就永远比传统手段更好用呢？也不尽然。从另外一个例子来看：如果拿到了犯罪嫌疑人的手机，还在想着用技术手段去破解开机密码，就没有那些公安老哥们直接从嫌疑人口中撬出密码来的方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然我只举两个很简单也不那么敏感的例子，实际上在这近7年的工作中，上百场战役和案件的侦办给我留下很深刻的认知：就是“技术是达成目标的一种手段”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网安的成功破案并不是在我们这种技术人员招进来后才有的，只不过我们给了网安多一种选择，有时则是一种更短的路径。而在工作中，包括体制内、甲方和乙方，也不应该总从纯技术角度去考虑问题，有时换一种思路会发现有更快更容易的解决途径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;乙方时代：打铁必须自身硬&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果用一句话来总结我在乙方的工作经验，那么就是：“打铁必须自身硬”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Q公司是目前网络安全toB领域的佼佼者。18年初我来Q公司时，它还没有自己的专业化红队。一些实战攻防演习任务的承接还要靠抽调各地渗透测试人员临时组队，人员战斗力以及演习排名均得不到保障。入职时，我在主管副总裁的引荐下，带着一个题为《专业化渗透团队可行性研究分析》的团队规划PPT赶赴北京见到了董事长。里面讲的就是要建立一支高精尖、能打胜仗的专业化渗透团队。汇报比较顺利，董事长最终同意给我5-6个HC来建设这样一支团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为这个团队主要是模拟黑客APT手段来开展工作业务，因此我从APT“高级持续性威胁”这个名词中借用了“高级”二字，从零开始组建了“高级攻防部”网络攻防实战团队。在团队建设过程中，我借鉴了体制内团队建设管理经验，以“队”为建制来组建红队，把每支红队的管理者称为“队长”，队内员工称之为“队员”，红队按区域做命名，譬如“成都队”、“南京队”、“沈阳队”、“杭州队”等。在接下来的两年中，队伍一直在向着最高效、最专业化的道路迈进。建设过程含辛茹苦暂且不谈，现如今高级攻防部已经是一支横跨全国三个大区，人数超过*0人的专业级红队，攻击队数量也从0增长到*支。每次工作任务都以攻击队为单位来开展，类似于特种部队中的作战单元。一支攻击队由*-*个人构成，以攻击队队长为技术及领导核心，团队成员各具打点、社工、内网等不同方向本领，大家协同作战。正如任正非所言：要把能力建立在组织上。这样的团队组成模式对于实战攻防演习及红队评估项目来说是最有战斗力的。我统计过去年（2019年）的全年实战演习项目，我们排名第一次数是76%，排名第二是24%（第三及以后没有），综合作战能力已经远远将友商团队甩到了后面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在部门的成长和管理过程当中，技术是我们的饭碗、能力是我们的本钱、排名是我们的荣誉。团队成员在技术能力、带队能力以及声望名气上均日新月异，长足提高。我们没有设立任何类似于996的工作制度，也不树立任何“舍己为人”的典型，但在项目中所有人都勇于吃苦耐劳、加班熬夜、奋战到底，因为大家都知道“打铁必须自身硬”，自身硬就是本钱，就是底气，就是话语权，是谁都拿不走的资本。前些日子，团队中某个毕业2年带队1年多的攻击队队长被某大型合资公司以高年薪挖走了，去做安全防护方面的负责人，还给配车。在不舍的同时，我也感到十分欣慰，有着沉甸甸的满足感，感觉团队没白带，人没看错也没白培养。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多管理者怕人员流动，其实正常的人员流动对于团队和个人都有着好处。对于团队所有人员，我一直在宣贯着我称之为“技术人员发展四阶段”的成长路线：技术输出、经验输出、思路输出和决策输出（这个上一篇公众号也有详细地说明）。我希望从我团队走出的技术人员能成为外面的技术Leader，技术Leader能成为外面的技术经理，技术经理能成为技术总监。在日常的团队管理中，我也会尽量为大家提供能够向下一阶段发展的舞台和平台，给大家锻炼成长的机会。我认为这样的团队氛围才是健康的，对于团队成员来说才是负责任的，这也是自身硬的表现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;坚守梦想，持续奋斗&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;最近“刘备”那段“接着奏乐，接着舞”火了，然而在这个梗之前“刘备”说了一句话：“我打了一辈子仗，就不能享受享受吗？”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以享受吗？当然可以！然而梦想达成了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于刘备来说，没有！对于我来说，也没有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么就远没有到可以享受的时候。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在机关单位后期的安逸并不是我想要的。很多人打破脑袋想要进机关，捧着铁饭碗“混机关”。但对我来说混的不是机关，混的是自己。铁饭碗不应该是某个单位，应该是自己的能力和本事。不能靠“混”的施舍，因为混着混着就到达“宇宙的终点”了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在乙方团队建成后的功成名就也不是我期望的状态。临走前有个大哥劝我说：如今团队已经建起来了，最难的时候都过去了，接下来可以养老了，只要大差不差干一干，可以活得比很多人都好。他说的都是真心话，我也都想到。但我还有追求，还想发展，还想做更多，还想做得更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如最近这个段子：“看到74岁与77岁的两个老人为了一份工作还争吵这么激烈，你的人生还有什么借口不努力呢？”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我的人生又经历了这一次回环：我又从乙方回到了甲方，我又从沈阳回到了北京。虽然岗位在变，城市在变，但奋斗的心没变。在接下来工作中，持续奋斗还是会贯穿我工作的始终。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仅以此文作为第一个十年工作的总结，也作为接下来工作的自勉吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感谢爱人的理解，朋友的支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也感谢屏幕前您的传阅，谢谢！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>