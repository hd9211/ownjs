<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fc28a115e21d45b51c9845072a45de6b</guid>
<title>Python机器学习：适合新手的8个项目</title>
<link>https://toutiao.io/k/dns1z81</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再多的理论也不能代替动手实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;教科书和课程会让你误以为精通，因为材料就在你面前。但当你尝试去应用它时，可能会发现它比看起来更难。而「项目」可帮助你快速提高应用的 ML 技能，同时让你有机会探索有趣的主题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，你可以将项目添加到你的投资组合中，从而更轻松地找到工作，找到很酷的职业机会，甚至协商更高的薪水。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这篇文章中，我们将&lt;span&gt;&lt;strong&gt;为初学者介绍 8 个有趣的机器学习项目。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;你&lt;/span&gt;可以在一个周末完成其中的任何一个，或者如果你很喜欢它们，可以将它扩展为更长的项目。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;1、机器学习角斗士&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们亲切地称其为「机器学习角斗士」，但它并不新鲜。这是围绕机器学习建立 实用 直觉的最快方法之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目标是&lt;strong&gt;采用开箱即用&lt;/strong&gt;的模型并将其应用于不同的数据集。这个项目很棒有 3 个主要原因：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，你将建立模型与问题拟合的直觉。哪些模型对缺失数据具有鲁棒性？哪些模型可以很好地处理分类特征？是的，你可以翻阅教科书来寻找答案，但是通过实际操作您会学得更好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，这个项目将教你快速制作原型的宝贵技能。在现实世界中，如果不简单地尝试它们，通常很难知道哪种模型表现最好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，本练习可以帮助你掌握模型构建的&lt;strong&gt;工作流程&lt;/strong&gt;。例如，你将开始练习……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;导入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;清理数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将其拆分为训练/测试或交叉验证集&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特征工程&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为你将使用开箱即用的模型，你将有机会专注于磨练这些关键步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;查看 sklearn (Python) 或 caret (R) 文档页面以获取说明。你应该练习&lt;strong&gt;回归、 分类和聚类算法。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;教程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• Python: sklearn&lt;/strong&gt;  – sklearn包 的官方教程&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 使用 Scikit-Learn 预测葡萄酒质量&lt;/strong&gt;——训练机器学习模型的分步教程&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• R: caret&lt;/strong&gt;  – 由 caret 包的作者提供的网络研讨会&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• UCI 机器学习存储库&lt;/strong&gt; ——350 多个可搜索的数据集，涵盖几乎所有主题。您一定会找到您感兴趣的数据集。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• Kaggle 数据集&lt;/strong&gt;——Kaggle 社区上传的 100 多个数据集。这里有一些非常有趣的数据集，包括 PokemonGo 产卵地点和圣地亚哥的墨西哥卷饼。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• data.gov&lt;/strong&gt; ——美国政府发布的开放数据集。如果您对社会科学感兴趣，可以去看看。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、玩钱球&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在《点球成金》一书中 ，奥克兰 A 队通过分析球员球探彻底改变了棒球运动。他们建立了一支有竞争力的球队，而只花费了洋基队等大型市场球队支付薪水的 1/3。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，如果你还没有读过这本书，你应该去看看。这是我们的最爱之一！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;幸运的是，体育界有大量数据可供使用。球队、比赛、比分和球员的数据都可以在线跟踪和免费获取。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于初学者来说，有很多有趣的机器学习项目。例如，您可以尝试……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 体育博彩……&lt;/strong&gt;根据每场新比赛前的可用数据预测盒子得分。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 人才球探……&lt;/strong&gt; 使用大学统计数据来预测哪些球员将拥有最好的职业生涯。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 综合管理...... &lt;/strong&gt;根据他们的优势创建球员集群，以建立一个全面的团队。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;体育也是练习&lt;strong&gt;数据可视化&lt;/strong&gt;和&lt;strong&gt;探索性分析&lt;/strong&gt;的绝佳领域。你可以使用这些技能来帮助您决定要在分析中包含哪些类型的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 体育统计数据库 &lt;/strong&gt;——体育统计和历史数据，涵盖了许多职业运动和一些大学运动。干净的界面使网页抓取更容易。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• Sports Reference &lt;/strong&gt; – 另一个体育统计数据库。界面更杂乱，但可以将单个表格导出为 CSV 文件。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• cricsheet.org &lt;/strong&gt;– 国际和 IPL 板球比赛的逐球数据。提供 IPL 和 T20 国际比赛的 CSV 文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、预测股票价格&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于任何对金融感兴趣的数据科学家来说，股票市场就像是糖果乐园。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，您有多种类型的数据可供选择。您可以找到价格、基本面、全球宏观经济指标、波动率指数等……不胜枚举。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，数据可能非常精细。您可以轻松获取每家公司按天（甚至按分钟）的时间序列数据，从而让您创造性地思考交易策略。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，金融市场通常具有较短的反馈周期。因此，您可以快速验证您对新数据的预测。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;你可以尝试的一些适合初学者的机器学习项目示例包括……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 量化价值投资……&lt;/strong&gt; 根据公司季度报告的基本面指标预测 6 个月的价格走势。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 预测…… &lt;/strong&gt;在隐含波动率和实际波动率之间的差值上构建时间序列模型，甚至是循环神经网络。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 统计套利…… &lt;/strong&gt;根据价格走势和其他因素找到相似的股票，并寻找价格出现分歧的时期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;明显的免责声明：&lt;/span&gt;建立交易模型来练习机器学习很简单。让他们盈利是极其困难的。这里没有任何财务建议，我们不建议交易真钱。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Python: sklearn for Investing – 将机器学习应用于投资的 YouTube 视频系列。&lt;/p&gt;&lt;p&gt;• R: Quantitative Trading with R – 使用 R 进行量化金融的详细课堂笔记。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Quandl  – 提供免费（和优质）金融和经济数据的数据市场。例如，您可以批量下载3000 多家美国公司的日终股票价格 或美联储的经济数据。&lt;/p&gt;&lt;p&gt;• Quantopian – 量化金融社区，为开发交易算法提供免费平台。包括数据集。&lt;/p&gt;&lt;p&gt;• US Fundamentals Archive – 5000 多家美国公司的 5 年基本面数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;strong&gt;教神经网络阅读笔迹&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;神经网络和深度学习是现代人工智能的两个成功案例。它们在图像识别、自动文本生成甚至自动驾驶汽车方面取得了重大进展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要涉足这个令人兴奋的领域，您应该从可管理的数据集开始。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;MNIST手写数字分类挑战赛&lt;/strong&gt;是经典的切入点。图像数据通常比「平面」关系数据更难处理。MNIST 数据对初学者很友好，并且小到可以放在一台计算机上。&lt;/p&gt;&lt;p&gt;手写识别会挑战你，但它不需要高计算能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，我们建议使用下面教程中的第一章。它将教你如何从头开始构建神经网络，以高精度解决 MNIST 挑战。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 神经网络和深度学习（在线书籍） ——第 1 章介绍了如何在 Python 中从头开始编写神经网络，以对来自 MNIST 的数字进行分类。作者还对神经网络背后的直觉给出了很好的解释。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• MNIST  – MNIST 是美国国家标准与技术研究院收集的两个数据集的修改子集。它包含 70,000 个带标签的手写数字图像。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5、调查安然&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;安然丑闻和倒闭是历史上最大的 企业崩溃之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2000 年，安然是美国最大的能源公司之一。然后，在因欺诈而被揭露后，它在一年内螺旋式下降到破产。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;幸运的是，我们拥有安然电子邮件数据库。它包含 150 名前安然员工（主要是高级管理人员）之间的 50 万封电子邮件。它也是唯一一个真实电子邮件的大型公共数据库，这使得它更有价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上，数据科学家多年来一直在使用这个数据集进行教育和研究。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;您可以尝试的初学者机器学习项目示例包括……&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 异常检测…... &lt;/strong&gt;按小时绘制和接收电子邮件的分布图，并尝试检测导致公共丑闻的异常行为。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 社交网络分析…… &lt;/strong&gt;在员工之间建立网络图模型以找到关键影响者。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 自然语言处理……&lt;/strong&gt;结合电子邮件元数据分析正文消息，以根据电子邮件的目的对电子邮件进行分类。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 安然电子邮件数据集 &lt;/strong&gt;——这是由 CMU 托管的安然电子邮件存档。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 安然数据描述 (PDF)&lt;/strong&gt; – 对安然电子邮件数据的探索性分析，可以帮助您获得基础。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;6、从头开始编写 ML 算法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从头开始编写机器学习算法是一种出色的学习工具，主要有两个原因。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，没有更好的方法来建立对他们机制的真正理解。您将被迫考虑每一步，这将导致真正的掌握。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，您将学习如何将数学指令转换为工作代码。在从学术研究中调整算法时，您将需要这项技能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们建议选择不太复杂的算法。即使是最简单的算法，您也需要做出许多微妙的决定。在您熟悉构建简单算法后，尝试扩展它们以获得更多功能。例如，尝试通过添加正则化参数将普通&lt;strong&gt;逻辑回归&lt;/strong&gt;算法扩展为&lt;strong&gt;套索/岭回归。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，这是每个初学者都应该知道的提示：不要气馁，因为您的算法不如现有软件包中的算法快或花哨。这些软件包是多年发展的成果！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Python：从零开始的逻辑回归&lt;/p&gt;&lt;p&gt;• Python：从零开始的 k-最近邻&lt;/p&gt;&lt;p&gt;• R：从零开始的逻辑回归&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;7、&lt;/span&gt;&lt;/span&gt;挖掘社交媒体情绪&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于用户生成的内容数量庞大，社交媒体几乎已成为「大数据」的代名词。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;挖掘这些丰富的数据可以证明以前所未有的方式来掌握观点、趋势和公众情绪。Facebook、Twitter、YouTube、微信、WhatsApp、Reddit……这个名单还在继续。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，每一代人在社交媒体上花费的时间都比他们的前辈多。这意味着社交媒体数据将与营销、品牌和整个业务更加相关。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然有许多流行的社交媒体平台，&lt;strong&gt;但Twitter 是练习机器学习的经典切入点。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 Twitter 数据，您可以获得数据（推文内容）和元数据（位置、主题标签、用户、转发推文等）的有趣混合，为分析开辟了几乎无穷无尽的路径。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Python：挖掘 Twitter 数据——如何对 Twitter 数据进行情绪分析&lt;/p&gt;&lt;p&gt;• R：使用机器学习进行情感分析——简短而甜蜜的情感分析教程&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Twitter API  – twitter API 是流数据的经典来源。您可以跟踪推文、主题标签等。&lt;/p&gt;&lt;p&gt;• StockTwits API  – StockTwits 就像交易者和投资者的推特。 您可以通过使用时间戳和股票代码将其连接到时间序列数据集来以许多有趣的方式扩展此数据集 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8、改善医疗保健&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于机器学习，另一个正在经历快速变化的行业是全球健康和医疗保健。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在大多数国家，成为一名医生需要多年的教育。这是一个要求高、工作时间长、风险高、进入门槛更高的领域。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，最近在机器学习的帮助下减轻医生的工作量并提高医疗保健系统的整体效率做出了重大努力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用例包括：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 预防性护理…… &lt;/strong&gt;预测个人和社区层面的疾病爆发。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 诊断护理...... &lt;/strong&gt;自动对图像数据进行分类，例如扫描、X 射线等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;• 保险……&lt;/strong&gt;根据公开的风险因素调整保险费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着医院继续对患者记录进行现代化改造，并且随着我们收集更细化的健康数据，数据科学家将有大量唾手可得的机会来发挥作用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• R：为疾病预测构建有意义的机器学习模型&lt;/p&gt;&lt;p&gt;• 医疗保健中的机器学习——微软研究院的精彩演讲&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 大型健康数据集——大型健康相关数据集的集合&lt;/p&gt;&lt;p&gt;• data.gov/health – 美国政府提供的与健康和医疗保健相关的数据集。&lt;/p&gt;&lt;p&gt;• 健康营养和人口统计——世界银行提供的全球健康、营养和人口统计数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66b33ecf05d37a61e5f20addc8186d98</guid>
<title>Facebook 是怎么保证缓存一致性的</title>
<link>https://toutiao.io/k/6agqjku</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;缓存有助于减少延迟，提高重读工作负载的可扩展性，并且节省成本。实际上缓存是无处不在的，它也在你的手机和你的浏览器中运行。例如，CDN和DNS本质上是地理复制的缓存。正是由于许多缓存在幕后工作，你现在才能阅读这篇文章。&lt;br/&gt;&lt;br/&gt;Phil Karlton有句名言：&quot;计算机科学中只有两个难题：缓存失效和命名&quot;。如果你曾经处理过的无效缓存，那么你很有可能遇到过缓存不一致这个恼人的问题。&lt;br/&gt;&lt;br/&gt;在Meta，我们运营着世界上最大的高速缓存，包括TAO和Memcache。多年来，我们将TAO的缓存一致性提高了一个档次，从99.9999%（六个九）提高到99.99999999%（十个九）。&lt;br/&gt;&lt;br/&gt;当涉及到缓存无效时，我们相信我们现在有一个有效的解决方案来弥补理论和实践之间的差距。这篇博文中的原则和方法广泛适用于大多数（如果不是所有）的缓存服务。无论你是在Redis中缓存Postgres数据，还是将分散数据具像化，都是如此。&lt;br/&gt;&lt;br/&gt;我们希望能帮助减少工程师必须处理的缓存失效问题，并帮助增强缓存的一致性。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;定义缓存失效和缓存一致性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据定义，缓存并不是你数据的真实来源（例如，数据库）。缓存失效描述的是当真实源中的数据发生变化时，主动将陈旧的缓存条目失效的过程。如果缓存失效处理不当，就会在缓存中无限期地保留一个不一致的值。&lt;br/&gt;&lt;br/&gt;缓存失效涉及到一个必须由缓存自身以外的程序来执行的动作。一些程序（例如，客户端或公共/子系统）需要告诉缓存其中数据发生了变化。仅仅依靠TTL来保持有效性的缓存，不在本文讨论范围之内。在这篇文章的其余部分，我们将假设存在缓存失效操作。&lt;br/&gt;&lt;br/&gt;为什么这个看似简单的过程在计算机科学中被认为是个困难的问题？下面是个简单的例子，说明如何引入缓存不一致的问题。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGQdrp2DZvv8w8438vHX6ncpxfFiaUPPhCfpCz1bGWq8ibCkbCDZrEmkCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;缓存首先尝试从数据库中填充x。但是在 &quot;x=42 &quot;到达缓存主机之前，有人将x设置为43。缓存失效事件 &quot;x=43 &quot;首先到达缓存主机，将x设置为43。&quot;x=42 &quot;到达了缓存，将x设置为42。现在数据库中&quot;x=43 &quot;，而缓存中 &quot;x=42 &quot;。&lt;br/&gt;&lt;br/&gt;有很多方法来解决这个问题，其中之一就是维护版本字段。这样我们就可解决冲突，因为旧的数据不应该覆盖新的数据。但是，如果缓存条目 &quot;x=43 @version=2 &quot;在 &quot;x=42 &quot;到达之前就失效了呢？在这种情况下，缓存数据依然是错误的。&lt;br/&gt;&lt;br/&gt;缓存失效的挑战不仅来自于失效协议的复杂性，还来自于监控缓存一致性和如何确定缓存不一致的原因。设计一个一致的缓存与操作一个一致的缓存有很大不同，就像设计Paxos协议与构建在生产中实际运行的Paxos一样，都有很大区别。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;我们为什么要关心缓存的一致性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们必须解决复杂的缓存失效问题吗？在某些情况下，缓存的不一致性几乎和数据库数据丢失一样严重。从用户的角度来看，它甚至和数据丢失没有区别。&lt;br/&gt;&lt;br/&gt;让我们来看看另一个关于缓存不一致如何导致脑裂的例子。Meta公司使用消息将其从用户在主存储数据的映射到TAO中。它经常进行移动，以保证用户可以就近访问。每次你向某人发送消息时，系统都会查询TAO，以找到消息的存储位置。许多年前，当TAO的一致性较差时，一些TAO副本在重新移动后会出现不一致的数据，如下例所示。&lt;br/&gt;&lt;br/&gt;想象一下，在将Alice的主消息存储从区域2切换到区域1后，Bob和Mary，都向Alice发送了消息。当Bob向Alice发送消息时，系统查询了靠近Bob居住地的区域的TAO副本，并将消息发送到区域1。当Mary向Alice发送消息时，系统查询了靠近Mary居住地的地区的TAO副本，命中了不一致的TAO副本，并将消息发送到了地区2。Bob和Mary将他们的消息发送到不同的区域，而两个区域都没有爱丽丝消息的完整副本。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGFby1YSiaQLicGw7hicBgWayK94ib3IDcmlCiaiaf8CpZa0iaofhJqRkAvuAng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;缓存失效模型&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGlibAehZ9pdBswAO62iasibyKB7m5VloG9UmgI0XIrTlSG65Cia1jjJ2nOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;了解缓存失效的困难之处尤其具有挑战性。让我们从一个简单的模型开始。缓存的核心是一个有状态的服务，它将数据存储在一个可寻址的存储介质中。分布式系统本质上是一种状态机。如果每个状态转换都能正确执行，我们就会有一个按预期工作的分布式系统。否则，系统就会问题。所以，关键的问题是：对于有状态的服务，什么在改数据？&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.490625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGEd1TLOhQ8mut0TtV0P5JduWia3j2ubjMrUVV45hk9tnrOM1oclJHRSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;静态缓存有一个非常简单的缓存模型（例如，简化的CDN接近这个模型）。数据是不可改变的。没有缓存主动失效。对于数据库来说，数据只有在写入（或复制）时才会发生变化。我们通常对数据库的每一个状态变化都有日志。每当发生异常时，日志可以帮助我们了解发生了什么，缩小问题的范围，并找出问题所在。构建容错的分布式数据库（这已经很困难了），有其独特的挑战。这些只是简化的模型。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.57734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGcaAsHsRUyV7pdnwxlTLXhWsicDrFics3r1iaGzOTBiciafiaUuYKII07DdTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;对于像TAO和Memcache这样的动态缓存，数据在读取（缓存填充）和写入（缓存失效）的路径上都会发生变化。这种组合使得多竞态条件成为可能，而缓存失效则是一个困难的问题。缓存中的数据是不持久的，这意味着有时候对解决冲突很重要的版本信息会被清除出去。结合所有这些特点，动态缓存产生的竞态条件超出了我们的想象。&lt;br/&gt;&lt;br/&gt;而且，记录和跟踪每一个缓存状态的变化几乎是不现实的。缓存经常被引入来扩展重读的工作负载。这意味着大部分的缓存状态变化都来自缓存填充路径。以TAO为例。它每天提供超过四亿次的查询。即使缓存命中率达到99%，我们每天也要进行超过10万亿次的缓存填充。记录和追踪所有的缓存状态变化会使一个重读的缓存工作负载变成一个极重写的日志系统工作负载。调试一个分布式系统已经带来了巨大的挑战。调试一个没有缓存状态变化的日志或追踪的分布式系统，基本是不可能的。&lt;br/&gt;&lt;br/&gt;尽管有这些挑战，我们还是提高了TAO的缓存一致性，这些年来从99.9999提高到99.99999999。在文章的其余部分，我们将解释我们是如何做到的，并强调一些未来的工作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;针对一致性的可观察性&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决缓存失效和缓存一致性问题，第一步涉及测量。我们要测量高速缓存的一致性，并在高速缓存中出现不一致的条目时发出警报。测量不能包含任何假阳性。人类的大脑可以很容易地调出噪音。如果存在任何误报，人们很快就会学会忽略它，而这个测量也变得毫无用处。我们还需要测量是精确的，因为我们谈论的是测量超过10个九的一致性。如果一个修正已经落地，我们要保证我们可以定量地测量它带来的改进。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGzPzGkS6aPLAr5iaJ8ILQKjFPZDKicrCpFIlOyYY1ibd3ooMKwkl5kGvCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;为了解决测量问题，我们建立了一个名为Polaris的服务。对于一个有状态的服务中的任何异常，只有当客户能够以这种或那种方式观察到它，它才是一个异常。否则，它就根本不重要。基于这一原则，Polaris 专注于测量违反客户可观察不变量的情况。&lt;br/&gt;&lt;br/&gt;在高层次上，Polaris作为客户端与有状态的服务进行交互，并且不假设了解服务内部。这使得它是通用的。Meta有几十个服务使用Polaris。&quot;缓存最终应该与数据库一致 &quot;是Polaris监控的一个典型的客户端可观察到的不变因素，特别是在异步缓存失效的情况下。在这种情况下，Polaris假装是一个缓存服务器并接收缓存失效事件。例如，如果Polaris收到一个无效事件，说 &quot;x=4 @version 4&quot;，它就会作为客户查询所有的缓存副本，以验证是否有任何违反该不变性的情况发生。如果一个缓存副本返回 &quot;x=3 @version 3&quot;，Polaris将其标记为不一致，并重新等待样本，以便以后针对同一目标缓存主机进行检查。Polaris在某些时间尺度上报告不一致，例如一分钟、五分钟或十分钟。如果这个样本在一分钟后仍然显示为不一致，Polaris就将其报告为相应时间尺度的不一致。&lt;br/&gt;&lt;br/&gt;这种多时间尺度的设计不仅允许Polaris在内部存在多个队列，以有效地实现回退和重试，而且对于防止产生误报也是至关重要的。&lt;br/&gt;&lt;br/&gt;我们来看看一个更有趣的例子。假设Polaris收到一个 &quot;x=4 @version 4 &quot;的无效信息。但是当它查询一个缓存副本时，得到的答复是x不存在。目前还不清楚Polaris是否应该将此作为一个不一致的标记。有可能x在版本3的时候是不存在的，版本4的写入是对key的最新写入，而这种情况确实是缓存不一致。也有可能是第5个版本的操作删除了x，也许Polaris只是看到了失效事件中的数据更新的视图。&lt;br/&gt;&lt;br/&gt;为了区分这两种情况，我们需要绕过缓存，检查数据库中的内容。绕过缓存的查询是非常密集的运算。它们也会使数据库面临风险，因为保护数据库和扩展重读工作负载是缓存最常见的用例之一。因此，我们不能绕过缓存发送太多的查询。Polaris通过延迟执行计算密集型操作来解决这个问题，直到不一致的样本跨越报告时间尺度（如一分钟或五分钟）。真正的缓存不一致和对同一key的竞争写操作是很少的。因此，在它跨越下一个时间尺度边界之前才进行一致性检查有助于消除执行大部分数据库查询。&lt;br/&gt;&lt;br/&gt;我们还在Polaris发给缓存服务器的查询中加入了一个特殊的标志。因此，Polaris会知道目标缓存服务器是否已经看到并处理了缓存失效事件。这一点信息使Polaris能够区分瞬时的缓存不一致（通常由复制/验证滞后引起）和 &quot;永久 &quot;的缓存不一致(旧版本还无限期地存在于缓存中)。&lt;br/&gt;&lt;br/&gt;Polaris也提供观测指标，如&quot;N个9的缓存写入在M分钟内是一致的&quot;。在文章的开头，我们提到，通过一项改进，我们将TAO的缓存一致性从99.9999%提高到99.99999999%。Polaris提供了5分钟时间尺度的指标。换句话说，99.99999999%的缓存写入在5分钟内是一致的。在TAO中5分钟内，100亿次缓存写入中不到1次会出现不一致。&lt;br/&gt;&lt;br/&gt;我们将Polaris部署为一个单独的服务，这样它就可以独立于生产服务及其工作负载进行扩展。如果我们想测量到更多的数据，我们可以只增加Polaris的吞吐量或在更长的时间窗口上执行聚合。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一致性追踪&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大多数图中，我们用一个简单的盒子来表示缓存。在现实中，省略了许多依赖关系和数据流之后，看起来可能像这样。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.54296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGZR1icQS64ia0wxibbWiciaR6lTYGUEib5Eibk0FibuV0maZao6LtkrtfYBh9gg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;缓存可以在不同的时间点从不同的上游填充，这些上游可以是在同一region内或跨region。升级、分片移动、故障恢复、网络分区和硬件故障都有可能触发导致缓存不一致的问题。&lt;br/&gt;&lt;br/&gt;然而，正如前面提到的，记录和追踪每一个缓存数据的变化是不切实际的。但是，如果我们只在缓存不一致的地方和时候（或者缓存失效可能被错误地处理）记录和跟踪缓存的突变，会怎么样呢？在这个庞大而复杂的分布式系统中，任何组件的缺陷都可能导致缓存不一致，是否有可能找到一个引入大部分（如果不是全部）缓存不一致的地方？&lt;br/&gt;&lt;br/&gt;我们的任务变成了寻找一个简单的解决方案来帮助我们管理这种复杂性。我们想从单个缓存服务器的角度来评估整个缓存一致性问题。最后，不一致的问题必须在一个缓存服务器上出现。从它的角度来看，它只关心几个方面。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是否收到了失效信息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它是否正确地处理了这个失效信息？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;之后缓存是否变得不一致了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.490625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGUK3epnxUB56eia3iad3AQQkNLuYNwjyCSRmZCDhGs3szgAOaeMQnZFpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;这就是我们在文章开头解释的那个例子，现在用一个时空图来说明。如果我们把注意力集中在底部的缓存时间轴上，我们可以看到在客户端写完之后，有一个窗口，在这个窗口中，失效和缓存填充都在竞争更新缓存。一段时间后，缓存将处于静止状态。在这种状态下，缓存的填充仍然会大量发生，但从一致性的角度来看，由于没有写入，它已经沦为一个静态的缓存，所以它的意义不大。&lt;br/&gt;&lt;br/&gt;我们建立了一个有状态的库，记录和跟踪这个小的紫色窗口中的缓存突变，在这个窗口中，所有相关的复杂交互都会引发导致缓存不一致的问题。它涵盖了缓存的过期，甚至没有日志也能告诉我们是否无效事件从未到达。它被嵌入到几个主要的缓存服务中，并贯穿于整个失效管道。它缓冲了最近修改的数据索引，用于确定后续的缓存状态变化是否应该被记录下来。它还支持代码追踪，所以我们会知道每个被追踪查询的确切代码路径。&lt;br/&gt;&lt;br/&gt;这种方法帮助我们发现并修复了许多缺陷。它为诊断缓存的不一致提供了一个系统性的、更可扩展的方法。事实证明，它非常有效。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;我们今年发现并修复的一个线上错误&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGWnLgMaXCTQ3dWGVicQwlLn1or4JYic0F60bTj09JIPTGbJFWWsk9CTJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;在一个系统中，我们对每条数据进行了版本排序和冲突解决。在这种情况下，我们在缓存中观察到 &quot;metadata=0 @version4&quot;，而数据库中包含 &quot;metadata=1 @version4&quot;。缓存无限期地保持不一致。这种状态应该是不可能的。你会如何处理这个问题？如果我们能得到导致最终不一致状态的每一个步骤的完整时间线，那该有多好？&lt;br/&gt;&lt;br/&gt;一致性追踪正好提供了我们需要的时间线。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8XkvNnTiapOM64gt2kf0PavSjTt9IV1XGzmib3ZFBUHvypxA685prqEEEIYjYSxTtia8wUJicCT3vvticxiapDmiagTbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;在系统中，一个非常罕见的操作以事务方式更新了底层数据库的两个表—元数据表和版本表。&lt;br/&gt;&lt;br/&gt;根据一致性追踪，我们知道发生了以下情况。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存试图添加版本数据和元数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在第一轮中，缓存首先填充了旧的元数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接下来，一个写事务以原子方式更新了元数据表和版本表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在第二轮中，缓存写入了新的版本数据。这里，缓存填充操作与数据库事务交错进行。因为竞态窗口很小，所以这种情况很少发生。你可能会想，&quot;这就是bug。&quot;。但是实际上到目前为止，一切都按预期进行，因为缓存失效应该可以把缓存恢复一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;稍后，在尝试将缓存项更新为新元数据和新版本时，出现了缓存无效。这几乎总是有效的，但这次没有。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存失效在缓存主机上遇到了一个罕见的瞬时错误，这触发了错误处理代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;错误处理程序将该条目删除。伪代码看起来是这样的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;drop_cache(key, version);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果条目的版本低于指定的版本，则将其放入缓存。但是，不一致的缓存项包含最新版本。所以这段代码什么也没做，将过时的元数据无限期地留在缓存中。这就是bug。我们在这里把这个例子简化了很多。实际的bug甚至更加复杂，涉及到数据库复制和跨区域通信。只有当以上所有的步骤都发生，并且以这个顺序具体发生时，这个bug才会被触发。不一致的情况很少出现。该错误隐藏在交互操作和瞬时错误背后的错误处理代码中。&lt;br/&gt;&lt;br/&gt;许多年前，如果有人对代码和服务了如指掌并且他们足够幸运的话，要花几周时间才能找到这种错误的根本原因。在这种情况下，Polaris发现了异常情况，并立即发出警报。通过一致性追踪的信息，值班工程师花了不到30分钟就可以找到这个错误。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;未来的缓存一致性工作&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们已经分享了我们如何用一种通用的、系统的、可扩展的方法来增强我们的缓存一致性。展望未来，我们想让我们所有缓存的一致性在物理上尽可能地接近100%。分散的二级指数的一致性带来了一个有趣的挑战。我们也在测量并有目的地改善读取时的缓存一致性。最后，我们正在为分布式系统建立高水平的一致性API，想想针对分布式系统的C++的std::memory_order。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://engineering.fb.com/2022/06/08/core-data/cache-invalidation/?continueFlag=5d7598b8068e4850d16d3bc686805488&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构翻译。技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;活动预告&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;↓&lt;span&gt;↓&lt;span&gt;↓&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6133333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapOPZD13CEzFeLiaWJl9icbazMdaAf95oSdj7OXva3ZaE5DLOmiaT1zG0LYiaB0Eqns9X3Z2uuLFatq6YaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GIAC 全球互联网架构大会 2022 将于 7 月 22 - 23 日在深圳举行，本届 GIAC 议题共设置有 24 个专题，覆盖各类架构热点领域，每个主题由业内知名架构师、技术负责人等专家担任出品人，负责议题选取和质量把控。本次大会包括基础架构（由bilibili技术委员会主席毛剑担任出品人）和高并发&amp;amp;高可用（由菜鸟架构委员会主席钟勇担任出品人）等专题，将有更多本文相关内容演讲，点击阅读原文查看 GIAC 详细日程。&lt;/span&gt;&lt;/p&gt;&lt;p data-morpho-type=&quot;paragraph&quot; data-slate-node=&quot;element&quot;&gt;&lt;/p&gt;&lt;p data-morpho-type=&quot;paragraph&quot; data-slate-node=&quot;element&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击【&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;】，了解更多活动信息。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/92wl596</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f3245593491d5a22af72c050fdb6c186</guid>
<title>高并发下如何防重？</title>
<link>https://toutiao.io/k/m1fi6au</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近测试给我提了一个 bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;追查原因之后发现，这个事情没想象中简单，可以说一波多折。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1. 需求&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;产品有个需求：&lt;strong&gt;用户选择一些品牌，点击确定按钮之后，系统需要基于一份默认品牌的商品数据，复制出一批新的商品&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;拿到这个需求时觉得太简单了，三下五除二就搞定。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我提供了一个复制商品的基础接口，给商城系统调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当时的流程图如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2962382445141066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74v073cEphxgnuialQdxJ1APTqGmxga34icfB9dD7VVPPq7rjYbYF7Pdyqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果每次复制的商品数量不多，使用同步接口调用的方案问题也不大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于每次需要复制的商品数量比较多，可能有几千。&lt;/span&gt;&lt;span&gt;如果每次都是用同步接口的方式复制商品，可能会有性能问题。&lt;/span&gt;&lt;span&gt;因此，后来我把复制商品的逻辑改成使用 MQ &lt;/span&gt;&lt;span&gt;异步处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;改造之后的流程图：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25058823529411767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGmIG2UQ0ACq9ibuIG9mV02Bjdjtw4ibmE06BJucicvkBTaAgibNuEeLdsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1700&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复制商品的结果还需要通知商城系统：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vfCDzNOsHJ1a6TElFvSNKEEA8B7320Rhm2hje3tib4B8cdGUzMHK94KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方案看起来，挺不错的。&lt;/span&gt;&lt;span&gt;但后来出现问题了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 出问题了&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试给我们提了一个 bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过追查之后发现，商城系统为了性能考虑，也改成异步了。&lt;/span&gt;&lt;span&gt;他们没有在接口中直接调用基础系统的复制商品接口，而是在 &lt;/span&gt;&lt;span&gt;job &lt;/span&gt;&lt;span&gt;中调用的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;站在他们的视角流程图是这样的&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28144458281444584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vibicaial4QeBQweXfssQVwcqaMnTPY52iaBOGzRd6GuajlLDmicAsHKq0Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户调用商城的接口，他们会往请求记录表中写入一条数据，然后在另外一个 job 中，异步调用基础系统的接口去复制商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但&lt;strong&gt;实际情况&lt;/strong&gt;是这样的：商城系统内部出现了 bug，在请求记录表中，同一条请求产生了重复的数据。这样导致的结果是，在 job 中调用基础系统复制商品接口时，发&lt;strong&gt;送了重复的请求&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;刚好，基础系统现在是使用 RocketMQ 异步处理的。由于商城的 job 一次会取一批数据（比如 20 条记录），在极短的时间内（其实就是在一个 for 循环中）多次调用接口，可能存在相同的请求参数连续调用复制商品接口情况。于是，出现了并发插入重复数据的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;为什么会出现这个问题呢？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 多线程消费&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RocketMQ 的消费者，为了性能考虑，默认是用多线程并发消费的，最大支持 64 个线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        consumerGroup = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MessageReceiver&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String message = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        doSamething(message);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也就是说，如果在极短的时间内，连续发送重复的消息，就会被不同的线程消费。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;即使在代码中有这样的判断：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Product oldProduct = query(hashCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(oldProduct == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    productMapper.insert(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在插入数据之前，先判断该数据是否已经存在，只有不存在才会插入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于在并发情况下，不同的线程都判断商品数据不存在，于是同时进行了插入操作，所以就产生了重复数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.432601880877743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vqwIZ9vSeRvxOrn1vhCYibVaGM9Zz9z9sTlu9LrDFUoCROAiaMN4k81Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 顺序消费&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决上述并发消费重复消息的问题，我们从两方面着手：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商城系统修复产生重复记录的 bug；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基础系统将消息改成单线程顺序消费。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我仔细思考了一下，如果只靠商城系统修复 bug，以后很难避免不出现类似的重复商品问题。比如，如果用户在极短的时间内点击创建商品按钮多次，或者商城系统主动发起重试。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，基础系统还需进一步处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实 RocketMQ 本身是支持顺序消费的，需要消息的生产者和消费者一起改。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生产者改为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rocketMQTemplate.asyncSendOrderly(topic, message, hashKey, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SendCallback() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onSuccess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(SendResult sendResult)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      log.info(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sendMessage success&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onException&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Throwable e)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sendMessage failed!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重点是要调用 rocketMQTemplate 对象的 asyncSendOrderly 方法，发送顺序消息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消费者改为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        consumeMode = ConsumeMode.ORDERLY,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        consumerGroup = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MessageReceiver&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String message = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        doSamething(message);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接收消息的重点是 RocketMQMessageListener 注解中的 consumeMode 参数，要设置成 ConsumeMode.ORDERLY，这样就能顺序消费消息了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;修改后关键流程图如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2842105263157895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vmDcibWsNfwwiag30A8LHM0UIjibtV9tDYv9HFmL6xQuDxNe5MFfxC7kjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两边都修改之后，复制商品这一块就没有再出现重复商品的问题了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;But，修完 bug 之后，我又思考了良久。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;复制商品只是创建商品的其中一个入口，如果有其他入口，跟复制商品功能同时创建新商品呢？&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;不也会出现重复商品问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽说，这种概率非常非常小。&lt;/span&gt;&lt;span&gt;但如果一旦出现重复商品问题，后续涉及到要合并商品的数据，非常麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过这一次的教训，一定要防微杜渐。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不管是用户，还是自己的内部系统，从不同的入口创建商品，都需要解决重复商品创建问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，如何解决这个问题呢？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 唯一索引&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决重复商品数据问题，最快成本最低最有效的办法是：给表建唯一索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想法是好的，但我们这边有个规范就是：业务表必须都是逻辑删除。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而我们都知道，要删除表的某条记录的话，如果用 delete 语句操作的话。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; product &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种 delete 操作是物理删除，即该记录被删除之后，后续通过 SQL 语句基本查不出来。（不过通过其他技术手段可以找回，那是后话了）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有另外一种是逻辑删除，主要是通过 update 语句操作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; product &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; delete_status=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,edit_time=&lt;span class=&quot;code-snippet__keyword&quot;&gt;now&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逻辑删除需要在表中额外增加一个删除状态字段，用于记录数据是否被删除。在所有的业务查询的地方，都需要过滤掉已经删除的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过这种方式删除数据之后，数据任然还在表中，只是从逻辑上过滤了删除状态的数据而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实对于&lt;strong&gt;这种逻辑删除的表，是没法加唯一索引的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设之前给商品表中的 name 和 model 加了唯一索引，如果用户把某条记录删除了， delete_status 设置成 1 了。后来，该用户发现不对，又重新添加了一模一样的商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于唯一索引的存在，该用户第二次添加商品会失败，即使该商品已经被删除了，也没法再添加了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个问题显然有点严重。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有人可能会说：把 name、model 和 delete_status 三个字段同时做成唯一索引不就行了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答：这样做确实可以解决用户逻辑删除了某个商品，后来又重新添加相同的商品时，添加不了的问题。但如果第二次添加的商品，又被删除了。该用户第三次添加相同的商品，不也出现问题了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此可见，如果表中有逻辑删除功能，是不方便创建唯一索引的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. 分布式锁&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，你想到的第二种解决数据重复问题的办法可能是：加分布式锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前最常用的性能最高的分布式锁，可能是 Redis 分布式锁了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 &lt;span&gt;Redis &lt;/span&gt;分布式锁的伪代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  String result = jedis.&lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt;(lockKey, requestId, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      doSamething();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unlock(lockKey,requestId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过需要在 finally 代码块中释放锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中 lockKey 是由商品表中的 name 和 model 组合而成的，requestId 是每次请求的唯一标识，以便于它每次都能正确得释放锁。还需要设置一个过期时间 expireTime，防止释放锁失败，锁一直存在，导致后面的请求没法获取锁。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果只是单个商品，或者少量的商品需要复制添加，则加分布式锁没啥问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8079470198675496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGcexEIvtOkk5Jfh2JwW8cvMKIibvp3JvHQdQoia82efOcepStGicuTNcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以在复制添加商品之前，先尝试加锁。如果加锁成功，则在查询商品是否存在，如果不存在，则添加商品。此外，在该流程中如果加锁失败，或者查询商品时不存在，则直接返回。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加分布式锁的目的是：保证查询商品和添加商品的两个操作是原子性的操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但现在的问题是，我们这次需要复制添加的商品数量很多，如果每添加一个商品都要加分布式锁的话，会非常影响性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;显然对于批量接口，加 Redis 分布式锁，不是一个理想的方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 统一 MQ 异步处理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面我们已经聊过，在批量复制商品的接口，我们是通过 RocketMQ 的顺序消息，单线程异步复制添加商品的，可以暂时解决商品重复的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但那只改了一个添加商品的入口，还有其他添加商品的入口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;能不能把添加商品的底层逻辑统一一下，最终都调用同一段代码。然后通过 RocketMQ 的顺序消息，单线程异步添加商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要流程如下图所示&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6787762906309751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vp4QahsQibEx0YLVVX1xLYMzETZOdC0LNJP9VwkNo5MxANC3moic6ZZ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样确实能够解决重复商品的问题。&lt;/span&gt;&lt;span&gt;但同时也&lt;/span&gt;&lt;span&gt;带来了另外两个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;现在所有的添加商品功能都改成异步了，之前同步添加商品的接口如何返回数据呢？这就需要修改前端交互，否则会影响用户体验；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;之前不同的添加商品入口，是多线程添加商品的，现在改成只能由一个线程添加商品，这样修改的结果导致添加商品的整体效率降低了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此，综合考虑了一下各方面因素，这个方案最终被否定了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. insert on duplicate key update&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实，在 MySQL 中存在这样的语法，即 insert on duplicate key update。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在添加数据时，&lt;/span&gt;&lt;span&gt;&lt;span&gt;MySQL&lt;/span&gt; 发现数据不存在，则直接 insert。&lt;/span&gt;&lt;span&gt;如果发现数据已经存在了，则做 update 操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过要求表中存在唯一索引或 PRIMARY KEY。这样当这两个值相同时，才会触发更新操作，否则是插入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在的问题是 PRIMARY KEY 是商品表的主键，是根据雪花算法提前生成的，不可能产生重复的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此，insert on duplicate key update 这套方案，暂时也没法用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，insert on duplicate key update 在&lt;strong&gt;高并发的情况下，可能会产生死锁问题&lt;/strong&gt;，需要特别注意一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. insert ignore&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 &lt;span&gt;MySQL &lt;/span&gt;中还存在这样的语法，即 insert ... ignore。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 insert 语句执行的过程中：&lt;span&gt;MySQL &lt;/span&gt;发现如果数据重复了，就忽略，否则就会插入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它主要是用来忽略，插入重复数据产生的 Duplicate entry &#x27;XXX&#x27; for key &#x27;XXXX&#x27; 异常的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过也要求表中存在唯一索引或 PRIMARY KEY。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此可见，这个方案也不行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;温馨的提醒一下，使用 insert ... ignore 也有可能会导致死锁。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;11. 防重表&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;之前聊过，因为有逻辑删除功能，给商品表加唯一索引，行不通。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后面又说了加分布式锁，或者通过 MQ 单线程异步添加商品，影响创建商品的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，如何解决问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们能否换一种思路，加一张防重表，在防重表中增加商品表的 name 和 model 字段作为唯一索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`product_unique`&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;id&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`name`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;130&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`model`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;255&lt;/span&gt;)  &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;规格&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`user_id`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建用户id&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`user_name`&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;)  &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建用户名称&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`create_date`&lt;/span&gt; datetime(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  PRIMARY &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`id`&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`ux_name_model`&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`name`&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;`model`&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;code-snippet__keyword&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8mb4 &lt;span class=&quot;code-snippet__keyword&quot;&gt;COMMENT&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;商品防重表&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中表中的id可以用商品表的 id，表中的 name 和 model 就是商品表的 name 和 model，不过在这张防重表中增加了这两个字段的唯一索引。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;视野一下子被打开了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在添加商品数据之前，先添加防重表。如果添加成功，则说明可以正常添加商品，如果添加失败，则说明有重复数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;防重表添加失败，后续的业务处理，要根据实际业务需求而定。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果业务上允许添加一批商品时，发现有重复的，直接抛异常，则可以提示用户：“系统检测到重复的商品，请刷新页面重试&lt;span&gt;”&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productUniqueMapper.batchInsert(productUniqueList);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productMapper.batchInsert(productList);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;.TRUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; BusinessException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;系统检测到重复的商品，请刷新页面重试&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在批量插入数据时，如果出现了重复数据，捕获 DuplicateKeyException 异常，转换成 BusinessException 这样运行时的业务异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有一种业务场景，要求即使出现了重复的商品，也不抛异常，让业务流程也能够正常走下去。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productUniqueMapper.insert(productUnique);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productMapper.insert(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;.TRUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   product = productMapper.query(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在插入数据时，如果出现了重复数据，则捕获 DuplicateKeyException，在 catch 代码块中再查询一次商品数据，将数据库已有的商品直接返回。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果调用了同步添加商品的接口，这里&lt;strong&gt;非常关键的一点&lt;/strong&gt;，是要返回已有数据的 id，业务系统做后续操作，要拿这个 id 操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然在执行 execute 之前，还是需要先查一下商品数据是否存在，如果已经存在，则直接返回已有数据，如果不存在，才执行 execute 方法。这一步千万不能少。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Product oldProduct = productMapper.query(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(Objects.nonNull(oldProduct)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; oldProduct;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productUniqueMapper.insert(productUnique);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      productMapper.insert(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;.TRUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   product = productMapper.query(product);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; product;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;千万注意：防重表和添加商品的操作必须要在同一个事务中，否则会出问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;顺便说一下，还需要对商品的删除功能做特殊处理一下，在逻辑删除商品表的同时，要物理删除防重表。用商品表 id 作为查询条件即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说实话，解决重复数据问题的方案挺多的，没有最好的方案，只有最适合业务场景的，最优的方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651513304&amp;amp;idx=1&amp;amp;sn=230e9d2c35b0c8a2e7c79d7a7436a854&amp;amp;chksm=bd258da78a5204b192f6804d04dc337d8670e055191b3aa54ae7d2bbb94be6f2456e8dc6953c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;优雅地处理重复请求（并发请求）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;优雅地处理重复请求（并发请求）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651510835&amp;amp;idx=1&amp;amp;sn=4210d78b8ca703b7017fa4aac211cdab&amp;amp;chksm=bd25b44c8a523d5a08ca3ae408b684129946c306f0eb27049e53d2cf64e2c3c666dc01b58f58&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring Cloud Stream整合Rabbit之重复投递&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud Stream整合Rabbit之重复投递&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651489365&amp;amp;idx=1&amp;amp;sn=d1a8bd439fbee22d7be047839e11ee77&amp;amp;chksm=bd25e82a8a52613c203e62cb1e6cd58c367add5f6999ac90799ad1b1bbb0ac0eb417dd7af81b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;消息队列面试连环问：如何保证消息不丢失？处理重复消息？消息有序性？消息堆积处理？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;消息队列面试连环问：如何保证消息不丢失？处理重复消息？消息有序性？消息堆积处理？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4b7f76bbc545a6400b2c5398ba0e4eb3</guid>
<title>是什么能让 APP 快速精准定位到我们的位置？</title>
<link>https://toutiao.io/k/gta4w93</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;output_wrapper&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文作者：&lt;/span&gt;&lt;span&gt;smallyang，腾讯 IEG 开发工程师&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是geohash？它的原理是什么？它帮助我们解决了哪些痛点，本文为你娓娓道来。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本文包含以下内容，阅读完需要约10分钟：&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;我们日常生活中遇到哪些定位的场景&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;简单复习一下经纬度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;geohash原理解析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;geohash存在的边界问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何解决边界问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;计算两点距离的计算&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;geohash 在redis中的实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;我们日常生活中遇到哪些定位的场景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;我们上下班经常会用APP打车和共享单车，下面2张图，应该都很熟悉，打开定位，查找我附近的车，那么，这个是怎么实现的呢？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7497354497354497&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEfONZtnRsAQHy0DHp5xaa42tAeseQlPf3XErnFkm8PubpDfzaxqfLEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot;/&gt;&lt;/p&gt;&lt;p&gt;我脑海中第一个实现方式是：&lt;strong&gt;实时上报经纬度&lt;/strong&gt;。在数据库里，把经纬度都标记为索引，通过查找对比经纬度的值，来找到附近1km的车子，但是这种做法第一是索引比较多，数值比较大，二是需要循环遍历经纬度，查询会很慢，效率很低。&lt;/p&gt;&lt;p&gt;那么，这些APP是怎么做到，既能精准定位，又能快速查找呢？答案就是 &lt;code&gt;geohash&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;geohash通过算法将1个定位的经度和纬度2个数值，转换成1个hash字符串。如果2个地方距离越近，那么他们的hash值的前缀越相同。然后通过数据库中like操作符 “ like wtw366%” 快速查找到附近的车。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如上海腾讯大厦的经纬度是：&lt;code&gt;（31.1688749, 121.3975184）&lt;/code&gt;，那么转换成geohash就是 &lt;code&gt;wtw366ngz5qt&lt;/code&gt;，我们想找附近的车子，可以用：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python language-python hljs&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; cart where geohash like &lt;span class=&quot;hljs-string&quot;&gt;&#x27;wtw366%&#x27;&lt;/span&gt; ;&lt;br/&gt;&lt;br/&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; cart where LEFT(geohash, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;) = &lt;span class=&quot;hljs-string&quot;&gt;&#x27;wtw366&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;简单复习一下经纬度&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在大致了解什么是geohash之后，我们先来复习一下什么是经纬度（高中学的，可能已经忘记光了（逃）），这对于理解geohash有很大的帮助。&lt;/p&gt;&lt;p&gt;我们将地球铺平开来，会得到下面这个平面图。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.48866631523458093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WES4vsjdVzeOibpjA3wRzxrMzic3nOyC2SkialpgkVUrhow9vLiaJOCy3S9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1897&quot; title=&quot;地球铺平面图&quot;/&gt;&lt;figcaption&gt;地球铺平面图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;以赤道和本初子午线为界，将地球分为经度和纬度。赤道是在0度，本初子午线也在0度。以赤道作为经度X横坐标，以本初子午线作为纬度 Y 竖坐标。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.45459373340414233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WE2icRPn0licamT7frWh0NOCs2dW5OBm6zAecdwaQhWHPTlLNmGthtkgoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1883&quot; title=&quot;经纬度图&quot;/&gt;&lt;figcaption&gt;经纬度图&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;经度（longitude）&lt;span class=&quot;hljs-string&quot;&gt;`和`&lt;/span&gt;纬度（latitude）&lt;span class=&quot;hljs-string&quot;&gt;`简称 `&lt;/span&gt;lng&lt;span class=&quot;hljs-string&quot;&gt;` 和 `&lt;/span&gt;lat&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，从本初子午线向东划分180度称为东经，用”E”表示：（0, 180]；向西划分180度为西经,用“W”表示：[-180, 0）&lt;/p&gt;&lt;p&gt;以赤道为0度,向南北各分出90度，南北极的读数均是90度，北纬用“N”表示 :（0, 90] ，南纬用“S”表示: [-90, 0）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;纬线和纬线是角度数值，并不是米。&lt;br/&gt;[ 表示等于， （表示小于&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;所以，我们常用十字坐标法来表示经纬度坐标图：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.47449521785334753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEduicQmRYFJWJ79d4DZicOibPMiafe9U1eTQMHPlmroliaMS2QLznBO1YOwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1882&quot; title=&quot;十字坐标法&quot;/&gt;&lt;figcaption&gt;十字坐标法&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;我们一般读“经纬度”，其实，表示一个定位的书面经纬度是 “（纬度，经度）”。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;比如上海腾讯大厦的定位就是：(31.1688749, 121.3975184）表示的是：纬度=31.1688749，经度=121.3975184&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.4687830687830688&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WETFZ0fmyfxvl9I01jchxjWKibsibLFfvtyTAyNzy9G2ce3iaHiaWibkzRaZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1890&quot; title=&quot;上海腾讯大厦经纬度图&quot;/&gt;&lt;figcaption&gt;上海腾讯大厦经纬度图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;geohash原理解析&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在了解什么是经纬度之后，现在我们就可以开始来说下geohash的原理了，geohash通过以下步骤，实现了将一个经纬度数子串，转换成1个hash字符串。&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指定一个位置的经纬度坐标值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据十字坐标图和二分法，将纬度和经度划分成1和0的二进制数字串。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照“偶数位放经度，奇数位放纬度”算法，合并经度和纬度这2个二进制数字串。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;合并后的二进制数字串，按照从前往后，每隔5位，换算成十进制数字，最后不足5位的用0补齐。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;十进制数字，对应base32字符串算法的所在位置，一一匹配，得到了最后的字符串结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照进度划分截取，得到最终的geohash值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们按照这个顺序，结合实际的例子，依次计算操作一下。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1. 找出一个位置的经纬度&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们可以用各种地图和定位工具，比如依靠Google地图，通过定位或者搜索一个地点，就容易找出经纬度。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.5385021097046413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEiaPtjvUt9AIHcgI500sctOjHUXzdmu4kQzojicAW44Ghqe2GdicaUBhAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot; title=&quot;腾讯大厦的经纬度&quot;/&gt;&lt;figcaption&gt;腾讯大厦的经纬度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这样，我们就找出了上海腾讯大厦的经纬度是 （31.1688749, 121.3975184）&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2. 将经纬度按照二分算法变成01二进制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;上海腾讯大厦的经纬度是 （31.1688749, 121.3975184）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;将纬度范围(-90, 90)平分成两个区间(-90, 0)、(0, 90)， 如果目标纬度位于前一个区间，则编码为0，否则编码为1。&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于31.1688749属于(0, 90)，所以取编码为1。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后再将(0, 90)分成 (0, 45), (45, 90)两个区间，而31.1688749位于(0, 45)，所以编码为0。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;然后再将(0, 45)分成 (0, 22.5), (22.5, 45)两个区间，而31.1688749位于(22.5, 45)，所以编码为1。&lt;br/&gt;….&lt;br/&gt;….&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;依次类推可得上海腾讯大厦纬度编码为：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python language-python hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;101011000101010000111101101101&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经度也用同样的算法，对(-180, 180)依次细分，(-180，0)、(0,180) ，得出编码为：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python language-python hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;110101100101001110111110011010&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们用php代码来具体实现一下这个算法：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;&lt;br/&gt;$minLat = &lt;span class=&quot;hljs-number&quot;&gt;-90&lt;/span&gt;;&lt;br/&gt;$maxLat = &lt;span class=&quot;hljs-number&quot;&gt;90&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;$minLng = &lt;span class=&quot;hljs-number&quot;&gt;-180&lt;/span&gt;;&lt;br/&gt;$maxLng = &lt;span class=&quot;hljs-number&quot;&gt;180&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;$latLength = $lngLength = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;$latList = $lngList = [];&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;$originPrecision = &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; ($latLength &amp;lt; $originPrecision) {&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ($lat &amp;gt;= $middle = ($minLat + $maxLat) / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) {&lt;br/&gt;        $latList[] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;        $minLat = $middle;&lt;br/&gt;    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;        $latList[] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;        $maxLat = $middle;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    $latLength++;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; ($lngLength &amp;lt; $originPrecision) {&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ($lng &amp;gt;= $middle = ($minLng + $maxLng) / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) {&lt;br/&gt;        $lngList[] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;        $minLng = $middle;&lt;br/&gt;    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;        $lngList[] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;        $maxLng = $middle;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    $lngLength++;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;var_dump(implode(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;, $latList), implode(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;, $lngList));&lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;3. 偶数位放经度，奇数位放纬度&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过二分算法，我们得到了腾讯大厦的纬度和经度的二级制串为：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;string(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;101011000101010000111101101101&quot;&lt;/span&gt;&lt;br/&gt;string(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;110101100101001110111110011010&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在需要按照”偶数位放经度，奇数位放纬度”，将这2个数字串，合二为一。那么这个到底怎么理解呢？我刚开始不理解到底怎么操作，后来经过一系列的思考，可以如下操作：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEElmTyK3ico0I27INyZBcOCxoXUNnR70hMLfepJBdzXVXf0VibPBSRMrg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1894&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;621.1505376344086&quot; data-ratio=&quot;0.328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasWzBccgzEFxM7coT4Hu5WErArzxU3wklYDZ45YU39J15q8gPzzbbO1KT3lVSj5lyDaEOVEicndLGA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; title=&quot;偶数位放经度，奇数位放纬度&quot;/&gt;&lt;figcaption&gt;偶数位放经度，奇数位放纬度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;由于无法用文字表述，我截了个操作图，如图上的箭头操作顺序所示，就是把纬度往右移动一个位置，然后依次串起来。&lt;/p&gt;&lt;p&gt;用php代码实现，或许看起来更好理解：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;&lt;br/&gt;$stringList = &lt;span class=&quot;hljs-string&quot;&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ($i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; $i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;; $i++) {&lt;br/&gt;    $stringList .= $lngList[$i];&lt;br/&gt;    $stringList .= $latList[$i];&lt;br/&gt;}&lt;br/&gt;var_dump($stringList);&lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，合并之后，我们得了一个60个字符长度的的二进制数字串：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;string(&lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;111001100111100000110011000110101000111111111001011011011001&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;4. 二进制转换成十进制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们把这个60位的二进制，按照从左往右，每5位划分成1个组，最后一组如果不足5位就用0补齐到5位。划分后如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;11100&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;11001&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;11100&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00011&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00110&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00110&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10100&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;01111&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;11111&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00101&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10110&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;11001&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，把分好的二进制，转换成十进制：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt; &lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用php实现也很简单：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;$stringList = &lt;span class=&quot;hljs-string&quot;&gt;&quot;111001100111100000110011000110101000111111111001011011011001&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;$stringListLen = strlen($stringList) / &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;$code = [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ($i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; $i &amp;lt; $stringListLen; $i++) {&lt;br/&gt;    $code[] = bindec(substr($stringList, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; * $i, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;var_dump(implode(&lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;,$code));&lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;5. 匹配对应base32表算法的所在位置&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;base32表是用0-9、b-z（去掉a, i, l, o）这32个字母进行组合的编码集合，base-32如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0123456789&lt;/span&gt;bcdefghjkmnpqrstuvwxyz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了更好理解和一一对应，我们把base32各个字符的位置信息和它的字符串用表对应起来：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.25960482985729966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEe87dugnb4s5zY6gglh6XyVIKBcTUVU5XqoCj0wria7XicXa8oiaTSSvXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;所以， &lt;code&gt;28 25 28 3 6 6 20 15 31 5 22 25&lt;/code&gt; 对应上面的表的位置就得到了，是：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;wtw366ngz5qt&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样，我们也用php算法来实现一下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;&lt;br/&gt;$base32Code = &lt;span class=&quot;hljs-string&quot;&gt;&quot;0123456789bcdefghjkmnpqrstuvwxyz&quot;&lt;/span&gt;;&lt;br/&gt;$encodeString = &lt;span class=&quot;hljs-string&quot;&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; ($code as $value) {&lt;br/&gt;    $encodeString .= $base32Code{$value};&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;var_dump($encodeString);&lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，最后我们得到了，上海腾讯大厦的经纬度&lt;code&gt;（31.1688749, 121.3975184）&lt;/code&gt; 对应的 geohash 为 &lt;code&gt;wtw366ngz5qt&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;geohash 的精度问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;geohash其实表示的是一个矩形的块状区间，它总共分成最大12个字符串，也就是表示从 1-12 级。字符数越大，块区间就越小，那么定位就越精准。&lt;/p&gt;&lt;p&gt;我们刚才计算上海腾讯大厦的geohash采用的是12级，基本计算出来的位置就是毫秒级别了，可以说是非常的精准了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6157205240174672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEhY7Gg7icLMJAUnw4nd6UdIBxxG4kTLe7Z27XAjeH8uPicaCsLwqwMIEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1832&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上面是geohash字符串长度对应的区间精度，我们可以看到，当geohash为12位时，表示是37毫米范围的区间，已经是非常的精准了。当geohash为6位时，表示为1.2k米范围内的矩形位置。&lt;/p&gt;&lt;p&gt;所以，当2个定位的geohash 前7位是一样的时，表示他们在附近1.2km的范围内。&lt;/p&gt;&lt;p&gt;那我们还是用腾讯大厦的geohash值，分别截取经度为前7，6，5位看看，在地图上是怎么样的：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7325949367088608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WE7ibysn5Ugibt3U3LcYPXad5HbMx5qz6UBIcDxcXKuZBJzBAxr55gKneQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot; title=&quot;精度为7，153m范围内&quot;/&gt;&lt;figcaption&gt;精度为7，153m范围内&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6705385427666315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEoSc8GBa4PReQRMeMibU5gtH8icYdZia2yFp1LrOCKqShaBFERTCUB0wPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1894&quot; title=&quot;精度为6，1.22km范围内&quot;/&gt;&lt;figcaption&gt;精度为6，1.22km范围内&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7077818951826363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WE0Yen4QXK6hhEibvMha0oRJicXFfe7ZLupKpdVjjXPKGVkZzsDgWgs6jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1889&quot; title=&quot;精度为5， 4.89km范围内&quot;/&gt;&lt;figcaption&gt;精度为5， 4.89km范围内&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;所以，根据上面的图，随着字符越来越少，精度越来越小，这个矩形也越来越大，&lt;strong&gt;这一整块区间都共用一个geohash来表示&lt;/strong&gt;。在实际应用中，我们就可以动态的调整精度，实现更大或者更小范围内的搜索，既能精准定位，又可以隐藏住一个地点的具区位信息。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;geohash存在的边界问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;由于geohash表示的是一个区块信息，在同一个区块里的2个位置，它会认为是最近的，然而，其实更近的位置可能刚好在另一个区间，这样就造成了不匹配的问题。这就存在一个边界问题。&lt;/p&gt;&lt;p&gt;我们用实际例子来看。我们想找腾大附近1.5km范围内的便利店，我们选取geohash精度为6。园区有2家 A 和 B。B距离我们更近一点，但是，由于A 和腾大在一个hash区块内，所以，就得出了A是最佳的选择。这就是边界的问题。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7403896787783044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WEc1bW8MljT6QXJbMmqLRSur6C6mtVIHXFCFM36ptQCkqicvlGmkQKHAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1899&quot; title=&quot;边界问题&quot;/&gt;&lt;figcaption&gt;边界问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;如何解决边界问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;那么如何解决这个边界问题，给出最近最优的算法方案呢？答案就是：把定位附近的8个方向的geohash都算出来。最后分别计算这些点和自己的距离（由于范围很小，点的数量就也很少，计算量就很少）过滤掉不满足条件的点就ok了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.7310746426680783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasWzBccgzEFxM7coT4Hu5WETE00gjPxgbQAUucwbXjnY7GMM0C20ib56IUGUiayHa1lg6uR25V1AtvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1889&quot; title=&quot;8个geohash都算出来&quot;/&gt;&lt;figcaption&gt;8个geohash都算出来&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;计算两点距离的计算&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;通过余弦定理以及弧度计算方法，最终推导出来的算式A为：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;$s = acos(cos($radLat1) * cos($radLat2) * cos($radLng1 - $radLng2) + sin($radLat1) * sin($radLat2)) * $R;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目前大多使用的是Google公开的距离计算公司，推导算式B为：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;$s = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*asin(sqrt(pow(sin(($radLat1-$radLat2)/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;),&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)+cos($radLat1)*cos($radLat2)*pow(sin(($radLng1-$radLng2)/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;),&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)))*$R;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 : &lt;/p&gt;&lt;p&gt;用PHP实现一下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php language-php hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getDistance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;($lat1, $lng1, $lat2, $lng2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    $R = &lt;span class=&quot;hljs-number&quot;&gt;6378137&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    $radLat1 = deg2rad($lat1);&lt;br/&gt;    $radLat2 = deg2rad($lat2);&lt;br/&gt;    $radLng1 = deg2rad($lng1);&lt;br/&gt;    $radLng2 = deg2rad($lng2);&lt;br/&gt;    &lt;br/&gt;    $s = acos(cos($radLat1)*cos($radLat2)*cos($radLng1-$radLng2)+sin($radLat1)*sin($radLat2))*$R;&lt;br/&gt;    &lt;br/&gt;    $s = round($s* &lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;)/&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;;&lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;  round($s);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getDistanceByGoogle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;($lat1, $lng1, $lat2, $lng2)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//地球半径&lt;/span&gt;&lt;br/&gt;    $R = &lt;span class=&quot;hljs-number&quot;&gt;6378137&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//deg2rad()函数将角度转换为弧度&lt;/span&gt;&lt;br/&gt;    $radLat1 = deg2rad($lat1);&lt;br/&gt;    $radLat2 = deg2rad($lat2);&lt;br/&gt;    $radLng1 = deg2rad($lng1);&lt;br/&gt;    $radLng2 = deg2rad($lng2);&lt;br/&gt;    $a = $radLat1 - $radLat2;&lt;br/&gt;    $b = $radLng1 - $radLng2;&lt;br/&gt;&lt;br/&gt;    $s = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * asin(sqrt(pow(sin($a / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) + cos($radLat1) * cos($radLat2) * pow(sin($b / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;))) * $R;&lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; $s;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;geohash 在redis中的实现&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;redis在 &lt;code&gt;3.2.0&lt;/code&gt;中加入了geo相关的命令，对geohash的支持。&lt;/p&gt;&lt;p&gt;redis中经纬度使用52位的整数进行编码，放进zset中，zset的value元素是key，score是GeoHash的52位整数值。在使用redis进行Geo查询时，其内部对应的操作其实只是zset(skiplist)的操作。通过zset的score进行排序就可以得到坐标附近的其它元素，通过将score还原成坐标值就可以得到元素的原始坐标&lt;/p&gt;&lt;p&gt;redis中处理这些地理位置坐标点的思想是: 二维平面坐标点 —&amp;gt; 一维整数编码值 —&amp;gt; zset(score为编码值) —&amp;gt; zrangebyrank(获取score相近的元素)、zrangebyscore —&amp;gt; 通过score(整数编码值)反解坐标点 —&amp;gt; 附近点的地理位置坐标。&lt;/p&gt;&lt;p&gt;redis 中有6个命令，对地理位置的算法支持，可以去redis官网具体查看其用法 : https://redis.io/commands#geo&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;GEOADD&lt;br/&gt;GEOPOS&lt;br/&gt;GEODIST&lt;br/&gt;GEORADIUS&lt;br/&gt;GEORADIUSBYMEMBER&lt;br/&gt;GEOHASH&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;其他资料&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;更多内容可以戳我们的「腾讯技术」知乎专栏：&lt;/section&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/90889887&quot; target=&quot;_blank&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvast9Hxnic4Lyx4N1ZU4c6iaDMRHvLVhZicZBjdAJsiaRcVUPCd0FP9LTtFGFicQzfbUwPZqYTWk5cRicpcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>