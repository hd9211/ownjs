<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>259ad0b59bc92cc81e7b2680e89d8433</guid>
<title>【大内存服务GC实践】- 一文看懂G1GC垃圾回收器</title>
<link>https://toutiao.io/k/fio8ane</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;笔者在这个系列的第一篇文章&lt;/span&gt;&lt;span&gt;《一文看懂&quot;ParNew+CMS&quot;垃圾回收器》&lt;/span&gt;&lt;span&gt;中详细介绍了&quot;ParNew+CMS&quot;垃圾回收器的工作原理。文章最后笔者提到CMS垃圾回收器有两个比较显著的问题，一个是长时间运行无法避免Full GC，一个是Remark阶段STW时间较长。正是因为这两个问题的存在，CMS垃圾回收器在JDK9被标记弃用，慢慢开始退出历史舞台。有走的，就有来的，JVM重新设计了另一款垃圾回收器G1，有效地解决了CMS垃圾回收器遇到的上述两大问题。那么，这篇文章我们就详细探讨一下G1垃圾回收器是如何解决上述两大问题的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;和上篇文章介绍&quot;ParNew+CMS&quot;垃圾回收器一样，笔者会从G1垃圾回收器最基础的数据结构和算法出发，深入分析它的工作原理，对其中的一些关键机制进行剖析。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;G1核心数据结构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. Region&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;为什么CMS垃圾回收器长时间运行无法避免FGC？本质是因为CMS垃圾回收器中老年代采用标记清理算法，这种算法会产生较多内存碎片，当内存碎片很碎无法给对象分配出连续空间的时候，JVM就会触发FGC整理老年代。那有些同学就会问为什么不在每次老年代GC的时候执行整理操作呢？这主要是因为老年代如果很大的话，整理一次STW的时间会不可控。那怎么破这个局呢？JVM设计者提出了一个思路：&lt;/span&gt;&lt;span&gt;老年代不是很大吗，那就将老年代划分成很多小的格子，在此基础上GC算法基本不变，还是先标记，不过在标记完成后，按照优先级选择部分格子使用复制算法进行整理，这样每次整理的内存空间是可控的，STW的时间就相对可控，而且因为使用复制算法就不再会出现内存碎片。对，这就是G1垃圾回收器的核心设计思想。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1 是一个分代回收器，它依然保留了&quot;ParNew+CMS&quot;垃圾回收器中新生代和老年代的分代逻辑。但与&quot;ParNew+CMS&quot;回收器不同的是，它引入了一个新的数据结构 - Region，也就是上文中笔者提到的小格子。G1垃圾回收器会把整个堆划分成一个个大小相等的Region，每个Region的大小可以通过参数设置，通常大小在1~32M之间，默认大小取决于总堆的大小。下图是G1回收器堆划分的示意图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.584&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7V31D1DuulGjuLKpGb8ibWBNa606rM79FO963TatEyNUSzRkea0wxibRw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中整个堆区会被划分为新生代以及老年代，其中新生代又分为Eden区和Survivor区，这和&quot;ParNew+CMS&quot;回收器是相同的。不同的主要有两点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）G1回收器不要求新生代或者老年代的Region连续分布，换言之，这些Region可以随意分布在整个堆区，它和新生代或者老年代的隶属关系属于逻辑隶属。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）如果一个对象大小超过Region大小的一半，就会被视为巨型对象（Humongous Object），巨型对象会被分配到Humongous Region。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. RememberedSet（RSet）和Card Table&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;《一文看懂&quot;ParNew+CMS&quot;垃圾回收器》&lt;/span&gt;&lt;span&gt;文章在介绍对象标记的时候重点说明了一个对象跨代引用的问题。比如YGC阶段标记新生代对象的时候，不仅需要扫描GC Roots标记其直接引用的新生代对象，还需要扫描所有老年代对象，查看其是否引用了新生代对象，如果引用了的话，对应新生代对象也是需要标记的，否则就会发生漏标。然而实际实现中，扫描整个老年代对象的代价相当大。文章中我们介绍了可以通过Card Table这种数据结构大幅降低扫描老年代对象查找跨代引用的代价，简单来说，就是通过写屏障技术在老年代对象引用新生代对象的时候将Card Table对应Card设置成&quot;脏卡&quot;，这样的话，查找跨代引用，只需要扫描Card Table脏卡对应的老年代区域，而不需要扫描整个老年代，大大降低了扫描代价。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据上文介绍，G1也是一个分代回收器，也需要处理跨代引用扫描代价大的问题。为了解决这个问题，G1引用了另一种新的数据结构 - Remembered Set，简称RSet。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2.1 RSet是什么样的数据结构呢？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在G1实现中，每个Region会被划分成很多512Byte大小的小块，这样一个32M的Region就会被划分为65536个小块。与之大小对应的会有一个长度为65536的Card Table数组，数组的每个元素只有1Byte，对应Region的每个小块。Card Table数组这个结构和CMS垃圾回收器中Card Table是相同的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了Card Table数组之外，每个Region还会有一个RSet数据结构，RSet主要用来记录哪个Region的哪个Card上的对象引用了本Region中的对象。实际实现中，RSet默认是一个HashMap，Map的key是引用Region，value是一个List，List中存储引用Region中的引用Card列表。Region、Card Table以及RSet的示意图如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38671875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7WoADaHdp3CtC46djM3gPUd7VCFPyvOLr7Gb5SY8ZyvBnzCjJQ5iblkg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中，RegionA和RegionB中分别有对象引用RegionC中的对象，在RegionC对应的RSet就会记录这样的引用关系。该RSet中有两个KV对，第一个KV对的key是RegionA，value是一个列表，列表中有两个元素3和65534，分别代表RegionA中引用对象在对应Card Table中的下标。第二个KV对的key是RegionB，value中列表只有一个元素1565，代表RegionB中引用对象在对应Card Table中的下标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;介绍到这里，大家应该对RSet的结构有了初步的了解。与CMS回收器中Card Table相比，Card Table中的脏卡代表&quot;我引用了别的对象&quot;，属于一种points-out结构。而RSet记录的是哪些其他Region引用了本Region中的对象，属于points-into结构。两者是有本质区别的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照上述介绍，如果一个Region是热点Region，表示这个Region中的对象被大量其他Region中的对象所引用，那么RSet占用的内存空间开销就会越大。但我们要清楚一点，RSet内存开销不是为业务服务的，实际上不应该占用太多。因此为了控制RSet占用内存空间的大小，RSet会根据引用Region个数的多少，设置3种不同的实现方式（上文中介绍的是其中一种），分别称为：&lt;/span&gt;&lt;/section&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;sparse per-region-table (PRT)，从字面意思来看表示这个RSet是一个稀疏的集合。具体实现使用HashMap方式记录引用关系，其中Map的key是引用Region，value是一个List，List中存储引用Region中的引用Card列表。上文有过介绍。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;fine-grained PRT，还是使用HashMap方式记录引用关系，其中Map的key是引用Region，但value不再是List，而是一个bitmap，bit位为1表示对应Card是引用Card，否则不是引用Card。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;coarse-grained bitmap，从字面意思可以看出来这就是一个bitmap，不过bitmap中每个bit位引用粒度不再是Card，而是Region。如果bit位值为1，表示这个Region是引用Region，即这个Region中有对象引用了该Region中的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;很显然，上述3种实现方式中，spase PRT和fine-grained PRT都是精确到Card，而coarse-grained bitmap是精确到Region。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;2.2 G1是如何管理RSet的？&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1会创建一个用于管理RSet的线程池，这些线程称为Refine线程。G1中RSet的更新不是同步完成的，G1会把所有引用关系都先放入一个队列中，称为Dirty Card Queue（DCQ），然后使用Refine线程来消费这个队列完成引用关系的记录并更新RSet。如果Refine线程忙不过来，GC线程以及应用线程也可能会协助更新RSet。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;G1核心工作流程&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在介绍G1垃圾回收器工作流程之前，先简单回顾一下&quot;ParNew+CMS&quot;回收器的工作流程，具体流程不再赘述，参考下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7MYFIIJtOVn7IRj1HmSiaMibOZ9fuWriaibAhEm4Yj7ZbeJWHlax21f2kdg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1回收器核心工作流程与&quot;ParNew+CMS&quot;回收器基本相同，参考上图看下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.421875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd75561RchITIS4syKIa5581cbu89icPvIsp9ben0IdhnhOELs2vwd47uw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对比&quot;ParNew+CMS&quot;回收器工作流程，G1中同样会比较频繁地进行新生代YGC，同样也有老年代并发标记周期。不同的是，G1在并发标记之后并没有直接清理全部垃圾对象，而是新增了一个混合收集周期，这个周期包含多次Mixed GC，每次Mixed GC只会回收部分Region，直至未处理Region集合占比低于特定阈值。之所以将这个周期称为&quot;Mixed Collection Cycle&quot;，是因为每次Mixed GC都会同时回收新生代和老生代中的Region。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中，IHOP(InitiatingHeapOccupancyPercent) Trigger代表&quot;并发标记周期&quot;触发的阈值。一旦当前JVM已使用内存/总堆内存超过这个阈值，就会触发并发标记。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然G1回收器的工作流程和&quot;ParNew+CMS&quot;回收器差的不是很多，但是每个核心步骤的具体实现却有很大的不同。接下来分别来看G1中的YGC、Concurrent Marking Cycle以及Mixed GC的一些核心实现细节。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;1. Young GC核心流程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;和&quot;ParNew+CMS&quot;一样，一旦Eden区满了之后，就会触发YGC。YGC只负载回收堆中新生代的所有Region，不回收老年代的Region。基本流程可以表示为如下几步：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）将eden区和survivor区所有Region添加到CSet中准备回收。注：CSet是一个存放待回收Region的数据结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）标记阶段&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从GC Roots开始标记直接引用的新生代对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于RSet标记跨代引用的新生代对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;（3）复制阶段：将标记活跃的对象复制到其他Region中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了更加清楚的明白上述步骤，下图是一次真实的YGC日志片段，可以对照着上述流程来看。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51953125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7t4y7ib4pvXw1uQI5JJ4PCA19RmXEibjoKyibFuo7BKQUefxOqxaIR9ib5Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1在日志的细节上比&quot;ParNew+CMS&quot;要详细很多，如果研究G1的话，日志是一个非常不错的研究入口。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2. Concurrent Marking Cycle核心流程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;根据上文介绍，一旦&quot;JVM已使用内存/总内存&quot;的比例超过设定阈值IHOP（InitiatingHeapOccupancyPercent）后，G1会执行一次Concurrent Marking Cycle，并在之后进行多轮Mixed GC。和CMS回收器基本一样，G1中一轮并发标记周期包含初始标记、并发标记、重新标记，再加上一个cleanup阶，这样就可以完成整堆所有Region的对象标记。下面是一段G1回收器中并发标记周期的完整日志：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8796875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7daMdUdiaZ3WK1jgfL9kGjlcyHQXC68ZT13sia5p6Gia4GkynfJPLG7kgw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始标记（Initial Marking）：初始化标记是伴随一次普通的YGC发生的，从GC Root开始标记直接可达的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并发标记( Concurrent Marking)：这个阶段标记线程和应用线程并发工作，遍历整堆所有可达对象并标记。这个阶段需要特别关注并发标记可能产生的&quot;漏标&quot;问题，G1使用Snapshot AT Begining（简称SATB）算法避免漏标问题发生，这和CMS完全不同。3.4小节深入介绍。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;重新标记( Remark) ：标记那些在并发标记阶段发生变化的对象,将被回收。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;清理( Cleanup )：释放没有存活对象的Region。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3. Mixed GC核心流程&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;一轮并发标记之后紧接着是混合回收周期，包括多次Mixed GC，每次Mixed GC只回收部分Region。这里有三个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）为什么这些Region需要分为多次回收？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;主要原因是所有Region一起回收的话有可能会导致暂停时间比较长，尤其在内存较大的情况下。为了每次回收的暂停时间可控，就将一次大回收分成很多次小回收。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）每次回收Region集合的选择原则是什么？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在执行混合回收之前，G1会将所有Region按照每个Region中垃圾对象占比进行一次排序，垃圾对象占比越高，排名越靠前。排好序之后，每次Mixed GC按顺序选择部分Region进行回收，选择多少Region取决于这些Region的回收预估暂停时间不超过设置的最大暂停时间。这个回收算法称为Garbage First，也就是G1的意思。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（3）每次Mixed GC的过程是怎么样的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的回收过程和上文中介绍的Young GC没有太大区别，可以参考上文介绍。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;4. 并发标记阶段对象&quot;漏标&quot;问题解法 - SATB算法&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在介绍SATB算法之前，先简单介绍一下并发标记过程中可能出现的对象&quot;漏标&quot;问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.1 对象漏标简介&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;什么是对象漏标？就是本应该被标记为活跃的对象因为某些原因最终没有被标记，被垃圾回收器认为是垃圾对象而回收掉，最终导致应用错误，很显然这种情况是不允许发生的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并发标记阶段什么场景下会发生对象漏标？应用线程和标记线程并发执行，在下面两种场景下会出现漏标：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 应用线程在并发标记过程中新生成的活跃对象因为某些原因没有被标记线程标记。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 应用线程在并发标记过程中变更引用关系的时候在特定场景下会出现漏标，具体场景涉及标记算法&quot;三色标记法&quot;，详细可以阅读文章《【大内存服务GC实践】- 一文看懂”ParNew+CMS”垃圾回收器》。这里只简单进行描述：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6053882725832013&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd71JwLKervUHfePuicJlY7Rfu4ntXWJu2uhgl0owoFGUUBT3PNVC0uy8w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，老年代中有三个对象A、B和C，在标记之前的引用关系是A引用B，B引用C。先分别介绍一下他们的标记情况：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象A已经被标记为黑色，表示为A为活跃对象且所有它引用的对象也完成标记。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象B被标记为灰色，表示B对象是活跃对象，但是它关联的对象还没有被完全标记完。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象C是白色，表示还没有被标记。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这种背景下，应用线程此时发生了一次引用关系变更，B引用C的关系被删除了且同时A引用了C，即如下所示代码：&lt;/span&gt;&lt;/section&gt;&lt;pre data-wrap=&quot;true&quot;&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;objB.fieldC = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;objA.filedC = C;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此时，标记线程就不再会标记对象C，因为对象A已经是黑色，表示所有它引用的对象都已经完成标记。然而实际上活跃的对象C就会被漏标最终被回收掉。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.2 SATB算法思想简介&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;对象漏标介绍之后简单介绍一下SATB算法的基本思想，可以概括为如下三句话：&lt;/span&gt;&lt;/section&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并发标记之前先给Region内存打个快照，标记线程基于这个快照独立进行标记。应用线程不会直接修改这个快照中的对象，也就是说应用线程不会干扰标记线程的工作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用线程新分配的对象都认为是活跃对象，实际在下一个并发标记周期进行标记。上文说过漏标发生的第一种场景是&quot;应用线程在并发标记过程中新生成的活跃对象因为某些原因没有被标记线程标记&quot;，那如果能够将标记阶段新分配的对象全都集合到一起，这些对象全部都标记为活跃对象（实际肯定会有部分垃圾对象，将垃圾对象标记为活跃对象不影响程序正确性）就可以解决这个问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并发标记过程中已存在对象的引用关系变更在Remark阶段单独进行处理。上文介绍了漏标发生的第二种场景，为了解决这个场景引入的漏标问题，可以将引用关系变更分解为旧的引用关系先删除，新的引用关系生成两个步骤，只要破坏任何一个步骤就可以防止漏标发生。因此有两种针对性解法：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在并发标记阶段如果有新引用关系生成，就记录下来，Remark阶段进行重标记，这个破坏了步骤二，即黑色对象重新引用了白色对象，就记录下来重新扫描黑色对象，将其引用的所有对象都标记成存活对象。这个就是CMS垃圾回收器使用的增量更新算法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在并发标记阶段如果有引用关系被删除，就记录下来，Remark阶段对这些引用关系被删除的重标记，这个破坏了步骤一，即灰色对象断开了白色对象引用的时候，记录下来，后面重新把这个白色对象标记成存活对象。这个就是G1垃圾回收器使用的算法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单来说，SATB明确将并发标记这一个大工程分成了三个字模块，分别是对快照进行并发标记、对并发标记过程中新分配的对象全部标记为活跃、对并发标记过程中引用关系变更的对象单独进行处理。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.3 SATB算法实现&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;了解了SATB算法的核心思想之后，再来看看这个算法是如何实现的。G1回收器将堆内存分成一个一个Region，在Region中分配对象时，对象都是连续分配的。这里介绍两个指针：Bottom指针和Top指针，其中Bottom指针指向Region的初始位置，Top指针指向下一个对象分配的内存位置，如果有新的对象分配，就将Top指针向前移动。如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.615686274509804&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;510&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7SbgkJvPgvuqVQyNv3dFfCgZkjIAy9Y4HRnOegV5vp8V5yzYdNicGhGA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1使用的SATB算法是基于内存快照的，那SATB算法具体怎么实现基于内存快照的标记呢？现在假设在标记之前Region如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23556231003039513&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd78ib0N8xZBsywicVb5picxHRZJQb87ZWRyWFu4VyWBNGXDGtrv4kf3xaqQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这个时候要进行一轮完整的并发标记周期，按照上面的说法是要先给这个Region打个快照，这个快照实际上就是[Bottom, Top)现在这块内存区域。但是在并发标记周期内，因为有引用线程在分配对象，所以Top指针肯定会往前移动，所以为了将标记开始前Top这个位置记录下来，需要定义另一个指针TAMS（全称Top-At-Mart-Start）指向标记前Top这个位置，从Top-At-Mark-Start这个字面含义就可以理解是标记开始时Top指针所在位置，这样快照所代表的内存区域就是[Bottom, TAMS)这块，并发标记过程中标记线程就基于这块内存对象进行标记，后面Top指针就可以随意往前移动了。所以按照正常的逻辑应该是这样：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5485362095531587&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7mT6oJdwTZ1twOnOoicnseW6TlazrI0ymPLuxvx9AgsrJrpf5ibvia3qiag/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上图中Initial Marking刚开始的时候，Top指针和TAMS指针指向同一个内存位置，[Bottom, TAMS）这块内存区域有一个对应的bitmap，bitmap中每一位代表对应内存区域对象是否存活。经过并发标记之后，Remark开始的时候，Top指针因为应用线程有分配对象所以会向前移动，并发标记线程独立标记[Bottom, TAMS)这块内存区域对应的对象，标记后的结果使用bitmap表示（其中黑色方块表示对应对象被标记为活跃对象）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在并发标记过程中新生成的对象都分配在[TAMS, Top) 这块内存区域，G1算法会将这部分新生成的对象都认为是存活对象，这轮标记不处理这部分新生成对象，留到下一轮标记处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在继续来看SATB算法如何处理并发标记过程中引用关系变更问题。在并发标记阶段，引用变更发生后通过写屏障会将这些变更记录并保存在一个队列里（&lt;/span&gt;&lt;code&gt;&lt;span&gt;satb_mark_queue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），在remark阶段会扫描这个队列，通过这种方式，旧的引用所指向的对象就会被标记上，其子孙也会被递归标记上，这样就不会漏标记任何对象，snapshot的完整性也就得到了保证。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际上介绍到这里基本上已经将SATB算法实现介绍的比较清楚了。下图是完整的两轮并发标记示意图（摘自网上）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.6863636363636363&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;440&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7hZZ5upIGVeyYMnuwfFxiaqp9W9icHWGG5thFIj4jSAaFaHEnPL99QeBg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.4 SATB算法 vs Incremental Update算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;G1的SATB算法在Remark阶段不需要暂停遍历整堆对象，所以避免了这个阶段可能的长耗时。但是CMS垃圾回收器中增量更新算法因为无法知道哪些对象是并发标记阶段新增的，所以在Remark阶段需要重新扫描GC Roots标记整堆对象，这就可能带来不可控的长耗时暂停。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;全文总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;至此，笔者基本将G1GC的核心内容介绍完了。可以看到，G1相比CMS在很多地方都做了非常大的改动，整体思路还是比较清晰的。但是在具体实践中，因为G1的这种复杂性，导致想要用好G1，需要开发同学对其中各个参数的含义比较了解，并且要有一定的调优经验。尤其在一些大内存场景下，一旦参数调不好，很可能GC效果会非常差。因为笔者目前接触到的大数据系统都是大内存场景，所以在这些场景下用好G1，实际上还是需要不断地测试和调优。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>492648e91b5b0f73105be2abc7dbcc42</guid>
<title>2022 年升职加薪就靠它了！抓紧时间！</title>
<link>https://toutiao.io/k/i6bb1wf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;码农周刊是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;span&gt;码农周刊VIP会员&lt;/span&gt;」服务。&lt;br/&gt;&lt;strong&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何加入「码农周刊VIP会员」？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;391&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6elqZKJKdKVMrGKUKjLwPpIFaDmrXyf1iaRtelGc6Fm6W4vp1uEAbb7Nz7QuBzxXNW96CiauDAL3Aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如心动，赶快订阅吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac564c005bceb65428ebde9b1c6e7e56</guid>
<title>纳瓦尔宝典：财富和幸福指南.pdf</title>
<link>https://toutiao.io/k/br1y473</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff197705a203b7f27c53aa11e8448ab3</guid>
<title>Http缓存有什么最佳实践么？</title>
<link>https://toutiao.io/k/7qn4gpb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 &lt;code&gt;ConardLi&lt;/code&gt;，我又来给大家解读浏览器策略了，这次是缓存相关的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置缓存大家可能大家都是从性能角度去考虑的，但是如果你不注意或者稍微设置不当，缓存也可能对我们的网站的安全性和用户隐私造成负面影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开门见山&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老规矩，先把推荐的配置说出来，后面再啰嗦：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了防止中介缓存，建议设置：&lt;code&gt;Cache-Control: private&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建议设置适当的二级缓存 key：如果我们请求的响应是跟请求的 &lt;code&gt;Cookie&lt;/code&gt; 相关的，建议设置：&lt;code&gt;Vary: Cookie&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为啥推荐这两个配置呢？如果不配置会对我们的网站带来什么风险呢？且听我下面的讲解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回顾 HTTP 缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到缓存，大家可能很快就会想到两种缓存方式，以及对应的几个请求头，我们来快速回顾一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，我们的浏览器客户端会像服务器发起请求，然后服务器会将数据响应返回给客户端。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35242839352428396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iakP3DS0ibWqw7k2Hp2kR7azbWPceWUwW3oicQN3gIeTEJkFVdjGV90GTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一台服务器可能要对成千上万台客户端的请求进行响应，其中也有非常多是重复的请求，这会对服务器造成非常大的压力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.361890694239291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iamJ5gQe5N6wRQWVMs9Gxcy8E6P8HXRHqY9zzZicl1PFOia3hOV0CLe9ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以一般我们都会在客户端和服务器间进行一些缓存，对于一些重复的请求数据，如果之前的响应已经被存储到缓存数据库中，满足一定条件的话就会直接去缓存中取，不会到达服务器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34140969162995594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1ia6BiaFeghnKEcgyauhgdqR898NP2icB3yMJwicbIgibdSZCyH4M2uqLCuaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，HTTP 缓存一般又分为两种，强缓存和协商缓存：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;强缓存，在缓存数据未失效的情况下，客户端可以直接使用缓存数据，不用和数据库进行交互。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，判断请求是否失效主要靠两个 HTTP Header：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Expires&lt;/code&gt;：数据的缓存到期时间，下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Cache-Control&lt;/code&gt;：可以指定一个 &lt;code&gt;max-age&lt;/code&gt; 字段，表示缓存的内容将在一定时间后失效。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;协商缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协商缓存，顾名思义需要和服务器进行一次协商。浏览器第一次请求时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端比较成功，可以使用缓存数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断请求主要靠下面两组 HTTP Header：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Last-Modified&lt;/code&gt;：一个 &lt;code&gt;Response Header&lt;/code&gt;，服务器在响应请求时，告诉浏览器资源的最后修改时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;if-Modified-Since&lt;/code&gt;：一个 &lt;code&gt;Request Header&lt;/code&gt;，再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器会通过收到的 &lt;code&gt;If-Modified-Since&lt;/code&gt; 和资源的最后修改时间进行比对，判断是否使用缓存。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Etag&lt;/code&gt;：一个 &lt;code&gt;Response Header&lt;/code&gt;，服务器返回的资源的唯一标示&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;If-None-Match&lt;/code&gt;：一个 &lt;code&gt;Request Header&lt;/code&gt;，再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器会通过收到的 &lt;code&gt;If-None-Match&lt;/code&gt; 和资源的唯一标识进行对比，判断是否使用缓存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于缓存的常见误区&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的知识估计就是平时大家最常背到的，不过大家有没有认真想过一个问题？我们取到的缓存数据，一定缓存在浏览器里面吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上是不然的：资源的缓存通常是有多级的，一些缓存专门用于单个用户，一些缓存专用于多个用户。有些是由服务器控制的，有些是由用户控制的，有些则由中介层控制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6525198938992043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iaLhpyDhzc5Q30MQGFFw9oVAWWjFibKuvdIic5R1Iib2ia1gwTTwcticJfMUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2262&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;浏览器缓存：一般并专用于单个用户，在浏览器客户端中实现。它们通过避免多次获取相同的响应来提高性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地代理：可能是用户自己安装的，也可能是由某个中介层管理的：比如公司的网络层或者网络提供商。本地代理通常会为多个用户缓存单个响应，这就构成了一种“公共”缓存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;源服务器缓存/CDN。由服务器控制，源服务器缓存的目标是通过为多个用户缓存相同的响应来减少源服务器的负载。CDN 的目标是相似的，但它分布在全球各个地区，然后通过分配给最近的一组用户来达到减少延迟的目的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我们也经常会使用本地配置的代理，这些代理能够通过配置信任证书来缓存 &lt;code&gt;HTTPS&lt;/code&gt; 资源。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spectre 漏洞&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么缓存怎么会对我们网站的安全性和用户隐私造成威胁呢？我们来看一个非常有名的漏洞：&lt;code&gt;Spectre&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1ia1uwibW7rsBGtFVKF3ibL0hOKkiaLyGQicrIZF9ibPM3VR1icfJnEicXC0xSDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;攻击者可以利用 &lt;code&gt;Spectre 漏洞&lt;/code&gt; 来读取操作系统进程的内存，这意味着可以访问到未经过授权的跨域数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别是在使用一些需要和计算机硬件进行交互的 API 时：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SharedArrayBuffer (required for WebAssembly Threads)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;performance.measureMemory()&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JS Self-Profiling API&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，浏览器一度禁用了 &lt;code&gt;SharedArrayBuffer&lt;/code&gt; 等高风险的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个漏洞其实在我之前的多个文章中都有提到过，其实浏览器出过的很多安全策略都和它有关：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴对它具体的攻击原理感兴趣，通过几个 &lt;code&gt;JavaScript API&lt;/code&gt; 怎么做到越权访问数据的？这个下次我会专门出个文章来讲一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存是怎么影响 Spectre 的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 &lt;code&gt;Spectre&lt;/code&gt; 和缓存有啥关系呢？我们可以简单的这样理解下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们正常打开一个收到跨域限制的页面，肯定是获取不到数据的。但是如果我们的 &lt;code&gt;Cache-Control&lt;/code&gt; 设置为了 &lt;code&gt;Public&lt;/code&gt;，这份数据可能会被缓存到一个 &lt;code&gt;Public Cache&lt;/code&gt; 上（比如我们本地代理的 &lt;code&gt;Cache&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们是没有权限访问这个数据的，但是数据却被存到缓存数据库里了。一旦数据已经被存下来了，攻击者就可以利用 &lt;code&gt;Spectre&lt;/code&gt; 漏洞获取到这些缓存数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为啥利用 &lt;code&gt;Spectre&lt;/code&gt; 可以越权访问到这些缓存数据呢？我们来举个简单的小例子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们有个网站的登录密码是 &lt;code&gt;conardli&lt;/code&gt;，一个攻击者想要爆破我们的密码，假设我们的密码一定由小写字母组成，那攻击者也至少需要 26 的 8 次方次来猜出我们的密码。这是一个非常大的数字，几乎不可能爆破成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设，我们的密码存在了一块攻击者无权限访问到的内存里，然后攻击者自己又单独使用一块内存存储了所有的26个英文字母，并把这段内存设置为不可缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44754653130287647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1ia9Tmu8HBC4sAQcRC7kl0ice3TN7bcey0tbjptXCeaNQOiaRnVyRrdLWng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2364&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个时候，攻击者越界访问了我们密码的存储区域，访问到了 c 这个字母，但是由于权限问题，他肯定是访问不到的，会被计算机拒绝。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4204368174726989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iaThMM7ObCSu5ibJeOmKwtjD9icmGSgd7oM0aV8l6Aib5bjlYV5jNfla0hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2564&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是虽然访问不到，c 这个字母会被缓存起来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5821347464042392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iavTeBvHspSG6D85MUHf7qBO2OnjRvrBC0BVBLzgPZNabXzyiayib9IWibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2642&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，攻击者再回去遍历他那 26 个字母的内存，会发现，c 的访问速度变快了 ...&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4981549815498155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iaBrkiaBymE13LrWpJc9RPdVZKD9WYeaNpqvSKuv2LLnEpYzIPmRtpXBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2710&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你的密码第一个数字是 c ...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就简单讲一下，下篇文章我会专门来讲一下 &lt;code&gt;Spectre&lt;/code&gt; 漏洞，还是非常巧妙的 ... 感兴趣的小伙伴可以再留言区告诉我。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网站的建议配置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为上面的问题，我们建议对所有比较重要的网站数据做下面的两个配置：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;禁用 Public Cache&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置 &lt;code&gt;Cache-Control: private&lt;/code&gt;，这可以禁用掉所有 &lt;code&gt;Public Cache&lt;/code&gt;（比如代理），这就减少了攻击者跨界访问到公共内存的可能性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里注意，&lt;code&gt;private&lt;/code&gt; 这个值并不是一个独立的值，比如他是可以和 max-age 进行共存的，性能和 public 差不了多少，我们打开 Google 的网站来看一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3247663551401869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iac3npOhHUVmCquGUZ5KxLRibzwLicfwosa3nhyiaEDlWicCN5LBUbOASzQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置适当的二级缓存 key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，我们浏览器的缓存使用 URL 和 请求方法来做缓存 key 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着，如果一个网站需要登录，不同用户的请求由于它们的请求URL和方法相同，数据会被缓存到一块内存里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这显然是有点问题，我们可以通过设置 &lt;code&gt;Vary: Cookie&lt;/code&gt; 来避免这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户身份信息发生变化的时候，缓存的内存也会发生变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你的资源是一个大家都可以访问的公共 CDN 资源，那你的缓存当然是随便设置了，如果你的资源数据是比较敏感的，建议走上面这两个设置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://web.dev/http-cache-security/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://zhuanlan.zhihu.com/p/32784852&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家有在业务里设置过缓存吗？都是怎么设置的呢？有考虑过这个问题吗？欢迎在留言区告诉我。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;296&quot; data-ratio=&quot;0.5299270072992701&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/5Q3ZxrD2qNAwfITg4YV29uSdjzeu5TianfNF4GxRloxGjYnDmsXeLeaiaxc3JplwWTTlaDU8tr50srgXqHe3Gr4Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;685&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong/&gt;&lt;strong&gt;&lt;span&gt;彦祖，&lt;/span&gt;&lt;span&gt;点个&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;「在看」&lt;/strong&gt;&lt;span&gt;吧&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>33a461292fcba4f49f9dbcb4c88f2073</guid>
<title>对Go存严重误导，Go开发团队leader怒驳AWS</title>
<link>https://toutiao.io/k/dif57if</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5NzM0MjcyMQ==&amp;amp;action=getalbum&amp;amp;album_id=2042960611138928647#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2042960611138928647&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#aws&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;2个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650139642&amp;amp;idx=1&amp;amp;sn=d547a99ff986208e8130afa7a50e0b13&amp;amp;chksm=beda309489adb982fcc6079419235c67906372c1a6c141d62f837447b1a23fb5db73c74ffd75&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK8XHJPGghvOOjPGlt5aKtiaIjgs0LuJrft9aOylIpuU7h5KSFGVGdNYMcFFXfXmQo3xAZhjria14H5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;文 | 局长&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出品 | OSC开源社区（ID：oschina2013）&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;事件起因是 AWS 前几天发布的一篇博客：《Sustainability with Rust》。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38777292576419214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9dkbwY9iaicVjvJeFjBhicpDkiaRHggZ78WxhEIn0UsTH90DiaYQbwibql3UN4ZlLia47smicSJ2GTib1N4SA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1145&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;博客原文：&lt;span&gt;https://aws.amazon.com/cn/blogs/opensource/sustainability-with-rust/&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这篇文章里，AWS 举例的时候将 Rust 和 Go 进行了对比。文章提到了早期 Discord 的一项关键 Go 服务存在问题，原本这是一个非常简单的服务，但它的尾部延迟 (Tail Latency) 非常慢。AWS 认为原因在于 Go 是一种垃圾回收 (GC) 语言，因此当对象被创建和释放时，垃圾回收器每隔一段时间就需要停止程序的执行并运行一次垃圾回收。当垃圾回收器运行时，会导致进程无法响应请求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了解决此问题，Discord 决定尝试用 Rust 重写这个服务。测试结果显示，使用 Rust 重写后的速度提升超 10 倍，最慢的尾部延迟时间也降低至为原来的约 1%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是运行过程中 CPU 和响应时间的峰值，左边为 Go 实现的版本，右边为 Rust 实现的版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39043381535038935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9dkbwY9iaicVjvJeFjBhicpDkK6VGRibfMW55TyAujuCx1WBIk2PldLibyyBuS2k1nbCHFKkub1vFmwxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;899&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Go 开发团队 leader Russ Cox (rsc) 认为 AWS 在这里的比较对 Go 存在严重的误导。他认为，AWS 的文章将两者进行对比时，将 Go 版本的数据与在&lt;span&gt;使用新的数据结构和更多内存&lt;/span&gt;后的 Rust 版本数据放在了一起，还特意圈出“ms”和“µs”时间刻度。rsc 表示，这要么是 AWS 对 Discord 的原贴存在误解，要么就是公然地说谎。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为在 Discord 的原文中，他们展示 Go 服务器和同级别 Rust 服务器的对比时，图表数据来源既有原始的版本，也包括重写数据结构和提供额外内存后的情况。AWS 的文章却对此进行了故意的歪曲。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而且 AWS 引用的 Discord 数据当时使用的 Go 版本还是 Go 1.10，但现在 1.18 版本很快就推出了。在这 8 个重要版本的迭代过程中，Go 团队改进了许多功能，对因 GC 而引起的中断也提供了极大的改善（这正是当时 Discord 面临的问题）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了这个，rsc 认为 AWS 引用的一份“非常有趣”的研究的真实性也十分可疑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9191321499013807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9dkbwY9iaicVjvJeFjBhicpDkALFVAA1984s3tllJDXYVBwM4QrZs3EVngG8tnKSwrm2ibIxkcChqGsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;507&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9177820267686424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9dkbwY9iaicVjvJeFjBhicpDkbAm3qt67IR2bKjNnaLGq9WJzxvep2qhBflYuSLNcpQw2FshqWadOww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;523&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;rsc 表示，AWS 的文章对 Rust 的描述公正客观，但对 Go 却存在误导性的描述。他认为 Rust 和 Go 不是零和的博弈关系。Rust 十分优秀，所以他更愿意关注 Go 和 Rust 相互补充并进行良好合作的方式。比如这个案例：https://thenewstack.io/rust-vs-go-why-theyre-better-together/&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86032&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span data-brushtype=&quot;text&quot;&gt;往期精彩回顾&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86032&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9574468085106383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZP3JEv2BgJ7cx4oxeYNNqh2oytepen4zyw43jGnqXCiaAYWgK59RF4HTukPFrHF7FJarvFzETH87kr3It44zLmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;94&quot;/&gt;&lt;span&gt;觉得不错，请点个&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;呀&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>