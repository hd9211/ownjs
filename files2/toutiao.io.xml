<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ce296fb34058beaa93d36b4abba0f67e</guid>
<title>技术变化那么快，如何做到不被淘汰呢？</title>
<link>https://toutiao.io/k/8958dqc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;作为程序员，技术变化那么快，如何做到不被淘汰呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav94sFJmRfZmWtb6Z7heu46zN3fozSgjLyDuicyEokozKXKQ3YCagOicLcHDylwhnWMTWesHo5XaKIJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数位上市公司 CTO 都在订阅的「码农周刊 VIP 会员专属邮件周报」，了解一下？&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！还没加入的，抓紧时间啦！&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;260&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavibNJDoLvVWUq6RKn5LwtlzRHSMFBED29234hRwibmOzJF4XxKOv5lzRVCelQJIEIOaXh3vYRHOMRzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>84bbafa2cf7edfaa33b5b9940d905c56</guid>
<title>常见算法模版总结（一）</title>
<link>https://toutiao.io/k/m7uyc89</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/f93EtXu3Zk9TibJxSn9tLMfK37bcbQtgTXznNxWSfwp7FGx94fcczKB8YwbC3HctNntf3XDibgYQ6ibykpGa7c0xA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; title=&quot;日常&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;日常&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;鉴于leetcode刷题即使有了思路，代码也总是磕磕绊绊调试好久，也调不对……直到发现网上不少算法模版，原来模版像单词一样，是需要背的。背会了模版也许能事半功倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本篇文章233酱准备了二分法、排序、位运算的一些模版，欢迎小伙伴们交流指正，持续更新中&amp;gt;_&amp;lt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;二分法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;「二分查找」的思想是待搜索的数据元素满足一些&lt;strong&gt;二段性&lt;/strong&gt;（前面的一半不满足这段性质，后面的一半满足这个性质，如有序数组），能够通过中间元素&lt;/span&gt;&lt;code&gt;&lt;span&gt;arr[mid]&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和判断条件&lt;/span&gt;&lt;code&gt;&lt;span&gt;check(mid)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;将数据分为两半,目标值&lt;/span&gt;&lt;code&gt;&lt;span&gt;target&lt;/span&gt;&lt;/code&gt;&lt;span&gt;一定在符合条件的一半中。这样通过每次折半，查找的时间的复杂为O(logN)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设目标值存在闭区间[l,r]中，每次将区间长度缩小一半，当l=r时，就找到了目标值target。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;    &lt;span&gt;//区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;binarySearch1&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(l&amp;lt;r){&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = l +r &amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//如果mid满足了这个性质，target在区间[l,mid]中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(mid)) r=mid;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; l = mid + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//此时l==r,跳出后判断arr[r]是不是我们要的target即可&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; r;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//区间[l, r]被划分成[l, mid -1]和[mid, r]时使用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;binarySearch2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(l&amp;lt;r){&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = l + r+ &lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//如果mid满足了这个性质，target在右区间[mid,r]中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(mid)) l=mid;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; r = mid - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//此时l==r,跳出后判断arr[r]是不是我们要的target即可&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; r;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;check&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; mid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// mid是否满足我们区分二段性的条件&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上面两段模版代码&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;微妙的区别在于mid应该被划分在区间[l,mid] 还是 区间[mid,r]。前者在满足check条件下不断向左试探target，后者在满足条件的情况下不断向右试探target。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通过leetcodee34 来理解这两个模版代码。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;br/&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;br/&gt;如果数组中不存在目标值 target，返回 [-1, -1]。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目分析：&lt;/strong&gt;&lt;br/&gt;这道题让我们找到target的开始位置和结束位置，&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;Step1:找开始位置&lt;/span&gt;&lt;/code&gt; &lt;br/&gt;&lt;span&gt;从[l,r]中找到start,不断向左试探。更新r=mid，套用模版&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Step2:找结束位置&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;span&gt;Step1结束后如果 arr[r] == target,则说明r是target的开始位置&lt;br/&gt;继续二分[r,nums-1]：不断向右试探。更新l=mid，套用模版&lt;/span&gt;&lt;code&gt;&lt;span&gt;binarySearch2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整代码为：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] &lt;span&gt;searchRange&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; target&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;        result[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        result[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums.length == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;0&lt;/span&gt;, r = nums.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//Step1:从[l,r]中找到start,不断向左试探&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (l &amp;lt; r) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = l + r &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[mid] &amp;gt;= target) {&lt;br/&gt;                r = mid;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                l = mid + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums[r] != target) {&lt;br/&gt;            &lt;span&gt;//不存在目标元素&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;        result[&lt;span&gt;0&lt;/span&gt;] = r;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//Step2:从[r,nums.length-1]中寻找end，不断向右试探&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; L = r, R = nums.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (L &amp;lt; R) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; mid = L + R + &lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[mid] == target) {&lt;br/&gt;                L = mid;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                R = mid - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        result[&lt;span&gt;1&lt;/span&gt;] = L;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;排序算法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;排序算法的复杂度图表如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4548254620123203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9TibJxSn9tLMfK37bcbQtgTNt2zsC4BsmR5EeFGJeXWBnTQ5VBVxhxAADial7Ll2CX7T0zWurlUpfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;这里我准备了一下快速排序、堆排序和归并排序的模版。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;快速排序和归并排序都用了&lt;strong&gt;分治思想&lt;/strong&gt;，就是将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。通过将全局排序不断分解，局限在子问题内排序，减少了排序中不必要的重复比较操作。从而使平均复杂度降为O(nlogn)。不过在全局排序的分与合的策略上，两者有一些区别。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;快速排序&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;「快速排序」的思想是使用&lt;/span&gt;&lt;span&gt;分治法&lt;/span&gt;&lt;span&gt;（Divide and conquer）策略来把一个&lt;/span&gt;&lt;span&gt;序列&lt;/span&gt;&lt;span&gt;（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;quickSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[]nums,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (l&amp;gt;=r) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = l - &lt;span&gt;1&lt;/span&gt;, j = r + &lt;span&gt;1&lt;/span&gt;, partition = nums[l + r &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i&amp;lt;j){&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (nums[ ++ i] &amp;lt; partition);&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (nums[ -- j] &amp;gt; partition);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i&amp;lt;j) {&lt;br/&gt;                swap(nums,i,j);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;span&gt;//递推步骤&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//注意：分界区间是[l,j] 和 [j+1,r],因为如果r-l+1 = 偶数时，跳出循环时 i&amp;gt;j。此时j才是分区的位置&lt;/span&gt;&lt;br/&gt;        quickSort(nums,l,j);&lt;br/&gt;        quickSort(nums,j+&lt;span&gt;1&lt;/span&gt;,r);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[]nums,&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; temp = nums[i];&lt;br/&gt;        nums[i] = nums[j];&lt;br/&gt;        nums[j] = temp;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;归并排序&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;「归并排序」指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;mergeSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//终止条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (l&amp;gt;=r) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; mid = l+r&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//递推公式&lt;/span&gt;&lt;br/&gt;        mergeSort(nums,l,mid);&lt;br/&gt;        mergeSort(nums,mid+&lt;span&gt;1&lt;/span&gt;,r);&lt;br/&gt;&lt;span&gt;//合并过程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] temp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[r-l+&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; k =&lt;span&gt;0&lt;/span&gt;,i=l,j=mid+&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i&amp;lt;=mid &amp;amp;&amp;amp; j &amp;lt;= r){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[i]&amp;lt;= nums[j]) {&lt;br/&gt;                temp[k++] = nums[i++];&lt;br/&gt;            }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                temp[k++] = nums[j++];&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (i&amp;lt;=mid) temp[k++] = nums[i++];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (j&amp;lt;=r) temp[k++] = nums[j++];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; ( i=l,j=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=r;i++,j++){&lt;br/&gt;            nums[i] = temp[j];&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;堆排序&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;堆是一个近似&lt;/span&gt;&lt;span&gt;完全二叉树&lt;/span&gt;&lt;span&gt;的结构，并同时满足&lt;strong&gt;堆的性质&lt;/strong&gt;：即子节点的键值或索引总是小于（或者大于）它的父节点。&lt;br/&gt;如果先构建一个大顶堆，重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的&lt;/span&gt;&lt;span&gt;堆&lt;/span&gt;&lt;span&gt;维持最大堆性质，从而完成排序。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;heapSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//构建一个大顶堆&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; lastIndex = nums.length &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxParent = (lastIndex&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = maxParent;i&amp;gt;= &lt;span&gt;0&lt;/span&gt;;i--){&lt;br/&gt;            maxHeapify(nums,i,lastIndex);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//不断交换数组的最后面&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = lastIndex;i&amp;gt;&lt;span&gt;0&lt;/span&gt;;i--){&lt;br/&gt;            swap(nums,&lt;span&gt;0&lt;/span&gt;,i);&lt;br/&gt;            maxHeapify(nums,&lt;span&gt;0&lt;/span&gt;,i&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;maxHeapify&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums,&lt;span&gt;int&lt;/span&gt; parent,&lt;span&gt;int&lt;/span&gt; lastIndex)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; lChild = (parent&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+ &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rChild = lChild + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (lChild &amp;gt; lastIndex) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; maxChild = lChild;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (rChild &amp;lt;= lastIndex &amp;amp;&amp;amp; nums[rChild] &amp;gt; nums[lChild]) maxChild = rChild;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nums[maxChild] &amp;gt; nums[parent]) {&lt;br/&gt;            swap(nums,maxChild,parent);&lt;br/&gt;            &lt;span&gt;//需要继续判断换下后的父节点是否符合堆的特性&lt;/span&gt;&lt;br/&gt;            maxHeapify(nums,maxChild, lastIndex);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[]nums,&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; temp = nums[i];&lt;br/&gt;        nums[i] = nums[j];&lt;br/&gt;        nums[j] = temp;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;位运算&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我们看一下leetcode191如何运用上述性质。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;计算数字的二进制中有多少个1&lt;br/&gt;&lt;strong&gt;题目示例：&lt;/strong&gt;&lt;br/&gt;输入：00000000000000000000000000001011&lt;br/&gt;输出：3&lt;br/&gt;解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法一：&lt;/strong&gt;常规解法，如果n &amp;amp; mask != 0，说明n的右边第k位为1，则计数+1，mask左移一位。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hammingWeight&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; bits = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; mask = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;32&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((n &amp;amp; mask) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                bits++;&lt;br/&gt;            }&lt;br/&gt;            mask &amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bits;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法二：&lt;/strong&gt;令n=n&amp;amp;(n-1)，如果 n!=0，则说明去掉了最右面的1，则计数+1&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hammingWeight&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; bits =&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(n != &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            bits++;&lt;br/&gt;            n = n&amp;amp;(n&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bits;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考资料：&lt;br/&gt;[1].https://www.acwing.com/blog/content/277/&lt;br/&gt;[2].https://stackoverflow.com/questions/4678333/n-n-1-what-does-this-expression-do&lt;br/&gt;[3].维基百科&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bccb1c0eae68c74a781e97729b04ea6e</guid>
<title>我是如何把简单题目做成困难的？</title>
<link>https://toutiao.io/k/tt4iw77</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;作者：小漾&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;来源：https://github.com/suukii/91-days-algorithm&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 lucifer，众所周知，我是一个小前端 (不是) 。其实，我是 lucifer 的 1379 号迷妹观察员，我是一粒纳米前端。(不要回答，不要回答，不要回答！！！)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是第一次投稿，所以可以废话几句，说一下我为什么做题和写题解。刚开始做算法题的时候，只是纯粹觉得好玩，所以不仅没有刷题计划，写题解也只是随便记下几笔，几个月后自己也看不懂的那种。一次偶然机会发现了 lucifer 的明星题解仓库，是找到了 onepiece 的感觉。受他的启发，我也开始写些尽量能让人看懂的题解，虽然还赶不上 lucifer，但跟自己比总算是有了些进步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;身为迷妹观察员，lucifer 的 91 天学算法当然是不能错过的活动，现在活动的第二期正在 🔥 热进行中，有兴趣的同学了解一下呀。言归正传，跟着 91 课程我不再是漫无目的，而是计划清晰，按照课程安排的专题来做题，这样不仅更有利于了解某一类题涉及的相关知识，还能熟悉这类题的套路，再次遇见相似题型也能更快有思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话就这么多，以下是正文部分。等等，还有最后一句，上面的&quot;不要回答&quot;是个三体梗，不知道有没有人 GET 到我。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家带来一道力扣简单题，官方题解只给出了一种最优解。本文比较贪心，打算带大家用&lt;strong&gt;「四种姿势」&lt;/strong&gt;来解决这道题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;题目描述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目地址：https://leetcode-cn.com/problems/shortest-distance-to-a-character&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。&lt;br/&gt;&lt;br/&gt;示例 1:&lt;br/&gt;&lt;br/&gt;输入: S = &lt;span&gt;&quot;loveleetcode&quot;&lt;/span&gt;, C = &lt;span&gt;&#x27;e&#x27;&lt;/span&gt;&lt;br/&gt;输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]&lt;br/&gt;说明:&lt;br/&gt;&lt;br/&gt;字符串 S 的长度范围为 [1, 10000]。&lt;br/&gt;C 是一个单字符，且保证是字符串 S 里的字符。&lt;br/&gt;S 和 C 中的所有字母均为小写字母。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解法 1：中心扩展法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;思路&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是最符合直觉的思路，对每个字符分别进行如下处理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从当前下标出发，分别向左、右两个方向去寻找目标字符 &lt;code&gt;C&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只在一个方向找到的话，直接计算字符距离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个方向都找到的话，取两个距离的最小值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8395303326810176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaT5dytkaTd3zK4WoYWSQAUsoGEqk9wxiaEcdfsppScMqynm3Yq7GCiaDgcYlbBeUHW73gRpjHvE6niaicWkskyc8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;复杂度分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要对每一个元素都进行一次扩展操作，因此时间复杂度就是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -683 888 683&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; * 向两边扩展的总时间复杂度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而最坏的情况是目标字符 C 在字符串 S 的左右两个端点位置，这个时候时间复杂度是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，因此总的时间复杂度就是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N^2)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -833.9 2899.6 1083.9&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msup&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(955, 363) scale(0.707)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2510.6, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;代码&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript Code&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{string}&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{character}&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@return &lt;span&gt;{number[]}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; shortestToChar = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;S, C&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 结果数组 res&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; res = &lt;span&gt;Array&lt;/span&gt;(S.length).fill(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; S.length; i++) {&lt;br/&gt;    &lt;span&gt;// 如果当前是目标字符，就什么都不用做&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (S[i] === C) &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; l = i,&lt;br/&gt;      r = i,&lt;br/&gt;      shortest = &lt;span&gt;Infinity&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (l &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (S[l] === C) {&lt;br/&gt;        shortest = &lt;span&gt;Math&lt;/span&gt;.min(shortest, i - l);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      l--;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (r &amp;lt; S.length) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (S[r] === C) {&lt;br/&gt;        shortest = &lt;span&gt;Math&lt;/span&gt;.min(shortest, r - i);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      r++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    res[i] = shortest;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解法 2：空间换时间&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;思路&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为目标字符 &lt;code&gt;C&lt;/code&gt; 在 &lt;code&gt;S&lt;/code&gt; 中的位置是不变的，所以我们可以提前将 &lt;code&gt;C&lt;/code&gt; 的所有下标记录在一个数组 &lt;code&gt;cIndices&lt;/code&gt; 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后遍历字符串 &lt;code&gt;S&lt;/code&gt; 中的每个字符，到 &lt;code&gt;cIndices&lt;/code&gt; 中找到距离当前位置最近的下标，计算距离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;复杂度分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面方法类似，只是向两边扩展的动作变成了线性扫描 &lt;code&gt;cIndices&lt;/code&gt;，因此时间复杂度就是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -683 888 683&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; * 线性扫描 &lt;code&gt;cIndices&lt;/code&gt;的时间复杂度。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;时间复杂度：&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N*K)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 4262.4 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2262.2, 0)&quot;&gt;&lt;path data-c=&quot;2217&quot; d=&quot;M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2984.4, 0)&quot;&gt;&lt;path data-c=&quot;4B&quot; d=&quot;M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3873.4, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，N 是 S 的长度，K 是字符 &lt;code&gt;C&lt;/code&gt; 在字符串中出现的次数。由于 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;K &amp;lt;= N&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -683 3888.6 765&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4B&quot; d=&quot;M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1166.8, 0)&quot;&gt;&lt;path data-c=&quot;3C&quot; d=&quot;M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z&quot;/&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3000.6, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。因此时间上一定是优于上面的解法的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空间复杂度：&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(K)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2430 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4B&quot; d=&quot;M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2041, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，K 为字符 &lt;code&gt;C&lt;/code&gt; 出现的次数，这是记录字符 &lt;code&gt;C&lt;/code&gt; 出现下标的辅助数组消耗的空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，由于 &lt;code&gt;cIndices&lt;/code&gt; 是一个单调递增的序列，因此我们可以使用二分来确定最近的 index，时间可以优化到 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N*logK&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -694 3981.4 899&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1110.2, 0)&quot;&gt;&lt;path data-c=&quot;2217&quot; d=&quot;M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1832.4, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2130.4, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2615.4, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3092.4, 0)&quot;&gt;&lt;path data-c=&quot;4B&quot; d=&quot;M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，这个就留给各位来解决吧。如果对二分不熟悉的，可以看看我往期的《二分专题》&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;代码&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript Code&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{string}&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{character}&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@return &lt;span&gt;{number[]}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; shortestToChar = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;S, C&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 记录 C 字符在 S 字符串中出现的所有下标&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; cIndices = [];&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; S.length; i++) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (S[i] === C) cIndices.push(i);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 结果数组 res&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; res = &lt;span&gt;Array&lt;/span&gt;(S.length).fill(&lt;span&gt;Infinity&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; S.length; i++) {&lt;br/&gt;    &lt;span&gt;// 目标字符，距离是 0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (S[i] === C) {&lt;br/&gt;      res[i] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 非目标字符，到下标数组中找最近的下标&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; cIndex &lt;span&gt;of&lt;/span&gt; cIndices) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; dist = &lt;span&gt;Math&lt;/span&gt;.abs(cIndex - i);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 小小剪枝一下&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (dist &amp;gt;= res[i]) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      res[i] = dist;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解法 3：左右扫描&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;思路&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实对于每个字符来说，它只关心离它最近的那个 &lt;code&gt;C&lt;/code&gt; 字符，其他的它都不管。所以这里还可以用左右两次扫描的思路：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先 &lt;code&gt;从左往右&lt;/code&gt; 遍历字符串 &lt;code&gt;S&lt;/code&gt;，用一个数组 left 记录每个字符 &lt;code&gt;左侧&lt;/code&gt; 出现的最后一个 &lt;code&gt;C&lt;/code&gt; 字符的下标；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再 &lt;code&gt;从右往左&lt;/code&gt; 遍历字符串 &lt;code&gt;S&lt;/code&gt;，用一个数组 right 记录每个字符 &lt;code&gt;右侧&lt;/code&gt; 出现的最后一个 &lt;code&gt;C&lt;/code&gt; 字符的下标；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后同时遍历这两个数组，计算距离最小值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「优化 1」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再多想一步，其实第二个数组并不需要。因为对于左右两侧的 &lt;code&gt;C&lt;/code&gt; 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;字符左侧没有出现过 &lt;code&gt;C&lt;/code&gt; 字符&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;i - left&lt;/code&gt; &amp;gt; &lt;code&gt;right - i&lt;/code&gt; (i 为当前字符下标，left 为字符左侧最近的 &lt;code&gt;C&lt;/code&gt; 下标，right 为字符右侧最近的 &lt;code&gt;C&lt;/code&gt; 下标)&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「优化 2」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们是直接记录 &lt;code&gt;C&lt;/code&gt; 与当前字符的距离，而不是记录 &lt;code&gt;C&lt;/code&gt; 的下标，还可以省掉最后一次遍历计算距离的过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;复杂度分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我说了要开辟一个数组。而实际上题目也要返回一个数组，这个数组的长度也恰好是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -683 888 683&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，这个空间是不可避免的。因此我们直接利用这个数组，而不需要额外开辟空间，因此这里空间复杂度是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，而不是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，具体可以看下方代码区。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;代码&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript Code&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{string}&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{character}&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@return &lt;span&gt;{number[]}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; shortestToChar = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;S, C&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; res = &lt;span&gt;Array&lt;/span&gt;(S.length);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 第一次遍历：从左往右&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 找到出现在左侧的 C 字符的最后下标&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; S.length; i++) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (S[i] === C) res[i] = i;&lt;br/&gt;    &lt;span&gt;// 如果左侧没有出现 C 字符的话，用 Infinity 进行标记&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; res[i] = res[i - &lt;span&gt;1&lt;/span&gt;] === &lt;span&gt;void&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;Infinity&lt;/span&gt; : res[i - &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 第二次遍历：从右往左&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 找出现在右侧的 C 字符的最后下标&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = S.length - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (res[i] === &lt;span&gt;Infinity&lt;/span&gt; || res[i + &lt;span&gt;1&lt;/span&gt;] - i &amp;lt; i - res[i]) res[i] = res[i + &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 计算距离&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; res.length; i++) {&lt;br/&gt;    res[i] = &lt;span&gt;Math&lt;/span&gt;.abs(res[i] - i);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「直接计算距离：」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript Code&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{string}&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{character}&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@return &lt;span&gt;{number[]}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; shortestToChar = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;S, C&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; res = &lt;span&gt;Array&lt;/span&gt;(S.length);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; S.length; i++) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (S[i] === C) res[i] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 记录距离：res[i - 1] + 1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; res[i] = res[i - &lt;span&gt;1&lt;/span&gt;] === &lt;span&gt;void&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;Infinity&lt;/span&gt; : res[i - &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = S.length - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;    &lt;span&gt;// 更新距离：res[i + 1] + 1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (res[i] === &lt;span&gt;Infinity&lt;/span&gt; || res[i + &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt; &amp;lt; res[i]) res[i] = res[i + &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python Code:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;shortestToChar&lt;/span&gt;&lt;span&gt;(self, S: str, C: str)&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;br/&gt;        pre = -len(S)&lt;br/&gt;        ans = []&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(S)):&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; S[i] == C: pre = i&lt;br/&gt;            ans.append(i - pre)&lt;br/&gt;        pre = len(S) * &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(S) - &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;-1&lt;/span&gt;, &lt;span&gt;-1&lt;/span&gt;):&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; S[i] == C: pre = i&lt;br/&gt;            ans[i] = min(ans[i], pre - i)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解法 4：窗口&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;思路&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 &lt;code&gt;C&lt;/code&gt; 看成分界线，将 &lt;code&gt;S&lt;/code&gt; 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值，并在遍历的过程中更新窗口信息即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1115173674588665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaT5dytkaTd3zK4WoYWSQAUsoGEqk9wxicnIFsuXA9dD7ev6P43DjpF0HawlZY8XR50SqyAwbnB11aBrMbGU3CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;复杂度分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于更新窗口里的“搜索”下一个窗口的操作&lt;strong&gt;「总共」&lt;/strong&gt;只需要 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -683 888 683&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 次，因此时间复杂度仍然是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -683 888 683&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，而不是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N^2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -833.9 1358.6 833.9&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(955, 363) scale(0.707)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;代码&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript Code&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{string}&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@param &lt;span&gt;{character}&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; * &lt;span&gt;@return &lt;span&gt;{number[]}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; shortestToChar = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;S, C&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 窗口左边界，如果没有就初始化为 Infinity&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; l = S[&lt;span&gt;0&lt;/span&gt;] === C ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;Infinity&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 窗口右边界&lt;/span&gt;&lt;br/&gt;    r = S.indexOf(C, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; res = &lt;span&gt;Array&lt;/span&gt;(S.length);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; S.length; i++) {&lt;br/&gt;    &lt;span&gt;// 计算字符到当前窗口左右边界的最小距离&lt;/span&gt;&lt;br/&gt;    res[i] = &lt;span&gt;Math&lt;/span&gt;.min(&lt;span&gt;Math&lt;/span&gt;.abs(i - l), &lt;span&gt;Math&lt;/span&gt;.abs(r - i));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 遍历完了当前窗口的字符后，将整个窗口右移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (i === r) {&lt;br/&gt;      l = r;&lt;br/&gt;      r = S.indexOf(C, l + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文给大家介绍了这道题的四种解法，从直觉思路入手，到使用空间换时间的策略，再到两次扫描算法思想。最后是一个窗口的解法简单直白，同时复杂度也是最优的思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于刚开始做题的人来说，&quot;做出来&quot;是首要任务，但如果你有余力的话，也可以试试这样&quot;一题多解&quot;，多锻炼一下自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但无论怎样，只要你对算法感兴趣，一定要考虑关注 lucifer 这个算法灯塔哦。不要嫌我啰嗦，真话不啰嗦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多题解可以访问：https://github.com/suukii/91-days-algorithm&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;end&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家对此有何看法，欢迎给我留言，我有时间都会一一查看回答。更多算法套路可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。目前已经 37K star 啦。大家也可以关注我的公众号《力扣加加》带你啃下算法这块硬骨头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我整理的 1000 多页的电子书已限时免费下载，大家可以去我的公众号《力扣加加》后台回复电子书获取。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a25fd535a30bdad555fb2d005505cac2</guid>
<title>分布式搜索引擎 Elasticsearch 的架构分析</title>
<link>https://toutiao.io/k/j4aoyho</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、写在前面&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt; ES（Elasticsearch下文统一称为ES）越来越多的企业在业务场景是使用ES存储自己的非结构化数据，例如电商业务实现商品站内搜索，数据指标分析，日志分析等，ES作为传统关系型数据库的补充，提供了关系型数据库不具备的一些能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES最先进入大众视野的是其能够实现全文搜索的能力，也是由于基于Lucene的实现，内部有一种倒排索引的数据结构。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文作者将介绍ES的分布式架构，以及ES的存储索引机制，本文不会详细介绍ES的API，会从整体架构层面进行分析，后续作者会有其他文章对ES的使用进行介绍。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、什么是倒排索引&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;要讲明白什么是倒排索引，首先我们先梳理下什么索引，比如一本书，书的目录页，有章节，章节名称，我们想看哪个章节，我们通过目录页，查到对应章节和页码，就能定位到具体的章节内容，通过目录页的章节名称查到章节的页码，进而看到章节内容，这个过程就是一个索引的过程，那么什么是倒排索引呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如查询《java编程思想》这本书的文章，翻开书本可以看到目录页，记录这个章节名字和章节地址页码，通过查询章节名字“继承”可以定位到“继承”这篇章节的具体地址，查看到文章的内容，我们可以看到文章内容中包含很多“对象”这个词。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么如果我们要在这本书中查询所有包含有“对象”这个词的文章，那该怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按照现在的索引方式无疑大海捞针，假设我们有一个“对象”--→文章的映射关系，不就可以了吗？类似这样的反向建立映射关系的就叫倒排索引。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如图1所示，将文章进行分词后得到关键词，在根据关键词建立倒排索引，关键词构建成一个词典，词典中存放着一个个词条（关键词），每个关键词都有一个列表与其对应，这个列表就是倒排表，存放的是章节文档编号和词频等信息，倒排列表中的每个元素就是一个倒排项，最后可以看到，整个倒排索引就像一本新华字典，所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件被称之为倒排文件。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.61875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSI7oibNs8pACX2nnvzUz12ErCz3U8FBCkpA7kbpTzpsdvBcPEIK58ic8YQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图1）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;词典和倒排文件是Lucene的两种基本数据结构，但是存储方式不同，词典在内存中存储，倒排文件在磁盘上。本文不会去介绍分词，tf-idf，BM25，向量空间相似度等构建倒排索引和查询倒排索引所用到的技术，读者只需要对倒排索引有个基本的认识即可。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、ES的集群架构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;集群节点&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个ES集群可以有多个节点构成，一个节点就是一个ES服务实例，通过配置集群名称cluster.name加入集群。那么节点是如何通过配置相同的集群名称加入集群的呢？要搞明白这个问题，我们必须先搞清楚ES集群中节点的角色。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ES中节点有角色的区分的，通过配置文件conf/elasticsearch.yml中配置以下配置进行角色的设定。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node.master: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;/&lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node.&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;/&lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;集群中单个节点既可以是候选主节点也可以是数据节点，通过上面的配置可以进行两两组合形成四大分类：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）仅为候选主节点&lt;br/&gt;（2）既是候选主节点也是数据节点&lt;br/&gt;（3）仅为数据节点&lt;br/&gt;（4）既不是候选主节点也不是数据节点&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;候选主节点：&lt;/strong&gt;只有是候选主节点才可以参与选举投票，也只有候选主节点可以被选举为主节点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主节点：&lt;/strong&gt;负责索引的添加、删除，跟踪哪些节点是群集的一部分，对分片进行分配、收集集群中各节点的状态等，稳定的主节点对集群的健康是非常重要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据节点：&lt;/strong&gt;负责对数据的增、删、改、查、聚合等操作，数据的查询和存储都是由数据节点负责，对机器的CPU，IO以及内存的要求比较高，一般选择高配置的机器作为数据节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;此外还有一种节点角色叫做&lt;strong&gt;协调节点&lt;/strong&gt;，其本身不是通过设置来分配的，用户的请求可以随机发往任何一个节点，并由该节点负责分发请求、收集结果等操作，而不需要主节点转发。这种节点可称之为协调节点，集群中的任何节点都可以充当协调节点的角色。每个节点之间都会保持联系。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9761904761904762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIiaEp5sbQSYFolFc7SJCVhLxLbaGKsyjH97xkpUTIITTXYR8vlzlqtLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;462&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图2）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 发现机制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前文说到通过设置一个集群名称，节点就可以加入集群，那么ES是如何做到这一点的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就要讲一讲ES特殊的发现机制ZenDiscovery。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ZenDiscovery是ES的内置发现机制，提供单播和多播两种发现方式，主要职责是集群中节点的发现以及选举Master节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;多播也叫组播&lt;/strong&gt;，指一个节点可以向多台机器发送请求。生产环境中ES不建议使用这种方式，对于一个大规模的集群，组播会产生大量不必要的通信。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单播&lt;/strong&gt;，当一个节点加入一个现有集群，或者组建一个新的集群时，请求发送到一台机器。当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系Master节点，并加入集群。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;只有在同一台机器上运行的节点才会自动组成集群。ES 默认被配置为使用单播发现，单播列表不需要包含集群中的所有节点，它只是需要足够的节点，当一个新节点联系上其中一个并且通信就可以了。如果你使用 Master 候选节点作为单播列表，你只要列出三个就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这个配置在 elasticsearch.yml 文件中：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;discovery&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.zen&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.ping&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.unicast&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.hosts&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[&quot;host1&quot;, &quot;host2:port&quot;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;集群信息收集阶段采用了 Gossip 协议，上面配置的就相当于一个seed nodes，Gossip协议这里就不多做赘述了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES官方建议unicast.hosts配置为所有的候选主节点，ZenDiscovery 会每隔ping_interval（配置项）ping一次，每次超时时间是discovery.zen.ping_timeout（配置项），3次(ping_retries配置项)ping失败则认为节点宕机，宕机的情况下会触发failover，会进行分片重分配、复制等操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果宕机的节点不是Master，则Master会更新集群的元信息，Master节点将最新的集群元信息发布出去，给其他节点，其他节点回复Ack，Master节点收到discovery.zen.minimum_master_nodes的值-1个 候选主节点的回复，则发送Apply消息给其他节点，集群状态更新完毕。如果宕机的节点是Master，则其他的候选主节点开始Master节点的选举流程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1 选主&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Master的选主过程中要确保只有一个master，ES通过一个参数quorum的代表多数派阈值，保证选举出的master被至少quorum个的候选主节点认可，以此来保证只有一个master。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;选主的发起由候选主节点发起，当前候选主节点发现自己不是master节点，并且通过ping其他节点发现无法联系到主节点，并且包括自己在内已经有超过minimum_master_nodes个节点无法联系到主节点，那么这个时候则发起选主。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;选主流程图&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.9256559766763848&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIXPOTlNGb66uD03SRKj0ZGyF5BuJBY7mY6g3do2MdgntnXdN2N8ZVoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图3）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;选主的时候按照集群节点的参数&amp;lt;stateVersion, id&amp;gt; 排序。stateVersion从大到小排序，以便选出集群元信息较新的节点作为Master，id从小到大排序，避免在stateVersion相同时发生分票无法选出 Master。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;排序后第一个节点即为Master节点。当一个候选主节点发起一次选举时，它会按照上述排序策略选出一个它认为的Master。     &lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2 脑裂&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;提到分布式系统选主，不可避免的会提到脑裂这样一个现象，什么是脑裂呢？如果集群中选举出多个Master节点，使得数据更新时出现不一致，这种现象称之为脑裂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简而言之集群中不同的节点对于 Master的选择出现了分歧，出现了多个Master竞争。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;  一般而言脑裂问题可能有以下几个&lt;strong&gt;原因&lt;/strong&gt;造成：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;网络问题：&lt;/strong&gt;集群间的网络延迟导致一些节点访问不到Master，认为Master 挂掉了，而master其实并没有宕机，而选举出了新的Master，并对Master上的分片和副本标红，分配新的主分片。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;节点负载：&lt;/strong&gt;主节点的角色既为Master又为Data，访问量较大时可能会导致 ES 停止响应（假死状态）造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;内存回收：&lt;/strong&gt;主节点的角色既为Master又为Data，当Data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如何避免脑裂：我们可以基于上述原因，做出优化措施：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;适当调大响应超时时间，减少误判。通过参数 discovery.zen.ping_timeout 设置节点ping超时时间，默认为 3s，可以适当调大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;选举触发，我们需要在候选节点的配置文件中设置参数 discovery.zen.munimum_master_nodes 的值。这个参数表示在选举主节点时需要参与选举的候选主节点的节点数，默认值是 1，官方建议取值(master_eligibel_nodes/2)+1，其中 master_eligibel_nodes 为候选主节点的个数。这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性，因为只要不少于 discovery.zen.munimum_master_nodes 个候选节点存活，选举工作就能正常进行。当小于这个值的时候，无法触发选举行为，集群无法使用，不会造成分片混乱的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;角色分离，即是上面我们提到的候选主节点和数据节点进行角色分离，这样可以减轻主节点的负担，防止主节点的假死状态发生，减少对主节点宕机的误判。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、索引如何写入的&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1.  写索引原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1.1 分片&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES支持PB级全文搜索，通常我们数据量很大的时候，查询性能都会越来越慢，我们能想到的一个方式的将数据分散到不同的地方存储，ES也是如此，ES通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据库块称之为一个分片Shard，很像MySQL的分库分表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同的主分片分布在不同的节点上，那么在多分片的索引中数据应该被写入哪里？肯定不能随机写，否则查询的时候就无法快速检索到对应的数据了，这需要有一个路由策略来确定具体写入哪一个分片中，怎么路由我们下文会介绍。在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.2 副本&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;副本就是对分片的复制，每个主分片都有一个或多个副本分片，当主分片异常时，副本可以提供数据的查询等操作。主分片和对应的副本分片是不会在同一个节点上的，避免数据的丢失，当一个节点宕机的时候，还可以通过副本查询到数据，副本分片数的最大值是 N-1（其中 N 为节点数）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对doc的新建、索引和删除请求都是写操作，这些写操作是必须在主分片上完成，然后才能被复制到对应的副本上。ES为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES通过乐观锁的方式控制，每个文档都有一个 _version号，当文档被修改时版本号递增。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.132890365448505&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIJ5yn7SADwniaoNUUtFNKK9xVCbAUkJ7wSusG6WOV9xkVpUkhl4myR3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;301&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图4）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.3 Elasticsearch 的写索引流程&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面提到了写索引是只能写在主分片上，然后同步到副本分片，那么如图4所示，这里有四个主分片分别是S0、S1、S2、S3，一条数据是根据什么策略写到指定的分片上呢？这条索引数据为什么被写到S0上而不写到 S1 或 S2 上？这个过程是根据下面这个公式决定的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;shard&lt;/span&gt; = hash(routing) % number_of_primary_shards&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以上公式的值是在0到number_of_primary_shards-1之间的余数，也就是数据档所在分片的位置。routing通过Hash函数生成一个数字，然后这个数字再除以number_of_primary_shards（主分片的数量）后得到余数。routing是一个可变值，默认是文档的_id ，也可以设置成一个自定义的值。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在一个写请求被发送到某个节点后，该节点按照前文所述，会充当协调节点，会根据路由公式计算出写哪个分片，当前节点有所有其他节点的分片信息，如果发现对应的分片是在其他节点上，再将请求转发到该分片的主分片节点上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在ES集群中每个节点都通过上面的公式知道数据的在集群中的存放位置，所以每个节点都有接收读写请求的能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么为什么在创建索引的时候就确定好主分片的数量，并且不可修改？因为如果数量变化了，那么所有之前路由计算的值都会无效，数据也就再也找不到了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.654510556621881&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIBHFm80tQEuh9sIeecFsRGdZgoX42oic9ibS4Tibr8TviaVCxwDpCMMqc3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（ 图5）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上图5所示，当前一个数据通过路由计算公式得到的值是 shard=hash(routing)%4=0，则具体流程如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）数据写请求发送到 node1 节点，通过路由计算得到值为1，那么对应的数据会应该在主分片S1上。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;（2）node1节点将请求转发到 S1 主分片所在的节点node2，node2 接受请求并写入到磁盘。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;（3）并发将数据复制到三个副本分片R1上，其中通过乐观并发控制数据的冲突。一旦所有的副本分片都报告成功，则节点 node2将向node1节点报告成功，然后node1节点向客户端报告成功。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这种模式下，只要有副本在，写入延时最小也是两次单分片的写入耗时总和，效率会较低，但是这样的好处也很明显，避免写入后单个机器硬件故障导致数据丢失，在数据完整性和性能方面，一般都是优先选择数据，除非一些允许丢数据的特殊场景。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在ES里为了减少磁盘IO保证读写性能，一般是每隔一段时间（比如30分钟）才会把数据写入磁盘持久化，对于写入内存，但还未flush到磁盘的数据，如果发生机器宕机或者掉电，那么内存中的数据也会丢失，这时候如何保证？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于这种问题，ES借鉴数据库中的处理方式，增加CommitLog模块，在ES中叫transLog，在下面的ES存储原理中会介绍。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.  存储原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面介绍了在ES内部的写索引处理流程，数据在写入到分片和副本上后，目前数据在内存中，要确保数据在断电后不丢失，还需要持久化到磁盘上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们知道ES是基于Lucene实现的，内部是通过Lucene完成的索引的创建写入和搜索查询，Lucene 工作原理如下图所示，当新添加一片文档时，Lucene进行分词等预处理，然后将文档索引写入内存中，并将本次操作写入事务日志（transLog），transLog类似于mysql的binlog，用于宕机后内存数据的恢复，保存未持久化数据的操作日志。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;默认情况下，Lucene每隔1s(refresh_interval配置项)将内存中的数据刷新到文件系统缓存中，称为一个segment（段）。一旦刷入文件系统缓存，segment才可以被用于检索，在这之前是无法被检索的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此refresh_interval决定了ES数据的实时性，因此说ES是一个准实时的系统。segment 在磁盘中是不可修改的，因此避免了磁盘的随机写，所有的随机写都在内存中进行。随着时间的推移，segment越来越多，默认情况下，Lucene每隔30min或segment 空间大于512M，将缓存中的segment持久化落盘，称为一个commit point，此时删掉对应的transLog。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当我们在进行写操作的测试的时候，可以通过手动刷新来保障数据能够被及时检索到，但是不要在生产环境下每次索引一个文档都去手动刷新，刷新操作会有一定的性能开销。一般业务场景中并不都需要每秒刷新。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以通过在 Settings 中调大 refresh_interval = &quot;30s&quot; 的值，来降低每个索引的刷新频率，设值时需要注意后面带上时间单位，否则默认是毫秒。当 refresh_interval=-1 时表示关闭索引的自动刷新。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6065773447015834&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIqicx9Qwynb3hkrEN7m1Xe2T9hmHhp8fwryaiblSFZ5tM5olv2sEYlXcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;821&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图6）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;索引文件分段存储并且不可修改，那么新增、更新和删除如何处理呢？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;segment被设定为不可修改具有一定的优势也有一定的缺点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其它缓存(像 Filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;当对旧数据进行删除时，旧数据不会马上被删除，而是在 .del 文件中被标记为删除。而旧数据只能等到段更新时才能被移除，这样会造成大量的空间浪费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 若有一条数据频繁的更新，每次更新都是新增新的，标记旧的，则会有大量的空间浪费。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每次新增数据时都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源例如文件句柄的消耗会非常大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在查询的结果中包含所有的结果集，需要排除被标记删除的旧数据，这增加了查询的负担。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1  段合并&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由于每当刷新一次就会新建一个segment（段），这样会导致短时间内的段数量暴增，而segment数目太多会带来较大的麻烦。大量的segment会影响数据的读性能。每一个segment都会消耗文件句柄、内存和CPU 运行周期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;更重要的是，每个搜索请求都必须轮流检查每个segment然后合并查询结果，所以segment越多，搜索也就越慢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此Lucene会按照一定的策略将segment合并，合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档不会被拷贝到新的大segment中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;合并的过程中不会中断索引和搜索，倒排索引的数据结构使得文件的合并是比较容易的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;段合并在进行索引和搜索时会自动进行，合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这些段既可以是未提交的也可以是已提交的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;合并结束后老的段会被删除，新的段被刷新到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点，新的段被打开，可以用来搜索。段合并的计算量庞大，而且还要吃掉大量磁盘 I/O，并且段合并会拖累写入速率，如果任其发展会影响搜索性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ES在默认情况下会对合并流程进行资源限制，所以搜索性能可以得到保证。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7016742770167428&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIc9XA81prMddC48pDjca3zHGvWU7lGK1Tsic6RsDvhHz9cZVAV81icxOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图7）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、写在最后&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者对ES的架构原理和索引存储和写机制进行介绍，ES的整体架构体系相对比较巧妙，我们在进行系统设计的时候可以借鉴其设计思路，本文只介绍ES整体架构部分，更多的内容，后续作者会在其他文章中继续分享。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1730382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSI80WRIpDRicCaQdHjjurJ7VdYSt9xD2qibbm0EDareT9m7B3JDcFobIhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;994&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIRx2tcy1EZsbvicvcAMzjDVQgUH5c0PjUbm8leBX8b6YRSgJCPRAOznA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;vivo互联网技术&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo移动互联网是基于vivo 智能手机所建立的完整移动互联网生态圈，围绕vivo大数据运营，打造包括应用、游戏、资讯、品牌、电商、内容、金融、搜索的全方位服务生态，满足海量用户的多样化需求。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;点一下，代码无 Bug&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8808777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt4ow2AdCLPQ2WvaZhf8iarSIcZEEmjkyld5v3qhALAJDpVxa9wt6PgeX5C5f2rYkPcWJD9KiaxD9riaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>538568a608f9c28e75b6e2c7645a5764</guid>
<title>码仔漫画：重学设计模式之装饰者模式</title>
<link>https://toutiao.io/k/38691ur</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>