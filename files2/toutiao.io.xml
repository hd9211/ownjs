<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b15079191076f98c975bb961389177ce</guid>
<title>[译] 2021 Go 趋势报告</title>
<link>https://toutiao.io/k/runaz5c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;h1&gt;&lt;a id=&quot;user-content-2021-go-趋势报告&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#2021-go-趋势报告&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;2021 Go 趋势报告&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.jetbrains.com/author/ekaterina-zharovajetbrains-com&quot; rel=&quot;nofollow&quot;&gt;Ekaterina Zharova&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2021.2.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在当今最流行的编程语言列表里，Go语言一直是名列前茅。众所周知 Go 语言现在很火，写 Go 代码也很有意思，Go 在社区也很受用户欢迎，主要是 Go 语言的速度块，效率高。除了这些众所周知的优点之外，我们期待发现 Go 更多不为人知的信息。为了发现更多的事实，我们在目前Go现有信息的基础上，进行了深入研究。我们邀请了Go语言专家、&lt;code&gt;Goland&lt;/code&gt;开发倡导者 &lt;code&gt;Florin Pățan&lt;/code&gt;  来发表他对Go语言发展趋势的看法。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/Go_8001611039611515.gif&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/Go_8001611039611515.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-在哪儿&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#在哪儿&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;在哪儿&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-约110万go开发者&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#约110万go开发者&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;约110万Go开发者&lt;/h3&gt;
&lt;p&gt;总的来说，大约有 &lt;strong&gt;110万专业的 Go 开发者&lt;/strong&gt; 使用 Go 作为&lt;strong&gt;主要开发语言&lt;/strong&gt;。 如果我们把那些使用其他语言作为主力开发语言，但是把Go当作业余爱好的开发人员算在内的话，这一数字可能接近&lt;strong&gt;270万&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就全球分布而言，居住在 &lt;strong&gt;亚洲&lt;/strong&gt; 的 Go 开发者最多，大约有57万开发者使用 Go 作为主要开发语言。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这也正是我最期待的使用Go开发的地方。就Go用户数量而言，亚洲高居榜首，我认为主要原因是有大量的来自像腾讯、阿里巴巴、华为这些大公司的开发者。这些公司一般都有很多开发人员。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/1-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/1-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-具体在哪里&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#具体在哪里&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;具体在哪里&lt;/h2&gt;
&lt;p&gt;下图显示了我们在 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt; 中调查的每个国家使用Go作为主要语言的开发者的分布情况（受访者最多可以选择3种主要语言）。&lt;strong&gt;中国&lt;/strong&gt; 的开发者集中度最高，有16%的中国开发者在使用Go。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;看到中国排在榜首，我一点也不惊讶。我本以为俄罗斯会排在第二，美国会高一点，大概在前五位。&lt;/p&gt;
&lt;p&gt;中国之所以排在榜首，可能正是因为他们拥有的开发者数量最多。而且我认识的很多公司，比如 &lt;code&gt;PingCAP&lt;/code&gt;、腾讯和华为，都有很多开发者来支撑和构建他们的内部工具、基础设施和后端服务，这些服务都和微服务相结合。这似乎是中国排在榜首关键原因。&lt;/p&gt;
&lt;p&gt;我知道俄罗斯的 Go 社区非常棒，所以也难怪 Go 在那里很受欢迎。我对日本和乌克兰很好奇，因为我没想到他们会这么高，我以为德国和印度会更高些。记得四五年前我在柏林的时候，我认识的每一家创业公司都在使用 Go 。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/2-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/2-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-行业洞察&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#行业洞察&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;行业洞察&lt;/h2&gt;
&lt;p&gt;Go 依然保持着开发者主要使用语言的 &lt;strong&gt;前10名&lt;/strong&gt;，根据&lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt;显示 Go 的份额约为9%。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我认为 Go 会一直增长。人们通常不会把 Go 作为他们开始编程的入门语言，但是会从其他语言迁移过来，例如 &lt;code&gt;PHP&lt;/code&gt; &lt;code&gt;Ruby&lt;/code&gt;，但据我所知，主要从 &lt;code&gt;C++&lt;/code&gt; &lt;code&gt;C#&lt;/code&gt; 迁移过来。&lt;/p&gt;
&lt;p&gt;Go 相比 PHP 的优势是类型安全，因为 Go 是一门静态类型语言，而 PHP 是门动态类型语言。这就意味着编译器在运行时做了大量的工作来确保你写的代码能够编译并且正常运行。相比于 C++ ，Go 的优势是简单。在 Go 里面，一切都是那么简单。&lt;/p&gt;
&lt;p&gt;总的来说，Go 的特点就是与生俱来的速度快，无论是写代码还是运行时。一般来说，在不做任何特殊优化的情况下，采用 Go 语言你就能提高5-10倍的性能，这对公司来说是一个很重要的生产优势。同时 Go 也是一门简单的语言，很容易上手，很容易替换现有项目中的微服务。&lt;/p&gt;
&lt;p&gt;许多 IT 基础设施工具，如 &lt;code&gt;Kubernetes&lt;/code&gt;、&lt;code&gt;Docker&lt;/code&gt;和&lt;code&gt;Vault&lt;/code&gt;（举几个大型的例子）都是用 Go 构建的。因此虽然很多公司是使用 Java ，但是还是会有一个团队会用 Go，特别是为了来维护这些项目和给这些项目打补丁。这可能是 Go  采用率保持增长的另外一个原因。 这种技术在公共技术设施和部署中使用的越多，Go 就增长的越快。我认为接下来几年会有越来越多的人采用Go，我们将会看到大约有15%-20%的开发者会使用 Go 。特别是考虑到开发者生态调查中问的一个问题，“您打算在今后12个月内采用或迁移到其他语言吗？”，13%的受访者回答是Go。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/3-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/3-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-go开发的软件类型&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#go开发的软件类型&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Go开发的软件类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Web 服务&lt;/strong&gt; 是使用 Go  最受欢迎的领域，根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt; 结果显示，其占有36%份额。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;为什么是 web 服务，我认为主要原因是构建一个 API 服务非常快。他们不需要框架，就可以用 Go 快速启动和运行一个。&lt;/p&gt;
&lt;p&gt;我不认为这张图在未来会有很大变化，我真心希望看到 web 服务得到更多的分享，因为用 Go 开始一个web 服务确实很简单。&lt;/p&gt;
&lt;p&gt;对于实用小程序，我见过很多类似的，因为 Go 很容易快速写一个小应用来帮你处理大量的数据，写一个小的实用程序或需要消耗大量资源的一次性任务。越来越多的人采用&lt;code&gt;Docker&lt;/code&gt; 和&lt;code&gt;Kubernetes&lt;/code&gt;，就会有越来越多的人使用 Go,仅仅是因为他们都是用 Go 写的。任何类型的 DevOps 的工作都可以从 Go 中获益，因为它提供了类型安全和速度。与基础设施的云端交互很容易（Google、Amazon、Azure等），因为他们都有很好的 SDK 。我认为未来几年，当泛型到来时，我们还可以期待下 “Libraries / Frameworks” 的一些提升。&lt;/p&gt;
&lt;p&gt;系统软件——我认为随着越来越多的人开始使用像 Rust 这样的语言编写系统软件，这一数字将会下降。数据库也是如此。所以这大约6%市场，在未来这可能会变成一个商机。编程工具——我很惊讶它在列表中份额这么高，我非常感兴趣去了解一下 Go 有哪些编程工具。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/5-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/5-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-使用go的顶级行业&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#使用go的顶级行业&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;使用Go的顶级行业&lt;/h2&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020开发者生态调查&lt;/a&gt; ，Go 程序员主要从事 &lt;strong&gt;IT 服务&lt;/strong&gt;，其次是 &lt;strong&gt;金融和金融科技&lt;/strong&gt;、&lt;strong&gt;云技术/云平台&lt;/strong&gt; 和其他行业。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;金融和金融科技。这是我希望看到的，因为据我所知有相当多的银行已经开始采用 Go 或者正在广泛使用 Go 作为他们的基础设施。例如，&lt;a href=&quot;https://monzo.com/blog/2016/09/19/building-a-modern-bank-backend&quot; rel=&quot;nofollow&quot;&gt;来自英国的Monzo使用 Go 构建了他们整个银行系统&lt;/a&gt;。云计算和云平台也很有意义，因为它们对于使用 Go 编写的应用来说是很自然的。&lt;/p&gt;
&lt;p&gt;移动开发，这是意料之外的。Go 并没有好的移动开发历史。如果有什么不同的话，我希望大家使用 Go 来为移动程序提供网络服务或者后端服务，但仅此而已。&lt;/p&gt;
&lt;p&gt;有几个行业，我不认为 Go 的使用率会很快增加。比如，任何基于机器学习的东西，因为这仍然是 Python 的地盘。人们正在努力让机器学习在 Go 中变得受欢迎和变得更好，但是我认为至少要几年之后才会有一些结果。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/4-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/4-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-go-工具&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#go-工具&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Go 工具&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-包管理&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#包管理&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;包管理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Go Modules&lt;/strong&gt; 是 Go 开发者中最受欢迎的包管理工具。根据 &lt;em&gt;2020 开发者生态调查&lt;/em&gt; 其使用率从 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2019/go/&quot; rel=&quot;nofollow&quot;&gt;2019&lt;/a&gt; 到41%上升到到 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 的82%。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我认为在某种程度上我们可能不得不停止问这个问题，因为 Go Modules已经被设置为标准默认模型，而且Go团队也想要弃用 &lt;code&gt;GOPATH&lt;/code&gt;。到那时，其他的所有的包管理工具都将会被淘汰。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/6-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/6-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-go-路由&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#go-路由&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Go 路由&lt;/h3&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 和 &lt;a href=&quot;https://www.jetbrains.com/research/devecosystem-2018/go/&quot; rel=&quot;nofollow&quot;&gt;2018&lt;/a&gt; 的开发者生态调查显示，&lt;strong&gt;Gorilla / Mux&lt;/strong&gt; 和 &lt;strong&gt;标准库&lt;/strong&gt; 自2018年以来一直是使用最多的 Go 路由。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;标准库之所以如此受欢迎，可能是因为每当你去Reddit、Slack或其他地方，人们通常都会建议你坚持使用标准库，只有在你真正需要的时候才使用其他东西。我使用&lt;code&gt;gorilla/mux&lt;/code&gt;，是因为它在标准库的基础上有更多的抽象，又不会牺牲太多的性能。也可能是因为它是最接近标准库的，而且它使得编写服务端更容易。总的来说，这种分布可能是我希望看到的。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/7-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/7-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-5大web框架&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#5大web框架&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;5大web框架&lt;/h3&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 和 &lt;a href=&quot;https://www.jetbrains.com/research/devecosystem-2018/go/&quot; rel=&quot;nofollow&quot;&gt;2018&lt;/a&gt; 的开发者生态调查显示，&lt;strong&gt;Gin&lt;/strong&gt; 的使用量自2018年以来几乎翻了一倍，而其他 web 框架基本保持稳定。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Gin 在 web 上如此受欢迎，因为它是一个速度快的框架，而且也得到了很好的推荐。它也是最古老的框架之一。因为会有很多文档摆在那儿，很多用户已经在使用它和推荐它。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/8-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/8-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&quot;user-content-测试框架&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#测试框架&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;测试框架&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;内置测试框架&lt;/strong&gt; 的比例从 &lt;a href=&quot;https://www.jetbrains.com/research/devecosystem-2018/go/&quot; rel=&quot;nofollow&quot;&gt;2018&lt;/a&gt; 64%下降到 &lt;a href=&quot;https://www.jetbrains.com/lp/devecosystem-2020/go/&quot; rel=&quot;nofollow&quot;&gt;2020&lt;/a&gt; 的44%，而使用其他测试框架的比例略有增长。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;内置的测试框架比例很高是因为 Go 标准库有一个非常好的开箱即用的测试库。&lt;/p&gt;
&lt;p&gt;内置测试可能会下降主要是因为越来越多的人从其他语言(比如 PHP )转向这门语言，他们试图复制自己已有的测试习惯。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/9-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/9-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-讨论最多的go工具和其他语言&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#讨论最多的go工具和其他语言&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;讨论最多的Go工具和其他语言&lt;/h2&gt;
&lt;p&gt;Go 经常在 IT 社区中被讨论，Stack Overflow 就是其中之一。我们从其 Q&amp;amp;A 单元获取数据来找出哪些标签与“Go”同时出现次数最多。其中有23种工具和两种语言（&lt;code&gt;MySQL&lt;/code&gt; 和 &lt;code&gt;PostgreSQL&lt;/code&gt;）。除了这些工具，还有与其他顶级语言的共存。纵轴表示标签出现的总次数，而横轴表示带有“Go”的标签的提及次数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;专家分析&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我早料到&lt;code&gt; JSON&lt;/code&gt; 会是个问题，把 Go 的数据结构序列化和反序列化成&lt;code&gt; JSON&lt;/code&gt;确实是很不容易的，这可能就是 &lt;code&gt;JSON&lt;/code&gt;会如此醒目的原因。来自其他语言的人通常很难理解&lt;code&gt;struct&lt;/code&gt;，除非它们来自C++或C。&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;AWS&lt;/code&gt;本身的受欢迎程度，我认为&lt;code&gt;Amazon Web Services&lt;/code&gt;会有很多问题。现在现在为&lt;code&gt;Google App Engine&lt;/code&gt;开发 Go 应用程序更简单了，但以前并不是这样，所以才会有这么多问题。&lt;/p&gt;
&lt;p&gt;总而言之，Go社区是一个非常有趣且具有包容性的社区，你可以成为其中的一员。从不排斥新人，鼓励他们提出问题，探索语言。在一般的主题方面，泛型以及某些语言改进、编译器改进等都是经常讨论的话题。&lt;/p&gt;
&lt;p&gt;尤其是泛型，因为它是该语言最需要的特性之一，并且有大量的工作负载将受益于该特性。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&quot;&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/gocn/translator/blob/master/static/images/w6_the_state_of_Go/11-2x.png&quot;&gt;&lt;img src=&quot;/gocn/translator/raw/master/static/images/w6_the_state_of_Go/11-2x.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;/article&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>baf9d7288663f2179bd7a28c6b6cc940</guid>
<title>Go 工程化（二）：项目目录结构</title>
<link>https://toutiao.io/k/9p2dvmm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;p&gt;本系列为 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营&lt;/a&gt; 笔记，预计 2021Q1 完成更新，访问 &lt;a href=&quot;https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/&quot;&gt;博客: Go 进阶训练营&lt;/a&gt; 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳&lt;/p&gt;&lt;p&gt;工程化这一节说简单看似简单，无非就是目录结构，代码分层，依赖注入等等。但是其中很多坑如果没踩过是不知道这里面的痛点的。除此之外这里面也会有很多架构的思想在里面，这也就是为什么我会把架构整洁之道的阅读笔记放在第一小节的原因。&lt;/p&gt;&lt;p&gt;接来下包含这一篇文章在内，我会先用几篇文章结合参考材料以及个人的理解整理一下毛老师课上讲的内容。然后恰好在这个课程前，我也在对我们之前的一些项目做重构，所以会再用一到两篇文章大概说一些我最后选择的方式，已经在实践过程中的一些取舍，就工程化这个事情来说大概原理上基本都是相通的，但是每个团队甚至每个人所面临的一些问题都各不相同，所以最后出来的东西肯定不是完全一致的。&lt;/p&gt;&lt;p&gt;注意，你如果是只是需要写一个脚本，或者是做一些简单的 demo 大可不必像文章接下来介绍的这样搞的这么麻烦，直接一个 main.go 简单快捷方便即可，但是如果你这是一个长期维护的项目，甚至涉及到的多个人之间的合作，那么接下来的几篇文章就不能错过了，可以仔细阅读，希望可以对你有所帮助。&lt;/p&gt;&lt;h2 id=&quot;Standard-Go-Project-Layout&quot;&gt;&lt;a href=&quot;#Standard-Go-Project-Layout&quot; class=&quot;headerlink&quot; title=&quot;Standard Go Project Layout&quot;/&gt;Standard Go Project Layout&lt;/h2&gt;&lt;p&gt;这一部分的内容主要来自于 github 的高星项目：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/golang-standards/project-layout/blob/master/README_zh.md&quot;&gt;golang-standards/project-layout&lt;/a&gt; 通过这个我们可以大概的了解到在 Go 中一些约定俗成的目录含义，虽然这些不是强制性的，但是如果有去看官方的源码或者是一些知名的项目可以发现大多都是这么命名的，所以我们最好和社区保持一致，大家保持同样的语言。&lt;/p&gt;&lt;h3 id=&quot;cmd&quot;&gt;&lt;a href=&quot;#cmd&quot; class=&quot;headerlink&quot; title=&quot;/cmd&quot;/&gt;/cmd&lt;/h3&gt;&lt;p&gt;我们一般采用 &lt;code&gt;/cmd/[appname]/main.go&lt;/code&gt; 的形式进行组织&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先 cmd 目录下一般是项目的主干目录&lt;/li&gt;&lt;li&gt;这个目录下的文件&lt;strong&gt;不应该有太多的代码，不应该包含业务逻辑&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;main.go 当中主要做的事情就是负责程序的生命周期，服务所需资源的依赖注入等，其中依赖注入一般而言我们会使用一个依赖注入框架，这个主要看复杂程度，后续会有一篇文章单独介绍这个&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;internal&quot;&gt;&lt;a href=&quot;#internal&quot; class=&quot;headerlink&quot; title=&quot;/internal&quot;/&gt;/internal&lt;/h3&gt;&lt;p&gt;internal 目录下的包，不允许被其他项目中进行导入，这是在 Go 1.4 当中引入的 feature，会在编译时执行&lt;/p&gt;&lt;ul&gt;&lt;li&gt;所以我们一般会把项目文件夹放置到 internal 当中，例如 &lt;code&gt;/internal/app&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果是可以被其他项目导入的包我们一般会放到 pkg 目录下&lt;/li&gt;&lt;li&gt;如果是我们项目内部进行共享的包，而不期望外部共享，我们可以放到 &lt;code&gt;/internal/pkg&lt;/code&gt; 当中&lt;/li&gt;&lt;li&gt;注意 internal 目录的限制并不局限于顶级目录，在任何目录当中都是生效的&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;举个 🌰 下面的是我们当前的目录结构，其中的代码很简单，在 &lt;code&gt;t.go&lt;/code&gt; 当中导出了一个变量 &lt;code&gt;I&lt;/code&gt; 然后在 &lt;code&gt;a/cmd/a/main.go&lt;/code&gt; 和 &lt;code&gt;b/cmd/b/main.go&lt;/code&gt; 当中分别导入输出这个变量的值&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;❯ tree&lt;br/&gt;.&lt;br/&gt;├── a&lt;br/&gt;│   ├── cmd&lt;br/&gt;│   │   └── a&lt;br/&gt;│   │       └── main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;│   └── internal&lt;br/&gt;│       └── pkg&lt;br/&gt;│           └── t&lt;br/&gt;│               └── t.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;└── b&lt;br/&gt;    └── cmd&lt;br/&gt;        └── b&lt;br/&gt;            └── main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们可以发现， &lt;code&gt;a&lt;/code&gt; 目录下可以直接输出 &lt;code&gt;I&lt;/code&gt; 的值&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;❯ &lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt; run ./a/cmd/a/main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;但是在 &lt;code&gt;b&lt;/code&gt; 目录下，编译器会直接报错说导入了 &lt;code&gt;a&lt;/code&gt; 的私有包&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;❯ &lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt; run ./b/cmd/b/main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; command-line-arguments&lt;br/&gt;        b/cmd/b/main.&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;: use of internal &lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; github.com/mohuishou/&lt;span class=&quot;hljs-keyword&quot;&gt;go&lt;/span&gt;-training/Week04/blog/&lt;span class=&quot;hljs-number&quot;&gt;02&lt;/span&gt;_project_layout/&lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;_internal_example/a/internal/pkg/t not allowed&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;pkg&quot;&gt;&lt;a href=&quot;#pkg&quot; class=&quot;headerlink&quot; title=&quot;/pkg&quot;/&gt;/pkg&lt;/h3&gt;&lt;p&gt;一般而言，我们在 pkg 目录下放置可以被外部程序安全导入的包，对于不应该被外部程序依赖的包我们应该放置到 &lt;code&gt;internal&lt;/code&gt; 目录下， &lt;code&gt;internal&lt;/code&gt; 目录会有编译器进行强制验证&lt;/p&gt;&lt;ul&gt;&lt;li&gt;pkg 目录下的包一般会按照功能进行区分，例如 &lt;code&gt;/pkg/cache&lt;/code&gt; 、 &lt;code&gt;/pkg/conf&lt;/code&gt; 等&lt;/li&gt;&lt;li&gt;如果你的目录结构比较简单，内容也比较少，其实也可以不使用 &lt;code&gt;pkg&lt;/code&gt; 目录，直接把上面的这些包放在最上层即可&lt;/li&gt;&lt;li&gt;一般而言我们应用程序 app 在最外层会包含很多文件，例如 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; &lt;code&gt;makefile&lt;/code&gt; &lt;code&gt;.gitignore&lt;/code&gt; 等等，这种时候顶层目录会很多并且会有点杂乱，建议还是放到 &lt;code&gt;/pkg&lt;/code&gt; 目录比较好&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;Kit-Project-Layout&quot;&gt;&lt;a href=&quot;#Kit-Project-Layout&quot; class=&quot;headerlink&quot; title=&quot;Kit Project Layout&quot;/&gt;Kit Project Layout&lt;/h2&gt;&lt;p&gt;kit 库其实也就是一些基础库&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每一个公司正常来说应该&lt;strong&gt;有且仅有一个基础库项目&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;kit 库一般会包含一些常用的公共的方法，例如缓存，配置等等，比较典型的例子就是 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/go-kit/kit&quot;&gt;go-kit&lt;/a&gt;&lt;/li&gt;&lt;li&gt;kit 库必须具有的特点：&lt;ul&gt;&lt;li&gt;统一&lt;/li&gt;&lt;li&gt;标准库方式布局&lt;/li&gt;&lt;li&gt;高度抽象&lt;/li&gt;&lt;li&gt;支持插件&lt;/li&gt;&lt;li&gt;尽量减少依赖&lt;/li&gt;&lt;li&gt;持续维护&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;减少依赖和持续维护是我后面补充的，这一点其实很遗憾，我们部门刚进来的时候方向是对的也建立了一套基础库，然后大家都使用这同一套库，但是很遗憾，我们这一套库一是没人维护，二是没有一套机制来进行迭代，到现在很多团队和项目已经各搞各的了。&lt;br/&gt;这样其实会导致做很多重复工作以及后续的一些改动很难推进，前车之鉴，如果有类似的情况一定要在小火苗出来的时候先摁住，从大的角度来讲统一有时候比好用重要，不好用应该参与贡献而不是另起炉灶。&lt;/p&gt;&lt;h2 id=&quot;Service-Application-Project-Layout&quot;&gt;&lt;a href=&quot;#Service-Application-Project-Layout&quot; class=&quot;headerlink&quot; title=&quot;Service Application Project Layout&quot;/&gt;Service Application Project Layout&lt;/h2&gt;&lt;p&gt;在这一小节我们会先看到毛老师在课上讲解的他们的应用程序目录的迭代变化，然后说一些我最后的采用的目录结构以及里面的取舍，关于具体怎么演进来的当中遇到了什么问题，我们会在 Go 工程化这个系列的最后一篇文章详细说明。&lt;/p&gt;&lt;h3 id=&quot;api&quot;&gt;&lt;a href=&quot;#api&quot; class=&quot;headerlink&quot; title=&quot;/api&quot;/&gt;/api&lt;/h3&gt;&lt;p&gt;API 定义的目录，如果我们采用的是 grpc 那这里面一般放的就是 proto 文件，除此之外也有可能是 openapi/swagger 定义文件，以及他们生成的文件。&lt;/p&gt;&lt;p&gt;下面给出一个我现在使用的 api 目录的定义，其实和毛老师课上讲的类似，后面还有一篇文章会专门讲 api 的设计会讲到这里就不详细讲了&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;.&lt;br/&gt;└── api&lt;br/&gt;    └── product_name &lt;span class=&quot;hljs-comment&quot;&gt;// 产品名称&lt;/span&gt;&lt;br/&gt;        └── app_name &lt;span class=&quot;hljs-comment&quot;&gt;// 应用名称&lt;/span&gt;&lt;br/&gt;            └── v1   &lt;span class=&quot;hljs-comment&quot;&gt;// 版本号&lt;/span&gt;&lt;br/&gt;                └── v1.proto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;config-s&quot;&gt;&lt;a href=&quot;#config-s&quot; class=&quot;headerlink&quot; title=&quot;/config(s)&quot;/&gt;/config(s)&lt;/h3&gt;&lt;p&gt;为什么加个(s) 是课上讲的还有参考材料中很多都叫 configs 但是我们习惯使用 config 但是含义上都是一样的&lt;br/&gt;这里面一般放置配置文件文件和默认模板&lt;/p&gt;&lt;h3 id=&quot;test&quot;&gt;&lt;a href=&quot;#test&quot; class=&quot;headerlink&quot; title=&quot;/test&quot;/&gt;/test&lt;/h3&gt;&lt;p&gt;额外的外部测试应用程序和测试数据。一般会放测试一些辅助方法和测试数据&lt;/p&gt;&lt;h3 id=&quot;服务类型&quot;&gt;&lt;a href=&quot;#服务类型&quot; class=&quot;headerlink&quot; title=&quot;服务类型&quot;/&gt;服务类型&lt;/h3&gt;&lt;p&gt;微服务中的 app 服务类型分为 4 类：interface、service、job、admin。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;interface: 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口。&lt;/li&gt;&lt;li&gt;service: 对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了 gRPC 接口只对内服务。&lt;/li&gt;&lt;li&gt;admin：区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全。&lt;/li&gt;&lt;li&gt;job: 流式任务处理的服务，上游一般依赖 message broker。&lt;/li&gt;&lt;li&gt;task: 定时任务，类似 cronjob，部署到 task 托管平台中。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1612614638378-d00b94ac-f743-414e-bca2-b9d941da7902.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;这上面是毛老师课上讲解的类型，和我们常用的做法类似，但是有点区别，同样假设我们有一个应用叫 &lt;code&gt;myapp&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;myapp-api: 这个是对外暴露的 api 的服务，可以是 http, 也可以是 grpc&lt;/li&gt;&lt;li&gt;myapp-cron: 这个是定时任务&lt;/li&gt;&lt;li&gt;myapp-job: 这个用于处理来自 message 的流式任务&lt;/li&gt;&lt;li&gt;myapp-migration: 数据库迁移任务，用于初始化数据库&lt;/li&gt;&lt;li&gt;scripts/xxx: 一次性执行的脚本，有时候会有一些脚本任务&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大多大同小异，主要是 BFF 层我们一般是一个独立的应用，不会放在同一个仓库里面，&lt;/p&gt;&lt;h3 id=&quot;项目布局-v1&quot;&gt;&lt;a href=&quot;#项目布局-v1&quot; class=&quot;headerlink&quot; title=&quot;项目布局 v1&quot;/&gt;项目布局 v1&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1612615089844-dfc6a101-710e-42e4-983f-ea340676b5f4.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;项目的依赖路径为: model -&amp;gt; dao -&amp;gt; service -&amp;gt; api，model struct 串联各个层，直到 api 需要做 DTO 对象转换。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;model: 放对应“存储层”的结构体，是对存储的一一隐射。&lt;/li&gt;&lt;li&gt;dao: 数据读写层，数据库和缓存全部在这层统一处理，包括 cache miss 处理。&lt;/li&gt;&lt;li&gt;service: 组合各种数据访问来构建业务逻辑。&lt;/li&gt;&lt;li&gt;server: 依赖 proto 定义的服务作为入参，提供快捷的启动服务全局方法。&lt;/li&gt;&lt;li&gt;api: 定义了 API proto 文件，和生成的 stub 代码，它生成的 interface，其实现者在 service 中。&lt;/li&gt;&lt;li&gt;service 的方法签名因为实现了 API 的 接口定义，DTO 直接在业务逻辑层直接使用了，更有 dao 直接使用，最简化代码。&lt;/li&gt;&lt;li&gt;DO(Domain Object): 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。缺乏 DTO -&amp;gt; DO 的对象转换。&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;v1-存在的问题&quot;&gt;&lt;a href=&quot;#v1-存在的问题&quot; class=&quot;headerlink&quot; title=&quot;v1 存在的问题&quot;/&gt;v1 存在的问题&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;没有 DTO 对象，model 中的对象贯穿全局，所有层都有&lt;ul&gt;&lt;li&gt;model 层的数据不是每个接口都需要的，这个时候会有一些问题&lt;/li&gt;&lt;li&gt;在上一篇文章中其实也反复提到了 “如果两段看似重复的代码，如果有不同的变更速率和原因，那么这两段代码就不算是真正的重复”&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;server 层的代码可以通过基础库干掉，提供统一服务暴露方式&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;项目布局-v2&quot;&gt;&lt;a href=&quot;#项目布局-v2&quot; class=&quot;headerlink&quot; title=&quot;项目布局 v2&quot;/&gt;项目布局 v2&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1612615164024-9156a848-53f7-4324-963a-e7e4ae110424.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;app 目录下有 api、cmd、configs、internal 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;internal:&lt;/strong&gt; 是为了避免有同业务下有人跨目录引用了内部的 biz、data、service 等内部 struct。&lt;ul&gt;&lt;li&gt;如果存在一个仓库多个应用，那么可以在 internal 里面进行分层，例如 &lt;code&gt;/internal/app&lt;/code&gt; , &lt;code&gt;/internal/job&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;biz&lt;/strong&gt;: 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;: 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra 层。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;service&lt;/strong&gt;: 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -&amp;gt; DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;PO(Persistent Object): 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么数据表中的每个字段（或若干个）就对应 PO 的一个（或若干个）属性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;示例可以参考 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/go-kratos/examples/tree/main/blog&quot;&gt;kratos v2 的 example&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;我的项目布局&quot;&gt;&lt;a href=&quot;#我的项目布局&quot; class=&quot;headerlink&quot; title=&quot;我的项目布局&quot;/&gt;我的项目布局&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;.&lt;br/&gt;├── api&lt;br/&gt;├── cmd&lt;br/&gt;│   └── app&lt;br/&gt;├── config&lt;br/&gt;├── internal&lt;br/&gt;│   ├── domain&lt;br/&gt;│   ├── repo&lt;br/&gt;│   ├── service&lt;br/&gt;│   └── usecase&lt;br/&gt;└── pkg&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;internal:&lt;/strong&gt; 是为了避免有同业务下有人跨目录引用了内部的对象&lt;/p&gt;&lt;h2 id=&quot;应该避免的坏习惯&quot;&gt;&lt;a href=&quot;#应该避免的坏习惯&quot; class=&quot;headerlink&quot; title=&quot;应该避免的坏习惯&quot;/&gt;应该避免的坏习惯&lt;/h2&gt;&lt;h3 id=&quot;src&quot;&gt;&lt;a href=&quot;#src&quot; class=&quot;headerlink&quot; title=&quot;/src&quot;/&gt;/src&lt;/h3&gt;&lt;p&gt;一般而言，在 Go 项目当中不应该出现 src 目录，Go 和 Java 不同，在 Go 中每一个目录都是一个包，每一个包都是一等公民，我们不需要将项目代码放到 src 当中，不要用写其他语言的方式来写 Go&lt;/p&gt;&lt;h3 id=&quot;utils，common&quot;&gt;&lt;a href=&quot;#utils，common&quot; class=&quot;headerlink&quot; title=&quot;utils，common&quot;/&gt;utils，common&lt;/h3&gt;&lt;p&gt;不要在项目中出现 utils 和 common 这种包，如果出现这种包，因为我们并不能从包中知道你这个包的作用，长久之后这个包就会变成一个大杂烩，所有东西都往这里面扔。&lt;br/&gt;有的同学这个时候会问说，那我们的工具函数应该放到哪里？怎么放？&lt;br/&gt;举个例子，我们当前使用 &lt;code&gt;gin&lt;/code&gt; 作为路由框架，但是 &lt;code&gt;gin&lt;/code&gt; 的 handler 注册其实不是很方便，所以我们做了一层封装，这个时候这个工具方法我们一般放在 &lt;code&gt;/pkg/ginx&lt;/code&gt; 目录下，表示这个是对 &lt;code&gt;gin&lt;/code&gt; 增强的包，不直接使用 &lt;code&gt;gin&lt;/code&gt; 作为包名的原因是因为我们在项目中也会引用 &lt;code&gt;gin&lt;/code&gt; 相同的命名一个是会导致误解，另一个是在同时导入的时候也会需要去进行重命名会比较麻烦&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;关于项目目录结构这种真的算是见仁见智，不同的理论有不同的方法，但是我觉得有两件事比较重要，就服务应用而言需要灵活应用，就基础库而言一定要统一，做的好不好和要不要做是两件事情，如果因为当前做的不够好而不做，那么越到后面就越做不了。&lt;br/&gt;下一篇文章会讲一讲依赖注入框架 wire 的使用与最佳(?)实践&lt;/p&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;/&gt;参考文献&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营-极客时间&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/golang-standards/project-layout/blob/master/README_zh.md&quot;&gt;golang-standards/project-layout · GitHub&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html&quot;&gt;Package Oriented Design&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://golang.org/doc/go1.4#internalpackages&quot;&gt;Go 1.4 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/&quot;&gt;I’ll take pkg over internal&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1&quot;&gt;https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;关注我获取更新&quot;&gt;&lt;a href=&quot;#关注我获取更新&quot; class=&quot;headerlink&quot; title=&quot;关注我获取更新&quot;/&gt;关注我获取更新&lt;/h2&gt;&lt;p&gt;看到这里了还不关注点赞走一波&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz&quot;&gt;博客&lt;/a&gt; 可以订阅 RSS，也可以点击首页通过 webpush 订阅浏览器消息&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/mohuishou&quot;&gt;Github&lt;/a&gt; Follow me&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.zhihu.com/people/mo-hui-shou-76&quot;&gt;知乎&lt;/a&gt; 关注账号，顺便点个 👍&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://toutiao.io/subjects/387401?f=new&quot;&gt;开发者头条&lt;/a&gt; 订阅订阅号，顺便点个 👍&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1ab739fd37e62813103eaa50b813d5f</guid>
<title>公司内U盘不能写入的解决方案</title>
<link>https://toutiao.io/k/55xb950</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;h3 id=&quot;一背景&quot;&gt;一、背景&lt;/h3&gt;
&lt;p&gt;因为安全原因，公司的电脑安装了安全软件，开启启动后就把U盘写权限关闭了，博主长期挂载移动硬盘使用，对日常使用造成很大困扰。本文提供两种思路，可实现公司内电脑U盘的读写。&lt;/p&gt;
&lt;p&gt;注：本文只针对windows。&lt;/p&gt;
&lt;h3 id=&quot;二方法1手动修改本地组策略&quot;&gt;二、方法1：手动修改本地组策略&lt;/h3&gt;
&lt;p&gt;点击windows键，输入gpedit.msc，打开本地组策略编辑器，依次找到：计算机配置--&amp;gt; 管理模板 --&amp;gt; 系统 --&amp;gt; 可移动存储访问。找到：可移动磁盘:拒绝写入权限，如果是已开启状态，则编辑改为未配置或已禁用即可实现U盘写入。如果还是不行，把U盘拔掉重新插入即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208161208393.png&quot; alt=&quot;image-20210208161208393&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三方法2虚拟器映射smb远程访问&quot;&gt;三、方法2：虚拟器映射smb远程访问&lt;/h3&gt;
&lt;p&gt;上面方法1对于临时写入够用了， 如果想挂载U盘或移动硬盘长期使用，每次开机启动都要重新配置一遍，很是麻烦。由于公司内安全软件是管理员权限开启启动，不能阻止它将本地组策略中的可移动磁盘:拒绝写入权限给开启。那有什么办法可以绕过这个权限呢？&lt;/p&gt;
&lt;p&gt;答案就是虚拟机，开机启动时把U盘挂载到虚拟中，然后共享samba给宿主机，开启读写权限，宿主机就可以正常读写U盘中的内容了。&lt;/p&gt;
&lt;p&gt;博主安装的是VirtualBox虚拟机。第一步当然是安装软件及系统，推荐安装debian最小镜像，因为这个镜像包小而且安全性高。操作习惯和Ubuntu一样，详细安装过程及网络配置请参考其他文档。&lt;/p&gt;
&lt;h5 id=&quot;1安装virtualbox扩展启用usb30支持&quot;&gt;1、安装VirtualBox扩展，启用USB3.0支持。&lt;/h5&gt;
&lt;p&gt;默认VirtualBox是不支持USB3.0的，需要安装扩展才能支持。&lt;/p&gt;
&lt;p&gt;下载官网链接: &lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;https://www.virtualbox.org/wiki/Downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细下载教程请参考：&lt;a href=&quot;https://blog.csdn.net/qzhn_/article/details/86365917&quot;&gt;https://blog.csdn.net/qzhn_/article/details/86365917&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装扩展包教程参考：&lt;a href=&quot;https://jingyan.baidu.com/article/3052f5a1b2dd39d6f21f862d.html&quot;&gt;https://jingyan.baidu.com/article/3052f5a1b2dd39d6f21f862d.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完成，打开虚拟机USB设备配置，出现USB3.0即表示安装成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208163042492.png&quot; alt=&quot;image-20210208163042492&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;2挂载u盘到虚拟机&quot;&gt;2、挂载U盘到虚拟机&lt;/h5&gt;
&lt;p&gt;虚拟机关机，打开配置，按以下步骤添加USB设备，USB控制器选择USB3.0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208163408809.png&quot; alt=&quot;image-20210208163408809&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动虚拟机，输入命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出现硬盘即为映射成功，记住红框中的Device名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208163231638.png&quot; alt=&quot;image-20210208163231638&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;3配置虚拟机启动挂载&quot;&gt;3、配置虚拟机启动挂载&lt;/h5&gt;
&lt;p&gt;默认硬盘是不会自动挂载的，通过以下步骤配置开机自动挂载。&lt;/p&gt;
&lt;p&gt;（1）安装驱动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install ntfs-3g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2) 编辑/etc/fstab, 再末尾加入如下内容就可以了，以下是我的配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/dev/sdb1       /mnt/move       ntfs-3g defaults,locale=zh_CN.UTF-8     0       0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启虚拟机，查看/mnt/move目录，看是不是正确列出U盘中的文件。&lt;/p&gt;
&lt;h5 id=&quot;3配置samba&quot;&gt;3、配置samba&lt;/h5&gt;
&lt;p&gt;Linux中安装samba配置项很多，一不小心就配置不对，这里推荐使用docker安装samba，我使用是的这个image：&lt;a href=&quot;https://github.com/dperson/samba&quot;&gt;https://github.com/dperson/samba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（1）安装docker，推荐使用国内daocloud一键安装命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -sSL https://get.daocloud.io/docker | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）docker启动samba，并支持开机启动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo docker run -d \
    --name samba \
    --restart unless-stopped \
    -p 139:139 \
    -p 445:445 \
    -v /mnt/move:/mount \
    -d dperson/samba \
    -u &quot;youusername;yourpassword&quot; \
    -s &quot;移动硬盘;/mount/;yes;no;no;all;yourusername&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将命令中的用户名密码改成你自己的，执行启动，在宿主机的文件资源管理器中输入，192.168.56.101是我的虚拟机ip，查看自己的虚拟机ip使用命令：sudo ifconfig&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\\192.168.56.101
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示出入用户名、密码。输入正确后进入弹出我们移动硬盘表示配置成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208164925982.png&quot; alt=&quot;image-20210208164925982&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后可以右键“移动硬盘”，映射网络驱动器，即可当成本地磁盘使用。&lt;/p&gt;
&lt;h5 id=&quot;4配置虚拟机开机启动&quot;&gt;4、配置虚拟机开机启动&lt;/h5&gt;
&lt;p&gt;右击VirtualBox中的虚拟机，点击创建桌面快捷方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/image-20210208165241154.png&quot; alt=&quot;image-20210208165241154&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开桌面，右击快捷方式，点最下面的属性，编辑“目标”栏，配置成headless模式。即不打开VirtualBox，直接无界面启动虚拟机。将下面中VirtualBox路径和虚拟机ID改成你自己的，并保存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;D:\Program Files\Oracle\VirtualBox\VBoxManage.exe&quot; startvm &quot;{7a1f224f-af3f-4850-bc39-20f76d83db83}&quot; --type headless
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一步，将此快捷方式移动到，即可开启启动虚拟机。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\&amp;lt;your name&amp;gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;四总结&quot;&gt;四、总结&lt;/h3&gt;
&lt;p&gt;本文提供了两种解决公司内U盘不能写入的方法，第一种适合临时使用，第二种适合长期挂载U盘使用。你还有什么更好的方法吗，欢迎讨论。&lt;/p&gt;
&lt;p&gt;本文作者：&lt;strong&gt;木小丰&lt;/strong&gt;，美团Java高级工程师，不定期分享软件研发过程中的实践、思考。&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;https://lesofn.com/jie-jue-gong-si-nei-u-pan-bu-neng-xie-ru-de-wen-ti&quot;&gt;https://lesofn.com/jie-jue-gong-si-nei-u-pan-bu-neng-xie-ru-de-wen-ti&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公共号：Java研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B0%8F_1607785087313.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3b8e20cca6b893e339f25e7c46d07f1</guid>
<title>闲鱼如何一招保证推荐流稳如泰山</title>
<link>https://toutiao.io/k/mmzvygh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲鱼是阿里巴巴旗下品牌，是中国最大的闲置交易平台，于2014年成立至今，是继淘宝、天猫之后，阿里巴巴正在催生的第三个万亿级平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闲鱼技术部不断在驱动业务变革，通过创新追寻更多价值。从出版书籍、峰会发声，到开源专利、海外传播。闲不住，上闲鱼——技术团队对极致的探索与深耕是我们的底气。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 立即加入 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1、招&lt;/span&gt;&lt;span&gt;&lt;strong&gt;项目经理PMO&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;/客户端/服务端/前端/数据+算法/质量工程师&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、发简历给guicai.gxy@alibaba-inc.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、您还可以在头条、知乎、掘金、facebook、twitter找到我们&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac851d13a3b8f22ccb454d85007648a8</guid>
<title>C++ folly 库解读之 Fbstring：一个完美替代 std::string 的库（上）</title>
<link>https://toutiao.io/k/uftea8o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;string 常见的三种实现方式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Fbstring 介绍&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Storage strategies&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Implementation highlights&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Benchmark&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主要类&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;字符串存储数据结构&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;small strings&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;medium strings&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;large strings&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何区分字符串类型 category&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;小端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;small strings&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;medium strings&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;large strings&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;category()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;capacity()&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;字符串初始化&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;initSmall&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;initMedium&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;initLarge&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;特殊的构造函数 —— 不拷贝用户传入的字符串&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在引入&lt;span&gt;fbstring&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;之前，我们首先再回顾一下 string 常见的三种实现方式。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;string 常见的三种实现方式&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;string 中比较重要的 3 个字段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;char *data. 指向存放字符串的首地址（在 SSO 的某些实现方案中可能没有此字段）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size_t size. 字符串长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size_t capacity. 字符串容量。capacity &amp;gt;= size. 在字符串相加、reserve 等场景下会用到此字段。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;eager copy&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是最简单、最好理解的一种，在每次拷贝时将原 string 对应的内存以及所持有的动态资源完整地复制一份，即没有任何特殊处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42061855670103093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZmRibpI3oIuqpwUZEpPP1qbfcwlBAz1aV4rCBpdWI7ZVpgpkibatvjAtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实现简单。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个对象互相独立，不用考虑那么多乱七八糟的场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;COW&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也算是计算机里的基本思想了。不同于 eager copy 的每次拷贝都会复制，此种实现方式为写时复制，即 copy-on-write。只有在某个 string 要对共享对象进行修改时，才会真正执行拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存在共享机制，所以需要一个&lt;code&gt;std::atomic&amp;lt;size_t&amp;gt;&lt;/code&gt;，代表被多少对象共享。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZMXiaCOXHNefbeE3OibDoEBh198xRaspYYGOsTSkJyibGzw6KibaH0NDVJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.49074074074074076&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写时复制：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.684053651266766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93Z6EuB4hhlb6qWkaoQTBA9c6kJpWfUVLUd8jBuw9aP7RmLMe5CKic9Ntg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;refcount 需要原子操作，性能有损耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;某些情况下会带来意外的开销。比如非 const 成员使用&lt;code&gt;[]&lt;/code&gt;，这会触发 COW，因为无法知晓应用程序是否会对返回的字符做修改。典型的如&lt;span&gt;Legality of COW std::string implementation in C++11&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;中举的例子：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;s&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;str&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* p = s.data();&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &lt;span&gt;s2&lt;/span&gt;&lt;span&gt;(s)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    (&lt;span&gt;void&lt;/span&gt;) s[&lt;span&gt;0&lt;/span&gt;];         &lt;span&gt;// 触发COW&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;;      &lt;span&gt;// p指向的原有空间已经无效&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;其他更细节的缺点可以参考：&lt;span&gt;std::string 的 Copy-on-Write：不如想象中美好&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SSO&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Small String Optimization. &lt;strong&gt;基于字符串大多数比较短的特点&lt;/strong&gt;，利用 string 对象本身的栈空间来存储短字符串。而当字符串长度大于某个临界值时，则使用 eager copy 的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSO 下，string 的数据结构会稍微复杂点，使用 union 来区分短字符串和长字符串的场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *start;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kLocalSize = &lt;span&gt;15&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;union&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; buffer[kLocalSize+&lt;span&gt;1&lt;/span&gt;];      &lt;span&gt;// 满足条件时，用来存放短字符串&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;size_t&lt;/span&gt; capacity;&lt;br/&gt;  }data;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;短字符串，SSO：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9580536912751678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZiaR7rJ8PTQzgEXoCt5PWD1P0oRX2Exiayeicw5WdFXZYwImicw5MxB03Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长字符串，eager copy：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5677179962894249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZicA52ZoFv8FiakPqnWMT0PKEOFKlvbYh5eUqgGGjspOia8XeqZ2215icAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1078&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种数据结构的实现下，SSO 的阈值一般是 15 字节。folly 的 fbstring 在 SSO 场景下，数据结构做了一些优化，可以存储 23 个字节，后面会提到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;string 对象占用空间比 eager copy 和 cow 要大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Fbstring 介绍&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fbstring 可以 100%兼容 std::string。配合三种存储策略和&lt;span&gt;jemalloc&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，可以显著的提高 string 的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fbstring 支持 32-bit、64-bit、little-endian、big-endian.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Storage strategies&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Small Strings (&amp;lt;= 23 chars) ，使用 SSO.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Medium strings (24 - 255 chars)，使用 eager copy.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Large strings (&amp;gt; 255 chars)，使用 COW.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Implementation highlights&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与 std::string 100%兼容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;COW 存储时对于引用计数线程安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 Jemalloc 友好。如果检测到使用 jemalloc，那么将使用 jemalloc 的一些非标准扩展接口来提高性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;find()&lt;/code&gt;使用简化版的&lt;span&gt;Boyer-Moore algorithm&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。在查找成功的情况下，相对于&lt;code&gt;string::find()&lt;/code&gt;有 30 倍的性能提升。在查找失败的情况下也有 1.5 倍的性能提升。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以与 std::string 互相转换。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Benchmark&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;span&gt;FBStringBenchmark.cpp&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;中。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主要类&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22646007151370678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZiaDT8mBqG62BmaqYFI1uwOR9nR7S0wMQEiavJVaIluib9xhhJlIH9dKSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1678&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;::folly::fbstring str(&quot;abc&quot;)&lt;/code&gt;中的 fbstring 为 basic_fbstring&lt;char&gt;的别名 ：&lt;code&gt;typedef basic_fbstring&amp;lt;char&amp;gt; fbstring;&lt;/code&gt;&lt;/char&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;basic&lt;em&gt;fbstring 在 fbstring_core 提供的接口之上，实现了 std::string 定义的所有接口。里面有一个私有变量 store&lt;/em&gt;，默认值即为 fbstring_core。basic_fbstring 的定义如下，比 std::basic_string 只多了一个默认的模板参数 Storage：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;br/&gt;    &lt;span&gt;typename&lt;/span&gt; E,&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; = &lt;span&gt;std&lt;/span&gt;:&lt;/span&gt;:char_traits&amp;lt;E&amp;gt;,&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; = &lt;span&gt;std&lt;/span&gt;:&lt;/span&gt;:allocator&amp;lt;E&amp;gt;,&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Storage&lt;/span&gt; = &lt;span&gt;fbstring_core&lt;/span&gt;&amp;lt;E&amp;gt;&amp;gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;basic_fbstring&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fbstring_core 负责字符串的存储及字符串相关的操作，例如 init、copy、reserve、shrink 等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符串存储数据结构&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最重要的 3 个数据结构 union{Char small*, MediumLarge ml*}、MediumLarge、RefCounted，定义在 fbstring_core 中，基本上所有的字符串操作都离不开这三个数据结构。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;RefCounted&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt; refCount_;&lt;br/&gt;    Char data_[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; RefCounted * &lt;span&gt;create&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; * size)&lt;/span&gt;&lt;/span&gt;;       &lt;span&gt;// 创建一个RefCounted&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; RefCounted * &lt;span&gt;create&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Char * data, &lt;span&gt;size_t&lt;/span&gt; * size)&lt;/span&gt;&lt;/span&gt;;     &lt;span&gt;// ditto&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incrementRefs&lt;/span&gt;&lt;span&gt;(Char * p)&lt;/span&gt;&lt;/span&gt;;     &lt;span&gt;// 增加一个引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;decrementRefs&lt;/span&gt;&lt;span&gt;(Char * p)&lt;/span&gt;&lt;/span&gt;;    &lt;span&gt;// 减少一个引用&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 其他函数定义&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;MediumLarge&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  Char* data_;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; size_;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; capacity_;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;capacity&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; kIsLittleEndian ? capacity_ &amp;amp; capacityExtractMask : capacity_ &amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCapacity&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; cap, Category cat)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    capacity_ = kIsLittleEndian&lt;br/&gt;        ? cap | (&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(cat) &amp;lt;&amp;lt; kCategoryShift)&lt;br/&gt;        : (cap &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) | &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(cat);&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;union&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;uint8_t&lt;/span&gt; bytes_[&lt;span&gt;sizeof&lt;/span&gt;(MediumLarge)];          &lt;span&gt;// For accessing the last byte.&lt;/span&gt;&lt;br/&gt;    Char small_[&lt;span&gt;sizeof&lt;/span&gt;(MediumLarge) / &lt;span&gt;sizeof&lt;/span&gt;(Char)];&lt;br/&gt;    MediumLarge ml_;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;small strings（SSO）时，使用 union 中的 Char small_存储字符串，即对象本身的栈空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;medium strings（eager copy）时，使用 union 中的&lt;code&gt;MediumLarge ml_&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Char* data_ ：指向分配在堆上的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size&lt;em&gt;t size&lt;/em&gt;：字符串长度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size&lt;em&gt;t capacity&lt;/em&gt; ：字符串容量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;large strings（cow）时， 使用&lt;code&gt;MediumLarge ml_&lt;/code&gt;和 RefCounted：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RefCounted.refCount_ ：共享字符串的引用计数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RefCounted.data_[1] : &lt;strong&gt;flexible array.&lt;/strong&gt; 存放字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ml*.data&lt;em&gt;指向 RefCounted.data&lt;/em&gt;，ml*.size&lt;em&gt;与 ml&lt;/em&gt;.capacity_的含义不变。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这里有一个问题是：SSO 情况下的 size 和 capacity 存在哪里了？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;capacity : 首先 SSO 的场景并不需要 capacity，因为此时利用的是栈空间，或者理解此种情况下的 capacity=maxSmallSize.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size : 利用 small_的一个字节来存储 size，&lt;strong&gt;而且具体存储的不是 size，而是&lt;code&gt;maxSmallSize - s&lt;/code&gt;&lt;/strong&gt;（maxSmallSize=23，再转成 char 类型），因为这样可以 SSO 多存储一个字节，具体原因后面详细讲。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;small strings :&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZjhN2oEDUVuTWib79CBdGUMgDN3qwHdQdd69MyOj7HysicekEkibrNkv0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4351851851851852&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;medium strings :&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZVic0tyreDbLuldVOicJzcQrqFr9ncXKB1O9LPk2VObry6SEsva2ZyxwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.55&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;large strings :&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93Zn1rF7teY0M2qkaf4qSib0navbPLY308GAJDFPugwQyUYjUcTwia0ar6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7777777777777778&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何区分字符串类型 category&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串的 small/medium/large 类型对外部透明，而且针对字符串的各种操作例如 copy、shrink、reserve、赋值等等，三种类型的处理方式都不一样，&lt;strong&gt;所以，我们需要在上面的数据结构中做些“手脚”，来区分不同的字符串类型。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为只有三种类型，所以只需要 2 个 bit 就能够区分。相关的数据结构为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;uint8_t&lt;/span&gt; category_type;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Category&lt;/span&gt; :&lt;/span&gt; category_type {&lt;br/&gt;    isSmall = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    isMedium = kIsLittleEndian ? &lt;span&gt;0x80&lt;/span&gt; : &lt;span&gt;0x2&lt;/span&gt;,       &lt;span&gt;//  10000000 , 00000010&lt;/span&gt;&lt;br/&gt;    isLarge = kIsLittleEndian ? &lt;span&gt;0x40&lt;/span&gt; : &lt;span&gt;0x1&lt;/span&gt;,        &lt;span&gt;//  01000000 , 00000001&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kIsLittleEndian 为判断当前平台的大小端，大端和小端的存储方式不同。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;small strings&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;category 与 size 共同存放在 small_的最后一个字节中（size 最大为 23，所以可以存下），考虑到大小端，所以有移位操作，这主要是为了让 category()的判断更简单，后面再详细分析。具体代码在 setSmallSize 中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setSmallSize&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ......&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;auto&lt;/span&gt; shift = kIsLittleEndian ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  small_[maxSmallSize] = &lt;span&gt;char&lt;/span&gt;((maxSmallSize - s) &amp;lt;&amp;lt; shift);&lt;br/&gt;  ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93Zax1XKEiagk6gzibUib1xofvIASCedCHBDUDxX5Hd5sx07bJ0rWlNzmcGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5787037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;medium strings&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有人注意到了，在 MediumLarge 结构体中定义了两个方法，&lt;code&gt;capacity()&lt;/code&gt;和&lt;code&gt;setCapacity(size_t cap, Category cat)&lt;/code&gt;，其中 setCapacity 即同时设置 capacity 和 category :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; kCategoryShift = (&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;size_t&lt;/span&gt;) - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCapacity&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; cap, Category cat)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    capacity_ = kIsLittleEndian&lt;br/&gt;        ? cap | (&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(cat) &amp;lt;&amp;lt; kCategoryShift)&lt;br/&gt;        : (cap &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) | &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(cat);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;小端时，将 category = isMedium = 0x80 向左移动&lt;code&gt;(sizeof(size_t) - 1) * 8&lt;/code&gt;位，即移到最高位的字节中，再与 capacity 做或运算。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大端时，将 category = isMedium = 0x2 与 cap &amp;lt;&amp;lt; 2 做或运算即可，左移 2 位的目的是给 category 留空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设 64 位机器，capacity = 100 :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5846153846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93Zefd3fYbBolXBwSNhAzPdoiaCeYktmEic9kNXWMY3DNrP3mu3MqEKAorQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;large strings&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样使用 MediumLarge 的 setCapacity，算法相同，只是 category 的值不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 64 位机器，capacity = 1000 ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6088834053053671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93Zia50Wt4ZVJf77Uq30WmEic1xXLibgcukRf8YwhYAuErE1HZ4woudxibe3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1621&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;category()&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;category()&lt;/code&gt;为最重要的函数之一，作用是获取字符串的类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;uint8_t&lt;/span&gt; categoryExtractMask = kIsLittleEndian ? &lt;span&gt;0xC0&lt;/span&gt; : &lt;span&gt;0x3&lt;/span&gt;;    &lt;span&gt;// 11000000 , 00000011&lt;/span&gt;&lt;br/&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; lastChar = &lt;span&gt;sizeof&lt;/span&gt;(MediumLarge) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;union&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;uint8_t&lt;/span&gt; bytes_[&lt;span&gt;sizeof&lt;/span&gt;(MediumLarge)];          &lt;span&gt;// For accessing the last byte.&lt;/span&gt;&lt;br/&gt;    Char small_[&lt;span&gt;sizeof&lt;/span&gt;(MediumLarge) / &lt;span&gt;sizeof&lt;/span&gt;(Char)];&lt;br/&gt;    MediumLarge ml_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Category &lt;span&gt;category&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// works for both big-endian and little-endian&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;Category&amp;gt;(bytes_[lastChar] &amp;amp; categoryExtractMask);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bytes_定义在 union 中，从注释可以看出来，是为了配合 lastChar 更加方便的取该结构最后一个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配合上面三种类型字符串的存储，可以很容易理解这一行代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小端&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4276401564537158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZE62zmLdvmdMeBnCp1vEFM4kKrhDdruiaX4433SzaZiaHQIeaiaaqNe1tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大端&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4050925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/On8kUXFskR1rE9ibNCZdEF9F2Aib7mx93ZFGl2iaUUicsh2f0UuENHeuqy2PfKRn7vibibX3jASY2dA3gtvIu0eGl0ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;capacity()&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取字符串的 capaticy，因为 capacity 与 category 存储都在一起，所以一起看比较好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样分三种情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;capacity&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;switch&lt;/span&gt; (category()) {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; Category::isSmall:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; maxSmallSize;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; Category::isLarge:&lt;br/&gt;      &lt;span&gt;// For large-sized strings, a multi-referenced chunk has no&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// available capacity. This is because any attempt to append&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// data would trigger a new allocation.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (RefCounted::refs(ml_.data_) &amp;gt; &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ml_.size_;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; Category::isMedium:&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ml_.capacity();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;small strings : 直接返回 maxSmallSize，前面有分析过。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;medium strings : 返回 ml_.capacity()。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;large strings :&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当字符串引用大于 1 时，直接返回 size。因为此时的 capacity 是没有意义的，任何 append data 操作都会触发一次 cow&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，返回 ml_.capacity()。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下 ml.capacity() :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;uint8_t&lt;/span&gt; categoryExtractMask = kIsLittleEndian ? &lt;span&gt;0xC0&lt;/span&gt; : &lt;span&gt;0x3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; kCategoryShift = (&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;size_t&lt;/span&gt;) - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; capacityExtractMask = kIsLittleEndian&lt;br/&gt;      ? ~(&lt;span&gt;size_t&lt;/span&gt;(categoryExtractMask) &amp;lt;&amp;lt; kCategoryShift)&lt;br/&gt;      : &lt;span&gt;0x0&lt;/span&gt; &lt;span&gt;/* unused */&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;capacity&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; kIsLittleEndian ? capacity_ &amp;amp; capacityExtractMask : capacity_ &amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;categoryExtractMask 和 kCategoryShift 之前遇到过，分别用来计算 category 和小端情况下将 category 左移 kCategoryShift 位。capacityExtractMask 的目的就是消掉 category，让 capacity_中只有 capacity。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对着上面的每种情况下字符串的存储的图，应该很好理解，这里不细说了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;size()&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;size&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; ret = ml_.size_;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;/* constexpr */&lt;/span&gt; (kIsLittleEndian) {&lt;br/&gt;    &lt;span&gt;// We can save a couple instructions, because the category is&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// small iff the last char, as unsigned, is &amp;lt;= maxSmallSize.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;typename&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::make_unsigned&amp;lt;Char&amp;gt;::type UChar;&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; maybeSmallSize = &lt;span&gt;size_t&lt;/span&gt;(maxSmallSize) -&lt;br/&gt;        &lt;span&gt;size_t&lt;/span&gt;(&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;UChar&amp;gt;(small_[maxSmallSize]));&lt;br/&gt;    &lt;span&gt;// With this syntax, GCC and Clang generate a CMOV instead of a branch.&lt;/span&gt;&lt;br/&gt;    ret = (&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;ssize_t&lt;/span&gt;&amp;gt;(maybeSmallSize) &amp;gt;= &lt;span&gt;0&lt;/span&gt;) ? maybeSmallSize : ret;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    ret = (category() == Category::isSmall) ? smallSize() : ret;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小端的情况下，medium strings 和 large strings 对应的 ml_的高字节存储的是 category（0x80、0x40），而 small strings 存储的是 size，所以正如注释说的，可以先判断 kIsLittleEndian &amp;amp;&amp;amp; maybeSmall，会快一些，不需要调用 smallSize()。而且现在绝大多数平台都是小端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是大端，那么如果是 small，调用 smallSize()，否则返回 ml.size_;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;smallSize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  assert(category() == Category::isSmall);&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;auto&lt;/span&gt; shift = kIsLittleEndian ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;auto&lt;/span&gt; smallShifted = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(small_[maxSmallSize]) &amp;gt;&amp;gt; shift;&lt;br/&gt;  assert(&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(maxSmallSize) &amp;gt;= smallShifted);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(maxSmallSize) - smallShifted;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较简单，不说了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符串初始化&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 fbstring_core 的构造函数中，根据字符串的长度，调用 3 种不同类型的初始化函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fbstring_core(&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; Char* &lt;span&gt;const&lt;/span&gt; data,&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; size,&lt;br/&gt;    &lt;span&gt;bool&lt;/span&gt; disableSSO = FBSTRING_DISABLE_SSO) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!disableSSO &amp;amp;&amp;amp; size &amp;lt;= maxSmallSize) {&lt;br/&gt;    initSmall(data, size);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (size &amp;lt;= maxMediumSize) {&lt;br/&gt;    initMedium(data, size);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    initLarge(data, size);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;initSmall&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Char&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fbstring_core&lt;/span&gt;&amp;lt;Char&amp;gt;:&lt;/span&gt;:initSmall(&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; Char* &lt;span&gt;const&lt;/span&gt; data,&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; size) {&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// If data is aligned, use fast word-wise copying. Otherwise,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// use conservative memcpy.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// The word-wise path reads bytes which are outside the range of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// the string, and makes ASan unhappy, so we disable it when&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// compiling with ASan.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;ifndef&lt;/span&gt; FOLLY_SANITIZE_ADDRESS&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt;(data) &amp;amp; (&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;size_t&lt;/span&gt;) - &lt;span&gt;1&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; byteSize = size * &lt;span&gt;sizeof&lt;/span&gt;(Char);&lt;br/&gt;    &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; wordWidth = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;size_t&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; ((byteSize + wordWidth - &lt;span&gt;1&lt;/span&gt;) / wordWidth) { &lt;span&gt;// Number of words.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;br/&gt;        ml_.capacity_ = &lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt;*&amp;gt;(data)[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;        FOLLY_FALLTHROUGH;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;        ml_.size_ = &lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt;*&amp;gt;(data)[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        FOLLY_FALLTHROUGH;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;        ml_.data_ = *&lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;Char**&amp;gt;(&lt;span&gt;const_cast&lt;/span&gt;&amp;lt;Char*&amp;gt;(data));&lt;br/&gt;        FOLLY_FALLTHROUGH;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;#endif&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      fbstring_detail::podCopy(data, data + size, small_);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  setSmallSize(size);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，如果传入的字符串地址是内存对齐的，&lt;strong&gt;则配合 reinterpret_cast 进行 word-wise copy，提高效率。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;否则，调用 podCopy 进行 memcpy。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，通过 setSmallSize 设置 small string 的 size。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;setSmallSize :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setSmallSize&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// Warning: this should work with uninitialized strings too,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// so don&#x27;t assume anything about the previous value of&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// small_[maxSmallSize].&lt;/span&gt;&lt;br/&gt;  assert(s &amp;lt;= maxSmallSize);&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;auto&lt;/span&gt; shift = kIsLittleEndian ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  small_[maxSmallSize] = &lt;span&gt;char&lt;/span&gt;((maxSmallSize - s) &amp;lt;&amp;lt; shift);&lt;br/&gt;  small_[s] = &lt;span&gt;&#x27;\0&#x27;&lt;/span&gt;;&lt;br/&gt;  assert(category() == Category::isSmall &amp;amp;&amp;amp; size() == s);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前提到过，small strings 存放的 size 不是真正的 size，是&lt;code&gt;maxSmallSize - size&lt;/code&gt;，这样做的原因是可以 small strings 可以多存储一个字节 。&lt;strong&gt;因为假如存储 size 的话，small&lt;em&gt;中最后两个字节就得是\0 和 size，但是存储&lt;code&gt;maxSmallSize - size&lt;/code&gt;，当 size == maxSmallSize 时，small&lt;/em&gt;的最后一个字节恰好也是\0。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;initMedium&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Char&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span&gt;FOLLY_NOINLINE&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fbstring_core&lt;/span&gt;&amp;lt;Char&amp;gt;:&lt;/span&gt;:initMedium(&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; Char* &lt;span&gt;const&lt;/span&gt; data,&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; size) {&lt;br/&gt;  &lt;span&gt;// Medium strings are allocated normally. Don&#x27;t forget to&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// allocate one extra Char for the terminating null.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;auto&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; allocSize = goodMallocSize((&lt;span&gt;1&lt;/span&gt; + size) * &lt;span&gt;sizeof&lt;/span&gt;(Char));&lt;br/&gt;  ml_.data_ = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;Char*&amp;gt;(checkedMalloc(allocSize));&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (FOLLY_LIKELY(size &amp;gt; &lt;span&gt;0&lt;/span&gt;)) {&lt;br/&gt;    fbstring_detail::podCopy(data, data + size, ml_.data_);&lt;br/&gt;  }&lt;br/&gt;  ml_.size_ = size;&lt;br/&gt;  ml_.setCapacity(allocSize / &lt;span&gt;sizeof&lt;/span&gt;(Char) - &lt;span&gt;1&lt;/span&gt;, Category::isMedium);&lt;br/&gt;  ml_.data_[size] = &lt;span&gt;&#x27;\0&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;folly 会通过 canNallocx 函数检测是否使用 jemalloc，如果是，会使用 jemalloc 来提高内存分配的性能。关于 jemalloc 我也不是很熟悉，感兴趣的可以查查，有很多资料。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;所有的动态内存分配都会调用 goodMallocSize，获取一个对 jemalloc 友好的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再通过 checkedMalloc 真正申请内存，存放字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 podCopy 进行 memcpy，与 initSmall 的 podCopy 一样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后再设置 size、capacity、category 和\0。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;initLarge&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt; &amp;lt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Char&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span&gt;FOLLY_NOINLINE&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fbstring_core&lt;/span&gt;&amp;lt;Char&amp;gt;:&lt;/span&gt;:initLarge(&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; Char* &lt;span&gt;const&lt;/span&gt; data,&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; size) {&lt;br/&gt;  &lt;span&gt;// Large strings are allocated differently&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; effectiveCapacity = size;&lt;br/&gt;  &lt;span&gt;auto&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; newRC = RefCounted::create(data, &amp;amp;effectiveCapacity);&lt;br/&gt;  ml_.data_ = newRC-&amp;gt;data_;&lt;br/&gt;  ml_.size_ = size;&lt;br/&gt;  ml_.setCapacity(effectiveCapacity, Category::isLarge);&lt;br/&gt;  ml_.data_[size] = &lt;span&gt;&#x27;\0&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 medium strings 最大的不同是会通过 RefCounted::create 创建 RefCounted 用于共享字符串：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;RefCounted&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;size_t&lt;/span&gt;&amp;gt; refCount_;&lt;br/&gt;    Char data_[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;getDataOffset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; offsetof(RefCounted, data_);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; RefCounted* &lt;span&gt;create&lt;/span&gt;&lt;span&gt;(&lt;span&gt;size_t&lt;/span&gt;* size)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; allocSize =&lt;br/&gt;          goodMallocSize(getDataOffset() + (*size + &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;sizeof&lt;/span&gt;(Char));&lt;br/&gt;      &lt;span&gt;auto&lt;/span&gt; result = &lt;span&gt;static_cast&lt;/span&gt;&amp;lt;RefCounted*&amp;gt;(checkedMalloc(allocSize));&lt;br/&gt;      result-&amp;gt;refCount_.store(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_release);&lt;br/&gt;      *size = (allocSize - getDataOffset()) / &lt;span&gt;sizeof&lt;/span&gt;(Char) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; RefCounted* &lt;span&gt;create&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; Char* data, &lt;span&gt;size_t&lt;/span&gt;* size)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; effectiveSize = *size;&lt;br/&gt;      &lt;span&gt;auto&lt;/span&gt; result = create(size);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (FOLLY_LIKELY(effectiveSize &amp;gt; &lt;span&gt;0&lt;/span&gt;)) {&lt;br/&gt;        fbstring_detail::podCopy(data, data + effectiveSize, result-&amp;gt;data_);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ml*.data*指向的是 RefCounted.data_.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getDataOffset()用 offsetof 函数获取 data*在 RefCounted 结构体内的偏移，&lt;code&gt;Char data*[1]&lt;/code&gt;为 flexible array，存放字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注意对&lt;code&gt;std::atomic&amp;lt;size_t&amp;gt; refCount_&lt;/code&gt;进行原子操作的 c++ memory model :&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;store，设置引用数为 1 : std::memory_order_release&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;load，获取当前共享字符串的引用数: std::memory_order_acquire&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;add/sub。增加/减少一个引用 : std::memory_order_acq_rel&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;c++ memory model 是另外一个比较大的话题，可以参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Memory model synchronization modes&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNDI5NzEzNg==&amp;amp;mid=2651159677&amp;amp;idx=1&amp;amp;sn=f246d11601ed006b592f813e27f6a4fc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;一文带你看懂 C++11 的内存模型&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C++11 中的内存模型下篇 - C++11 支持的几种内存模型&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;特殊的构造函数 —— 不拷贝用户传入的字符串&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的三种构造，都是将应用程序传入的字符串，不管使用 word-wise copy 还是 memcpy，拷贝到 fbstring_core 中，且在 medium 和 large 的情况下，需要动态分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fbstring 提供了一个特殊的构造函数，让 fbstring_core 接管应用程序自己分配的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;basic_fbstring 的构造函数，并调用 fbstring_core 相应的构造函数。&lt;strong&gt;注意这里 AcquireMallocatedString 为 enum class，比使用 int 和 bool 更可读。&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * Defines a special acquisition method for constructing fbstring&lt;br/&gt; * objects. AcquireMallocatedString means that the user passes a&lt;br/&gt; * pointer to a malloc-allocated string that the fbstring object will&lt;br/&gt; * take into custody.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AcquireMallocatedString&lt;/span&gt; {&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Nonstandard constructor&lt;/span&gt;&lt;br/&gt;basic_fbstring(value_type *s, size_type n, size_type c,&lt;br/&gt;                 AcquireMallocatedString a)&lt;br/&gt;      : store_(s, n, c, a) {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;basic_fbstring 调用相应的 fbstring_core 构造函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Snatches a previously mallocated string. The parameter &quot;size&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// is the size of the string, and the parameter &quot;allocatedSize&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// is the size of the mallocated block.  The string must be&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// \0-terminated, so allocatedSize &amp;gt;= size + 1 and data[size] == &#x27;\0&#x27;.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// So if you want a 2-character string, pass malloc(3) as &quot;data&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// pass 2 as &quot;size&quot;, and pass 3 as &quot;allocatedSize&quot;.&lt;/span&gt;&lt;br/&gt;fbstring_core(Char * &lt;span&gt;const&lt;/span&gt; data,&lt;br/&gt;              &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; size,&lt;br/&gt;              &lt;span&gt;const&lt;/span&gt; &lt;span&gt;size_t&lt;/span&gt; allocatedSize,&lt;br/&gt;              AcquireMallocatedString) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (size &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    FBSTRING_ASSERT(allocatedSize &amp;gt;= size + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    FBSTRING_ASSERT(data[size] == &lt;span&gt;&#x27;\0&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// Use the medium string storage&lt;/span&gt;&lt;br/&gt;    ml_.data_ = data;&lt;br/&gt;    ml_.size_ = size;&lt;br/&gt;    &lt;span&gt;// Don&#x27;t forget about null terminator&lt;/span&gt;&lt;br/&gt;    ml_.setCapacity(allocatedSize - &lt;span&gt;1&lt;/span&gt;, Category::isMedium);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// No need for the memory&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(data);&lt;br/&gt;    reset();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出这里没有拷贝字符串的过程，而是直接接管了上游传递过来的指针指向的内存。但是，正如注释说的，这里直接使用了 medium strings 的存储方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 folly/io/IOBuf.cpp 中的调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Ensure NUL terminated&lt;/span&gt;&lt;br/&gt;*writableTail() = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;fbstring &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;      &lt;span&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;*&amp;gt;(writableData()),&lt;br/&gt;      length(),&lt;br/&gt;      capacity(),&lt;br/&gt;      AcquireMallocatedString())&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;fbstring: &lt;em&gt;https://github.com/facebook/folly/blob/master/folly/docs/FBString.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Legality of COW std::string implementation in C++11: &lt;em&gt;https://stackoverflow.com/questions/12199710/legality-of-cow-stdstring-implementation-in-c11&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;std::string 的 Copy-on-Write：不如想象中美好: &lt;em&gt;https://www.cnblogs.com/promise6522/archive/2012/03/22/2412686.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;jemalloc: &lt;em&gt;http://jemalloc.net/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Boyer-Moore algorithm: &lt;em&gt;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;FBStringBenchmark.cpp: &lt;em&gt;https://github.com/facebook/folly/blob/master/folly/test/FBStringBenchmark.cpp&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Memory model synchronization modes: &lt;em&gt;https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;C++11 中的内存模型下篇 - C++11 支持的几种内存模型: &lt;em&gt;https://www.codedump.info/post/20191214-cxx11-memory-model-2/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>