<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fb7e0acfbf93b24ead313a14ce2405fb</guid>
<title>徐尧：如何搭建好的数据指标体系？</title>
<link>https://toutiao.io/k/w9ynkus</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-backh=&quot;156&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;561&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;156&quot; data-fileid=&quot;100072321&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxe53FSEJr7ogaf9QJMSV0iboV8bKNibavEhvl3VqpqOQVXI1r4kwgIhLjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAx0xHQlmCpU1ErH4HDb1boeHNosDFibMhhoJ6ImXLsz8GpfY7vgfylyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：徐尧 止观科技 首席技术顾问&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理&lt;/span&gt;&lt;span&gt;：朱佳佳 北京航空航天大学&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;随着经济增速放缓，科学、有效地引领业务持续增长，已成为企业发展的首要任务。&lt;/span&gt;&lt;span&gt;如何有效地利用数据指标体系，将决策方向从“业务经验驱动”向“数据量化驱动”转型，成为企业的关注要点。&lt;/span&gt;&lt;span&gt;好的指标体系能够监控业务变化，当业务出现问题时，数据人员可以通过指标体系进行问题回溯和下钻来准确定位到问题，反馈给业务解决相应的问题。&lt;/span&gt;&lt;span&gt;今天会和大家分享一下如何搭建数据指标体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要内容包括以下几大方面：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;指标体系的用途&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本节主要回答两个问题，一是为什么需要数据指标体系，二是数据指标体系对于工作有何帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 为什么需要数据指标体系？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SALH8PGnqb64r1DbYjmkxJm03eYLEGCq4d6QcagR9916Mn1CIosXmz2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现实中，数据相关人员&lt;/span&gt;&lt;span&gt;常常要回答与公司业务相关的核心指标是什么，比如&lt;/span&gt;&lt;span&gt;商品交易总额GMV，&lt;/span&gt;&lt;span&gt;月活MAU，新增付费用户等。如果核心指标变化了，我们需要知道为什么变化，受哪些因素影响，怎么解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过诊断、倒推的方式去解决上诉问题，不能较快的对这些问题给出答案，比较耗费时间，且容易遗漏信息，不能保证分析的颗粒度足够细。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 数据指标体系对工作有何帮助？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAzcgM5qVVtQ3ptSorOstLFH927zEvQ9IF7kqXzg8K5RWhjuD69pDQeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有了数据指标体系，它能够发挥以下作用：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自动拆解指标：在搭建数据指标体系的过程中，按照整个链路和流程进行拆解，将拆解逻辑贯穿在整个指标体系搭建的过程当中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主动发现问题：有了数据指标体系，我们可以清晰的看到各种指标的上升或者下降，能够通过多个维度完全量的流程来帮我们分析，也可以帮助我们主动发现问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;及时检测效果：构建的指标体系是从头至尾的，在这个过程中任何环节出现了问题，都可以观察到原因所在。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何搭建指标体系&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;前面&lt;/span&gt;&lt;span&gt;描述了搭建数据指标体系的作用，下面分享下如何搭建指标体系，包括&lt;/span&gt;&lt;/span&gt;&lt;span&gt;构建指标体系的具体步骤，以及搭建过程中的一些注意事项。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAxqzPzdNQ2CGKeMJfpURMIXebJziccNCjiaVXh9ial5MyY7SJ1xT8onIjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的搭建指标体系的方法，就是OSM模型：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; O是Object（目标），也就是我们希望实现的业务目标。它可以是公司层面的，也可以是针对某条业务线的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;S是Strategy（策略），是为了实现以上目标，我们会采取的具体的行动策略。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;M是Measure（度量），用来衡量我们的策略是否有效，以及目标是否达成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;搭建指标体系有四个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面具体讲解这四步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;确定核心指标（北极星指标），对应OSM模型中的O&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SA40Ofl5iamPgIibcqnCZcpftnMegBT7bYriccVhcGeqwZXRdHQsJLblhug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;北极星指标是公司中最核心且可以主动影响业务的指标，即我们在工作中说的主要矛盾，冲着它发力能够取得更好的效果。比如说电商可能最关注总销售额，知识付费平台可能最关心问题回答数，网约车公司可能最关心月活用户数等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下情况下需要制定北极星指标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何找到核心指标？这里举一个网约车司机的核心指标的例子。网约车的主要目的是赚钱，他的核心指标怎么确定呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我们可以将网约车司机的收入做一个拆分，这其中包括业务费用、订单奖励、附加费及其他费用。网约车收入计算公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;48&quot; data-backw=&quot;348&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAcgibqXf7gaav8cic5wZDlfey5LMRLacqRNNK8m8ZZVFNYIuMjrg3sIvg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;147.61245674740485&quot; data-cropx2=&quot;799.7231833910034&quot; data-cropy1=&quot;237.30103806228374&quot; data-cropy2=&quot;325.12110726643596&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13496932515337423&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SA3iaMxZx0YcHDszsbp2sZNDtcwOmXFzJQZRHzTSDhflPje9m0Wf6gjwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;652&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着，确定哪些变量会影响各项指标。其中，业务费用等于订单量乘以客单价，订单量指的是同样时间内可以接多少单，客单价指的是同样车型情况下的客单价。而订单量又等于接单时长乘以单均时长。订单奖励等于订单完成率乘以各段奖金。附加费就是极端条件的乘客加价。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，确定可以影响哪些变量。对于网约车司机而言，“在不增加工作时长的情况下提高收入”的关键是：接更多的单和接更贵的单。对于司机来说，影响平台派单的核心指标是订单量和好评率。而司机可以主动影响的就是好评率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，就可以确定网约车司机的核心指标是好评率。其实，司机可以有很多方式来增加收入，比如换一个更好的车，或者去一些需求量大的地方去跑，或者每天工作时间更长，但如果可以找到一个核心指标，我们可以花很少的时间取得更好的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 梳理为了实现核心指标，需要哪些关键要素或节点，对应OSM模型中的S&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SABqf2lrAz0IAhs7yEuelNBWJzXTlqSuP0aLf6M1z7lK8XeUPzMWoToQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在梳理指标体系过程中，要把和核心指标相关的路径梳理清楚，这其中会用到UJM模型，全称User Journey Map，用户旅程地图。在梳理的过程中有三个注意事项。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，不能流水账式的梳理，应当是以一些有产出的指标为节点；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAHzuOM8fHfDZIjjqjGl6icKNc8IEcKU0FfrGaMjsQSs74qMMhCiaMLYZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，路径的起点和终点都要围绕着核心指标展开。例如对于全站APP来说，核心指标是播放人数和人均的播放时长，购买行为对于播放行为来说不是最重要的，则可以隐去，因为我们的路径的起始点是围绕着核心指标也就是播放行为来展开的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAOECwwgPPZVkAbY8ULibxGRZutgLbyzWmsOqicYEbJ5TibsgdbaZ63iaGNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，梳理路径的时候，仅以单一的视角展开，不要做跳转。如对于淘宝业务梳理而言，卖家视角和买家视角不能同时存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SASAdjaMaDhfiatUwk9EwzXraJibCicVMmPyTM2yhyIfyQUEQo4W3KlObOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 写出各环节对应的关键指标度量，对应OSM模型中的M&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAQPlEc64aR2cdQC8RUmm1nwhUth2ZicINX7el1QK1PuhQzu8V7OMIf7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般梳理关注的指标有人数、次数、转化率，和购买行为相关的钱和订单量，还有一些功能性指标如视频的播放量、B站的一键三连等。再加上不同的维度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;333&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5756929637526652&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAlnjn4h3uOoK9x4AtV8Q2Q3G34f01ia08DbfA5iaEd4WR3RzYAniaicGn4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 指标宣贯、存档、落地&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAUWMcYuzJQ2eNpibBUNq1GF5ESeCcfJeeMV23v1mvcRRjx4P2iaYYOP2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指标体系建立完成后需要制定具体的行动策略，即采取哪些措施去影响这些指标。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;指标体系的应&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本节介绍指标体系如何发挥作用，即如何回答核心指标为什么发生变化？&lt;/span&gt;&lt;span&gt;和哪些因素有关？&lt;/span&gt;&lt;span&gt;如何解决？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 如何回答为什么发生变化？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAZFMNJGvxQoibOWRJPBAuVGdQo38B7Z2tsWgCGqiaeABb58b3EUYr3oeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过涉及到的流程，往前追踪来确定为什么发生变化。如播放时长减少了，首先可以往前去追踪上游谁影响了播放时长，还可以按照维度来进行分析，比如有可能是搜索量少了，或者是今天的日活少了等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 如何回答和哪些因素有关？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAEfXLGdVxqcqdf5ibicbzk0HtngIQPTiaqw5sEUIxA1DOZFmibUA8dHXltw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于&lt;/span&gt;&lt;span&gt;搭建指标时把可能影响关键指标的行动策略已经列出&lt;/span&gt;&lt;span&gt;，可以看到该指标和哪些动作或者哪些因素相关，然后根据原先的行动策略去追踪。比如播放时长减少，是不是有什么内容影响观看，会不会是产品有什么问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 如何解决？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAQ7kTyDH3qO8m77ic6FdRfkPfCG0tV2YHB5Fpiboib3qhkfblUZGMZC0SA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦某一个指标发生了变化，就可以根据搭建指标体系所列出的行动策略去解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;330&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5709219858156028&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SA1faQOObvnOo4W8nE7t9PqMtykoKvNOgJhc7ic08j47tHuUNLmjgyd0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;846&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际应用中，通过指标体系提出具体的产品运营策略，实现精细化的运营，在运营的过程中，做实验验证结果，进而完善指标体系。所以指标体系是一个反复迭代、不断优化和调整的过程。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总结&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;建立数据指标体系的目的是获取全局性的、有体系性的信息，进而通过这些信息去驱动业务的发展，达成组织目标。&lt;/span&gt;&lt;span&gt;一套好的指标体系，能够帮助我们描述现状、洞察原因、预判未来。&lt;/span&gt;&lt;span&gt;指标体系最大的价值就是帮助大家高效利用时间，把时间花在解决问题上，而不是寻找问题上，从而提高团队整体的人效。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;精彩问答&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Q：以司机角度，如果所有司机都冲着“好评率”这一核心指标发力，会不会有一些负面影响？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：首先，如果所有人都这么做，整体效率会提升，是应该认可这个效果的。其次，就像天道酬勤一样，不是所有人都能做到。假设所有人都做到了，可能会有新的核心指标出现，这是一个动态调整、不断迭代的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Q：产品或者业务同学在数据指标体系建立的过程中如何参与？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：产品或业务同学要有这种数据赋能团队的意识，根据数据指标体系的方法论影响数据团队沉淀出一套指标体系出来，而不是简单的提出问题。因为数据指标体系的搭建不是单独的数据或者业务团队能够做出来的，而是两者配合的过程。所以数据团队要努力了解业务，业务团队要赋能数据，共同搭建数据指标体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Q：数据指标体系在业务部门如何推广？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：如果没有成熟的数据指标体系产品，就需要与业务部门去沟通，了解他们&lt;/span&gt;&lt;span&gt;的痛点，重新搭建一个数据指标体系。如果已有产品，则可以把指标梳理&lt;/span&gt;&lt;span&gt;出来，发给业务人员，以小的试点去影响他们，如果取得了一些效果以后，再试着去把它给全链路的拓展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Q：什么角色主导数据指标体系搭建？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：没有定义一定要什么团队来做。这涉及到数据权限归属的问题，对于产品同学如果有这个需求且有权限的话，就需要去做。不管是业务的分析还是数据部门的分析，都需要去帮助业务梳理指标体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Q：指标体系和标签体系的区别和联系？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A：指标体系更多的作用是分析，标签体系没有这个作用，指标体系是对业务整体结构的描述，会对业务的理解更深。标签作用是维度，比如购物性别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiag5cNwzcd24hoMSavfs7SAZ205KibicLgLsYP8Y4df0Mgjw611muoddL0b5MX8oJx0I1okiaT0pcdMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;电子书下载&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;578&quot; data-fileid=&quot;100072705&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5273159144893111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaRicGE7AUlibuJxeADOZKSs9Y7wc13ITIFEiajABOicZWWYgAnMovIeyczayoCg9ibNrOeQibPAta3spkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1263&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;识别二维码&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，添加小助手微信，回复&lt;strong&gt;『数据科学典藏版合集』&lt;/strong&gt;，即可下载。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;146&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;145&quot; data-fileid=&quot;100072704&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9927007299270073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lAStFsJ0Pm0T9eZG6MS4grBiaJAPvOxCotLBIwWiceTLXicvMa6pq5s7ZmCgDFrQQnlWEvhAG1iaKkicXymMicpeVWFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;274&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFun：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100+线下和100+线上沙龙、论坛及峰会，已邀请近1000位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章500+，百万+阅读，12万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgiaIKm4YqA09u83TvzKbfsabjfX1TLzaXLAK9MWmC4qI6cuTBJnxygZLZPU49O8g6j8QI9264NMqQ/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0fce63032de929d10d8fb80185da3724</guid>
<title>你知道的Go切片扩容机制可能是错的</title>
<link>https://toutiao.io/k/4e7rhoy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是太白，今天和你探索下Go语言的切片扩容机制。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果觉得文章对你有帮助，记得点赞+关注。目前本公众号没有评论功能，有问题请联系我。&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5OTcwNDc5Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/y18hkib7c4x9eqg3nPicpPPwX5QicW5GH0GDjvnLvCTOBOBqXvBDElILDVzRne2QibNY0DIV2Sg0FweAFze3K0aBog/0?wx_fmt=png&quot; data-nickname=&quot;太白技术&quot; data-alias=&quot;taibai_tech&quot; data-signature=&quot;关键词：Go语言、微服务、架构、开源项目。欢迎关注。&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1 前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2 代码片段1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3 代码片段2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4 growslice源代码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5 代码片段3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6 go1.18beta1的变化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;7 总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg5OTcwNDc5Ng==&amp;amp;mid=2247483865&amp;amp;idx=1&amp;amp;sn=36a2dbcfd7df1db52852d379dbe6d724&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Go切片与技巧（附图解）》&lt;/a&gt;，我们讲到了Go内置函数&lt;code&gt;append&lt;/code&gt;操作，当append操作的时候，切片容量如果不够，会触发扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于Go切片的扩容机制，网上文章很多，很多结论是这样的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结论1：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1、当需要的容量超过原切片容量的两倍时，会使用需要的容量作为新容量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、当原切片长度小于1024时，新切片的容量会直接翻倍。而当原切片的容量大于等于1024时，会反复地增加25%，直到新容量超过所需要的容量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结论2：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在结论1的基础上（切片的预估容量阶段），提到了&lt;code&gt;内存对齐&lt;/code&gt;，容量计算完了后还要考虑到内存的高效利用，进行内存对齐。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中结论1，可能最让人熟知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将和你一起来探索下这个切片的扩容机制，看看到底是不是这样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 代码片段1&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; s := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s)) &lt;span&gt;// cap s 1&lt;/span&gt;&lt;br/&gt; s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s)) &lt;span&gt;// cap s 2&lt;/span&gt;&lt;br/&gt; s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s)) &lt;span&gt;// cap s 4&lt;/span&gt;&lt;br/&gt; s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s)) &lt;span&gt;// cap s 4&lt;/span&gt;&lt;br/&gt; s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s)) &lt;span&gt;// cap s 8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码的结果，我们可以看到，容量是成翻倍扩容的。符合前言提到的结论1的第一点。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; s2 := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s2&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s2)) &lt;span&gt;// cap s2 1024&lt;/span&gt;&lt;br/&gt; s2 = &lt;span&gt;append&lt;/span&gt;(s2, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s2&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s2)) &lt;span&gt;// cap s2 1280&lt;/span&gt;&lt;br/&gt; s2 = &lt;span&gt;append&lt;/span&gt;(s2, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s2&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s2)) &lt;span&gt;// cap s2 1280&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码的结果，我们可以看到，当原切片的容量大于1024时，符合前言提到的结论1的第二点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 代码片段2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下下面的这端代码，执行结果是6，为什么不是8呢？这个和前言提到的结论1貌似有冲突。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; s3 := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; s3 = &lt;span&gt;append&lt;/span&gt;(s3, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s3&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s3)) &lt;span&gt;// cap s3 6&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 growslice源代码&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解释上面的代码片段2，我们开看下go的runtime帮我们干了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过delve来调式我们的Go代码。这边演示的Go版本：&lt;code&gt;1.16.5&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过打断点&lt;code&gt;b main.main&lt;/code&gt;、然后用&lt;code&gt;si&lt;/code&gt;指令定位到以下代码，&lt;code&gt;runtime.growslice()&lt;/code&gt;正式Go扩容的源代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) si&lt;br/&gt;&amp;gt; runtime.growslice() /Users/xujiajun/go/go1.16.5/src/runtime/slice.go:125 (PC: 0x10483a0)&lt;br/&gt;Warning: debugging optimized &lt;span&gt;function&lt;/span&gt;&lt;br/&gt;   120: // NOT to the new requested capacity.&lt;br/&gt;   121: // This is &lt;span&gt;for&lt;/span&gt; codegen convenience. The old slice&lt;span&gt;&#x27;s length is used immediately&lt;br/&gt;   122: // to calculate where to write new values during an append.&lt;br/&gt;   123: // TODO: When the old backend is gone, reconsider this decision.&lt;br/&gt;   124: // The SSA backend might prefer the new length or to return only ptr/cap and save stack space.&lt;br/&gt;=&amp;gt; 125: func growslice(et *_type, old slice, cap int) slice {&lt;br/&gt;   126:  if raceenabled {&lt;br/&gt;   127:   callerpc := getcallerpc()&lt;br/&gt;   128:   racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))&lt;br/&gt;   129:  }&lt;br/&gt;   130:  if msanenabled {&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过刚才的debug我们可以找到&lt;code&gt;growslice&lt;/code&gt;的源代码位置：&lt;code&gt;$GOROOT/src/runtime/slice.go&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;growslice&lt;/span&gt;&lt;span&gt;(et *_type, old slice, &lt;span&gt;cap&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...&lt;br/&gt;&lt;br/&gt; newcap := old.&lt;span&gt;cap&lt;/span&gt;&lt;br/&gt; doublecap := newcap + newcap&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;cap&lt;/span&gt; &amp;gt; doublecap {&lt;br/&gt;  newcap = &lt;span&gt;cap&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; old.&lt;span&gt;cap&lt;/span&gt; &amp;lt; &lt;span&gt;1024&lt;/span&gt; {&lt;br/&gt;   newcap = doublecap&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// Check 0 &amp;lt; newcap to detect overflow&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// and prevent an infinite loop.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;lt; newcap &amp;amp;&amp;amp; newcap &amp;lt; &lt;span&gt;cap&lt;/span&gt; {&lt;br/&gt;    newcap += newcap / &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// Set newcap to the requested cap when&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// the newcap calculation overflowed.&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; newcap &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    newcap = &lt;span&gt;cap&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过&lt;code&gt;n&lt;/code&gt;指令执行到这边：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;cap&lt;/span&gt; &amp;gt; doublecap {&lt;br/&gt;  newcap = &lt;span&gt;cap&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;locals&lt;/code&gt;知道当前的变量值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;newcap = 5&lt;br/&gt;doublecap = 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么newcap最后怎么变成了6呢？我们继续往下看。通过debug，我们发现执行到以下代码位置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;178&lt;/span&gt;:  &lt;span&gt;case&lt;/span&gt; et.size == sys.PtrSize:&lt;br/&gt;   &lt;span&gt;179&lt;/span&gt;:   lenmem = &lt;span&gt;uintptr&lt;/span&gt;(old.&lt;span&gt;len&lt;/span&gt;) * sys.PtrSize&lt;br/&gt;   &lt;span&gt;180&lt;/span&gt;:   newlenmem = &lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;cap&lt;/span&gt;) * sys.PtrSize&lt;br/&gt;   &lt;span&gt;181&lt;/span&gt;:   capmem = roundupsize(&lt;span&gt;uintptr&lt;/span&gt;(newcap) * sys.PtrSize)&lt;br/&gt;   &lt;span&gt;182&lt;/span&gt;:   overflow = &lt;span&gt;uintptr&lt;/span&gt;(newcap) &amp;gt; maxAlloc/sys.PtrSize&lt;br/&gt;=&amp;gt; &lt;span&gt;183&lt;/span&gt;:   newcap = &lt;span&gt;int&lt;/span&gt;(capmem / sys.PtrSize)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过&lt;code&gt;locals&lt;/code&gt;指令获取newcap的变量变成了6，&lt;code&gt;newcap = int(capmem / sys.PtrSize)&lt;/code&gt;，从下面结构结果看出&lt;code&gt;capmem=48&lt;/code&gt;，而&lt;code&gt;sys.PtrSize&lt;/code&gt;等于8（case et.size == sys.PtrSize，et为int类型的，在64位操作系统是8字节），所以6(newcap) = 48(capmem) / 8(sys.PtrSize)`&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) locals&lt;br/&gt;newcap = &lt;span&gt;6&lt;/span&gt;&lt;br/&gt;doublecap = (unreadable could not find loclist entry at &lt;span&gt;0x2b3ae&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; address &lt;span&gt;0x1050d70&lt;/span&gt;)&lt;br/&gt;overflow = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;newlenmem = &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;lenmem = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;capmem = &lt;span&gt;48&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么关键点在于capmem怎么变成了48而不是40，&lt;code&gt;lenmem=0&lt;/code&gt;，&lt;code&gt;newlenmem=5&lt;/code&gt;，所以&lt;code&gt;capmem = roundupsize(uintptr(newcap) * sys.PtrSize)&lt;/code&gt; 带入变量变成&lt;code&gt;capmem = roundupsize(5 * 8)&lt;/code&gt;，所以主要是&lt;code&gt;roundupsize&lt;/code&gt;影响了最终的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过debug，我们发现执行到了&lt;code&gt;return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;11&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;12&lt;/span&gt;: &lt;span&gt;// Returns size of the memory block that mallocgc will allocate if you ask for the size.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;13&lt;/span&gt;: &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;roundupsize&lt;/span&gt;&lt;span&gt;(size &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;14&lt;/span&gt;:  &lt;span&gt;if&lt;/span&gt; size &amp;lt; _MaxSmallSize {&lt;br/&gt;    &lt;span&gt;15&lt;/span&gt;:   &lt;span&gt;if&lt;/span&gt; size &amp;lt;= smallSizeMax&lt;span&gt;-8&lt;/span&gt; {&lt;br/&gt;=&amp;gt;  &lt;span&gt;16&lt;/span&gt;:    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])&lt;br/&gt;    &lt;span&gt;17&lt;/span&gt;:   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;18&lt;/span&gt;:    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]])&lt;br/&gt;    &lt;span&gt;19&lt;/span&gt;:   }&lt;br/&gt;    &lt;span&gt;20&lt;/span&gt;:  }&lt;br/&gt;    &lt;span&gt;21&lt;/span&gt;:  &lt;span&gt;if&lt;/span&gt; size+_PageSize &amp;lt; size {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候我们的size是40，&lt;code&gt;uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]])&lt;/code&gt;带入变量变成：&lt;code&gt;divRoundUp(40, 8) returns ceil(n / a).&lt;/code&gt;等于40 / 8 = 5&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; size_to_class8 = [smallSizeMax/smallSizeDiv + &lt;span&gt;1&lt;/span&gt;]&lt;span&gt;uint8&lt;/span&gt;{&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;23&lt;/span&gt;, &lt;span&gt;23&lt;/span&gt;, &lt;span&gt;23&lt;/span&gt;, &lt;span&gt;23&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，&lt;code&gt;size_to_class8[divRoundUp(size, smallSizeDiv)]&lt;/code&gt;结果是5，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下这个变量&lt;code&gt;class_to_size&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; class_to_size = [_NumSizeClasses]&lt;span&gt;uint16&lt;/span&gt;{&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;48&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;, &lt;span&gt;96&lt;/span&gt;, &lt;span&gt;112&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;144&lt;/span&gt;, &lt;span&gt;160&lt;/span&gt;, &lt;span&gt;176&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;208&lt;/span&gt;, &lt;span&gt;224&lt;/span&gt;, &lt;span&gt;240&lt;/span&gt;, &lt;span&gt;256&lt;/span&gt;, &lt;span&gt;288&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;, &lt;span&gt;352&lt;/span&gt;, &lt;span&gt;384&lt;/span&gt;, &lt;span&gt;416&lt;/span&gt;, &lt;span&gt;448&lt;/span&gt;, &lt;span&gt;480&lt;/span&gt;, &lt;span&gt;512&lt;/span&gt;, &lt;span&gt;576&lt;/span&gt;, &lt;span&gt;640&lt;/span&gt;, &lt;span&gt;704&lt;/span&gt;, &lt;span&gt;768&lt;/span&gt;, &lt;span&gt;896&lt;/span&gt;, &lt;span&gt;1024&lt;/span&gt;, &lt;span&gt;1152&lt;/span&gt;, &lt;span&gt;1280&lt;/span&gt;, &lt;span&gt;1408&lt;/span&gt;, &lt;span&gt;1536&lt;/span&gt;, &lt;span&gt;1792&lt;/span&gt;, &lt;span&gt;2048&lt;/span&gt;, &lt;span&gt;2304&lt;/span&gt;, &lt;span&gt;2688&lt;/span&gt;, &lt;span&gt;3072&lt;/span&gt;, &lt;span&gt;3200&lt;/span&gt;, &lt;span&gt;3456&lt;/span&gt;, &lt;span&gt;4096&lt;/span&gt;, &lt;span&gt;4864&lt;/span&gt;, &lt;span&gt;5376&lt;/span&gt;, &lt;span&gt;6144&lt;/span&gt;, &lt;span&gt;6528&lt;/span&gt;, &lt;span&gt;6784&lt;/span&gt;, &lt;span&gt;6912&lt;/span&gt;, &lt;span&gt;8192&lt;/span&gt;, &lt;span&gt;9472&lt;/span&gt;, &lt;span&gt;9728&lt;/span&gt;, &lt;span&gt;10240&lt;/span&gt;, &lt;span&gt;10880&lt;/span&gt;, &lt;span&gt;12288&lt;/span&gt;, &lt;span&gt;13568&lt;/span&gt;, &lt;span&gt;14336&lt;/span&gt;, &lt;span&gt;16384&lt;/span&gt;, &lt;span&gt;18432&lt;/span&gt;, &lt;span&gt;19072&lt;/span&gt;, &lt;span&gt;20480&lt;/span&gt;, &lt;span&gt;21760&lt;/span&gt;, &lt;span&gt;24576&lt;/span&gt;, &lt;span&gt;27264&lt;/span&gt;, &lt;span&gt;28672&lt;/span&gt;, &lt;span&gt;32768&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带入结果5，class_to_size[5] 刚好对应的是 48。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下上面的关键值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;doublecap = 0 + 0&lt;br/&gt;&lt;br/&gt;newcap = 5 &lt;br/&gt;&lt;br/&gt;newcap &amp;gt; doublecap &lt;br/&gt;&lt;br/&gt;capmem = roundupsize(5 * 8)  = 48&lt;br/&gt;&lt;br/&gt;newcap = int(48 / 8) = 6&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 代码片段3&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别提下，下面两端切片类型不同，扩容的结果也不同，大家可以自行debug下，所以前言提到的结论1中翻倍的结论也是有问题的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; s := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int32&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s)) &lt;span&gt;// cap s 2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; s := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;cap s&quot;&lt;/span&gt;, &lt;span&gt;cap&lt;/span&gt;(s)) &lt;span&gt;// cap s 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 go1.18beta1的变化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面分析是基于go1.16.5的，太白注意到go1.18之后，&lt;code&gt;growslice&lt;/code&gt;改了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;1024&lt;/code&gt;变成了&lt;code&gt;256&lt;/code&gt;，公式也改了，&lt;code&gt;newcap += newcap / 4&lt;/code&gt;变成了&lt;code&gt;newcap += (newcap + 3*threshold) / 4&lt;/code&gt;，这边我就不展开了。给大家贴下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;newcap := old.cap&lt;br/&gt; doublecap := newcap + newcap&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;cap&lt;/span&gt; &amp;gt; doublecap {&lt;br/&gt;  newcap = &lt;span&gt;cap&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  const threshold = 256&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; old.cap &amp;lt; threshold {&lt;br/&gt;   newcap = doublecap&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   // Check 0 &amp;lt; newcap to detect overflow&lt;br/&gt;   // and prevent an infinite loop.&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; 0 &amp;lt; newcap &amp;amp;&amp;amp; newcap &amp;lt; &lt;span&gt;cap&lt;/span&gt; {&lt;br/&gt;    // Transition from growing 2x &lt;span&gt;for&lt;/span&gt; small slices&lt;br/&gt;    // to growing 1.25x &lt;span&gt;for&lt;/span&gt; large slices. This formula&lt;br/&gt;    // gives a smooth-ish transition between the two.&lt;br/&gt;    newcap += (newcap + 3*threshold) / 4&lt;br/&gt;   }&lt;br/&gt;   // Set newcap to the requested &lt;span&gt;cap&lt;/span&gt; when&lt;br/&gt;   // the newcap calculation overflowed.&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; newcap &amp;lt;= 0 {&lt;br/&gt;    newcap = &lt;span&gt;cap&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1、前言中的结论1讲法不严谨，讲对了一部分（代码片段1可知），&lt;code&gt;不同的切片类型，扩容值可能是不同的&lt;/code&gt;（代码片段3可知），Go的runtime分配内存的时候，会调用&lt;code&gt;roundupsize&lt;/code&gt;，取整内存值（代码片段2可知）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、前言中的结论2比结论1好一点，但它是基于结论1的，随着Go版本的迭代，这个结论也会过时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、Go切片的扩容机制还是比较复杂的，受到Go版本、操作系统、数据类型等因数，其机制都会有不同，要具体情况具体分析，不要单一的记下一个结论就觉得ok。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4、网上的文章参差不齐，大家在搜资料的时候，需要我们去甄别，最好自己去验证下。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6bc21175e41ac6ee4e32a62aff6ae23b</guid>
<title>树莓派系统推出64位版本，更好支持4GB内存以上硬件</title>
<link>https://toutiao.io/k/vrdgebv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;文 | 罗奇奇&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出品 | OSC开源社区（ID：oschina2013）&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;虽然 Raspberry Pi 3 具有 64 位 Cortex CPU 内核，甚至 Raspberry Pi Zero 2 也支持 64 位，但作为 Raspberry Pi 官方操作系统的 Raspbian OS 仍然是 32 位的系统。终于在 2022 年，Raspbian OS 推出了正式的 64 位版本。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这款 64 位 Raspberry Pi 操作系统在过去一年中进行了测试，现在确定其状态良好，可供客户在较新的 Raspberry Pi 板上使用，作为其 32 位版本的替代品。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33076923076923076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibOeZElXkIHiaL1PFVcXdY5M4GRDuFcjjybKFu8BbGiaB8tculIyxNOiaFY6wS2zaRIpMic8LHnef0nnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;之所以开发 64 位的 Raspbian OS，兼容性是一个关键问题：许多闭源应用程序仅适用于 arm64，而开源应用程序并未针对 armhf 端口进行完全优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除此之外，A64 指令集还有一些内在的性能优势，32 位指针只允许寻址 4GB 的内存。但在 Raspberry Pi 4 上需要使用 ARM 大型物理地址扩展 (LPAE) 来访问高达 8GB 的内存，因此 64 位系统的寻址能力，为那些需要消耗大量内存的单进程应用提供更好的性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更多内容可在树莓派&lt;/span&gt;&lt;span&gt;官方博客中&lt;/span&gt;&lt;span&gt;查看：&lt;span&gt;https://www.raspberrypi.com/news/raspberry-pi-os-64-bit/&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86032&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span data-brushtype=&quot;text&quot;&gt;END&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;104423&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;新年快乐~&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAm1wo0S5u-QAAAAstQy6ubaLX4KHWvLEZgBPEhYN0KyZGOsn8zNPgMIu6qtJqc5HtHDlzTHYX-S_a&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaj0xiar1tuDrg3UiaASMibeX8NhPYw7r6Xmgbb1TglugaPZj64607eibY6FssxOOxDk08004kTX5sJgdB1E21SOJJKA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdUdQW4TlBdJ3BXz0WwADQZzELGT4ibzORvfd2ibAMuDyaIHSbOAjjX0lEE3suAHbKicTs&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/TTQibyKjrickxaZ7LG0fWYjKslHKkuycfC5r2ibT51J7x6QsFbfHfl2uQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1bcbd1c806e434b077b18cbd3cef6a3a95a1814d2dc66ee22d@finder&quot; data-nickname=&quot;OSC开源社区&quot; data-desc=&quot;2022 #新春贺岁，中国开源创企集结&quot; data-nonceid=&quot;5994202310144662410&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502646051&quot; data-ratio=&quot;0.9574468085106383&quot; data-type=&quot;png&quot; data-w=&quot;94&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZP3JEv2BgJ7cx4oxeYNNqh2oytepen4zyw43jGnqXCiaAYWgK59RF4HTukPFrHF7FJarvFzETH87kr3It44zLmA/640?wx_fmt=png&quot;/&gt;&lt;span&gt;觉得不错，请点个&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;呀&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ba36b4ca04b9786c3da06d23120e843d</guid>
<title>KubeVela v1.2 发布：聚焦开发者体验，轻松发布你的多集群应用</title>
<link>https://toutiao.io/k/a6gjcmr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着云原生的不断发展和成熟，越来越多的基础设施能力逐渐标准化成为 PaaS 平台或者 SaaS 化产品。一个产品的诞生不再像过去那样需要建立一个团队，从开发、测试一直到运维、基础设施全部分多种角色系统完成。如今，敏捷组织文化和云原生技术驱动，使得这些职责更多的是“左移”到了开发者身上，测试左移、监控左移、安全左移，以及 DevOps 等一系列理念都是在强调，通过开源项目或者云的产品和服务将测试、监控、安全、运维等一系列事务提前到开发阶段完成。这看似美好的愿景却给开发者带来了巨大的挑战，开发者对底层五花八门的产品和复杂 API 缺乏掌控力，他们不仅仅是在做选择，更多的需要去理解和协调底层复杂异构的基础设施能力，以便满足上层业务的快速发展和迭代需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种复杂性和不确定性无疑大大降低了开发者的体验，降低了业务系统的交付效率，增加了运维风险。开发者体验的核心是“简单”和“高效率”，不管是开发者还是企业都需要更好用的开发者工具或者平台来达成。在现代云原生技术之上打造一款帮助开发者从开发、交付以及后续持续运维的一体化平台，一直是 KubeVela 演进的核心目标。如图 1 所示，在 v1.2 版本中，我们围绕开发者体验新增了 UI 控制台组件（VelaUX），简化了编排 YAML 的复杂性，完善了插件体系建设，丰富了云资源的扩展能力，增加了大量 CI/CD 等生态对接的能力，进一步完善了开发者端到端的使用体验。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.56640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNCx3aZznXhsia5h5VJa8Eay5xicnFRY7MJQuH0KZvhBR2upG5oJmw1TrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 1：KubeVela 架构设计&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;发展历程回顾&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们再来简单回顾一下 OAM 和 KubeVela 的发展阶段和历程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;OAM（Open Application Model）诞生和成长&lt;/strong&gt;在复杂的世界中要创造简单，首先我们需要解决的问题就是抽象和标准化。阿里云和微软联合推出 **OAM **模型，创新性地提出“关注点分离”的理念，开发者关注业务本身、运维关注模块化能力。OAM 模型围绕“一切皆服务，全面模块化”的思想，为各大厂商和云原生的平台构建者们实现自己的应用管理平台提供了简单易用与高度可扩展相结合的标准实践方式。该模型提出后的短短一年内便得到了包括 AWS、Oracle、腾讯、华为在内的国内外各大厂商响应，被国家信通院立项作为行业标准。因为大家有共同的目标，降低云原生的使用门槛，让应用交付和管理更简单。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;KubeVela 开源项目 v1.0 发布，为社区带来了 OAM 的标准实现&lt;/strong&gt;有了 OAM 模型作为实践指导，社区高级玩家也开始创造自己的工具来实践，包括阿里、微软、Oracle、Upbond、腾讯在内的一系列公司都基于 OAM 的指导构建了自己的业务平台。但对于更广大的开发者和中小型企业群体来说，他们却无法直接享受模型带来的红利，于是，KubeVela 作为 OAM 社区的官方实现引擎诞生了。它从一开始就由 7 家来自不同组织的 OAM 社区成员从零到一构建。KubeVela 的实现吸收了多家公司针对 OAM 的实践经验，同时结合 Kubernetes 社区生态优势，实现了自动化、可收敛、幂等且稳定的应用发布控制器，围绕 IaC（基础设施即配置）构造了用户友好的抽象层，帮助开发者实现了开箱基于的 OAM 实现引擎。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;KubeVela v1.1 发布，实现应用交付工作流，原生支持混合环境多集群应用交付&lt;/strong&gt;随着企业上云进程的推进，混合云、分布式云等多元化基础设施逐渐成为常态。KubeVela 作为现代应用管理系统也顺应潮流，整体架构升级为面向混合环境做应用交付和管理的控制平面，将所有的功能天然构筑在多集群技术之上。我们相信，出于高可用、成本性能、数据安全等多方面因素，未来大多数企业应用的形态都将是异构多元的。KubeVela v1.1 版本的发布，同时也实现了高度可扩展的应用发布工作流，它天然以混合环境架构呈现，创新性的实现了交付工作流与应用抽象相结合的工作模式，实现了面向终态的应用交付工作流，大大简化了流程编排的复杂性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间来到 2022 年，KubeVela 也正式进入了第四个阶段，在原先核心控制器 API 基本稳定的基础上，我们以插件的形式增加了一系列开箱即用的功能。让开发者可以通过 UI 控制台的方式，连接 CI/CD 完整流程，端到端发布多集群应用，进一步提升开发者体验。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;v1.2 版本的核心能力&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;图形化操作控制台（VelaUX）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供好用的图形化操作界面是降低开发者使用门槛的首选途径，从 KubeVela 诞生以来，社区对 UI 控制台的呼声一直很高。从 v1.2 版本开始，它正式到来了。打造 UI 控制台的目的是帮助开发者以更标准化的方式组装和管理异构业务应用，帮助他们分析和更快的发现业务故障和阻碍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;VelaUX&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 是 KubeVela 的前端项目，设计实现时它充分考虑了 KubeVela 的可扩展性这一核心要点。引入了低代码平台的理念来打造前端，我们的目标是打造一个可以通过拖拉拽方式就能做到自定义应用交付输入参数，并且实现运行数据可观测的平台。为此我们设计了前端描述规范 &lt;span&gt;UISchema&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，配合 KubeVela 的模块化定义 &lt;span&gt;X-Definition&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，通过配置就可以渲染出丰富的前端交互元素。同时为了让前端的数据查询也配置化，我们设计了多维数据自定义查询语言 &lt;span&gt;VelaQL&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，这样的设计形成了 KubeVela 交付和管理异构应用的基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前通过 VelaUX ，用户可以管理扩展，连接 Kubernetes 集群，分配交付目标，规划环境和交付各类型应用，并观测应用运行状态，实现应用交付的完整闭环。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.49296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNB9WqmdTf1bvIr2y4oK3taH9YCsGoBGia6Pce7hAOgGX4FzibICE30WrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 2：VelaUX 预览&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图 2 所示，VelaUX 中出现了一些新名词，请参考 &lt;span&gt;核心概念&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 文档进行学习和了解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多环境统一化管理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KubeVela 将 N 个 Kubernetes 集群，N 个云厂商服务或其他私有云服务统一为大的基础设施资源池。在此基础上，我们的开发者可以按照业务需求、流程需求、团队需求等多种业务维度划分环境。在大资源池的基础上形成环境空间。同一个应用可发布到不同的环境，环境之间从管理到运行态完全隔离。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNyFjJXfxQl7FicKMRt3wwCsDpxrf0jibeiaamJZNwYO1rjR7m2Cd8oJSLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 3：多环境/多集群应用管理页面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图 3 所示，应用可被发布到生产、测试、默认三个环境中，每一个环境可以包括多个交付目标，每一个交付目标背后可以是独立的 Kubernetes 集群。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;异构应用标准化交付&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在云原生体系中，我们交付应用的形式选择非常多。基于 Kubernetes 基础设施，我们既可以通过成熟的 Helm Chart 包交付中间件和第三方开源应用，也可以通过镜像交付企业业务应用，还可以通过 OpenYurt 交付管理边缘应用。基于云服务商的开放能力，我们可以交付数据库、消息、缓存等中间件，也有日志、应用监控等运维能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这么多的可选项，KubeVela 采用标准的 OAM 规范实现对异构应用的统一交付和管理。KubeVela 实现了高度可扩展的交付系统，通过内置、社区共享等形态帮助用户扩展平台，以一致化的交付和管理体验处理异构的应用。在 KubeVela 之上，开发者看到的都是模块化、一切皆服务的管理形态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJykl78gSWLQ2BgZksNPibndN0bU8Kk383wHbRMg5JV58zibMkbOI1zwgkX3B53XPdb66IJ0PyTENDPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 4：云服务应用管理页面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图 4 所示，我们可以看到，相同的应用管理页面，用户可以非常便捷得获取到云服务应用。开发者可以通过阅读下面几篇文档查看异构应用的交付过程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;交付 Docker 镜像&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;交付 Helm Chart 包&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;交付 Kubernetes 资源&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;交付 云服务&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;扩展体系（Addon）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KubeVela 从一开始就是设计为一款微内核高可扩展的系统，上文我们说到异构应用，KubeVela 可以通过扩展体系，以标准化的形态，扩充无限的应用交付能力。既匹配企业差异性诉求，也不带来过多的认知负担。KubeVela 中可扩展的点包括了组件类型、运维能力、工作流类型、应用交付策略等。在当前版本中，我们发布了 Addon 扩展体系。Addon 是组织各种扩展能力的承载体，它便于分发和管理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNocSaoyM4rzkdvk9aecCIPEf0zPLaYNgQKh982v0dPAkA3fbuP5NfJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 5：KubeVela 插件管理页面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前在官方仓库中已经存在如图 5 所示的可用 Addon。同时在实验性仓库中我们正在联合社区用户积极创造更多的扩展能力。当然，这里需要每一个社区开发者的积极参与。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止到现在，KubeVela 已经成长为一款可直接服务于广大开发者的应用交付平台，那么企业哪些场景可以直接利用 KubeVela 呢？我们整理了以下几个常见场景：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;企业开发场景解决方案&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多集群应用 DevOps&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过往社区的交流中，我们发现企业主流的研发体系都类似如图 6 所示的结构，他们使用云服务厂商提供的计算资源作为生产、演示环境。使用自己购买或历史遗留的服务器搭建开发、测试环境。如果业务有多区域或灾备需求，生产环境可能需要部署到多个区域或多云。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpkQxibjhkJykl78gSWLQ2BgZksNPibndNGA11svpjCoEzRpEFpiaRx0icLpYgwxwL9Bibejsm1OUkyWIkNIFydaTkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图 6：多集群应用实践架构&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于基础的 DevOps 流程，包括了代码托管和 CI/CD 的环节。KubeVela 目前为你提供 CD 环节的支持。对于企业实践的步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据实际情况准备本地或云服务资源。至少单项打通本地和云资源的网络，便于资源集中管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 KubeVela 系统搭建在生产环境中，保障持续的可用性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 KubeVela 部署 Gitlab、Jenkins、Sonar 等 DevOps 工具，并打通工具链。通常情况下，代码托管和开发工具的可用性至关重要，我们需要将其部署在生产环境中（如果你本地机房具备生产可用性，且希望代码数据在本地环境流转，可部署在本地机房）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 KubeVela 规划本地开发环境，部署本地测试用中间件，规划生产环境和部署云服务中间件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 Jenkins 搭建业务代码 CI 流水线，产出 Docker 镜像交由 KubeVela 进行多环境部署，形成完整应用交付工作流。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合 KubeVela 的多集群应用 DevOps 方案有如下优势：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;开发者无需掌握过多的 Kubernetes 生态知识，可实现异构应用云原生部署。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多集群，多环境统一管理，原生可部署跨集群应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;统一的应用管理模式，无论是业务应用还是开发工具链。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灵活的工作流，帮助企业打通各种开发规范流程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;混合环境一体化管理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的企业往往都存在不一样的基础设施和业务诉求。在基础设施侧：企业可能搭建了私有云，可能购买了公有云，可能还有边缘计算资源。在业务侧：不同的业务规模不同，资源需求不同，可能有多云多活应用，也有企业遗留系统。在研发侧：业务研发往往需要开发、测试、预发和生产环境。在管理侧：不同的业务团队需要相互隔离，又可能需要业务互通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间的累积，企业由于职责边界和不同分工的影响，会逐渐形成不同业务团队相互独立甚至割裂的状态，这种割裂包括了：开发工具割裂，技术架构割裂，业务管理形态割裂。KubeVela 秉持着“尊重现实，积极创新”的原则，带来的方案是追求统一的过程中用高扩展的能力去兼容差异性。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面对基础设施差异，我们支持以 Kubernetes API、云服务 API 或其他自定义 API 的形态，去对基础设施进行充分的模型化。最终通过统一的 OAM 模型向上暴露一致的概念。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面对业务架构差异，应用模型是开放的，对架构无要求的。KubeVela 做的是连接和赋能，连接已有系统，通过扩展机制加持新的生态技术。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面对开发工具链的差异，企业中可能已经存在不同的开发工具链，产出不同的业务制品。KubeVela 通过扩展和标准模型去支持各类制品，实现其标准化交付。当然，它的标准逐步衍生到前置环节，帮助企业逐步实现工具链一致化。因此，你不用担心你是用的 Gitlab 还是 Jenkins，它都能对接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面对运维能力差异，企业中不同团队的运维能力、工具方案可以在 KubeVela 的规范下逐步积累，能力互通。更多运维能力也同样在社区的维度进行共享和复用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，使用 KubeVela 来作为企业打通业务，进行统一能力建设的基础平台，它是可落地、有未来的方案&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自定义企业发布平台&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Heroku 、Cloud Foundry 时代开始，市场上一直在产生不同的 PaaS 平台，我们都知道固定模式的发布平台往往不适合所有的企业。举个例子，某些规范化程度较高的企业，他们基于业务的特性，发布应用时仅需更新镜像名称，然而使用通用 PaaS 就不得不去理解大量的概念和参数。再比如某个企业生产的是 AI 应用，对于 AI 应用的发布与普通应用有比较大的区别，这时就需要定制 AI 场景的 PaaS，企业不得不付更多的费用和学习更多的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通用产品不符合企业需求时，自研是真实存在的诉求。但是对于从零开始自研平台，必然又需要投入大量的人力物力，甚至超过了企业核心业务的投入，这显得得不偿失。KubeVela 也考虑到了具备自研能力企业的独特诉求，他们可以基于 KubeVela 微内核、高可扩展的设计，针对自己的业务场景和领域知识，打造属于自己的、更为简单易用的业务平台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于需要自研发布平台的企业来说，KubeVela 的微内核是一个 PaaS 平台研发框架。一方面，企业可以根据自己的需求自研或者安装社区的各种功能插件；另一方面，企业也可以基于 OAM 模型修改模块化配置，新增或裁剪用户使用的参数。这种模块化的设计可以大大降低企业的投入成本，同时可以跟上社区的发展潮流，随时将社区更多的先进技术转化为自身的生产力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参与社区&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做了这么多的介绍，你是否对 KubeVela 的发展有了一些新的认识，没有哪个产品是绝对的银弹，也没有一个方案可以解决所有的问题。但是我们的理想是可以创造一个标准化模式，让更多的企业和开发者用户参与到这场为了“简单”和“高效”的开发者体验战役中来。KubeVela 还很年轻，我们希望你可以参与进来共同打造。这里非常感谢在过去参与 KubeVela 贡献的 &lt;span&gt;100 多位开发者&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，正是因为你们的携手努力，才让我们的社区生态变得更加繁荣。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;共建 OAM 应用规范&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 OAM 应用规范，模型的更新和升级基于 KubeVela 实践驱动，但是它并不绑定 KubeVela 实现。它是 KubeVela 在云原生应用交付和管理层面实践经验的总结和抽象，是创造规范化应用管理体系的最佳实践和核心理念。我们非常欢迎云厂商、平台厂商、最终用户可以参与进来，同时我们也欣喜的看到国内包括腾讯在内的多家厂商对 OAM 应用规范的关注和支持。任何人、组织都可以发表你的想法、建议和思考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问，&lt;span&gt;参与 OAM 模型讨论&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;共建 Addon 扩展生态&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上文介绍的一样，我们已经开启了 Addon 的扩展体系，非常欢迎社区的创造者、开发者可以来贡献更多的扩展能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问，&lt;span&gt;如何扩展和贡献 Addon 参考文档&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;贡献云服务能力&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KubeVela 通过集成 Terraform Module 来扩展云服务集成能力，我们已经支持了 &lt;span&gt;常用的云资源&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt; ，欢迎社区朋友参考并贡献更多的云服务厂商和产品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问，&lt;span&gt;如何扩展和贡献云资源&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反馈你的需求或痛点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或许你是普通开发者，也或许你是云原生领域的从业者，如果你认可我们的方向，认可我们正在做的事情，我们非常欢迎你可以参与到 KubeVela 社区讨论中来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问，&lt;span&gt;参与社区讨论&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;KubeVela 网站加速访问&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KubeVela 的官方文档托管在 &lt;span&gt;GitHub kubevela.io&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt; 上，如果你发现有任何错漏或者想要参与翻译，欢迎直接到项目中贡献。同时为了国内用户可以加速访问，我们增加了 kubevela.net 这个域名，可以方便国内用户更快的访问，内容与 kubevela.io 的域名完全一致、实时同步。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;KubeVela 是 CNCF 沙箱项目，了解更多信息，请查阅&lt;span&gt;官方文档&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;VelaUX: &lt;em&gt;https://github.com/oam-dev/velaux&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;UISchema: &lt;em&gt;https://kubevela.io/zh/docs/reference/ui-schema&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;X-Definition: &lt;em&gt;https://kubevela.net/zh/docs/platform-engineers/oam/x-definition&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;VelaQL: &lt;em&gt;https://kubevela.io/zh/docs/platform-engineers/system-operation/velaql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;核心概念: &lt;em&gt;https://kubevela.net/zh/docs/getting-started/core-concept&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;交付 Docker 镜像: &lt;em&gt;https://kubevela.net/zh/docs/deliver-app/webservice&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;交付 Helm Chart 包: &lt;em&gt;https://kubevela.net/zh/docs/deliver-app/helm&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;交付 Kubernetes 资源: &lt;em&gt;https://kubevela.net/zh/docs/deliver-app/k8s-object&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;交付 云服务: &lt;em&gt;https://kubevela.net/zh/docs/tutorials/consume-cloud-services&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;100 多位开发者: &lt;em&gt;https://github.com/oam-dev/kubevela/graphs/contributors&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;参与 OAM 模型讨论: &lt;em&gt;https://github.com/oam-dev/spec&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;如何扩展和贡献 Addon 参考文档: &lt;em&gt;https://kubevela.net/zh/docs/platform-engineers/addon/intro&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;常用的云资源: &lt;em&gt;https://kubevela.io/zh/docs/end-user/components/cloud-services/provider-and-consume-cloud-services#%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%91%E8%B5%84%E6%BA%90%E5%88%97%E8%A1%A8&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;如何扩展和贡献云资源: &lt;em&gt;https://kubevela.net/zh/docs/platform-engineers/components/component-terraform&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;参与社区讨论: &lt;em&gt;https://github.com/oam-dev/kubevela&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;GitHub kubevela.io: &lt;em&gt;https://github.com/oam-dev/kubevela.io&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;p&gt;官方文档: &lt;em&gt;https://kubevela.io/zh/docs/install&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2e831b38dd2bb0d35a87f087bf2f14fd</guid>
<title>深入浅出 tnpm rapid 模式 - 如何比 pnpm 快 10 秒</title>
<link>https://toutiao.io/k/n35ir19</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大厂技术&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Node进阶&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;作为一名老前端，不得不感慨，前端变得越来越复杂，依赖安装的速度很慢很慢。&lt;/section&gt;&lt;section&gt;1月8日，蚂蚁集团前端工程师零弌在 SEE Conf 2022 发表了主题演讲：《一种秒级安装 npm 的黑科技》。&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAaN0FbcXSKAAAAAstQy6ubaLX4KHWvLEZgBPExqFEUWlff_H8zNPgMItRMOp24IciCGdiyQHSjtKG&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqzsiajO20MEo83iaKibVXLRfVIJGPEpSIWzbsicJWa6bNibgEkcwtuEtDU6KH554pYAf8ic8Gt5ykiafgMhbN4icBArGyEVA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdXo947nusaRCOWGN6pEgH3L1pkicK82V1DmMpzITApty64M8AkVicsBtQibMFGwL2BE2Y&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/yaiaQbhpvE5ZcraDSQBTMDWa5dKgvLPlQSpLZNwibXb2Q/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08e1dc4dcce0cef3cb0773652b4978fd945026b5a5f1739cf607f@finder&quot; data-nickname=&quot;支付宝体验科技&quot; data-desc=&quot;一种秒级安装 npm 的方式  - 零弌&amp;#10;&amp;#10;现在使用 npm 安装，动辄分钟级的速度很影响研发体验，并且黑洞般的体积浪费了宝贵的磁盘空间。市面上有很多 npm 的替代方案，比如 yarn，pnpm 等等，但是这些工具远远称不上极速。本次分享将带领大家深入 npm 安装原理，通过全方面的优化，将 npm 的安装速度提升到秒级。&amp;#10;#支付宝体验科技大会&amp;#10;&amp;#10;&amp;#10;&quot; data-nonceid=&quot;11979108312335577325&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文从另一个角度来阐述下关于前端依赖安装提速 整个优化工作的背景、思考、结果以及未来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;黑魔法和黑科技的区别在于：前者用&quot;又不是不能用&quot;的脏活来实现目的，后者用跨领域的知识来实现降维打击。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48214285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNGwP59adkLFNtR2uiakaEpfPpx4lbkGOGYc55vIXiaGQnpxQMv5IXUwVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1232&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;npm 为什么会慢？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7784256559766763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZN83nhgD1iad5nicL07sppE8GEAGsX8lbMLJpZYIx9DoHvaNs0VWbOrsww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/section&gt;&lt;section&gt;在现代 npm 生态体系下，模块数量和依赖关系日趋复杂化：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;模块数量众多，截止到 2021 年底，npm 包数量已经超过 180 万，数倍于其他语言的模块数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块关系错综复杂，存在重复依赖，小文件很多，浪费磁盘空间并拖慢写入速度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;就如同一个硬币的两面，追求小而美的 Node.js 的模块生态，推动社区发展空前繁荣的同时，也使得依赖关系变得非常的复杂，一定程度上造成了依赖安装非常慢。&lt;/section&gt;&lt;section&gt;生态现状正确与否，不在今天我们探讨的范畴之内，让我们聚焦在当下如何来提升安装速度。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2578046324269889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNnRfI1oErZts8der1lpxDgR8nRUWAia8QkQRQ3dwTeALDicxMu0wdkwTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1986&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;一个应用的依赖安装过程大致如上，&lt;strong&gt;关键操作&lt;/strong&gt;主要有：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;查询子依赖的包信息，获取下载地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下载 tgz 包到本地，解压安装。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;构造 node_modules 目录结构，写入文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;依赖包安装&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;我们以一个比较有代表性的测试对象 vuepress@1.9.2 为例，&lt;strong&gt;实际依赖数大概 1000 个左右&lt;/strong&gt;，磁盘占用 170M，文件数量 18542 个。&lt;/section&gt;&lt;section&gt;但若使用 npm@2 按传统嵌套目录方式安装后，实际安装依赖数高达 3626 个，有&lt;strong&gt;两千多个重复的依赖&lt;/strong&gt;，磁盘占用 523M，文件数量高达 60257 个。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;然而，文件 IO，尤其是海量小文件的读写是非常耗时的。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;npm@3 先提出了优化思路：&lt;strong&gt;『扁平化依赖』能力&lt;/strong&gt;，所有子依赖都被拍平到了根目录的 node_modules 下，试图解决了重复依赖以及层级太深的问题。&lt;/section&gt;&lt;section&gt;但它也带来了额外的新问题：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;幽灵依赖问题&lt;/strong&gt;（phantom dependencies）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多重身问题&lt;/strong&gt;，无法彻底解决重复依赖，譬如还存在 183 个重复依赖。（doppelgangers）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;依赖结构的不确定性&lt;/strong&gt;。（通过 依赖关系图 可以解决）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扁平化算法的复杂度和性能损耗。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;鉴于扁平化依赖的诸多副作用，pnpm 提出了&lt;strong&gt;另一种解决思路，通过 软链接 + 硬链接 的方式&lt;/strong&gt;：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4741847826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNzNTuDyTKwYY61l3xEqia12KB3FTMOxfYdmz9tYtRJUtFeYl71u9PtfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1472&quot;/&gt;&lt;/section&gt;&lt;section&gt;这种方式能很好的实现了：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;减少包的重复问题，兼容 Node.js 的寻址逻辑，未引入幽灵依赖、多重身等问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全局缓存的硬链接方式，能减少文件复制，节省磁盘占用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;从数据也看到：1109 个模块，18747 个文件，5435 个目录，3150 个软链接，磁盘占用 175M。&lt;/section&gt;&lt;section&gt;我们的 cnpm 当年也受到 pnpm 的启发，重构并实现了 cnpm/npminstall 这个库，同样是通过软链接方式，但没有用到硬链接，也未把子依赖提升到同级。&lt;/section&gt;&lt;section&gt;这种方式潜在的一些问题：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;软链会导致一些 IDE 出现&lt;strong&gt;死循环的 indexing 问题&lt;/strong&gt;。（随着 IDE 的优化，目前已经好了很多）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子依赖提升到同级的目录结构，虽然由于 Node.js 的父目录上溯寻址逻辑，可以实现兼容。但对于类似 Egg、Webpack 的插件加载逻辑，在用到相对路径的地方，需要去适配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同应用的依赖是硬链接到同一份文件，调试时修改了文件，有可能会无意中影响到其他项目。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;硬链接无法跨文件系统，软链在不同操作系统的实现不太一样，且在非 SSD 的硬盘上，还是会有一定的磁盘 IO 损耗的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;此外，yarn 也提出了 Plug&#x27;n&#x27;Play 等优化方式，但鉴于它太过于激进，无法兼容 Node.js  现存生态，在此我们不展开讨论。&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;包信息查询&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;我们再来观察下依赖安装过程：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个依赖都需要 1 次包信息查询，1 次 tgz 下载，共 2 次 HTTP 请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同包不同版本时，仅查询 1 次信息，然后每个版本 tgz 下载 1 次。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;由于当前生态下，依赖个数是非常多的，从而 HTTP 请求次数会对应的被放大，造成可观的耗时增加。譬如上面的例子，npm@2 会发起 2500 多次 HTTP 请求。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;目前的优化共识是：通过事先计算好的依赖关系图，可以直接去下载 tgz，无需查询包信息，从而减少了一大半的网络耗时&lt;/strong&gt;。&lt;/section&gt;&lt;section&gt;npm 先提出了 shrinkwrap 的概念，随即被 yarn 提出 lockfile 所代替，pnpm 也有对应的支持但配置格式不一样。&lt;/section&gt;&lt;section&gt;虽然它们最初的出发点是锁版本，但意外地发现还可以作为 依赖关系图 来提速下载。&lt;/section&gt;&lt;section&gt;但它存在的问题是：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首次安装不会提速，除非把 lockfile 存入源码管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;锁版本在大规模实践中会带来了一定的治理问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNtem3XAFlKZmhYO7gdSGm8NLZ0sWMEEWO51dHIzurqIicOYsiaJz6PNKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2048&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;总结下，若要提升安装速度，我们需要思考：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如何更快的获取依赖关系？（解析策略）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如何更快的下载 tgz 包？（网络 IO）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如何更快的写入到硬盘？重复的依赖如何处理？（文件 IO）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;目前已达成的共识：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过依赖关系图，来优化网络 IO 时序，实现更高效的并发下载。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过某些方式去简化 node_modules 目录，优化重复依赖带来的文件 IO 问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全局缓存，减少网络 IO 下载量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;存在的问题：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;lockfile 一定程度上会带来维护成本问题，锁版本和不锁版本都不是银弹。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扁平化依赖 和 软链接 方式都存在各自的一些兼容性问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全局缓存的使用方式未达成共识，解压复制方式产生大量文件 IO，硬链接方式会有潜在的冲突问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;参考阅读：JavaScript 包管理简史&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;tnpm 和 cnpm 是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3646723646723647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNaZVJ3n5pCODES5vJZJyEedPMmVnE11IOI8VrQ6j541MOrt6zKR9JPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2106&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;如上图，简单的说：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cnpm 是我们开源的 npm 实现，支持官方 npm registry 的镜像同步，以及私有包能力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;npmmirror 是社区基于 cnpm 部署的一个公益项目，为中国前端开发者提供镜像服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tnpm 是我们在阿里巴巴及蚂蚁集团的企业服务，同样基于 cnpm 之上做了企业级的能力定制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;优化效果&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;在阿里巴巴及蚂蚁集团，对工程师来说，研发效能是一个很重要的指标，而前端依赖的安装速度，是一个很大的影响因子。&lt;/section&gt;&lt;section&gt;因此我们在 2021 年发起了一个攻关专项，目标之一就是优化依赖的安装速度，最终成功地提速了 3 倍，斩获了蚂蚁集团鲁班奖。&lt;/section&gt;&lt;section&gt;接下来，将带大家一起剖析下&lt;code&gt;tnpm rapid 模式&lt;/code&gt;的优化思路及结果。&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;测试场景&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;性能调优法则：无度量，不优化。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;307&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5310734463276836&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNOA5kNEgfhm7D0g7Yk36WliaJFFrDU6A9wpn382ffv6CF9FwOAwOX7QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PS：我们可能是业界首个把 Mac mini m1 重装为 Linux 组成前端构建集群的企业，它让我们的整体构建速度额外提升了一倍。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;测试结果&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;242&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.41931942919868276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNOY4ficRbW2ibQVEB6MaZLZ4jyY5hqEWqLOYWOKTDy7A10XR8iaaNoPAfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot;/&gt;&lt;/section&gt;&lt;section&gt;我们先不对该结果做解读，等我们对 tnpm rapid 模式的优化思路逐一讨论后，再来讨论会更有体感。&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;背后的数据&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;回忆之前我们在最开始分析慢的原因时给出的数据，完整如下：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;228&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39433293978748524&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNd34SGZFELXicB6J65X1UuCmBtLjldQdG9BWVGkmmjQljutX2KvgVxTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1694&quot;/&gt;&lt;/section&gt;&lt;section&gt;在无 lock + cache 情况下，通过  strace 和 charles 采集了相关数据，并统计对应的文件个数和体积。&lt;/section&gt;&lt;section&gt;简单解读下：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件数：扁平化依赖 和 软硬链接 的数量基本上差不多，都大幅减少了磁盘占用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;磁盘 IO：一个重要的指标，文件写入次数直接关系到安装速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络速度：体现的是安装过程是否能尽可能的跑满带宽，越大越好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求数：包括 tgz 下载数和查询包信息数，基本上都近似为模块个数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;从数据中可以看到，tnpm 对 磁盘 IO 和 网络 IO 都有较大的优化。&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;我们是如何优化的？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;网络 IO&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;对于网络 IO 的优化，我们只有一个目标：&lt;strong&gt;如何最大化的跑满带宽？&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;第一个优化点是 依赖关系图&lt;/strong&gt;（dependencies graph）：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;目前的共识都是通过它来避免在 CLI 近端侧去请求每个包的元数据，从而极大的减少了 HTTP 请求数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们的特殊之处在于：&lt;strong&gt;在服务端侧生成依赖关系图，并实现了多级缓存策略。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用&lt;code&gt;@npmcli/arborist&lt;/code&gt;，遵循 npm 规范。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;在我们的企业级大规模实践中的经验和理念是不提倡本地锁版本，仅在迭代推进工作流中会复用上一阶段的依赖关系图，如 开发环境 → 测试环境，或紧急迭代等。（锁不锁版本是一个时常争吵的话题，并没有银弹，根据企业团队情况寻找各自的平衡点，在此不展开讨论。）&lt;/section&gt;&lt;section&gt;&lt;strong&gt;第二个优化点是 HTTP 请求预热&lt;/strong&gt;：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一次 tgz 的下载过程，会先访问 registry，然后被 302 到 oss 下载地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过提前预热，可以提高并发度，从而减少总的 HTTP 耗时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;期间还踩过一个 DNS 间歇性 5 秒延迟的坑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;npm registry 是没有这一次 302 跳转的，我们把下载流量的逻辑从 registry 分离了出去，重定向到有 CDN 缓存的 OSS 存储地址，从而提升稳定性，以及支持应急止血治理等企业级场景。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;第三个优化点是合并文件&lt;/strong&gt;：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们在测试时发现无法跑满带宽，分析后发现：&lt;strong&gt;在海量的依赖包的情况下，小文件的频繁写入会导致文件 IO 瓶颈。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仅把 tgz 解压为 tar 文件，鉴于 tar 是归档文件格式，我们可以非常方便地在写入磁盘时适当地合并文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经过我们反复的测试，得到的经验值是合并为 40 个 tar 包。即 1000 多个 tgz 最终仅存储为 40 个 tar。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;第四个优化是用 Rust 重新实现了下载和解压逻辑：&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;并发 40 个协程，流式下载，解压并合并写入为 tar 包。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于内置的底层库有所差异，就目前而言，Rust 的下载和解压性能会优于 Node.js。于是我们用 Rust 封装了 napi 模块供 tnpm 调用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4915651358950328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZN63F81cicZqoYulPgjsNza6ftUiafpNqZQsfzH38L29oiaTxtu4kc3lsKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2134&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;FUSE 文件系统&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;我们认为 Node.js 最初的&lt;code&gt;嵌套目录&lt;/code&gt;优于&lt;code&gt;扁平化&lt;/code&gt;方案，但又希望能解决软链带来的兼容性问题，如何鱼与熊掌兼得呢？&lt;/section&gt;&lt;section&gt;先来引入一个黑科技：FUSE (FileSystem in Userspace)，即 &lt;strong&gt;用户态文件系统&lt;/strong&gt;。&lt;/section&gt;&lt;section&gt;似乎比较抽象？我们回想一个前端很熟悉的场景：使用 ServiceWorker 来精细化地定制 HTTP Cache Control 逻辑。&lt;/section&gt;&lt;section&gt;是的，前端同学可以&lt;strong&gt;把 FUSE 理解为文件系统版的 ServiceWorke&lt;/strong&gt;r，&lt;strong&gt;通过 FUSE 可以接管一个目录的文件系统操作逻辑。&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48366650414431983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNibuYbGJhic8zxw8N3ztOlYW0zCyk1EENW35icLRtgyyicPGtsia5IXvr26Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2051&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;如上图：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们基于 nydus 实现了 npmfs 守护进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 npmfs 注册为操作系统的 fuse 守护进程，挂载了虚拟映射目录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当读取该目录的文件时，操作系统会把控制权转交给我们的进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们的进程通过查询&lt;code&gt;依赖关系图&lt;/code&gt;来从全局缓存找到并返回对应的文件内容。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;通过这种方式，我们实现了：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;所有的系统文件操作指令，都会把这个目录视为真实的目录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个文件都被视为是独立的文件，不会像硬链接那样会互相影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;nydus 目前不支持 macOS，故我们实现 nydus 到 macfuse 的适配层，待完善后会开源出来。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;冷知识：nydus 是星际里的一个兵种，负责挖洞。&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;OverlayFS&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;日常开发时，我们有可能会需要临时修改 node_modules 下的代码，以便调试。这也是软硬链接方案潜在的问题，会导致不同应用在无意间互相干扰。&lt;/section&gt;&lt;section&gt;FUSE 支持自定义写入操作，但实现起来比较复杂，我们直接使用了 OverlayFS&lt;strong&gt;联合文件系统&lt;/strong&gt;。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;OverlayFS 可以聚合多种不同的挂载点到一个目录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常用的场景是：在一个只读层上覆盖一个读写层，达到让只读层能够读写。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker 中的镜像就是这么实现的，镜像中的 layer 可以复用于不同的容器，且不互相影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.601380042462845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZN3olvoGJD0CuVOB4pxtPklSia5K5ySjAvPniciafyZicQAMDunvCuT2nbGg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1884&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;所以，我们进一步实现了：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把 FUSE 目录作为 OverlayFS 的 Lower Dir，构造出一个可以读写的文件系统，并挂载为应用的&lt;code&gt;node_modules&lt;/code&gt;目录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用其 COW(copy-on-write) 特性，我们可以复用底层文件，达到节省空间的目的，并支持独立的文件修改，隔离不同应用的互相干扰，&lt;strong&gt;安全的全局复用一份缓存&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;文件 IO&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;接下来我们再聊聊&lt;code&gt;全局缓存&lt;/code&gt;，目前业界主要有 2 种方案：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;npm：把 tgz 解包成 tar 作为全局缓存，再次安装依赖时解压到 node_modules。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pnpm：把 tgz 解压为文件，以 hash 方式全局缓存， 同个包的不同版本的同个文件也能共享，再次安装时直接硬链接过去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;它们的共同点都是会在某个阶段解压为文件，并写入到磁盘。&lt;/section&gt;&lt;section&gt;我们通过 strace 来分析系统调用，会发现解压产生的海量小文件会造成海量的文件 IO 操作。&lt;/section&gt;&lt;section&gt;某天我们突然开了个脑洞，&lt;strong&gt;干脆别解压了？&lt;/strong&gt;🤔 🤔 🤔&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47101760412194077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNh4nvGTSj0jic249K5UiaxQ5e2Ovqkm3KLIsW0RrIhqPmqJHrAYYaB0Sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2329&quot;/&gt;&lt;/p&gt;&lt;section&gt;所以，我们又进化了一步：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;直接把 &lt;code&gt;node_modules&lt;/code&gt;通过 FUSE + 依赖关系图 映射到 tar 归档文件，省去了解压带来的文件 IO。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时基于 FUSE 的高度可控性，我们可以很容易支持&lt;code&gt;嵌套目录&lt;/code&gt;和&lt;code&gt;扁平化&lt;/code&gt;两种结构，按需切换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;想象空间：如何未来云存储的访问性能进一步提升，我们甚至可以不用下载 tgz 了？&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;曾经的另一些尝试：我们一度想把 tar + gzip 转换为 stargz + lz4，但收益不是很大：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;stargz 比 tar 多了索引能力，但实际上独立的依赖关系图也能实现类似的目的，没必要打包在一起。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lz4 比 gzip 有很高的性能提升，但在我们目前的实践中发现， ROI 不高。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;额外成本&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;任何方案都不可能是完美无缺的，我们的方案存在一些额外的成本：&lt;/section&gt;&lt;section&gt;&lt;strong&gt;第一点是 FUSE 的成本&lt;/strong&gt;：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;跨系统兼容性成本，虽然有各个操作系统的支持库，但兼容性上还需要时间检验。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;企业内部场景需要支持特权容器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;社区场景要看 GitHub Actions 和 Travis 是否支持 FUSE。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;第二点是服务端维护成本&lt;/strong&gt;：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用的依赖关系图分析能力，仅能在企业内部私有化部署的 Registry 开启。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于服务端资源限制，该能力不对公共镜像站服务开放，会 fallback 到 CLI 近端侧生成方式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;核心思路&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6066311911584118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNATCFib0VicoRMELUDbQOgQneUOTusibUNgjRWCGR1M6nsVic0eYGccGmYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2443&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;综上，我们的方案的核心优势：&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务端生成依赖树，省去元数据请求，即：&lt;code&gt;模块数 * HTTP 耗时&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Rust 带来的性能提升。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;合并写入 tar，节省磁盘写入次数，即：&lt;code&gt;(模块数 - 40) * 磁盘操作耗时&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FUSE 映射，不解压文件，节省磁盘写入次数，即 &lt;code&gt;(文件个数 + 目录个数 + 软硬链个数) * 磁盘操作耗时&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Node.js 标准目录结构，无软链，无扁平化副作用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;数据解读&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;经过上面的分析，大家应该基本清楚&lt;code&gt;tnpm rapid 模式&lt;/code&gt;的优化思路，现在再让我们回过头来，解读下前面的测试结果数据。&lt;/section&gt;&lt;section&gt;注意：目前 tnpm rapid 模式还处于小范围测试和持续迭代完善阶段，故该测试数据仅供参考。&lt;/section&gt;&lt;section&gt;另外，表中的 yarn 比 npm@8 还慢，暂时不知道原因，但用 pnpm 的 benchmark 测试了多次，基本上是这个结果。&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;252&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4361334867663982&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHenyxsibaiacbwpK3X4a5fZNnKBYqVhjx0TqwLvBkLwF7N7mq44TafC09fibWZb4edpyps0hXVs0ibIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1738&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;简单解读下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;第一点：生成&lt;code&gt;依赖关系图&lt;/code&gt;的耗时。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以通过观察 1 和 5 两项测试，它的差值即为对应的包管理器的耗时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pnpm 是近端侧 HTTP 分析方式，大概是 4 秒多一点（查询包信息和下载是并行的）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tnpm 是服务端侧分析方式，目前是 5 秒，它比 pnpm 少了网络延迟但速度却一样，后面我们还需要继续优化&lt;strong&gt;。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;在企业场景中，依赖的模块是相对收敛的，由于 tnpm 的依赖关系图有缓存机制，故在命中缓存情况下，第一项测试 tnpm 的耗时仅为 5 秒。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;第二点：&lt;strong&gt;文件 IO 耗时&lt;/strong&gt;。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在实际场景中，&lt;strong&gt;CI 场景和迭代场景，有依赖关系图 + 无全局缓存&lt;/strong&gt;，可以近似认为是 测试 5。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该情况下主要耗时 = tgz 下载时间 + 文件 IO 时间，前者数量基本一致，故两者的差距主要是文件 IO。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据中可以观察到：&lt;strong&gt;tnpm 比 pnpm 快 4 秒，归因是 FUSE 省掉了解压写入文件的耗时 + TAR 合并&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;第三点：&lt;strong&gt;本地开发常态&lt;/strong&gt;。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于&lt;strong&gt;日常开发场景，有依赖关系图 + 有全局缓存。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对应于 测试 2（依赖未有新版本，二次开发），测试 3（二次开发，重装依赖），测试 4（新应用首次开发）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从原理上分析，耗时 = 依赖关系图更新 +  写入 node_modules 文件 + 少量包的下载更新。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于 tnpm 还在开发中，本次未能测试该项，不过从以上公式可以分析，tnpm 比 pnpm 有 IO 优势。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;小结下：tnpm 比起 pnpm 的速度优势在于 依赖关系图 的 5 秒 + FUSE 免解压的 4 秒。&lt;/strong&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;未来寄望&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;前端的包管理已经发展了近十年了，从 npm 拓荒时的积极进取，到 bower 等认输后 npm 的四顾茫然原地蹉跎，到鲶鱼 yarn 出现后的群雄逐鹿，再到 pnpm 的精益求精。&lt;/section&gt;&lt;section&gt;我们认为前端依赖的优化之路和治理之路，还任重道远，希望能和国内外同行，继续加强合作，一起推动 npm 的进化。&lt;/section&gt;&lt;section&gt;从 cnpm 在 2013 年开源之后，在社区的价值更多是 npmmirror 镜像站。而我们在企业级场景中的很多经验都在 tnpm，没能顺畅的下沉出来形成循环。&lt;/section&gt;&lt;section&gt;因此，我们后续的规划是：把我们在企业级私有化部署和治理的经验尽可能沉淀出来回馈给社区。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;目前 cnpm/npmcore 在重构中，以便更好的支持更好的私有化部署。（欢迎参与开源）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 tnpm rapid 模式完善后，将把对应的能力，以及 npmfs 套件开源出来。（因此目前社区同学还没办法体验）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于 npm 在企业级实践中的经验分享，希望有时间能写成小册分享出来。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;同时我们也呼吁：&lt;strong&gt;前端的包管理的规范化&lt;/strong&gt;：&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有类似 ECMA 之类的标准，来规范各个包管理器的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有类似 Test 262 的测试用例规范。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处于薛定谔阶段的 ESM 和 CommonJS 规范的加速演进。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前端 和 Node.js 不同场景依赖的差异性的混乱局面得到解决。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;经过这一年的优化，我们收获很多，也在思考和总结：为什么我们能做到这事？&lt;/section&gt;&lt;section&gt;我们的&lt;strong&gt;优势之一是 云 + 端 的全局掌控力&lt;/strong&gt;：不仅仅是一个近端的 CLI，还比其他包管理器多了一个远端的 registry 服务，可以更深度的进行优化。&lt;/section&gt;&lt;section&gt;其次，我们的团队成员更加的&lt;strong&gt;多元化，具备来自不同领域的知识&lt;/strong&gt;，让我们可以跳出前端视野局限，从操作系统、文件系统、网络调优等方面去碰撞灵感。&lt;/section&gt;&lt;section&gt;借用之前 死月 分享的一句话：&lt;strong&gt;黑魔法和黑科技的区别在于：前者用&quot;又不是不能用&quot;的脏活来实现目的，后者用跨领域的知识来实现降维打击。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;在企业级应用场景里面，前端构建提速的优化之路，不仅仅是依赖安装这一环节，它是一个系统化的工程，还有非常多的优化点，欲知详情，欢迎加入我们。&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKFT2qmMSUOo7dbqAFU6YbcKNicEcjicibAWucVqCNluuhhvkcaykgnIx7vppA2Kt6pK8etGdcSy2iasYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;关于我&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;我是天猪，目前在蚂蚁体验技术部广州分部，负责前端基础设施的建设，团队主要以 Node.js 为主，局部会用 Go 写 mesh，用 Rust 写模块，开源了 eggjs, cnpm 等项目，等你加入。&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;118&quot; data-source-title=&quot;天猪&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section data-content-utf8-length=&quot;117&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;『Node.js 在前端领域是一个不可或缺的基础设施，或许未来前端的变革使得一切工程问题从根本上得到解决，但不管怎样，我只是希望当下能认真记录自己以及同行者们在这个领域的所见所想，与正在经历前端工业化演进并被此过程困扰的同学交流心得。』&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A118%2C%22text%22%3A%22%E3%80%8ENode.js%20%E5%9C%A8%E5%89%8D%E7%AB%AF%E9%A2%86%E5%9F%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%8C%E6%88%96%E8%AE%B8%E6%9C%AA%E6%9D%A5%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8F%98%E9%9D%A9%E4%BD%BF%E5%BE%97%E4%B8%80%E5%88%87%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98%E4%BB%8E%E6%A0%B9%E6%9C%AC%E4%B8%8A%E5%BE%97%E5%88%B0%E8%A7%A3%E5%86%B3%EF%BC%8C%E4%BD%86%E4%B8%8D%E7%AE%A1%E6%80%8E%E6%A0%B7%EF%BC%8C%E6%88%91%E5%8F%AA%E6%98%AF%E5%B8%8C%E6%9C%9B%E5%BD%93%E4%B8%8B%E8%83%BD%E8%AE%A4%E7%9C%9F%E8%AE%B0%E5%BD%95%E8%87%AA%E5%B7%B1%E4%BB%A5%E5%8F%8A%E5%90%8C%E8%A1%8C%E8%80%85%E4%BB%AC%E5%9C%A8%E8%BF%99%E4%B8%AA%E9%A2%86%E5%9F%9F%E7%9A%84%E6%89%80%E8%A7%81%E6%89%80%E6%83%B3%EF%BC%8C%E4%B8%8E%E6%AD%A3%E5%9C%A8%E7%BB%8F%E5%8E%86%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%B8%9A%E5%8C%96%E6%BC%94%E8%BF%9B%E5%B9%B6%E8%A2%AB%E6%AD%A4%E8%BF%87%E7%A8%8B%E5%9B%B0%E6%89%B0%E7%9A%84%E5%90%8C%E5%AD%A6%E4%BA%A4%E6%B5%81%E5%BF%83%E5%BE%97%E3%80%82%E3%80%8F%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22%E5%A4%A9%E7%8C%AA%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;天猪&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; letter-spacing: 0px; text-align: left; white-space: normal; font-size: 16px; line-height: 1.6; word-break: break-word;&quot; data-darkmode-color-16072568501583=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(0, 0, 0)&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_t_042&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;Node 社群&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwsF7OKB4iaaXAzQPbNstk2LybA0Zz5I1hiaiazE9W7WH2Ojt2dibDODWMVUmHqgfXCefVwt7z5ibNMWLvg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;578.2649006622516&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;700.2119205298013&quot; data-fileid=&quot;100016913&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2093425605536332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwvFQgO67XibvUG5S2UMXwCghOuJvE8BFRzUXnCAfWXkU1qHld6Ly9xiarib3siaWicJWJ0U3lI8kSgD38w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; color: rgb(89, 89, 89); line-height: 26px;&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span&gt;如果你觉得这篇内容对你有帮助，我想请你帮我2个小忙：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;1. 点个&lt;/span&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;，让更多人也能看到这篇文章&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;2. 订阅官方博客 &lt;/span&gt;&lt;span&gt;www.inode.club &lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;让我们一起成长&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>