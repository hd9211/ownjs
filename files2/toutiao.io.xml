<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6b636b9eaebb464527414216810bf75c</guid>
<title>春联专用喷胶，点击领券现价只需4.6元！</title>
<link>https://toutiao.io/k/1i9uqmb</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>361823b3c6e24bc3b8e4b869d0e18332</guid>
<title>[推荐] 2021年美团技术团队最受欢迎的22篇技术文章</title>
<link>https://toutiao.io/k/pjse55y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;48&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5nRELR88hKm19m3h9O1VyjezVQS8yoeqdGeowicW5M36rScUKVg0Fgjg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;再见2021&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;你好2022&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;「美团技术团队」微信公众号祝大家新年快乐！温故而知新，我们根据文章的「阅读量」和「在看」数，以及所覆盖的技术领域，精选了22篇技术文章作为新年礼物送给大家。希望在2022年，继续陪大家一起，静心苦练，砥砺向前。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了做出更好的内容，从2022年开始，我们在选题层面想多听听大家的意见和建议。我们准备了一份&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://wenjuan.meituan.com/survey/4718823&quot; textvalue=&quot;调研问卷&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;调研问卷&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;，欢迎大家帮忙填写。我们会评选出5位小伙伴，每人送上一个美团礼品店的精美键盘手托&lt;span&gt;（&lt;/span&gt;&lt;/span&gt;&lt;span&gt;活动的截止日期为2022年1月6日&lt;/span&gt;&lt;span&gt;&lt;span&gt;）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2021年「阅读量」最高的11篇技术文章&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw585Do2RKobEuibjYJcen1Hqfz8L3kuFPIdJPS5aR3Ok3GWewibKbSib9Cw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;操作日志几乎存在于每个系统中，而这些系统都有记录操作日志的一套API。操作日志和系统日志不一样，操作日志必须要做到简单易懂。所以如何让操作日志不跟业务逻辑耦合，如何让操作日志的内容易于理解，如何让操作日志的接入更加简单？上面这些都是本文要回答的问题。本文主要围绕着如何「优雅」地记录操作日志展开描述。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5iceicaTuWEYBK0jlc61atMev5gLsstYibesiaDKcia7GyMibBvWWgSqFcXGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;剧本杀作为爆发式增长的新兴业务，在商家上单、用户选购、供需匹配等方面存在不足，供给标准化能为用户、商家、平台三方创造价值，助力业务增长。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文介绍了美团到店综合业务数据团队从0到1快速建设剧本杀供给标准化的过程及算法方案。我们将美团到店综合知识图谱（&lt;/span&gt;&lt;span&gt;GENE，GEneral NEeds net&lt;/span&gt;&lt;span&gt;）覆盖至剧本杀行业，构建剧本杀知识图谱，实现供给标准化建设，包括剧本杀供给挖掘、标准剧本库构建、供给与标准剧本关联等环节，并在多个场景进行应用落地。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651764792&amp;amp;idx=1&amp;amp;sn=ac3469fb016bca3cd3316b2adcd2e6cf&amp;amp;chksm=bd1261758a65e863c57dfdc4f4c7b2c92ca0fc964d67a74461d6018e5549b3eb6323316827d2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团商品知识图谱的构建及应用&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团商品知识图谱的构建及应用&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; | &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;阅读量24601&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SrzneHh6Xq8pmkzhmGWGViaiagFFqst6M2uClyMictt4CUUSxLIiaKU3M6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;商品知识图谱作为新零售行业数字化的基石，提供了围绕商品的精准结构化理解，对业务应用起到了至关重要的作用。相比于美团大脑中原有的围绕商户的图谱而言，商品图谱需应对更加分散、复杂、海量的数据和业务场景，且面临着信息来源质量低、数据维度多、依赖常识以及专业知识等挑战。本文将围绕零售商品知识图谱，介绍美团在商品层级建设、属性体系建设、图谱建设人效提升等方向的探索，希望对大家有所帮助或启发。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651762036&amp;amp;idx=1&amp;amp;sn=744a07b22a3988b93403c34c4dd3ec1e&amp;amp;chksm=bd1274398a65fd2f091425dc439adaaf38948dade7d96d9da7ae11a8cdd3ac804afe43152146&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;GraphQL及元数据驱动架构在后端BFF中的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;GraphQL及元数据驱动架构在后端BFF中的实践&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阅读量22247&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SPa9eV4oRDuMr5RMLf9x5ZbDLczAB1SJEiaMcfUCB6IpDM75IuictrsKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;GraphQL是Facebook提出的一种数据查询语言，核心特性是数据聚合和按需索取，目前被广泛应用于前后端之间，解决客户端灵活使用数据问题。本文介绍的是GraphQL的另一种实践，我们将GraphQL下沉至后端BFF（&lt;/span&gt;&lt;span&gt;Backend For Frontend&lt;/span&gt;&lt;span&gt;）层之下，结合元数据技术，实现数据和加工逻辑的按需查询和执行。这样不仅解决了后端BFF层灵活使用数据的问题，这些字段加工逻辑还可以直接复用，大幅度提升了研发的效率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651764763&amp;amp;idx=1&amp;amp;sn=422829698f38fd660b791f30e6197d26&amp;amp;chksm=bd1261568a65e8403d9e95a7d9e10c192c9837282fff0914f7b709d613d64cb0888f2f82bc46&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团外卖实时数仓建设实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;美团外卖实时数仓建设实践&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; | 阅&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;读量21767&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SFJWVW0v0mtw6OtFnwe8bFReQXwIkg4VFdNsXQfTlqRWUMLDYm4azPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文主要介绍一种通用的实时数仓构建的方法与实践。实时数仓以端到端低延迟、SQL标准化、快速响应变化、数据统一为目标。美团外卖数据智能组总结的最佳实践是：一个通用的实时生产平台跟一个通用交互式实时分析引擎相互配合，同时满足实时和准实时业务场景。两者合理分工，互相补充，形成易开发、易维护且效率高的流水线，兼顾开发效率与生产成本，以较好的投入产出比满足业务的多样性需求。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651761795&amp;amp;idx=1&amp;amp;sn=49a812ee8b9bf1cae5bd088c53772007&amp;amp;chksm=bd1275ce8a65fcd8cb960cf727125c8462022c39e50a314bc79a60737a75909b26791c37536e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团酒旅数据治理实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团酒旅数据治理实践&lt;/a&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; | &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;阅读量20692&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SO0BokziboNoW4gWFY9kQlfkGuFcUZcz458fKtkWiaxPOFfvx2z66QiaZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据已成为很多公司的核心资产，而在数据开发的过程中会引入各种质量、效率、安全等方面的问题，而数据治理就是要不断消除引入的这些问题，保障数据准确、全面和完整，为业务创造价值，同时严格管理数据的权限，避免数据泄露带来的业务风险。数据治理是数字时代很多公司一项非常重要的核心能力，本文介绍了美团酒旅平台在数据治理方面的实践。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651766025&amp;amp;idx=1&amp;amp;sn=aa679077682c4ede23ea82d3a8353d11&amp;amp;chksm=bd1264448a65ed52ef2537d0bfb08d32e8beb71406e141dfdd7cf7bfe657e6de0f28053b05c0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;FlutterWeb性能优化探索与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;FlutterWeb性能优化探索与实践&lt;/a&gt; | &lt;strong&gt;&lt;span&gt;阅读量19642&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SVMbUKI71xm50r6XgJXvJxiaKEQFBVvicGDAAfuSvyWWvnMP9DQom05ibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;美团外卖商家端基于 FlutterWeb 的技术探索已久，目前在多个业务中落地了App、PC、H5的多端复用，有效提升了产研的整体效率。在这过程中，性能问题是我们面临的最大挑战，本文结合实际业务场景进行思考，介绍美团外卖商家端在FlutterWeb性能优化上所进行的探索和实践。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651762298&amp;amp;idx=1&amp;amp;sn=1fec5406ab2f3cc9161050247d9c1a9a&amp;amp;chksm=bd1277378a65fe2112c5bbf9d1add0fbb12388833c81dc4df8a4fb63f2b6ed84e70c38b73a7e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;百亿规模API网关服务Shepherd的设计与实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;百亿规模API网关服务Shepherd的设计与实现&lt;/a&gt; | 阅读量19591&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SFmntgNfzHGE6O7JTE0HIKH9fcQw6survYEVyoSERZBh5ftvJbkHCrQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在微服务架构下，服务拆分会让API的规模成倍增长，使用API网关来管理API逐渐成为一种趋势。美团统一API网关服务Shepherd就是在这种背景下应运而生，适用于美团业务且完全自研，用于替换传统的Web层网关应用，业务研发人员通过配置的方式即可对外开放功能和数据。本文将介绍美团统一API网关诞生的背景、关键的技术设计和实现，以及API网关未来的规划。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765144&amp;amp;idx=1&amp;amp;sn=57eaf4171ae1a21c177d5631d5f27c22&amp;amp;chksm=bd1260d58a65e9c36f07e280895b618a9af8fc4de313d110f960ad57ee2c2daf7cb97534adba&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;情感分析技术在美团的探索与应用&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;情感分析技术在美团的探索与应用&lt;/a&gt;  | 阅读量18820&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SncMqTwJaFhbYphqreTMibKTQEkUZkHwOYNicib5JL6Qj0MC9ibibHk9kfJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2021年5月，美团NLP中心开源了迄今规模最大的基于真实场景的中文属性级情感分析数据集ASAP，该数据集相关论文被自然语言处理顶会NAACL2021录用，同时该数据集加入中文开源数据计划千言，将与其他开源数据集一起推动中文信息处理技术的进步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文回顾了美团情感分析技术的演进和在典型业务场景中的应用，包括篇章/句子级情感分析、属性级情感分析和观点三元组分析。在业务应用上，依托情感分析技术能力构建了在线实时预测服务和离线批量预测服务。截至目前，情感分析服务已经为美团内部十多个业务场景提供了服务。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651763589&amp;amp;idx=1&amp;amp;sn=61af71dfa809ce8a6c816cff410ca9ad&amp;amp;chksm=bd126ac88a65e3ded3e065f7303427d55f1d10d0095d276ca64d2722462158a8b10c36312722&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;多业务建模在美团搜索排序中的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;多业务建模在美团搜索排序中的实践&lt;/a&gt;  | 阅读量18124&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SODZ0Cxib9RPOLX3n7fsOeXDrXEN6kb2aGsaRtictVdgKjORqwicnYQ5ibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文分享了美团搜索中的多业务排序建模优化工作，我们主要聚焦在到店商家多业务场景，后续的内容会分为以下四个部分：第一部分是对美团搜索排序分层架构进行简单介绍；第二部分会介绍多路融合层上的多业务融合建模；第三部分会介绍精排模型的多业务排序建模；最后一部分是总结和展望。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651764420&amp;amp;idx=1&amp;amp;sn=392b2a0b187521aad5742cbfe7ca9452&amp;amp;chksm=bd126f898a65e69f6f56368c8dfd2e16dd0a987c3b0136d61205ae0e166a14fb0f3e21b70917&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spock单元测试框架以及在美团优选的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Spock单元测试框架以及在美团优选的实践&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; | 阅读量15531&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SPYqFNJgu9SnURXvYP4m4zL7eictN6qgHkjLOtxs4jBztzwVvnOJQsew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Spock是国外一款优秀的测试框架，基于BDD（&lt;/span&gt;&lt;span&gt;行为驱动开发&lt;/span&gt;&lt;span&gt;）思想实现，功能非常强大。Spock结合Groovy动态语言的特点，提供了各种标签，并采用简单、通用、结构化的描述语言，让编写测试代码更加简洁、高效。目前，美团优选物流绝大部分后端服务已经采用了Spock作为测试框架，在开发效率、可读性和维护性方面均取得了不错的收益。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2021年「在看」数最高的11篇技术文章&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5Sy9htBdN2sdiao2u5icGiaEh9blyPKibRj3I0TxM4R6n0glz3NxNb7zslg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;压缩在数据传输和存储过程中经常扮演着十分重要的角色，因此提高压缩的效率可以帮助我们节省时间和降低存储成本。本文介绍了压缩算法的优化在构建部署平台的应用，能够帮助研发团队提高研发和交付效率。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;310&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;310&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5L3ePvPBYq1Szn35Q7LMo1J4JbIbJOTggbDVX6Sib1EypibegVOme3aNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kafka在美团数据平台承担着统一的数据缓存和分发的角色，针对因PageCache互相污染，进而引发PageCache竞争导致实时作业被延迟作业影响的痛点，美团基于SSD自研了Kafka的应用层缓存架构。本文主要介绍了该架构的设计与实现，主要包括方案选型，与其他备选方案的比较以及方案的核心思考点等，最后介绍该方案与其他备选方案的性能对比。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5WwQ90TwdYkZ1nb2johiaNVpd3ToZAfCm0oXxZvLAGvumrKr6VxhMJSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;鸿蒙系统HarmonyOS是华为推出的一款分布式操作系统，那么如何在保证开发迭代效率的前提下，以相对低的成本将移动应用快速移植到鸿蒙平台上呢？美团外卖MTFlutter团队近期做了一次技术探索，成功地实现了Flutter对于鸿蒙系统的原生支持。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651757344&amp;amp;idx=1&amp;amp;sn=ac67ad68f296d95f4cdc9746ef717469&amp;amp;chksm=bd12426d8a65cb7bfb166e9f1a3dc9a0a3b9157ad3d7b43d2874534b4734f9f39a31fc8c1bfa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;自动驾驶轨迹预测算法：NeurIPS挑战赛冠军方案&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;自动驾驶轨迹预测算法：NeurIPS挑战赛冠军方案&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;strong&gt;| &lt;/strong&gt;&lt;span&gt;在看数2931&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5ibDk8HHQ8fx6s1c8seVLf7wkVAtMq57SkWb0hE3SicuSiaEicCcQlEHE5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团无人车配送中心团队获得NeurIPS 2020 INTERPRET轨迹预测挑战赛Generalizability赛道冠军、Regular赛道亚军，本文对算法层面进行了介绍。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw54T85B0rFEUqLLIAEDuHibW37s4q3IRusREB9AhfKEtLeOXChCDNWOXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;本文介绍了美团平台自研的一款cocoapods插件，该插件可以大幅提升iOS工程代码的编译速度。文章前半部分主要介绍相关的原理，后面主要阐述在工程层面的实践。&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5tw6XF3g375ypALib9lJ2W4dxMYbCMfjMiaM4nw0qo0SQexlUNHrZ9aZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着美团外卖业务的发展，算法模型也在不断演进迭代中。本文从特征框架演进、特征生产、特征获取计算以及训练样本生成四个方面介绍了美团外卖特征平台在建设与实践中的思考和优化思路。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw58SXibWlJ62ibnibWXjzfXVJ7JddnpTzJOPzfTtlCzbLyywjjJqLy8Eb9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;OCTO 2.0是美团下一代分布式服务治理系统，它基于美团现有服务治理系统OCTO 1.0与Service Mesh通信基础设施层的结合，是命名服务、配置管理、性能监控、限流鉴权等服务治理功能的全新演进版本。本文主要讲述OCTO 2.0的重要功能及实现思路。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw58uwVCRVInW1qCWcZRg0qV0tH9etn2wHg2ZKCvb8FBD2l1u0FQyGbcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在多形态业务场景下，如何保障多端体验的一致性，是前端技术领域一个比较受关注的方向。美团外卖前端技术团队基于FlutterWeb探索跨端（&lt;/span&gt;&lt;span&gt;App\PC\H5&lt;/span&gt;&lt;span&gt;）的解决方案，真正实现「Write Once &amp;amp; Run AnyWhere」，本文系该团队的实践经验总结。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw57g1ezIBKwM7n96wHSAekjJ35gEuApaiaGrEpAz8FLWHH8jBepH1T3ibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计稿（&lt;/span&gt;&lt;span&gt;UI视图&lt;/span&gt;&lt;span&gt;）转代码是前端工程师日常不断重复的工作，这部分工作复杂度较低但工作占比较高，所以提升设计稿转代码的效率一直是前端工程师追求的方向之一。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;此前，前端工程师尝试过将业务组件模块化构建成通用视图库，并通过拖拽、拼接等形式搭建业务模块，从而实现视图复用，降低设计稿转代码的研发成本。但随着业务的发展和个性化的驱动，通用视图库无法覆盖所有应用场景，本文提出了一种设计稿自动生成代码的方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUQsT0hP654Z3BSI1icicHkw5pibxSPnGbdTmT0hFsGte3u1CAib8bFycmWEicPmnu1cWRzMy7fco1H87Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图数据结构，能够更好地表征现实世界。美团业务相对较复杂，存在比较多的图数据存储及多跳查询需求，亟需一种组件来对千亿量级图数据进行管理，海量图数据的高效存储和查询是图数据库研究的核心课题。本文介绍了美团在图数据库选型及平台建设方面的一些工作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651761602&amp;amp;idx=1&amp;amp;sn=b8438d6b521d60d90c6b0639d77c536a&amp;amp;chksm=bd12728f8a65fb99ac84b219ae7ca6912147408b0ad9e22682e1001187ff4e0ec246bb03e308&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;实践之后，我们来谈谈如何做好威胁建模&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;实践之后，我们来谈谈如何做好威胁建模&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; | 在看数540&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUtypR2icKnMokMrENgby83SfLeGobcVreNKCGsntmemKGRwDkkSIqbR9F8nd0Ag7EzrhO60X4uU2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对美团安全团队来说，引入领先的安全技术设计能力，构建全方位、多维度智能防御体系，是我们不懈追求的目标。美团有众多基础设施，核心业务系统也需要以成熟的方法论进行威胁评审。本文将着重分享威胁建模是如何帮助美团安全团队评估、发现大量安全设计的风险，以及互联网企业应该如何大范围地实施威胁建模并完整地进行落地。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;备注：数据统计于2021年12月30日16:00，同时入围两个榜单的文章已经做了去重处理。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写在后面&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;再次邀请大家帮忙填一下美团技术团队公众号的&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://wenjuan.meituan.com/survey/4718823&quot; textvalue=&quot;调研问卷&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;调研问卷&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，欢迎大家留下宝贵的意见或者建议，期待未来我们能共同成长（&lt;/span&gt;&lt;span&gt;我们将评选出5位小伙伴，每人送上一个美团礼品店的精美键盘手托&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5805892547660312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUtypR2icKnMokMrENgby83SYySiblrEuPxAoPsWa0qiaia3ibBUtJoTQ6iaobjqWPiaNcguLt9OAN95scqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2013年12月4日，&lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;美团技术团队博客&lt;/span&gt;&lt;/a&gt;&lt;span&gt;诞生，发表了第1篇文章。8年多的时间，2948天，目前我们已经发布了483篇技术文章，美团技术团队博客/公众号，感谢大家的一路相伴！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，祝大家在2022年，健康平安，「虎」力冲天。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1650abb6796a707f506e2cb5cbe17f98</guid>
<title>[推荐] 面渣逆袭：JVM经典五十问，这下面试稳了！</title>
<link>https://toutiao.io/k/wideaab</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，“&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247488709&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭&lt;/a&gt;“系列继续，这节我们来搞定JVM。说真的，JVM调优什么的一个程序员可能整个职业生涯都碰不到两次，但是，一旦用到的时候，那就是救命了，而且最重要的是——面试必问，所以，还能怎么办？整！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.什么是JVM?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM——Java虚拟机，它是Java实现平台无关性的基石。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT6sCpCRPEkDmXia2Af3mnSXiaDAdXlxP4crT1Ph9RZGg5rVyGzK4d3P4A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java语言编译运行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时JVM也是一个跨语言的平台，和语言无关，只和class的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被JVM运行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTNhiae9Zu0KoxXUE44fxKLMQTNwAdAfn4Ih4o16MUpPEGRdxk1MyXm6A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JVM跨语言&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存管理&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.能说一下JVM的内存区域吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM内存区域最粗略的划分可以分为&lt;code&gt;堆&lt;/code&gt;和&lt;code&gt;栈&lt;/code&gt;，当然，按照虚拟机规范，可以划分为以下几个区域：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTrefbiarN08NsiabzYjseLpa5ib4rlxRWl3icjNQGZ6f6pcAmfZKiaOLTGbw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java虚拟机运行时数据区&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM内存分为线程私有区和线程共享区，其中&lt;code&gt;方法区&lt;/code&gt;和&lt;code&gt;堆&lt;/code&gt;是线程共享区，&lt;code&gt;虚拟机栈&lt;/code&gt;、&lt;code&gt;本地方法栈&lt;/code&gt;和&lt;code&gt;程序计数器&lt;/code&gt;是线程隔离的数据区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、程序计数器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它可以看作是当前线程所执行的字节码的行号指示器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、Java虚拟机栈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTN2lzU3fCTMeSzcuLs9N9CWxN7LGpHZ6B3v0iaAwPAzpickO70BCHiaplw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java虚拟机栈&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、本地方法栈&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、Java堆&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java里“&lt;strong&gt;几乎&lt;/strong&gt;”所有的对象实例都在这里分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现&lt;code&gt;新生代&lt;/code&gt;、&lt;code&gt;老年代&lt;/code&gt;、&lt;code&gt;Eden空间&lt;/code&gt;、&lt;code&gt;From Survivor空间&lt;/code&gt;、&lt;code&gt;To Survivor空间&lt;/code&gt;等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT0V3y5wXvIu5EQdSuAibX23yicpNNFfQ99CTZkhhYRGicvQh0HegfqQpGw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java 堆内存结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.方法区&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它特别在Java虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如jdk1.7之前使用永久代作为方法区的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.说一下JDK1.6、1.7、1.8内存区域的变化？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK1.6、1.7/1.8内存区域发生了变化，主要体现在方法区的实现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTcbdiaps8YA1WTibKewfAIEf82Y0ickAh2wB2iaD6yEVED9Kib8iaqKzS6T8A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.6内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JDK1.7时发生了一些变化，将字符串常量池、静态变量，存放在堆上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTEsicg5FQqMuq51jv3hHfj6y0n3RXibicTZP8dDgQeiaXxflug804zicpuSw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.7内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在JDK1.8时彻底干掉了永久代，而在直接内存中划出一块区域作为&lt;strong&gt;元空间&lt;/strong&gt;，运行时常量池、类常量池都移动到元空间。&lt;/p&gt;&lt;figure&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTLm5dph6wcoQ7LsBzWeWd9LqJNpPIGXOTfwj6oXAYL9pv9GtNsUq0JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JDK 1.8内存区域&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.为什么使用元空间替代永久代作为方法区的实现？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客观上使用永久代来实现方法区的决定的设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主观上当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.对象创建的过程了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中对象的创建，我们从一个new指令开始：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类加载检查通过后，接下来虚拟机将为新生对象分配内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程大概图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTI3SsibF3J171z2nX1QL460maVXOnL3GJTFicsO4y6iaIicFgMic4zsnSJyw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象创建过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.什么是指针碰撞？什么是空闲列表？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存分配有两种方式，&lt;strong&gt;指针碰撞&lt;/strong&gt;（Bump The Pointer）、&lt;strong&gt;空闲列表&lt;/strong&gt;（Free List）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTqkW9BcnpksRB5NcMtyjpwlKviayTmu68j4MflCtpY8oEl7dXsQkOicrw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;指针碰撞和空闲列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空闲列表：如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会，假设JVM虚拟机上，每一次new 对象时，指针就会向右移动一个对象size的距离，一个线程正在给A对象分配内存，指针还没有来的及修改，另一个为B对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种可选方案来解决这个问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT76tQN7aZYXZhgc9v9pDxibzE4FoYWFSSHTZZwAV4PhjZgwmbceYAXAg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;堆抢占和解决方案&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;采用CAS分配重试的方式来保证更新操作的原子性&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个线程在Java堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation&lt;/p&gt;&lt;p&gt;Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.能说一下对象的内存布局吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTY5FSkH1KVsMXcZnjc1ErBkakvpYmCr08wfb4BqEFzKVLqVBhMQQrOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象的存储布局&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对象头&lt;/strong&gt;主要由两部分组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为Mark Word，它是个动态的结构，随着对象状态变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此外，如果对象是一个Java数组，那还应该有一块用于记录数组长度的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实例数据&lt;/strong&gt;用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对齐填充&lt;/strong&gt;不是必须的，没有特别含义，仅仅起着占位符的作用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.对象怎么访问定位？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTXFcy5QuefJhIRibTDBr80RIficQPJN5rk8glVNQ0nRj9XL72ppLZTJiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;通过句柄访问对象&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTYldac8BLjSK1jQblvnPz5XOdwHsbSH0VDYCntop74tav3UQxIDr1nA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;通过直接指针访问对象&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot虚拟机主要使用直接指针来进行对象访问。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.内存溢出和内存泄漏是什么意思？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存溢出就是申请的内存超过了可用内存，内存不够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者关系：内存泄露可能会导致内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人占着茅坑不拉屎，占着茅坑不拉屎的多了可能会导致坑位不够用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTbl6wa1yZSXBJhnQYdo4EmKL91w2U3b3k8uFNV5sY7OHVNnIPricuq2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;内存泄漏、内存溢出&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.能手写内存溢出的例子吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能，重点关注堆和栈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java堆用于储存对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（OutOfMemoryError）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就相当于一个房子里，不断堆积不能被收走的杂物，那么房子很快就会被堆满了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HeapOOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OOMObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;OOMObject&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OOMObject&amp;gt;();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            list.add(&lt;span&gt;new&lt;/span&gt; OOMObject());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK使用的HotSpot虚拟机的栈内存大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生OutOfMemoryError异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * vm参数：-Xss2M&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JavaVMStackOOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;dontStop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;stackLeakByThread&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    dontStop();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            thread.start();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        JavaVMStackOOM oom = &lt;span&gt;new&lt;/span&gt; JavaVMStackOOM();&lt;br/&gt;        oom.stackLeakByThread();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12.内存泄漏可能由哪些原因导致呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏可能的原因有很多种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTj2R64dfqznKMQcFWzASAQNSl9gcuDxbc6icjeMpe6GiaeI9Cbyu3ficqw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;内存泄漏可能原因&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;静态集合类引起内存泄漏&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; List list = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;oomTests&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;br/&gt;   list.add(obj);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单例模式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据连接、IO、Socket等连接&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建的连接不再使用时，需要调用 &lt;strong&gt;close&lt;/strong&gt; 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Connection conn = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;            conn = DriverManager.getConnection(&lt;span&gt;&quot;url&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;            Statement stmt = conn.createStatement();&lt;br/&gt;            ResultSet rs = stmt.executeQuery(&lt;span&gt;&quot;....&quot;&lt;/span&gt;);&lt;br/&gt;          } &lt;span&gt;catch&lt;/span&gt; (Exception e) { &lt;br/&gt;           &lt;br/&gt;          }&lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//不关闭连接&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;变量不合理的作用域&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Simple&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        &lt;span&gt;//...其他代码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放&lt;/span&gt;&lt;br/&gt;        object = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;hash值发生变化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象Hash值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hah值和存储进容器时的Hash值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么String类型被设置成了不可变类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ThreadLocal使用不当&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一定要记得使用remove方法来进行清除。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13.如何判断对象仍然存活？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种方式，**引用计数算法（reference counting）**和可达性分析算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数器的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTZiaq73lOU6kKF1PmDdLnPnIDjFAfffCMTu5vP7BkKDopUiaDGvNx78HA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;引用计数算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTwXhzhPuC1NmAzWXmE5FmZXwcMRz8thEPVc3lKkF74gILtribxRJ0LUg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;14.Java中可作为GC Roots的对象有哪几种？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以作为GC Roots的主要有四种对象：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法区中类静态属性引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法区中常量引用的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地方法栈中JNI引用的对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;15.说一下对象有哪几种引用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;强引用是最传统的&lt;code&gt;引用&lt;/code&gt;的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object obj =&lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        SoftReference reference = &lt;span&gt;new&lt;/span&gt; SoftReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        WeakReference reference = &lt;span&gt;new&lt;/span&gt; WeakReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        Object obj = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        ReferenceQueue queue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt;        PhantomReference reference = &lt;span&gt;new&lt;/span&gt; PhantomReference(obj, queue);&lt;br/&gt;        &lt;span&gt;//强引用对象滞空，保留软引用&lt;/span&gt;&lt;br/&gt;        obj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTzEruV6Mu4mKfWqZdAyicj71dyWhU4j6Kedwic2W4nwmaAj8EzoVFcDGw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;四种引用总结&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;16.finalize()方法了解吗？有什么作用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个不太贴切的比喻，垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT76PAiaQLAV8hQpg8Ezg36uVItzNkqzX5jP66L2zl21Km74Uqcicw5DFg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;刀下留人&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果对象在在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;17.Java堆的内存分区了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照垃圾收集，将Java堆划分为**新生代 （Young Generation）&lt;strong&gt;和&lt;/strong&gt;老年代（Old Generation）**两个区域，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而新生代又可以分为三个区域，eden、from、to，比例是8：1：1，而新生代的内存分区同样是从垃圾收集的角度来分配的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTILmlIV9ECMWEVibImt63ebRsXqP6exzE0lNLQ8eJAV2cXicnk8jwLs0A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Java堆内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;18.垃圾收集算法了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集算法主要有三种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-清除算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见名知义，&lt;code&gt;标记-清除&lt;/code&gt;（Mark-Sweep）算法分为两个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记&lt;/strong&gt; : 标记出所有需要回收的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;清除&lt;/strong&gt;：回收所有被标记的对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT03GOXRmjSQLq8Kp9AvtUFahuwI6ibIv4KzXt9whicxqDf2AJ0BRe3MiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-清除算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除算法比较基础，但是主要存在两个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-复制算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTu9U2nWFMGA4rWRXW0qHGPiaNYzMicoMSibP848Sxwg3rLFfcrsh9VvTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-复制算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标记-整理算法&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低内存的消耗，引入一种针对性的算法：&lt;code&gt;标记-整理&lt;/code&gt;（Mark-Compact）算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTx2Iafn9HyDvr0UXP6fq41xVPvnAYQd0eJ7eP53XDEWR8j7F1FjZEag/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;标记-整理算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要Stop The World才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;19.说一下新生代的区域划分？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这种算法，虚拟机将内存分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。默认Eden和Survivor的大小比例是8∶1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT4YHlwFclfhibRsibkPxqrp2eHSXY71WBAytV0CjrjdyoruE7s9rQeDRg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;新生代内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;20.Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;部分收集&lt;/strong&gt;（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前&lt;strong&gt;只有&lt;/strong&gt;CMS收集器会有单独收集老年代的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;整堆收集&lt;/strong&gt;（Full GC）：收集整个Java堆和方法区的垃圾收集。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;21.Minor GC/Young GC什么时候触发？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新创建的对象优先在新生代Eden区进行分配，如果Eden区没有足够的空间时，就会触发Young GC来清理新生代。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;22.什么时候会触发Full GC？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个触发条件稍微有点多，往下看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTia2jz8FrptJQ3N8DQRmYTzogpLO2jiaVZV0ZPyTZdomnoolVWPaKvTOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Full GC触发条件&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Young GC之前检查老年代&lt;/strong&gt;：在要进行 Young GC 的时候，发现&lt;code&gt;老年代可用的连续内存空间&lt;/code&gt; &amp;lt; &lt;code&gt;新生代历次Young GC后升入老年代的对象总和的平均大小&lt;/code&gt;，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Young GC之后老年代空间不足&lt;/strong&gt;：执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Full GC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;老年代空间不足&lt;/strong&gt;，老年代内存使用率过高，达到一定比例，也会触发Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;空间分配担保失败&lt;/strong&gt;（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;方法区内存空间不足&lt;/strong&gt;：如果方法区由永久代实现，永久代空间不足 Full GC。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;System.gc()等命令触发&lt;/strong&gt;：System.gc()、jmap -dump 等命令会触发 full gc。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;23.对象什么时候会进入老年代？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTkR19bP4X5X1dqDVckbYcB8M68a3Aq4swUxickib8HBJKe3yYribgZNhHw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对象进入老年代&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;长期存活的对象将进入老年代&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次YoungGC之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到15(默认)之后,这个对象将会被移入老年代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这个参数设置这个年龄值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;- XX:MaxTenuringThreshold&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大对象直接进入老年代&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot虚拟机提供了这个参数来设置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX：PretenureSizeThreshold&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动态对象年龄判定&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;空间分配担保&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如在Young GC之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;24.知道有哪些垃圾收集器吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要垃圾收集器如下，图中标出了它们的工作区域、垃圾收集算法，以及配合关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTH8Vib0FiayIHPwScYicjhJ4ibEiceMnOz4LXHMKRiaxbETf2p1xVEcCn9N4g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HotSpot虚拟机垃圾收集器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些收集器里，面试的重点是两个——&lt;strong&gt;CMS&lt;/strong&gt;和&lt;strong&gt;G1&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial收集器是最基础、历史最悠久的收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial/Serial Old收集器的运行过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTrsAicwCPx0558QjDzvLYiagicoSdLdSdD6GXa6JKeV8R3AaPYPEnO3GoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Serial/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew收集器实质上是Serial收集器的多线程并行版本，使用多条线程进行垃圾收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew/Serial Old收集器运行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTx2taFoj9KkJk0gJOg0yn4kH3fADYzPuDqea5wKNIcgouf3I2QyYI4A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ParNew/Serial Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和ParNew有些类似，但Parallel Scavenge主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是CPU用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT8eb1TJQZFLyvX1ZRYeiaG6tIzNicd9XOcxQLHRnKWzCUkr285AZhfaxg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;吞吐量&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTW7Fiab6ToYoS76g2YAulthtYZiafxct4L7eGQwlDgCFGdSLACZa1zWWA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Parallel Scavenge/Parallel Old收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用标记-清除算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为&lt;code&gt;Stop The World&lt;/code&gt;。也简称为STW。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HotSpot中，有个数据结构（映射表）称为&lt;code&gt;OopMap&lt;/code&gt;。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在&lt;code&gt;特定的位置&lt;/code&gt;生成 OopMap，记录下栈上和寄存器里哪些位置是引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些特定的位置主要在：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.循环的末尾（非 counted 循环）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.方法临返回前 / 调用方法的call指令后&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.可能抛异常的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些位置就叫作&lt;strong&gt;安全点(safepoint)。&lt;/strong&gt; 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT8LZHjoVgNeiaVMsLeicGn7aHEyazxGy9GSVOPnEEwrjSuzkcalu8ARxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;老王拉车只能在平路休息&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;26.能详细说一下CMS收集器的垃圾收集过程吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS收集齐的垃圾收集分为四步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（CMS initial mark）：单线程运行，需要Stop The World，标记GC Roots能直达的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（（CMS concurrent mark）：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重新标记&lt;/strong&gt;（CMS remark）：多线程运行，需要Stop The World，标记并发标记阶段产生对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发清除&lt;/strong&gt;（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Concurrent Mark Sweep收集器运行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT2sTricwq5keYkNCoEW12KA7IeUNQq1Q4kXj8wqELUiac71VB00iaorgUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Concurrent Mark Sweep收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;27.G1垃圾收集器了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT6FqGp13gGUHUpD94omUYNSba7EF1E2C95F3bduicH6lYiasfaQhLZXibg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;G1 Heap Regions&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的“价值，优先收集价值高的Region。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1收集器的运行过程大致可划分为以下四个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最终标记&lt;/strong&gt;（Remark），STW，标记再并发标记过程中产生的垃圾。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;筛选回收&lt;/strong&gt;（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTnibUuMAwtqgTqNuGu7fHUK4XSLXCzR1G0WakjBicOcBjS1LgyZpS55Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;G1收集器运行示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;28.有了CMS，为什么还要引入G1？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：CMS最主要的优点在名字上已经体现出来——并发收集、低停顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：CMS同样有三个明显的缺点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Mark Sweep算法会导致内存碎片比较多&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1主要解决了内存碎片过多的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;29.你们线上用的什么垃圾收集器？为什么要用它？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么说呢，虽然调优说的震天响，但是我们一般都是用默认。管你Java怎么升，我用8，那么JDK1.8默认用的是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -XX:+PrintCommandLineFlags -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到有这么一行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-XX:+UseParallelGC&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;UseParallelGC&lt;/code&gt; = &lt;code&gt;Parallel Scavenge + Parallel Old&lt;/code&gt;，表示的是新生代用的&lt;code&gt;Parallel Scavenge&lt;/code&gt;收集器，老年代用的是&lt;code&gt;Parallel Old&lt;/code&gt; 收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么要用这个呢？默认的呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然面试肯定不能这么答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge的特点是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用&lt;code&gt;Parallel Scavenge + Parallel Old&lt;/code&gt;的组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个默认虽然也有说法，但不太讨喜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以说：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用&lt;code&gt;Parallel New&lt;/code&gt;+&lt;code&gt;CMS&lt;/code&gt;的组合，我们比较关注服务的响应速度，所以采用了CMS来降低停顿时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者一步到位：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们线上采用了设计比较优秀的G1垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了CMS的浮动垃圾问题、内存碎片问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;30.垃圾收集器应该如何选择？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用JDK的发行商是什么？等等……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单地列一下上面提到的一些收集器的适用场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Serial ：如果应用程序有一个很小的内存空间（大约100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受1秒或更长的停顿时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CMS/G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约1秒以内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZGC：如果响应时间是高优先级的，或者堆空间比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;31.对象一定分配在堆中吗？有没有了解逃逸分析技术？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对象一定分配在堆中吗？&lt;/strong&gt; 不一定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着JIT编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是逃逸分析？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逃逸分析&lt;/strong&gt;是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗点讲，当一个对象被new出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTynkkcDXF9sKPjYEbYzMD8SaIW4j1iawsVqy4xy2ukHuaItaPwUXNnfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;逃逸&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTTOX3vvAdwcByN7iaxpH1MiakOAnH9KgvR4sOgRH962y6tatVXFMKqFzg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;逃逸强度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逃逸分析的好处&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个Java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM调优&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32.有哪些常用的命令行性能监控和故障处理工具？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;操作系统工具&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;top：显示系统整体资源使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vmstat：监控内存和CPU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iostat：监控IO使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;netstat：监控网络使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK性能监控工具&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jps：虚拟机进程查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstat：虚拟机运行时信息查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jinfo：虚拟机配置查看&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jmap：内存映像（导出）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jhat：堆转储快照分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstack：Java堆栈跟踪&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jcmd：实现上面除了jstat外所有命令的功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;33.了解哪些可视化的性能监控和故障处理工具？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一些JDK自带的可视化性能监控和故障处理工具：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTibBKNxlQnYeOVuUaBEsuIJ3kXTqCkFKQ7vvtC7ibiab8Q2ryYiaMl6ibhlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JConsole概览&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTd5Ks3dLxgcznsRWvAUjGYrnYibsTpIlnE1APYGg7EDFO6jm2lxnb5bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;VisualVM安装插件&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTic6Bc6zaxFx6kEHCXhDWibd6vY5bb8iagBlmOrqpDia6ELCp1MiauNsRPAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JMC主要界面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有一些第三方的工具：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 堆内存分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GC 日志分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GC&lt;/code&gt; 日志分析工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商用的性能分析利器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里开源诊断工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 应用性能分析工具，开源、火焰图、跨平台。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;34.JVM的常见参数配置知道哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些常见的参数配置：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;堆配置：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms:初始堆大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xms：最大堆大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewSize=n:设置年轻代大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewRatio=n:设置年轻代和年老代的比值。如：为3表示年轻代和年老代比值为1：3，年轻代占整个年轻代年老代和的1/4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden：3 Survivor：2，一个Survivor区占整个年轻代的1/5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxPermSize=n:设置持久代大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;收集器设置：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+UseSerialGC:设置串行收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelGC:设置并行收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParalledlOldGC:设置并行年老代收集器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseConcMarkSweepGC:设置并发收集器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并行收集器设置&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxGCPauseMillis=n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:ParallelGCThreads=n:设置并发收集器年轻代手机方式为并行收集时，使用的CPU数。并行收集线程数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印GC回收的过程日志信息&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCDetails&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCTimeStamps&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xloggc:filename&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;35.有做过JVM调优吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM调优是一件很严肃的事情，不是拍脑门就开始调优的，需要有严密的分析和监控机制，大概的一个JVM调优流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoT4jicGxb8ENuyvB7pwKLWylruUQbqR0xAgFyNNMHPWXRwickIMefjlWgA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;JVM调优大致流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，JVM调优是不得已而为之，有那功夫，好好把烂代码重构一下不比瞎调JVM强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，面试官非要问怎么办？可以从处理问题的角度来回答（对应图中事后），这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发OOM异常，堆内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从4G调整到8G   -Xms8g。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、用JProfiler 对  堆dump文件进行分析，通过JProfiler查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，&lt;code&gt;导出订单信息&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是做了两个处理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端代码加分布式锁，做防重处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;36.线上服务CPU占用过高怎么排查？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题分析：CPU高一定是某个程序长期占用了CPU资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTiaAoib9d8fhbGUaPsOZ121D3fLC7EUY0HtO8b5JY1g2Su7LhahcQaWzw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CPU飙高&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、所以先需要找出那个进程占用CPU高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、然后根据找到对应进行里哪个线程占用CPU高。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;top -Hp 进程ID   列出对应进程里面的线程占用资源情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、找到对应线程ID后，再打印出对应线程的堆栈信息&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;printf &quot;%x\n&quot;  PID    把线程ID转换为16进制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看是否有线程长时间的watting 或blocked，如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;37.内存飙高问题怎么排查？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、先观察垃圾回收的情况&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jmap -histo PID | head -20   查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、导出堆内存文件快照&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jmap -dump:live,format=b,file=/home/myheapdump.hprof PID  dump堆内存信息到文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;38.频繁 minor gc 怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化Minor GC频繁问题：通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor  GC，因此可以通过增大新生代空间&lt;code&gt;-Xmn&lt;/code&gt;来降低Minor GC的频率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;39.频繁Full GC怎么办？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Full GC的排查思路大概如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;清楚从程序角度，有哪些原因导致FGC？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;大对象&lt;/strong&gt;：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序频繁生成一些&lt;strong&gt;长生命周期的对象&lt;/strong&gt;，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;程序BUG&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码中&lt;strong&gt;显式调用了gc&lt;/strong&gt;方法，包括自己的代码甚至框架中的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;清楚排查问题时能使用哪些工具&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK的自带工具，包括jmap、jstat等常用命令：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看堆内存各区域的使用率以及GC情况&lt;/span&gt;&lt;br/&gt;jstat -gcutil -h20 pid 1000&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看堆内存中的存活对象，并按空间排序&lt;/span&gt;&lt;br/&gt;jmap -histo pid | head -n20&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; dump堆内存文件&lt;/span&gt;&lt;br/&gt;jmap -dump:format=b,file=heap pid&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可视化的堆内存分析工具：JVisualVM、MAT等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;排查指南&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解该时间点之前有没有程序上线、基础组件升级等情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;40.有没有处理过内存泄漏问题？是如何定位的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏是内在病源，外在病症表现可能有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用程序长时间连续运行时性能严重下降&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 使用率飙升，甚至到 100%&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;频繁 Full GC，各种报警，例如接口超时报警等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序偶尔会耗尽连接对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;严重&lt;strong&gt;内存泄漏&lt;/strong&gt;往往伴随频繁的 &lt;strong&gt;Full GC&lt;/strong&gt;，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;jps&lt;/code&gt; 查看运行的 Java 进程 ID&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用&lt;code&gt;top -p [pid]&lt;/code&gt; 查看进程使用 CPU 和 MEM 的情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;top -Hp [pid]&lt;/code&gt; 查看进程下的所有线程占 CPU 和 MEM 的情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将线程 ID 转换为 16 进制：&lt;code&gt;printf &quot;%x\n&quot; [pid]&lt;/code&gt;，输出的值就是线程栈信息中的 &lt;strong&gt;nid&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;例如：&lt;code&gt;printf &quot;%x\n&quot; 29471&lt;/code&gt;，换行输出 &lt;strong&gt;731f&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抓取线程栈：&lt;code&gt;jstack 29452 &amp;gt; 29452.txt&lt;/code&gt;，可以多抓几次做个对比。&lt;/p&gt;&lt;p&gt;在线程栈信息中找到对应线程号的 16 进制值，如下是 &lt;strong&gt;731f&lt;/strong&gt; 线程的信息。线程栈分析可使用 Visualvm 插件 &lt;strong&gt;TDA&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&quot;Service Thread&quot;&lt;/span&gt; #&lt;span&gt;7&lt;/span&gt; daemon prio=&lt;span&gt;9&lt;/span&gt; os_prio=&lt;span&gt;0&lt;/span&gt; tid=&lt;span&gt;0x00007fbe2c164000&lt;/span&gt; nid=&lt;span&gt;0x731f&lt;/span&gt; runnable [&lt;span&gt;0x0000000000000000&lt;/span&gt;]&lt;br/&gt;   java.lang.Thread.State: RUNNABLE&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用&lt;code&gt;jstat -gcutil [pid] 5000 10&lt;/code&gt; 每隔 5 秒输出 GC 信息，输出 10 次，查看 &lt;strong&gt;YGC&lt;/strong&gt; 和 &lt;strong&gt;Full GC&lt;/strong&gt; 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。&lt;/p&gt;&lt;p&gt;或使用 &lt;code&gt;jstat -gccause [pid] 5000&lt;/code&gt; ，同样是输出 GC 摘要信息。&lt;/p&gt;&lt;p&gt;或使用 &lt;code&gt;jmap -heap [pid]&lt;/code&gt; 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果发现 &lt;code&gt;Full GC&lt;/code&gt; 次数太多，就很大概率存在内存泄漏了&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 &lt;code&gt;jmap -histo:live [pid]&lt;/code&gt; 输出每个类的对象数量，内存大小(字节单位)及全限定类名。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;生成 &lt;code&gt;dump&lt;/code&gt; 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了&lt;/p&gt;&lt;p&gt;使用 jmap 生成 dump 文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# jmap -dump:live,format=b,file=&lt;span&gt;29471&lt;/span&gt;.dump &lt;span&gt;29471&lt;/span&gt;&lt;br/&gt;Dumping heap to /root/dump ...&lt;br/&gt;Heap dump file created&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 &lt;strong&gt;jhat&lt;/strong&gt; 命令分析：&lt;code&gt;jhat -port 8000 29471.dump&lt;/code&gt;，浏览器访问 jhat 服务，端口是 8000。&lt;/p&gt;&lt;p&gt;通常使用图形化工具分析，如 JDK 自带的 &lt;strong&gt;jvisualvm&lt;/strong&gt;，从菜单 &amp;gt; 文件 &amp;gt; 装入 dump 文件。&lt;/p&gt;&lt;p&gt;或使用第三方式具分析的，如 &lt;strong&gt;JProfiler&lt;/strong&gt; 也是个图形化工具，&lt;strong&gt;GCViewer&lt;/strong&gt; 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 &lt;strong&gt;GCEasy&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;注意：如果 dump 文件较大的话，分析会占比较大的内存。&lt;/p&gt;&lt;p&gt;基本上就可以定位到代码层的逻辑了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol start=&quot;11&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 dump 文析结果中查找存在大量的对象，再查对其的引用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dump 文件分析&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;41.有没有处理过内存溢出问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排查过程和排查内存泄漏过程类似。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虚拟机执行&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;42.能说一下类的生命周期吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTQ4kgKmAgYMV4GYJSLgiaOZeyLX7ibpRenh6ebqiaQkiaBHaOx2kVFRBS4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;类的生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;43.类加载的过程知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载是JVM加载的起点，具体什么时候开始加载，《Java虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在加载过程，JVM要做三件事情：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTpWvLTEpdH0icvwhcCqmUm78AOAdXWA9o8ZELScYBU5Yh2XZ7wgVx1Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;加载&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1）通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;44.类加载器有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有四种类加载器:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;启动类加载器&lt;/strong&gt;(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;扩展类加载器&lt;/strong&gt;(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;系统类加载器&lt;/strong&gt;（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;用户自定义类加载器&lt;/strong&gt; (user class loader)，用户通过继承 java.lang.ClassLoader类的方式自行实现的类加载器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;45.什么是双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTtcyiaOeuLwFYlzwvuNujp8nkcg12lY7C631yKNy9I3HibB3HsKpoeQkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双亲委派模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;46.为什么要用双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是为了保证应用程序的稳定有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如类java.lang.Object，它存放在rt.jar之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证Object的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;47.如何破坏双亲委派机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想打破双亲委派模型，就重写ClassLoader类中的fifindClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;48.历史上有哪几次双亲委派机制的破坏？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派机制在历史上主要有三次破坏：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTOicIJL9OMa5am46V4EpXLL2qoWSDyTeMOeJpgSxI4FBkNBb8SaPmqQw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;双亲委派模型的三次破坏&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第一次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类  java.lang.ClassLoader则在Java的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的  protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第二次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们比较熟悉的JDBC:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各个厂商各有不同的JDBC的实现，Java在核心包&lt;code&gt;\lib&lt;/code&gt;里定义了对应的SPI，那么这个就毫无疑问由&lt;code&gt;启动类加载器&lt;/code&gt;加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是各个厂商的实现，是没办法放在核心包里的，只能放在&lt;code&gt;classpath&lt;/code&gt;里，只能被&lt;code&gt;应用类加载器&lt;/code&gt;加载。那么，问题来了，启动类加载器它就加载不到厂商提供的SPI服务代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;第三次破坏&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;49.你觉得应该怎么实现一个热部署功能？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道了Java类的加载过程。一个Java类文件到虚拟机里的对象，要经过如下过程:首先通过Java编译器，将Java文件编译成class字节码，类加载器读取class字节码，再将类转化为实例，对实例newInstance就可以生成对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器ClassLoader功能，也就是将class字节码转换到类的实例。在Java应用中，所有的实例都是由类加载器，加载而来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的java类（如com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候问题就来了，如果我们希望将java类卸载，并且替换更新版本的java类，该怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然在类加载器中，Java类只能被加载一次，并且无法卸载。那么我们是不是可以直接把Java类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写ClassLoader的findClass方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要实现热部署可以分以下三个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;销毁原来的自定义ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新class类文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建新的ClassLoader去加载更新后的class类文件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此，一个热部署的功能就这样实现了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;50.Tomcat的类加载机制了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat是主流的Java Web服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat类加载器如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdXVfRtic6m8yMAjqOeKnPoTMGYrkqKcRpLsXsiaicqrvSRhr9XaibAvk2beJwFCCcWjtcjoeueUSrQeg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Tomcat类加载器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomcat实际上也是破坏了双亲委派模型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Tomact是web容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Tomcat破坏了&lt;strong&gt;双亲委派原则&lt;/strong&gt;，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。每一个WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交CommonClassLoader加载，这和双亲委派刚好相反。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;好了，本期的50道JVM面试题就分享到这了，下期继续分享Java并发相关面试题，&lt;big&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/big&gt;、&lt;big&gt;&lt;strong&gt;关注&lt;/strong&gt;&lt;/big&gt;  不迷路，咱们下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dfe5304959ee4108032de2d773ec31a1</guid>
<title>[推荐] 聊聊spring事务失效的12种场景，太坑了</title>
<link>https://toutiao.io/k/uf6yk96</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(0, 0, 0)&quot; data-style=&quot;outline: 0px; letter-spacing: 0.544px; text-align: left; white-space: normal; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255);&quot; class=&quot;js_darkmode__2&quot;&gt;点击关注公众号，Java干货&lt;/strong&gt;&lt;span data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot; data-style=&quot;outline: 0px; letter-spacing: 0.544px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(255, 76, 65);&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;strong data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot;&gt;及时送达👇&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4MDUyMDQyNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/knmrNHnmCLEX3M6DvCn5gKuBOaMMVu9lUJAvwH2k66nV9VgGG0cyczd1ryib06P1z5pF72Le3HUr5loicnQx36lg/0?wx_fmt=png&quot; data-nickname=&quot;小哈学Java&quot; data-alias=&quot;xiaoha_java&quot; data-signature=&quot;专注于Java领域干货分享，不限于BAT面试, 算法，数据库，Spring Boot, 微服务,高并发, JVM, Docker容器，ELK相关知识，期待与您一同进步。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5645161290322581&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLHoM2ib2hgLaZr0ruTQZDRYZlAFxVibcicZ18G3Llxx1ibOBNRVRWeex0qMOndOBUfLgh1K72Nm1G31zg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;496&quot;/&gt;&lt;span data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot; data-style=&quot;outline: 0px; letter-spacing: 0.544px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(255, 76, 65);&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;strong data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些业务场景下，如果一个请求中，需要同时&lt;span&gt;写入&lt;/span&gt;多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实，spring事务用起来贼爽，就用一个简单的注解：&lt;code&gt;@Transactional&lt;/code&gt;，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你使用不当，它也会坑你于无形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9913419913419913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDFI5ibhP1TXOMnqQtJhfb3XCnTbgmpiab2LDA8VVCmg2jMUoeJd70gAJsj7vL2IB0icYxsbsvnKIu9LQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1386&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一 事务不生效&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.访问权限问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         saveData(userModel);&lt;br/&gt;         updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法的访问权限被定义成了&lt;code&gt;private&lt;/code&gt;，这样会导致事务失效，spring要求被代理方法必须是&lt;code&gt;public&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，在&lt;code&gt;AbstractFallbackTransactionAttributeSource&lt;/code&gt;类的&lt;code&gt;computeTransactionAttribute&lt;/code&gt;方法中有个判断，如果目标方法不是public，则&lt;code&gt;TransactionAttribute&lt;/code&gt;返回null，即不支持事务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; TransactionAttribute &lt;span&gt;computeTransactionAttribute&lt;/span&gt;&lt;span&gt;(Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Don&#x27;t allow no-public methods as required.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// The method may be on an interface, but we need attributes from the target class.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// If the target class is null, the method will be unchanged.&lt;/span&gt;&lt;br/&gt;    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// First try is the method in the target class.&lt;/span&gt;&lt;br/&gt;    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Second try is the transaction attribute on the target class.&lt;/span&gt;&lt;br/&gt;    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (specificMethod != method) {&lt;br/&gt;      &lt;span&gt;// Fallback is to look at the original method.&lt;/span&gt;&lt;br/&gt;      txAttr = findTransactionAttribute(method);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// Last fallback is the class of the original method.&lt;/span&gt;&lt;br/&gt;      txAttr = findTransactionAttribute(method.getDeclaringClass());&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是&lt;code&gt;public&lt;/code&gt;，而是private、default或protected的话，spring则不会提供事务功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 方法用final修饰&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        saveData(userModel);&lt;br/&gt;        updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法被定义成了&lt;code&gt;final&lt;/code&gt;的，这样会导致事务失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.方法内部调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;  &lt;span/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        updateStatus(userModel);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateStatus&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        doSameThing();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，在同一个类中的方法直接内部调用，会导致事务失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 新加一个Service方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   prvate ServiceB serviceB;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         serviceB.doSave(user);&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 在该Service类中注入自己&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   prvate ServiceA serviceA;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         serviceA.doSave(user);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：不会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 通过AopContent类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该Service类中使用AopContext.currentProxy()获取代理对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         ((ServiceA)AopContext.currentProxy()).doSave(user);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.未被spring管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一天，你匆匆忙忙的开发了一个Service类，但忘了加@Service注解，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         saveData(userModel);&lt;br/&gt;         updateData(userModel);&lt;br/&gt;    }    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子，我们可以看到UserService类没有加&lt;code&gt;@Service&lt;/code&gt;注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.多线程调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Map&amp;lt;Object, Object&amp;gt;&amp;gt; resources =&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.表不支持事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周所周知，在mysql5之前，默认的数据库引擎是&lt;code&gt;myisam&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些老项目中，可能还在用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建表的时候，只需要把&lt;code&gt;ENGINE&lt;/code&gt;参数设置成&lt;code&gt;MyISAM&lt;/code&gt;即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE `category` (&lt;br/&gt;  `id` bigint NOT NULL AUTO_INCREMENT,&lt;br/&gt;  `one_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `two_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `three_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `four_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  &lt;span&gt;PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;(`id`)&lt;/span&gt;&lt;br/&gt;) ENGINE&lt;/span&gt;=MyISAM AUTO_INCREMENT=&lt;span&gt;4&lt;/span&gt; DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;myisam好用，但有个很致命的问题是：&lt;code&gt;不支持事务&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，myisam还不支持行锁和外键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.未开启事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，事务没有生效的根本原因是没有开启事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看到这句话可能会觉得好笑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启事务不是一个项目中，最最最基本的功能吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么还会没有开启事务？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，如果项目已经搭建好了，事务功能肯定是有的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然原因有很多，但没有开启事务，这个原因极其容易被忽略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用的是springboot项目，那么你很幸运。因为springboot通过&lt;code&gt;DataSourceTransactionManagerAutoConfiguration&lt;/code&gt;类，已经默默的帮你开启了事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你所要做的事情很简单，只需要配置&lt;code&gt;spring.datasource&lt;/code&gt;相关参数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体配置如下信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;br/&gt;&amp;lt;!-- 配置事务管理器 --&amp;gt; &lt;br/&gt;&amp;lt;bean &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt; id=&lt;span&gt;&quot;transactionManager&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;dataSource&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;dataSource&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt; &lt;br/&gt;&amp;lt;/bean&amp;gt; &lt;br/&gt;&amp;lt;tx:advice id=&lt;span&gt;&quot;advice&quot;&lt;/span&gt; transaction-manager=&lt;span&gt;&quot;transactionManager&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;    &amp;lt;tx:attributes&amp;gt; &lt;br/&gt;        &amp;lt;tx:method name=&lt;span&gt;&quot;*&quot;&lt;/span&gt; propagation=&lt;span&gt;&quot;REQUIRED&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;    &amp;lt;/tx:attributes&amp;gt; &lt;br/&gt;&amp;lt;/tx:advice&amp;gt; &lt;br/&gt;&amp;lt;!-- 用切点把事务切进去 --&amp;gt; &lt;br/&gt;&amp;lt;aop:config&amp;gt; &lt;br/&gt;    &amp;lt;aop:pointcut expression=&lt;span&gt;&quot;execution(* com.susan.*.*(..))&quot;&lt;/span&gt; id=&lt;span&gt;&quot;pointcut&quot;&lt;/span&gt;/&amp;gt; &lt;br/&gt;    &amp;lt;aop:advisor advice-ref=&lt;span&gt;&quot;advice&quot;&lt;/span&gt; pointcut-ref=&lt;span&gt;&quot;pointcut&quot;&lt;/span&gt;/&amp;gt; &lt;br/&gt;&amp;lt;/aop:config&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二 事务不回滚&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.错误的传播特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们在使用&lt;code&gt;@Transactional&lt;/code&gt;注解时，是可以指定&lt;code&gt;propagation&lt;/code&gt;参数的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REQUIRED&lt;/code&gt; 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SUPPORTS&lt;/code&gt; 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MANDATORY&lt;/code&gt; 如果当前上下文中存在事务，否则抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REQUIRES_NEW&lt;/code&gt; 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NOT_SUPPORTED&lt;/code&gt; 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NEVER&lt;/code&gt; 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NESTED&lt;/code&gt; 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NEVER)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        saveData(userModel);&lt;br/&gt;        updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.自己吞了异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务不会回滚，最常见的问题是：开发者在代码中手动try...catch了异常。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            saveData(userModel);&lt;br/&gt;            updateData(userModel);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.手动抛了别的异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;             saveData(userModel);&lt;br/&gt;             updateData(userModel);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为spring事务，默认情况下只会回滚&lt;code&gt;RuntimeException&lt;/code&gt;（运行时异常）和&lt;code&gt;Error&lt;/code&gt;（错误），对于普通的Exception（非运行时异常），它不会回滚。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.自定义了回滚异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置&lt;code&gt;rollbackFor&lt;/code&gt;参数，来完成这个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = BusinessException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;UserModel&lt;/span&gt; &lt;span&gt;userModel&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       saveData(userModel);&lt;br/&gt;       updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.嵌套事务回滚多了&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        roleService.doOtherThing();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NESTED)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;why?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么样才能只回滚保存点呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将内部嵌套事务放在try/catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三 其他&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1 大事务问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们会在方法上&lt;code&gt;@Transactional&lt;/code&gt;注解，填加事务功能，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;       query1();&lt;br/&gt;       query2();&lt;br/&gt;       query3();&lt;br/&gt;       roleService.save(userModel);&lt;br/&gt;       update(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;       query4();&lt;br/&gt;       query5();&lt;br/&gt;       query6();&lt;br/&gt;       saveData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但&lt;code&gt;@Transactional&lt;/code&gt;注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这个例子中，在UserService类中，其实只有这两行才需要事务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;roleService.save(userModel);&lt;br/&gt;update(userModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RoleService类中，只有这一行需要事务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;saveData(userModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEBCPPbyDJ73OtgGneSbqS4EPv3uEv9HEcX4hevWFJGDG8gPspHNL0abAiaEvxZoGZbBIkTbBQGfHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.编程式事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面聊的这些内容都是基于&lt;code&gt;@Transactional&lt;/code&gt;注解的，主要说的是它的事务问题，我们把这种事务叫做：&lt;code&gt;声明式事务&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，&lt;span&gt;我们把这种事务叫做&lt;/span&gt;：&lt;code&gt;编程式事务&lt;/code&gt;。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; TransactionTemplate transactionTemplate;&lt;br/&gt;   &lt;br/&gt;   ...&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         transactionTemplate.execute((status) =&amp;gt; {&lt;br/&gt;            addData1();&lt;br/&gt;            updateData2();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;         })&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较于&lt;code&gt;@Transactional&lt;/code&gt;注解声明式事务，我更建议大家使用，基于&lt;code&gt;TransactionTemplate&lt;/code&gt;的编程式事务。主要原因如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免由于spring aop问题，导致事务失效的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够更小粒度的控制事务的范围，更直观。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c23d048cdaa3a668d501f399e25bacf1</guid>
<title>[推荐] 再见了 VMware，一款更轻量级的虚拟机！</title>
<link>https://toutiao.io/k/xw2lnva</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;section class=&quot;js_darkmode__1&quot;&gt;&lt;span&gt;公众号关注&lt;/span&gt;&lt;span&gt; “GitHubDaily”&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;设为 “&lt;/span&gt;&lt;span&gt;星标&lt;/span&gt;&lt;span&gt;”，每天带你逛 GitHub！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8C07b1Ih2doNmiaicSttMccejE1onYNcszau24r6lIzHr6Fib3XlicibHcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大家好，我是小 G。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，打算在 &lt;/span&gt;&lt;strong&gt;Mac&lt;/strong&gt;&lt;span&gt; 电脑上安装一个虚拟机，用来学习 &lt;/span&gt;&lt;strong&gt;K8S&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先想到的是 &lt;strong&gt;Vmware&lt;/strong&gt; 和 &lt;strong&gt;Parallels Desktop&lt;/strong&gt;，然后打开浏览器找了找，发现都只提供付费版本，只有 &lt;strong&gt;Parallels Desktop&lt;/strong&gt; 提供了 &lt;strong&gt;14&lt;/strong&gt; 天的免费试用。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsCKOCmkQFvjvr9uqCL45fUVicA4uFf5iaNiaicY6kcTXK9rxfOWicwicWwh4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;无法白嫖&quot;/&gt;&lt;figcaption&gt;无法白嫖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然后，开始尝试使用免费 &lt;strong&gt;VirtualBox&lt;/strong&gt;，但是在安装 &lt;strong&gt;CentOS&lt;/strong&gt; 的时候，貌似因为 &lt;strong&gt;MacOS&lt;/strong&gt; 最新版本的原因，总是报错，花费了好几天的时间，试过各种方案，最终解决无果，就放弃了。。&lt;/p&gt;&lt;p&gt;就在陌溪要放弃的时候，突然在 &lt;strong&gt;Ubuntu&lt;/strong&gt; 官网进行冲浪的时候，发现了一款叫 &lt;strong&gt;Multipass&lt;/strong&gt; 的东西。&lt;/p&gt;&lt;p&gt;它可以快速在电脑上快速搭建一个轻量级的虚拟机，并且相比于 &lt;strong&gt;Vmware&lt;/strong&gt; 更加轻量，只需一行命令快速创建 &lt;strong&gt;Ubuntu&lt;/strong&gt; 虚拟机。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Multipass&lt;/strong&gt; 是一个轻量虚拟机管理器，是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 运营公司 &lt;strong&gt;Canonical&lt;/strong&gt; 所推出的开源项目。运行环境支持 &lt;strong&gt;Linux&lt;/strong&gt;、&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt;。在不同的操作系统上，使用的是不同的虚拟化技术。在 &lt;strong&gt;Linux&lt;/strong&gt; 上使用的是 &lt;strong&gt;KVM&lt;/strong&gt;、&lt;strong&gt;Window&lt;/strong&gt; 上使用 &lt;strong&gt;Hyper-V&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt; 中使用 &lt;strong&gt;HyperKit&lt;/strong&gt; 以最小开销运行VM，支持在笔记本模拟小型云。&lt;/p&gt;&lt;p&gt;同时，&lt;strong&gt;Multipass&lt;/strong&gt; 提供了一个命令行界面来启动和管理 &lt;strong&gt;Linux&lt;/strong&gt; 实例。下载一个全新的镜像需要几秒钟的时间，并且在几分钟内就可以启动并运行 &lt;strong&gt;VM&lt;/strong&gt;。（直呼好家伙，大大降低的我们安装虚拟机的成本了）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Multipass官网：https://multipass.run/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5435185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsQ45NQiaofsON9YRJTedbwFRuqjGRIxDJ3icaxa7jicJRXoxrI4iapRSyGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;Multipass官网&quot;/&gt;&lt;figcaption&gt;Multipass官网&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;开始使用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在使用 &lt;strong&gt;Multipass&lt;/strong&gt; 之前 ，首先需要安装 &lt;strong&gt;Multipass&lt;/strong&gt; 工具，可以打开官网进行下载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//multipass.run/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择对应的操作系统，因为我的是 &lt;strong&gt;Mac&lt;/strong&gt; 电脑，所以选择 MacOS，点击 &lt;strong&gt;Download&lt;/strong&gt; 开始下载&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsw2biaGewZU8V4TKK2tE67EnX91WqwFBhLu1lbMewrialrl419NIdwfIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211120120019913&quot;/&gt;&lt;figcaption&gt;选择对应版本安装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果电脑装了 &lt;strong&gt;brew&lt;/strong&gt; 可以直接命令行下载安装:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;brew&lt;/span&gt; cask install multipass&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载安装成功后, 执行以下命令可以查看当前软件版本:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; --version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，点击运行，即可打开 &lt;strong&gt;Multipass&lt;/strong&gt; 客户端，这里能够快速的通过 &lt;strong&gt;Open Shell&lt;/strong&gt; 创建和启动一个虚拟机&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7735849056603774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8hqCKQmRFhia7ic3pgBhtL2gd9M55Rf0Gib3icFE6YeqZ28P2b7hiaNyf5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot; title=&quot;Multipass客户端&quot;/&gt;&lt;figcaption&gt;Multipass客户端&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;下面，我们来介绍如何通过命令的方式，创建一台虚拟机&lt;/p&gt;&lt;h2&gt;&lt;span&gt;创建Ubuntu虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先，通过以下指令查看可供下载的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; find&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行成功后，可以看到下面的这些镜像列表，包含各种版本的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Image&lt;/span&gt;                       &lt;span&gt;Aliases&lt;/span&gt;           &lt;span&gt;Version&lt;/span&gt;          &lt;span&gt;Description&lt;/span&gt;&lt;br/&gt;&lt;span&gt;core&lt;/span&gt;                        &lt;span&gt;core16&lt;/span&gt;            20200818         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 16&lt;br/&gt;&lt;span&gt;core18&lt;/span&gt;                                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 18&lt;br/&gt;18&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;bionic&lt;/span&gt;            20211109         &lt;span&gt;Ubuntu&lt;/span&gt; 18&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;20&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;focal&lt;/span&gt;,&lt;span&gt;lts&lt;/span&gt;         20211118         &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;hirsute&lt;/span&gt;           20211119         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.04&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.10&lt;/span&gt;                       &lt;span&gt;impish&lt;/span&gt;            20211103         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:adguard-home&lt;/span&gt;                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;AdGuard&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:mosquitto&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Mosquitto&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:nextcloud&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Nextcloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:openhab&lt;/span&gt;                             20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;openHAB&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:plexmediaserver&lt;/span&gt;                     20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Plex&lt;/span&gt; &lt;span&gt;Media&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;anbox-cloud-appliance&lt;/span&gt;                         &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;Anbox&lt;/span&gt; &lt;span&gt;Cloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;minikube&lt;/span&gt;                                      &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;minikube&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载最新版的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像并运行，初次创建时需要下载 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像，网络畅通的情况下，稍等片刻即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; launch -n vm01 -c &lt;span&gt;1&lt;/span&gt; -m &lt;span&gt;1G&lt;/span&gt; -d &lt;span&gt;10G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义配置创建可以参考如下方式:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;-n, --name: 名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-c, --cpus: cpu核心数, 默认: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-m, --mem: 内存大小, 默认: 1G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d, --disk: 硬盘大小, 默认: 5G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;操作虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机列表&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;虚拟机创建完成后，可以使用 &lt;strong&gt;multipass list&lt;/strong&gt; 命令进行查看虚拟机列表&lt;/p&gt;&lt;pre&gt;&lt;code&gt;% &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;                    &lt;span&gt;State&lt;/span&gt;             &lt;span&gt;IPv4&lt;/span&gt;             &lt;span&gt;Image&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vm01&lt;/span&gt;                    &lt;span&gt;Running&lt;/span&gt;           192&lt;span&gt;.168.64.2&lt;/span&gt;     &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到目前正在运行一台 &lt;strong&gt;Ubuntu 20.04&lt;/strong&gt; 版本的虚拟机，并且对应的 &lt;strong&gt;IP&lt;/strong&gt; 地址为 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;外部操作虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass exec&lt;/strong&gt; 命令在实例内执行给定的命令。第一个参数是运行命令的实例，也就是 &lt;strong&gt;vm01&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们通过 &lt;strong&gt;exec&lt;/strong&gt; 命令，就可以在外部操作刚刚创建的虚拟机，例如查看内部所处的目录，执行 &lt;strong&gt;pwd&lt;/strong&gt; 命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; multipass &lt;span&gt;exec&lt;/span&gt; vm01 &lt;span&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;/home/ubuntu&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机信息&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass info&lt;/strong&gt; 命令，即可查看当前运行的虚拟机信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;info&lt;/span&gt; &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;:           &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;State&lt;/span&gt;:          &lt;span&gt;Running&lt;/span&gt;&lt;br/&gt;&lt;span&gt;IPv4&lt;/span&gt;:           192&lt;span&gt;.168.64.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Release&lt;/span&gt;:        &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04.3&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Image&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;:     91740&lt;span&gt;d72ffff&lt;/span&gt; (&lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;Load&lt;/span&gt;:           0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Disk&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:     1&lt;span&gt;.3G&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 9&lt;span&gt;.5G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Memory&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:   170&lt;span&gt;.9M&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 1&lt;span&gt;.9G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mounts&lt;/span&gt;:         &lt;span&gt;--&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;进入虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass shell&lt;/strong&gt; 命令，即可进入到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; shell vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后的结果如下所示，可以看到目前虚拟机的一些系统配置信息，以及内存和磁盘的使用情况&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7129629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcskVp6KUe7Mm9HbLT6dmUhJzpnabyPt7rKHAbulLKO6ib1UUMNrsN0xXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121085114961&quot;/&gt;&lt;figcaption&gt;进入虚拟机内部&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;同时会运行一个新的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统，此时便进入到了&lt;strong&gt;Ubuntu&lt;/strong&gt; 环境中, 在里面可以执行相关的 &lt;strong&gt;linux&lt;/strong&gt; 指令&lt;/p&gt;&lt;p&gt;当然如果不想进入系统内部，也可以通过上述提到的 &lt;strong&gt;multipass exce&lt;/strong&gt; 命令，来操作 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;&lt;p&gt;首先执行下面命令，给系统设置一个 &lt;strong&gt;root&lt;/strong&gt; 密码，设置好密码后，使用 &lt;strong&gt;su root&lt;/strong&gt; 切换到 &lt;strong&gt;root&lt;/strong&gt; 用户&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 设置密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sudo&lt;/span&gt; passwd&lt;br/&gt;&lt;span&gt;# 切换 root&lt;/span&gt;&lt;br/&gt;su root&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;ubuntu&lt;/strong&gt; 是使用 &lt;strong&gt;apt-get&lt;/strong&gt; 来进行包管理的，首先更新一下 &lt;strong&gt;apt-get&lt;/strong&gt;，然后安装 &lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 更新apt&lt;/span&gt;&lt;br/&gt;apt-get &lt;span&gt;update&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装 nginx&lt;/span&gt;&lt;br/&gt;apt-&lt;span&gt;get&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好 &lt;strong&gt;nginx&lt;/strong&gt; 后，可以到 /etc/nginx 目录即可看到刚刚的 &lt;strong&gt;nginx&lt;/strong&gt; 配置信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@vm01&lt;span&gt;:/lost+found&lt;/span&gt;&lt;span&gt;# cd /etc/nginx/&lt;/span&gt;&lt;br/&gt;root@vm01&lt;span&gt;:/etc/nginx&lt;/span&gt;&lt;span&gt;# ls&lt;/span&gt;&lt;br/&gt;conf.d        fastcgi_params  koi-win     modules-available  nginx.conf    scgi_params      sites-enabled  uwsgi_params&lt;br/&gt;fastcgi.conf  koi-utf         mime.types  modules-enabled    proxy_params  sites-available  snippets       win-utf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面我们可以测试一下，&lt;strong&gt;nginx&lt;/strong&gt; 是否安装成功，在 &lt;strong&gt;mac&lt;/strong&gt; 上打开浏览器，输入虚拟机的 &lt;strong&gt;ip&lt;/strong&gt; 地址 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsUBdjGbOeCEodmicmTpQIYIe9oBNlhExhKudlB5HqryPI1YeAa5UKvGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121094727506&quot;/&gt;&lt;figcaption&gt;nginx安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;可以看出，目前 &lt;strong&gt;nginx&lt;/strong&gt; 已经成功运行了，后续的话，可能会考虑在上面部署更多的应用，感兴趣的小伙伴欢迎关注～&lt;/p&gt;&lt;h3&gt;&lt;span&gt;挂载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;multipass&lt;/strong&gt; 还提供和 &lt;strong&gt;Docker&lt;/strong&gt; 一样的挂载数据卷的功能，能够与外部宿主机的文件保持同步。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 挂载格式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; mount 宿主机目录  实例名:虚拟机目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面，我在用户的目录下，创建一个 &lt;strong&gt;hello&lt;/strong&gt; 目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 创建hello目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;mkdir&lt;/span&gt; hello&lt;br/&gt;&lt;span&gt;# 挂载&lt;/span&gt;&lt;br/&gt;multipass mount /Users/moxi/hello  vm01:/hello&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挂载完成后，我们回到实例 vm01 中，可以看出多了一个 &lt;strong&gt;hello&lt;/strong&gt; 文件夹，说明已经成功挂载～&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsWKnic6p04c1vu5iaTib7bziaz2iaZwXCZutNm18U6wng3t7ljIBUldLHiayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot; title=&quot;image-20211121110217283&quot;/&gt;&lt;figcaption&gt;挂载成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因此，以后在 &lt;strong&gt;vm01&lt;/strong&gt; 的 &lt;strong&gt;hello文件夹&lt;/strong&gt; 中创建的文件，都会在的宿主机的 &lt;strong&gt;hello 文件夹&lt;/strong&gt;同步显示&lt;/p&gt;&lt;h3&gt;&lt;span&gt;卸载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果以后不需要用到挂载了，可以使用 &lt;strong&gt;unmount&lt;/strong&gt; 命令卸载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#卸载数据卷&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; umount 容器名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;传输文件&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;除了使用上述的 &lt;strong&gt;mount&lt;/strong&gt; 挂载卷的方式实现文件的交互，同时还可以通过 transfer 命令，将宿主机的文件，发送到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; transfer 主机文件 容器名:容器目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，将 &lt;strong&gt;hello.txt&lt;/strong&gt; 发送到&lt;/p&gt;&lt;pre&gt;&lt;code&gt;multipass transfer hello.txt vm01:&lt;span&gt;/home/ubuntu/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;删除和释放实例&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用下面的命令，可以开启、停止、删除和释放实例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 启动实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;start&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 停止实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;stop&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 删除实例（删除后，还会存在）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;delete&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 释放实例（彻底删除）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;purge&lt;/span&gt; vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;容器配置自动化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为了保持开发环境和线上环境一致性 同时节省部署时间 &lt;strong&gt;multipass&lt;/strong&gt; 给我们提供了 &lt;strong&gt;--cloud-init&lt;/strong&gt; 选项进行容器启动初始化配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;launch&lt;/span&gt; &lt;span&gt;--name&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt; &lt;span&gt;--cloud-init&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;&lt;span&gt;.yaml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面 &lt;strong&gt;config.yaml&lt;/strong&gt; 则是容器的初始化配置文件，例如，我们想在初始化容器的时候，自动下载安装 &lt;strong&gt;Node.js&lt;/strong&gt;，内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#cloud-config&lt;/span&gt;&lt;br/&gt;runcmd:&lt;br/&gt;  - curl -sL https:&lt;span&gt;//deb.nodesource.com/setup_12.x | sudo -E bash -&lt;/span&gt;&lt;br/&gt;  - sudo apt-&lt;span&gt;get&lt;/span&gt; install -y nodejs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runcmd&lt;/code&gt; 可以指定容器 &lt;strong&gt;首次启动&lt;/strong&gt; 时运行的命令&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;凡是用户自定义的cloud-init的配置文件,必须以#cloud-config开头，这是cloud-init识别它的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;yaml&lt;/strong&gt; 配置文件可以参考下面的文章&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https://cloudinit.readthedocs.io/en/latest/topics/examples.html?highlight=&lt;span&gt;lock&lt;/span&gt;-passwd&lt;span&gt;#including-users-and-groups&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多关于 &lt;strong&gt;multipass&lt;/strong&gt; 的高阶的技巧，欢迎访问 &lt;strong&gt;multipass&lt;/strong&gt; 官方文档&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//m&lt;/span&gt;ultipass.run&lt;span&gt;/docs/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，本期关于 &lt;strong&gt;Multipass&lt;/strong&gt; 的基础学习就到这里了，感兴趣的小伙伴环境下载自己动手学习呢～&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;使用了一阵子后，&lt;strong&gt;Multipass&lt;/strong&gt; 在使用起来很简洁直观，在整体操作上和 &lt;strong&gt;docker&lt;/strong&gt; 类似，如果想在自己电脑上快速搭建一个 &lt;strong&gt;Linux&lt;/strong&gt; 系统用于学习的话，选择使用 &lt;strong&gt;Multipass&lt;/strong&gt; 还是非常方便的。&lt;/p&gt;&lt;p&gt;唯一不足的地方就是，&lt;strong&gt;Multipass&lt;/strong&gt; 是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 背后的 &lt;strong&gt;Canonical&lt;/strong&gt; 公司开发的，因此 &lt;strong&gt;Multipass&lt;/strong&gt; 所使用的镜像也都是 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像（这也可以理解，毕竟支持自家的产品），不过对于习惯了使用 &lt;strong&gt;CentOS&lt;/strong&gt; 的用户来说，还是用些许不太习惯。&lt;/p&gt;&lt;p&gt;不过瑕不掩瑜，&lt;strong&gt;Multipass&lt;/strong&gt; 在我看来还是一款非常棒的软件～&lt;/p&gt;&lt;p&gt;另外，它的代码也在 GitHub 开源了，需要进一步研究的小伙伴也可以看下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;GitHub：https://github.com/canonical/multipass&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxOTcxNTIwNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28ia8xsyOClt8NDDCTAZNaDsEic4EEpUG1FPduFr5TUMK1GbDiaFX0qNCJiaS2XPfHzWlFicK95v1a9ic7Vg/0?wx_fmt=png&quot; data-nickname=&quot;GitHubDaily&quot; data-alias=&quot;GitHubDaily&quot; data-signature=&quot;专注于分享 GitHub 上知名的 Python、Java、Web、AI、数据分析等多个领域的优质学习资源、开源项目及开发者工具，为 GitHub 开发者提供优质编程资讯。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>