<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>31d9ce0967a693e0c18a8acd042d1040</guid>
<title>MongoDB全方位知识图谱！</title>
<link>https://toutiao.io/k/efxw4nr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4psjPOibic6BZSicnBFh6uWzCFp3uqN5R114Fq85DmuCzdL3eESlQ37bFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span/&gt;&lt;span&gt;MongoDB是一个强大的分布式存储引擎，天然支持高可用、分布式和灵活设计。MongoDB的一个很重要的设计理念是：服务端只关注底层核心能力的输出，至于怎么用，就尽可能的将工作交个客户端去决策。这也就是MongoDB灵活性的保证，但是灵活性带来的代价就是使用成本的提升。与MySql相比，想要用好MongoDB，减少在项目中出问题，用户需要掌握的东西更多。本文致力于全方位的介绍MongoDB的理论和应用知识，目标是让大家可以通过阅读这篇文章之后能够掌握MongoDB的常用知识，具备在实际项目中高效应用MongoDB的能力。本文既有MongoDB基础知识也有相对深入的进阶知识，同时适用于对MonogDB感兴趣的初学者或者希望对MongoDB有更深入了解的业务开发者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是笔者在学习和使用MongoDB过程中总结的MongoDB知识图谱。本文将按照一下图谱中依次介绍MongoDB的一些核心内容。由于能力和篇幅有限，本文并不会对图谱中全部内容都做深入分析，后续将会针对特定条目做专门的分析。同时，如果图谱和内容中有错误或疏漏的地方，也请大家随意指正，笔者这边会积极修正和完善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文按照图谱从以下&lt;/span&gt;&lt;span&gt;3个方面&lt;/span&gt;&lt;span&gt;来介绍MongoDB相关知识：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;902&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.56328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96wFFuYibavG2DePVqax9J0BykcIEibibPgUxCogPVp4TzCCeiatVTMfLT4GASuJ1susdEgP3UuIXgWvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、基础知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB是基于文档的NoSql存储引擎。MongoDB的数据库管理由数据库、Collection（集合，类似MySql的表）、Document（文档，类似MySQL的行）组成，每个Document都是一个类JSON结构BSON结构数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的核心特性是：No Schema、高可用、分布式（可平行扩展），另外MongoDB自带数据压缩功能，使得同样的数据存储所需的资源更少。本节将会依次介绍这些特性的基本知识，以及MongoDB是如何实现这些能力的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（一）No Schema&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB是文档型数据库，其文档组织结构是BSON(Binary Serialized Document Format) 是类JSON的二进制存储格式，数据组织和访问方式完全和JSON一样。支持动态的添加字段、支持内嵌对象和数组对象，同时它也对JSON做了一些扩充，如支持Date和BinData数据类型。正是BSON这种字段灵活管理能力赋予了Mongo的No Schema或者Schema Free的特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;No Schema特性带来的好处包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MongoDB在提供No Schema特性基础上，提供了部分可选的Schema特性：Validation。其主要功能有包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的字段包含内嵌文档的，也就是说，你可以指定Document内任意一层JSON文件的字段属性。validator的值有两种，一种是简单的JSON Object，另一种是通过关键字$jsonSchema指定。以下是简单示例，想了解更多请参考官方文档：&lt;/span&gt;&lt;span&gt;MongoDB JSON Schema详解&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-jsonSchema.html）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方式一：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.createCollection&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;saky_test_validation&lt;/span&gt;&quot;,{&lt;span class=&quot;code-snippet__attribute&quot;&gt;validator&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    $and:[&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      {name:{$type: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;}},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      {&lt;span class=&quot;code-snippet__attribute&quot;&gt;status&lt;/span&gt;:{$in:[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;INIT&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DEL&quot;&lt;/span&gt;]}}]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方式二：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.createCollection&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;saky_test_validation&lt;/span&gt;&quot;, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attribute&quot;&gt;validator&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      $jsonSchema: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         bsonType: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         required: [ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;status&quot;&lt;/span&gt;, ],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         properties: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            name: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               bsonType: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               description: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;must be a string and is required&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;status&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__attribute&quot;&gt;enum&lt;/span&gt;: [ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;INIT&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DEL&quot;&lt;/span&gt;], &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               description: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;can only be one of the enum values and is required&quot;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} }})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;（二）MongoDB的高可用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用是MongoDB最核心的功能之一，相信很多同学也是因为这一特性才想深入了解它的。那么本节就来说下MongoDB通过哪些方式来实现它的高可用，然后给予这些特性我们可以实现什么程度的高可用。&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信一旦提到高可用，浮现在大家脑海里会有如下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，带着这些问题，我们继续看下去，看完大家应该会对这些问题有所了解了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MongoDB高可用的基础是复制集群，复制集群本质来说就是一份数据存多份，保证一台机器挂掉了数据不会丢失。一个副本集至少有3个节点组成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的节点类型可以看出，一个三节点的复制集群可能是PSS或者PSA结构。PSA结构优点是节约成本，但是缺点是Primary挂掉之后，一些依赖 majority（多数）特性的写功能出问题，因此一般不建议使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;复制集群确保数据一致性的核心设计是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面4点我们可以得出 MongoDB 高可用的如下结论：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上一小节发现，MongoDB的高可用机制在不同的场景表现是不一样的。实际上，MongoDB提供了一整套的机制让用户根据自己业务场景选择不同的策略。这里要说的就是MongoDB的读写策略，根据用户选取不同的读写策略，你会得到不同程度的数据可靠性和一致性保障。这些对业务开放者非常重要，因为你只有彻底掌握了这些知识，才能根据自己的业务场景选取合适的策略，同时兼顾读写性能和可靠性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Write Concern——写策略    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;控制服务端一次写操作在什么情况下才返回客户端成功，由两个参数控制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Read Preference——读策略    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;控制客户端从什么节点读取数据，默认为primary，具体参数及含义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多信息可参考&lt;/span&gt;&lt;span&gt;MongoDB 官方文档&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（https://www.mongodb.com/docs/v4.0/reference/read-preference/index.html?_ga=2.71414227.1531435120.1648536327-1778944104.1630835426）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Read Concern Level——读级别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个非常有意思的参数，也是最不容易理解的异常参数。它主要控制的是读到的数据是不是最新的、是不是持久的，最新的和持久的是一对矛盾，最新的数据可能会被回滚，持久的数据可能不是最新的，这需要业务根据自己场景的容忍度做决策，前提是你的先知道有哪些，他们代表什么意义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了便于理解local和majority，这里引用一下MongoDB官网上的一张 WriteConcern=majority时写操作的过程图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3787465940054496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96wFFuYibavG2DePVqax9J0BprBVMoOib34nWvgic5naLlOyqDo9jJibxNtLjLtPcXPcibd7VZ2xZx1aHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这张图可以看出，不同节点在不同阶段看待同一条数据满足的level是不同的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.19814814814814816&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96wFFuYibavG2DePVqax9J0B4ibQVXhibAzXz1dEuvEpLN0gKASvLWFPtpibjM1Xg7FCicic1icpmeWWLe9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（三）MongoDB的可扩展性——分片集群&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;水平扩展是MongoDB的另一个核心特性，它是MongoDB支持海量数据存储的基础。&lt;/span&gt;&lt;span&gt;MongoDB天然的分布式特性使得它几乎可无限的横向扩展，你再也不用为MySQL分库分表的各种繁琐问题操碎心了。&lt;/span&gt;&lt;span&gt;当然，我们这里不讨论MongoDB和其它存储引擎的对比，这个以后专门写下，这里只关注分片集群相关信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的分片集群由如下三个部分组成：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7103109656301145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQX5F50QpF1w2LVmagceTUfkKuic5P4NnwRcics1OzNyxYehZSO4KR0VPSw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Config：配置，本质上是一个MongoDB的副本集，负责存储集群的各种元数据和配置，如分片地址、chunks等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Mongos：路由服务，不存具体数据，从Config获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Mongod：一般将具体的单个分片叫mongod，实质上每个分片都是一个单独的复制集群，具备负责集群的高可用特性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实分片集群的架构看起来和很多支持海量存储的设计很像，本质上都是将存储分片，然后在前面挂一个proxy做请求路由。但是，MongoDB的分片集群有个非常重要的特性是其它数据库没有的，这个特性就是数据均衡。数据分片一个绕不开的话题就是数据分布不均匀导致不同分片负载差异巨大，不能最大化利用集群资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的数据均衡的实现方式是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分片集群上数据管理单元叫chunk，一个chunk默认64M，可选范围1～ 1024M。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集群有多少个chunk，每个chunk的范围，每个chunk是存在哪个分片上的，这些数据都是存储在Config的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;chunk会在其内部包含的数据超过阈值时分裂成两个。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MongoDB在运行时会自定检测不同分片上的chunk数，当发现最多和最少的差异超过阈值就会启动chunk迁移，使得每个分片上的chunk数差不多。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;chunk 迁移过程叫rebalance，会比较耗资源，因此一般要把它的执行时间设置到业务低峰期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于chunk更加深入的知识会在后面进阶知识里面讲解，这里就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB支持&lt;/span&gt;&lt;span&gt;两种分片算法&lt;/span&gt;&lt;span&gt;来满足不同的查询需求：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;区间分片：可以按shardkey做区间查询的分片算法，直接按照shardkey的值来分片。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;hash分片：用的最多的分片算法，按shardkey的hash值来分片。hash分片可以看作一种特殊的区间分片。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;区间分片示例：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3585434173669468&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXl1h4S3NoqkMr7JFSv0qQsj53QLg0W3Dx668ia0A9NVRT9za2awZrkgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1428&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;hash分片示例：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36623748211731044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXaQ3Dsia4Ye0ib2lr5exJs4HibKUup0Py1aJDeZBDkSibqLG2yibPwT1rcbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1398&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面两张图可以看出：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分片的本质是将shardkey按一定的函数变换f(x)之后的空间划分为一个个连续的段，每一段就是一个chunk。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;区间分片f(x)=x；hash分片f(x)=hash(x)。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每个chunk在空间中起始值是存在Config里面的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当请求到Mongos的时候，根据shardkey的值算出f(x)的具体值为 f(shardkey)，找到包含该值的chunk，然后就能定位到数据的实际位置了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（四）数据压缩&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的另外一个比较重要的特性是数据压缩，MongoDB会自动把客户数据压缩之后再落盘，这样就可以节省存储空间。MongoDB的数据压缩算法有多种：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;前缀压缩：索引用的压缩算法，简单理解就是丢掉重复的前缀。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;zstd：MongoDB 4.2之后新增的压缩算法，拥有更好的压缩率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在推荐的MongoDB版本是4.0，在这个版本下推荐使用snappy算法，虽然zlib有更高的压缩比，但是读写会有一定的性能波动，不适合核心业务，但是比较适合流水、日志等场景。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、应用接入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在掌握第一部分的基础上，基本上对MongoDB有一个比较直观的认识了，知道它是什么，有什么优势，适合什么场景。在此基础上，我们基本上已经可以判定MongoDB是否适合自己的业务了。如果适合，那么接下来就需要考虑怎么将其应用到业务中。在此之前，我们还得先对MongoDB的性能有个大致的了解，这样才能根据业务情况选取合适的配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（一）基本性能测试&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在使用MongoDB之前，需要对其功能和性能有一定的了解，才能判定是否符合自己的业务场景，以及需要注意些什么才能更好的使用。笔者这边对其做了一些测试，本测试是基于自己业务的一些数据特性，而且这边使用的是分片集群。因此有些测试项不同数据会有差异，如压缩比、读写性能具体值等。但是也有一些是共性的结论，如写性能随数据量递减并最终区域平稳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对比了同样数据在Mongo和MySQL下压缩比对比，可以看出snapy算法大概是MySQL的3倍，zlib大概是6倍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3092053501180173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQX29yn4xQIkFNicibInJibz7PIlFua3Oa4QbxKzTJejia7DZBf2Z5sgyr7Cw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1271&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分片集群写性能在测试之后得到如下结论，这里分片是4核8G的配置：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当数据量小时是存内存读写，写性能很好，之后随着数量增加急剧下降，并最终趋于平稳，在3000QPS。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分片集群批量写和逐条写性能无差异，而如果是复制集群批量写性能是逐条写性能的数倍。这点有点违背常识，具体原因这边还未找到。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6899696048632219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXskvOMYIy5Md7vddB8fyMPMGzS6nahJeYWHHwEkjw63nR57ZgZ4vfDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;658&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分片集群的读分为三年种情况：按shardkey查询、按索引查询、其他查询。下面这些测试数据都是在单分片2亿以上的数据，这个时候cache已经不能完全换成业务数据了，如果数据量很小，数据全在cache这个性能应该会很好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mongos有点特殊情况要注意的，就是客户端请求会到哪个Mongos是通过客户端ip的hash值决定的，因此同一个客户端所有请求一定会到同一个 Mongos，如果客户端过少的时候还会出现Mongos负载不均问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（二）分片选择&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在了解了MongoDB的基本性能数据之后，就可以根据自己的业务需求选取合适的配置了。如果是分片集群，其中最重要的就是分片选取，包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于前面两点，其实在知道各种性能参数之后就很简单了，前人已经总结出了相关的公式，我这里就简单把图再贴一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36523652365236525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXCf5f0nLhYQRdV90EPDn5uTWubSWbMMyNv5PewBxrfX9rAk58v2xTdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1818&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（三）spring-data-mongo&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MonogDB官方提供了各种语言的Client，这些Client是对mongo原始命令的封装。笔者这边是使用的java，因此并未直接使用MongoDB官方的客户端，而是经过二次封装之后的spring-data-mongo。好处是可以不用他关心底层的设计如连接管理、POJO转换等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;spring-data-mongo的使用方式非常简单。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一步：引入jar包&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-mongodb&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二步：ymal配置&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;spring&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;data&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;mongodb&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;host&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_HOST}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;port&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_PORT}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;database&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_DB}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;username&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_USER}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;password&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_PASS}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里有个两个要注意：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;权限，MongoDB的权限是到数据级别的，所有配置的username必须有 database那个库的权限，要不然会连不上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;这种方式配置没有指定读写concern，如果需要在连接上指定的话，需要用 uri的方式来配置，两种配置方式是不兼容的，或者自己初始化 MongoTemplate。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于配置，跟多的可以在IDEA里面搜索MongoAutoConfiguration查看源码，具体就是这个类：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;org.springframework.boot.autoconfigure.mongo.MongoProperties&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于自己初始化MongoTemplate的方式是：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyMongoConfig&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Primary&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; MongoTemplate &lt;span class=&quot;code-snippet__title&quot;&gt;mongoTemplate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MongoDbFactory mongoDbFactory,  MongoConverter mongoConverter)&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        MongoTemplate mongoTemplate = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MongoTemplate(mongoDbFactory,mongoConverter);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mongoTemplate.setWriteConcern(WriteConcern.MAJORITY);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; mongoTemplate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三步：使用MongoTemplate&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在完成上面这些之后，就可以在代码里面注入MongoTemplate，然后使用各种增删改查接口了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB Client的批量操作有两种方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;bulkOps的方式会比另外一种方式在性能上低一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两种方式到引擎层面具体执行时都是一条条语句单独执行，它们有一个很重要的参数：ordered，这个参数的作用是控制批量操作在引擎内最终执行时是并行的还是穿行的。其默认值是true。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然，false模式下插入耗时会低一些，但是MongoTemplate的insertAll 函数是在内部写死的true。因此，如果想用false模式，需要自己继承MongoTemplate然后重写里面的insertDocumentList方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyMongoTemplate&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MongoTemplate&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; List&amp;lt;Object&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;insertDocumentList&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String collectionName, List&amp;lt;Document&amp;gt; documents)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .........&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                InsertManyOptions options = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InsertManyOptions();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                options = options.ordered(&lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; begin = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (writeConcernToUse == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    collection.insertMany(documents, options); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              collection.withWriteConcern(writeConcernToUse).insertMany(documents,options);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; MappedDocument.toIds(documents);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为MongoDB真的将太多自主性交给的客户端来决策，因此如果对其了解不够，真的会很容易踩坑。这里例举一些常见的坑，避免大家遇到。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预分片&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个问题的常见表现就是：为啥我的数据分布很随机了，但是分片集群的MongoDB插入性能还是这么低？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先我们说下预分片是什么，预分片就是提前把shard key的空间划分成若干段，然后把这些段对应的chunk创建出来。那么，这个和插入性能的关系是什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们回顾下前面说到的chunk知识，其中有两点需要注意：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当chunk内的数据超过阈值就会将chunk拆分成两个。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当各个分片上chunk数差异过大时就会启动rebalance，迁移chunk。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，很明显，问题就是出在这了，chunk分裂和chunk迁移都是比较耗资源的，必然就会影响插入性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，如果提前将个分片上的chunk创建好，就能避免频繁的分裂和迁移chunk，进而提升插入性能。预分片的设置方式为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; sh.shardCollection(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;saky_db.saky_table&quot;&lt;/span&gt;, {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;_id&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hashed&quot;&lt;/span&gt;}, &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,{&lt;span class=&quot;code-snippet__attr&quot;&gt;numInitialChunks&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;8192&lt;/span&gt;*分片数})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;numInitialChunks的最大值为8192*分片数&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存排序&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个是一个不容易被注意到的问题，但是使用MongoDB时一定要注意的就是避免任何查询的内存操作，因为用MongoDB的很多场景都是海量数据，这个情况下任何内存操作的成本都可能是非常高昂甚至会搞垮数据库的，当然MongoDB为了避免内存操作搞垮它，是有个阈值，如果需要内存处理的数据超过阈值它就不会处理并报错。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;继续说内存排序问题，它的本质是索引问题。MongoDB的索引都是有序的，正序或者逆序。如果我们有一个Collection里面记录了学生信息，包括年龄和性别两个字段。然后我们创建了这样一个复合索引：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;span class=&quot;code-snippet__attr&quot;&gt;gender&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这个时候，如果你排序顺序是下面这样的话，就会导致内存排序，如果数据两小到没事，如果非常大的话就会影响性能。避免内存排序就是要查询的排序方式要和索引的相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;span class=&quot;code-snippet__attr&quot;&gt;gender&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链式复制&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链式复制是指副本集的各个副本在复制数据时，并不是都是从Primary节点拉oplog，而是各个节点排成一条链，依次复制过去。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优点&lt;/span&gt;&lt;span&gt;：避免大量Secondary从Primary拉oplog，影响Primary的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;span&gt;：如果WriteConcern=majority，那么链式复制会导致写操作耗时更长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，是否开启链式复制就是一个成本与性能的平衡，默认是开启链式复制的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链式复制关闭时，节点数据复制对Primary节点性能影响程度目前没有专业测试过，因此不能评判到底开启还是关闭好，这边数据库同学从他们的经验来建议是关闭，因此我这边是关闭的，如果有用到MongoDB的可以考虑关掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、进阶知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来终于到了最重要的部分了，这部分将讲解一些MongoDB的一些高级功能和底层设计。虽然不了解这些也能使用，但是如果想用好MongoDB，这部分知识是必须掌握的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（一）存储引擎Wired Tiger&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说到MongoDB最重要的知识，其存储引擎Wired Tiger肯定是要第一个说的。因为MongoDB的所有功能都是依赖底层存储引擎实现的，掌握了存储引擎的核心知识，有利于我们理解MongoDB的各种功能。存储引擎的核心工作是管理数据如何在磁盘和内存上读写，从MongoDB 3.2开始支持多种存储引擎：Wired Tiger，MMAPv1和In-Memory，其中默认为Wired Tiger。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;B+Tree&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;存储引擎最核心的功能就是完成数据在客户端-内存-磁盘之间的交互。客户端是不可控的，因此如何设计一个高效的数据结构和算法，实现数据快速在内存和磁盘间交互就是存储引擎需要考虑的核心问题。目前大多少流行的存储引擎都是基于B/B+Tree和LSM(Log Structured Merge) Tree来实现，至于他们的优势和劣势，以及各种适用的场景，暂时超出了笔者的能力，后面到是有兴趣去研究一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Oracle、SQL Server、DB2、MySQL (InnoDB) 这些传统的关系数据库依赖的底层存储引擎是基于B+ Tree开发的；而像Cassandra、Elasticsearch (Lucene)、Google Bigtable、Apache HBase、LevelDB和RocksDB这些当前比较流行的NoSQL数据库存储引擎是基于LSM开发的。MongoDB虽然是NoSQL的，但是其存储引擎Wired Tiger 却是用的B+Tree，因此有种说法是MongoDB是最接近SQL的NoSQL存储引擎。好了，我们这里知道Wired Tiger的存储结构是B+Tree就行了，至于什么是B+Tree，它有些啥优势网都有很多文章，这里就不在赘述了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Wired Tiger在内存和磁盘上的数据结构都B+Tree，B+的特点是中间节点只有索引，数据都是存在叶节点。Wired Tiger管理数据结构的基本单元Page。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6114494518879415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXT6nd8UyrNhbNwxZShPzZFWx93xqX2gTya2Vcoz5b8ZiaIgJDx8nRObw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1642&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上图是Page在内存中的数据结构，是一个典型的B+ Tree，Page上有3个重要的list WT_ROW、WT_UPDATE、WT_INSERT。这个Page的组织结构和Page的3个list对后面理解cache、checkpoint等操作很重要：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;叶节点Page的WT_ROW：是从磁盘加载进来的数据数组。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;叶节点Page的WT_UPDATE：是记录数据加载之后到下个checkpoint之间被修改的数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;叶节点Page的WT_INSERT：是记录数据加载之后到下个checkpoint之间新增的数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面说了Page的基本结构，接下来再看下Page的生命周期和状态扭转，这个生命周期和Wired Tiger的缓存息息相关。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8660785886126704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXFOgfA0jUcsXj03xwlZSX6MHwMaEJOkGM9Uic8S85UgCkUSib4RIqsicow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1247&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Page在磁盘和内存中的整个生命周期状态机如上图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;READING：Page正在被从磁盘加载到内存中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LOCKED：内存淘汰过程（evict）正在锁住Page。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LOOKASIDE：在执行reconcile的时候，如果page正在被其他线程读取被修改的部分，这个时候会把数据存储在lookasidetable里面。当页面再次被读时可以通过lookasidetable重构出内存Page。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LIMBO：&lt;/span&gt;&lt;span&gt;在执行完reconcile之后，Page会被&lt;/span&gt;&lt;span&gt;刷到磁盘。&lt;/span&gt;&lt;span&gt;这个时候如果page有lookasidetable数据，并且还没合并过来之前就又被加载到内存了，就会是这个状态，需要先从lookasidetable重构内存Page才能正常访问。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中两个比较重要的过程是reconcile和evict。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中reconcile发生在checkpoint的时候，将内存中Page的修改转换成磁盘需要的B+ Tree结构。前面说了Page的WT_UPDATE和WT_UPDATE列表存储了数据被加载到内存之后的修改，类似一个内存级的oplog，而数据在磁盘中时显然不可能是这样的结构。因此reconcile会新建一个Page来将修改了的数据做整合，然后原Page就会被discarded，新page会被刷新到磁盘，同时加入LRU队列。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;evict是内存不够用了或者脏数据过多的时候触发的，根据LRU规则淘汰内存 Page到磁盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB不是内存数据库，但是为了提供高效的读写操作存储引擎会最大化的利用内存缓存。MongoDB的读写性能都会随着数据量增加到了某个点出现近乎断崖式跌落最终趋于稳定。这其中的根本原因就是内存是否能cover住全部的数据，数据量小的时候是纯内存读写，性能肯定非常好，当数据量过大时就会触发内存和磁盘间数据的来回交换，导致性能降低。所以，如果在使用MongoDB时，如果发现自己某些操作明显高于常规，那么很大可能是它触发了磁盘操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来说下MongoDB的存储引擎Wired Tiger是怎样利用内存cache的。首先，Wired Tiger会将整个内存划分为3块：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;存储引擎内部cache：缓存前面提到的内存数据，默认大小Max((RAM-1G)/2,256M )，服务器16G的话，就是(16-1)/2=7.5G。这个内存配置一定要注意，因为Wired Tiger如果内存不够可能会导致数据库宕掉的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件系统cache：这个实际上不是存储引擎管理，是利用的操作系统的文件系统缓存，目的是减少内存和磁盘交互。剩下的内存都会用来做这个。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存分配大小一般是不建议改的，除非你确实想把自己全部数据放到内存，并且主够的引擎知识。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引擎cache和文件系统cache在数据结构上是不一样的，文件系统cache是直接加载的内存文件，是经过压缩的数据，可以占用更少的内存空间，相对的就是数据不能直接用，需要解压；而引擎中的数据就是前面提到的B+ Tree，是解压后的，可以直接使用的数据，占有的内存会大一些。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Evict&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;就算内存再大它与磁盘间的差距也是数据量级的差异，随着数据增长也会出现内存不够用的时候。因此内存管理一个很重要的操作就是内存淘汰evict。内存淘汰时机由eviction_target（内存使用量）和eviction_dirty_target（内存脏数据量）来控制，而内存淘汰默认是有后台的evict线程控制的。但是如果超过一定阈值就会把用户线程也用来淘汰，会严重影响性能，应该避免这种情况。用户线程参与evict的原因，一般是大量的写入导致磁盘IO抗不住了，需要控制写入或者更换磁盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34324659231722426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXLWybBbjzspykrbsCNWbxP5Zh3ibx5mRreuOYG93AkgHdiaYqr41j2mJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面说过，MongoDB的读写都是操作的内存，因此必须要有一定的机制将内存数据持久化到磁盘，这个功能就是Wired Tiger的checkpoint来实现的。checkpoint实现将内存中修改的数据持久化到磁盘，保证系统在因意外重启之后能快速恢复数据。checkpoint本身数据也是会在每次checkpoint执行时落盘持久化的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7451923076923077&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavNnSoX9tkcNKAh4MBmVzDD62B6SH8ghUJOv53sg3mLItiawVx0GmzwXdOMRmPK9UkX13eAt72icW3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个checkpoint 就是一个内存B+ Tree，其结构就是前面提到的Page组成的树，它有几个重要的字段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35030728709394204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXtlsEF5THgD8EGW2xhtM7DyQOvIttja7gUxibO2G9XhehcmdUa6Z6KdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2278&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;checkpoint的大致流程入上图所述：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在系统启动或者集合文件打开时，从磁盘加载最新的checkpoint。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据checkpoint的file size truncate文件。因为只有checkpoint确认的数据才是真正持久化的数据，它后面的数据可能是最新checkpoint之后到宕机之间的数据，不能直接用，需要通过Journal日志来回放。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据checkpoint构建内存的B+Tree。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据库run起来之后，各种修改操作都是操作checkpoint的B+Tree，并且会checkpoint会有专门的list来记录这些修改和新增的page。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在60s一次的checkpoint执行时，会创建新的checkpoint，并且将旧的 checkpoint数据合并过来。然后执行reconcile将修改的数据刷新到磁盘，并删除旧的checkpoint。这时候会清空allocated，discarded里面的 page，并且将空闲的page加到available里面。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（二）Chunk&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Chunk为啥要单独出来说一下呢，因为它是MongoDB分片集群的一个核心概念，是使用和理解分片集群读写实现的最基础的概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，说下chunk是什么，chunk本质上就是由一组Document组成的逻辑数据单元。它是分片集群用来管理数据存储和路由的基本单元。具体来说就是，分片集群不会记录每条数据在哪个分片上，这不现实，它只会记录哪一批（一个chunk）数据存储在哪个分片上，以及这个chunk包含哪些范围的数据。而数据与chunk之间的关联是有数据的shard key的分片算法f(x)的值是否在chunk的起始范围来确定的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面说过，分片集群的chunk信息是存在Config里面的，而Config本质上是一个复制集群。如果你创建一个分片集群，那么你默认会得到两个库，admin和config，其中config库对应的就是分片集群架构里面的Config。其中的包含一个Collection chunks里面记录的就是分片集群的全部chunk信息，具体结构如下图：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3814026792750197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXNC3ok0HhLEN2m8Wt25vgZVI0Vgkk5hW4V3rODWSFPGb9Xwjwq2BLnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1269&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk的几个关键属性：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ns：命名空间，就是DB.COLLECTION的结构。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;min：chunk包含数据的shard key的f(x)最小值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;max：chunk包含数据的shard key的f(x)最大值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk是分片集群管理数据的基本单元，本身有一个大小，那么随着chunk内的数据不断新增，最终大小会超过限制，这个时候就需要把chunk拆分成2个，这个就chunk的分裂。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk的大小不能太大也不能太小。太大了会导致迁移成本高，太小了有会触发频繁分裂。因此它需要一个合理的范围，默认大小是64M，可配置的取值范围是1M～1024M。这个大小一般来说是不用专门配置的，但是也有特例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导致chunk分裂有两个条件，达到任何一个都会触发&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB一个区别于其他分布式数据库的特性就是自动数据均衡。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk分裂是MongoDB保证数据均衡的基础&lt;/span&gt;&lt;span&gt;：数据的不断增加，chunk不断分裂，如果数据不均匀就会导致不同分片上的chunk数目出现差异，这就解决了分片集群的数据不均匀问题发现。然后就可以通过将chunk从数据多的分片迁移到数据少的分片来实现数据均衡，这个过程就是rebalance。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下图所示，随着数据插入，导致chunk分裂，让AB两个分片有3个 chunk，C分片只有一个，这个时候就会把B分配的迁移一个到C分分片实现集群数据均衡。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34075104311543813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXRBLwurwoRnFrOjSlKEn84xicUh2yTH0YqlJNXZ3EzCric8SNhicypfzVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行rebalance是有几个前置条件的：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据库和集合开启了rebalance开关，默认是开启的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当前时间在设置的rebalance时间窗，默认没有配置，就是只要检测到了就会执行rebalance。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集群中分片chunk数最大和最小之差超过阈值，这个阈值和chunk总数有关，具体如下：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.572347266881029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXJsqLGTEEkL43YibIvKSg2wk2t2IGaMlRZVv1aQWdgDIheRllErIlg3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;rebalance为了尽快完成数据迁移，其设计是尽最大努力迁移，因此是非常消耗系统资源的，在系统配置不高的时候会影响系统正常业务。因此，为了减少其影响需要：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;预分片：减少大量数据插入时频繁的分裂和迁移chunk。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于可能会影响业务的大规模数据迁移，如扩容分片，可以采取手段迁移的方式来控制迁移速度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（三）一致性/高可用&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式系统必须要面对的一个问题就是数据的一致性和高可用，针对这个问题有一个非常著名的理论就是CAP理论。CAP理论的核心结论是：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。关于CAP理论在网上有非常多的论述，这里也不赘述。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CAP理论提出了分布式系统必须面临的问题，但是我们也不可能因为这个问题就不用分布式系统。因此，BASE（Basically Available基本可用、Soft state软状态、Eventually consistent最终一致性）理论被提出来了。BASE理论是在一致性和可用性上的平衡，现在大部分分布式系统都是基于 BASE理论设计的，当然MongoDB也是遵循此理论的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB为了保证可用性和分区容错性，采用的是副本集的方式，这种模式就必须要解决的一个问题就是怎样快速在系统启动和Primary发生异常时选取一个合适的主节点。这里潜在着多个问题：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;哪些Secondary节点有资格参加Primary选举？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发现Primary异常之后用什么样的算法选出新的Primary节点？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Raft协议&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的选举算法是基于Raft协议的改进，Raft协议将分布式集群里面的节点有&lt;/span&gt;&lt;span&gt;3种状态&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;leader：就是Primary节点，负责整个集群的写操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;candidate：候选者，在Primary节点挂掉之后，参与竞选的节点。只有选举期间才会存在，是个临时状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;flower：就是Secondary节点，被动的从Primary节点拉取更新数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节点的状态变化是：正常情况下只有一个leader和多个flower，当leader挂掉了，那么flower里面就会有部分节点成为candidate参与竞选。当某个candidate竞选成功之后就成为新的leader，而其他candidate回到flower状态。具体状态机如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5559055118110237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXtbpHL8dbtnrx5tBU8uw5DuJLtNPEpFoXxro2x4SibVDNpNTg4NVddeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1270&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Raft协议中有两个核心RPC协议分别应用在选举阶段和正常阶段：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求投票：选举阶段，candidate向其他节点发起请求，请求对方给自己投票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;追加条目：正常阶段，leader节点向flower节点发起请求，告诉对方有数据更新，同时作为心跳机制来向所有flower宣示自己的地位。如果flower在一定时间内没有收到该请求就会启动新一轮的选举投票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;投票规则&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Raft协议规定了在选举阶段的投票规则：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一个节点，在一个选举周期（Term）内只能给一个candidate节点投赞成票，且先到先得。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;只有在candidate节点的oplog领先或和自己相同时才投赞成票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;选举过程&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一轮完整的选举过程包含如下内容：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;某个/多个flower节点超时未收到leader的心跳，将自己改变成candidate 状态，增加选举周期（Term），然后先给自己投一票，并向其他节点发起投票请求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;等待其它节点的投票返回，在此期间如果收到其它candidate发来的请求，根据投票规则给其它节点投票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果某个candidate在收到过半的赞成票之后，就把自己转换成leader状态，并向其它节点发送心跳宣誓即位。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果节点在没有收到过半赞成票之前，收到了来自leader的心跳，就将自己退回到flower状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;只要本轮有选出leader就完成了选举，否则超时启动新一轮选举。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;catchup（追赶）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上就是目前掌握的MongoDB的选举机制，其中有个问题暂时还未得到解答，就是最后一个，怎样确保选出的Primary是最合适的那一个。因为，从前面的协议来看，存在一个逻辑bug：&lt;/span&gt;&lt;span&gt;由于flower转换成candidate是随机并行的，再加上先到先得的投票机制会导致选出一个次优的节点成为Primary&lt;/span&gt;&lt;span&gt;。但是这一点应该是笔者自己掌握知识不够，应该是有相关机制保证的，怀疑是通过节点优先级实现的。这点也和相关同学确认过，因此这里暂定此问题不存在，等深入学习这里的细节之后补充其设计和实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对Raft协议的这个问题，下来查询了一些资料，结论是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Raft协议确实不保证选举出来的Primary节点是最优的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MongoDB通过在选举成功，到新Primary即位之前，新增了一个 catchup（追赶）操作来解决。即在节点获取投票胜利之后，会先检查其它节点是否有比自己更新的oplog，如果没有就直接即位，如果有就先把数据同步过来再即位。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的主从同步机制是确保数据一致性和可靠性的重要机制。其同步的基础是oplog，类似MySQL的binlog，但是也有一些差异，oplog虽然叫log但并不是一个文件，而是一个集合（Collection）。同时由于 oplog 的并行写入，存在尾部乱序和空洞现象，具体来说就是oplog里面的数据顺序可能是和实际数据顺序不一致，并且存在时间的不连续问题。为了解决这个问题，MongoDB采用的是混合逻辑时钟（HLC）来解决的，HLC不止解决乱序和空洞问题，同时也是用来解决分布式系统上事务一致性的方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从同步的本质实际上就是，Primary节点接收客户端请求，将更新操作写到oplog，然后Secondary从同步源拉取oplog并本地回放，实现数据的同步。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同步源选取&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同步源是指节点拉取oplog的源节点，这个节点不一定是Primary，链式复制模式下就可能是任何节点。节点的同步源选取是一个非常复杂的过程，大致上来说是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;节点维护整个集群的全部节点信息，并每2s发送一次心跳检测，存活的节点都是同步源备选节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;落后自己的节点不能做同步源：就是源节点最新的opTime不能小于自己最新的opTime。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;太超前的节点不能作为同步源：就是源节点最老的opTime不能大于自己最新的opTime，否则有oplog空洞。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在同步源选取时有些特殊情况：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果关闭链式复制，所有Secondary节点的同步源都是Primary节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;oplog拉取和回放&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个拉取和回放的逻辑非常复杂，这里根据自己的理解简化说明，如果想了解更多知识可以参考&lt;/span&gt;&lt;span&gt;《MongoDB复制技术内幕》&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节点有一个专门拉取oplog的线程，通过Exhausted cursor从同步源拉取 oplog。拉取下来之后，并不会执行回放执行，而是会将其丢到一个本地的阻塞队列中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后有多个具体的执行线程，从阻塞队列中取出oplog并执行。在取出过程中，同一个Collection的oplog一定会被同一个线程取出执行，线程会尽可能的合并连续的插入命令。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个回放的执行过程，大致为先加锁，然后写本店oplog，然后将oplog刷盘（WAL机制），最后更新自己的最新opTime。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（四）索引&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;索引对任何数据库而言都是非常重要的一个功能。数据库支持的索引类型，决定的数据库的查询方式和应用场景。而正确的使用索引能够让我们最大化的利用数据库性能，同时避免不合理的操作导致的数据库问题，最常见的问题就是CPU或内存耗尽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的索引和MySql的索引有点不一样，它的索引在创建时必须指定顺序（1：升序，-1：降序），同时所有的集合都有一个默认索引 _id，这是一个唯一索引，类似MySql的主键。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB支持的索引类型有：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单字段索引：建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB可以头/尾开始遍历。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多key索引：我们知道MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多key索引。MongoDB会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Hash索引：按数据的哈希值索引，用在hash分片集群上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;地理位置索引：基于经纬度的索引，适合2D和3D的位置查询。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文本索引：MongoDB虽然支持全文索引，但是性能低下，暂时不建议使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;索引功能强大，但是也有很多限制，使用索引时一定要注意一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复合索引&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复合索引有几个问题需要注意：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;避免内存排序：复合索引除第一个字段之外，其他字段的查询排序方式，必须和索引排序方式一致，否则会导致内存排序。如前面的索引，可以支持 {userid:-1,score:-1}的查询，同时也能支持{userid:1,score:1}的查询，只是后一种需要内存排序score字段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;索引交集：索引交集时查询优化器的优化方案，很少用到，尽量不要依赖这个功能。索引交集本质上就有创建两个独立的单字段索引，在查询保护两个字段时，优化器自动做索引交集。如{user:1}+{score:-1}两个索引的交集可以支持前面的{userid:1,score:1}的查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后台创建索引&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在对一个已经拥有较大数据集的Collection创建索引时，建议通过创建命令参数指定后台创建，不会阻塞命令和意外中断。但是，在后台创建多个索引时，不能命令执行完就接着下一个。因为是后台创建，命令行虽然推出了，但是索引还没创建完。这个时候如果同事输入多个创建索引命令，会因为大量的写操作和数据复制导致系统cpu耗尽。这个时候需要观察系统监控，确定第一个索引创建完了再执行下一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;explain是MongoDB的查询计划工具，和MySql的explain功能相同，都是用来分析一条语句的索引使用情况、影响行数、执行时间等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;explain有三种参数分别对应结果输出的三部分数据：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;queryPlanner：MongoDB运行查询优化器对当前的查询进行评估并选择一个最佳的查询计划。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;exectionStats：mongoDB运行查询优化器对当前的查询进行评估并选择一个最佳的查询计划进行执行。在执行完毕后返回这个最佳执行计划执行完成时的相关统计信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;allPlansExecution：即按照最佳的执行计划执行以及列出统计信息，如果有多个查询计划，还会列出这些非最佳执行计划部分的统计信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;explain是一个非常有用的工具，建议在一个数据量较大的数据库上开发新功能时，一定要用explain分析一下自己的语句是否合理、索引是否合理，避免在项目上线之后出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96wFFuYibavG2DePVqax9J0BmzP4xvWAROiawpjb0Cr7JVzic9qm47nZgyIicJRe0VWJiafPL4xxgDv0CQ/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;134.09523809523807&quot; data-cropy2=&quot;1414.095238095238&quot; data-fileid=&quot;100043716&quot; data-ratio=&quot;1.000925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96wFFuYibavG2DePVqax9J0BlFpfajib50UP3traPRdf7kJgQoNgf7sfZWpRgwZnIhTY8kPPeeredJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;sakychen&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;腾讯应用开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯应用开发工程师，毕业于电子科技大学，目前主要从事腾讯优码的码平台设计和开发工作。喜欢研究新技术，擅长快速梳理和总结复杂事物的逻辑脉络，并乐于和同事分享总结和经验。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;37b42a3b6ddcc414e6e32be4a161956e&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247538447&amp;amp;idx=1&amp;amp;sn=3d6ff1dae8f2ed056e9012fb7e860ddc&amp;amp;chksm=eaa84d5fdddfc4495e89716470071c0ff65507a638fe409347c93aef6bd99f2934172200c89e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;解锁tRPC高性能密码：网络方案简介！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;解锁tRPC高性能密码：网络方案简介！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247538296&amp;amp;idx=1&amp;amp;sn=97eacded099b48cc2f117a590c939a57&amp;amp;chksm=eaa84c28dddfc53e644d86a54577a3bdbda3b0eadfe14a202a9d24604c2782b5b9b61b2c8941&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;异步编程指北！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;异步编程指北！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247538229&amp;amp;idx=1&amp;amp;sn=2d7dcbb1b79fc2a53ffb20dbc0741cef&amp;amp;chksm=eaa84c65dddfc573bed4f9558174eb14dc8a8d917594a9a111f39a48563206a19a7d96bc3ed1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;图文结合！Redis延迟队列golang高效实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;图文结合！Redis延迟队列golang高效实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247537945&amp;amp;idx=1&amp;amp;sn=d51d07540f96441cd96ee708480c4646&amp;amp;chksm=eaa84f49dddfc65f817c15fe9885414cb6b305dd71dbe0f939a7d46134aee03201fa406b64c7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;开箱即用！深入浅出Prometheus监控神器&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;开箱即用！深入浅出Prometheus监控神器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96FK2eEg86vUicOR3n6kAHk1PHvTb8VBicYk0RmNQYsQyibgg8iaZqT0bCEU9VKo3Z3iceoQfgycyMpKWQ/0?wx_fmt=png&quot; data-nickname=&quot;云加社区&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4xV7ckfbmtFLyUjFID2k7yO4q8hvB4OqYoNkARZ2xuvzKvMtnmVN2BQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9343e05cab0c2dbcefea4d2470e3d056</guid>
<title>RedisJson 横空出世，性能碾压ES和Mongo！</title>
<link>https://toutiao.io/k/c394zol</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;近期官网给出了RedisJson（RedisSearch）的性能测试报告，可谓碾压其他NoSQL，下面是核心的报告内容，先上结论：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于隔离写入(isolated writes)，RedisJSON 比 MongoDB 快 5.4 倍，比 ElasticSearch 快 200 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于隔离读取(isolated reads)，RedisJSON 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;在混合工作负载场景中，实时更新不会影响 RedisJSON 的搜索和读取性能，而 ElasticSearch 会受到影响。以下是具体的数据：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 支持的操作数/秒比 MongoDB 高约 50 倍，比 ElasticSearch 高 7 倍/秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 的延迟比 MongoDB 低约 90 倍，比 ElasticSearch 低 23.7 倍。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;此外，RedisJSON 的读取、写入和负载搜索延迟在更高的百分位数中远比 ElasticSearch 和 MongoDB 稳定。当增加写入比率时，RedisJSON 还能处理越来越高的整体吞吐量，而当写入比率增加时，ElasticSearch 会降低它可以处理的整体吞吐量。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;二、查询引擎&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;如前所述，reresearch和RedisJSON的开发非常强调性能。对于每一个版本，我们都想确保开发者可以体验到稳定和产品。为此，我们我们给出了一些分析工具、探测器来进行性能分析。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并且，我们每次发行新版本时时，也在不断的提升性能。特别是对于reresearch来说，2.2版本在加载和查询性能上都比2.0快了1.7倍，同时还改进了吞吐量和数据加载的延迟。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 加载优化&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的两个图显示了运行纽约市出租车基准测试的运行结果&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6240740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPatFAxS6nhz3Et0gMDjB5zBNQgq36L2g6NH1kdic28mlwBsYo63xZWj8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6240740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPaibHw8uPOJXiby26CBpGMpv8xkRgqartUXUsQ59q1hSuW0KFzGRfAicRow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这些图表中可以看出，每一个reresearch的新版本都有一个实质性的性能改进。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 全文搜索优化&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估搜索性能，我们索引了590万篇维基百科摘要。然后我们运行一个全文搜索查询面板，得到的结果如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5833333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPa4TJ4NQeKdvhklqAyjKia5AqgR1Xgsob4ibiauia3xMKPguKrr9hsBI5HEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6240740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPasdscso49TeicLZWKaCAznfibic9ic9FDpoeRiayt6K5M8Azp5YpR8rImW3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图可以看出，通过从v2.0迁移到v2.2，同样的数据，在写、读、搜索(延迟图)方面都有了大幅度的改进，从而提高了运行Search和JSON的可实现吞吐量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;三、和其他框架的对比&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估RedisJSON的性能，我们决定将它与MongoDB和ElasticSearch进行比较。为了方便对比，我们会从文档存储、本地可用、云中可用、专业支持和提供可伸缩性、性能等方面进行全方位的对比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用了完善的YCSB标准来进行测试对比，它能够基于常见的工作负载来评估不同的产品，测量延迟、吞吐量曲线直到饱和。除了CRUD YCSB操作之外，我们还添加了一个两个字的搜索操作，专门帮助开发人员、系统架构师和DevOps从业者找到适合他们用例的最佳搜索引擎。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 基准测试&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次测试，我们使用了如下的一些软件环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MongoDB v5.0.3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ElasticSearch 7.15&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON (RediSearch 2.2+RedisJSON 2.0)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次是在Amazon Web Services 实例上运行基准测试，这三种解决方案都是分布式数据库，并且最常用于生产中的分布式方式。这就是为什么所有产品都使用相同的通用 m5d.8xlarge VM 和本地 SSD，并且每个设置由四个 VM 组成：一个客户端 + 三个数据库服务器。基准测试客户端和数据库服务器都在处于最佳网络条件下的单独 m5d.8xlarge 实例上运行，将实例紧密地打包在一个可用区内，实现稳态分析所需的低延迟和稳定的网络性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试是在三节点集群上执行的，部署细节如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MongoDB 5.0.3&lt;/code&gt;：三成员副本集（Primary-Secondary-Secondary）。副本用于增加读取容量并允许更低的延迟读取。为了支持对字符串内容的文本搜索查询，在搜索字段上创建了一个文本索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ElasticSearch 7.15&lt;/code&gt;：15 个分片设置，启用查询缓存，并为 2 个基于 NVMe 的本地 SSD 提供 RAID 0 阵列，以实现更高级别的文件系统相关弹性操作性能。这 15 个分片为我们为 Elastic 所做的所有分片变体提供了可实现的最佳性能结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;RedisJSON*&lt;/code&gt;：RediSearch 2.2 and RedisJSON 2.0: OSS Redis Cluster v6.2.6，有27个分片，均匀分布在三个节点上，加载了RediSearch 2.2和RedisJSON 2.0 OSS模块。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这个主要的基准/性能分析场景之外，我们还在网络、内存、CPU 和 I/O 上运行基准基准测试，以了解底层网络和虚拟机特性。在整个基准测试集期间，网络性能保持在带宽和 PPS 的测量限制以下，以产生稳定稳定的超低延迟网络传输（每个数据包 p99 &amp;lt; 100micros）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们将从提供单独的操作性能 [100% 写入] 和 [100% 读取] 开始，并以一组混合工作负载结束以模拟现实工作中的应用程序场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 100% 写入基准&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，该基准测试表明，RedisJSON* 的摄取速度比 ElasticSearch 快 8.8 倍，比 MongoDB 快 1.8 倍，同时保持每个操作的亚毫秒级延迟。值得注意的是，99% 的 Redis 请求在不到 1.5 毫秒的时间内完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，RedisJSON* 是我们测试过的唯一一种在每次写入时自动更新其索引的解决方案。这意味着任何后续的搜索查询都会找到更新的文档。ElasticSearch 没有这种细粒度的容量；它将摄取的文档放在一个内部队列中，并且该队列由服务器（不受客户端控制）每 N 个文档或每 M 秒刷新一次。他们称这种方法为近实时 (NRT)。Apache Lucene 库（它实现了 ElasticSearch 的全文功能）旨在快速搜索，但索引过程复杂且繁重。如这些 WRITE 基准测试图表所示，由于这种“设计”限制，ElasticSearch 付出了巨大的代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合延迟和吞吐量改进，RedisJSON* 比 Mongodb 快 5.4 倍，比 ElasticSearch 快 200 倍以上，用于隔离写入。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5638888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPaDYsTdmcRulUMvWibGFJdxFS0huslvT0f9n9hvLiawD3r090QZ8PgL38A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5638888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPajtibQ50dnz2R49CR3icPEAPcZGQfrRMicgKmEZV3noGC3KZWYRxJTNgbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 100% 读取基准&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与写类似，我们可以观察到 Redis 在读取方面表现最佳，允许读取比 ElasticSearch 多 15.8 倍，比 MongoDB 多 2.8 倍，同时在整个延迟范围内保持亚毫秒级延迟，如下表所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在结合延迟和吞吐量改进时，RedisJSON* 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上，用于隔离读取。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5638888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPaCzFrnbDYib4ebKGy3icvxJCdhguhj1GyL6xq7BGmb5TibjQwMTs1xmn9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6185185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPa4FbrdG8vuP9lPezM0TdyzI7rypSbONh6OHyEpagz1apxMVsJ54gavA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.4 混合读/写/搜索基准&lt;/h4&gt;&lt;section&gt;&lt;span&gt;实际应用程序工作负载几乎总是读取、写入和搜索查询的混合。因此，在接近饱和时了解由此产生的混合工作负载吞吐量曲线更为重要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为起点，我们考虑了 65% 搜索和 35% 读取的场景，这代表了一个常见的现实世界场景，在该场景中，我们执行的搜索/查询比直接读取更多。65% 搜索、35% 读取和 0% 更新的初始组合也导致 ElasticSearch 和 RedisJSON* 的吞吐量相等。尽管如此，YCSB 工作负载允许您指定搜索/读取/更新之间的比率以满足您的要求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“搜索性能”可以指不同类型的搜索，例如“匹配查询搜索”、“分面搜索”、“模糊搜索”等等。我们所做的最初向 YCSB 增加的搜索工作负载仅专注于“匹配查询搜索”，模仿分页的两词查询匹配，按数字字段排序。“匹配查询搜索”是任何启用搜索功能的供应商进行搜索分析的起点，因此，每个支持 YCSB 的数据库/驱动程序都应该能够在其基准驱动程序上轻松启用此功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在每个测试变体中，我们添加了 10% 的写入，以按相同的比例混合和减少搜索和读取百分比。这些测试变体的目标是了解每个产品如何处理数据的实时更新，我们认为这是事实上的架构目标，即写入立即提交到索引，读取始终是最新的。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPaeb55zxy2DzPQqYOUCrRfj14yDrYDtImDF9IyTUibYJBiavOgO1KFoHoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;正如您在图表中所看到的，在 RedisJSON* 上不断更新数据和增加写入比例不会影响读取或搜索性能并提高整体吞吐量。对数据产生的更新越多，对 ElasticSearch 性能的影响就越大，最终导致读取和搜索速度变慢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ElasticSearch 可实现的 ops/sec 从 0% 更新到 50% 的演变，我们注意到它在 0% 更新基准上以 10k Ops/sec 开始，并受到严重影响，减少了 5 倍的 ops/sec，在50% 更新率基准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与我们在上述单个操作基准中观察到的类似，MongoDB 搜索性能比 RedisJSON* 和 ElasticSearch 慢两个数量级，MongoDB 的最大总吞吐量为 424 ops/sec，而 RedisJSON* 为 16K 最大 ops/sec。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，对于混合工作负载，RedisJSON* 支持的操作数/秒比 MongoDB 高 50.8 倍，比 ElasticSearch 高 7 倍。如果我们将分析集中在混合工作负载期间的每种操作类型的延迟上，与 MongoDB 相比，RedisJSON* 可将延迟降低多达 91 倍，与 ElasticSearch 相比，延迟降低 23.7 倍。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.5 完整延迟分析&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与测量每个解决方案饱和之前产生的吞吐量曲线类似，在所有解决方案通用的可持续负载下进行完整的延迟分析也很重要。这将使您能够了解对于所有已发布操作在延迟方面最稳定的解决方案是什么，以及哪种解决方案不易受到应用程序逻辑引发的延迟峰值的影响（例如，弹性查询缓存未命中）。如果您想更深入地了解我们为什么要这样做，Gil Tene 提供了延迟测量注意事项的深入概述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看上一节的吞吐量图表，并关注 10% 更新基准以包含所有三个操作，我们做了两种不同的可持续负载变化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;250 ops/sec&lt;/code&gt;：比较 MongoDB、ElasticSearch 和 RedisJSON*，低于 MongoDB 的压力率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;6000 ops/sec&lt;/code&gt;：比较 ElasticSearch 和 RedisJSON*，低于 ElasticSearch 压力率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.5.1 MongoDB 与 ElasticSearch 与 RedisJSON* 的延迟分析&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的第一张图片中，展示了从 p0 到 p9999 的百分位数，很明显，在每次搜索时，MongoDB 的表现都远远优于 Elastic 和 RedisJSON*。此外，关注 ElasticSearch 与 RedisJSON*，很明显，ElasticSearch 容易受到较高延迟的影响，这很可能是由垃圾收集 (GC) 触发器或搜索查询缓存未命中引起的。RedisJSON* 的 p99 低于 2.61 毫秒，而 ElasticSearch p999 搜索达到 10.28 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPamMciadBgPHDmLiccSI4yjZVnT3qmicwicBCpLT4TUtwhByal5ibvdpJAc2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的读取和更新图表中，我们可以看到 RedisJSON* 在所有延迟范围内表现最佳，其次是 MongoDB 和 ElasticSearch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 是在所有分析的延迟百分位数上保持亚毫秒级延迟的唯一解决方案。在 p99，RedisJSON* 的延迟为 0.23 毫秒，其次是 MongoDB 的 5.01 毫秒和 ElasticSearch 的 10.49 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPa21IxrTZq3EZ5RNhkdkZJ6tBSA2ib02oL3ZTKbIoicuGWB3Ifg2PMDvZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写入时，MongoDB 和 RedisJSON* 即使在 p99 时也能保持亚毫秒级的延迟。另一方面，ElasticSearch 显示出高尾延迟（&amp;gt; 10 毫秒），这很可能与导致 ElasticSearch 搜索峰值的原因 (GC) 相同。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPaN3wJG6QwM8EJhdiaxWj1Wuek8icY5qIAgEDpiavJWE4YibzTEa2IE9Riadg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.5.2 ElasticSearch 与 RedisJSON 的延迟分析&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅关注 ElasticSearch 和 RedisJSON*，在保持 6K ops/sec 的可持续负载的同时，我们可以观察到 Elastic 和 RedisJSON* 的读取和更新模式与以 250 ops/sec 进行的分析保持一致。RedisJSON* 是更稳定的解决方案，其 p99 读取时间为 3 毫秒，而 Elastic 的 p99 读取时间为 162 毫秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新时，RedisJSON* 保留了 3 毫秒的 p99，而 ElasticSearch 则保留了 167 毫秒的 p99。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPa91wsOia0IicwBGgGoUrPdcDPjbgGUJM7NsOfYubu55aibLclt1hibYDLuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPaP1K5h3Ck7gffwicbYn2upvZHca35CS3tZiaQX4msa2P8bgNUicJRr9ibmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;专注于搜索操作，ElasticSearch 和 RedisJSON* 以个位数 p50 延迟开始（p50 RedisJSON* 为 1.13 毫秒，而 ElasticSearch 的 p50 为 2.79 毫秒），其中 ElasticSearch 付出了 GC 触发和查询缓存未命中的代价在较高的百分位数上，在 &amp;gt;= p90 百分位数上清晰可见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 将 p99 保持在 33 毫秒以下，而 ElasticSearch 上的 p99 百分位数为 163 毫秒，高出 5 倍。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJQJWCvJQRVSibnc5turTKPaj6DCL0qdbWusejWHpvX2z7Xdu6mvY3DwYjYCLEBZNKQ5ZrMD16Dz8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>da4e46faa80112f52f437e7c44d744b9</guid>
<title>吐血推荐17个提升开发效率的“轮子”</title>
<link>https://toutiao.io/k/10u7n9b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gEUIHd7HFBm8mgd6RiavSHC3iaDgONobX3XIWtLZw2jHzLoqHBz9HpWiacGZMYqjKU41o1trASibVM6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：&lt;code&gt;轮子&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我决定把一些压箱底的小工具，分享给大家，希望对你有所帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文会分享17个我们日常工作中一定会用得到的小工具。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能。&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/YunaiV/ruoyi-vue-pro&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先出场的是&lt;code&gt;java.util&lt;/code&gt;包下的&lt;code&gt;Collections&lt;/code&gt;类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工作中经常有对集合排序的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看使用&lt;code&gt;Collections&lt;/code&gt;工具是如何实现升序和降序的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;  list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;  Collections.sort(list);&lt;span&gt;//升序&lt;/span&gt;&lt;br/&gt;  System.out.println(list);&lt;br/&gt;  Collections.reverse(list);&lt;span&gt;//降序&lt;/span&gt;&lt;br/&gt;  System.out.println(list);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候需要找出集合中的&lt;code&gt;最大值&lt;/code&gt;或者&lt;code&gt;最小值&lt;/code&gt;，这时可以使用Collections的&lt;code&gt;max&lt;/code&gt;和&lt;code&gt;min&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;Integer max = Collections.max(list);&lt;span&gt;//获取最大值&lt;/span&gt;&lt;br/&gt;Integer min = Collections.min(list);&lt;span&gt;//获取最小值&lt;/span&gt;&lt;br/&gt;System.out.println(max);&lt;br/&gt;System.out.println(min);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，这些集合在多线程的环境中，添加数据会出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，可以用Collections的&lt;code&gt;synchronizedxxx&lt;/code&gt;方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;  list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  List&amp;lt;Integer&amp;gt; integers = Collections.synchronizedList(list);&lt;span&gt;//将ArrayList转换成线程安全集合&lt;/span&gt;&lt;br/&gt;  System.out.println(integers);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的底层会创建&lt;code&gt;SynchronizedRandomAccessList&lt;/code&gt;或者&lt;code&gt;SynchronizedList&lt;/code&gt;类，这两个类的很多方法都会用&lt;code&gt;synchronized&lt;/code&gt;加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，我们在判空之后，需要返回空集合，就可以使用&lt;code&gt;emptyList&lt;/code&gt;方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (list == &lt;span&gt;null&lt;/span&gt; || list.size() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Collections.emptyList();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//业务处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;binarySearch&lt;/code&gt;方法提供了一个非常好用的&lt;code&gt;二分查找&lt;/code&gt;功能，只用传入指定集合和需要找到的key即可。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; i = Collections.binarySearch(list, &lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//二分查找&lt;/span&gt;&lt;br/&gt;System.out.println(i );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的&lt;code&gt;unmodifiablexxx&lt;/code&gt;方法就能轻松实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; integers = Collections.unmodifiableList(list);&lt;br/&gt;integers.add(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;System.out.println(integers);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.UnsupportedOperationException&lt;br/&gt; at java.util.Collections$UnmodifiableCollection.add(Collections.java:&lt;span&gt;1055&lt;/span&gt;)&lt;br/&gt; at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:&lt;span&gt;19&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhX8BflOYas3SicLTLLxxGI9gRNEhmtG6LWX7N3xA5iaicqIDJC3q9jP8wQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9537037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhEZoGXa23Xw1JibibNO6ibLI2vBlxv3SxNEHDibFdTUmib2mgshUjFBjg1vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba 。&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/YunaiV/onemall&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对集合操作，除了前面说的&lt;code&gt;Collections&lt;/code&gt;工具类之后，&lt;code&gt;CollectionUtils&lt;/code&gt;工具类也非常常用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前比较主流的是&lt;code&gt;spring&lt;/code&gt;的&lt;code&gt;org.springframework.util&lt;/code&gt;包下的CollectionUtils工具类。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.674074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhJvoort7hZkFwfREJMFq6YeHYly4brlia3zsANmBZMOKvA6ep98GILNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;code&gt;apache&lt;/code&gt;的&lt;code&gt;org.apache.commons.collections&lt;/code&gt;包下的CollectionUtils工具类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhkhTKCXIEcqzSGAU6EtiaQfyw7xWibc2VSIoPL7huiaK9VOCgGeOGbr8JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uhn5zDWiaEWtfcWKgMn47uOMicL4Z4tibG7PgH5PspZqGgW5h8qA0htt0lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我个人更推荐使用apache的包下的CollectionUtils工具类，因为它的工具更多更全面。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个简单的例子，&lt;code&gt;spring&lt;/code&gt;的CollectionUtils工具类没有判断集合不为空的方法。而&lt;code&gt;apache&lt;/code&gt;的CollectionUtils工具类却有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们以&lt;code&gt;apache&lt;/code&gt;的CollectionUtils工具类为例，介绍一下常用方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过CollectionUtils工具类的&lt;code&gt;isEmpty&lt;/code&gt;方法可以轻松判断集合是否为空，&lt;code&gt;isNotEmpty&lt;/code&gt;方法判断集合不为空。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(list)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;集合为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (CollectionUtils.isNotEmpty(list)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;集合不为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list2.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list2.add(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取并集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; unionList = CollectionUtils.union(list, list2);&lt;br/&gt;System.out.println(unionList);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取交集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; intersectionList = CollectionUtils.intersection(list, list2);&lt;br/&gt;System.out.println(intersectionList);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取交集的补集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; disjunctionList = CollectionUtils.disjunction(list, list2);&lt;br/&gt;System.out.println(disjunctionList);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取差集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; subtractList = CollectionUtils.subtract(list, list2);&lt;br/&gt;System.out.println(subtractList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你引入&lt;code&gt;com.google.guava&lt;/code&gt;的pom文件，会获得很多好用的小工具。这里推荐一款&lt;code&gt;com.google.common.collect&lt;/code&gt;包下的集合工具：&lt;code&gt;Lists&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是在太好用了，让我爱不释手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们想创建一个空集合。这时可以用Lists的&lt;code&gt;newArrayList&lt;/code&gt;方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将两个集合做&lt;code&gt;笛卡尔积&lt;/code&gt;，Lists的&lt;code&gt;cartesianProduct&lt;/code&gt;方法可以帮你实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list1 = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;List&amp;lt;Integer&amp;gt; list2 = Lists.newArrayList(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; productList = Lists.cartesianProduct(list1,list2);&lt;br/&gt;System.out.println(productList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;], [&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将一个&lt;code&gt;大集合&lt;/code&gt;分成若干个&lt;code&gt;小集合&lt;/code&gt;，可以使用Lists的&lt;code&gt;partition&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.partition(list, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;System.out.println(partitionList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;5&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我最喜欢的方法之一，经常在项目中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想把某个集合转换成另外一个接口，可以使用Lists的&lt;code&gt;transform&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;List&amp;lt;String&amp;gt; transformList = Lists.transform(list, x -&amp;gt; x.toUpperCase());&lt;br/&gt;System.out.println(transformList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将小写字母转换成了大写字母。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lists的有颠倒顺序的方法&lt;code&gt;reverse&lt;/code&gt;。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;List&amp;lt;Integer&amp;gt; reverseList = Lists.reverse(list);&lt;br/&gt;System.out.println(reverseList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;list的原始顺序是312，使用&lt;code&gt;reverse&lt;/code&gt;方法颠倒顺序之后，变成了213。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7861111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhlSZTfIOibDn3ZqZlxbtwGtUkIYcUtYIZ3R6S05et6jI0icjjHwqzHxLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;jdk7&lt;/code&gt;之后，提供了&lt;code&gt;Objects&lt;/code&gt;工具类，我们可以通过它操作对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中万事万物皆对象，对象的判空可以说无处不在。Objects的&lt;code&gt;isNull&lt;/code&gt;方法判断对象是否为空，而&lt;code&gt;nonNull&lt;/code&gt;方法判断对象是否不为空。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (Objects.isNull(integer)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;对象为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (Objects.nonNull(integer)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;对象不为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想在对象为空时，抛出空指针异常，可以使用Objects的&lt;code&gt;requireNonNull&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;128&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Objects.requireNonNull(integer1);&lt;br/&gt;Objects.requireNonNull(integer1, &lt;span&gt;&quot;参数不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Objects.requireNonNull(integer1, () -&amp;gt; &lt;span&gt;&quot;参数不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常需要判断两个对象是否相等，Objects给我们提供了&lt;code&gt;equals&lt;/code&gt;方法，能非常方便的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer integer2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(Objects.equals(integer1, integer2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但使用这个方法有坑，比如例子改成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Long integer2 = &lt;span&gt;new&lt;/span&gt; Long(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(Objects.equals(integer1, integer2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体原因不细说了，有兴趣的小伙们可以看看我的另一篇文章《Objects.equals有坑》，里面有非常详细的讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个对象的hashCode，可以使用Objects的&lt;code&gt;hashCode&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(Objects.hashCode(str));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;96354&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Objects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.662004662004662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uhlt1anvibHLapehvbqN7QTgLf4SRaj59QN0qEU2zpW3LM6tj4RkibsTaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中布尔值，随处可见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用了布尔的包装类：&lt;code&gt;Boolean&lt;/code&gt;，总感觉有点麻烦，因为它有三种值：&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;。我们在处理Boolean对象时，需要经常判空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;头疼！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用&lt;code&gt;BooleanUtils&lt;/code&gt;类处理布尔值，心情一下子就愉悦起来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个参数的值是true或false，可以直接使用&lt;code&gt;isTrue&lt;/code&gt;或&lt;code&gt;isFalse&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;System.out.println(BooleanUtils.isTrue(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.isFalse(aBoolean));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;isNotTrue&lt;/code&gt;或&lt;code&gt;isNotFalse&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Boolean aBoolean1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;System.out.println(BooleanUtils.isNotTrue(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.isNotTrue(aBoolean1));&lt;br/&gt;System.out.println(BooleanUtils.isNotFalse(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.isNotFalse(aBoolean1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将true转换成数字1，false转换成数字0，可以使用&lt;code&gt;toInteger&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Boolean aBoolean1 = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;System.out.println(BooleanUtils.toInteger(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.toInteger(aBoolean1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有时候需要将包装类&lt;code&gt;Boolean&lt;/code&gt;对象，转换成原始的&lt;code&gt;boolean&lt;/code&gt;对象，可以使用&lt;code&gt;toBoolean&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Boolean aBoolean1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;System.out.println(BooleanUtils.toBoolean(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.toBoolean(aBoolean1));&lt;br/&gt;System.out.println(BooleanUtils.toBooleanDefaultIfNull(aBoolean1, &lt;span&gt;false&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.124074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh2MZD07FW7NXXcUy0icracXNDicYLQE5M4myUdgnWpWbqLFcYWnPRKfRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;字符串&lt;/code&gt;（String）在我们的日常工作中，用得非常非常非常多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有个好消息是：&lt;code&gt;org.apache.commons.lang3&lt;/code&gt;包下的&lt;code&gt;StringUtils&lt;/code&gt;工具类，给我们提供了非常丰富的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实空字符串，不只是null一种，还有&quot;&quot;，&quot; &quot;，&quot;null&quot;等等，多种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringUtils给我们提供了多个判空的静态方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; String str1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;String str2 = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;String str3 = &lt;span&gt;&quot; &quot;&lt;/span&gt;;&lt;br/&gt;String str4 = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(StringUtils.isEmpty(str1));&lt;br/&gt;System.out.println(StringUtils.isEmpty(str2));&lt;br/&gt;System.out.println(StringUtils.isEmpty(str3));&lt;br/&gt;System.out.println(StringUtils.isEmpty(str4));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str1));&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str2));&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str3));&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str4));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.isBlank(str1));&lt;br/&gt;System.out.println(StringUtils.isBlank(str2));&lt;br/&gt;System.out.println(StringUtils.isBlank(str3));&lt;br/&gt;System.out.println(StringUtils.isBlank(str4));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str1));&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str2));&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str3));&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str4));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;=====&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;=====&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;=====&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的：&lt;code&gt;isEmpty&lt;/code&gt;、&lt;code&gt;isNotEmpty&lt;/code&gt;、&lt;code&gt;isBlank&lt;/code&gt;和&lt;code&gt;isNotBlank&lt;/code&gt;，这4个判空方法你们可以根据实际情况使用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;优先推荐使用&lt;code&gt;isBlank&lt;/code&gt;和&lt;code&gt;isNotBlank&lt;/code&gt;方法，因为它会把&lt;code&gt;&quot; &quot;&lt;/code&gt;也考虑进去。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;System.out.println(StringUtils.split(str1,&lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(str1.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.NullPointerException&lt;br/&gt; at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:&lt;span&gt;21&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个字符串，判断它是否为纯数字，可以使用&lt;code&gt;isNumeric&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str1 = &lt;span&gt;&quot;123&quot;&lt;/span&gt;;&lt;br/&gt;String str2 = &lt;span&gt;&quot;123q&quot;&lt;/span&gt;;&lt;br/&gt;String str3 = &lt;span&gt;&quot;0.33&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(StringUtils.isNumeric(str1));&lt;br/&gt;System.out.println(StringUtils.isNumeric(str2));&lt;br/&gt;System.out.println(StringUtils.isNumeric(str3));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用&lt;code&gt;join&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;List&amp;lt;Integer&amp;gt; list2 = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.join(list, &lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(StringUtils.join(list2, &lt;span&gt;&quot; &quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a,b,c&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然还有很多实用的方法，我在这里就不一一介绍了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhlvMeG2HrX8aImcgnc0d207UpHbDEHg5tVouHiaqAYGILl2UIfWxPticA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9953703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhthmcPYsBNKDqLx5joUwlSE3tkwe3LYHSNcIMiaupuiamsQ2pibzXyzrXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有统一的封装呢?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;spring&lt;/code&gt;给我们提供了&lt;code&gt;Assert&lt;/code&gt;类，它表示&lt;code&gt;断言&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言&lt;code&gt;参数&lt;/code&gt;是否空，如果不满足条件，则直接抛异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Assert.isNull(str, &lt;span&gt;&quot;str必须为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.isNull(str, () -&amp;gt; &lt;span&gt;&quot;str必须为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.notNull(str, &lt;span&gt;&quot;str不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不满足条件就会抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言&lt;code&gt;集合&lt;/code&gt;是否空，如果不满足条件，则直接抛异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Map&amp;lt;String, String&amp;gt; map = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Assert.notEmpty(list, &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.notEmpty(list, () -&amp;gt; &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.notEmpty(map, &lt;span&gt;&quot;map不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不满足条件就会抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言是否满足某个&lt;code&gt;条件&lt;/code&gt;，如果不满足条件，则直接抛异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Assert.isTrue(CollectionUtils.isNotEmpty(list), &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.isTrue(CollectionUtils.isNotEmpty(list), () -&amp;gt; &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然Assert类还有一些其他的功能，这里就不多介绍了。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2472222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh7OKzquJaWkfLd8Ih6ibUNPStj7vQCWVicBEOXNQGuIhJbNYkgSNZwmtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO&lt;/code&gt;流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在&lt;code&gt;finally&lt;/code&gt;代码块中关闭流，不然可能会造成&lt;code&gt;内存溢出&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个好消息是：如果你使用&lt;code&gt;org.apache.commons.io&lt;/code&gt;包下的&lt;code&gt;IOUtils&lt;/code&gt;类，会节省大量的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的&lt;code&gt;toString&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = IOUtils.toString(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;/temp/a.txt&quot;&lt;/span&gt;), StandardCharsets.UTF_8);&lt;br/&gt;System.out.println(str);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的&lt;code&gt;write&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;&quot;abcde&quot;&lt;/span&gt;;&lt;br/&gt;IOUtils.write(str, &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;&quot;/temp/b.tx&quot;&lt;/span&gt;), StandardCharsets.UTF_8);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的&lt;code&gt;copy&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;IOUtils.copy(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;/temp/a.txt&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;&quot;/temp/b.txt&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的&lt;code&gt;toByteArray&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = IOUtils.toByteArray(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;/temp/a.txt&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1564814814814814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh6HLLwUBK302H4peAUR5BWpicqf2xReNPOKtzvCRRfkNdHEORYC9ePWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MDC&lt;/code&gt;是&lt;code&gt;org.slf4j&lt;/code&gt;包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MDC的底层是用了&lt;code&gt;ThreadLocal&lt;/code&gt;来保存数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用它传递参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如现在有这样一种场景：我们使用&lt;code&gt;RestTemplate&lt;/code&gt;调用远程接口时，有时需要在&lt;code&gt;header&lt;/code&gt;中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种业务场景就能通过&lt;code&gt;ClientHttpRequestInterceptor&lt;/code&gt;接口实现，具体做法如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;        MdcUtil.add(UUID.randomUUID().toString());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;记录请求日志&quot;&lt;/span&gt;);&lt;br/&gt;        chain.doFilter(request, response);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;记录响应日志&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，实现&lt;code&gt;ClientHttpRequestInterceptor&lt;/code&gt;接口，MDC中获取当前请求的traceId，然后设置到header中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RestTemplateInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ClientHttpRequestInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ClientHttpResponse &lt;span&gt;intercept&lt;/span&gt;&lt;span&gt;(HttpRequest request, &lt;span&gt;byte&lt;/span&gt;[] body, ClientHttpRequestExecution execution)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        request.getHeaders().set(&lt;span&gt;&quot;traceId&quot;&lt;/span&gt;, MdcUtil.get());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; execution.execute(request, body);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，定义配置类，配置上面定义的&lt;code&gt;RestTemplateInterceptor&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RestTemplateConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RestTemplate &lt;span&gt;restTemplate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; restTemplate;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RestTemplateInterceptor &lt;span&gt;restTemplateInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RestTemplateInterceptor();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MdcUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TRACE_ID = &lt;span&gt;&quot;TRACE_ID&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; MDC.get(TRACE_ID);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(String value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        MDC.put(TRACE_ID, value);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring的&lt;code&gt;org.springframework.util&lt;/code&gt;包下的&lt;code&gt;ClassUtils&lt;/code&gt;类，它里面有很多让我们惊喜的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面包含了类和对象相关的很多非常实用的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个对象的所有接口，可以使用ClassUtils的&lt;code&gt;getAllInterfaces&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Class&amp;lt;?&amp;gt;[] allInterfaces = ClassUtils.getAllInterfaces(&lt;span&gt;new&lt;/span&gt; User());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的包名，可以使用ClassUtils的&lt;code&gt;getPackageName&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String packageName = ClassUtils.getPackageName(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;System.out.println(packageName);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个类是否内部类，可以使用ClassUtils的&lt;code&gt;isInnerClass&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(ClassUtils.isInnerClass(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断对象是否代理对象，可以使用ClassUtils的&lt;code&gt;isCglibProxy&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(ClassUtils.isCglibProxy(&lt;span&gt;new&lt;/span&gt; User()));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1703703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhTRglsYWZUMgjjMz4ibx9gP2ian6NXcTWRoVolQxchSy2PibQv7e47rI4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring给我们提供了一个&lt;code&gt;JavaBean&lt;/code&gt;的工具类，它在&lt;code&gt;org.springframework.beans&lt;/code&gt;包下面，它的名字叫做：&lt;code&gt;BeanUtils&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们一起看看这个工具可以带给我们哪些惊喜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的&lt;code&gt;copyProperties&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user1 = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;user1.setId(&lt;span&gt;1L&lt;/span&gt;);&lt;br/&gt;user1.setName(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;user1.setAddress(&lt;span&gt;&quot;成都&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;User user2 = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;BeanUtils.copyProperties(user1, user2);&lt;br/&gt;System.out.println(user2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想通过反射实例化一个类的对象，可以使用BeanUtils的&lt;code&gt;instantiateClass&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = BeanUtils.instantiateClass(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;System.out.println(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的指定方法，可以使用BeanUtils的&lt;code&gt;findDeclaredMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method declaredMethod = BeanUtils.findDeclaredMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;System.out.println(declaredMethod.getName());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个方法的参数，可以使用BeanUtils的&lt;code&gt;findPropertyForMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method declaredMethod = BeanUtils.findDeclaredMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;PropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);&lt;br/&gt;System.out.println(propertyForMethod.getName());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对BeanUtils比较感兴趣，可以看看下面内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh9yaXjxBwHETxoS3Bhkak1fV1Ngoa8b2yANQtbgCwMBiaYXu11FbMtKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要在项目中使用&lt;code&gt;反射&lt;/code&gt;功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好消息是spring给我们提供了一个&lt;code&gt;ReflectionUtils&lt;/code&gt;工具，它在&lt;code&gt;org.springframework.util&lt;/code&gt;包下面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的某个方法，可以使用ReflectionUtils类的&lt;code&gt;findMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method method = ReflectionUtils.findMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的某个字段，可以使用ReflectionUtils类的&lt;code&gt;findField&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Field field = ReflectionUtils.findField(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;id&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的&lt;code&gt;invokeMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个字段是否常量，可以使用ReflectionUtils类的&lt;code&gt;isPublicStaticFinal&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Field field = ReflectionUtils.findField(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;id&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;System.out.println(ReflectionUtils.isPublicStaticFinal(field));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的&lt;code&gt;isEqualsMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method method = ReflectionUtils.findMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;System.out.println(ReflectionUtils.isEqualsMethod(method));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh10pfOquMyQP1hFAdje31XPnbDq1jib5IlKRZKxa6ia8n9jEHatCnIkAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，为了安全考虑，需要将参数只用&lt;code&gt;base64&lt;/code&gt;编码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就能直接使用&lt;code&gt;org.springframework.util&lt;/code&gt;包下的&lt;code&gt;Base64Utils&lt;/code&gt;工具类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面包含：&lt;code&gt;encode&lt;/code&gt;和&lt;code&gt;decode&lt;/code&gt;方法，用于对数据进行加密和解密。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;String encode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.encode(str.getBytes()));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;加密后：&quot;&lt;/span&gt; + encode);&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    String decode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.decode(encode.getBytes()), &lt;span&gt;&quot;utf8&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;解密后：&quot;&lt;/span&gt; + decode);&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (UnsupportedEncodingException e) {&lt;br/&gt;    e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;加密后：YWJj&lt;br/&gt;解密后：abc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就可以直接使用&lt;code&gt;java.nio.charset&lt;/code&gt;包下的&lt;code&gt;StandardCharsets&lt;/code&gt;类中静态变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;String encode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.encode(str.getBytes()));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;加密后：&quot;&lt;/span&gt; + encode);&lt;br/&gt;String decode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.decode(encode.getBytes())&lt;br/&gt;, StandardCharsets.UTF_8);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;解密后：&quot;&lt;/span&gt; + decode);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要对数据进行加密处理，比如：md5或sha256。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用apache的&lt;code&gt;org.apache.commons.codec.digest&lt;/code&gt;包下的&lt;code&gt;DigestUtils&lt;/code&gt;类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想对数据进行md5加密，可以使用DigestUtils的&lt;code&gt;md5Hex&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String md5Hex = DigestUtils.md5Hex(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(md5Hex);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想对数据进行sha256加密，可以使用DigestUtils的&lt;code&gt;sha256Hex&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String md5Hex = DigestUtils.sha256Hex(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(md5Hex);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个工具还有很多其他的加密方法：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.643020594965675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh0COn42SKmKwZyzRzR2s9TCuUpjVtoIJWpWFsrMBw3pS2TcUrkmOYVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要把数据进行&lt;code&gt;序列化&lt;/code&gt;和&lt;code&gt;反序列化&lt;/code&gt;处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的做法是某个类实现&lt;code&gt;Serializable&lt;/code&gt;接口，然后重新它的&lt;code&gt;writeObject&lt;/code&gt;和&lt;code&gt;readObject&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用&lt;code&gt;org.springframework.util&lt;/code&gt;包下的&lt;code&gt;SerializationUtils&lt;/code&gt;工具类，能更轻松实现序列化和反序列化功能。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Map&amp;lt;String, String&amp;gt; map = Maps.newHashMap();&lt;br/&gt;map.put(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;map.put(&lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;map.put(&lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] serialize = SerializationUtils.serialize(map);&lt;br/&gt;Object deserialize = SerializationUtils.deserialize(serialize);&lt;br/&gt;System.out.println(deserialize);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SUCCESS_CODE = &lt;span&gt;200&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ERROR_CODE = &lt;span&gt;500&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NOT_FOUND_CODE = &lt;span&gt;404&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;org.springframework.http&lt;/code&gt;包下的HttpStatus枚举，或者&lt;code&gt;org.apache.http&lt;/code&gt;包下的&lt;code&gt;HttpStatus&lt;/code&gt;接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4363207547169812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uhnr3IxBZGY6uFB1zPlcf2xawdhPRNPwLcepicVvQ53yHu5CsQDO4YaxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的内容分享到这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作当中还有很多好用的小工具，欢迎在下方留言。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0dc2b5377ae60ba106a1da96814b2684</guid>
<title>设计一个高质量的 API 接口</title>
<link>https://toutiao.io/k/19ochdr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;上方蓝色“&lt;/span&gt;&lt;span&gt;程序员追风&lt;/span&gt;&lt;span&gt;”，选择“设为星标”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;回复“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;资料&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”获取整理好的&lt;/span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;面试资料&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;blog.csdn.net/weixin_43318367/article/details/108746057&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你是否也感同身受？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对接XX业务时，XX业务具备的功能和API全靠跑业务负责人那反复逐个询问、确认。用哪个API；怎么用；有没有限制；等等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;各个业务间，甚至同一业务内，API风格不统一。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;API命名：&lt;/strong&gt; 按自然语义全翻译的；按属性角度定义的；按操作角度定义的；动宾、非动宾的；复数、非复数的；等等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;API入参：&lt;/strong&gt; 带Map的；相同语义字段名称不一样；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;API出参：&lt;/strong&gt; 有包装Resoponse的；直接返回结果数据的；相同数据，返回格式和字段名称有差别的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;错误信息：&lt;/strong&gt; 直接返回中文提示的；返回提示信息编码的；返回异常类型的；等等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;XX业务API性能方面未知。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着业务的演进，开放的API持续在增加，但类同的很多&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;API编码规范迫在眉睫&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;优秀API的特质&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;自解释&lt;/span&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从API本身一眼就能看懂API是干什么的，支持的用法，适用的场景，异常的处理等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;易学习&lt;/span&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有完善的文档，以及提供尽可能多的示例和可copy－paste的代码。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;易使用&lt;/span&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;功能强大，但使用简单。不增加调用方的使用成本（例如要求业务方用API时需要额外的配置和依赖），不暴露复杂的细节、冗长的使用流程给调用方感知。调用方只做最小的感知和最少的传参。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;难误用&lt;/span&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优秀的API可以使有经验的开发直接使用API而不需要阅读文档。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;充分的静态检查、动态校验、显式的异常说明、有效的错误提示。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;API 设计原则&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 充分原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不是随便一个功能就要有个接口，也不是随便一个需求就要加个接口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每新建一个接口，要有充分的理由和考虑，即这个接口的存在是十分有意义和价值的。无意义的接口不仅增加了维护的难度，更重要是对于程序的可控性的大大降低，接口也会十分臃肿。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 单一视角原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计接口时，分析的角度要统一。否则会造成接口结构的混乱。例如：不要一会以角色的角度设计，一会儿就要以功能的角度设计。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐：以&quot;属性对象 + 行为&quot;的视角定义API&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 单一功能原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个API接口应该只专注一件事，并做好。产品概念简单、关系清楚。功能模棱两可，诸多特殊逻辑的API肯定不是个优雅的API，且会造成功能类似重复的API。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注：如果API它很难命名，那么这或许是个不好的征兆，好的名称可以驱动开发、并且只需拆分与合并模块即可。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;功能大而全的API在灵活性、简单性方面肯定捉襟见肘。定义API的粒度之前，建议先将业务分领域、划边界，以此来提取业务对象，然后再根据业务对象用例来设计单一功能的API。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如：查询会员，可能除了查询会员表外还要获取该会员的其他必要信息，但不要在查询会员的同时还有修改权限等类似的其他业务功能，应该分成两个接口执行。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 简单原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口设计简单、清晰。API执行的功能可以很丰富、很强大，但API声明和用法一定要尽量的简单，不能将功能的丰富通过复杂的用法来实现，这会导致API功能不单一，演进不可控。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最终的评审要看API的简单易用程度。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你写的例子，能不能让你的代码看起来更简单？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你是不是强迫调用方关注/提供他们不在乎的选项/配置？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有没有毫无价值的额外步骤？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;编写的代码一定要易于读、易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 抽象原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API的入参、出参所述的对象、属性，一定是按业务特性进行抽象后的实体。误将底层数据模型概念如实的反应到API上。抽象API、抽象对象实体更宏观，具有更好的适用性、兼容性、扩展性。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 兼容扩展原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对扩展开放，对修改关闭。保证API的向后兼容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扩展参数应当是便利的，保证后续类似的需求，可以在已有的API上通过兼容扩展的方式实现。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 最小惊讶原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码应该尽可能减少让读者惊喜。业务API只需根据需求来设计即可，不需要刻意去设计一下复杂无用、华而不实的API，以免弄巧成拙。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8. 低耦合原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API应该减少对其他业务代码的依赖关系。低耦合往往是完美结构系统和优秀设计的标志。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;耦合的种类：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;代码实现业务逆向调用。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;条件逻辑依赖耦合。&lt;/strong&gt; 例如：此API在处理国税网超订单类型时，需要额外发送结算支付凭证上传的事件MQ出来。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;耦合API无关的业务行为。&lt;/strong&gt; 例如：采购计划链路日志API被调用时，若是项目采购委托单的情况，需要额外调用公告的API拉取链路信息，新建成为一条此委托单的一条链路日志。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9. 正交原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正交性是指改变某个特性而不会影响到其他的特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API之间的功能应该成正交性，无功能重合。API之间应该是互相补充的关系。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10. 易测试原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于API调用者而言，API应该是可被测试且易于被测试的。测试API不需要依赖额外的环境、容器、配置、公共服务等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对可测试友好的API也是可被有效集成测试的前提。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11. 统一原则&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;API要具备统一的命名、统一的入/出参规范、统一的异常规范、统一的错误码规范、统一的版本规范等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统一规范的API优点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;易于被框架集成、处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有助于API调用方、API提供方开发经验复用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;避免犯错，避免误用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNjg4MzY4NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/x0kXIOa6owURbBxemzQyQibDwXyic5Ow5cWU9S4aVnOfu7MLneQq36qB7rfJ90MJ9cibibULaDvWx0jqe2eWz0Niceg/0?wx_fmt=png&quot; data-nickname=&quot;程序员追风&quot; data-alias=&quot;&quot; data-signature=&quot;专注于分享Java各类学习笔记、面试题以及IT类资讯。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/xe4FY1hGDmq17JSGmvlibgJjT73DIFV5hNpPbbL7bDtKBKyOka9bl1LLiam25MusZplIsuk5l0zQW2Pg1WhvCRJw/?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;193&quot; data-cropy1=&quot;63&quot; data-cropy2=&quot;246&quot; data-fileid=&quot;100013684&quot; data-ratio=&quot;0.9583333333333334&quot; data-type=&quot;jpeg&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xe4FY1hGDmq17JSGmvlibgJjT73DIFV5hkricMTLpuRLmhy0OV8C9hGF9CkdmvficOyYXtfZcNTbYGgibtSSGd3zmw/640?wx_fmt=jpeg&quot;/&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;你在看吗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e71cdf89e0014441b998e1ebb87eaa2</guid>
<title>吴恩达：机器学习的六个核心算法</title>
<link>https://toutiao.io/k/7s61wih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin-right: 16px; margin-left: 16px; padding-right: 0em; padding-left: 0em; outline: 0px; max-width: 100%; color: rgb(34, 34, 34); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; font-size: 16px; widows: 1; background-color: rgb(255, 255, 255); text-align: right; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)|rgb(136, 136, 136)&quot;&gt;本文转载自 | AI科技评论&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin-right: 16px; margin-left: 16px; padding-right: 0em; padding-left: 0em; outline: 0px; max-width: 100%; color: rgb(34, 34, 34); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; font-size: 16px; widows: 1; background-color: rgb(255, 255, 255); text-align: right; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;span data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)|rgb(136, 136, 136)&quot;&gt;编译 | 黄楠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，吴恩达在其创办的人工智能周讯《The Batch》上更新了一篇博文，总结了机器学习领域多个基础算法的历史溯源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章开头，吴恩达回忆他的研究历程中曾有一次抉择：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多年前，在一次项目中，选择算法时，他不得不在神经网络与决策树学习算法之间做选择。考虑到计算预算，他最终选择了神经网络，在很长的一段时间内弃用增强决策树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个错误的决定，「幸好我的团队很快修改了我的选择，项目才成功。」吴恩达谈道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他由此感叹，不断学习与更新基础知识是十分重要的。与其他技术领域一样，随着研究人员的增加、研究成果数量的增长，机器学习领域也在不断发展。但有些基础算法与核心思想的贡献是经得起时间考验的：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;算法：线性和逻辑回归、决策树等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;概念：正则化、优化损失函数、偏差/方差等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在吴恩达看来，这些算法与概念是许多机器学习模型的核心思想，包括房价预测器、文本-图像生成器（如DALL·E）等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在最新的这篇文章中，吴恩达与团队调研了六种基础算法的来源、用途、演变等，并提供了较为详细的讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这六种算法分别是：线性回归、逻辑回归、梯度下降、神经网络、决策树与k均值聚类算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;1&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『线性回归：直的&amp;amp;窄的』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;线性回归是机器学习中的一个关键的统计方法，但它并非不战而胜。它由两位杰出的数学家提出，但200 年过去了，这个问题仍未解决。长期存在的争议不仅证明了该算法具有出色的实用性，还证明了它的本质十分简单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么线性回归到底是谁的算法呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1805 年，法国数学家 Adrien-Marie Legendre 发表了将一条线拟合到一组点的方法，同时试图预测彗星的位置（天体导航是当时全球商业中最有价值的科学方向，就像今天的人工智能一样）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;540&quot; data-ratio=&quot;1.424802110817942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOfNNUvlUgcVm2RhF8icQmNNOb50QvES1uhJqdO9M3zTp703V1ia6hjRsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot; data-width=&quot;379&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Adrien-Marie Legendre 的素描画像&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四年后，24 岁的德国神童 Carl Friedrich Gauss （高斯）坚称他自 1795 年以来一直在使用它，但认为它太琐碎了，无法写。高斯的主张促使Legendre匿名发表了一份文章，称“一位非常著名的几何学家毫不犹豫地采用了这种方法。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;463&quot; data-ratio=&quot;1.2740740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOJL0SJkvOC6EPy7ib63vO3OceJ9lfibpJW4ylRQOhjAvg9hOmhmlNvBQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-width=&quot;365&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Carl Friedrich Gauss&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;斜率和偏差&lt;/strong&gt;：当结果与影响它的变量之间的关系遵循直线时，线性回归很有用。例如，汽车的油耗与其重量成线性关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;普及的两个步骤&lt;/strong&gt;：该算法立即帮助航海者追踪星星，以及帮助后来的生物学家（尤其是查尔斯·达尔文的堂兄Francis Galton）识别植物和动物的可遗传特征。这两项深入发展释放了线性回归的广泛潜力。1922 年，英国统计学家 Ronald Fisher 和 Karl Pearson 展示了线性回归如何适应相关性和分布的一般统计框架，使其在所有科学中都有用。而且，近一个世纪后，计算机的出现提供了数据和处理能力，可以更大程度地利用它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;应对歧义&lt;/strong&gt;：当然，数据永远不会被完美地衡量，有些变量比其他变量更重要。这些生活事实激发了更复杂的变体。例如，带有正则化的线性回归（也称为「岭回归」，ridge regression）鼓励线性回归模型不要过多地依赖于任何一个变量，或者更确切地说，均匀地依赖于最重要的变量。如果为了简单起见，另一种形式的正则化（L1 而不是 L2）会产生 lasso（压缩估计），鼓励尽可能多的系数为零。换句话说，它学会选择具有高预测能力的变量并忽略其余的。弹性网络结合了这两种类型的正则化。当数据稀疏或特征看起来相关时，它很有用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在每个神经元中&lt;/strong&gt;：现在，简单的版本仍然非常有用。神经网络中最常见的神经元类型是线性回归模型，随后是非线性激活函数，使线性回归成为深度学习的基本组成部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『逻辑回归：跟随曲线』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;曾经有一段时间，逻辑回归只用于对一件事进行分类：如果你喝了一瓶毒药，你可能会被贴上的标签是“活着”还是“死去”呢？时代变了，今天，不仅呼叫紧急服务为这个问题提供了更好的答案，而且逻辑回归也成为了深度学习的核心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;毒物控制&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;逻辑函数可以追溯到 1830 年代，当时比利时统计学家 P.F. Verhulst 发明它来描述人口动态：随着时间的推移，指数增长的初始爆炸随着它消耗可用资源而趋于平缓，从而产生特征逻辑曲线。一个多世纪过去后，美国统计学家 E. B. Wilson 和他的学生 Jane Worcester 又设计了逻辑回归来计算给定有害物质有多少是致命的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;600&quot; data-ratio=&quot;1.5584415584415585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOyicCWGnByS9WB95gsKYhdhuibzJHDC2Dlg1mtldlfCNcrE0wpey6l0DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;385&quot; data-width=&quot;385&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：P.F. Verhulst&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;拟合函数&lt;/strong&gt;：逻辑回归将逻辑函数拟合到数据集，以便预测给定事件（例如，摄入士的宁）发生特定结果（例如，过早死亡）的概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更多结果&lt;/strong&gt;：Verhulst 的工作发现了二元结果的概率，忽略了进一步的可能性，例如中毒受害者可能会进入来世的哪一边。他的继任者扩展了算法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;492&quot; data-ratio=&quot;1.2793136320305052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsO3e3qmxibgZibLlDAM6NUReeIvjn1o6REPmxUeoNoJtkagn14UeGq031w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2098&quot; data-width=&quot;386&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：David Cox&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;多功能曲线&lt;/strong&gt;：逻辑函数以相当准确的方式描述了广泛的现象，因此逻辑回归在许多情况下提供了有用的基线预测。在医学上，它可以估计死亡率和疾病风险。在政治学中，它预测选举的赢家和输家。在经济学中，它预测商业前景。更重要的是，它在各种各样的神经网络中驱动一部分神经元（其中非线性是 Sigmoid 函数）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;3&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『梯度下降：一切都在下坡』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;想象一下黄昏后在山上徒步旅行，发现脚下什么都看不到。而且您的手机电池没电了，因此您无法使用 GPS 应用程序找到回家的路。您可能会通过梯度下降找到最快的路径。小心不要从悬崖上走。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;太阳和地毯：&lt;/strong&gt;梯度下降比通过陡峭的地形下降更有利。1847年，法国数学家Augustin-Louis Cauchy发明了近似恒星轨道的算法。60 年后，他的同胞 Jacques Hadamard 独立开发了它来描述薄而灵活的物体（如地毯）的变形，这可能会使膝盖向下徒步更容易。然而，在机器学习中，它最常见的用途是找到学习算法损失函数的最低点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;388&quot; data-ratio=&quot;1.3857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOHZ3Vk98Rr6FfnhkrNLJYotia1JVdhM9l3X07V6zw7mEHC9tH3J5j7dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;280&quot; data-width=&quot;280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Augustin-Louis Cauchy&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;向下爬&lt;/strong&gt;：经过训练的神经网络提供了一个函数，该函数在给定输入的情况下计算所需的输出。训练网络的一种方法是通过迭代计算实际输出与期望输出之间的差异，然后更改网络的参数值以缩小差异，从而将输出中的损失或误差最小化。梯度下降缩小了差异，将计算损失的函数最小化。网络的参数值相当于地形上的一个位置，损失的是当前高度。随着你的下降，你可以提高网络计算接近所需输出的能力。可见性是有限的，因为在典型的监督学习情况下，该算法仅依赖于网络的参数值和损失函数的梯度或斜率——即你在山上的位置和你脚下的斜率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;卡在山谷里&lt;/strong&gt;：太糟糕了，你的手机没电了，因为算法可能没有把你推到凸山的底部。你可能会陷入由多个山谷（局部最小值）、山峰（局部最大值）、鞍点（鞍点）和高原组成的非凸面景观中。事实上，图像识别、文本生成和语音识别等任务都是非凸的，并且已经出现了梯度下降的许多变体来处理这种情况。例如，该算法可能具有帮助它放大小幅上涨和下跌的动量，从而使其更有可能到达底部。研究人员设计了如此多的变体，以至于看起来优化器的数量与局部最小值一样多。幸运的是，局部最小值和全局最小值往往大致相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最优优化器&lt;/strong&gt;：梯度下降是寻找任一函数的最小值的明确选择。在可以直接计算精确解的情况下——例如，具有大量变量的线性回归任务中——它可以逼近一个值，而且通常速度更快、成本更低。但它确实在复杂的非线性任务中发挥了作用。凭借梯度下降和冒险精神，你可能可以及时赶出山区吃晚饭。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;4&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『神经网络：寻找函数』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;让我们先把这个问题弄清楚：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;大脑不是一个图形处理单元集&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;如果它是的话，那它运行的软件要比典型的人工神经网络复杂得多。而神经网络的灵感来自大脑的结构：一层层相互连接的神经元，每个神经元根据其相邻状态来计算自己的输出，由此产生的一连串活动形成了一个想法——或识别出一张猫的照片。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从生物到人工&lt;/strong&gt;：大脑通过神经元之间相互作用来学习的想法可以追溯到 1873 年，但直到 1943 年，美国神经科学家 Warren McCulloch 和 Walter Pitts 才利用简单的数学规则建立了生物神经网络模型。1958 年，美国心理学家Frank Rosenblatt开发出感测器——这是一种在打卡机上实现的单层视觉网络，旨在为美国海军建立一个硬件版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;307&quot; data-backw=&quot;546&quot; data-height=&quot;641&quot; data-ratio=&quot;0.5622807017543859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOGjmG7tr2UoxFKCJicdKUF3BPWU4PTT1Xt12T4hcRXGmiaNVibBkiaxoCxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot; data-width=&quot;1140&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Frank Rosenblatt&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;越大越好&lt;/strong&gt;：Rosenblatt 的发明只能识别单线分类。之后，乌克兰数学家 Alexey Ivakhnenko 和 Valentin Lapa 通过在任意层数中堆叠神经元网络，克服了这一限制。1985 年，独立工作的法国计算机科学家 Yann LeCun、David Parker 和美国心理学家 David Rumelhart 及其同事，描述了使用反向传播来有效训练此类网络。在新千年的第一个十年中，包括 Kumar Chellapilla、Dave Steinkraus 和 Rajat Raina（与吴恩达合作）在内的研究人员通过使用图形处理单元进一步推动了神经网络的发展，这使得越来越大的神经网络能从互联网生成的海量数据中得到学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;适合每项任务&lt;/strong&gt;：神经网络背后的原理很简单：对于任何任务，都有一个可执行它的函数。一个神经网络通过组合多个简单函数构成可训练函数，每个函数由单个神经元执行。一个神经元的功能由称为「权重」的可调参数决定。给定这些权重和输入示例及其所需输出的随机值，就可以反复更改权重，直到可训练的函数能完成手头的任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;黑匣子&lt;/strong&gt;：虽然运气好的话，一个训练有素的网络可以完成它的任务，但最终你要阅读一个函数，往往会非常复杂——包含数千个变量和嵌套的激活函数——以至于解释网络是如何成功完成其任务也是非常困难的。此外， 一个训练有素的网络只和它所学的数据一样好。例如，如果数据集有偏差，那么网络的输出也会出现偏差。如果它只包含猫的高分辨率图片，那它对低分辨率图片的反应就不得而知了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个常识：在报道 Rosenblatt 于1958年发明的感测器时，《纽约时报》开辟了人工智能炒作的道路，报道中提到“美国海军期望拥有一台会走路、说话、看、写、自我复制和意识到自己存在的电子计算机雏形。” 虽然当时的感测器没有达到这个要求，但它产生了许多令人印象深刻的模型：用于图像的卷积神经网络；文本的循环神经网络；以及用于图像、文本、语音、视频、蛋白质结构等的transformers。它们已经做出了令人惊叹的事情，像下围棋时的表现超过了人类水平，在诊断X射线图像等实际任务中也接近人类水平。然而，它们在常识和逻辑推理方面的问题仍然较难应对。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;5&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『决策树：从根到叶』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;亚里士多德是一个什么样的「野兽」？这位哲学家的追随者、第三世纪期间生活在叙利亚的 Porphyry 想出了一个合乎逻辑的方法来回答这个问题。他将亚里士多德提出的“存在类别”从一般到具体组合起来，将亚里士多德依次归入到每个分类中：亚里士多德的存在是物质的而不是概念或精神；他的身体是有生命的而不是无生命的；他的思想是理性的而不是非理性的。因此，他的分类是人类。中世纪的逻辑教师将这个序列绘制为垂直流程图：一个早期的决策树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数字差异&lt;/strong&gt;：快进到 1963 年，密歇根大学社会学家John Sonquist和经济学家James Morgan在将调查的受访者分组时，首次在计算机中实行了决策树。随着自动训练算法软件的出现，这种工作变得很普遍，如今包括 scikit-learn 等在内的各种机器学习库也已经使用决策树。这套代码是由斯坦福大学和加州大学伯克利分校的四位统计学家花费了10 年时间开发的。到今天，从头开始编写决策树已经成为了《机器学习 101》中的一项家庭作业。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;空中的根&lt;/strong&gt;：决策树可以执行分类或回归。它向下生长，从根部到树冠，将一个决策层次结构的输入示例分类为两个（或更多）。想到德国医学家和人类学家Johann Blumenbach的课题：大约在 1776 年，他首先将猴子与猿（撇开人类除外）区分开来，在此之前，猴子和猿是被归为一类的。这种分类取决于各种标准，例如是否有尾巴、胸部狭窄或宽阔、是直立还是蹲伏、还有智力的高低。使用经训练的决策树来为这类动物贴上标签，逐一考虑每个标准，最终将这两组动物分开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入前 10 名：鉴于 Blumenbach 的结论（后来被Charles Darwin推翻），即人类与猿的区别在于宽阔的骨盆、手和紧牙的牙齿，如果我们想扩展决策树以不仅分类猿和猴子，而是对人类进行分类，那会怎么样呢？澳大利亚计算机科学家 John Ross Quinlan 在 1986 年通过 ID3 实现了这一可能，它扩展了决策树，以支持非二元结果。2008 年， 在IEEE国际数据挖掘会议策划的数据挖掘十大算法名单中，一项命名为 C4.5 的扩展细化算法名列前茅。在一个创新猖獗的世界里，这就是持久力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扒开树叶：决策树确实有一些缺点。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它们很容易通过增加多级别层次来过度拟合数据，以至于叶节点只包括一个例子。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;更糟糕的是，它们很容易出现蝴蝶效应：更换一个例子，长出来的树就大不相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;走进森林：美国统计学家 Leo Breiman 和新西兰统计学家 Adele Cutler 将这一特征转化为优势，于 2001 年开发了随机森林（random forest）——这是一个决策树的集合，每个决策树会处理不同的、重叠的示例选择，并对最终结果进行投票。随机森林和它的表亲XGBoost不太容易过度拟合，这有助于使它们成为最受欢迎的机器学习算法之一。这就像让亚里士多德、Porphyry、Blumenbach、Darwin、 Jane Goodall、Dian Fossey和其他 1000 位动物学家一起在房间里，确保你的分类是最好的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;6&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『K均值聚类：群体思维』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你在聚会上与其他人站得很近，那么你们很可能有一些共同点。这就是使用 k 均值聚类将数据点分组的想法。无论是通过人类机构还是其他力量形成的群体，这个算法都会找到它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从爆炸到拨号音&lt;/strong&gt;：美国物理学家 Stuart Lloyd 是贝尔实验室标志性创新工厂和发明原子弹的曼哈顿计划的校友，他于 1957 年首次提出 k-means 聚类，以在数字信号中分配信息，但直到 1982 年才发表这个工作：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;105&quot; data-backw=&quot;546&quot; data-height=&quot;388&quot; data-ratio=&quot;0.19188921859545005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOpJuygA1lgnEzII4KgU8XhiasDWcKYJUDZiaUGNHg87RibIyeCW8JibgTDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2022&quot; data-width=&quot;2022&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文地址：https://cs.nyu.edu/~roweis/csc2515-2006/readings/lloyd57.pdf&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，美国统计学家 Edward Forgy 在 1965 年描述了一种类似的方法，导致了它的替代名称为「Lloyd-Forgy 算法」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;寻找中心&lt;/strong&gt;：考虑将聚类分成志同道合的工作组。给定房间中参与者的位置和要形成的组数，k-means 聚类可以将参与者分成大小大致相等的组，每个组都聚集在一个中心点或质心周围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不同的距离&lt;/strong&gt;：当然，聚类对象之间的距离不需要很大。两个向量之间的任何度量都可以。例如，k-means 聚类可以根据他们的服装、职业或其他属性来划分他们，而不是根据物理距离对参加派对的人进行分组。在线商店使用它根据客户的喜好或行为来划分客户，天文学家也可以将相同类型的星星分在一组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据点的力量&lt;/strong&gt;：这个想法产生了一些显着的变化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;n 维狂欢&lt;/strong&gt;：尽管如此，原始形式的算法仍然广泛有用——特别是因为作为一种无监督算法，它不需要收集昂贵的标记数据。它的使用速度也越来越快。例如，包括 scikit-learn 在内的机器学习库受益于 2002 年添加的 kd-trees，这些 kd-trees 可以非常快速地划分高维数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://read.deeplearning.ai/the-batch/issue-146/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jupejmznDCicCEDfm4Q5koCraSm45XoTnY8A5RQMIFlLNVKlC8bo97y7Pibp6VwDZmUGebhLN3akM0R19icNU6tCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>