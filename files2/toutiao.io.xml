<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>73284fc8941ed16fcde4a5a0ec7a0586</guid>
<title>跟 Kafka 学技术系列之时间轮</title>
<link>https://toutiao.io/k/77iozz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;kafka是一个分布式消息中间件，其高可用高吞吐的特点是大数据领域首选的消息中间件，Kafka是分布式消息队列的顺序读写文件分段组织串联起来思想的鼻祖，包括RocketMq这些消息队列都是借鉴了Kafka早期的架构和设计思路改造而来，所以在架构设计层面，Kafka有非常多值得借鉴的地方。本文是作者介绍Kafka优秀架构设计文章中的一篇，文中的代码和流程图均是base on 0.10.2.0版本。&lt;/p&gt;
&lt;h1&gt;引出环形队列和延迟队列&lt;/h1&gt;
&lt;p&gt;从2个面试题说起，第1个问题，如果一台机器上有10w个定时任务，如何做到高效触发？&lt;/p&gt;
&lt;p&gt;具体场景是：&lt;/p&gt;
&lt;p&gt;有一个APP实时消息通道系统，对每个用户会维护一个APP到服务器的TCP连接，用来实时收发消息，对这个TCP连接，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。&lt;/p&gt;
&lt;p&gt;其中，单机TCP同时在线量约在10w级别，keepalive请求包较分散大概30s一次，吞吐量约在3000qps。&lt;/p&gt;
&lt;p&gt;怎么做？&lt;/p&gt;
&lt;p&gt;常用方案使用time定时任务，每秒扫描一次所有连接的集合Map&amp;lt;uid, last_packet_time&amp;gt;，把连接时间（每次有新的请求更新对应连接的连接时间）比当前时间的差值大30s的连接找出来处理。&lt;/p&gt;
&lt;p&gt;另一种方案，使用环形队列法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202309477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;小桔车服 &amp;gt; 跟Kafka学技术-时间轮 &amp;gt; image2020-1-17_16-20-37.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三个重要的数据结构：&lt;/p&gt;
&lt;p&gt;1）30s超时，就创建一个index从0到30的环形队列（本质是个数组）&lt;/p&gt;
&lt;p&gt;2）环上每一个slot是一个Set&amp;lt;uid&amp;gt;，任务集合&lt;/p&gt;
&lt;p&gt;3）同时还有一个Map&amp;lt;uid, index&amp;gt;，记录uid落在环上的哪个slot里&lt;/p&gt;
&lt;p&gt;这样当有某用户uid有请求包到达时：&lt;/p&gt;
&lt;p&gt;1）从Map结构中，查找出这个uid存储在哪一个slot里&lt;/p&gt;
&lt;p&gt;2）从这个slot的Set结构中，删除这个uid&lt;/p&gt;
&lt;p&gt;3）将uid重新加入到新的slot中，具体是哪一个slot呢 =&amp;gt; Current Index指针所指向的上一个slot，因为这个slot，会被timer在30s之后扫描到&lt;/p&gt;
&lt;p&gt;4）更新Map，这个uid对应slot的index值&lt;/p&gt;
&lt;p&gt;哪些元素会被超时掉呢？&lt;/p&gt;
&lt;p&gt;Current Index每秒种移动一个slot，这个slot对应的Set&amp;lt;uid&amp;gt;中所有uid都应该被集体超时！如果最近30s有请求包来到，一定被放到Current Index的前一个slot了，Current Index所在的slot对应Set中所有元素，都是最近30s没有请求包来到的。&lt;/p&gt;
&lt;p&gt;所以，当没有超时时，Current Index扫到的每一个slot的Set中应该都没有元素。&lt;/p&gt;
&lt;p&gt;两种方案对比：&lt;/p&gt;
&lt;p&gt;方案一每次都要轮询所有数据，而方案二使用环形队列只需要轮询这一刻需要过期的数据，如果没有数据过期则没有数据要处理，并且是批量超时，并且由于是环形结构更加节约空间，这很适合高性能场景。&lt;/p&gt;
&lt;p&gt;第二个问题：在开发过程中有延迟一定时间的任务要执行，怎么做？&lt;/p&gt;
&lt;p&gt;如果不重复造轮子的话，我们的选择当然是延迟队列或者Timer。&lt;/p&gt;
&lt;p&gt;延迟队列和在Timer中增 加延时任务采用数组表示的最小堆的数据结构实现，每次放入新元素和移除队首元素时间复杂度为O(nlog(n))。&lt;/p&gt;
&lt;h1&gt;时间轮&lt;/h1&gt;
&lt;p&gt;方案二所采用的环形队列，就是时间轮的底层数据结构，它能够让需要处理的数据（任务的抽象）集中，在Kafka中存在大量的延迟操作，比如延迟生产、延迟拉取以及延迟删除等。Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。&lt;/p&gt;
&lt;h2&gt;时间轮的数据结构&lt;/h2&gt;
&lt;p&gt;参考下图，Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。TimerTaskList是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务TimerTask。在Kafka源码中对这个TimeTaskList是用一个名称为buckets的数组表示的，所以后面介绍中可能TimerTaskList也会被称为bucket。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202645122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮组成&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;时间轮相关名词解释&lt;/h2&gt;
&lt;p&gt;tickMs：时间轮由多个时间格组成，每个时间格就是tickMs，它代表当前时间轮的基本时间跨度。&lt;/p&gt;
&lt;p&gt;wheelSize：代表每一层时间轮的格数&lt;/p&gt;
&lt;p&gt;interval：当前时间轮的总体时间跨度，interval=tickMs × wheelSize&lt;/p&gt;
&lt;p&gt;startMs：构造当层时间轮时候的当前时间，第一层的时间轮的startMs是TimeUnit.NANOSECONDS.toMillis(nanoseconds()),上层时间轮的startMs为下层时间轮的currentTime。&lt;/p&gt;
&lt;p&gt;currentTime：表示时间轮当前所处的时间，currentTime是tickMs的整数倍（通过currentTime=startMs - (startMs % tickMs来保正currentTime一定是tickMs的整数倍），这个运算类比钟表中分钟里65秒分针指针指向的还是1分钟）。currentTime可以将整个时间轮划分为到期部分和未到期部分，currentTime当前指向的时间格也属于到期部分，表示刚好到期，需要处理此时间格所对应的TimerTaskList的所有任务。&lt;/p&gt;
&lt;h2&gt;时间轮中的任务存放&lt;/h2&gt;
&lt;p&gt;若时间轮的tickMs=1ms，wheelSize=20，那么可以计算得出interval为20ms。初始情况下表盘指针currentTime指向时间格0，此时有一个定时为2ms的任务插入进来会存放到时间格为2的TimerTaskList中。随着时间的不断推移，指针currentTime不断向前推进，过了2ms之后，当到达时间格2时，就需要将时间格2所对应的TimeTaskList中的任务做相应的到期操作。此时若又有一个定时为8ms的任务插入进来，则会存放到时间格10中，currentTime再过8ms后会指向时间格10。如果同时有一个定时为19ms的任务插入进来怎么办？新来的TimerTaskEntry会复用原来的TimerTaskList，所以它会插入到原本已经到期的时间格1中。总之，整个时间轮的总体跨度是不变的，随着指针currentTime的不断推进，当前时间轮所能处理的时间段也在不断后移，总体时间范围在currentTime和currentTime+interval之间。&lt;/p&gt;
&lt;h2&gt;时间轮的升降级&lt;/h2&gt;
&lt;p&gt;如果此时有个定时为350ms的任务该如何处理？直接扩充wheelSize的大小么？Kafka中不乏几万甚至几十万毫秒的定时任务，这个wheelSize的扩充没有底线，就算将所有的定时任务的到期时间都设定一个上限，比如100万毫秒，那么这个wheelSize为100万毫秒的时间轮不仅占用很大的内存空间，而且效率也会拉低。Kafka为此引入了层级时间轮的概念，当任务的到期时间超过了当前时间轮所表示的时间范围时，就会尝试添加到上层时间轮中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202605415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;时间轮升降级&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考上图，复用之前的案例，第一层的时间轮tickMs=1ms, wheelSize=20, interval=20ms。第二层的时间轮的tickMs为第一层时间轮的interval，即为20ms。每一层时间轮的wheelSize是固定的，都是20，那么第二层的时间轮的总体时间跨度interval为400ms。以此类推，这个400ms也是第三层的tickMs的大小，第三层的时间轮的总体时间跨度为8000ms。&lt;br/&gt;
刚才提到的350ms的任务，不会插入到第一层时间轮，会插入到interval=20*20的第二层时间轮中，具体插入到时间轮的哪个bucket呢？先用350/tickMs(20)=virtualId(17)，然后virtualId(17) %wheelSize (20) = 17，所以350会放在第17个bucket。如果此时有一个450ms后执行的任务，那么会放在第三层时间轮中，按照刚才的计算公式，会放在第0个bucket。第0个bucket里会包含&lt;/p&gt;
&lt;p&gt;[400,800)ms的任务。随着时间流逝，当时间过去了400ms，那么450ms后就要执行的任务还剩下50ms的时间才能执行，此时有一个时间轮降级的操作，将50ms任务重新提交到层级时间轮中，那么此时50ms的任务根据公式会放入第二个时间轮的第2个bucket中，此bucket的时间范围为[40,60)ms，然后再经过40ms，这个50ms的任务又会被监控到，此时距离任务执行还有10ms，同样将10ms的任务提交到层级时间轮，此时会加入到第一层时间轮的第10个bucket，所以再经过10ms后，此任务到期，最终执行。&lt;/p&gt;
&lt;p&gt;整个时间轮的升级降级操作是不是很类似于我们的时钟？ 第一层时间轮tickMs=1s, wheelSize=60，interval=1min，此为秒钟；第二层tickMs=1min，wheelSize=60，interval=1hour，此为分钟；第三层tickMs=1hour，wheelSize为12，interval为12hours，此为时钟。而钟表的指针就对应程序中的currentTime，这个后面分析代码时候会讲到（对这个的理解也是时间轮理解的重点和难点）。&lt;/p&gt;
&lt;p&gt;Kafka中任务添加和驱动时间轮滚动的核心流程：&lt;br/&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/20200308202809831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1poaVp1aUNodW5GZW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;任务添加和驱动时间轮滚动核心流程图&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;重点代码介绍&lt;/h2&gt;
&lt;p&gt;这是往SystenTimer中添加一个任务&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//在Systemtimer中添加一个任务，任务被包装为一个TimerTaskEntry&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; def &lt;span class=&quot;hljs-title&quot;&gt;addTimerTaskEntry&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Unit &lt;/span&gt;= {
&lt;span class=&quot;hljs-comment&quot;&gt;//先判断是否可以添加进时间轮中，如果不可以添加进去代表任务已经过期或者任务被取消，注意这里的timingWheel持有上一层时间轮的引用，所以可能存在递归调用&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timingWheel.add(timerTaskEntry)) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Already expired or cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!timerTaskEntry.cancelled)
     &lt;span class=&quot;hljs-comment&quot;&gt;//过期任务直接线程池异步执行掉&lt;/span&gt;
      taskExecutor.submit(timerTaskEntry.timerTask)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;timingWheel添加任务，递归添加直到添加该任务进合适的时间轮的bucket中&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timerTaskEntry: TimerTaskEntry)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  val expiration = timerTaskEntry.expirationMs
  &lt;span class=&quot;hljs-comment&quot;&gt;//任务取消&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timerTaskEntry.cancelled) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Cancelled&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + tickMs) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 任务过期后会被执行&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (expiration &amp;lt; currentTime + interval) {&lt;span class=&quot;hljs-comment&quot;&gt;//任务过期时间比当前时间轮时间加周期小说明任务过期时间在本时间轮周期内&lt;/span&gt;
    val virtualId = expiration / tickMs
    &lt;span class=&quot;hljs-comment&quot;&gt;//找到任务对应本时间轮的bucket&lt;/span&gt;
    val bucket = buckets((virtualId % wheelSize.toLong).toInt)
    bucket.add(timerTaskEntry)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Set the bucket expiration time&lt;/span&gt;
   &lt;span class=&quot;hljs-comment&quot;&gt;//只有本bucket内的任务都过期后才会bucket.setExpiration返回true此时将bucket放入延迟队列&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket.setExpiration(virtualId * tickMs)) {
     &lt;span class=&quot;hljs-comment&quot;&gt;//bucket是一个TimerTaskList，它实现了java.util.concurrent.Delayed接口，里面是一个多任务组成的链表，图2有说明&lt;/span&gt;
      queue.offer(bucket)
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-comment&quot;&gt;// Out of the interval. Put it into the parent timer&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//任务的过期时间不在本时间轮周期内说明需要升级时间轮，如果不存在则构造上一层时间轮，继续用上一层时间轮添加任务&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) addOverflowWheel()
    overflowWheel.add(timerTaskEntry)
  }
}

&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;在本层级时间轮里添加上一层时间轮里的过程，注意的是在下一层时间轮的interval为上一层时间轮的tickMs&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] &lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;addOverflowWheel&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
      overflowWheel = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TimingWheel(
        tickMs = interval,
        wheelSize = wheelSize,
        startMs = currentTime,
        taskCounter = taskCounter,
        queue
      )
    }
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;驱动时间轮滚动过程：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//注意这里会存在一个递归，一直驱动时间轮的指针滚动直到时间不足于驱动上层的时间轮滚动。&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeMs: Long)&lt;/span&gt;: Unit &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (timeMs &amp;gt;= currentTime + tickMs) {
   &lt;span class=&quot;hljs-comment&quot;&gt;//把当前时间打平为时间轮tickMs的整数倍&lt;/span&gt;
    currentTime = timeMs - (timeMs % tickMs)
    &lt;span class=&quot;hljs-comment&quot;&gt;// Try to advance the clock of the overflow wheel if present&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;//驱动上层时间轮，这里的传给上层的currentTime时间是本层时间轮打平过的，但是在上层时间轮还是会继续打平&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (overflowWheel != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) overflowWheel.advanceClock(currentTime)
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;这里是驱动源代码：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//循环bucket里面的任务列表，一个个重新添加进时间轮，对符合条件的时间轮进行升降级或者执行任务&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;] val reinsert = (timerTaskEntry: TimerTaskEntry) =&amp;gt; addTimerTaskEntry(timerTaskEntry)
 
&lt;span class=&quot;hljs-comment&quot;&gt;/*
 * Advances the clock if there is an expired bucket. If there isn&#x27;t any expired bucket when called,
 * waits up to timeoutMs before giving up.
 */&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;advanceClock&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(timeoutMs: Long)&lt;/span&gt;: Boolean &lt;/span&gt;= {
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bucket = delayQueue.poll(timeoutMs, TimeUnit.MILLISECONDS)
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
    writeLock.lock()
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (bucket != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;hljs-comment&quot;&gt;//驱动时间轮&lt;/span&gt;
        timingWheel.advanceClock(bucket.getExpiration())
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环buckek也就是任务列表，任务列表一个个继续添加进时间轮以此来升级或者降级时间轮，把过期任务找出来执行&lt;/span&gt;
        bucket.flush(reinsert)
       &lt;span class=&quot;hljs-comment&quot;&gt;//循环&lt;/span&gt;
        &lt;span class=&quot;hljs-comment&quot;&gt;//这里就是从延迟队列取出bucket，bucket是有延迟时间的，取出代表该bucket过期，我们通过bucket能取到bucket包含的任务列表&lt;/span&gt;
        bucket = delayQueue.poll()
      }
    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
      writeLock.unlock()
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;
  }
}
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;kafka的延迟队列使用时间轮实现，能够支持大量任务的高效触发，但是在kafka延迟队列实现方案里还是看到了delayQueue的影子，使用delayQueue是对时间轮里面的bucket放入延迟队列，以此来推动时间轮滚动，但是基于将插入和删除操作则放入时间轮中，将这些操作的时间复杂度都降为O(1)，提升效率。Kafka对性能的极致追求让它把最合适的组件放在最适合的位置。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e673c59e9f42b2dcaac6f769562148d6</guid>
<title>[推荐] 惊！这个 Go 开源项目号称「不改一行代码做秒杀」</title>
<link>https://toutiao.io/k/qnyxbs9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;23&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;阅读本文大概需要 2 分钟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 polarisxu。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到耗子叔发推文推荐了一个新开源的网关：Easegress。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.43005181347150256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBaZWKKF0aSaChclOHu7laFedvaxa0eueVuPxwnhF2HdGLz3ZIrMTaEwy6DJ5TfbyHNMhhYgArxW5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开看了下，这是一个 Go 语言实现的开源项目。它有如下亮点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高可用。内置 Raft 共识和领导者选举，提供 99.99％ 的可用性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流量编排。将各种过滤器动态地编排到流量管道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高性能。轻量级和基础特性提升性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可观察性。以可读方式定期存放许多有意义的统计数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可扩展性。使用高级编程语言开发自己的过滤器或控制器很容易。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一体化。简单的接口使其易于与其他系统集成，例如 Kubernetes Ingress，Easemesh Sidecar，Workflow 等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给一张架构图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBaZWKKF0aSaChclOHu7laFelnG5ouQsoNo4HAlGd7I5LXFaMlz93Kr5NEfywFoXLgdY4jibAxEevEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的功能特性，耗子叔给了一张图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;3.8641509433962264&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBaZWKKF0aSaChclOHu7laFecibnIyqiak6pfS1LYmYvaicg33tbR7Tcz4fkzGmia2LfYfAicRAiakiawibemQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来很强大，而且他们公司的产品宣传是：&lt;strong&gt;不改一行代码做秒杀&lt;/strong&gt;。有机会可以深入学习研究下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然是国人开源项目，不过文档是全英文的，没有中文版。很显然是要走向国际的。&lt;strong&gt;阅读原文&lt;/strong&gt;可以直达项目首页：https://github.com/megaease/easegress。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UzjmETLXwBYuP3ncUTaemHXQYjOZDS40VoicqII73Hu9RncJv06g0kJhnrVicSmUfJRg5Wf9qcDHj7zf5vTjns5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我是 polarisxu，北大硕士毕业，曾在 360 等知名互联网公司工作，10多年技术研发与架构经验！2012 年接触 Go 语言并创建了 Go 语言中文网！著有《&lt;/span&gt;&lt;span&gt;Go语言编程之旅&lt;/span&gt;&lt;span&gt;》、开源图书《&lt;/span&gt;&lt;span&gt;Go语言标准库&lt;/span&gt;&lt;span&gt;》等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;坚持输出技术（包括 Go、Rust 等技术）、职场心得和创业感悟！欢迎关注「polarisxu」一起成长！也欢迎加我微信好友交流：&lt;/span&gt;&lt;span&gt;gopherstudio&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2a830bfd8fbc9fd0106c7cecdab832ea</guid>
<title>[推荐] Linux 调度系统全景指南（终结篇）</title>
<link>https://toutiao.io/k/ow2rhiz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8bD08cI97gtcM69EHcDBDvhOXDNpIo7Y4xY8XpEIoib8GeEYnmNlibjdSwqBvHSuu38TgiaFflVhv9byn3DbRmCbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.42560553633217996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IsrmVA0RIYNibUD5Mz7pTdHok3G6UJVASP3dgDELEY2ficdvYic6om48TcTbErFJiaUmJZibFh4LR9D59ZJ1zKB6Nvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;289&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| 导语&lt;/span&gt;&lt;span&gt;本文主要是讲Linux的调度系统, 本篇是终结篇，主要讲当前多核系统调度策略和调度优化，调度可以说是操作系统的灵魂，为了让CPU资源利用最大化，Linux设计了一套非常精细的调度系统，对大多数场景都进行了很多优化，系统扩展性强，我们可以根据业务模型和业务场景的特点，有针对性的去进行性能优化。欢迎大家相互交流学习！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;                              目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.019455252918287938&quot; data-type=&quot;png&quot; data-w=&quot;514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VRxORJYZ4KNh7dvTFCCiaPDepEZG8R7W4sdpA5TzJ5727A9NmeX4HUN0ZG4atXvoxs3OYPu0AicXibgrLIvZic1Q5g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;476&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;954&quot; data-ratio=&quot;2.1588310038119443&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1ECE0stpb2H78NckHW8qHmy7s3iaINWibkqFLm4wNAkbIeB0jhPyJFt40YC75PUjGibInuVRFQFeLcGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;                                 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;多核调度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.05177993527508091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/C4BflpndvHSxhmF7rr5YNyEb0fEvxc2t2Jrew5jznCicz5fljTns2alIrjYELaHAxlX8YRLaxib1s8g7Iic4BvQXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在单核系统中，调度器只需要考虑任务执行先后顺序的问题，在多核系统中，除了任务先后问题，调度器还需要考虑CPU分配问题。也就是说，在多核系统中，调度器还需要决定任务在哪个CPU上运行，需要尽量做到公平和整体性能最大化。一般来说，调度器可以被划分为以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）全局类（Global）&lt;/strong&gt;：即一个调度器就可以管理系统中的所有CPU，任务可以在CPU之间自由迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）集群类（Clustered）&lt;/strong&gt;：系统中的CPU被分成互不相交的几个cluster，调度器负责调度任务到cluster内的CPU上去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）分区类（Partitioned ）&lt;/strong&gt;：每个调度器只管自己的那个CPU，系统有多少个CPU就有多少个调度器实体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）任意类（Arbitrary ）&lt;/strong&gt;：每一个任务都可以运行在任何一个CPU集合上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内核调度系统针对CPU架构演进：单CPU-&amp;gt;SMP-&amp;gt;NUMA-&amp;gt;复杂混合架构， 做了针对性的优化设计；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;SMP&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWic1ITAM3gmNOJ4VdibiaP32wzTxVB4WbIvDQ6TM7oWkr0KbolicbNmhzXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;SMP （Symmetric Multiprocessing），&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对称多处理器. 顾名思义, 在SMP中所有的处理器都是对等的, 它们通过总线连接共享同一块物理内存，这也就导致了系统中所有资源(CPU、内存、I/O等)都是共享的，其架构简单，但是拓展性能比较差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多处理器系统上，内核必须考虑几个额外的问题，以确保良好的调度效率。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; CPU负荷必须尽可能公平地在所有的处理器上共享。如果一个处理器负责3个并发的应用程序，而另一个只能处理空闲进程，那是没有意义的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程与系统中某些处理器的亲合性（affinity）必须是可设置的。例如在4个CPU系统中，可以将计算密集型应用程序绑定到前3个CPU，而剩余的（交互式）进程则在第4个CPU上运行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内核必须能够将进程从一个CPU迁移到另一个。但该选项必须谨慎使用，因为它会严重危害性能。在小型SMP系统上CPU高速缓存是最大的问题。对于真正大型系统， CPU与迁移进程此前使用的物理内存距离可能有若干米，因此对该进程内存的访问代价高昂。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程对特定CPU的亲合性 ，定义在task_struct的 cpus_allowed 成 员 中 。Linux 提供了sched_setaffinity系统调用，可修改进程与CPU的现有分配关系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在SMP系统上，每个调度器类的调度方法必须增加两个额外的函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;load_balance：&lt;/strong&gt;允许从最忙的就绪队列分配多个进程到当前CPU，但移动的负荷不能比max_load_move更多，每当内核认为有必要重新均衡时，核心调度器代码都会调用这些函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;move_one_task：&lt;/strong&gt;move_one_task则使用了iter_move_one_task，从最忙碌的就绪队列移出一个进程，迁移到当前CPU的就绪队列；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在SMP系统上，周期性调度器函数scheduler_tick按上文所述完成所有系统都需要的任务之后，会调用trigger_load_balance函数，&lt;/span&gt;&lt;span&gt;这会引发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SCHEDULE_SOFTIRQ软中断softIRQ，该中断确保会在适当的时机执行run_rebalance_domains。该函数最终对当前CPU调用rebalance_domains，实现负载均衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33541341653666146&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWsWKHUxxlJdKmaAoSxQIZXYhyA8saEb1NXMDtzZyRuYrv2WWqmUq0EA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;NUMA&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;        &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5659777424483307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWfL49wZ547572dANRGDqcWibicoTicEKiaWlqbZKGEhOkpibfXqlGSMEHicnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;非统一内存访问架构&lt;/strong&gt;（英语：&lt;strong&gt;Non-uniform memory access&lt;/strong&gt;，简称NUMA）是一种为多处理器的电脑设计的内存架构，内存访问时间取决于内存相对于处理器的位置。在NUMA下，处理器访问它自己的本地内存的速度比非本地内存（内存位于另一个处理器，或者是处理器之间共享的内存）快一些；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;非统一内存访问架构的特点是：被共享的内存物理上是分布式的，所有这些内存的集合就是全局地址空间。所以处理器访问这些内存的时间是不一样的，显然访问本地内存的速度要比访问全局共享内存或远程访问外地内存要快些。另外，NUMA中内存可能是分层的：本地内存，群内共享内存，全局共享内存；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在NUMA中还有三个节点的概念：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;       本地节点：对于某个节点中的所有CPU，此节点称为本地节点。&lt;br/&gt;        邻居节点：与本地节点相邻的节点称为邻居节点。&lt;br/&gt;        远端节点：非本地节点或邻居节点的节点，称为远端节点。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;调度域（Scheduling Domain）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Scheduling Domains 是现代硬件技术尤其是多 CPU 多核技术发展的产物。现在，一个复杂的高端系统由上到下可以这样构成：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;它是一个 NUMA 架构的系统，系统中的每个 Node 访问系统中不同区域的内存有不同的速度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同时它又是一个 SMP 系统。由多个物理 CPU(Physical Package) 构成。这些物理 CPU 共享系统中所有的内存。但都有自己独立的 Cache 。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个物理 CPU 又由多个核 (Core) 构成，即 Multi-core 技术或者叫 Chip-level Multi processor(CMP) 。这些核都被集成在一块 die 里面。一般有自己独立的 L1 Cache，但可能共享 L2 Cache 。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个核中又通过 SMT 之类的技术实现多个硬件线程，或者叫 Virtual CPU( 比如 Intel 的 Hyper-threading 技术 ) 。这些硬件线程，逻辑上看是就是一个 CPU 。它们之间几乎所有的东西都共享。包括 L1 Cache，甚至是逻辑运算单元 (ALU) 以及 Power 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在上述系统中，最小的执行单元是逻辑 CPU，进程的调度执行也是相对于逻辑 CPU 的。因此，后文皆简称逻辑 CPU 为 CPU，是物理 CPU 时会特别说明。在这样复杂的系统，调度器要解决的一个首要问题就是如何发挥这么多 CPU 的性能，使得负载均衡。不存某些 CPU 一直很忙，进程在排队等待运行，而某些 CPU 却是处于空闲状态。但是在这些 CPU 之间进行 Load Balance 是有代价的，比如对处于两个不同物理 CPU 的进程之间进行负载平衡的话，将会使得 Cache 失效。造成效率的下降。而且过多的 Load Balance 会大量占用 CPU 资源，为了解决上述的这些问题，内核开发人员 Nick Piggin 等人在 Linux 2.6 中引入基于 Scheduling Domains 的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;img data-ratio=&quot;0.5260960334029228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWNrmwBGyGysWFRiboAdOGTLYbeEW1UVibscibuOPH4vA8wgLFpJl1ejjicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;479&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每个 Scheduling Domain 其实就是具有相同属性的一组 cpu 的集合。并且跟据 Hyper-threading, Multi-core, SMP, NUMA architectures 这样的系统结构划分成不同的级别。不同级之间通过指针链接在一起，从而形成一种的树状的关系;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;负载平衡就是针对 Scheduling domain 的。从叶节点往上遍历。直到所有的 domain 中的负载都是平衡的。当然对不同的 domain 会有不同的策略识别是否负载不平衡，以及不同的调度策略。通过这样的方式，从而很好的发挥众多 cpu 的效率;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于 Scheduling Domains 的调度器引入了一组新的数据结构。下面先讲一下两个主要的数据结构:&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;struct sched_domain: 代表一个 Scheduling Domain，也就是一个 CPU 集合，这个集合里所有的 CPU 都具有相同的属性和调度策略。Load Balance 是针对每个 domain 里的 CPU 进行的。这里要注意 Scheduling Domains 是分级的。像上节所讲的复杂系统就分为 Allnuma_domain,Numa_domain, Phy_domain, Core_domain, Smt_domain(Cpu_domain) 五个等级。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;struct sched_group: 每个 Scheduling domain 都有一个或多个 CPU group，每个 group 都被 domain 当做一个单独的单元来对待。Load Balance 就是在这些 CPU group 之间的 CPU 进行的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;                             &lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;                                调度优化&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.05177993527508091&quot; data-type=&quot;png&quot; data-w=&quot;618&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/C4BflpndvHSxhmF7rr5YNyEb0fEvxc2t2Jrew5jznCicz5fljTns2alIrjYELaHAxlX8YRLaxib1s8g7Iic4BvQXA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;    &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前主流服务器都是多核，多处理器，多NUMA等多CPU架构系统，很多程序都同时跑着服务器里面，怎么最大化利用当前CPU资源， 让整体运行效率更高呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;调度优化的本质 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; CPU资源和任务之间最优匹配&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6797312430011199&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;893&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KW8FmdWpxRGeSHKbaulqH8qg6e3ZNMicxxccIDyWn2b2XWwOcoujJoMoA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里讨论CPU调度优化一些比较常见的优化点，即包括怎么提升CPU性能，怎么提升单个程序性能，也包括怎么提升整个系统的性能，后面计划会详细讨论关于性能优化等内容，本篇探讨了一些优化点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进行任何性能优化前，有个很重要的前提原则是要找到性能瓶颈点，然后才能针对性优化，这要求我们学会用性能分析工具：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHialAr1UPBopdx77IDYe852SZwAtqtGaI1yVaKfKCq0iaPFyg2mTuGoNQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;perf &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;perf sta&lt;/span&gt;&lt;span&gt;t 采集程序运行事件，用于分析指定程序的性能概况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5372714486638537&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vH5tO25kvVfRBjOyJAGnJgCuaTwVC3kCichyER6Twkd3EDMqhVrNWdTJA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;task-clock：目标任务真真占用处理器的时间，单位是毫秒，我们称之为任务执行时间，后面是任务的处理器占用率（执行时间和持续时间的比值）。持续时间值从任务提交到任务结束的总时间（总时间在stat结束之后会打印出来）。CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;context-switches：上下文切换次数，前半部分是切换次数，后面是平均每秒发生次数（M是10的6次方）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cpu-migrations：处理器迁移，linux为了位置各个处理器的负载均衡，会在特定的条件下将某个任务从一个处理器迁往另外一个处理器，此时便是发生了一次处理器迁移。即被调度器从一个 CPU 转移到另外一个 CPU 上运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;page-fault：缺页异常，linux内存管理子系统采用了分页机制，&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当应用程序请求的页面尚未建立、请求的页面不在内存中或者请求的页面虽在在内存中，&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;但是尚未建立物理地址和虚拟地址的映射关系是，会触发一次缺页异常。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cycles：任务消耗的处理器周期数；处理器时钟，一条机器指令可能需要多个 cycles；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;instructions：任务执行期间产生的处理器指令数，IPC（instructions perf cycle）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;IPC（Instructions/Cycles ）是评价处理器与应用程序性能的重要指标。（很多指令需要多个处理周期才能执行完毕），&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;IPC越大越好，说明程序充分利用了处理器的特征。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;branches：程序在执行期间遇到的分支指令数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;branch-misses：预测错误的分支指令数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-misses：cache时效的次数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-references：cache的命中次数&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;perf top &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;对系统性能进行实时分析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6012558869701727&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHibheJg8MEr2YLib5EpL0SCHXDZm4vO7rDHXUPwExibGHcdvDXwfSRt8sw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;可以观察到当前函数CPU使用占比；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以查看当前系统最耗时的内核函数或某个用户进程&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以查看到当前耗时的指令；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;CPU 火焰图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.449955713020372&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHUfIxOfu9eXQFaz9j6icX8UM2gjWthqydia8TfMuVcm8xbIUkJAVLvicHw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持多种工具源，可以从包含堆栈跟踪的任何配置文件数据生成火焰图，包括从以下配置文件工具生成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux: perf, eBPF, SystemTap, and ktap&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Solaris, illumos, FreeBSD: DTrace&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mac OS X: DTrace and Instruments&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Windows: Xperf.exe&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以查看哪些代码路径很热（CPU占有率高）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以显示堆栈路径上CPU消耗，找到耗时的最多的函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;gperf 性能检测&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.58671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHmjfsxwbfM1yTKlybWFkfgfk0MGfKzZAFIfPZIKSXmrVcia7It9LarTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1622596241525&quot; data-category_id_list=&quot;48|32|26|49|1|27|28|45|46|55|39|8|3|47|35|41|5|31|6|7|24|37|22|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1622596241525&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;性能优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;局部性原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;局部性有两种，即时间局部性和空间局部性。时间局部性是指当一个数据被访问后，它很有可能会在不久的将来被再次访问，比如循环代码中的数据或指令本身。而空间局部性指的是，当程序访问地址为&lt;/span&gt;&lt;em&gt;x&lt;/em&gt;&lt;span&gt;的数据时，很有可能会紧接着访问&lt;/span&gt;&lt;em&gt;x&lt;/em&gt;&lt;span&gt;周围的数据，比如遍历数组或指令的顺序执行。由于这两种局部性存在于大多数的程序中，硬件系统可以很好地预测哪些数据可以放入缓存，从而运行得很好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525XWx2yhXYicZEQ49WmoA4oxiak3SI7xnKuwalzJ1Om9Rk2jQFNt1rnZjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存访问在设计多处理器调度时遇到的最后一个问题，是所谓的缓存亲和度（cache affinity）。这个概念很简单：一个进程在某个CPU上运行时，会在该CPU的缓存中维护许多状态。下次该进程在相同CPU上运行时，由于缓存中的数据而执行得更快。相反，在不同的CPU上执行，会由于需要重新加载数据而很慢（好在硬件保证的缓存一致性可以保证正确执行）。因此多处理器调度应该考虑到这种缓存亲和性，并尽可能将进程保持在同一个CPU上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;NUMA优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4621212121212121&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EBUR11xGfGu9jEjRmAnib1JaAFnzJ205KamGH3vjlMFNDTt2RStbPEf3hqL0FSGiabcHuLfGhn0VibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比起访问remote memory，local memory 访问不仅延迟低(100ns)，而且也减少了对公共总线（interconnect)的竞争。因此合理地放置数据(比如直接调用NUMA api) ，  软件调优化基本上还是围绕在尽量访问本地内存这一思路上。如果本地内存已用完，那么尽量访问本CPU下相临节点的内存，避免访问跨CPU访问最远端的内存，可以提高20-30%性能，具体数据和当前应用相关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU资源优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU独占：独占CPU资源，减少调度影响，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU绑定：减少CPU上下文切换，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中断亲和 : 中断负载均衡，减轻其他CPU负担，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程亲和：减少CPU上下文切换，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中断隔离：减少中断对CPU调度影响，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内存优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时钟优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;优先级优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;调度算法优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; linux 系统一些主线调度算法演进：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;strong&gt;O(n)调度算法&lt;/strong&gt; -&lt;span&gt;2.4时代&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8944365192582026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525LNcndbSbe5HW7fmSVBEibxIKvN7E8C4gszFgUezv3B7ckaibrYXfM8Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/p&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(n)调度器&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;调度器采用基于优先级的设计；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;pick next算法非常简单：对runqueue中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每次进程切换时, 内核扫描可运行进程的链表, 计算优先级,然后选择”最佳”进程来运行；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(n)调度器面临的问题&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;时间复杂度问题，时间复杂度是O(n),当系统中的进程很少的时候性能还可以，但是当系统中的进程逐渐增多，选择下一个进程的时间则是逐渐增大。而且当系统中无可运行的进程时，重新初始化进程的时间片也是相当耗时，在系统中进程很多的情况系下。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SMP扩展问题。当需要picknext下一个进程时，需要对整个runqueue队列进行加锁的操作，spin_lock_irq(&amp;amp;runqueue_lock);当系统中进程数目比较多的时候，则在临界区的时间就比较长，导致其余的CPU自旋比较浪费&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实时进程的运行效率问题，因为实时进程和普通进程在一个列表中，每次查实时进程时，都需要全部扫描整个列表，导致实时进程不是很“实时”&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CPU资源浪费问题：因为系统中只有一个runqueue,则当运行队列中的进程少于CPU的个数时，其余的CPU则几乎是idle状态，浪费资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache缓存问题：当系统中的进程逐渐减少时，原先在CPU1上运行的进程，不得不在CPU2上运行，导致在CPU2上运行时，cacheline则几乎是空白的，影响效率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总之O(n)调度器有很多问题，不过有问题肯定要解决的。所以在Linux2.6引入了O(1)的调度器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;O(1)调度算法 -&lt;span&gt;2.6&lt;/span&gt;时代&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0813953488372092&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl5255ibRtYdctHMibWwMtKYt9hA8aqRrx4Z8BXylJS0ribY5CBbsJ7R2MHOmw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;              &lt;/p&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(1)调度器：&lt;/h3&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(1)调度器面临的问题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;CFS调度算法&lt;/strong&gt; -如今主流&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 背后的主要想法是维护为任务提供处理器时间方面的平衡（公平性）。这意味着应给进程分配相当数量的处理器。分给某个任务的时间失去平衡时（意味着一个或多个任务相对于其他任务而言未被给予相当数量的时间），应给失去平衡的任务分配时间，让其执行&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 在叫做vruntime-&lt;/span&gt;&lt;em&gt;虚拟运行时&lt;/em&gt;&lt;span&gt; 的地方维持提供给某个任务的时间量。任务的虚拟运行时越小， 意味着任务被允许访问服务器的时间越短 — 其对处理器的需求越高&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 不直接使用优先级而是将其用作允许任务执行的时间的衰减系数。低优先级任务具有更高的衰减系数，而高优先级任务具有较低的衰减系数。这意味着与高优先级任务相比，低优先级任务允许任务执行的时间消耗得更快。这是一个绝妙的解决方案，可以避免维护按优先级调度的运行队列&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 维护了一个以时间为顺序的红黑树&lt;/span&gt;，&lt;span&gt;任务存储在以时间为顺序的红黑树中&lt;/span&gt;，&lt;span&gt;对处理器需求最多的任务 （最低虚拟运行时）存储在树的左侧，处理器需求最少的任务（最高虚拟运行时）存储在树的右侧&lt;/span&gt;，pick_next算法选择vruntime最小进程运行，即&lt;span&gt;选取红黑树最左端的节点调度为下一个以便保持公平性&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6383442265795207&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;459&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525rM4Qm9ia1QFEDYz3USuJWLM0nGj0X9xnTIsrxOeHk55O5aANkvz1BZA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; BFS &amp;amp; MuqSS-面向桌面或移动设备调度器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BFS的原理十分简单，其实质正是使用了O(1)调度器中的位图的概念，所有进程被安排到103个queue中，各个进程不是按照优先级而是按照优先级区间被排列到各自所在的区间，每一个区间拥有一个queue：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6302325581395349&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525ut8C5NfHBqPtdwPGsBTsxjicP0ibmcKJs8v4sgSGibQw7uGNRYn6nhp5Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BFS 是一个适用于桌面或移动设备的调度器，设计地比较简洁，用于改善桌面应用的交互性，减小响应时间，提升用户体验。它采用了全局单任务队列设计，不再让每个 CPU 都有独立的运行队列。虽然使用单个全局队列，需要引入队列锁来保证并发安全性，但是对于桌面系统而言，处理器通常都比较少，锁的开销基本可以忽略。BFS 每次会在任务链表中选择具有最小 virtual deadline 的任务运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54765625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525u1RAFF76RA7L1qDypGanm7GNfkIicslmguOXRD2hYaiaib4YMSlJK8CEQ/640?wx_fmt=png&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MuqSS 是作者后来基于 BFS 改进的一款调度器，同样是用于桌面环境任务调度。它主要解决了 BFS 的两个问题：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并行优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并行&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：多个任务在同一时刻一起发生;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：多个任务在同一时刻只能有一个发生，CPU快速切换-操作系统分时复用，给人的感觉还是同时在跑，本质还是串行执行；&lt;/span&gt;&lt;span&gt;并发的关键是你有处理多个任务的能力，不一定要同时；&lt;/span&gt;&lt;span&gt;并行的关键是你有同时处理多个任务的能力，必须在多核系统上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在多核系统中需要并行编程提高CPU运行效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一般采用多线程来实现并行计算来缩短计算时间，提高多核系统整体性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通常是一个线程绑定一个核，可以实现多线程程序CPU利用率最大化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尽量使用线程 local 数据，减少共享数据访问；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尽量使用线程栈内存（local变量），减少指针引用，数据结构内存对齐（利用编译指令），减少cache miss；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;了解参考一些经典成熟并行编程模型对你设计多线程并行程序大有裨益：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2884927066450567&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHokKoVzAkIVgTUPsO17moymfCLjwOz0a7SiafX2miceo9VsKECetnzkHg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;锁和无锁设计优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何正确有效的保护共享数据是编写并行程序必须面临的一个难题，通常的手段就是同步。同步可分为阻塞型同步（Blocking Synchronization）和非阻塞型同步（ Non-blocking Synchronization），多&lt;/span&gt;&lt;span&gt;线程里面难免需要访问&quot;共享内存&quot;，如果不加锁很容易导致结果异常&lt;/span&gt;&lt;span&gt;，程序首先要保证正确，即使影响性能低也需要加锁来防止错误，此时该怎么提高&lt;/span&gt;&lt;span&gt;CPU执行性能呢？ 一个比较重要的优化工作是锁需要精心设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阻塞锁&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阻塞锁通过改变了线程的运行状态。让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的线程，通过竞争，进入运行状态；&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;mutex 主要用于线程间互斥访问资源场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;semaphore 主要用于多个线程同步场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;读写锁针主要用于读多写少场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;非阻塞锁&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非阻塞锁不会改变线程状态，使用时不会产生调度，通过CPU忙等待或者基于&lt;span&gt;CAS（Compare - And - Swap）原子&lt;/span&gt;操作指令实现非阻塞访问资源；&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自旋锁底层通过控制原子变量的值，让其他CPU忙等待，cache亲和性高和控制好锁粒度，可以提高多线程访问资源效率，主要用于加锁时间极短且无阻塞点场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RCU锁(Read-Copy Update)--非常重要一种无锁设计，对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它（因此不会导致锁竞争，不会导致锁竞争，内存延迟以及流水线停滞，读效率极高），但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作，RCU实际上是一种改进的读写锁，更能提高读多写少场景的系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原子操作可以保证指令以原子的方式执行（锁总线或者锁CPU缓存）——执行过程不被打断,主要用于全局统计、引用计数，无锁设计等场景；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CAS操作（Compare And Set或是 Compare And Swap），现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构，主要用于各种追求极限高性能场景，比如内存数据库，内存消息队列，DPDK的内存池mempool，java 的&lt;span&gt;Disruptor等&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;真正无锁-没有资源冲突，每个线程只使用local数据，最高级别的无锁设计，适合分而治之算法场景；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;IO优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;零拷贝:  减少驱动到协议栈之间内存拷贝，减少用户空间到内核空间内存拷贝，提升IO性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网卡硬件升级：10G-&amp;gt;25G-&amp;gt;40G-&amp;gt;100G-&amp;gt;200G-&amp;gt;400G-&amp;gt;...；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;kernelbypass：绕过内核协议栈（路径长，多核性能差），提高IO吞吐量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;   DPDK： &lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Intel DPDK全称Intel Data Plane Development Kit，是intel提供的数据平面开发工具集，为Intel architecture（IA）处理器架构下用户空间高效的数据包处理提供库函数和驱动的支持，它不同于Linux系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理，适合高性能网关(IO需求大）场景；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.62734375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHRLOnstsz8urg7oueVQFTYHfoDiavczo2noB7Qn5GicdrlX0dIePGH4ZA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PMD用户态驱动，使用无中断方式直接操作网卡的接收和发送队列；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;采用&lt;/span&gt;&lt;span&gt;HugePage&lt;/span&gt;&lt;span&gt;减少TLB Miss；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DPDK采用向量SIMD指令优化性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU亲缘性和独占；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存对齐：根据不同存储硬件的配置来优化程序，确保对象位于不同channel和rank的起始地址，这样能保证对象并并行加载，性能也能够得到极大的提升；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cache对齐，提高cache访问效率：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;NUMA亲和，提高numa内存访问性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;减少进程上下文切换：保证活跃进程数目不超过CPU个数；减少堵塞函数的调用，尽量采样无锁数据结构；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;利用空间局部性，采用预取Prefetch，在数据被用到之前就将其调入缓存，增加缓存命中率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;充分挖掘网卡的潜能：借助现代网卡支持的分流（RSS, FDIR）和卸载（TSO，chksum）等特性；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;   XDP:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.546875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHunA467uj6iazVYiaCVGn4qc78LPNfDia9zib9hgOWa5SMN0DSWJ2hrkibEA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; XDP（eXpress Data Path）为Linux内核提供了高性能、可编程的网络数据路径。由于网络包在还未进入网络协议栈之前就处理，它给Linux网络带来了巨大的性能提升（性能比DPDK还要高）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在网络协议栈前处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无锁设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;批量I/O操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;轮询式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;直接队列访问&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDIO（网卡直接IO），支持硬件offload加速&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持eBPF，高效开发，安全可靠，性能好&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;和内核耦合紧密，适合基于内核网络组件平滑演进高性能方案，比如DDOS防护，网络采&lt;/span&gt;&lt;span&gt;样，高性能防火墙；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;  P4 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44144144144144143&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHsiabaJzDxGEuuU8IU9icSsCKOXia4tDmyRibmvxU0or1lojkPRo0ibkcCLA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;p4 为一种高级可编程协议无关处理语言，结合可编程交换机芯片，编程能力强，&lt;/span&gt;&lt;span&gt;可以实现业务offload 到硬件，转发面 p4lang 定制开发，控制面可通过 Apache Thrift、gRPC 接口远程管理，生态繁荣包括P4 Runtime、Stratum；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能高&lt;/span&gt;&lt;span&gt;，&lt;strong&gt;1.8T ~ 6.5T&lt;/strong&gt; 线速转发，&lt;/span&gt;&lt;span&gt;&lt;span&gt;更低时延&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每Tbps设备成本大幅降低；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主要应用场景是大流量的边界网关，大流量无状态网关，大流量状态网关（当前P4交换机对内存容量支持有限，对配置量有一定的限制）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时空互换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Per CPU&lt;/p&gt;&lt;p&gt;Per-CPU是基于空间换时间的方法, 让每个CPU都有自己的私有数据段(放在L1中),并将一些变量私有化到 每个CPU的私有数据段中. 单个CPU在访问自己的私有数据段时, 不需要考虑其他CPU之间的竞争问题,也不存在同步的问题.  注意只有在该变量在各个CPU上逻辑独立时才可使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指&lt;/span&gt;&lt;span/&gt;&lt;span&gt;令并行&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;通过展开循环降低循环开销，提高指令并行执&lt;/span&gt;&lt;span&gt;行效率；&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;采用SIMD扩展指令集来优化指令执行效率；&lt;/span&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;分支预测&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9574014909478168&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHQFyN2p3moJXGiaEDoiaicFODxaLmicRPFYKkwa2xP3ykeEVYRQFTGV3P2g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;分支预测采用空间换时间方式，直接预测分支条件，把分支指令填入流水线，如果预测失败，再回滚清空流水线，重新选择分支，通过采用有效的预测算法，可以极大提高CPU流水线的执行效率，我们需要合理利用这个特性，减少分支判断，在代码中采用编&lt;/span&gt;&lt;span&gt;译指令优化提供分支预测准确性，比如在linux内核中，提分支预测的信息提供给编译器&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span/&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;ikely(x)  表示x的值为真的可能性更大；&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span/&gt;&lt;span&gt;nlik&lt;/span&gt;&lt;span&gt;ely(x)   表示x的值为假的可能性更大；&lt;/span&gt;&lt;span&gt;这样编译器对代码进行优化，以减少指令跳转带来的性能下&lt;/span&gt;&lt;span&gt;降。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BIOS优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BIOS（基本输入/输出系统）是主板上的一个小内存，其数据定义了系统的配置。某些数据被写入死存储器（ROM），因此无法更改。另一方面，某些配置可以从BIOS配置中访问，我们在启动PC时通过按键激活该配置。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;超线程优化（&lt;span&gt;Hyper-Threading&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;超线程，是一种用于提升CPU计算并行度的处理器技术，用一个物理核模拟两个逻辑核。这两个逻辑核拥有自己的中断、状态，但是共用物理核的计算资源（寄存器）。超线程技术旨在提高CPU计算资源的使用率，从而提高计算并行度。但是超线程也&lt;/span&gt;&lt;span&gt;有副作用，会产生访问cache的竞争，会导致更多的cache不命中(cache-miss)，增加线程间的通信负载。加大内存的通信带宽，I/O总线的压力，所以对于一些高性能程序，一般是需要关闭超线程的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;电源模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果服务器想获得最大的吞吐量或最低的延迟，修改电源模式为最大性能，可以提高服务器的性能；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;h4&gt;&lt;span&gt;Lockstep模式&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;锁步模式对内存进行了更高的校验，提升了系统的可靠性，但是降低了内存访问的带宽和延时，对于实时性要求高，吞吐量大的业务场景不适用，对于这些场景从系统，软件和方案层面都有完善的保护机制，所以建议关闭;&lt;/span&gt;&lt;/h4&gt;&lt;/li&gt;&lt;li&gt;&lt;h4&gt;&lt;span&gt;Turbo Mode&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;Turbo boost就是Intel的睿频加速技术，通常所说的自动超频技术，主要用于提升处理器的频率，最大程度发挥处理器性能;&lt;/span&gt;&lt;br/&gt;&lt;/h4&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;批量合并&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预处理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;预处理策略就是提前做好一些准备工作，这样可以提高后续处理性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;比如网站页面资源的提前加载，可以显著地提升页面下载性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;比如CPU 预取指令，提前将所需要的数据和指令取出来，可以提高流水线效率和缓存效率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;惰性求值&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;惰性处理策略就是尽量将操作（比如计算），推迟到必需执行的时刻，这样很可能避免多余的操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Linux COW（Copy On Write，写时复制）机制，比如fork 调用只有真正用到资源时候才拷贝；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中断后半部分优化，把可延迟函数放到延后处理，从而提高中断处理整体效率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缺页中断处理，不需要进程把所有内存页载入内存，只有需要的时候再加载，这样可以减少大量无效内存操作，提高整体性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;架&lt;/span&gt;&lt;span&gt;构优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统资源优化：物理机器-&amp;gt;集群-&amp;gt;虚拟化-&amp;gt;云计算-&amp;gt;容器-&amp;gt;k8s编排器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用架构优化： 单体应用-&amp;gt;基于组件-&amp;gt;面向服务-&amp;gt;微服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;软件工程优化： 瀑布模型-&amp;gt;敏捷开发-&amp;gt;DevOps-&amp;gt;智能化工程，主要是提高研发效能，建设产品的性能测试CI/CD自动化流水线，每个优化点都可以及时查看到性能指标变化和对比，从小作坊到标准化，工业化，智能化发展；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;算法优化&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;循环优化：适当展开循环，可以让指令并行执行，提供搞性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;条件判断：减少条件判断语句，可以减少分支预测失败概率，提升CPU流水线效率，从而提升性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;表达式优化： 优化布尔逻辑可以减少不必要计算；使++i而不使用i++可以减少中间临时变量；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;采用位运算：如果没有越界风险，使用位运算符合计算机计算模型，效率更高；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;内存&amp;amp;cache对齐：数据结构最好是cache 对齐的整数倍，把高频使用的属性，放到最前面，这样可以提高cache命中效率，减少Cache miss；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;指针优化：尽量减少指针使用，指针跳转会导致Cache miss；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;向量化：合适使用SIMD高级指令可以优化代码；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;插入其他语言：插入汇编，优化高频函数；采用CPython优化python代码；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;递归优化：尽量把递归修&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;改为循环，减少递归调用代价；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;编译优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编译器优化：O0 --&amp;gt;&amp;gt; O1 --&amp;gt;&amp;gt; O2 --&amp;gt;&amp;gt; O3，来额外的性能提升；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编译器API：使用内联函数，使用内存对齐API，使用cache对齐API等 ，可以更好让编译器优化代码，减少调用指令，提高性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JIt编译器优化：使用Jit技术，可以把中间代码生成本地指令，提升代码执行效率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优化无止境，上面每一个优化点，都可以更详细展开讲，更多是需要我们深入理解计算机原理，才能找到得更多优化点，让我们向顶级程序员迈进；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>35b847572daa0a8491692d02ce6fff69</guid>
<title>[推荐] 面试题：MySQL 一棵 B+ 树能存多少条数据？</title>
<link>https://toutiao.io/k/85kvlje</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是Tom哥~&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;今日寄语：充满活力的新人，能让身边的人都重回初心，真是不可思议。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;sql 的InnoDB存储引擎 一棵B+树可以存放多少行数据?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41114982578397213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzpVLicRx4bhoYFC2IyEJGQichDkNPaf1ubltvu1LibkZTwU9dP5pyVJejA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（答案在文章中！！）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要搞清楚这个问题，首先要从InnoDB索引数据结构、数据组织方式说起。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们都知道计算机有五大组成部分：控制器，运算器，存储器，输入设备，输出设备。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中很重要的，也跟今天这个题目有关系的是存储器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道万事万物都有自己的单元体系，若干个小单体组成一个个大的个体。就像拼乐高一样，可以自由组合。所以说，如果能熟悉最小单元，就意味着我们抓住了事物的本事，再复杂的问题也会迎刃而解。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;存储单元&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;存储器范围比较大，但是数据具体怎么存储，有自己的最小存储单元。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、数据持久化存储磁盘里，磁盘的最小单元是扇区，&lt;/span&gt;&lt;code&gt;&lt;span&gt;一个扇区的大小是 512个字节&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、文件系统的最小单元是块，&lt;/span&gt;&lt;code&gt;&lt;span&gt;一个块的大小是 4K&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、InnoDB存储引擎，有自己的最小单元，称之为页，&lt;/span&gt;&lt;code&gt;&lt;span&gt;一个页的大小是16K&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;扇区、块、页这三者的存储关系？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzlYj9YicSEnH5fHR3M2vhZXRAx5ziaicicGYF8ticfyhddjfoMDSsia5F2kzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;InnoDB引擎&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果mysql部署在本地，通过命令行方式连接mysql，默认的端口 &lt;/span&gt;&lt;code&gt;&lt;span&gt;3306&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，然后输入密码即可进入&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;mysql -u root -p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看InnoDB的页大小&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;show variables like &lt;span&gt;&#x27;innodb_page_size&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3391304347826087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzEFG2ibmpdO3d6tPLUeKoXj30aAaJKib31DbJrsucRC8RGAffyxIcNO6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;mysql数据库中，table表中的记录都是存储在页中，那么一页可以存多少行数据？假如一行数据的大小约为1K字节，那么按 &lt;/span&gt;&lt;code&gt;&lt;span&gt;16K / 1K = 16&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，可以计算出一页大约能存放16条数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;mysql 的最小存储单元叫做“页”，这么多的页是如何构建一个庞大的数据组织，我们又如何知道数据存储在哪一个页中？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果逐条遍历，性能肯定很差。为了提升查找速度，我们引入了&lt;/span&gt;&lt;code&gt;&lt;span&gt;B+树&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，先来看下&lt;/span&gt;&lt;code&gt;&lt;span&gt;B+树&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的存储结构&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7431972789115646&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzQoknttTWIrdxibtddSIiaXkNRwaa7nbLNhzAZic8jOx7ExBGFkDT5hZQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;页除了可以存放&lt;/span&gt;&lt;code&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（叶子节点），还可以存放&lt;/span&gt;&lt;code&gt;&lt;span&gt;健值和指针&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（非叶子节点），当然他们是有序的。这样的数据组织形式，我们称为索引组织表。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如：上图中 page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;B+ 树是如何检索记录？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;首先找到根页，你怎么知道一张表的根页在哪呢？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其实每张表的根页位置在表空间文件中是固定的，即page number=3的页&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;然后再去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;如何计算B+树的高度？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的表空间文件中，约定&lt;/span&gt;&lt;code&gt;&lt;span&gt;page number = 3&lt;/span&gt;&lt;/code&gt;&lt;span&gt;表示主键索引的根页&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SELECT&lt;br/&gt;b.name, a.name, index_id, &lt;span&gt;type&lt;/span&gt;, a.space, a.PAGE_NO&lt;br/&gt;FROM&lt;br/&gt;information_schema.INNODB_SYS_INDEXES a,&lt;br/&gt;information_schema.INNODB_SYS_TABLES b&lt;br/&gt;WHERE&lt;br/&gt;a.table_id = b.table_id AND a.space &amp;lt;&amp;gt; 0&lt;br/&gt;and b.name like &lt;span&gt;&#x27;%sp_job_log&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4416326530612245&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzDYSy4C3FBQGVAicTia8eWaE0ibSbmR1nR0fQrxvPzpH314j8wwD7BQzJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1225&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从图中可以看出，每个表的主键索引的根页的page number都是3，而其他的二级索引page number为4&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在根页偏移量为&lt;/span&gt;&lt;code&gt;&lt;span&gt;64&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的地方存放了该B+树的&lt;/span&gt;&lt;code&gt;&lt;span&gt;page level&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。主键索引B+树的根页在整个表空间文件中的第3个页开始，所以算出它在文件中的偏移量：&lt;/span&gt;&lt;code&gt;&lt;span&gt;16384*3 + 64 = 49152 + 64 =49216&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，前2个字节中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，找到MySql数据库物理文件存放位置：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;show global variables like &lt;span&gt;&quot;%datadir%&quot;&lt;/span&gt; ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23905723905723905&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketznDFboCv74nXKOaM99gicGfGPWOX4iaV47GdCokFqSrlUv32h8z5mS6wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;hexdump工具，查看表空间文件指定偏移量上的数据：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hexdump -s 49216 -n 10  sp_job_log.ibd&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.09765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzuZepNfX9ZfrDShVg5coaEoKmmZEe5jAxad1Te2Q5y8v5IcI09mzzpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;page_level 值是 1，那么 B+树高度为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;page level + 1 = 2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;查询数据库时，不论读一行，还是读多行，都是将这些行所在的整页数据加载，然后在内存中匹配过滤出最终结果。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;表的检索速度跟树的深度有直接关系，毕竟一次页加载就是一次IO，而磁盘IO又是比较费时间。&lt;/span&gt;&lt;code&gt;&lt;span&gt;对于一张千万级条数B+树高度为3的表与几十万级B+树高度也为3的表，其实查询效率相差不大。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;一棵树可以存放多少行数据？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;假设B+树的深度为2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这棵B+树的存储总记录数 = &lt;/span&gt;&lt;code&gt;&lt;span&gt;根节点指针数 * 单个叶子节点记录条数&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;那么指针数如何计算？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设主键ID为&lt;/span&gt;&lt;code&gt;&lt;span&gt;bigint&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型，长度为&lt;/span&gt;&lt;code&gt;&lt;span&gt;8字节&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而指针大小在InnoDB源码中设置为&lt;/span&gt;&lt;code&gt;&lt;span&gt;6字节&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这样一共&lt;/span&gt;&lt;code&gt;&lt;span&gt;14字节&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么一个页中能存放多少这样的组合，就代表有多少指针，即 &lt;/span&gt;&lt;code&gt;&lt;span&gt;16384 / 14 = 1170&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。那么可以算出一棵高度为2 的B+树，能存放 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1170 * 16 = 18720&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 条这样的数据记录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同理：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;高度为3的B+树可以存放的行数 =  &lt;/span&gt;&lt;code&gt;&lt;span&gt;1170 * 1170 * 16 = 21902400&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;千万级的数据存储只需要约3层B+树，查询数据时，每加载一页（page）代表一次IO。所以说，根据主键id索引查询约3次IO便可以找到目标结果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;对于一些复杂的查询，可能需要走二级索引，那么通过二级索引查找记录最多需要花费多少次IO呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketz38TgsCyJTkFxDq7psbdsdsbYqoL9le40CKiaeaiaObAliaFWnOaGs48aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，从二级索引B+树中，根据&lt;/span&gt;&lt;code&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 找到对应的主键id&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.69296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzk8Vt860QGV3uwh5GjeEgfwmRcYFpADH8hZNwV2ic5eTutzYPGhVEttQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后，再根据主键id 从 聚簇索引查找到对应的记录。如上图所示，二级索引有3层，聚簇索引有3层，那么最多花费的IO次数是：3+3 = 6&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这也是为什么InnoDB表必须有主键，并且推荐使用整型的自增主键！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;举例说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、若使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;&quot;where id = 14&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这样的条件查找记录，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、若对Name列进行条件搜索，则需要两个步骤：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二步使用主键值在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;实战演示&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际项目中，每个表的结构设计都不一样，占用的存储空间大小也各不相等。如何计算不同的B+树深度下，一个表可以存储的记录条数？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们以业务日志表 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sp_job_log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为例，讲解详细的计算过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、查看表的状态信息&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;show table status like &lt;span&gt;&#x27;sp_job_log&#x27;&lt;/span&gt;\G&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzPSO6icytqwXDU2rF2yy2CJKyc3V4462NyPbvuVroIicBhoz7Bk5TILDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图中看到&lt;/span&gt;&lt;code&gt;&lt;span&gt;sp_job_log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;表的行平均大小为&lt;/span&gt;&lt;code&gt;&lt;span&gt;153&lt;/span&gt;&lt;/code&gt;&lt;span&gt;个字节&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、查看表结构&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;desc sp_job_log;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzlKOpFialibXWIiaZOIY26AZjhr2lTWicGTfOxAdq7xeZTzCZS0ib5ZQgVicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、计算B+树的行数&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单个叶子节点（页）中的记录数 = 16K / 153 = 105&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;非叶子节点能存放多少指针， 16384 / 14 = 1170&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果树的高度为3，可以存放的记录行数 =  1170 * 1170 * 105 = 143,734,500&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;最后加餐&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;普通索引和唯一索引在查询效率上有什么不同？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页全部加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次&lt;/span&gt;&lt;code&gt;&lt;span&gt;判断下一条记录&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于我：前阿里架构师，出过专利，竞赛拿过奖，CSDN博客专家，负责过电商交易、社区生鲜、营销、金融等业务，多年团队管理经验，爱思考，喜欢结交朋友&lt;/span&gt;&lt;/section&gt;&lt;h1 accuse=&quot;qTitle&quot;&gt;&lt;span&gt;&lt;span&gt;「长按2秒」↓↓&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;↓ 二维码，拉你进群，一线大厂技术交流&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2021660649819494&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXLL4AVYEUeBKzcTZJd7mrk9XicnYiccg6n8YjsA4ibpRk6hkog7Qqx6cJNIF1rhicl992vID1IFUKWYuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484947&amp;amp;idx=1&amp;amp;sn=5a70f88fba83b435b8144bf1ddd3cc9f&amp;amp;chksm=ceb9fab8f9ce73ae97afc43f87314dd3bb61c966b9a40c12801cddc454dcf2845bbb605694e3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;亿级系统的Redis缓存如何设计？？？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484957&amp;amp;idx=1&amp;amp;sn=e50e0808cb6503ca7214bdd6fee4f134&amp;amp;chksm=ceb9fab6f9ce73a0c0725e381673fc7dc50c0594fb995b5f985b263143b34371e5e2936d7be0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【高并发、高性能、高可用】系统设计经验&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484929&amp;amp;idx=1&amp;amp;sn=d8cb3306dea9f1b92fd30d59da3f536a&amp;amp;chksm=ceb9faaaf9ce73bca59b46021a450fdc84aa0f85d6b49ff0e5578cc3abaa1433447f7dffc5e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;人人都是架构师？？？谈何容易！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484921&amp;amp;idx=1&amp;amp;sn=b429efe7e622759fc8f3bb24c2979a90&amp;amp;chksm=ceb9f952f9ce7044b001528ce8ae0ec89ed63727764081c21a8400e9f8f685345ec9cb0a54d7&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【万级并发】电商库存扣减如何设计？不超卖！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>779e0494608d1b91993862a6f4173d32</guid>
<title>[推荐] 利用 Kubernetes 搭建便携式开发环境之 MySQL 和 Redis</title>
<link>https://toutiao.io/k/kkc4ght</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前给大家介绍过， 我自己用的开发环境都是容器化的，只不过前两年不会用K8，大部分都是用的 Docker 或者 Docker-Compose。随着这一年多对 K8 的学习和工作中的使用，一直有想法用K8 做一套便携式开发环境，以后换电脑就不用再愁数据库、缓存、队列这些基础软件的安装了。正好下个月我就能换新的办公电脑啦，也不能拿『能用就行』的理由再拖延下去了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果问你 “ 平时开发程序依赖最多的基础软件时啥？”，我猜大部分人会回答：“MySQL 和 Redis”，毕竟万物皆是增删改查，整天做CURD的我们怎么能离开它们呢。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;工具选择&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是要在本地 Kubernetes 上搭建开发环境，那电脑上得先有 Kubernetes 集群才行。目前可以在本地运行 Kubernetes 集群的工具有：Minikube 、Kind 和 K3d ，我们的MySQL和Redis都是靠先编写资源定义YAML文件，再通过 kubectl 交给Kubernetes 集群执行的，所以这三种工具用哪种都行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我自己在本地使用的是Minikube，这是 Kubernetes 官方提供的工具，说实话运行起来后电脑有点卡，Minikube的安装步骤可以参考我以前写的文章「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485235&amp;amp;idx=1&amp;amp;sn=0cdd31c25b13790b336e0a8222f00b64&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Minikube-运行在笔记本电脑上的Kubernetes集群&lt;/a&gt;」。另外两种 Kind 和 K3d 则是轻量级集群，支持多节点部署。其中我比较推荐K3d，尤其是使用 M1芯片MacBook的同学，现在暂时只能使用K3d安装Kubernetes集群。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;K3d 是使用 docker 容器在本地运行 k3s 集群，k3s 是由 Rancher Lab 开源的轻量级 Kubernetes。k3d 完美继承了 k3s 的简单、快速和占用资源少的优势，镜像大小只有 100 多 M，启动速度快，支持多节点集群。虽然 k3s 对 Kubernetes 进行了轻量化的裁剪，但是提供了完整了功能，像 Istio 这样复杂的云原生应用都可以在 k3s 上顺利运行。&lt;/p&gt;&lt;p&gt;K3d 除了启动速度快和占用资源少以外，在边缘计算和嵌入式领域也有着不俗的表现。因为 k3s 本身应用场景主要在边缘侧，所以支持的设备和架构很多，如：ARM64 和 ARMv7 处理器。很多老旧 PC 和树莓派这样的设备都可以拿来做成 k3s 集群，为本地研发测试燃尽最后的生命。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;预备知识点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完了安装工具的选择，我们再来说一下在Kubernetes上从零搭建开发环境需要提前做哪些知识储备，如果你已经对Kubernetes这些基础概念已经有所了解可以直接跳过去看实操环节了，如果还比较生疏的话，我建议大家先看看下面这几篇文章，这些都是我们搭建开发环境时需要用到的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485464&amp;amp;idx=1&amp;amp;sn=00ca443bbcd4b2996efdede396b6c667&amp;amp;chksm=fa80d98fcdf7509944d63f618264e36cd8082a77e23aa36428a3d57a2f4189bcce4e52986967&amp;amp;token=2033333242&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Kubernetes Pod入门指南&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485643&amp;amp;idx=1&amp;amp;sn=6460bf2e170e4b2e8ebb2882bfe7c60f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;应用编排利器之Deployment&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486082&amp;amp;idx=1&amp;amp;sn=42a9bc8fcfc9da09445e9e2f4cf2fb96&amp;amp;chksm=fa80db15cdf752039494992f71a3bc488cf386841bd1aaaa44115f5e7f155ba55ce468ec89ee&amp;amp;token=2033333242&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;学练结合，快速掌握Kubernetes Service&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486416&amp;amp;idx=1&amp;amp;sn=20d568f93d0f39e0f3c7ef3ce42ac1d8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;用面向对象的方式管理配置文件&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486737&amp;amp;idx=1&amp;amp;sn=e7d0689fa74b108bae734515837c68e1&amp;amp;chksm=fa80dc86cdf755909f2f29ee8cb9dce930b95a837cb045be5c9700a9000743c9cb7f8eed6731&amp;amp;token=1423297622&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;深入理解StatefulSet，用Kubernetes编排有状态应用&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装MySQL&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正式开始在Kubernetes上安装MySQL和Redis前我先说明下安装这两个基础软件服务的思路。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先因为是用作开发环境，我们就不追求高可用了，尽量精简。文章后面我会给出安装主从和集群式数据库的一些教程链接，供大家参考。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;安装MySQL和Redis的思路是一样的，每个服务都由下面几个主要的部分构成：&lt;/p&gt;&lt;p&gt;① 一个单副本 Pod 作为运行MySQL或者Redis 的载体。&lt;/p&gt;&lt;p&gt;② 一个调度Pod用的Deployment控制器，因为服务里只包含一个Pod，不需要维持构建的顺序，所以不用使用StatefulSet作为Pod的控制器。&lt;/p&gt;&lt;p&gt;③一个ConfigMap对象，包含了MySQL或者Redis配置文件里需要的配置项，在创建Pod时会作为配置文件挂载到应用所在的容器中。&lt;/p&gt;&lt;p&gt;④一个 Service 对象，将应用 Pod 作为自己的后端端点，以始终保持不变的NodeId:NodePort 方式向外暴露服务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这张图很好的解释了这四部分的协作关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5279912184412733&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z4pQ0O5h0f727NCYVkxF8ic7Bp7Ue9zn3UGfGUe5SiafCBLWQZQT9qEOTicNmq6Jd4A9NribpiaricrtTj07NGlffczA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;911&quot;/&gt;&lt;figcaption&gt;MySQL on Kubernetes&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释清楚我们在Kubernetes上搭建MySQL和Redis开发环境的思路后，下面就可以进入实操环节啦，我为大家准备了可以直接拿来使用的YAML资源定义文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;创建MySQL配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来创建一个名为 mysql-db-config 的ConfigMap，稍后会把这些配置作为 my.cnf 配置文件挂载到MySQL应用Pod的容器里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;### 文件名 mysql-configmap.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;ConfigMap&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-db-config&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;mysql-db-config&lt;/span&gt;&lt;br/&gt;&lt;span&gt;data:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;my.cnf:&lt;/span&gt; &lt;span&gt;|&lt;br/&gt;    [client]&lt;br/&gt;    default-character-set=utf8mb4&lt;br/&gt;    [mysql]&lt;br/&gt;    default-character-set=utf8mb4&lt;br/&gt;    [mysqld]&lt;br/&gt;    character-set-server = utf8mb4&lt;br/&gt;    collation-server = utf8mb4_unicode_ci&lt;br/&gt;    init_connect=&#x27;SET NAMES utf8mb4&#x27;&lt;br/&gt;    skip-character-set-client-handshake = true&lt;br/&gt;    max_connections=2000&lt;br/&gt;    secure_file_priv=/var/lib/mysql&lt;br/&gt;    datadir=/var/lib/mysql&lt;br/&gt;    bind-address=0.0.0.0&lt;br/&gt;    symbolic-links=0&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假定MySQL相关的YAML定义文件都放在 mysql-singleton 这个目录下，通过 kubectl 把这个ConfigMap 提交给Kubernetes 进行创建即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f mysql-singleton/mysql-configmap.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;创建MySQL容器和Service&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了MySQL配置相关的 ConfigMap后，我们就能在创建运行MySQL的容器时，把他作为配置文件挂载到容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;### 文件名 deployment-service.yaml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;NodePort&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;3306&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;nodePort:&lt;/span&gt; &lt;span&gt;30306&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;targetPort:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;strategy:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;Recreate&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;mysql:5.7&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;env:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;root&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;MYSQL_USER&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;MYSQL_PASSWORD&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;3306&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-persistent-storage&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/var/lib/mysql&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-config&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/etc/mysql/conf.d/my.cnf&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;subPath:&lt;/span&gt; &lt;span&gt;my.cnf&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-persistent-storage&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;emptyDir:&lt;/span&gt; &lt;span&gt;{}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-config&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;configMap:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-db-config&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;items:&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;my.cnf&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;path:&lt;/span&gt; &lt;span&gt;my.cnf&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的，使用kubectl 把 YAML 提交给Kubernetes后，等资源创建完毕我们的开发环境MySQL就算搭建好了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;kubectl apply -f mysql-singleton/deployment-service.yaml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的YAML文件中，有三点需要详细说明一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 mysql-db-config 这个ConfigMap 中my.cnf这个配置项以my.cnf文件名挂载到容器中去，但是因为挂载进去后会覆盖容器中conf.d 目录中的内容。通过volumeMounts.subPath可以支持选定ConfigMap中的Key-Value挂载到容器中而不覆盖容器中原有的文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Service 用 30306 端口向集群外暴露了MySQL服务，客户端从电脑上使用NodeIP:NodePort即可连接到这里创建的数据库，如果用的是Minikube创建的Kubernetes集群， 可以通过minikube ip 命令查到NodeIP。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;emptyDir 类型的数据卷的生命周期与Pod同步，这里的同步指的是Pod被kubectl delete 主动删除时才会销毁对应的数据卷，如果是Pod自己崩溃，或者是集群Shotdown，等恢复后重建出来的Pod仍然会使用之前的数据卷，不会造成数据丢失。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kubernetes上创建完MySQL后，我们可以通过任意客户端或者mysql命令行，连接MySQL服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql -uroot -puser -h {minikube-ip} -P 30306&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装Redis&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聊清楚了怎么用Kubernetes创建单节点的MySQL后，对于创建单例的Redis相信大家对大致流程也就比较清楚了，唯一少的就是定义Redis服务的这些YAML文件了。我已经帮你们踩好坑了，下面这些YAML都是我在线下调试过一段时间的，并且也能正确完成Redis数据的持久化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于声明 Redis 配置的 ConfigMap 篇幅太长，为了不影响文章的阅读我就把这个安装Redis需要的YAML文件都放在GitHub上了，可以点击阅读原文或者通过链接：https://github.com/kevinyan815/LearningKubernetes 访问下载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个仓库里我给出了MySQL和Redis的详细安装步骤，以及各种资源的YAML定义文件，包括之前安装ETCD集群的教程也整合到了这个仓库里。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;安装步骤详解，参考 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247487400&amp;amp;idx=1&amp;amp;sn=bd6b3eca835cbe65fb70a4dfe9326037&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;用Kubernetes搭建ETCD集群和WebUI&lt;/a&gt;&lt;/p&gt;&lt;p&gt;关于安装过程中遇到的问题可以在留言里跟我交流，大家还想看其他基础软件在Kubernetes上的安装教程的话也可以告诉我。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章里整理了在Kubernetes上安装MySQL和Redis这两款我们常用的基础软件的操作步骤，由于目的是在本地开发环境用，所以力求资源定义尽量简单，能做到数据可持久化就行了，高可用不再这里讨论。如果你对在Kubernetes上创建MySQL集群有兴趣，可以参考我下面给出的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MySQL Operator FOR Kubernetnes&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;资料引用&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;MySQL Operator FOR Kubernetnes: &lt;span&gt;:https://medium.com/oracledevs/getting-started-with-the-mysql-operator-for-kubernetes-8df48591f592&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>