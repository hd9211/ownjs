<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>884628e91e4519772281b9da99eda1f2</guid>
<title>优质网站同好者周刊（第 61 期）- 倾城之链 - 悠然宜想亭</title>
<link>https://toutiao.io/k/y74arhr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot; rel=&quot; nofollow ugc&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot; rel=&quot; nofollow ugc&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot; rel=&quot; nofollow ugc&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot; rel=&quot; nofollow ugc&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E5%8F%91%E8%80%85&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;开发者&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：roadmap, developer roadmaps, developer roadmap, frontend developer, frontend developer roadmap, frontend, frontend roadmap, backend, backend developer, backend developer roadmap, devops, devops roadmap, fullstack developer roadmap, guide to becoming a developer, sre roadmap, sre, operations roadmap, qa roadmap, android roadmap, android developer roadmap&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Community driven roadmaps, articles, guides, quizzes, tips and resources for developers to learn from, identify their career paths, know what they don`t know, find out the knowledge gaps, learn and improve.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/roadmap.sh.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Developer Roadmaps&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://roadmap.sh/&quot; rel=&quot; nofollow ugc&quot;&gt;Roadmap.sh&lt;/a&gt; 是一个包含社区策划的路线图、学习计划、路径和资源的地方，供新兴开发人员使用（网站基于 &lt;a href=&quot;https://nicelinks.site/post/61c928af5be6454b4e3d5146&quot; rel=&quot; nofollow ugc&quot;&gt;Next.js&lt;/a&gt; 构建）。它最初是一组图表，用于指导 对下一步应该学习什么感到困惑的开发人员，但仅此还不够，因此我将其扩展到网站，以吸引更多贡献者。&lt;/p&gt;

&lt;p&gt;Roadmap.sh 涉猎内容非常丰富，诸如：FrontEnd、BackEnd、DevOps、&lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot; rel=&quot; nofollow ugc&quot;&gt;React&lt;/a&gt;、Android、Python、Go、Java、DBA 等；作者将主题所涉及的相关内容，及其关系，绘制于一张图内，形成指南，从而为开发者带来参考。除了路线图外，该网站还提供有些技术（工具）相关的文章、视频相关分享。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://roadmap.sh/&quot; rel=&quot; nofollow ugc&quot;&gt;Roadmap.sh&lt;/a&gt; 是一个开源项目，截止 2022 年 4 月份，其 Star 数接近 20 万，每月有数十万开发人员访问。您如果对其感兴趣，可订阅更新（支持免费、也支持更新付费内容）。如果你想更多充分了解它，请参见 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://roadmap.sh/about&quot; rel=&quot; nofollow ugc&quot;&gt;About Roadmap.sh&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6258222ff3a35106466b7702&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Developer Roadmaps&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;编程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A4%BE%E5%8C%BA&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;社区&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：freecodecamp, 编程, 前端, 后端, 程序员, python, javascript, git, aws, json, html, css, bootstrap, react, vue, 网站, web, 开发, 课程&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;freeCodeCamp 是一个免费学习编程的开发者社区，涵盖 Python、HTML、CSS、React、Vue、BootStrap、JSON 教程等，还有活跃的技术论坛和丰富的社区活动，在你学习编程和找工作时为你提供建议和帮助。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/chinese.freecodecamp.org.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 免费学习编程 - Python、JavaScript、Java、Git 等&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://chinese.freecodecamp.org/&quot; rel=&quot; nofollow ugc&quot;&gt;freeCodeCamp.org&lt;/a&gt;，是一个&lt;strong&gt;免费学习编程的&lt;/strong&gt;开发者社区，涵盖 Python、HTML、CSS、React、Vue、BootStrap、JSON 教程等，还有活跃的技术论坛和丰富的社区活动，在你学习编程和找工作时为你提供建议和帮助。其官网介绍道：自 2014 年以来，已有超过 40,000 名学员，入职科技公司。&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://chinese.freecodecamp.org/&quot; rel=&quot; nofollow ugc&quot;&gt;freeCodeCamp.org&lt;/a&gt; 的使命是：帮助人们免费学习编程。我们通过创建成千上万的视频、文章和交互式编程课程——所有内容向公众免费开放——来实现这一目标。学员在世界各地自发成立数千个 freeCodeCamp 学习小组。所有给 freeCodeCamp 的捐款都将用于我们的教育项目，购买服务器和其他服务，以及聘用员工。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;在 freeCodeCamp.org，您可以获得以下免费认证：响应式网页设计、JavaScript 算法和数据结构、前端开发库、数据可视化、后端开发和 APIs、Python 和科学计算、Python 和数据分析、Python 和机器学习、信息安全、关系数据库、质量保证等等。&lt;/p&gt;

&lt;p&gt;先前因为检索 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot; rel=&quot; nofollow ugc&quot;&gt;React&lt;/a&gt; 开发建议，再一次接触到 freeCodeCamp 这个网站，进一步浏览，发现非常多值得阅览的优质文章；深入了解后发现，这是一个&lt;strong&gt;免费学习编程的&lt;/strong&gt;开发者社区，其涉猎内容之广，令人惊叹；相信，无论您是编程初学者，或是已经有丰富编程经验，在这里，都会收获很多；当然，您也可以在 freeCodeCamp 分享自己的学识与经验，从而惠及更多人。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6256c645f3a35106466b7700&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 免费学习编程 - Python、JavaScript、Java、Git 等&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;命令行&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A8%8B%E5%BA%8F%E5%91%98&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;程序员&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Curl is used in command lines or scripts to transfer data. curl is also used in cars, television sets, routers, printers, audio equipment, mobile phones, tablets, settop boxes, media players and is the Internet transfer engine for thousands of software applications in over ten billion installations.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/curl.se.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - curl | command line tool and library for transferring data with URLs&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://curl.se/&quot; rel=&quot; nofollow ugc&quot;&gt;Curl&lt;/a&gt; 非常有用的命令行工具库，用于通过 URL 传输数据（是一款免费开源软件）。它的名字就是客户端（client）的 URL 工具的意思（&lt;strong&gt;command line tool and library&lt;/strong&gt; for transferring data with URLs）。它的功能非常强大，命令行参数多达几十种。如能熟练使用，可以在很多应用场景下，发挥巨大的价值。比如，Curl 还用于汽车、电视机、路由器、打印机、音频设备、移动电话、平板电脑、机顶盒、媒体播放器，并且是安装量超过 100 亿的数千个软件应用程序的 Internet 传输引擎。&lt;/p&gt;

&lt;p&gt;Curl 功能非常强大，支持 DICT、FILE、FTP、FTPS、GOPHER、GOPHERS、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、MQTT、POP3、POP3S、RTMP、RTMPS、RTSP、SCP、SFTP、SMB、SMBS、SMTP、SMTPS、TELNET 和 TFTP。curl 支持 SSL 证书、HTTP POST、HTTP PUT、FTP 上传、基于 HTTP 表单的上传、代理、HTTP/2、HTTP/3、cookie、用户+密码身份验证（Basic、Plain、Digest、CRAM-MD5、SCRAM-SHA、 NTLM、Negotiate 和 Kerberos）、文件传输恢复、代理隧道等格式。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://curl.se/&quot; rel=&quot; nofollow ugc&quot;&gt;Curl&lt;/a&gt; 是一款免费开源软件，截止 2021 年 2 月，最近稳定版本是 &lt;strong&gt;7.75.0&lt;/strong&gt;；无论是 Windows、Mac 还是 Linux 系统，Curl 都已默认安装，因此您可以直接使用。全球几乎每个使用 Internet 的人每天都在使用 Curl。无论您是否从事编程相关工作，相信知晓 Curl 之妙用，将会在很多场景，给你带来效率提升；如果您对这款工具软件感兴趣，可参见文章：&lt;a href=&quot;https://quickapp.lovejade.cn/magic-tools-series-curl/&quot; rel=&quot; nofollow ugc&quot;&gt;堪称神器的命令行工具系列之 curl&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62556c92f3a35106466b76fe&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - curl | command line tool and library for transferring data with URLs&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AE%98%E7%BD%91&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;官网&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BE%8E%E9%A3%9F&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;美食&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;海底捞成立于 1994 年，是一家以经营川味火锅为主的连锁品牌，创始人为张勇。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.haidilao.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - 海底捞&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.haidilao.com/&quot; rel=&quot; nofollow ugc&quot;&gt;海底捞&lt;/a&gt;，是一家以经营川味火锅为主的连锁品牌，成立于 1994 年，它以经营川味火锅为主、融汇各地火锅特色为一体，是大型跨省直营餐饮品牌火锅店，全称是：四川海底捞餐饮股份有限公司 。在北京、上海、郑州、西安、南京、天津、杭州，简阳等城市开有连锁门店。该品牌自创立以来，始终奉行“&lt;strong&gt;服务至上，顾客至上&lt;/strong&gt;”的理念，以贴心，周到，优质的服务，赢得了纷至沓来的顾客和社会的广泛赞誉。&lt;/p&gt;

&lt;p&gt;2018 年 5 月 17 日，海底捞在港交所递交上市申请。 2018 年 9 月 3 日，海底捞通过港交所上市聆讯，上半年营收 73.42 亿同比增 54.4%。 2018 年 9 月 27 日，海底捞在港交所上市。 2021 年 11 月 5 日，海底捞公告：决定在 2021 年 12 月 31 日逐步关停 300 家左右客流量相对较低、及经营业绩不如预期的海底捞门店。这几年，在商业上的发展，因各种原因，海底捞似乎不及预期。&lt;/p&gt;

&lt;p&gt;晚上有跟朋友到附近（深圳福田）「海底捞」用餐，其环境尚可（虽然占地颇广，座位宽松，但食客蛮多，有些吵闹），食材新鲜，味道颇好，服务极佳，甚得我心；如不是疫情反复突袭，倒是可以常常光顾。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6252e4fef3a35106466b76fc&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - 海底捞&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%BA%94%E7%94%A8&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;应用&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Chrome&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;Chrome&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%89%A9%E5%B1%95&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;扩展&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Textomap: Create interactive maps in one click,&lt;br/&gt;
from any text you&#x27;re reading or writing about.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.textomap.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Textomap&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.textomap.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Textomap&lt;/a&gt;，是一个网络应用程序和 Chrome 扩展程序，使用户能够立即（几秒中）从包含位置的任何文本生成地图。用户可以将地图添加到他们的阅读体验中，并使用 Chrome 扩展程序在同一浏览器选项卡中可视化文本。它具有以下特征：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用简单，只需在文本框，粘贴您的文本（带有地点内容），它即可开始工作；&lt;/li&gt;
&lt;li&gt;支持多种语言，比如：中文、英文等；而且生成的地图，也跟所输入的本文语言相符；&lt;/li&gt;
&lt;li&gt;无需离开页面，即可为您的阅读体验添加地图；&lt;/li&gt;
&lt;li&gt;使用 Chrome 扩展程序，可&lt;strong&gt;一键可视化&lt;/strong&gt;同一浏览器选项卡中的任何文本；&lt;/li&gt;
&lt;li&gt;支持添加多个来源，收集和比较内容，识别模式和趋势，轻松更新和&lt;strong&gt;编辑&lt;/strong&gt;；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;目前，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.textomap.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Textomap&lt;/a&gt; 尚处于公测版本；地图为我们提供重要信息，可让我们更清楚地了解情况。无论是当前新闻、下一个度假目的地，还是有关人物和地点的文章，地图都能为您提供更好的背景和概览。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62529693f3a35106466b76fa&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Textomap&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AI&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AC%E6%8D%A2&quot; rel=&quot; nofollow ugc&quot;&gt;&lt;code&gt;转换&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;Image to Cartoon is an online AI cartoonizer that converts your face to cartoon style. Create cartoon avatar and emoji yourself.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/imagetocartoon.com.png?x-oss-process=style/png2jpg&quot; title=&quot;&quot; alt=&quot;倾城之链 - Image to Cartoon | Cartoonize and emoji yourself&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://imagetocartoon.com/&quot; rel=&quot; nofollow ugc&quot;&gt;Cartoonize&lt;/a&gt;，一款在线将&lt;strong&gt;图片&lt;/strong&gt;转&lt;strong&gt;卡通&lt;/strong&gt;的网站，堪称：免费在线最佳 AI 漫画家；Cartoonize 可以将您的脸部照片变成具有 40 多种不同卡通效果的卡通。由人工智能（AI）技术提供支持，它可能是您应用令人难以置信的背景的最佳卡通头像制作者。体验了下，总结出 Cartoonize 具有以下几个特点：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;不仅可以将人脸照片转换为卡通，还可以自己转换表情符号；&lt;/li&gt;
&lt;li&gt;Cartoonize，支持免费使用，每周限制为 9 张；&lt;/li&gt;
&lt;li&gt;免费版本效果有限，您想要下载更具特色的版本，需要帮作者买杯咖啡来解锁；&lt;/li&gt;
&lt;li&gt;使用非常简单，上传照片，等待出结果，选择喜欢的效果，下载即可；&lt;/li&gt;
&lt;li&gt;除了网站外，Cartoonize 还支持 iOS、Android 版本应用；&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;有体验 Cartoonize 的 Web 和 iOS 版本，所转换出卡通效果，还可以。Cartoonize 依靠广告和增值服务获得利益，所以在应用程序上，你会看到广告。如果您有兴趣，将自己的头像卡通化，那么 Cartoonize 是一个挺不错的选择。&lt;/p&gt;

&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6252908db7bf120669dbd40f&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链 - Image to Cartoon | Cartoonize and emoji yourself&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;

&lt;p&gt;&amp;lt;div align=&quot;center&quot;&amp;gt;&amp;lt;img src=&quot;&lt;a href=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; rel=&quot; nofollow ugc&quot;&gt;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&lt;/a&gt;&quot; style=&quot;width: 200px;min-width: 200px;&quot; alt=&quot;倾城之链 - 客服微信&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;h2&gt;本期文末寄语&lt;/h2&gt;

&lt;p&gt;宠辱若惊，贵大患若身。何谓宠辱若惊？&lt;strong&gt;宠为下，得之若惊，失之若惊，是谓宠辱若惊&lt;/strong&gt;。何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患？故贵以身为天下，若可寄天下；爱以身为天下，若可托天下。── 春秋末期人 · 老子李耳《道德经》第十三章&lt;/p&gt;

&lt;blockquote class=&quot;uncited&quot;&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot; rel=&quot; nofollow ugc&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; title=&quot;&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;您可能感兴趣的文章&lt;/h3&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4ef55cf79afd95780d8e23147e3cbb31</guid>
<title>基于 js 实现一个小型编译器</title>
<link>https://toutiao.io/k/h02g7il</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;本文内容基于 https://github.com/jamiebuilds/the-super-tiny-compiler 仓库源码进行学习&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxNjgwMDIzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/udZl15qqib0OiahcrjrJncW0GOiclg6Jic6IQHYeIGzfXSbZicLUeUxNyQVmPSelMxQxTSu8wAibsyXjy9U3pVfic7FGA/0?wx_fmt=png&quot; data-nickname=&quot;全栈前端精选&quot; data-alias=&quot;Just_FED&quot; data-signature=&quot;内容为王，精选为则。从前端到全栈，定期分享前端、客户端、Node、面试、职场感悟等相关高质量文章。小白的大神养成记，你我共勉！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;最近在研究一些构建侧的东西，在翻 babel 官网的时候看到了这样一段话:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;For an awesome tutorial on compilers, check out the-super-tiny-compiler, which also explains how Babel itself works on a high level.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;出于学习的心态，去翻了一下这个仓库源码，以下是笔者的一些学习的记录，希望看完之后能对你理解 babel 的工作原理有一些帮助~&lt;/p&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;the-super-tiny-compiler&lt;/code&gt;是一个代码行数只有不到 200 行的超级小型的 compiler，但通过这个 compiler 能学习到最基础的 compile 原理，包括 babel 也是基于这样的原理来进行开发的。&lt;br/&gt;仓库本身的例子是将一组 lisp 风格的函数语法编译成了 C 风格的函数语法，举例子来说:&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;LISP 风格&lt;/th&gt;&lt;th&gt;C 风格&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2+2&lt;/td&gt;&lt;td&gt;(add 2 2)&lt;/td&gt;&lt;td&gt;add(2,2)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4-2&lt;/td&gt;&lt;td&gt;(subtract 4 2)&lt;/td&gt;&lt;td&gt;substract(4, 2)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2 + (4 - 2)&lt;/td&gt;&lt;td&gt;(add 2 (substract 4 2))&lt;/td&gt;&lt;td&gt;add(2, (substract(4, 2)))&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;这就大概是这次 compiler 需要完成的事情，可能看上去语法不是很完整，但是也能够演示现代编译器的主要部分思想了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;大多数的 Compilers 都会把编译过程分成三个主要的过程: parse、transform 以及 code generate：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;parse 主要是将源码转换成一种更抽象的代码表达&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;transform 则是将上面抽象的表达进行任意 compiler 想进行的操作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;code generate 将 transform 处理之后的代码生成一种新的代码&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;Parse&lt;/h2&gt;&lt;p&gt;parse 主要分为两个步骤: 词法分析以及语法分析。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;词法分析将源码根据表达切分一个个的 tokens，tokens 是一组用来描述单独语法的对象，可以是 numbers、labels、punctuation、operators 等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;语法分析则是将词法分析生成的 tokens 进行重新编排得到一个叫做抽象语法&lt;/span&gt;树&lt;span&gt;(AST)的结构，AST 是一种易于使用且能展示完整信息的嵌套树状结构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;例如前面提到的 &lt;code&gt;add 2 (subtract 4 2)&lt;/code&gt;表达式被词法分析处理之后生成的 tokens 大概是:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;,   &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;      },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;,   &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt; },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;        },&lt;br/&gt;  { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;        }&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;语法分析处理出来的 AST 结构为:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;body&lt;/span&gt;: [&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;params&lt;/span&gt;: [&lt;br/&gt;          {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;          },&lt;br/&gt;         {&lt;br/&gt;           &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;           &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;           &lt;span&gt;params&lt;/span&gt;: [&lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;,&lt;br/&gt;            }, &lt;br/&gt;            {&lt;br/&gt;              &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;              &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;            }&lt;br/&gt;           ]&lt;br/&gt;         }]&lt;br/&gt;      }]&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Transform&lt;/h2&gt;&lt;p&gt;transform 主要就是拿到 parse 得到的抽象语法树，并基于此做出一些修改。tranform 这个过程既可以基于当前语言的风格去修改 ast 也可以使用一种新的语言风格。&lt;br/&gt;下面基于前面的 ast 结构来展示 transform 这个过程的工作流程。&lt;br/&gt;可以看到，ast 里面的元素看起来都很相似，这些元素组成了 ast 的子结点，这些子结点的数据结构类型描述了代码中的一个单独的部分(例如变量、声明语句，表达式等等)。&lt;br/&gt;例如上面提到的类型是 &lt;code&gt;NumberLiteral&lt;/code&gt;的节点:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者更复杂一点的子节点类型:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;substract&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;params&lt;/span&gt;: [...nested nodes here ...],&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 transfrom 这个过程中，我们可以通过增/删/改来操作抽象语法树结点，或者可以直接基于当前的抽象语法树创建一个新的出来。&lt;br/&gt;既然这里我们的目标是将输入的代码转换成一种新的语言风格的代码(Lisp -&amp;gt; C)，所以这里会创建一个针对新语言的全新 AST 出来。&lt;br/&gt;因此这里我们需要明确一下修改 AST 的操作:&lt;/p&gt;&lt;h3&gt;Traversal(遍历)&lt;/h3&gt;&lt;p&gt;为了能处理所有的结点，我们可以用深度优先搜索对其进行遍历:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;  body: [{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;    name: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;    params: [{&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;      value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;    }, {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;      params: [{&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;&lt;br/&gt;      }, {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;      }]&lt;br/&gt;    }]&lt;br/&gt;  }]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;遍历流程是这样的:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Program - 从 AST 的顶结点开始&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CallExpression (add) - Program 的第一个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NumberLiteral (2) - CallExpression (add) 的第一个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CallExpression (subtract) - CallExpression (add) 的第二个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NumberLiteral (4) - CallExpression (subtract) 的第一个子元素&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NumberLiteral (2) - CallExpression (subtract) 的第二个子元素&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果直接在 ast 内部操作而不是产生一个新的 ast，可能就需要介绍所有的种类的抽象。但目前来看，访问所有结点的方法已经足够了。&lt;br/&gt;访问(visiting) 这个词代表一种在对象结构内对元素进行操作的模式。&lt;/p&gt;&lt;h3&gt;Visitors(访问)&lt;/h3&gt;&lt;p&gt;这里我们可以创建一个 visitor 对象，这个对象包括一些方法用于接收不同的结点。&lt;br/&gt;例如:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; visitor = {&lt;br/&gt;  &lt;span&gt;&lt;span&gt;NumberLiteral&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt; {},&lt;br/&gt;  &lt;span&gt;&lt;span&gt;CallExpression&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt; {}&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此当我们遍历 ast 的时候，如果匹配到了对应 type 的结点，可以调用 visitor 中的方法来处理。&lt;/p&gt;&lt;h2&gt;Code generate&lt;/h2&gt;&lt;p&gt;Compiler 的最后一个阶段就是 generate, 这个阶段做的事情可能会和 transformation 重叠，但是代码生成最主要的部分还是根据 AST 来输出代码。&lt;br/&gt;Generate 有几种不同的工作方式，有些 Compilers 会重用之前生成的 token，有些则会创建独立的代码表示，以便于线性输出代码，但接下来我们还是着重于使用之前生成好的 AST。&lt;br/&gt;我们的生成器需要知道如何打印 AST 中的所有类型结点，然后递归调用自身，知道所有的代码都被打印到一个很长的字符串中。&lt;/p&gt;&lt;h2&gt;代码实现&lt;/h2&gt;&lt;p&gt;以上就是 Compiler 所有的部分了，但并不是所有的 Compiler 都是这样，不同的 compiler 目的不同，所以也可能需要不同的步骤。&lt;br/&gt;接下来就开始代码的编写:&lt;/p&gt;&lt;h3&gt;词法分析器(tokenizer)&lt;/h3&gt;&lt;p&gt;按照前面的理论分析，我们一步先进行 parser 这个阶段里面的词法分析器(tokenizer)。&lt;br/&gt;这个函数接收一个字符串，然后将其分割成由 token 组成的数组:&lt;br/&gt;ex:&lt;br/&gt;&lt;code&gt;(add 2 (substract 4 2))&lt;/code&gt; =&amp;gt;&lt;code&gt;[{ type: &#x27;paren&#x27;, value: &#x27;(&#x27;}, ...]&lt;/code&gt;&lt;/p&gt;&lt;p&gt;因此可以编写这样的一个函数:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; tokenizer = &lt;span&gt;(&lt;span&gt;input&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; tokens = [];&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; current = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (current &amp;lt; input.length) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; char = input[current];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (char === &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;) {&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;,&lt;br/&gt;      })&lt;br/&gt;&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (char === &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;) {&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;)&#x27;&lt;/span&gt;,&lt;br/&gt;      })&lt;br/&gt;      current ++;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 空格目前不需要处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/\s/&lt;/span&gt;.test(char)) {&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理数字&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/[0-9]/&lt;/span&gt;.test(char)) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; value = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 一直遍历直到遇到非数字的字符&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;/[0-9]/&lt;/span&gt;.test(char)) {&lt;br/&gt;        value += char;&lt;br/&gt;        char = input[++current];&lt;br/&gt;      }&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;,&lt;br/&gt;        value,&lt;br/&gt;      })&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理字符串&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;/[a-z]/i&lt;/span&gt;.test(char)) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; value = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;/[a-z]/i&lt;/span&gt;.test(char)) {&lt;br/&gt;        value += char;&lt;br/&gt;        char = input[++current];&lt;br/&gt;      }&lt;br/&gt;      tokens.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;,&lt;br/&gt;        value,&lt;br/&gt;      });&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 如果存在匹配不上的 token 就抛错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown token: &lt;span&gt;${char}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tokens;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;语法分析器(parser)&lt;/h3&gt;&lt;p&gt;词法分析器接收语法分析得到的 token 数组，然后将其转换成 AST 结构。&lt;br/&gt;例如:&lt;br/&gt;&lt;code&gt;[{ type: &#x27;paren&#x27;, value: &#x27;(&#x27; }, ...]&lt;/code&gt; =&amp;gt; &lt;code&gt;{ type: &#x27;Program&#x27;, body: [...] }&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; parser = &lt;span&gt;(&lt;span&gt;tokens&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; current = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; walk = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; token = tokens[current];&lt;br/&gt;    &lt;span&gt;// 如果是 number 类型的结点，返回一个新的 ast 节点即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (token.type === &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;) {&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: token.value,&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 接下来检查 CallExpression 类型，先从左圆括号开始&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;      token.type === &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;      token.value === &lt;span&gt;&#x27;(&#x27;&lt;/span&gt;&lt;br/&gt;    ) {&lt;br/&gt;      &lt;span&gt;// 跳过左圆括号&lt;/span&gt;&lt;br/&gt;      token = tokens[++current];&lt;br/&gt;      &lt;span&gt;// 首先会创建一个 CallExpression 的根节点，然后 name 设置成当前的 token.value&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 因为左圆括号后的 token 一定是函数名称&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; node = {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;: token.value,&lt;br/&gt;        &lt;span&gt;params&lt;/span&gt;: [],&lt;br/&gt;      };&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 这里再跳一次函数名称&lt;/span&gt;&lt;br/&gt;      token = tokens[++current];&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 通过循环遍历接下来的每个 token，直到遇到右圆括号&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 这些 token 会成为 `CallExpression` 的  `params`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 以 lisp 风格的代码来说: (add 2 (substract 4 2))&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;/**&lt;br/&gt;       * token 中会有很多圆括号&lt;br/&gt;       * [&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        },&lt;br/&gt;          { type: &#x27;name&#x27;,   value: &#x27;add&#x27;      },&lt;br/&gt;          { type: &#x27;number&#x27;, value: &#x27;2&#x27;        },&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        },&lt;br/&gt;          { type: &#x27;name&#x27;,   value: &#x27;subtract&#x27; },&lt;br/&gt;          { type: &#x27;number&#x27;, value: &#x27;4&#x27;        },&lt;br/&gt;          { type: &#x27;number&#x27;, value: &#x27;2&#x27;        },&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        }, &amp;lt;&amp;lt;&amp;lt; 右圆括号&lt;br/&gt;          { type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        }  &amp;lt;&amp;lt;&amp;lt; 右圆括号&lt;br/&gt;        ]&lt;br/&gt;        遇到嵌套的 CallExpressions 的时候，会通过 walk 函数来处理&lt;br/&gt;       *&lt;br/&gt;       */&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt; (&lt;br/&gt;        token.type !== &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt; ||&lt;br/&gt;        (token.value !== &lt;span&gt;&#x27;)&#x27;&lt;/span&gt; &amp;amp;&amp;amp; token.type === &lt;span&gt;&#x27;paren&#x27;&lt;/span&gt;)&lt;br/&gt;      ) {&lt;br/&gt;        node.params.push(walk());&lt;br/&gt;        token = tokens[current];&lt;br/&gt;      }&lt;br/&gt;      current++;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown token type: &lt;span&gt;${token.&lt;span&gt;type&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ast = {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;body&lt;/span&gt;: [],&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;   * 使用递归函数将结点处理进 ast.body 中&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (current &amp;lt; tokens.length) {&lt;br/&gt;    ast.body.push(walk());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ast;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;遍历器(visitors)&lt;/h3&gt;&lt;p&gt;通过语法分析得到 ast 之后，接下来需要一个遍历器 (visitors) 去遍历结点。然后当遇到某个类型的结点的时候，可以调用 visitors 中对应的类型处理函数:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;traverse(ast, {&lt;br/&gt;  &lt;span&gt;&lt;span&gt;Program&lt;/span&gt;(&lt;span&gt;node, parent&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;CallExpression&lt;/span&gt;(&lt;span&gt;node, parent&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;NumberLiteral&lt;/span&gt;(&lt;span&gt;node, parent&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此我们的代码可以这样写:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; traverser = &lt;span&gt;(&lt;span&gt;ast, visitor&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 用于对数组中的每个元素都调用 traverseNode 函数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; traverseArray = &lt;span&gt;(&lt;span&gt;array, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    array.forEach(&lt;span&gt;(&lt;span&gt;child&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      traverseNode(child, parent);&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 函数接收一个 node 以及其父结点作为参数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 这个结点会被传入到 visitor 中相应的处理函数那里&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; traverseNode = &lt;span&gt;(&lt;span&gt;node, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; method = visitor[node.type];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (method) {&lt;br/&gt;      method(node, parent);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 对不同的结点分开处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (node.type) {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;:&lt;br/&gt;        traverseArray(node.body, node);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;:&lt;br/&gt;        traverseArray(node.params, node);&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;br/&gt;      &lt;span&gt;// 这种情况下就没有子节点了，直接 break 出去&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown node type: &lt;span&gt;${node.&lt;span&gt;type&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  traverseNode(ast, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;转换器(transformer)&lt;/h3&gt;&lt;p&gt;转换器配合上面的遍历器来一起使用，它接收之前构建好的 ast，然后将其和 visitor 一起传入遍历器中，从而得到一个全新的 AST 出来。&lt;br/&gt;原始的 AST 结构为(&lt;code&gt;add 2 (subtract 4 2)&lt;/code&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;  body: [{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;    name: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;    params: [{&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;      value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;    }, {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;      name: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;      params: [{&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;&lt;br/&gt;      }, {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;&lt;br/&gt;      }]&lt;br/&gt;    }]&lt;br/&gt;  }]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转换之后生成的 AST 结构为(&lt;code&gt;add(2, subtract(4, 2))&lt;/code&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;  body: [{&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;ExpressionStatement&#x27;&lt;/span&gt;,&lt;br/&gt;    expression: {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;      callee: {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;,&lt;br/&gt;        name: &lt;span&gt;&#x27;add&#x27;&lt;/span&gt;,&lt;br/&gt;      },&lt;br/&gt;      arguments: [{&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;      }, {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        callee: {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;,&lt;br/&gt;          name: &lt;span&gt;&#x27;subtract&#x27;&lt;/span&gt;,&lt;br/&gt;        },&lt;br/&gt;        arguments: [{&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;          value: &lt;span&gt;&#x27;4&#x27;&lt;/span&gt;,&lt;br/&gt;        }, {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;          value: &lt;span&gt;&#x27;2&#x27;&lt;/span&gt;,&lt;br/&gt;        }]&lt;br/&gt;      }]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们可以这样编写对应的转换器代码:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; transformer = &lt;span&gt;(&lt;span&gt;ast&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; newAst = {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;body&lt;/span&gt;: [],&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  ast._context = newAst.body;&lt;br/&gt;&lt;br/&gt;  traverser(ast, {&lt;br/&gt;    &lt;span&gt;// 处理 NumberLiteral 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;NumberLiteral&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;node, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      parent._context.push({&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: node.value,&lt;br/&gt;      });&lt;br/&gt;    },&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理 CallExpression 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;CallExpression&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;node, parent&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 初始化一个 CallExpression 的新节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 里面放个嵌套的 Identifier 节点&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; expression = {&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;callee&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;name&lt;/span&gt;: node.name&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;arguments&lt;/span&gt;: [],&lt;br/&gt;      };&lt;br/&gt;&lt;br/&gt;      node._context = expression.arguments;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 看看父节点是不是 CallExpression&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (parent.type !== &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;) {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 如果不是的话，就将 CallExpression 节点包在一个叫 `ExpressionStatement` 的语句节点里&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 这么做是因为 top level 的 CallExpression 在 JavaScript 中也可以被当成是声明语句&lt;/span&gt;&lt;br/&gt;        expression = {&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;ExpressionStatement&#x27;&lt;/span&gt;,&lt;br/&gt;          expression,&lt;br/&gt;        };&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 最后我们把 CallExpression 放入父结点的 context 中&lt;/span&gt;&lt;br/&gt;      parent._context.push(expression);&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; newAst;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;代码生成器(code generator)&lt;/h3&gt;&lt;p&gt;代码生成器同样是个递归函数，最后会将 AST 中的每个结点打印到一个大的字符串中:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; codeGenerator = &lt;span&gt;(&lt;span&gt;node&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;switch&lt;/span&gt; (node.type) {&lt;br/&gt;    &lt;span&gt;// 如果是 Program，则会遍历 &#x27;body&#x27; 属性中的每个结点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 并且对这些结点进行递归 codeGenerator,再把结果打印进新的一行里面&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;Program&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node.body.map(codeGenerator).join(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 对于 ExpressionStatement 对 expression 属性进行递归调用，并加个分号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;ExpressionStatement&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`&lt;span&gt;${codeGenerator(node.expression)}&lt;/span&gt;;`&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 对于 CallExpression 对 callee 属性进行递归调用，接着加上(括号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 然后对 arguments 属性进行递归调用，并加上)括号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;CallExpression&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`&lt;span&gt;${codeGenerator(node.callee)}&lt;/span&gt;(&lt;span&gt;${node.&lt;span&gt;arguments&lt;/span&gt;.map(codeGenerator).join(&lt;span&gt;&#x27;, &#x27;&lt;/span&gt;)}&lt;/span&gt;)`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 对于 Identifier,直接返回 name&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;Identifier&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node.name;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 对于 NumberLiteral,直接返回 value&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&#x27;NumberLiteral&#x27;&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; node.value;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Unknown node type: &lt;span&gt;${node.&lt;span&gt;type&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;编译器(Compiler)&lt;/h3&gt;&lt;p&gt;到这一步，基本上所有的流程就已经完成了，我们可以创建一个 compiler 函数，通过调用上面的函数就可以完成整个 compiler 的工作了:&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;input =&amp;gt; tokenizer =&amp;gt; tokens&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;tokens =&amp;gt; parser =&amp;gt; ast&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ast =&amp;gt; transformer =&amp;gt; newAst&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;newAst =&amp;gt; generator =&amp;gt; output&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码只需要以下简单几步即可:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; compiler = &lt;span&gt;(&lt;span&gt;input&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; tokens = tokenizer(input);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ast = parser(tokens);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; newAst = transformer(ast);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; codeGenerator(newAst);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以输入前面的几组测试例子，能保证得到的结果是正确的。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;至此一个 tiny-compiler 就被造出来了，babel 的编译流程也是基于此来完成，因为 babel 本身是个 source to source 的 compiler，整个流程也是分为 parser -&amp;gt; transform -&amp;gt; code generate 这三个步骤完成，具体可以参考 https://babeljs.io/docs/en/#babel-is-a-javascript-compiler&lt;/p&gt;&lt;p&gt;希望本文能帮助读者理解相关编译工具的编译流程。&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c30ff0697987b0e8f5ee99f72d48bf5</guid>
<title>阿里技术副总裁贾扬清回应深夜逃离上海去美国；微信灰测腾讯数字人民币钱包小程序；美团被曝发生两年内最大一波裁员｜开发者头条</title>
<link>https://toutiao.io/k/sfq7jrm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d4f6ec9a06ca7609dd7d487476be1cb0</guid>
<title>如何发起 MQTT 亿级连接和千万消息吞吐性能测试</title>
<link>https://toutiao.io/k/fcjsli1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;108&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;108&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/yvBJb5IiafvkDP9P693A2LkDdhuUjNlzSictp1vkqM03G6MpXtYTibfiaepIqRibA6ku3YmKFoecGYZJaSibQQbq9eOQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;作者：亦炎&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;随着 5G 时代的来临，万物互联的伟大构想正在成为现实。联网的物联网设备 在 2021 年已经达到了 120 亿，在未来两年，仅智能水电气表就将超过 10 亿。在如此大的物联网需求下，海量的设备接入和设备管理对网络带宽、通信协议以及平台服务架构都带来了很大挑战。如何做好以 MQTT 为代表的物联网协议性能测试，也就显得尤为重要。那么，我们该如何做好 MQTT 的性能测试呢？&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;什么是 MQTT 协议&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MQTT 是基于 TCP/IP 协议栈构建的异步通信消息协议，是一种轻量级的发布、订阅信息传输协议。可在不可靠的网络环境中进行扩展，适用于设备硬件存储空间或网络带宽有限的场景。使用 MQTT 协议，消息发送者与接收者不受时间和空间的限制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于物联网协议来说，必须针对性地解决物联网设备通信的几个关键问题：其网络环境复杂而不可靠、其内存和闪存容量小、其处理器能力有限。MQTT 协议凭借简单易实现、支持 QoS、报文小等特点，占据了物联网协议的半壁江山。&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt; MQTT 的发布订阅模式&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;发布订阅模式区别于传统的客户端-服务器模式，它使发送消息的客户端（发布者）与接收消息的客户端（订阅者）分离，发布者与订阅者不需要建立直接联系。我们既可以让多个发布者向一个订阅者发布消息，也可以让多个订阅者同时接收一个发布者的消息，它的精髓在于由一个被称为代理的中间角色（或称为 MQTT Broker）负责所有消息路由和分发的工作。传统的客户端-服务器模式可以实现类似的效果，但是无法做到像发布订阅模式这样简洁和优雅。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发布订阅模式的优点在于发布者与订阅者的解耦，这种解耦表现在以下两个方面：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;空间解耦：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;订阅者与发布者不需要建立直接连接，新的订阅者想要加入网络时不需要修改发布者的行为。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;时间解耦：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;订阅者和发布者不需要同时在线，即便不存在订阅者也不影响发布者发布消息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;386&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6692015209125475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvkDP9P693A2LkDdhuUjNlzSwEztGF0PD3YQiah02VBVIGyECAMHGiaXPzYMQ29wZTpW1zfdEMNLl77w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;为什么要做 MQTT 性能测试&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;MQTT 性能测试主要帮助我们做到如下内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1. 摸清 MQTT 核心指标&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同网络环境下，消息端到端的时延&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MQTT Broker 同时保持的最大连接数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MQTT 收发消息的 TPS&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2.  辅助 MQTT Broker 选型&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;物联网行业里可选的 MQTT Broker 不胜枚举，除了经典的 Mosquitto 和 AWS、Azure，百度云、阿里云、IBM 等几个提供物联网 MQTT 接入服务的产品外，可用于商业生产的 MQTT Broker 还有多款。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是每一款 MQTT Broker 的系统性能与适用场景都不尽相同。例如，EMQ 单机性能较高，单机支持百万级并发，集群支持千万级并发，优势在于高并发连接与高吞吐消息的服务能力；HiveMQ 单机性能相对较差，有一定高并发连接与高吞吐消息的服务能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过 MQTT 性能测试，我们可以更加精准的选择合适的 MQTT Broker。&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;业界一般如何做 MQTT 性能测试？&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MQTT 性能测试的难点在于能够同时发起并保持海量的连接。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前最常见的 MQTT 性能测试方式，是基于 JMeter 的 MQTT-Xmeter 插件实现的。该插件的底层原理就是每个线程都模拟一个 MQTT Client，向 MQTT Broker 发送连接请求。然而 JMeter 的线程模型（一个并发就是线程）决定了，想要发起海量的连接请求，施压机就必须创建同等数量的线程，不仅造成资源的严重浪费，还限制了单个施压机能够发起的总连接请求数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿里云的性能测试 PTS 允许单个线程发起并保持最多 100 个，单台施压机最大 5 万个，单次压测最大 1 亿个 MQTT 连接数。使用 PTS 可以帮助用户轻松发起千万乃至亿级的 MQTT 连接，节省大量时间成本和机器成本。&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;如何使用 PTS 发起 MQTT 亿级连接和千万消息吞吐性能测试&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt; 使用步骤&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、创建场景。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们在 PTS 控制台的【压测中心】-&amp;gt;【&lt;/span&gt;&lt;span&gt;创建场景&lt;/span&gt;&lt;span&gt;】中创建 MQTT 压测场景；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;210&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3629160063391442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvkDP9P693A2LkDdhuUjNlzSEAzMIqQ4oKqBOkwZH4aw4fqANjRqFoo7iaarSuT1ibLFfjkP6uLnGItQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3786&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、场景配置。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;PTS 支持建立连接、发布消息、订阅消息和关闭连接四种测试节点。用户若仅需测试 Broker 支持的最大连接数，可以只创建建立连接节点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;对于阿里云的 MQTT 实例，用户只需要打开签名鉴权开关，填入 AccessKey ID、AccessKey Secret 和实例 ID 即可，PTS 会动态生成用户名和密码。PTS 支持指定单并发连接数，以及均匀递增、阶梯递增和固定压力三种流量模型。用户可以通过调整压测中并发数，来控制 MQTT 连接数的增长速率。&lt;br/&gt;&lt;br/&gt;场景配置示例：1 万个 MQTT 连接作为 pub 客户端发送消息，每个 pub 客户端每秒发送 1 条 QoS0 消息；99 万个 MQTT 连接作为 sub 客户端接收消息，每个 sub 客户端每秒接收 1 条 QoS0 消息。因此，总的消息发布吞吐率为每秒 10000，总的消息接收吞吐率达到每秒 100 万。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;184&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3187203791469194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvkDP9P693A2LkDdhuUjNlzSzjIIZeqjtyDQUN3IKMJ5jMOh24E7guM67dFZK74TpiaAkrPI58FwzaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3376&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;276&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47739602169981915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvkDP9P693A2LkDdhuUjNlzSEx5SJFG9Yb2zwsRia8mib4GmyIIQHZdbbWHicpiaZI72zYbSaS0KWoK6Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3318&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;总结&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文阐述了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、什么是 MQTT 协议&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、MQTT 性能测试必要性&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、使用 PTS 做 MQTT 性能测试的优势&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、如何使用 PTS 快速发起 MQTT 性能测试&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，PTS 全新售卖方式来袭，基础版价格直降 50%！百万并发价格只需 6200！更有新用户 0.99 体验版、VPC 压测专属版，欢迎大家选购！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1044&quot; data-backw=&quot;375&quot; data-ratio=&quot;2.784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvkDP9P693A2LkDdhuUjNlzSAZrzSZHYBga9kJ0l962Ccu1ptE3R9nMyQZPNOqecJwsTsGkWTwjXSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;点击&lt;/span&gt;&lt;strong&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，了解微消息队列 MQTT 版更多资讯！&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9e072b8e76c3ac3ad19e54cececf799</guid>
<title>短视频内容理解与生成技术在美团的创新实践</title>
<link>https://toutiao.io/k/hu3rp7y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;美团技术团队&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;meituantech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>