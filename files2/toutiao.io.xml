<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fa12661745939f820ef3480e9fa3ab0e</guid>
<title>让您的 Android Auto 应用吸引更多用户</title>
<link>https://toutiao.io/k/8thoryh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;i&gt;作者 / 产品经理 Eric Bahna&lt;/i&gt;&lt;/p&gt;&lt;p&gt;去年 12 月份，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android-developers.googleblog.com/2020/12/opening-google-play-store-for-more-car.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我们更新了 Google Play 商店，以允许开发者发布新的 Android Auto 应用进行封闭式测试&lt;/a&gt;&lt;/b&gt;。现在，您可以将导航、停车以及收费类的应用发布到 Google Play 商店进行开放式测试，以触达更多的用户。在开放式测试中，可下载应用的用户数没有任何限制，您也无需管理电子邮件列表。这是一个重要的里程碑，借此我们能够更方便地将这些应用提供给所有实际使用的用户。您可以着手使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/navigation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android 汽车应用库&lt;/a&gt;&lt;/b&gt;并在 Play 管理中心选择开放式测试轨道。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1198&quot; data-rawheight=&quot;718&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1198&quot; data-rawheight=&quot;718&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们的早期合作伙伴之一 TomTom AmiGO&lt;/p&gt;&lt;p&gt;提前透露一下我们未来的工作: 我们会将 Android 汽车应用库添加到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android Jetpack&lt;/a&gt;&lt;/b&gt; 中！这样您就能保留与其他 Jetpack API 一致的体验，同时还能查看新的功能。我们添加该 Jetpack 开发库后，您可以轻松将自己的应用从现有库中迁移到该库，只需更改命名空间，并调整一些 API 调用即可。当该 Jetpack 库测试稳定后，我们会准备好 Google Play 商店，以便您能将这些新应用发布到生产轨道上。&lt;/p&gt;&lt;p&gt;当然，您现在就可以着手准备，无需等待该 Jetpack 库上线。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;参考 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/navigation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;开发者指南&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/docs/quality-guidelines/car-app-quality&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;应用质量指南&lt;/a&gt;&lt;/b&gt; 设计您的应用。&lt;/li&gt;&lt;li&gt;借助 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/navigation%23install-library&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;当前的 Beta 版开发库&lt;/a&gt;&lt;/b&gt; 进行开发，这样您可以从一开始就获得用户反馈。&lt;/li&gt;&lt;li&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/testing%23test-auto&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Desktop Head Unit&lt;/a&gt;&lt;/b&gt; 进行测试。&lt;/li&gt;&lt;li&gt;发布到 Google Play 商店 (现可发布至开放式测试轨道)。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们非常期待看到各位构建的应用，赶快尝试吧！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>023812eb760d255ef4c5a48b51867132</guid>
<title>Android NativeCrash 捕获与解析</title>
<link>https://toutiao.io/k/gdwz713</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Android 开发中，NE一直是不可忽略却又异常难解的一个问题，原因是这里面涉及到了跨端开发和分析，需要同时熟悉 Java，C&amp;amp;C++，并且需要熟悉 NDK开发，并且解决起来不像 Java异常那么明了，本文为了解决部分疑惑，将从NE的捕获，解析与还原等三个方面进行探索。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、NE 简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;NE全称NativeCrash，就是C或者C++运行过程中产生的错误，NE不同于普通的 Java 错误，普通的logcat无法直接还原成可阅读的堆栈，一般没有源码也无法调试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以日常应用层的工程师，即使我们内部有云诊断的日志，一般也会忽略NE的错误，那么遇到这些问题，作为应用层、对C++不甚了解的工程师能否解决还原堆栈，能否快速定位或者解决NE的问题呢？&lt;/p&gt;&lt;p&gt;下面将着重介绍：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 so 组成&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们先了解一下 so 的组成，一个完整的 so 由C代码加一些 debug 信息组成，这些debug信息会记录 so 中所有方法的对照表，就是方法名和其便宜地址的对应表，也叫做符号表，这种 so  也叫做未 strip 的，通常体积会比较大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常release的 so 都是需要经过一个strip操作的，这样strip之后的 so 中的debug信息会被剥离，整个 so 的体积也会缩小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38005390835579517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDQJibtmRDvCIVQoLtATEXsRHgicf4pZ4pHS4CffYe05PiaYW7Eib6L4Lj4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如下可以看到strip之前和之后的大小对比。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.07561436672967864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDzLzUAEV4OianNKlicwP0FDK72vJyOicEp8sUQ2INIuKVSvUglUhTn2x2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果对 NE 或者 so 不了解的，可以简单将这个debug信息理解为Java代码混淆中的mapping文件，只有拥有这个mapping文件才能进行堆栈分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果堆栈信息丢了，基本上堆栈无法还原，问题也无法解决。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，这些debug信息尤为重要，是我们分析NE问题的关键信息，那么我们在编译 so 时候务必保留一份未被strip的so 或者剥离后的符号表信息，以供后面问题分析，并且每次编译的so 都需要保存，一旦产生代码修改重新编译，那么修改前后的符号表信息会无法对应，也无法进行分析。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 查看 so 状态&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;事实上，也可以通过命令行来查看 so 的状态，Mac下使用 file 命令即可，在命令返回值里面可以查看到so的一些基本信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图所示，stripped代表是没有debug信息的so，with debug_info, not stripped代表携带debug信息的so。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;file libbreakpad-core-s.so&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;libbreakpad-core-s.so: *******, BuildID[sha1]=54ad86d708f4dc0926ad220b098d2a9e71da235a, stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;file libbreakpad-core.so&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;libbreakpad-core.so: ******, BuildID[sha1]=54ad86d708f4dc0926ad220b098d2a9e71da235a, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果你是 Windows系统的话，那么我劝你装一个 Linux子系统，然后在 Linux执行同样的命令，同样也可以得到该信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来看下我们如何获取两种状态下的so。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 获取 strip 和未被 strip 的 so&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;目前Android Studio无论是使用mk或者Cmake编译的方式都会同时输出strip和未strip的so，如下图是Cmake编译so产生的两个对应的so。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;strip之前的so路径：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;build/intermediates/transforms/mergeJniLibs&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;strip之后的so路径：&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;build/intermediates/transforms/stripDebugSymbol&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1985111662531018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD0kP7ciawAMLoHOuicgTylrMzkJDcnkBgr8fBiaLcUmVG7eNY4SdT1JicdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt; 另外也可以通过Android SDK提供的工具aarch64-linux-android-strip手动进行strip，aarch64-linux-android-strip这个工具位于&lt;/p&gt;&lt;p&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains目录下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个工具有多种版本，主要针对不同的手机CPU架构，如果不知道手机的CPU架构，可以连接手机使用以下命令查看：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;shell cat /proc/cpuinfo&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Processor&lt;/span&gt;   : &lt;span class=&quot;code-snippet__string&quot;&gt;AArch64 Processor rev 12 (aarch64)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上图可以看到我的手机CPU用的是aarch64，所以使用aarch64对应的工具aarch64-linux-android-strip，由于NDK提供了很多工具，后续都依照此原则使用即可：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-strip&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-android-strip&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;使用如下命令可以直接将debug的so进行strip&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64-linux-android-strip &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;使用Cmake进行编译的时候，可以增加如下命令，可以直接编译出strip的so&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt;(CMAKE_C_FLAGS_RELEASE &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;span class=&quot;code-snippet__variable&quot;&gt;${CMAKE_C_FLAGS_RELEASE}&lt;/span&gt; -s&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt;(CMAKE_CXX_FLAGS_RELEASE &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;span class=&quot;code-snippet__variable&quot;&gt;${CMAKE_CXX_FLAGS_RELEASE}&lt;/span&gt; -s&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;使用mk文件进行编译的时候，可以增加如下命令，也可以直接编译出strip的so&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;-fvisibility&lt;/span&gt;=hidden&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、NE 捕获与解析&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;NE解析顾名思议就是堆栈解析，当然所有的前提就是需要保存一份带符号表、也就是未被strip的so，如果你只有strip之后的so，那就无能为力了，堆栈基本无法还原了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般有以下三种方式可以捕获和还原堆栈。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 logcat捕获&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;顾名思义，就是通过logcat进行捕获，我们通过Android Studio打开logcat，制造一个NE，只能看到很多类似#00 pc 00000000000161a0的符号，并没有一个可以直接阅读的日志，我们想通过logcat直接输出一份可以直接阅读的log。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以使用Android/SDK/NDK下面提供的一个工具ndk-stack，它可以直接将NE输出的log解析为可阅读的日志。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ndk-stack一般是位于ndk的工具下面，Mac下的地址为&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/XXXX/Library/Android/sdk/ndk/&lt;span class=&quot;code-snippet__number&quot;&gt;21.3&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.6528147&lt;/span&gt;/ndk-&lt;span class=&quot;code-snippet__built_in&quot;&gt;stack&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;然后在该目录下执行控制台命令，或者在 Android Studio的terminal中执行也可&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;adb shell logcat | androidsdk绝对路径/ndk-&lt;span class=&quot;code-snippet__built_in&quot;&gt;stack&lt;/span&gt; -sym so所在目录&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如此控制台在应用发生NE的时候便会输出如下日志，由日志可以看出，崩溃对应的so以及对应的方法名，如果有c的源码，那么就很容易定位问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;markdown&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;promote:~ njvivo$ adb shell logcat | ndk-stack -sym libbreakpad-core.so&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt; Crash dump: &lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Build fingerprint: &#x27;vivo/PD1809/PD1809:8.1.0/OPM1.171019.026/compil04252203:user/release-keys&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;#00 0x00000000000161a0 /data/app/com.android.necase-lEp0warh8FqicyY1YqGXXA==/lib/arm64/libbreakpad-core.so (Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo+16)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;#01 0x00000000000090cc /data/app/com.android.necase-lEp0warh8FqicyY1YqGXXA==/oat/arm64/base.odex (offset 0x9000)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash dump is completed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;其实ndk-stack这个工具原理就是内部集成利用了addr2line来实时解析堆栈并且显示在控制台中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看到这里有的小伙伴就觉得那这个不是很简单，但是实际的崩溃场景一是不容易复现，二是用户的场景有时候很难模拟，那么线上的NE崩溃又该如何监测和定位呢，有两种方式。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 通过DropBox日志解析--适用于系统应用&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这个很简单，DropBox会记录JE，NE，ANR的各种日志，只需要将DropBox下面的日志传上来即可进行分析解决，下面贴上一份日志示例。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.72890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD0UNeubbiatU49icOiawqztQ3791QdWoLK2mSosGVlY9FgbMuh6sscexWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;解析方案1：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;借助上述的ndk-stack工具，可以直接将DropBox下面的日志解析成堆栈，从中可以看出，崩溃在breakpad.cpp第111行的Crash()方法中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ndk-stack -sym /Users/njvivo/Desktop/NE -&lt;span class=&quot;code-snippet__keyword&quot;&gt;dump&lt;/span&gt; data_app_native_crash@1605531663898.txt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;********** Crash &lt;span class=&quot;code-snippet__keyword&quot;&gt;dump&lt;/span&gt;: **********&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Build fingerprint: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vivo/PD1809/PD1809:8.1.0/OPM1.171019.026/compil04252203:user/release-keys&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:&lt;span class=&quot;code-snippet__number&quot;&gt;111&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:&lt;span class=&quot;code-snippet__number&quot;&gt;122&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash &lt;span class=&quot;code-snippet__keyword&quot;&gt;dump&lt;/span&gt; is completed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;解析方案2：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还是利用Android/SDK/NDK提供的工具linux-android-addr2line，这个工具位于/Users/njvivo/Library/Android/sdk/ndk目录下，有两个版本。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-addr2line&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;命令使用方法如下，结合未被strip的so以及日志里面出现的堆栈符号00000000000161a0，同样可以解析出崩溃地址和方法。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64-linux-android-addr2line -f -C -e libbreakpad-core.so 00000000000161a0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:111&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于以上，看似也很简单，但是有一个致命的问题就是DropBox只有系统应用能访问，非系统应用根本拿不到日志，那么，非系统应用该怎么办呢？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 通过BreakPad捕获解析--适用于所有应用&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;非系统应用可以通过google提供的开源工具BreakPad进行监测分析，CrashSDK也是采用的此种方式，可以实时监听到NE的发生，并且记录相关的文件， 从而可以将崩溃和相应的应用崩溃时的启动、场景等结合起来上报。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面简单介绍一下BreakPad的使用方式。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.1 BreakPad的实现功能&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;BreakPad主要提供两个个功能，NE的监听和回调，生成minidump文件，也就是dmp结尾的文件，另外提供两个工具，符号表工具和堆栈还原工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4431554524361949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDqa1fibcHtEg0baOicqXe83g0aS0XZpB96PhAbbVWdrZDG0vhdicKpjpRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;431&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这两个工具会在编译BreakPad源码的时候产生。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;编译完之后会产生minidump_stackwalk工具，有些同学不想编译的话，Android Studio本身也提供了这个工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个minidump_stackwalk程序在Android Studio的目录下面也存在，可以拿出来直接使用，如果不想编译的话，直接到该目录下面取即可，Mac路径为：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Applications/Android Studio.app/Contents/bin/lldb/bin/minidump_stackwalk&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.2 BreakPad的捕获原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由上述可以得知，BreakPad在应用发生NE崩溃时，可以将NE对应的minidump文件写入到本地，同时会回调给应用层，应用层可以针对本次崩溃做一些处理，达到捕获统计的作用，后续将minidump文件上传之后结合minidump_stackwalk以及addr2line工具可以还原出实际堆栈，示意图如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.734789391575663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDwpv65Cw4awKibbFGzZC0yG1uXYL3ibickTwc6tx7qYibMDzK2AA1XULPdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在应用发生NE时，BreakPad会在手机本地生成一个dump文件，如图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD9AkwiaYnJFrMTGMOPELEnTrIWmZoU4apIskoPmdkxiawFusGKWfgFcqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;得到了以上文件，我们只能知道应用发生了NE，但是这些文件其实是不可读的，需要解析这些文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面着重讲一下如何分析上面产生的NE：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.3 解析dump文件&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1、获取NE崩溃的dump文件，将刚才得到的minidump_stackwalk和dump文件放在同一个目录，也可以不放，填写路径的时候填写绝对路径即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后在该目录下的终端窗口执行以下命令，该命令表示用minidump_stackwalk解析dump文件，解析后的信息输出到当前目录下的crashLog.txt文件。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./minidump_stackwalk xxxxxxxx.dmp &amp;gt;crashLog.txt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2、执行完之后，minidump_stackwalk会将NE的相关信息写到crashLog.txt里面，详细信息如图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD3wSzwVCytKrmheAzG2HI0DAGydBWsclvCBcFWIKYBOqZ0a1YuENReA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3、根据解析出的NE信息，关注图中红框，可以得知，这个崩溃发生的 &lt;a target=&quot;_blank&quot; href=&quot;http://libcrash-lib.so/&quot; textvalue=&quot;libbreakpad-core.so&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;libbreakpad-core.so&lt;/a&gt; 里面，0x161a0代表崩溃发生在相对根位置偏移161a0的位置&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.4 获取崩溃堆栈&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1、利用之前提到的addr2line工具，可以根据发生Crash的so文件以及偏移地址（0x161a0）可以得出产生crash的方法、行数和调用堆栈关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2、在其根目录对的终端窗口运行以下命令。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm-linux-androideabi-addr2line -C -f -e ${SOPATH} ${Address}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-C -f           &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-e                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;${SOPATH}         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;${Address}        &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3、如下图是真实运行的示例&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64-linux-android-addr2line -f -C -e libbreakpad-core.so 0x161a0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:111&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由上图可以知道，该崩溃发生在breakpad.cpp文件的第111行，函数名是Crash()，与真实的文件一致，崩溃代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Crash&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *a = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *) (&lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *a = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;C&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;JNIEXPORT &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; JNICALL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(JNIEnv *env, jobject instance,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                        jstring mLaunchInfoStr_)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DO_TRY&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Crash();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *mLaunchInfoStr = env-&amp;gt;GetStringUTFChars(mLaunchInfoStr_, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        launch_info = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *) mLaunchInfoStr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DO_CATCH(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;updateLaunchInfo&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于以上，便可以通过应用收集的dump文件解析的NE的详细堆栈信息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt; 三、so 符号表的提取&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.1 提取 so 的符号表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过以上内容，我们知道，so中包含了一些debug信息，又叫做符号表，那么我们如何将这些debug信息单独剥离出来呢，ndk也给我们提供了相关的工具。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-objdump&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-android-objdump&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如下是命令运行的方式，通过此命令，可以将so中的debug信息提取到文件中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;promote:~ njvivo$ aarch64-linux-android-objdump -S libbreakpad-core.so &amp;gt; breakpad.&lt;span class=&quot;code-snippet__keyword&quot;&gt;asm&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.2 符号表分析&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 直接分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如下图所示就是输出的符号表文件，结合上面的log以及下面的符号表文件，我们同样可以分析出堆栈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如log中所示，已经表明了崩溃地址是161a0，而161a0对应的代码是*a=1,由上面的分析我们已经知道该崩溃是在breakpad.cpp的111行，也就是*a=1的位置，完全符合预期。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;backtrace:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDFTXCqFweWWzYoEBYKyYUo6tcmmGDiao195qUOAAcVibckUk9uciaBHPQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6240740740740741&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 工具解析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;google提供了一个Python的工具，将符号表和log结合起来可以直接分析出堆栈，python工具访问&lt;a target=&quot;_blank&quot; href=&quot;https://code.google.com/archive/p/android-ndk-stacktrace-analyzer/&quot; textvalue=&quot;https://code.google.com/archive/p/android-ndk-stacktrace-analyzer/&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://code.google.com/archive/p/android-ndk-stacktrace-analyzer/&lt;/a&gt; 可以进行下载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;执行命令，就可以解析出相关堆栈，该工具可以用于服务端批量进行解析，此处不再详细说明。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;python parse_stack.py &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;asm-file&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;logcat-file&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.3 偏移位置简析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面文章提到了一个偏移位置的概念，笔者对此了解也不多，不过大致有一个概念，C代码有一个根位置的代码的，每行代码相对根代码都有一个偏移位置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图示例log中有一行语句&lt;/p&gt;&lt;p&gt;(Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo+16)，+16就是代表相对nUpdateLaunchInfo方法的位置往后偏移16。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由上图可以看到，nUpdateLaunchInfo方法的位置是16190，偏移16，也就是16190+10(10进制的16转化16进制后为10)=161a0，同日志输出的一样。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt; 四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以上就是本篇文章的所有内容，主要简述了so的一些基础知识，以及Android中NE的崩溃，捕获解析方案，希望通过该文档对涉及到NE相关的小伙伴带来帮助，同时后续CrashSDK也会支持相关NE的解析功能。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21d5a8064580cd546cd71ee3e1e70ab6</guid>
<title>谈一谈算法工程师的落地能力</title>
<link>https://toutiao.io/k/c7m6qzt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot; data-custom=&quot;#1e9be8&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点击标题下「&lt;em&gt;&lt;strong&gt;搜索与推荐Wiki&lt;/strong&gt;&lt;/em&gt;」可快速关注&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93040&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92886&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;▼&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;相关推荐&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;▼&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247492967&amp;amp;idx=1&amp;amp;sn=c00788cd4ae9dbc14037ba0631711706&amp;amp;chksm=ea652dfddd12a4ebe0b1bef4fcf332706e46bc18878e667e612fd5343cc6875a3338f6c1aeab&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;腾讯2020广告大赛冠军解决方案带来的思考&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247493122&amp;amp;idx=1&amp;amp;sn=1005d5bddd68f5a3f779b10e74d72163&amp;amp;chksm=ea652e98dd12a78ebb6f7079a34a816e22a1ae93a1584d0d7e28b8cb673f64fa234d7c1ddb7f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span/&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247486905&amp;amp;idx=1&amp;amp;sn=42504fbf91eecd424f0302a5f6a3e1f5&amp;amp;chksm=ea66c523dd114c35f928eb6a053e8471c201a03624b511a333e3bbc39db74698617c7266aa70&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;2、&lt;/strong&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247492960&amp;amp;idx=1&amp;amp;sn=e2a9628dd4fa2feb41c2b66a168accaf&amp;amp;chksm=ea652dfadd12a4ecdac9a0787d5e110dff36c09c158efa02ecd253020c77d613544d45af1cef&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;转化率预估中的贝叶斯平滑&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;32&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;作者 | 桔了个仔 &lt;/p&gt;&lt;p&gt;来源 | 文末阅读原文处  &lt;/p&gt;&lt;p&gt;整理 | NewBeeNLP公众号&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，这里是桔了个仔，目前是一名Data Scientist(不太想翻译成数据科学家，毕竟感觉自己就是个工程师），过去几年在做基于机器学习的风控与合规系统，参与了一些算是成功的项目，和团队一起，成功在几个跨国银行那里落地了我们开发的系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我的经历以及对身边同事的观察，我个人会把落地工程师的「落地能力」分为三个维度： &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7287037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSPN4PhBNqNx9MBjsAkRw1BNaWasOeWbmN4hW8qLZSia2ChgONwd4hvwMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;558&quot; data-backh=&quot;407&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.技术层面&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人以为算法工程师日常工作就是调下参，改个算法再跑跑，直到神经网络输出符合预期。在入行前，他们以为算法工程师的日常是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1546296296296297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSPG42Nk7ktHdbehvSLkTseNlZz5WJwgHicibGPJWEwIUYWiabDInDiaPS1Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;542&quot; data-backh=&quot;626&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，算法工程师可能涉及的技术范围是很广的。很可能是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.38333333333333336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSP5ag0q0gSFKOchicpmWSPDQANlNS9fj4D4Qz07quJMjn9o0RxL4tVCOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;542&quot; data-backh=&quot;208&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间那个小小的几乎都快看不见的黑块，你放大图片，会发现里面写着ML Code，这就是「算法」的部分。当然，别被这个图吓到，这不一定全是你的工作，这里是一个团队的任务，这个团队可能是两人的团队，也可能是几十人的团队.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但可以肯定的是，无论你在哪个公司，一个算法工程师都不太可能只做纯&lt;strong&gt;「算法」&lt;/strong&gt;，不要忘了&lt;strong&gt;「工程师」&lt;/strong&gt;三个字。对于要做产品落地的工程师，搞算法的时间很可能不到10%，其他技术部分可能占据你40%。要增强自己落地能力中的技术水平，除了算法要基础打好，你还需要：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;学会数据获取&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原始数据需要经过ETL才能被算法利用。ETL（Extract, Transform, Load）是将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许你们公司有专职的数据工程师来做ETL，但你如果能稍微参与到ETL的过程中，不仅让你在大数据技术方面得到提升，而且对你理解上游业务非常有帮助。ETL工具的典型代表有:Informatica、Datastage、OWB、微软DTS等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构建特征&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有机会参加到ETL里，也没关系，我也没，毕竟客户不想给让我们接触原始数据。这时候，你也可以处理ETL之后的数据，从中构建特征。其实特征构建的过程能帮助你理解业务，例如给银行预测信用卡逾期风险，你了解到，债务负担率和用户风险有着一定关联，于是你会考虑把用户所有信用卡的欠款加起来除以这个用户的收入，得到一个新的特征。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于相关技术，我知道很多人肯定马上想到pandas，但老实讲句，我做了几年数据工作，能用到pandas的机会真的不多。产品都要落地了，几百万条的数据马上进来了，还在玩pandas？spark, hadoop, flink等分布式计算平台赶紧给我研究起来。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可视化数据&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信问出来这个问题的人都知道哪些python库可以做可视化，例如matplot, seaborn等等。当然，除了python库，excel里的可视化也要做好，这与算法无关，但在你做汇报时能帮助你把一个结果解释清楚。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;会用服务器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般数据产品部署，得上云或者私有服务器吧，那么如果你还不熟悉linux，那就赶紧练练吧。你把系统部署到服务器时，是不太可能用鼠标拖拽个exe就完事的。如果你还能熟练使用aws等云服务，那就更好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于UI层面，例如构建网页等等，开发app这种，这就不再推荐算法工程师学了，毕竟人的精力有限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面技术部分花了10%+40%的工作时间，然后其他50%的时间呢？用来和客户或者产品经理沟通，然后理解业务，做ppt，汇报结果。杂事很多，很难接受吧？没错，我刚入行时也是觉得自己一身技术无处施展，后来我上司一句话启发了我：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;技术是逻辑的艺术，业务也是，所以只搞技术不管业务的，不能算是逻辑能力出众的。&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你现在应该有疑问了，那怎么才算&lt;strong&gt;「懂业务」&lt;/strong&gt;？嘿嘿，马上道来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.业务层面&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实关于「懂业务」，可以分为宏观业务和微观业务两部分。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;宏观业务指的是行业的「共性」&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：你的产品所服务的对象所在的行业都有什么「痛点」。sorry，句子有点长，而且说法也有点「老土」，但了解客户痛点永远都是必须的。例如我做金融风控，客户的痛点是「旧的专家系统规则更新慢」，而我们提供「基于机器学习的方案」，数据来了就自动更新规则，就能解决他们痛点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们这项业务目前的工作流程如何。例如我做反洗钱，那么我得了解洗钱的三个步骤，反洗钱的警报产生，警报调查等等。这些流程在不同客户之间都是一样的，我了解清楚了这些，我才能知道，我的产品是在哪个环节发挥价值。如果你做的项目是对内的，例如为自己公司电商搞推荐算法，那你必须清楚用户在你们APP上的路径，例如首页到搜索页再到详情页。以及在每条路径上，怎么做推荐商品，例如有的商品是推荐搭配，有的商品是推荐近似替代品。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微观业务是指不同部门/公司在实践上的不同。&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微观业务是最容易被人忽视的而且也是最辛苦的，因为大家都有不同的「知识沉淀」方式，学习起来并没有那么立竿见影。但我发现有趣的一点是，当你接触微观的业务多了，你还是能从中提取「共性」。例如某个算法工程师，之前在银行做风控，在银行获取数据流程会比较长，每个步骤要做的事情不能跳过；现在去某互联网金融公司做风控，可能获取数据流程变得很短，但是你会发现共性是，大家都有准入审查、逾期催收等环节，用到的技术可能也是相近的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在你已经掌握了各种技术，准备大干一场，准备拿最强的深度学习模型，给客户设计一款准确率非常高的产品。现在你开始学习相关业务，我建议你带着问题学习。不过，你什么都不懂时，你应该问自己的第一个问题是什么？没错，那就是：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做这个系统的真实需求是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个故事是这样的：某大型日化公司引入了一条国外肥皂生产线，这条生产线将肥皂从原材料加入直到包装箱自动完成。不过产品线有瑕疵，个别肥皂盒是空的，这家公司联系厂商后被告知这是设计上的缺陷，无法避免。于是老板要求工程师们解决这个问题，以数名博士为核心形成一个技术攻关团队，耗费大笔资金之后，终于宣告解决。解决的办法是在生产线上安装一套 X 光机进行扫描识别。在另一家私人企业，老板让新来的小工解决问题，小工所用的办法是，找来一台电风扇放在生产线旁边&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道这是真实故事还是段子，不过我们可以知道的是，如果你只顾着解决自己拿到的问题，而不想问题背后的真实需求是什么，埋头苦干，用复杂的方法来解决个很简单的事，那么会弄出大炮打蚊子的笑话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个该问自己的问题是：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有什么制约因素？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于机器学习系统，落地时的制约因素主要包括（但不限于）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;开发时间&lt;/strong&gt;。即使项目刚开始，你还不知道要花多久，你也得计划开发时间出来，你计划不出来，领导也会给你设定期限。毕竟做产品不同于做研究，做产品大家都喜欢确定的投入和可预估的汇报。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;计算资源&lt;/strong&gt;。因为机器学习系统使用是需要成本的，你得知道用户能承受怎么样的成本或者自己服务器能承受怎样的成本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;算法性能&lt;/strong&gt;。算法落地不同于打kaggle比赛，并没有时间能把性能压榨到极致。只要比预期好些，基本就「先用着再说」了&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9462962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSPNPyG0QPRpszxyw4bL78exRa5JKOHb61Lgsp4ianX4WCdsic2cOibRZicBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;516&quot; data-backh=&quot;489&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要在这三个限制因素里面取得微妙的平衡，才能使得产品落地。我刚做数据科学工作时，总喜欢搞算法调优来炫技，但其实压榨算法的边际收益很低，你用一个月把算法准确率从70%提升到80%，可能还不如提前一个月把系统上线使用起来的收益高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个该问自己的问题是：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;算法、性能评估和业务是否吻合？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是拿我自己的经历做例子。我工作中面对的数据，是非常的不平衡的，我们做二元分类，100条数据里，标签为1的只有2~3条，其他97~98条数据标签都是0。这个时候显然需要选择一些合理的评估方法，首先就排除了用准确率（Accuracy）作为评判标准了，F1-score, AUC都可以备选。原因？可以看我在另一个问题的举的例子。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如何评价德国训练探雷犬和寻尸犬识别新冠患者，称准确率达94%？嗅探犬接触患者后会成为病毒传播介质吗？&lt;sup&gt;[1]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是模型选择。银行的业务需要强解释性，所以又否决了所有黑箱模型。剩下的就在tree-based model、logistic regression还有线性kernel的svm之间选择了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线之后要评价模型对正负样本区分度，于是又要引入KS值。随着时间迁移，数据分布可能会变化，又要引入PSI值来监控数据偏移程度来决定是否重新训练模型。你看，模型和评价指标，都是和业务息息相关的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看到这里还是感觉到迷茫，不知道怎么补足相关业务知识，例如产品和运营的知识，可以看我之前写的一个回答，这里就不重复叙述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么检验自己真的「懂业务」了呢？你可以检查下自己能不能做到下面这些点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;检查下自己是否能快速复现方案？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果能快速复现方案，是否能估算每个阶段大致需要多少人多少时间？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面对不同的数据量，能否估算一个大概的服务器性能需求？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.软实力层面&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懂技术了，又懂业务了，是不是感觉还不够差点什么能力去推动产品落地？这个是抛开技术和业务之外的东西，要描述成一个具体的能力，真的很难，我会把这些能力都归结于「软实力」。我认为主要是表现在沟通，思维这两方面。情商、亲和力、共情能力、有眼光，这些算不算软实力？当然算，但你有没有发现，这些软实力都是基于沟通和思维的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沟通和思维等软实力包括（但不限于）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;和客户沟通的能力&lt;/strong&gt;。听你讲的客户并不一定是算法工程师或者数据科学家，你是否能把自己的方案原理讲清楚？设计到技术的概念，是否能让非技术的听众也能大致理解？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;思考能力&lt;/strong&gt;。例如结构化思维和批判性思维。其实有一定套路，只要多加练习就能掌握。推荐书籍有《金字塔原理》、《批判性思维工具》等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;推动团队的能力&lt;/strong&gt;。和个人魅力息息相关。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里说个真实故事，和算法无关，和软实力有关。我大舅是开工厂的，产品良品率之前一直上不去。我二舅退休后就去我大舅厂里做质量监督。我二舅就中学学历，普通话也不标准，但我二舅进厂后，产品良品率上去了，工厂也扭亏为盈了。我问他怎么做到的，他说，很简单啊，对于那些手工不精湛的小伙子，我就亲自做一遍给他看，并告诉他，我一个退休老头都能按质做好，为啥你不行？就这么耐心的一个个沟通，一个个教学，盯着他们直到确认他们能做好为止。看起来这很简单是吧，但这过程需要耐心沟通，需要系统性思维找到关键因素。这就是软实力的表现之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你观察销售团队的日常，你会发现，他们做的事情看起来简单，大部分时间就是给客户发发邮件，和客户开开会，都是动嘴皮子的事情，但是如果让你去做这些，你会发现你会缺少自己貌似很难推进，你会问自己，自己嘴皮子咋就不那么好呢？软实力就像肌肉，运用软实力的过程就像搬砖，把砖头从A点搬到B点看着很容易，但搬起来才发现自己肌肉还不够强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而锻炼软实力的方法？无它，只有干多了，软实力才能上去。具体的说，对于算法工程师而言，就是不要逃避那些繁琐的看似没收获的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如在我为某客户落地风控系统的过程中，我们需要和他们的项目经理保持联系，有问题也要给他们的数据团队反馈。其实这过程还挺难搞，因为他们作为一个跨国大公司，显然数据中心是需要同时对接很多vendor的，所以当和他们合作时，需要经常主动推进项目进度，不然他们的项目经理会问责我们。例如我们有个pipeline每天固定时间要跑，他们作为上游，需要在运行时间前把数据给到我们。当时间到了，数据还没给到我们，我们要做的第一个事，就立马需要给数据团队发送邮件，抄送项目经理，分清责任；然后积极跟进回复，搞清楚原因，和数据团队商量个预计解决时间，并且在这个时间点来临前就问问进度，以预留足够时间来应变。在这些看似繁琐的沟通过程中，我掌握了推进工作的方法，养成了积极推动工作进展，并在deadline来临前检查进度以预留时间应变的好习惯。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法工程师的&lt;strong&gt;「落地能力」&lt;/strong&gt;包括技术能力，业务理解，还有软实力。但对自己要求不要太苛刻，就好像你玩游戏时很少能用到每个维度的能力都满分的英雄一样，人的能力是有个频谱的，不可能方方面面都能做得满分，所以不要对自己感到挫败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就拿我自己说，大家别看我说的头头是道，但是说实话，说了这么多，其实我自己也并不能每个方面都做得好。这个「落地能力频谱」就像是一个打分卡，帮助你从更全面的角度来分析自己的能力频谱。有的人技术不那么精湛，但很懂业务，很会带队，也能使得产品顺利落地；有的人技术满分，但业务和沟通能力欠缺，但配合其他团队成员的优势，也能使得产品顺利落地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，接受自己的不足，尽可能动态平衡自己的能力频谱，总有一日，你能成为具有超强「落地能力」甚至能独当一面的算法工程师。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一起交流&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你想和小编一起交流技术，交流心得，扫码下面的微信，一对一沟通吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.3146473779385173&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsIniciaZHX6E8pbwVZJwF0hyLqRnHm4XE8duvGxbibWmEvYTmGTrYa32y4209EjEwOCnWaygxen3T6PtBBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1106&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;如何评价德国训练探雷犬和寻尸犬识别新冠患者，称准确率达94%？嗅探犬接触患者后会成为病毒传播介质吗？: &lt;span&gt;https://www.zhihu.com/question/442962994/answer/1717172385&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;算法工程师如何补足产品和运营知识？: &lt;span&gt;https://www.zhihu.com/question/436066262/answer/1695872348&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0868b087330e7a84d6dc5e004ea49877</guid>
<title>死磕以太坊源码分析之 downloader 同步</title>
<link>https://toutiao.io/k/t6k5kkd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;md_view&quot;&gt;
                            &lt;blockquote&gt;
&lt;p&gt;死磕以太坊源码分析之downloader同步&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要配合注释代码看&lt;/strong&gt;：&lt;a href=&quot;https://github.com/blockchainGuide/&quot;&gt;https://github.com/blockchainGuide/&lt;/a&gt; 给个star哦&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这篇文章篇幅较长，能看下去的是条汉子，建议收藏&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;希望读者在阅读过程中，指出问题，给个关注，一起探讨。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;downloader&lt;/code&gt; 模块的代码位于 &lt;code&gt;eth/downloader&lt;/code&gt; 目录下1。主要的功能代码分别是：&lt;/p&gt;

&lt;h2&gt;同步模式&lt;/h2&gt;
&lt;h3&gt;full  sync&lt;/h3&gt;
&lt;p&gt;full 模式会在数据库中保存所有区块数据，同步时从远程节点同步 header 和 body 数据，而state 和 receipt 数据则是在本地计算出来的。&lt;/p&gt;
&lt;p&gt;在 full 模式下，downloader 会同步区块的 header 和 body 数据组成一个区块，然后通过 blockchain 模块的 &lt;code&gt;BlockChain.InsertChain&lt;/code&gt; 向数据库中插入区块。在 &lt;code&gt;BlockChain.InsertChain&lt;/code&gt; 中，会逐个计算和验证每个块的 &lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;recepit&lt;/code&gt; 等数据，如果一切正常就将区块数据以及自己计算得到的 &lt;code&gt;state&lt;/code&gt;、&lt;code&gt;recepit&lt;/code&gt; 数据一起写入到数据库中。&lt;/p&gt;
&lt;h3&gt;fast sync&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;fast&lt;/code&gt; 模式下，&lt;code&gt;recepit&lt;/code&gt; 不再由本地计算，而是和区块数据一样，直接由 &lt;code&gt;downloader&lt;/code&gt; 从其它节点中同步；&lt;code&gt;state&lt;/code&gt; 数据并不会全部计算和下载，而是选一个较新的区块（称之为 &lt;code&gt;pivot&lt;/code&gt;）的 &lt;code&gt;state&lt;/code&gt; 进行下载，以这个区块为分界，之前的区块是没有 &lt;code&gt;state&lt;/code&gt; 数据的，之后的区块会像 &lt;code&gt;full&lt;/code&gt; 模式下一样在本地计算 &lt;code&gt;state&lt;/code&gt;。因此在 &lt;code&gt;fast&lt;/code&gt; 模式下，同步的数据除了 &lt;code&gt;header&lt;/code&gt; 和 body，还有 &lt;code&gt;receipt&lt;/code&gt;，以及 &lt;code&gt;pivot&lt;/code&gt; 区块的 &lt;code&gt;state&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此 &lt;code&gt;fast&lt;/code&gt; 模式忽略了大部分 &lt;code&gt;state&lt;/code&gt; 数据，并且使用网络直接同步 &lt;code&gt;receipt&lt;/code&gt; 数据的方式替换了 full 模式下的本地计算，所以比较快。&lt;/p&gt;
&lt;h3&gt;light sync&lt;/h3&gt;
&lt;p&gt;light 模式也叫做轻模式，它只对区块头进行同步，而不同步其它的数据。&lt;/p&gt;
&lt;p&gt;SyncMode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FullSync:从完整区块同步整个区块链历史&lt;/li&gt;
&lt;li&gt;FastSync:快速下载标题，仅在链头处完全同步&lt;/li&gt;
&lt;li&gt;LightSync:仅下载标题，然后终止&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;区块下载流程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;图片只是大概的描述一下，实际还是要结合代码，&lt;strong&gt;所有区块链相关文章合集&lt;/strong&gt;，&lt;a href=&quot;https://github.com/blockchainGuide/&quot;&gt;https://github.com/blockchainGuide/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时希望结识更多区块链圈子的人，可以star上面项目，持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img.learnblockchain.cn/2021/02/24_/121517496.jpg&quot; alt=&quot;image-20201222221031797&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先根据&lt;code&gt;Synchronise&lt;/code&gt;开始区块同步，通过&lt;code&gt;findAncestor&lt;/code&gt;找到指定节点的共同祖先，并在此高度进行同步，同时开启多个&lt;code&gt;goroutine&lt;/code&gt;同步不同的数据：&lt;code&gt;header&lt;/code&gt;、&lt;code&gt;receipt&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt;。假如同步高度为 100 的区块，必须先&lt;code&gt;header&lt;/code&gt;同步成功同步完成才可以唤醒&lt;code&gt;body&lt;/code&gt;和&lt;code&gt;receipts&lt;/code&gt;的同步。&lt;/p&gt;
&lt;p&gt;而每个部分的同步大致都是由&lt;code&gt;FetchParts&lt;/code&gt;来完成的，里面包含了各个&lt;code&gt;Chan&lt;/code&gt;的配合，也会涉及不少的回调函数，总而言之多读几遍每次都会有不同的理解。接下来就逐步分析这些关键内容。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;synchronise&lt;/h2&gt;
&lt;p&gt;①：确保对方的TD高于我们自己的TD&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;currentBlock := pm.blockchain.CurrentBlock()
    td := pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
    pHead, pTd := peer.Head()
    if pTd.Cmp(td) &amp;lt;= 0 {
        return
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②：开启&lt;code&gt;downloader&lt;/code&gt;的同步&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;pm.downloader.Synchronise(peer.id, pHead, pTd, mode)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入函数：主要做了以下几件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;d.synchronise(id, head, td, mode)&lt;/code&gt; ：同步过程&lt;/li&gt;
&lt;li&gt;错误日志输出， 并删除此&lt;code&gt;peer&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进入到&lt;code&gt;d.synchronise&lt;/code&gt;，走到最后一步&lt;code&gt;d.syncWithPeer(p, hash, td)&lt;/code&gt;真正开启同步。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (d *Downloader) synchronise(id string, hash common.Hash, td *big.Int, mode SyncMode) error {
  ...
  return d.syncWithPeer(p, hash, td)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;syncWithPeer大概做了以下几件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查找祖先&lt;code&gt;findAncestor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;开启单独&lt;code&gt;goroutine&lt;/code&gt;分别运行以下几个函数：
&lt;ul&gt;
&lt;li&gt;fetchHeaders&lt;/li&gt;
&lt;li&gt;processHeaders&lt;/li&gt;
&lt;li&gt;fetchbodies&lt;/li&gt;
&lt;li&gt;fetchReceipts&lt;/li&gt;
&lt;li&gt;processFastSyncContent&lt;/li&gt;
&lt;li&gt;processFullSyncContent&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来的文章，以及整个&lt;code&gt;Downloader&lt;/code&gt;模块主要内容就是围绕这几个部分进行展开。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;findAncestor&lt;/h2&gt;
&lt;p&gt;同步首要的是&lt;strong&gt;确定同步区块的区间&lt;/strong&gt;：顶部为远程节点的最高区块，底部为两个节点都拥有的相同区块的最高高度（祖先区块）。&lt;code&gt;findAncestor&lt;/code&gt;就是用来找祖先区块。函数分析如下：&lt;/p&gt;
&lt;p&gt;①：确定本地高度和远程节点的最高高度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var (
        floor        = int64(-1) // 底部
        localHeight  uint64  // 本地最高高度
        remoteHeight = remoteHeader.Number.Uint64() // 远程节点最高高度
    )
switch d.mode {
    case FullSync:
        localHeight = d.blockchain.CurrentBlock().NumberU64()
    case FastSync:
        localHeight = d.blockchain.CurrentFastBlock().NumberU64()
    default:
        localHeight = d.lightchain.CurrentHeader().Number.Uint64()
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②：计算同步的高度区间和间隔&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;from, count, skip, max := calculateRequestSpan(remoteHeight, localHeight) &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;from&lt;/code&gt;:：表示从哪个高度开始获取区块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;：表示从远程节点获取多少个区块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skip&lt;/code&gt;：表示间隔，比如&lt;code&gt;skip&lt;/code&gt; 为 2 ，获取第一个高度为 5，则第二个就是 8&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max&lt;/code&gt;：表示最大高度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;③：发送获取&lt;code&gt;header&lt;/code&gt;的请求&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go p.peer.RequestHeadersByNumber(uint64(from), count, skip, false)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④：处理上面请求接收到的&lt;code&gt;header&lt;/code&gt;  :&lt;code&gt;case packet := &amp;lt;-d.headerCh&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;丢弃掉不是来自我们请求节的内容&lt;/li&gt;
&lt;li&gt;确保返回的&lt;code&gt;header&lt;/code&gt;数量不为空&lt;/li&gt;
&lt;li&gt;验证返回的&lt;code&gt;headers&lt;/code&gt;的高度是我们所请求的&lt;/li&gt;
&lt;li&gt;检查是否找到共同祖先&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;//----①
if packet.PeerId() != p.id {
                log.Debug(&quot;Received headers from incorrect peer&quot;, &quot;peer&quot;, packet.PeerId())
                break
            }
//-----②
headers := packet.(*headerPack).headers
            if len(headers) == 0 {
                p.log.Warn(&quot;Empty head header set&quot;)
        return 0
      }
//-----③
for i, header := range headers {
                expectNumber := from + int64(i)*int64(skip+1)
                if number := header.Number.Int64(); number != expectNumber { // 验证这些返回的header是否是我们上面请求的headers
                    p.log.Warn(&quot;Head headers broke chain ordering&quot;, &quot;index&quot;, i, &quot;requested&quot;, expectNumber, &quot;received&quot;, number)
                    return 0, errInvalidChain
                }
            }
//-----④
// 检查是否找到共同祖先
            finished = true
            //注意这里是从headers最后一个元素开始查找，也就是高度最高的区块。
            for i := len(headers) - 1; i &amp;gt;= 0; i-- {
                // 跳过不在我们请求的高度区间内的区块
                if headers[i].Number.Int64() &amp;lt; from || headers[i].Number.Uint64() &amp;gt; max {
                    continue
                }
                // //检查我们本地是否已经有某个区块了，如果有就算是找到了共同祖先，
                //并将共同祖先的哈希和高度设置在number和hash变量中。
                h := headers[i].Hash()
                n := headers[i].Number.Uint64()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⑤：如果通过固定间隔法找到了共同祖先则返回祖先，会对其高度与 &lt;code&gt;floor&lt;/code&gt; 变量进行验证, &lt;code&gt;floor&lt;/code&gt; 变量代表的是共同祖先的高度的最小值,如果找到共同祖先的高度比这个值还小，就认为是两个节点之间分叉太大了，不再允许进行同步。如果一切正常，就返回找到的共同祖先的高度 &lt;code&gt;number&lt;/code&gt; 变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-GO&quot;&gt;if hash != (common.Hash{}) {
        if int64(number) &amp;lt;= floor {
            return 0, errInvalidAncestor
        }
        return number, nil
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⑥：如果固定间隔法没有找到祖先则通过二分法来查找祖先，这部分可以思想跟二分法算法类似，有兴趣的可以细看。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;queue详解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;对象和&lt;code&gt;Downloader&lt;/code&gt;对象是相互作用的，&lt;code&gt;Downloader&lt;/code&gt;的很多功能离不开他，接下来我们介绍一下这部分内容，但是本节，&lt;strong&gt;可以先行跳过&lt;/strong&gt;，等到了阅读下面的关于&lt;code&gt;Queue&lt;/code&gt;调用的一些函数部分再回过来阅读这部分讲解。&lt;/p&gt;
&lt;h3&gt;queue结构体&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type queue struct {
  mode SyncMode // 同步模式

  // header处理相关
  headerHead      common.Hash   //最后一个排队的标头的哈希值以验证顺序
  headerTaskPool  map[uint64]*types.Header  //待处理的标头检索任务，将起始索引映射到框架标头
  headerTaskQueue *prque.Prque  //骨架索引的优先级队列，以获取用于的填充标头
  headerPeerMiss map[string]map[uint64]struct{} //已知不可用的对等头批处理集
  headerPendPool map[string]*fetchRequest //当前挂起的头检索操作
  headerResults []*types.Header //结果缓存累积完成的头
  headerProced int //从结果中拿出来已经处理的header
  headerContCh chan bool //header下载完成时通知的频道

  blockTaskPool  map[common.Hash]*types.Header //待处理的块（body）检索任务，将哈希映射到header
  blockTaskQueue *prque.Prque //标头的优先级队列,以用于获取块（bodies）
  blockPendPool map[string]*fetchRequest //当前的正在处理的块（body)检索操作
  blockDonePool map[common.Hash]struct{} //已经完成的块（body)

    receiptTaskPool map[common.Hash]*types.Header //待处理的收据检索任务，将哈希映射到header
    receiptTaskQueue *prque.Prque //标头的优先级队列,以用于获取收据
    receiptPendPool map[string]*fetchRequest //当前的正在处理的收据检索操作
    receiptDonePool map[common.Hash]struct{} //已经完成的收据

    resultCache []*fetchResult //下载但尚未交付获取结果
    resultOffset uint64 //区块链中第一个缓存的获取结果的偏移量
    resultSize common.StorageSize // 块的近似大小

    lock   *sync.Mutex
    active *sync.Cond
    closed bool

}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;主要细分功能&lt;/h3&gt;
&lt;h4&gt;数据下载开始安排任务&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ScheduleSkeleton&lt;/code&gt;:&lt;em&gt;将一批&lt;code&gt;header&lt;/code&gt;检索任务添加到队列中，以填充已检索的&lt;code&gt;header skeleton&lt;/code&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Schedule&lt;/code&gt;:&lt;em&gt;用来准备对一些 &lt;code&gt;body&lt;/code&gt; 和 &lt;code&gt;receipt&lt;/code&gt; 数据的下载&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数据下载中的各类状态&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pending&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pending&lt;/code&gt;表示待检索的XXX请求的数量，包括了：&lt;code&gt;PendingHeaders&lt;/code&gt;、&lt;code&gt;PendingBlocks&lt;/code&gt;、&lt;code&gt;PendingReceipts&lt;/code&gt;，分别都是对应取&lt;code&gt;XXXTaskQueue&lt;/code&gt;的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InFlight&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InFlight&lt;/code&gt;表示是否有正在获取XXX的请求，包括：&lt;code&gt;InFlightHeaders&lt;/code&gt;、&lt;code&gt;InFlightBlocks&lt;/code&gt;、&lt;code&gt;InFlightReceipts&lt;/code&gt;，都是通过判断&lt;code&gt;len(q.receiptPendPool) &amp;gt; 0&lt;/code&gt; 来确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ShouldThrottle&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ShouldThrottle&lt;/code&gt;表示检查是否应该限制下载XXX，包括:&lt;code&gt;ShouldThrottleBlocks&lt;/code&gt;、&lt;code&gt;ShouldThrottleReceipts&lt;/code&gt;，主要是为了防止下载过程中本地内存占用过大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Reserve&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reserve&lt;/code&gt;通过构造一个 &lt;code&gt;fetchRequest&lt;/code&gt; 结构并返回，向调用者提供指定数量的待下载的数据的信息（&lt;code&gt;queue&lt;/code&gt; 内部会将这些数据标记为「正在下载」）。调用者使用返回的 &lt;code&gt;fetchRequest&lt;/code&gt; 数据向远程节点发起新的获取数据的请求。包括：&lt;code&gt;ReserveHeaders&lt;/code&gt;、&lt;code&gt;ReserveBodies&lt;/code&gt;、&lt;code&gt;ReserveReceipts&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Cancel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cance&lt;/code&gt;用来撤消对 &lt;code&gt;fetchRequest&lt;/code&gt; 结构中的数据的下载（&lt;code&gt;queue&lt;/code&gt; 内部会将这些数据重新从「正在下载」的状态更改为「等待下载」）。包括：&lt;code&gt;CancelHeaders&lt;/code&gt;、&lt;code&gt;CancelBodies&lt;/code&gt;、&lt;code&gt;CancelReceipts&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;expire&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;expire&lt;/code&gt;检查正在执行中的请求是否超过了超时限制，包括：&lt;code&gt;ExpireHeaders&lt;/code&gt;、&lt;code&gt;ExpireBodies&lt;/code&gt;、&lt;code&gt;ExpireReceipts&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Deliver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当有数据下载成功时，调用者会使用 &lt;code&gt;deliver&lt;/code&gt; 功能用来通知 &lt;code&gt;queue&lt;/code&gt; 对象。包括：&lt;code&gt;DeliverHeaders&lt;/code&gt;、&lt;code&gt;DeliverBodies&lt;/code&gt;、&lt;code&gt;DeliverReceipts&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数据下载完成获取区块数据&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RetrieveHeaders&lt;/code&gt;
在填充 &lt;code&gt;skeleton&lt;/code&gt; 完成后，&lt;code&gt;queue.RetrieveHeaders&lt;/code&gt; 用来获取整个 &lt;code&gt;skeleton&lt;/code&gt; 中的所有 &lt;code&gt;header&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Results&lt;/code&gt;
&lt;code&gt;queue.Results&lt;/code&gt; 用来获取当前的 &lt;code&gt;header&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt; 和 &lt;code&gt;receipt&lt;/code&gt;（只在 &lt;code&gt;fast&lt;/code&gt; 模式下） 都已下载成功的区块（并将这些区块从 &lt;code&gt;queue&lt;/code&gt; 内部移除）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;h3&gt;函数实现&lt;/h3&gt;
&lt;h4&gt;ScheduleSkeleton&lt;/h4&gt;
&lt;p&gt;queue.ScheduleSkeleton主要是为了填充skeleton，它的参数是要下载区块的起始高度和所有 &lt;code&gt;skeleton&lt;/code&gt; 区块头，最核心的内容则是下面这段循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (q *queue) ScheduleSkeleton(from uint64, skeleton []*types.Header) {
    ......
    for i, header := range skeleton {
        index := from + uint64(i*y)
        q.headerTaskPool[index] = header
        q.headerTaskQueue.Push(index, -int64(index))
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设已确定需要下载的区块高度区间是从 10 到 46，&lt;code&gt;MaxHeaderFetch&lt;/code&gt; 的值为 10，那么这个高度区块就会被分成 3 组：10 - 19，20 - 29，30 - 39，而 skeleton 则分别由高度为 19、29、39 的区块头组成。循环中的 &lt;code&gt;index&lt;/code&gt; 变量实际上是每一组区块中的第一个区块的高度（比如 10、20、30），&lt;code&gt;queue.headerTaskPool&lt;/code&gt; 实际上是一个&lt;strong&gt;每一组区块中第一个区块的高度到最后一个区块的 header 的映射&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;headerTaskPool = {
  10: headerOf_19,
    20: headerOf_20,
    30: headerOf_39,
}&lt;/code&gt;&lt;/pre&gt;
&lt;hr/&gt;
&lt;h4&gt;ReserveHeaders&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;reserve&lt;/code&gt; 用来获取可下载的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;reserve  = func(p *peerConnection, count int) (*fetchRequest, bool, error) {
            return d.queue.ReserveHeaders(p, count), false, nil
        }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (q *queue) ReserveHeaders(p *peerConnection, count int) *fetchRequest {
  if _, ok := q.headerPendPool[p.id]; ok {
        return nil
    } //①
  ...
  send, skip := uint64(0), []uint64{}
    for send == 0 &amp;amp;&amp;amp; !q.headerTaskQueue.Empty() {
        from, _ := q.headerTaskQueue.Pop()
        if q.headerPeerMiss[p.id] != nil {
            if _, ok := q.headerPeerMiss[p.id][from.(uint64)]; ok {
                skip = append(skip, from.(uint64))
                continue
            }
        }
        send = from.(uint64) // ②
    }

 ...
  for _, from := range skip {
        q.headerTaskQueue.Push(from, -int64(from))
    } // ③
  ...
  request := &amp;amp;fetchRequest{
        Peer: p,
        From: send,
        Time: time.Now(),
    }
    q.headerPendPool[p.id] = request // ④

}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;①：根据&lt;code&gt;headerPendPool&lt;/code&gt;来判断远程节点是否正在下载数据信息。&lt;/p&gt;
&lt;p&gt;②：从&lt;code&gt;headerTaskQueue&lt;/code&gt;取出值作为本次请求的起始高度，赋值给&lt;code&gt;send&lt;/code&gt;变量，在这个过程中会排除headerPeerMiss所记录的节点下载数据失败的信息。&lt;/p&gt;
&lt;p&gt;③：将失败的任务再重新写回&lt;code&gt;task queue&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;④：利用&lt;code&gt;send&lt;/code&gt;变量构造&lt;code&gt;fetchRequest&lt;/code&gt;结构，此结构是用来作为&lt;code&gt;FetchHeaders&lt;/code&gt;来使用的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;fetch = func(p *peerConnection, req *fetchRequest) error { 
    return p.FetchHeaders(req.From, MaxHeaderFetch) 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，&lt;code&gt;ReserveHeaders&lt;/code&gt;会从任务队列里选择最小的起始高度并构造&lt;code&gt;fetchRequest&lt;/code&gt;传递给&lt;code&gt;fetch&lt;/code&gt;获取数据。&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;DeliverHeaders&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;deliver = func(packet dataPack) (int, error) {
            pack := packet.(*headerPack)
            return d.queue.DeliverHeaders(pack.peerID, pack.headers, d.headerProcCh)
        }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;①：如果发现下载数据的节点没有在 &lt;code&gt;queue.headerPendPool&lt;/code&gt; 中，就直接返回错误；否则就继续处理，并将节点记录从 &lt;code&gt;queue.headerPendPool&lt;/code&gt; 中删除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;request := q.headerPendPool[id]
    if request == nil {
        return 0, errNoFetchesPending
    }
    headerReqTimer.UpdateSince(request.Time)
    delete(q.headerPendPool, id)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②：验证&lt;code&gt;headers&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;包括三方面验证：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查起始区块的高度和哈希&lt;/li&gt;
&lt;li&gt;检查高度的连接性&lt;/li&gt;
&lt;li&gt;检查哈希的连接性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if accepted {
        //检查起始区块的高度和哈希
        if headers[0].Number.Uint64() != request.From {
            ...
            accepted = false
        } else if headers[len(headers)-1].Hash() != target {
            ...
            accepted = false
        }
    }
    if accepted {
        for i, header := range headers[1:] {
            hash := header.Hash() // 检查高度的连接性
            if want := request.From + 1 + uint64(i); header.Number.Uint64() != want {
                ...
            }
            if headers[i].Hash() != header.ParentHash { // 检查哈希的连接性
                ...
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③： 将无效数据存入&lt;code&gt;headerPeerMiss&lt;/code&gt;，并将这组区块起始高度重新放入&lt;code&gt;headerTaskQueue&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if !accepted {
    ...
        miss := q.headerPeerMiss[id]
        if miss == nil {
            q.headerPeerMiss[id] = make(map[uint64]struct{})
            miss = q.headerPeerMiss[id]
        }
        miss[request.From] = struct{}{}
        q.headerTaskQueue.Push(request.From, -int64(request.From))
        return 0, errors.New(&quot;delivery not accepted&quot;)
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④：保存数据，并通知&lt;code&gt;headerProcCh&lt;/code&gt;处理新的&lt;code&gt;header&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if ready &amp;gt; 0 {
        process := make([]*types.Header, ready)
        copy(process, q.headerResults[q.headerProced:q.headerProced+ready])
        select {
        case headerProcCh &amp;lt;- process:
            q.headerProced += len(process)
        default:
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⑤：发送消息给.&lt;code&gt;headerContCh&lt;/code&gt;，通知&lt;code&gt;skeleton&lt;/code&gt; 都被下载完了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if len(q.headerTaskPool) == 0 {
        q.headerContCh &amp;lt;- false
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DeliverHeaders&lt;/code&gt; 会对数据进行检验和保存，并发送 channel 消息给 &lt;code&gt;Downloader.processHeaders&lt;/code&gt; 和 &lt;code&gt;Downloader.fetchParts&lt;/code&gt;的 &lt;code&gt;wakeCh&lt;/code&gt; 参数。&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;Schedule&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;processHeaders&lt;/code&gt;在处理&lt;code&gt;header&lt;/code&gt;数据的时候，会调用&lt;code&gt;queue.Schedule&lt;/code&gt; 为下载 &lt;code&gt;body&lt;/code&gt; 和 &lt;code&gt;receipt&lt;/code&gt; 作准备。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;inserts := d.queue.Schedule(chunk, origin)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-GO&quot;&gt;func (q *queue) Schedule(headers []*types.Header, from uint64) []*types.Header {
    inserts := make([]*types.Header, 0, len(headers))
    for _, header := range headers {
    //校验
    ...
        q.blockTaskPool[hash] = header
        q.blockTaskQueue.Push(header, -int64(header.Number.Uint64()))

        if q.mode == FastSync {
            q.receiptTaskPool[hash] = header
            q.receiptTaskQueue.Push(header, -int64(header.Number.Uint64()))
        }
        inserts = append(inserts, header)
        q.headerHead = hash
        from++
    }
    return inserts
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数主要就是将信息写入到body和receipt队列，等待调度。&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;ReserveBody&amp;amp;Receipt&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;queue&lt;/code&gt; 中准备好了 &lt;strong&gt;body&lt;/strong&gt; 和 &lt;strong&gt;receipt&lt;/strong&gt; 相关的数据， &lt;code&gt;processHeaders&lt;/code&gt;最后一段，是唤醒下载Bodyies和Receipts的关键代码，会通知 &lt;code&gt;fetchBodies&lt;/code&gt; 和 &lt;code&gt;fetchReceipts&lt;/code&gt; 可以对各自的数据进行下载了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {
                select {
                case ch &amp;lt;- true:
                default:
                }
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;fetchXXX&lt;/code&gt; 会调用&lt;code&gt;fetchParts&lt;/code&gt;，逻辑类似上面的的，&lt;code&gt;reserve&lt;/code&gt;最终则会调用&lt;code&gt;reserveHeaders&lt;/code&gt;，&lt;code&gt;deliver&lt;/code&gt; 最终调用的是 &lt;code&gt;queue.deliver&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先来分析&lt;code&gt;reserveHeaders&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;①：如果没有可处理的任务，直接返回&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if taskQueue.Empty() {
        return nil, false, nil
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②：如果参数给定的节点正在下载数据，返回&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt; if _, ok := pendPool[p.id]; ok {
        return nil, false, nil
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③：计算 queue 对象中的缓存空间还可以容纳多少条数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;space := q.resultSlots(pendPool, donePool)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④：从 「task queue」 中依次取出任务进行处理&lt;/p&gt;
&lt;p&gt;主要实现以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算当前 header 在 &lt;code&gt;queue.resultCache&lt;/code&gt; 中的位置，然后填充 &lt;code&gt;queue.resultCache&lt;/code&gt; 中相应位置的元素&lt;/li&gt;
&lt;li&gt;处理空区块的情况，若为空不下载。&lt;/li&gt;
&lt;li&gt;处理远程节点缺少这个当前区块数据的情况，如果发现这个节点曾经下载当前数据失败过，就不再让它下载了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;code&gt;resultCache&lt;/code&gt; 字段用来记录所有正在被处理的数据的处理结果，它的元素类型是 &lt;code&gt;fetchResult&lt;/code&gt; 。它的 &lt;code&gt;Pending&lt;/code&gt; 字段代表当前区块还有几类数据需要下载。这里需要下载的数据最多有两类：body 和 receipt，&lt;code&gt;full&lt;/code&gt; 模式下只需要下载 &lt;code&gt;body&lt;/code&gt; 数据，而 &lt;code&gt;fast&lt;/code&gt; 模式要多下载一个 &lt;code&gt;receipt&lt;/code&gt; 数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for proc := 0; proc &amp;lt; space &amp;amp;&amp;amp; len(send) &amp;lt; count &amp;amp;&amp;amp; !taskQueue.Empty(); proc++ {
        header := taskQueue.PopItem().(*types.Header)
        hash := header.Hash()
        index := int(header.Number.Int64() - int64(q.resultOffset))
        if index &amp;gt;= len(q.resultCache) || index &amp;lt; 0 {
            ....
        }
        if q.resultCache[index] == nil {
            components := 1
            if q.mode == FastSync {
                components = 2
            }
            q.resultCache[index] = &amp;amp;fetchResult{
                Pending: components,
                Hash:    hash,
                Header:  header,
            }
        }

        if isNoop(header) {
            donePool[hash] = struct{}{}
            delete(taskPool, hash)

            space, proc = space-1, proc-1
            q.resultCache[index].Pending--
            progress = true
            continue
        }
        if p.Lacks(hash) {
            skip = append(skip, header)
        } else {
            send = append(send, header)
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后就是构造 &lt;code&gt;fetchRequest&lt;/code&gt; 结构并返回。&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;DeliverBodies&amp;amp;Receipts&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;body&lt;/code&gt; 或 &lt;code&gt;receipt&lt;/code&gt; 数据都已经通过 &lt;code&gt;reserve&lt;/code&gt; 操作构造了 &lt;code&gt;fetchRequest&lt;/code&gt; 结构并传给 &lt;code&gt;fetch&lt;/code&gt;，接下来就是等待数据的到达,数据下载成功后，会调用 &lt;code&gt;queue&lt;/code&gt; 对象的 &lt;code&gt;deliver&lt;/code&gt; 方法进行传递，包括 &lt;code&gt;queue.DeliverBodies&lt;/code&gt; 和 &lt;code&gt;queue.DeliverReceipts&lt;/code&gt;。这两个方法都以不同的参数调用了 &lt;code&gt;queue.deliver&lt;/code&gt; 方法:&lt;/p&gt;
&lt;p&gt;①：如果下载的数据数量为 0，则把所有此节点此次下载的数据标记为「缺失」&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if results == 0 {
        for _, header := range request.Headers {
            request.Peer.MarkLacking(header.Hash())
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②：循环处理数据，通过调用&lt;code&gt;reconstruct&lt;/code&gt; 填充 &lt;code&gt;resultCache[index]&lt;/code&gt; 中的相应的字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for i, header := range request.Headers {
  ...
  if err := reconstruct(header, i, q.resultCache[index]); err != nil {
            failure = err
            break
        }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③：验证&lt;code&gt;resultCache&lt;/code&gt; 中的数据，其对应的 &lt;code&gt;request.Headers&lt;/code&gt; 中的 &lt;code&gt;header&lt;/code&gt; 都应为 nil，若不是则说明验证未通过，需要假如到task queue重新下载&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for _, header := range request.Headers {
        if header != nil {
            taskQueue.Push(header, -int64(header.Number.Uint64()))
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④：如果有数据被验证通过且写入 &lt;code&gt;queue.resultCache&lt;/code&gt; 中了（&lt;code&gt;accepted&lt;/code&gt; &amp;gt; 0），发送 &lt;code&gt;queue.active&lt;/code&gt; 消息。&lt;code&gt;Results&lt;/code&gt; 会等待这这个信号。&lt;/p&gt;
&lt;hr/&gt;
&lt;h4&gt;Results&lt;/h4&gt;
&lt;p&gt;当(header、body、receipt)都下载完，就要将区块写入到数据库了，&lt;code&gt;queue.Results&lt;/code&gt; 就是用来返回所有目前已经下载完成的数据，它在 &lt;code&gt;Downloader.processFullSyncContent&lt;/code&gt; 和 &lt;code&gt;Downloader.processFastSyncContent&lt;/code&gt; 中被调用。代码比较简单就不多说了。&lt;/p&gt;
&lt;p&gt;到此为止&lt;code&gt;queue&lt;/code&gt;对象就分析的差不多了。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;同步headers&lt;/h2&gt;
&lt;h3&gt;fetchHeaders&lt;/h3&gt;
&lt;p&gt;同步&lt;code&gt;headers&lt;/code&gt; 是是由函数&lt;code&gt;fetchHeaders&lt;/code&gt;来完成的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fetchHeaders&lt;/code&gt;的大致思想：&lt;/p&gt;
&lt;p&gt;同步&lt;code&gt;header&lt;/code&gt;的数据会被填充到&lt;code&gt;skeleton&lt;/code&gt;，每次从远程节点获取区块数据最大为&lt;code&gt;MaxHeaderFetch&lt;/code&gt;（192），所以要获取的区块数据如果大于192 ，会被分成组，每组&lt;code&gt;MaxHeaderFetch&lt;/code&gt;，剩余的不足192个的不会填充进&lt;code&gt;skeleton&lt;/code&gt;，具体步骤如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.learnblockchain.cn/2021/02/24_/101568227.jpg&quot; alt=&quot;image-20201219111103965&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此种方式可以&lt;strong&gt;避免从同一节点下载过多错误数据&lt;/strong&gt;，如果我们连接到了一个恶意节点，它可以创造一个链条很长且&lt;code&gt;TD&lt;/code&gt;值也非常高的区块链数据。如果我们的区块从 0 开始全部从它那同步，也就下载了一些根本不被别人承认的数据。如果我只从它那同步 &lt;code&gt;MaxHeaderFetch&lt;/code&gt; 个区块，然后发现这些区块无法正确填充我之前的 &lt;code&gt;skeleton&lt;/code&gt;（可能是 &lt;code&gt;skeleton&lt;/code&gt; 的数据错了，或者用来填充 &lt;code&gt;skeleton&lt;/code&gt; 的数据错了），就会丢掉这些数据。&lt;/p&gt;
&lt;p&gt;接下来查看下代码如何实现：&lt;/p&gt;
&lt;p&gt;①：发起获取&lt;code&gt;header&lt;/code&gt;的请求&lt;/p&gt;
&lt;p&gt;如果是下载&lt;code&gt;skeleton&lt;/code&gt;，则会从高度 &lt;code&gt;from+MaxHeaderFetch-1&lt;/code&gt; 开始（包括），每隔 &lt;code&gt;MaxHeaderFetch-1&lt;/code&gt; 的高度请求一个 &lt;code&gt;header&lt;/code&gt;，最多请求 &lt;code&gt;MaxSkeletonSize&lt;/code&gt; 个。如果不是的话，则要获取完整的&lt;code&gt;headers&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;②：等待并处理&lt;code&gt;headerCh&lt;/code&gt;中的&lt;code&gt;header&lt;/code&gt;数据&lt;/p&gt;
&lt;p&gt;2.1 确保远程节点正在返回我们需要填充&lt;code&gt;skeleton&lt;/code&gt;所需的&lt;code&gt;header&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if packet.PeerId() != p.id {
                log.Debug(&quot;Received skeleton from incorrect peer&quot;, &quot;peer&quot;, packet.PeerId())
                break
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.2 如果&lt;code&gt;skeleton&lt;/code&gt;已经下载完毕，则需要继续填充&lt;code&gt;skeleton&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if packet.Items() == 0 &amp;amp;&amp;amp; skeleton {
                skeleton = false
                getHeaders(from)
                continue
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.3 整个&lt;code&gt;skeleton&lt;/code&gt;填充完成，并且没有要获取的&lt;code&gt;header&lt;/code&gt;了，要通知&lt;code&gt;headerProcCh&lt;/code&gt;全部完成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if packet.Items() == 0 {
                //下载pivot时不要中止标头的提取
                if atomic.LoadInt32(&amp;amp;d.committed) == 0 &amp;amp;&amp;amp; pivot &amp;lt;= from {
                    p.log.Debug(&quot;No headers, waiting for pivot commit&quot;)
                    select {
                    case &amp;lt;-time.After(fsHeaderContCheck):
                        getHeaders(from)
                        continue
                    case &amp;lt;-d.cancelCh:
                        return errCanceled
                    }
                }
                //完成Pivot操作（或不进行快速同步），并且没有头文件，终止该过程
                p.log.Debug(&quot;No more headers available&quot;)
                select {
                case d.headerProcCh &amp;lt;- nil:
                    return nil
                case &amp;lt;-d.cancelCh:
                    return errCanceled
                }
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.4 当&lt;code&gt;header&lt;/code&gt;有数据并且是在获取&lt;code&gt;skeleton&lt;/code&gt;的时候，调用&lt;code&gt;fillHeaderSkeleton&lt;/code&gt;填充&lt;code&gt;skeleton&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if skeleton {
                filled, proced, err := d.fillHeaderSkeleton(from, headers)
                if err != nil {
                    p.log.Debug(&quot;Skeleton chain invalid&quot;, &quot;err&quot;, err)
                    return errInvalidChain
                }
                headers = filled[proced:]
                from += uint64(proced)
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.5 如果当前处理的不是 &lt;code&gt;skeleton&lt;/code&gt;，表明区块同步得差不多了，处理尾部的一些区块&lt;/p&gt;
&lt;p&gt;判断本地的主链高度与新收到的 header 的最高高度的高度差是否在 &lt;code&gt;reorgProtThreshold&lt;/code&gt; 以内，如果不是，就将高度最高的 &lt;code&gt;reorgProtHeaderDelay&lt;/code&gt; 个 header 丢掉。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if head+uint64(reorgProtThreshold) &amp;lt; headers[n-1].Number.Uint64() {
                        delay := reorgProtHeaderDelay
                        if delay &amp;gt; n {
                            delay = n
                        }
                        headers = headers[:n-delay]
                    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.6 如果还有 &lt;code&gt;header&lt;/code&gt; 未处理，发给 &lt;code&gt;headerProcCh&lt;/code&gt; 进行处理，&lt;code&gt;Downloader.processHeaders&lt;/code&gt; 会等待这个 channel 的消息并进行处理；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if len(headers) &amp;gt; 0 {
                ...
                select {
                case d.headerProcCh &amp;lt;- headers:
                case &amp;lt;-d.cancelCh:
                    return errCanceled
                }
                from += uint64(len(headers))
  getHeaders(from)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.7 如果没有发送标头，或者所有标头等待 &lt;code&gt;fsHeaderContCheck&lt;/code&gt; 秒，再次调用 &lt;code&gt;getHeaders&lt;/code&gt; 请求区块&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;p.log.Trace(&quot;All headers delayed, waiting&quot;)
                select {
                case &amp;lt;-time.After(fsHeaderContCheck):
                    getHeaders(from)
                    continue
                case &amp;lt;-d.cancelCh:
                    return errCanceled
                }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码后来才加上的，其 commit 的记录在&lt;a href=&quot;https://github.com/ethereum/go-ethereum/commit/6ee3b26f447459d3f3a316dbb572e461a273e193#diff-c2fa15e758e986688c646459d8970a50&quot;&gt;这里&lt;/a&gt;，而 「pull request」 在&lt;a href=&quot;https://github.com/ethereum/go-ethereum/pull/17839&quot;&gt;这里&lt;/a&gt;。从 「pull request」 中作者的解释我们可以了解这段代码的逻辑和功能：这个修改主要是为了解决经常出现的 「invalid hash chain」 错误，出现这个错误的原因是因为在我们上一次从远程节点获取到一些区块并将它们加入到本地的主链的过程中，远程节点发生了 reorg 操作（参见&lt;a href=&quot;https://yangzhe.me/2019/03/24/ethereum-blockchain/&quot;&gt;这篇文章&lt;/a&gt;里关于「主链与侧链」的介绍 ）；当我们再次根据高度请求新的区块时，对方返回给我们的是它的新的主链上的区块，而我们没有这个链上的历史区块，因此在本地写入区块时就会返回 「invalid hash chain」 错误。&lt;/p&gt;
&lt;p&gt;要想发生 「reorg」 操作，就需要有新区块加入。在以太坊主网上，新产生一个区块的间隔是 10 秒到 20 秒左右。一般情况下，如果仅仅是区块数据，它的同步速度还是很快的，每次下载也有最大数量的限制。所以在新产生一个区块的这段时间里，足够同步完成一组区块数据而对方节点不会发生 「reorg」 操作。但是注意刚才说的「仅仅是区块数据」的同步较快，&lt;strong&gt;state 数据的同步就非常慢了&lt;/strong&gt;。简单来说在完成同步之前可能会有多个 「pivot」 区块，这些区块的 state 数据会从网络上下载，这就大大拖慢了整个区块的同步速度，使得本地在同步一组区块的同时对方发生 「reorg」 操作的机率大大增加。&lt;/p&gt;
&lt;p&gt;作者认为这种情况下发生的 「reorg」 操作是由新产生的区块的竞争引起的，所以最新的几个区块是「不稳定的」，如果本次同步的区块数量较多（也就是我们同步时消耗的时间比较长）（在这里「本次同步的区数数量较多」的表现是新收到的区块的最高高度与本地数据库中的最高高度的差距大于 &lt;code&gt;reorgProtThreshold&lt;/code&gt;），那么在同步时可以先避免同步最新区块，这就是 &lt;code&gt;reorgProtThreshold&lt;/code&gt; 和 &lt;code&gt;reorgProtHeaderDelay&lt;/code&gt; 这个变量的由来。&lt;/p&gt;
&lt;p&gt;至此，&lt;code&gt;Downloader.fetchHeaders&lt;/code&gt; 方法就结束了，所有的区块头也就同步完成了。在上面我们提到填充&lt;code&gt;skeleton&lt;/code&gt;的时候，是由&lt;code&gt;fillHeaderSkeleton&lt;/code&gt;函数来完成，接下来就要细讲填充&lt;code&gt;skeleton&lt;/code&gt;的细节。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;fillHeaderSkeleton&lt;/h3&gt;
&lt;p&gt;首先我们知道以太坊在同步区块时，先确定要下载的区块的高度区间，然后将这个区间按 &lt;code&gt;MaxHeaderFetch&lt;/code&gt; 切分成很多组，每一组的最后一个区块组成了 「skeleton」（最后一组不满 &lt;code&gt;MaxHeaderFetch&lt;/code&gt; 个区块不算作一组）。不清楚的可以查看上面的图。&lt;/p&gt;
&lt;p&gt;①：将一批&lt;code&gt;header&lt;/code&gt;检索任务添加到队列中，以填充&lt;code&gt;skeleton&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个函数参照上面&lt;strong&gt;queue详解&lt;/strong&gt;的分析&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;func (q &lt;em&gt;queue) ScheduleSkeleton(from uint64, skeleton []&lt;/em&gt;types.Header) {}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;②：调用&lt;code&gt;fetchParts&lt;/code&gt; 获取&lt;code&gt;headers&lt;/code&gt;数据&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fetchParts&lt;/code&gt;是很核心的函数，下面的&lt;code&gt;Fetchbodies&lt;/code&gt;和&lt;code&gt;FetchReceipts&lt;/code&gt;都会调用。先来大致看一下&lt;code&gt;fetchParts&lt;/code&gt;的结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (d *Downloader) fetchParts(...) error {
  ...
  for {
        select {
        case &amp;lt;-d.cancelCh:
        case packet := &amp;lt;-deliveryCh:
        case cont := &amp;lt;-wakeCh:
        case &amp;lt;-ticker.C:
        case &amp;lt;-update:
        ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简化下来就是这 5 个&lt;code&gt;channel&lt;/code&gt;在处理，前面 4 个&lt;code&gt;channel&lt;/code&gt;负责循环等待消息，&lt;code&gt;update&lt;/code&gt;用来等待其他 4 个&lt;code&gt;channel&lt;/code&gt;的通知来处理逻辑，先分开分析一个个的&lt;code&gt;channel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2.1 deliveryCh 传递下载的数据&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deliveryCh&lt;/code&gt; 作用就是传递下载的数据，当有数据被真正下载下来时，就会给这个 &lt;code&gt;channel&lt;/code&gt; 发消息将数据传递过来。这个 channel 对应的分别是：&lt;code&gt;d.headerCh&lt;/code&gt;、&lt;code&gt;d.bodyCh&lt;/code&gt;、&lt;code&gt;d.receiptCh&lt;/code&gt;，而这三个 &lt;code&gt;channel&lt;/code&gt; 分别在以下三个方法中被写入数据：&lt;code&gt;DeliverHeaders&lt;/code&gt;、&lt;code&gt;DeliverBodies&lt;/code&gt;、&lt;code&gt;DeliverReceipts&lt;/code&gt;。 看下&lt;code&gt;deliveryCh&lt;/code&gt;如何处理数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;case packet := &amp;lt;-deliveryCh:
            if peer := d.peers.Peer(packet.PeerId()); peer != nil {
                accepted, err := deliver(packet)//传递接收到的数据块并检查链有效性
                if err == errInvalidChain {
                    return err
        }
                if err != errStaleDelivery {
                    setIdle(peer, accepted)
                }
                switch {
                case err == nil &amp;amp;&amp;amp; packet.Items() == 0:
                    ...
                case err == nil:
                ...
                }
            }
            select {
            case update &amp;lt;- struct{}{}:
            default:
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;收到下载数据后判断节点是否有效，如果节点没有被移除，则会通过&lt;code&gt;deliver&lt;/code&gt;传递接收到的下载数据。如果没有任何错误，则通知&lt;code&gt;update&lt;/code&gt;处理。&lt;/p&gt;
&lt;p&gt;要注意&lt;code&gt;deliver&lt;/code&gt;是一个回调函数，它调用了 queue 对象的 Deliver 方法：&lt;code&gt;queue.DeliverHeaders&lt;/code&gt;、&lt;code&gt;queue.DeliverBodies&lt;/code&gt;、&lt;code&gt;queue.DeliverReceipts&lt;/code&gt;，在收到下载数据就会调用此回调函数（&lt;strong&gt;queue相关函数分析参照queue详解部分&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;在上面处理错误部分，有一个&lt;code&gt;setIdle&lt;/code&gt;函数，它也是回调函数，其实现都是调用了 &lt;code&gt;peerConnection&lt;/code&gt; 对象的相关方法：&lt;code&gt;SetHeadersIdle&lt;/code&gt;、&lt;code&gt;SetBodiesIdle&lt;/code&gt;、&lt;code&gt;SetReceiptsIdle&lt;/code&gt;。它这个函数是指某些节点针对某类数据是空闲的，比如&lt;code&gt;header&lt;/code&gt;、&lt;code&gt;bodies&lt;/code&gt;、&lt;code&gt;receipts&lt;/code&gt;，如果需要下载这几类数据，就可以从空闲的节点下载这些数据。&lt;/p&gt;
&lt;p&gt;2.2 &lt;code&gt;wakeCh&lt;/code&gt; 唤醒&lt;code&gt;fetchParts&lt;/code&gt; ，下载新数据或下载已完成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-GO&quot;&gt;case cont := &amp;lt;-wakeCh:
            if !cont {
                finished = true
            }
            select {
            case update &amp;lt;- struct{}{}:
            default:
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先我们通过调用fetchParts传递的参数知道，&lt;code&gt;wakeCh&lt;/code&gt; 的值其实是 &lt;code&gt;queue.headerContCh&lt;/code&gt;。在 &lt;code&gt;queue.DeliverHeaders&lt;/code&gt; 中发现所有需要下戴的 header 都下载完成了时，才会发送 false 给这个 channel。&lt;code&gt;fetchParts&lt;/code&gt; 在收到这个消息时，就知道没有 header 需要下载了。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (q *queue) DeliverHeaders(......) (int, error) {
    ......
    if len(q.headerTaskPool) == 0 {
        q.headerContCh &amp;lt;- false
    }
    ......
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样如此，&lt;code&gt;body&lt;/code&gt;和&lt;code&gt;receipt&lt;/code&gt;则是&lt;code&gt;bodyWakeCh&lt;/code&gt;和&lt;code&gt;receiptWakeCh&lt;/code&gt;，在 &lt;code&gt;processHeaders&lt;/code&gt; 中，如果所有 &lt;code&gt;header&lt;/code&gt; 已经下载完成了，那么发送 &lt;code&gt;false&lt;/code&gt; 给这两个 &lt;code&gt;channel&lt;/code&gt;，通知它们没有新的 &lt;code&gt;header&lt;/code&gt; 了。 &lt;code&gt;body&lt;/code&gt; 和 &lt;code&gt;receipt&lt;/code&gt; 的下载依赖于 &lt;code&gt;header&lt;/code&gt;,需要 &lt;code&gt;header&lt;/code&gt; 先下载完成才能下载，所以对于下戴 &lt;code&gt;body&lt;/code&gt; 或 &lt;code&gt;receipt&lt;/code&gt; 的 &lt;code&gt;fetchParts&lt;/code&gt; 来说，收到这个 &lt;code&gt;wakeCh&lt;/code&gt; 就代表不会再有通知让自己下载数据了.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (d *Downloader) processHeaders(origin uint64, pivot uint64, td *big.Int) error {
    for {
        select {
        case headers := &amp;lt;-d.headerProcCh:
            if len(headers) == 0 {
                for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {
                    select {
                    case ch &amp;lt;- false:
                    case &amp;lt;-d.cancelCh:
                    }
                }
                        ...
            }
            ...
            for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {
                select {
                case ch &amp;lt;- true:
                default:
                }
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.3 ticker 负责周期性的激活 &lt;code&gt;update&lt;/code&gt;进行消息处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;case &amp;lt;-ticker.C:
            select {
            case update &amp;lt;- struct{}{}:
            default:
            }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.4 &lt;code&gt;update&lt;/code&gt; （处理此前几个&lt;code&gt;channel&lt;/code&gt;的数据）(&lt;strong&gt;重要&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;2.4.1 判断是否有效节点，并获取超时数据的信息&lt;/p&gt;
&lt;p&gt;获取超时数据的节点ID和数据数量，如果大于两个的话，就将这个节点设置为空闲状态(&lt;code&gt;setIdle&lt;/code&gt;)，小于两个的话直接断开节点连接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;expire&lt;/code&gt; 是一个回调函数，会返回当前所有的超时数据信息。这个函数的实际实现都是调用了 &lt;code&gt;queue&lt;/code&gt; 对象的 &lt;code&gt;Expire&lt;/code&gt; 方法：&lt;code&gt;ExpireHeaders&lt;/code&gt;、&lt;code&gt;ExpireBodies&lt;/code&gt;、&lt;code&gt;ExpireReceipts&lt;/code&gt;,此函数会统计当前正在下载的数据中，起始时间与当前时间的差距超过给定阈值（&lt;code&gt;downloader.requestTTL&lt;/code&gt; 方法的返回值）的数据，并将其返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if d.peers.Len() == 0 {
                return errNoPeers
            }
for pid, fails := range expire() {
  if peer := d.peers.Peer(pid); peer != nil {
    if fails &amp;gt; 2 {
                        ...
                        setIdle(peer, 0)
                    } else {
                    ...
                        if d.dropPeer == nil {
                        } else {
                            d.dropPeer(pid)
                            ....
                        }
                    }
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.4.2 处理完超时数据，判断是否还有下载的数据&lt;/p&gt;
&lt;p&gt;如果没有其他可下载的内容，请等待或终止，这里&lt;code&gt;pending()&lt;/code&gt;和&lt;code&gt;inFlight()&lt;/code&gt;都是回调函数，&lt;code&gt;pending&lt;/code&gt;分别对应了&lt;code&gt;queue.PendingHeaders&lt;/code&gt;、&lt;code&gt;queue.PendingBlocks&lt;/code&gt;、&lt;code&gt;queue.PendingReceipts&lt;/code&gt;,用来返回各自要下载的任务数量。&lt;code&gt;inFlight()&lt;/code&gt;分别对应了&lt;code&gt;queue.InFlightHeaders&lt;/code&gt;、&lt;code&gt;queue.InFlightBlocks&lt;/code&gt;、&lt;code&gt;queue.InFlightReceipts&lt;/code&gt;,用来返回正在下载的数据数量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if pending() == 0 {
                if !inFlight() &amp;amp;&amp;amp; finished {
                ...
                    return nil
                }
                break
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.4.3 使用空闲节点，调用&lt;code&gt;fetch&lt;/code&gt;函数发送数据请求&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Idle()&lt;/code&gt;回调函数在上面已经提过了，&lt;code&gt;throttle()&lt;/code&gt;回调函数则分别对&lt;code&gt;queue.ShouldThrottleBlocks&lt;/code&gt;、&lt;code&gt;queue.ShouldThrottleReceipts&lt;/code&gt;,用来表示是否应该下载&lt;code&gt;bodies&lt;/code&gt;或者&lt;code&gt;receipts&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reserve&lt;/code&gt;函数分别对应&lt;code&gt;queue.ReserveHeaders&lt;/code&gt;、&lt;code&gt;queue.ReserveBodies&lt;/code&gt;、&lt;code&gt;queue.ReserveReceipts&lt;/code&gt;,用来从从下载任务中选取一些可以下载的任务，并构造一个 &lt;code&gt;fetchRequest&lt;/code&gt; 结构。它还返回一个 &lt;code&gt;process&lt;/code&gt; 变量，标记着是否有空的数据正在被处理。比如有可能某区块中未包含任何一条交易，因此它的 &lt;code&gt;body&lt;/code&gt; 和 &lt;code&gt;receipt&lt;/code&gt; 都是空的，这种数据其实是不需要下载的。在 &lt;code&gt;queue&lt;/code&gt; 对象的 &lt;code&gt;Reserve&lt;/code&gt; 方法中，会对这种情况进行识别。如果遇到空的数据，这些数据会被直接标记为下载成功。在方法返回时，就将是否发生过「直接标记为下载成功」的情况返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;capacity&lt;/code&gt;回调函数分别对应&lt;code&gt;peerConnection.HeaderCapacity&lt;/code&gt;、&lt;code&gt;peerConnection.BlockCapacity&lt;/code&gt;、&lt;code&gt;peerConnection.ReceiptCapacity&lt;/code&gt;,用来决定下载需要请求数据的个数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fetch&lt;/code&gt;回调函数分别对应&lt;code&gt;peer.FetchHeaders&lt;/code&gt;、&lt;code&gt;peer.Fetchbodies&lt;/code&gt;、&lt;code&gt;peer.FetchReceipts&lt;/code&gt;,用来发送获取各类数据的请求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;progressed, throttled, running := false, false, inFlight()
            idles, total := idle()
            for _, peer := range idles {
                if throttle() {
                    ...
        }
                if pending() == 0 {
                    break
                }
                request, progress, err := reserve(peer, capacity(peer))
                if err != nil {
                    return err
                }
                if progress {
                    progressed = true
                }
        if request == nil {
                    continue
                }
                if request.From &amp;gt; 0 {
                ...
                }
                ...
                if err := fetch(peer, request); err != nil {
                ...
            }
            if !progressed &amp;amp;&amp;amp; !throttled &amp;amp;&amp;amp; !running &amp;amp;&amp;amp; len(idles) == total &amp;amp;&amp;amp; pending() &amp;gt; 0 {
                return errPeersUnavailable
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单来概括这段代码就是：使用空闲节点下载数据，判断是否需要暂停，或者数据是否已经下载完成；之后选取数据进行下载；最后，如果没有遇到空块需要下载、且没有暂停下载和所有有效节点都空闲和确实有数据需要下载，但下载没有运行起来，就返回 &lt;code&gt;errPeersUnavailable&lt;/code&gt; 错误。&lt;/p&gt;
&lt;p&gt;到此为止&lt;code&gt;fetchParts&lt;/code&gt;函数就分析的差不多了。里面涉及的跟&lt;code&gt;queue.go&lt;/code&gt;相关的一些函数都在&lt;strong&gt;queue详解&lt;/strong&gt;小节里介绍了。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;processHeaders&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;headerProcCh&lt;/code&gt;接收&lt;code&gt;header&lt;/code&gt;数据，并处理的过程是在&lt;code&gt;processHeaders&lt;/code&gt;函数中完成的。整个处理过程集中在：&lt;code&gt;case headers := &amp;lt;-d.headerProcCh中&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;①：如果&lt;code&gt;headers&lt;/code&gt;的长度为0 ，则会有以下操作：&lt;/p&gt;
&lt;p&gt;1.1 通知所有人&lt;code&gt;header&lt;/code&gt;已经处理完毕&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {
                    select {
                    case ch &amp;lt;- false:
                    case &amp;lt;-d.cancelCh:
                    }
                }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.2 若没有检索到任何&lt;code&gt;header&lt;/code&gt;，说明他们的&lt;code&gt;TD&lt;/code&gt;小于我们的，或者已经通过我们的&lt;code&gt;fetcher&lt;/code&gt;模块进行了同步。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if d.mode != LightSync {
                    head := d.blockchain.CurrentBlock()
                    if !gotHeaders &amp;amp;&amp;amp; td.Cmp(d.blockchain.GetTd(head.Hash(), head.NumberU64())) &amp;gt; 0 {
                        return errStallingPeer
                    }
                }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.3 如果是&lt;code&gt;fast&lt;/code&gt;或者&lt;code&gt;light&lt;/code&gt; 同步，确保传递了&lt;code&gt;header&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-GO&quot;&gt;if d.mode == FastSync || d.mode == LightSync {
                    head := d.lightchain.CurrentHeader()
                    if td.Cmp(d.lightchain.GetTd(head.Hash(), head.Number.Uint64())) &amp;gt; 0 {
                        return errStallingPeer
                    }
                }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;②：如果&lt;code&gt;headers&lt;/code&gt;的长度大于 0&lt;/p&gt;
&lt;p&gt;2.1 如果是fast或者light 同步，调用&lt;strong&gt;ightchain.InsertHeaderChain()&lt;/strong&gt;写入&lt;code&gt;header&lt;/code&gt;到&lt;code&gt;leveldb&lt;/code&gt;数据库；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if d.mode == FastSync || d.mode == LightSync {
  ....
  d.lightchain.InsertHeaderChain(chunk, frequency);
  ....
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.2 如果是&lt;code&gt;fast&lt;/code&gt;或者&lt;code&gt;full sync&lt;/code&gt;模式，则调用 d.queue.Schedule进行内容(body和receipt)检索。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if d.mode == FullSync || d.mode == FastSync {
  ...
  inserts := d.queue.Schedule(chunk, origin)
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③：如果找到更新的块号，则要发信号通知新任务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if d.syncStatsChainHeight &amp;lt; origin {
                d.syncStatsChainHeight = origin - 1
            }
for _, ch := range []chan bool{d.bodyWakeCh, d.receiptWakeCh} {
                select {
                case ch &amp;lt;- true:
                default:
                }
            }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此处理&lt;code&gt;Headers&lt;/code&gt;的分析就完成了。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;同步bodies&lt;/h2&gt;
&lt;p&gt;同步&lt;code&gt;bodies&lt;/code&gt; 则是由&lt;code&gt;fetchBodies&lt;/code&gt;函数完成的。&lt;/p&gt;
&lt;h3&gt;fetchBodies&lt;/h3&gt;
&lt;p&gt;同步bodies的过程跟同步header类似，大致讲下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;fetchParts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReserveBodies&lt;/code&gt;()从&lt;code&gt;bodyTaskPool&lt;/code&gt;中取出要同步的&lt;code&gt;body&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;fetch&lt;/code&gt;，也就是调用这里的&lt;code&gt;FetchBodies&lt;/code&gt;从节点获取&lt;code&gt;body&lt;/code&gt;，发送&lt;code&gt;GetBlockBodiesMsg&lt;/code&gt;消息；&lt;/li&gt;
&lt;li&gt;收到&lt;code&gt;bodyCh&lt;/code&gt;的数据后，调用&lt;code&gt;deliver&lt;/code&gt;函数，将Transactions和&lt;code&gt;Uncles&lt;/code&gt;写入&lt;code&gt;resultCache&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;h2&gt;同步Receipts&lt;/h2&gt;
&lt;h3&gt;fetchReceipts&lt;/h3&gt;
&lt;p&gt;同步&lt;code&gt;receipts&lt;/code&gt;的过程跟同步&lt;code&gt;header&lt;/code&gt;类似，大致讲下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;fetchParts&lt;/code&gt;()&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReserveBodies&lt;/code&gt;()从&lt;code&gt;ReceiptTaskPool&lt;/code&gt;中取出要同步的&lt;code&gt;Receipt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用这里的&lt;code&gt;FetchReceipts&lt;/code&gt;从节点获取&lt;code&gt;receipts&lt;/code&gt;，发送&lt;code&gt;GetReceiptsMsg&lt;/code&gt;消息；&lt;/li&gt;
&lt;li&gt;收到&lt;code&gt;receiptCh&lt;/code&gt;的数据后，调用&lt;code&gt;deliver&lt;/code&gt;函数，将&lt;code&gt;Receipts&lt;/code&gt;写入&lt;code&gt;resultCache&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;h2&gt;同步状态&lt;/h2&gt;
&lt;p&gt;这里我们讲两种模式下的状态同步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fullSync&lt;/strong&gt;: &lt;code&gt;processFullSyncContent&lt;/code&gt;，&lt;code&gt;full&lt;/code&gt;模式下&lt;code&gt;Receipts&lt;/code&gt;没有缓存到&lt;code&gt;resultCache&lt;/code&gt;中，直接先从缓存中取出&lt;code&gt;body&lt;/code&gt;数据，然后执行交易生成状态，最后写入区块链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fastSync&lt;/strong&gt;:&lt;code&gt;processFastSyncContent&lt;/code&gt;：fast模式的Receipts、Transaction、Uncles都在resultCache中，所以还需要下载&quot;state&quot;，进行校验，再写入区块链。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来大致的讨论下这两种方式。&lt;/p&gt;
&lt;h3&gt;processFullSyncContent&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (d *Downloader) processFullSyncContent() error {
    for {
        results := d.queue.Results(true)
        ...
        if err := d.importBlockResults(results); err != nil ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (d *Downloader) importBlockResults(results []*fetchResult) error {
    ...
    select {
...
    blocks := make([]*types.Block, len(results))
    for i, result := range results {
        blocks[i] = types.NewBlockWithHeader(result.Header).WithBody(result.Transactions, result.Uncles)
    }
    if index, err := d.blockchain.InsertChain(blocks); err != nil {
        ....
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接从&lt;code&gt;result&lt;/code&gt;中获取数据并生成&lt;code&gt;block&lt;/code&gt;，直接插入区块链中，就结束了。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;processFastSyncContent&lt;/h3&gt;
&lt;p&gt;fast模式同步状态内容比较多，大致也就如下几部分，我们开始简单分析以下。&lt;/p&gt;
&lt;p&gt;①：下载最新的区块状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;sync := d.syncState(latest.Root)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们直接用一张图来表示整个大致流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.learnblockchain.cn/2021/02/24_/966021967.jpg&quot; alt=&quot;image-20201223100153241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的代码读者自己翻阅，大致就是这么个简单过程。&lt;/p&gt;
&lt;p&gt;②：计算出pivot块&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pivot&lt;/code&gt;为&lt;code&gt;latestHeight - 64&lt;/code&gt;，调用&lt;code&gt;splitAroundPivot&lt;/code&gt;()方法以pivot为中心，将&lt;code&gt;results&lt;/code&gt;分为三个部分：&lt;code&gt;beforeP&lt;/code&gt;，&lt;code&gt;P&lt;/code&gt;，&lt;code&gt;afterP&lt;/code&gt;；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;pivot := uint64(0)
    if height := latest.Number.Uint64(); height &amp;gt; uint64(fsMinFullBlocks) {
        pivot = height - uint64(fsMinFullBlocks)
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;P, beforeP, afterP := splitAroundPivot(pivot, results)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③： 对&lt;code&gt;beforeP&lt;/code&gt;的部分调用&lt;code&gt;commitFastSyncData&lt;/code&gt;，将&lt;code&gt;body&lt;/code&gt;和&lt;code&gt;receipt&lt;/code&gt;都写入区块链&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;d.commitFastSyncData(beforeP, sync); &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④：对&lt;strong&gt;P&lt;/strong&gt;的部分更新状态信息为&lt;code&gt;P block&lt;/code&gt;的状态，把&lt;strong&gt;P&lt;/strong&gt;对应的&lt;strong&gt;result&lt;/strong&gt;（包含&lt;strong&gt;body&lt;/strong&gt;和&lt;strong&gt;receipt&lt;/strong&gt;）调用&lt;strong&gt;commitPivotBlock&lt;/strong&gt;插入本地区块链中，并调用&lt;strong&gt;FastSyncCommitHead&lt;/strong&gt;记录这个&lt;strong&gt;pivot&lt;/strong&gt;的&lt;strong&gt;hash&lt;/strong&gt;值，存在&lt;strong&gt;downloader&lt;/strong&gt;中，标记为快速同步的最后一个区块&lt;strong&gt;hash&lt;/strong&gt;值；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if err := d.commitPivotBlock(P); err != nil {
                    return err
                }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⑤：对&lt;code&gt;afterP&lt;/code&gt;调用&lt;code&gt;d.importBlockResults&lt;/code&gt;，将&lt;code&gt;body&lt;/code&gt;插入区块链，而不插入&lt;code&gt;receipt&lt;/code&gt;。因为是最后 64 个区块，所以此时数据库中只有&lt;code&gt;header&lt;/code&gt;和&lt;code&gt;body&lt;/code&gt;，没有&lt;code&gt;receipt&lt;/code&gt;和状态，要通过&lt;code&gt;fullSync&lt;/code&gt;模式进行最后的同步。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if err := d.importBlockResults(afterP); err != nil {
            return err
        }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此为止整个Downloader同步完成了。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;公众号：区块链技术栈  （非常推荐关注哦）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ethereum/go-ethereum/pull/1889&quot;&gt;https://github.com/ethereum/go-ethereum/pull/1889&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts&quot;&gt;https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;                        &lt;/div&gt;
                    
                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a2a6658972b7045a548087bb30ddc48c</guid>
<title>融云 CEO 韩迎：飞信十年珍贵历练，做 To B 别有取巧的心思</title>
<link>https://toutiao.io/k/032ixhw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;▲&lt;/span&gt; 点击上方&lt;span&gt; &lt;span&gt;“科创人” &lt;/span&gt;&lt;/span&gt;关注公众号，回复&lt;span&gt;【1】&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;span&gt;领取商业&lt;span&gt;私房课450&lt;/span&gt;讲【独家资源】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9952&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orBnshnyvSONkSZ3CYWMb8ia0B4XSBgO5MhzBOl5BiaQY2Zbic4ucNc3xBYUsCiaHNiaIHhicic5Eicwdhicmia5Ygb34m0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文| babayage&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;编辑 | 笑   笑&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;4年苦修通信工程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;两年职场转型销售&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;韩迎大学就读于中国互联网黄埔军校之一的北京邮电大学通讯工程专业。毕业那年，韩迎短暂纠结过是要考研还是加入外企，但在那个年代，外企是职场鄙视链顶端的存在，面试套路满满都是“正宫范儿”，“给你留指标、给你签就业协议、给你北京户口，但抱歉，准考证要交上来，说白了人家绝不肯当备胎”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;韩迎最终加入北京国际交换系统公司（中方四企与西门子合资），度过了两年多纯正的码农生涯，也正是这段经历，让他意识到自己的性格不适合在桌子前一坐一天，对着电脑较劲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“我要做销售，做一个懂产品、懂技术的销售。”然而，想要在一个大型企业内从技术侧转向销售，难度堪比横穿无人区，“本部门的老板不同意，新部门的老板也不敢要你，只能走人。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2003年，韩迎加入UT斯达康，如愿成为一名销售。彼时UT斯达康的主营业务有两条线：第一，曾经红极一时的小灵通，在市场中处于供不应求的状态，不愁卖；第二，光传输业务，与前者恰恰相反，销售难度堪称逆天。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“光传输的客户主要是运营商，说白了客户正好是小灵通业务的竞争对手，销售小灵通的时候顺风顺水，可销售光传输的时候，陌拜某家运营商，刚张嘴自报家门就被下了逐客令，‘UT的？赶紧走’。那次打击其实挺大，我缓了好几天，随后调整策略、动用一切资源、想尽一切方法，最终赢得了客户信任。签下这一单的那天是我人生中最快乐的日子，其实没多少钱，但这段体验让我受益终生。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尊重苛刻的外部条件、不抱任何幻想，在允许范围内极尽所能，这一行事风格帮助韩迎多年后成功带领融云起飞。但2004年的韩迎还无法预见16年后的成功，这一年离开UT、加盟神州泰岳的他，迎来了人生的一份巨大机缘：中移动决定就飞信业务与神州泰岳展开合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;与飞信在一起的十年&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那个时候，微信尚未出生，QQ风头正盛。手机是诺基亚的天下，苹果才刚出第一代。飞信横空出世，无缝连接了移动网和互联网。——摘自《曾经的飞信去哪了》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有人说微信的诞生是因为腾讯感受到了飞信的威胁，这一说法无从考证，但恐怕没人能否认，在移动互联网幼龙初吟的时代，飞信是当之无愧的杀手级应用。正因如此，人们对飞信兴衰史有着无穷的八卦之心，其中一种说法是：飞信是由乙方企业神州泰岳开发的，不可能像微信之于腾讯一般被全心对待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说出这番话的朋友，真该看看谈及飞信时韩迎的神态：谨慎的措辞、低沉的语调、不时陷入回忆导致挫顿的对话……对于韩迎而言，飞信的意义远不止一笔甲方订单。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为飞信团队的核心管理者，他亲身经历过艰苦卓绝的谈判，带领过快速增长至3000人的庞大团队，感受过9000万活跃用户的意气风发，也一口一口咽下过飞信败退的苦果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;猛喝了几口热茶，整理好思绪的韩迎还是决定思甜不忆苦：“飞信十年，对我个人而言是极大的锻炼，广度、高度、韧性全方位的锤炼。团队从几十人到几千人，多次轮岗学习不同领域的专业知识，尝试克服快速增长带来的种种问题，不断应对市场竞争关系变化带来的全新挑战。最重要的是，给了我一个从通讯行业转向互联网行业的机会，并且沉淀了大量行业知识与技术能力。我个人万分感激飞信的那段经历，直到现在我都认为那是我人生中最重要的机缘。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于为何产生了创业的野心？韩迎哈哈一笑：“代孕太苦，自己生一个吧。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013年，经过十月怀胎般的长考，融云诞生，韩迎成为掌舵人，开始真正意义上的创业人生。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;-- 广告--&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.562037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orBnshnyvSMk5btvYrPRMBa7zVOrH3ZWOu1bBRDiaA6wSeeUyuzbH9LEYGicibMBkEiaARvpTkYIlY2yC00EiaVxzgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;自嘲运气好，实则定力高&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2014年，融云正式亮相，韩迎与融云早期的同袍深刻体会到了To B创业前期的种种艰难，“没名气，一提融云谁都不认识；没案例，好不容易联系上的客户也很难签单。起步阶段团队上下有很强的挫败感，我需要不断给团队打气，同时还得扮演好大销售的角色。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至今韩迎还能记起，自己谈下一些“只是稍微有点名气的客户”时，团队成员发自内心的喜悦，那些笑容和掌声也反馈给他足够的动力，支撑到真正破冰。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若是只听韩迎一面之词，那融云从立项到突破启动瓶颈顺利启航，都只是“运气好”而已：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一好运，选择To B赛道——“因为上市公司内部孵化的创业项目，不可能像互联网烧钱，不得不选择发展慢、但死得也慢的To B行业。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二好运，选择聚焦IM——“To B市场中的IM需求，有相当一部分是客服需求，客户需要的不是PaaS提供的IM能力，而是一款解决客服场景的SaaS产品。但客服领域已经有非常成功的企业，想打进去需要大量资源，反复权衡后我们决定拒绝这份诱惑。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三好运，选择重性能、轻功能——“功能是人堆的，人是钱堆的，融云刚开始没那么多钱，有的是10年沉淀出来的IM技术以及应对各种情况的经验，我们要死磕性能。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四好运，选择重口碑、轻营销——“同上，没钱。我的面前出现过大量互联网运营类的策划案，都被我否了，To B领域真没这个，To C项目流量大于口碑，To B相反，口碑才能持续带来流量。尤其对于我们这类技术项目，程序员、技术人最讨厌虚的，把产品做扎实才是最重要的。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“好运只会眷顾有准备的人”，所谓运气，实则是在社会、市场毒打中成长起来的韧性与定力，融云之崛起的背后有很多犀利的抉择，韩迎果决、凝练的战略定力居功至伟，所谓“被逼无奈”“好运气”皆是说辞，单是“因为客户提需求盲目进入新领域”“因为看了几篇公众号盲目砸营销”这些单一动作便伤筋动骨的创业项目，何止千百？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，弯路也不是没有。融云初创时，正是中国To B市场缓慢启航的阶段，To B究竟是个什么业务、怎么个玩法，没有太多人说得清。最初大家也都模仿过To C互联网的一些商业模式和推广套路，但经过这些年的摸索和积累，融云已经根据自身业务特点，总结出了自身的盈利模式，让业务运转越来越正规合理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;不碰数据&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;ALL IN RTC&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;科创人：越来越多的To B企业将大数据作为自己的副业，提供基于数据分析的增值服务，但融云却旗帜鲜明的声称不做数据生意，这是出于怎样的考量？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;韩迎：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;准确地说，为了提供更好的服务，融云对于质量数据是有使用的，但业务数据一概不碰。确实数据里隐藏着丰富的营养和极高的潜在价值，但是融云是IM基因的企业，没有大数据基因，这是其一；其二，融云产生的业务数据，只是某一价值链中的一小段，打个比方就是一套完整酒席中的一道小菜，甚至只是佐料，融云无意夸大这部分数据的价值，它的价值应当由客户根据自己的实际情况理性判断。如果我们将数据做成生意，可能就要夸大数据的价值，这不是真正意义上的为客户考虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;科创人：融云选择发力RTC（实时音视频技术Real-Time Communication）赛道，能否介绍下这一战略决策背后的思考？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;韩迎：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;RTC一直位于融云战略路线图的核心位置，融云的愿景是“全球互联网通信云服务商”，看上去IM和RTC是两种不同的技术，但所有通过互联网提供通讯能力的服务，都在融云规划的技术路线图中。在2016年底到2017年初，融云就已经开始了音视频的研究，前期经过大量政企客户的落地实践验证，例如私有云企业场景等，之后将RTC技术发布至公有云产品，现在融云的目标是致力于提供“IM 即时通讯 + RTC 实时音视频 + Push推送”一站式通信云服务。整个通讯场景中IM、RTC、Push的强耦合性，也让融云具备了与赛道中其他厂商所不同的核心竞争力。此外，融云也非常重视服务，如提供完备的开发者文档、多场景Demo，可视化的质量问题排查平台（北极星）、1小时工单回复等等，形成整套的服务体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我个人判断，整个RTC行业目前仍然处在起步阶段，后续会产生什么变化、带来哪些革新，都要走着看。既然决定了要走，融云会踏踏实实的一步一步走下去。To B是个长期战斗的过程，急不得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;科创人：说到To B创业，很多企业在早期都因为现金压力等原因做一些项目，融云是否有过类似经历？您能否给大家分享一些经验？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;韩迎：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;对于坚定走产品路线的企业而言，做项目有很大风险，一定要谨慎应对。为了一个大单把自己的资源耗尽的故事有很多，我们早期也踩过这种坑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;话说回来，所有创业都差不多，不可能不踩坑，所以我一直不建议大学生创业，很多事情需要成熟的心智和足够的经验去应对。创业99.95%都是破事，可话说回来，不是破事哪轮得着咱？（笑）&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;【商业精品课福利】&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orBnshnyvSMOeBnd7ibQgIh9XCVyfGbrgQCOErFiaEK75t4haaibRiatsictJVPsKQVmIk0iaUicJ9ed4ibG1AhUMg6plA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;-- 平台支持--&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2861328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orBnshnyvSMk5btvYrPRMBa7zVOrH3ZW32IEwMbNfDxNvalWc5thibQibfDibnv4lRwcibhecHk7aLT0cvH6EHytgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;谢谢您的「分享｜点赞｜在看 」一键三连&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>