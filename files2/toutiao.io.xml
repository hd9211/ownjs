<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5a004cf613fa340a91b28ddc0b3c9d68</guid>
<title>史上最全教程：idea 将 Java 项目打包 Jar 包，并生成 exe 可执行文件</title>
<link>https://toutiao.io/k/iyge3cy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;第一步：idea将Java项目打包Jar包&lt;/h2&gt;

&lt;h3&gt;使用idea创建springboot项目或者java项目&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;这个这里就不多讲解了。（相信大部分都会了，如果不会的话，我后面在出一篇文章专门讲解创建springboot项目和普通java项目。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;打包springboot或java项目到jar包&lt;/h3&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1lMDYxZGI2ZmM5MGNiYzIz?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iM2IzMTdjNmM2NDg0MzI0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iOGQ0MzViODFlYmZmNjFi?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0xOWJhNjJjZjc0ZjU0YTA5?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0yZjRhZWYxYzU2M2VmYzI2?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1lOTg1OGMwOTk5MTIxMzk0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bulid后会生成jar包，这个jar包会用于后面我们生成&quot;.exe&quot;可执行文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS01MDQ5ZGUyODNkYzc1OWQy?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;h2&gt;第二步：Springboot项目jar包生成exe可执行文件&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;jar包生成exe可执行文件需要一个软件-exe4j（微信公众号：Madison龙少 回复：jar2exe 获取资源）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;让我们一起开始使用exe4j打包项目&lt;/h2&gt;

&lt;h3&gt;下载安装exe4j&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS03Y2UzN2ZlNzNhNmIzNjdl?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; 
安装成功之后直接运行。&lt;/p&gt;

&lt;h3&gt;创建打包目录&lt;/h3&gt;

&lt;p&gt;比如在桌面创建一个文件夹gui，将jar包放到gui文件夹里面，如果你怕别的机器没有jre，将你本地的jre目录拷贝的里面，我的目录可以参考一下。（但是我添加了jre，其他机器（没有java环境）没有生效。有知道的可以告知一下。）
&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS05OWNkOGY4ZDkxNzE4MDQ5?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;h3&gt;开始打包&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;在打包前先注册，在welcome界面的右下角
用户名和公司随便填写即可。注册码下面的都可以用。
注册码：微信公众号：Madison龙少 回复：jar2exe 获取资源&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0wYzNlZDhiMGZiYzA0ZGU3?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS03OGFkMjlkNWEyOWE0OWMx?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个地方会出现一个报错&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/LongGroup/tinygray_picturebed/raw/master/wechat/jarToExeFile/01.jpg&quot; alt=&quot;&amp;quot;Madison龙少&amp;quot;&quot;/&gt;
设置方法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS03MTI3ZDZmMzhjZmMyODA0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1lMWI1MWE4ZTdmYTk3N2M3?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS0yMmU1NjZiNGYzMTgwZGM3?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击next，到如下界面，点击绿色“＋”，设置程序运行的Class Path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iNmY1ZDA2YmQ0MWM2NDkw?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择打包好的jar包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS01YmI4MTU1ODhlNTkyZWE0?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择主程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS05YmI4MDk1MGYyNTU4M2Jk?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击next，然后出现下面界面。输入Java最小Jre版本号，即低于这个版本的Jre无法运行该程序，接着点击“Advanced Options”-“Search sequence”，设置一下我们的JRE，之前说过，如果客户机上没装Jre咋办？，没关系我们捆绑一个进去&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1iNjA2Zjg1MDcyZDk4MDdk?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;绑定jre&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1kYjdhYWRlYjYxMmU0MTY1?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS00YTkzODA4ZDgzZjc4NWYw?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1jMjhkYjk3ZGMwNDY1MWE1?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS05MTE5ZmNjOWMyMWQyOTFk?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1hZjMzYTZmNWY2MGJiZmQy?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS1kNThlNTVlMjgxNjFiYjQw?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;p&gt;出现这个就说明我们大功告成了。鼓掌呱唧呱唧&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;看一下我们打包的结果，这就是我们生成的exe文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDQ3MDIwMS04M2U5NTE2ZWQ5Njg1NTI2?x-oss-process=image/format,png&quot; alt=&quot;image&quot;/&gt; &lt;/p&gt;

&lt;h2&gt;结束语&lt;/h2&gt;

&lt;p&gt;感谢阅读小生文章。祝大家早日富可敌国，实现财富自由。&lt;br/&gt;
&lt;code&gt;写文不易&lt;/code&gt;,一定要&lt;code&gt;点赞、评论、收藏哦&lt;/code&gt;,&lt;code&gt;感谢感谢感谢!!!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有任何问题可以在微信搜索&lt;code&gt;公众号&lt;/code&gt;：&lt;code&gt;Madison龙少&lt;/code&gt;进行咨询&lt;br/&gt;
或者微信扫描下面二维码进行咨询&lt;br/&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9af8ae383ef40249747bb2278c064d9%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&amp;quot;Madison龙少&amp;quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>950be1088b2d3d0af479f6f55c0a99d9</guid>
<title>Java 中的集合 List（入门篇）</title>
<link>https://toutiao.io/k/de00pgg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;大家好啊，我是汤圆，今天给大家带来的是《Java中的集合List - 入门篇》，希望对大家有帮助，谢谢&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;说实话，Java中的集合有很多种，但是这里作为入门级别，先简单介绍第一种集合&lt;code&gt;List&lt;/code&gt;，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/kTAnEyP9cv1DXai.png&quot; alt=&quot;集合&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;List是一种有序集合，和数组的行为非常相似，但是比数组灵活；&lt;/p&gt;

&lt;p&gt;因为数组是长度固定的，而List的长度是动态分配的。&lt;/p&gt;

&lt;h4&gt;数组的概览&lt;/h4&gt;

&lt;p&gt;既然LIst是基于数组实现的，那么在介绍List之前，我们先来熟悉一下Java的数组吧（简单过一下，毕竟用的不多了）&lt;/p&gt;

&lt;p&gt;数组对象有一个length属性来获取数组的长度，和一个&quot;[]&quot;方法来访问元素&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;数组也是一个对象，通过直接打印数组可以看出来，比如&lt;code&gt;[Ljava.lang.String;@1b6d3586&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如下所示，我们先初始化一个数组，并通过length访问了数组的长度，[]语法访问数组内的元素&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 初始化数组
String[] arr = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};
// 数组长度
int length = arr.length;
// 数组第一个元素
String a1 = arr[0];
// 数组转为字符串，需借助Arrays工具类
String res = Arrays.toString(arr);

System.out.println(length);
System.out.println(a1);
System.out.println(res);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中我们用到了Arrays这个工具类，因为数组的toString方法不能直接拼接内部的元素，而是打印数组对象的地址&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;List可以，直接调用List.toString()即可输出所有元素拼接后的字符串&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;数组的优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;随机访问快，也是仅存的一个优点（其他地方都没ArrayList好）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数组的缺点&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;长度固定，插入慢&lt;/p&gt;

&lt;p&gt;好了，数组先说到这里，下面开始说List&lt;/p&gt;

&lt;h4&gt;List的接口方法&lt;/h4&gt;

&lt;p&gt;下面是几个常用的List接口方法：&lt;/p&gt;



&lt;h4&gt;ArrayList和LinkedList的区别&lt;/h4&gt;

&lt;p&gt;用表格对比结果如下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th/&gt;
&lt;th&gt;ArrayList&lt;/th&gt;
&lt;th&gt;LinkedList&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内部结构&lt;/td&gt;
&lt;td&gt;数组，有序&lt;/td&gt;
&lt;td&gt;双向链表，无序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;随机访问&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;插入、修改&lt;/td&gt;
&lt;td&gt;慢（如果是末尾插入，则很快）&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;可以看到，ArrayList适合随机访问，LinkedList适合插入和修改（如果是尾插，则区别不大）&lt;/p&gt;

&lt;h4&gt;为什么ArrayList随机访问很快呢？&lt;/h4&gt;

&lt;p&gt;ArrayList是基于数组实现的，而数组又是基于整数索引（下标）来查询数据的，所以ArrayList的查询效率很高&lt;/p&gt;

&lt;h4&gt;为什么ArrayList插入又很慢？&lt;/h4&gt;

&lt;p&gt;插入很慢，是因为ArrayList内部基于数组实现，内存都是连续的，因此插入时要移动后面的数据；&lt;/p&gt;

&lt;p&gt;如果是直接在末尾插入，则不需要移动任何数据，也就快了（默认添加元素时，就是在尾部插入）&lt;/p&gt;

&lt;p&gt;但是如果我要在中间位置插入，那么后面的数据都需要移动&lt;/p&gt;

&lt;p&gt;比如下图，我想把 &quot;Cat 005&quot; 插入到 &quot;Cat 001&quot; 后面，那么后面的 &quot;Cat 002&quot;、&quot;Cat 003&quot;、 &quot;Cat 004&quot;都要移动，这就导致效率很低&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/OlEzYRg4sdJb6nq.png&quot; alt=&quot;ArrayList中间插入图&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;为什么LinkedList随机访问慢？&lt;/h4&gt;

&lt;p&gt;因为LinkedList内部是双向链表结构，即每个元素都包含一个前引用和后引用，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/zVmIGbyPHoKQwse.png&quot; alt=&quot;LinkedList内部结构&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这就导致了一个问题，每次不管我访问哪个元素，都需要从头开始一个个索引；&lt;/p&gt;

&lt;p&gt;结果就是访问速度很慢。&lt;/p&gt;

&lt;h4&gt;那么为什么LinkedList随机插入很快呢？&lt;/h4&gt;

&lt;p&gt;正所谓&quot;成也萧何败萧何&quot;，虽然随机访问慢，但是正因为有了这些链表结构，使得插入的时候很方便了&lt;/p&gt;

&lt;p&gt;因为现在不需要移动任何元素，只需要修改前后元素的引用就可以了&lt;/p&gt;

&lt;p&gt;比如下图，我想把 &quot;Dog 005&quot; 插入到 &quot;Dog 001&quot; 后面，那么只需要修改 &quot;Dog 001&quot;的后引用和&quot;Dog 002&quot;的前引用，其他元素都不用动的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/fxXyuFWgaoV3pi2.png&quot; alt=&quot;LinkedList中间插入图&quot;/&gt;&lt;/p&gt;

&lt;p&gt;细心的你们可能发现了，ArrayList图中的元素都是&lt;strong&gt;顺序排列&lt;/strong&gt;的，而LinkedList图中的元素都是&lt;strong&gt;随机排列&lt;/strong&gt;的；&lt;/p&gt;

&lt;p&gt;这个其实就是为了说明他们俩的内部结构特征，&lt;strong&gt;ArrayList内存空间有序，LinkedList内存空间无序&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;那么LinkedList这样设计，除了插入快，还有其他好处吗？&lt;/h4&gt;

&lt;p&gt;当然有啊，因为LinkedList内部的数据都是通过引用来连接到一起的，所以就可以很好的利用零散的内存空间，从而&lt;strong&gt;提高内存利用率&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;代码&lt;/h4&gt;

&lt;p&gt;下面我们用代码来实践下&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 初始化
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
// 插入数据
list.add(&quot;hello world 1&quot;);
// 在指定位置插入数据
list.add(0, &quot;hello world 2&quot;);
// 查询数据
String s1 = list.get(0);
// 查询List是否包含指定对象
boolean isContain = list.contains(s1);
// 查询列表的元素个数
int size = list.size();
// 打印list内部元素：
String res = list.toString();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下所示，可以看到，List.toString()会自动拼接内部元素&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/k8fiZYMSvlbdBCa.png&quot; alt=&quot;List代码输出&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt;是一种有序集合，和数组的行为非常相似，但是比数组灵活；&lt;/p&gt;

&lt;p&gt;最常用的是&lt;code&gt;ArrayList&lt;/code&gt;，它适用于大部分场景；&lt;/p&gt;

&lt;p&gt;但是在&lt;strong&gt;插多查少&lt;/strong&gt;的情况下，建议用&lt;code&gt;LinkedList&lt;/code&gt;，可以提高插入的效率；&lt;/p&gt;

&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04b15ac8431bc46bc16519d1f1008ae1</guid>
<title>Go 应用优化指北</title>
<link>https://toutiao.io/k/6jo6q1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;为什么要做优化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这是一个速度决定一切的时代，我们的生活在不断地数字化，线下的流程依然在持续向线上转移，转移过程中，作为工程师，我们会碰到各种各样的性能问题。&lt;/p&gt;&lt;p&gt;互联网公司本质是将用户共通的行为流程进行了集中化管理，通过中心化的信息交换达到效率提升的目的，同时用规模效应降低了数据交换的成本。&lt;/p&gt;&lt;p&gt;用人话来讲，公司希望的是用尽量少的机器成本来赚取尽量多的利润。利润的提升与业务逻辑本身相关，与技术关系不大。而降低成本则是与业务无关，纯粹的技术话题。这里面最重要的主题就是“性能优化”。&lt;/p&gt;&lt;p&gt;如果业务的后端服务规模足够大，那么一个程序员通过优化帮公司节省的成本，就可以负担他十年的工资了。&lt;/p&gt;&lt;h2&gt;优化的前置知识&lt;/h2&gt;&lt;p&gt;从资源视角出发来对一台服务器进行审视的话，CPU、内存、磁盘与网络是后端服务最需要关注的四种资源类型。&lt;/p&gt;&lt;p&gt;对于计算密集型的程序来说，优化的主要精力会放在 CPU 上，要知道 CPU 基本的流水线概念，知道怎么样在使用少的 CPU 资源的情况下，达到相同的计算目标。&lt;/p&gt;&lt;p&gt;对于 IO 密集型的程序(后端服务一般都是 IO 密集型)来说，优化可以是降低程序的服务延迟，也可以是提升系统整体的吞吐量。&lt;/p&gt;&lt;p&gt;IO 密集型应用主要与磁盘、内存、网络打交道。因此我们需要知道一些基本的与磁盘、内存、网络相关的基本数据与常见概念：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;要了解内存的多级存储结构：L1，L2，L3，主存。还要知道这些不同层级的存储操作时的大致延迟：&lt;span&gt;latency numbers every programmer should know&lt;/span&gt;&lt;span&gt;[1]&lt;/span&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要知道基本的文件系统读写 syscall，批量 syscall，数据同步 syscall。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要熟悉项目中使用的网络协议，至少要对 TCP, HTTP 有所了解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;优化越靠近应用层效果越好&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;Performance tuning is most effective when done closest to where the work is performed. For workloads driven by applications, this means within the application itself.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们在应用层的逻辑优化能够帮助应用提升几十倍的性能，而最底层的优化则只能提升几个百分点。&lt;/p&gt;&lt;p&gt;这个很好理解，我们可以看到一个 GTA Online 的新闻：&lt;span&gt;rockstar thanks gta online player who fixed poor load times&lt;/span&gt;&lt;span&gt;[2]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;简单来说，GTA online 的游戏启动过程让玩家等待时间过于漫长，经过各种工具分析，发现一个 10M 的文件加载就需要几十秒，用户 diy 进行优化之后，将加载时间减少 70%，并分享出来：&lt;span&gt;how I cut GTA Online loading times by 70%&lt;/span&gt;&lt;span&gt;[3]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;这就是一个非常典型的案例，GTA 在商业上取得了巨大的成功，但不妨碍它局部的代码是一坨屎。我们只要把这里的重复逻辑干掉，就可以完成三倍的优化效果。同样的案例，如果我们去优化磁盘的读写速度，则可能收效甚微。&lt;/p&gt;&lt;h2&gt;优化是与业务场景相关的&lt;/h2&gt;&lt;p&gt;不同的业务场景优化的侧重也是不同的。&lt;/p&gt;&lt;p&gt;对于大多数无状态业务模块来说，内存一般不是瓶颈，所以业务 API 的优化主要聚焦于延迟和吞吐。对于网关类的应用，因为有海量的连接，除了延迟和吞吐，内存占用可能就会成为一个关注的重点。对于存储类应用，内存是个逃不掉的瓶颈点。&lt;/p&gt;&lt;p&gt;在关注一些性能优化文章时，我们也应特别留意作者的业务场景。场景的侧重可能会让某些人去选择使用更为 hack 的手段进行优化，而 hack 往往也就意味着 bug。如果你选择了少有人走过的路，那你要面临的也是少有人会碰到的 bug。解决起来令人头疼。&lt;/p&gt;&lt;h2&gt;优化的工作流程&lt;/h2&gt;&lt;p&gt;对于一个典型的 API 应用来说，优化工作基本遵从下面的工作流：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;建立评估指标，例如固定 QPS 压力下的延迟或内存占用，或模块在满足 SLA 前提下的极限 QPS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过自研、开源压测工具进行压测，直到模块无法满足预设性能要求:如大量超时，QPS 不达预期，OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过内置 profile 工具寻找性能瓶颈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地 benchmark 证明优化效果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集成 patch 到业务模块，回到 2&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;可以使用的工具&lt;/h2&gt;&lt;h3&gt;pprof&lt;/h3&gt;&lt;h4&gt;memory profiler&lt;/h4&gt;&lt;p&gt;Go 内置的内存 profiler 可以让我们对线上系统进行内存使用采样，有四个相应的指标：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;inuse_objects：当我们认为内存中的驻留对象过多时，就会关注该指标&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inuse_space：当我们认为应用程序占据的 RSS 过大时，会关注该指标&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_objects：当应用曾经发生过历史上的大量内存分配行为导致 CPU 或内存使用大幅上升时，可能关注该指标&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;alloc_space：当应用历史上发生过内存使用大量上升时，会关注该指标&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;网关类应用因为海量连接的关系，会导致进程消耗大量内存，所以我们经常看到相关的优化文章，主要就是降低应用的 inuse_space。&lt;/p&gt;&lt;p&gt;而两个对象数指标主要是为 GC 优化提供依据，当我们进行 GC 调优时，会同时关注应用分配的对象数、正在使用的对象数，以及 GC 的 CPU 占用的指标。&lt;/p&gt;&lt;p&gt;GC 的 CPU 占用情况可以由内置的 CPU profiler 得到。&lt;/p&gt;&lt;h4&gt;cpu profiler&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;The builtin Go CPU profiler uses the setitimer(2) system call to ask the operating system to be sent a SIGPROF signal 100 times a second. Each signal stops the Go process and gets delivered to a random thread’s sigtrampgo() function. This function then proceeds to call sigprof() or sigprofNonGo() to record the thread’s current stack.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Go 语言内置的 CPU profiler 使用 setitimer 系统调用，操作系统会每秒 100 次向程序发送 SIGPROF 信号。在 Go 进程中会选择随机的信号执行 sigtrampgo 函数。该函数使用 sigprof 或 sigprofNonGo 来记录线程当前的栈。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Since Go uses non-blocking I/O, Goroutines that wait on I/O are parked and not running on any threads. Therefore they end up being largely invisible to Go’s builtin CPU profiler.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Go 语言内置的 cpu profiler 是在性能领域比较常见的 On-CPU profiler，对于瓶颈主要在 CPU 消耗的应用，我们使用内置的 profiler 也就足够了。&lt;/p&gt;&lt;p&gt;如果碰到的问题是应用的 CPU 使用不高，但接口的延迟却很大，那么就需要用上 Off-CPU profiler，遗憾的是官方的 profiler 并未提供该功能，我们需要借助社区的 fgprof。&lt;/p&gt;&lt;h3&gt;fgprof&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;fgprof is implemented as a background goroutine that wakes up 99 times per second and calls runtime.GoroutineProfile. This returns a list of all goroutines regardless of their current On/Off CPU scheduling status and their call stacks.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;fgprof 是启动了一个后台的 goroutine，每秒启动 99 次，调用 runtime.GoroutineProfile 来采集所有 gorooutine 的栈。&lt;/p&gt;&lt;p&gt;虽然看起来很美好：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;GoroutineProfile&lt;/span&gt;&lt;span&gt;(p []StackRecord)&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, ok &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    .....&lt;br/&gt; stopTheWorld(&lt;span&gt;&quot;profile&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, gp1 := &lt;span&gt;range&lt;/span&gt; allgs {&lt;br/&gt;  ......&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n &amp;lt;= &lt;span&gt;len&lt;/span&gt;(p) {&lt;br/&gt;  &lt;span&gt;// Save current goroutine.&lt;/span&gt;&lt;br/&gt;  ........&lt;br/&gt;  systemstack(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   saveg(pc, sp, gp, &amp;amp;r[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Save other goroutines.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, gp1 := &lt;span&gt;range&lt;/span&gt; allgs {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; isOK(gp1) {&lt;br/&gt;    .......&lt;br/&gt;    saveg(^&lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;), ^&lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;), gp1, &amp;amp;r[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;                .......&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; startTheWorld()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; n, ok&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但调用 GoroutineProfile 函数的开销并不低，如果线上系统的 goroutine 上万，每次采集 profile 都遍历上万个 goroutine 的成本实在是太高了。所以 fgprof 只适合在测试环境中使用。&lt;/p&gt;&lt;h3&gt;trace&lt;/h3&gt;&lt;p&gt;一般情况下我们是不需要使用 trace 来定位性能问题的，通过压测 + profile 就可以解决大部分问题，除非我们的问题与 runtime 本身的问题相关。&lt;/p&gt;&lt;p&gt;比如 STW 时间比预想中长，超过百毫秒，向官方反馈问题时，才需要出具相关的 trace 文件。比如类似 &lt;span&gt;long stw&lt;/span&gt;&lt;span&gt;[4]&lt;/span&gt; 这样的 issue。&lt;/p&gt;&lt;p&gt;采集 trace 对系统的性能影响还是比较大的，即使我们只是开启 gctrace，把 gctrace 日志重定向到文件，对系统延迟也会有一定影响，因为 gctrace 的日志 print 是在 stw 期间来做的：&lt;span&gt;gc trace 阻塞调度&lt;/span&gt;&lt;span&gt;[5]&lt;/span&gt;。&lt;/p&gt;&lt;h3&gt;perf&lt;/h3&gt;&lt;p&gt;如果应用没有开启 pprof，在线上应急时，我们也可以临时使用 perf：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6258389261744967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbfzcTCwKbhfoQCudo70ibSNqlYr2vG6VhSklEIicHdZsF5VmCDlYUl5viaZicvRI3FKx667XZ0P5cMNvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;figcaption&gt;perf demo&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;微观性能优化&lt;/h2&gt;&lt;p&gt;编写 library 时会关注关键函数的性能，这时可以脱离系统去探讨性能优化，Go 语言的 test 子命令集成了相关的功能，只要我们按照约定来写 Benchmark 前缀的测试函数，就可以实现函数级的基准测试。我们以常见的二维数组遍历为例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;make&lt;/span&gt;([][]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  x[i] = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;traverseVertical&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;100&lt;/span&gt;; j++ {&lt;br/&gt;   x[j][i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;traverseHorizontal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;100&lt;/span&gt;; j++ {&lt;br/&gt;   x[i][j] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkHorizontal&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  traverseHorizontal()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkVertical&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  traverseVertical()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行 &lt;code&gt;go test -bench=.&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;BenchmarkHorizontal-12       102368      10916 ns/op&lt;br/&gt;BenchmarkVertical-12          66612      18197 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见横向遍历数组要快得多，这提醒我们在写代码时要考虑 CPU 的 cache 设计及局部性原理，以使程序能够在相同的逻辑下获得更好的性能。&lt;/p&gt;&lt;p&gt;除了 CPU 优化，我们还经常会碰到要优化内存分配的场景。只要带上 -benchmem 的 flag 就可以实现了。&lt;/p&gt;&lt;p&gt;举个例子，形如下面这样的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;logStr := &lt;span&gt;&quot;userid :&quot;&lt;/span&gt; + userID + &lt;span&gt;&quot;; orderid:&quot;&lt;/span&gt; + orderID&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你觉得代码写的很难看，想要优化一下可读性，就改成了下列代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;logStr := fmt.Sprintf(&lt;span&gt;&quot;userid: %v; orderid: %v&quot;&lt;/span&gt;, userID, orderID)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的修改方式在某公司的系统中曾经导致了 p2 事故，上线后接口的超时俱增至 SLA 承诺以上。&lt;/p&gt;&lt;p&gt;我们简单验证就可以发现：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;BenchmarkPrin-12       7168467        157 ns/op       64 B/op        3 allocs/op&lt;br/&gt;BenchmarkPlus -12     43278558         26.7 ns/op        0 B/op        0 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 + 进行字符串拼接，不会在堆上产生额外对象。而使用 fmt 系列函数，则会造成局部对象逃逸到堆上，这里是高频路径上有大量逃逸，所以导致线上服务的 GC 压力加重，大量接口超时。&lt;/p&gt;&lt;p&gt;出于谨慎考虑，修改高并发接口时，拿不准的尽量都应进行简单的线下 benchmark 测试。&lt;/p&gt;&lt;p&gt;当然，我们不能指望靠写一大堆 benchmark 帮我们发现系统的瓶颈。&lt;/p&gt;&lt;p&gt;实际工作中还是要使用前文提到的优化工作流来进行系统性能优化。也就是尽量从接口整体而非函数局部考虑去发现与解决瓶颈。&lt;/p&gt;&lt;h2&gt;宏观性能优化&lt;/h2&gt;&lt;p&gt;接口类的服务，我们可以使用两种方式对其进行压测：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;固定 QPS 压测：在每次系统有大的特性发布时，都应进行固定 QPS 压测，与历史版本进行对比，需要关注的指标包括，相同 QPS 下的系统的 CPU 使用情况，内存占用情况(监控中的 RSS 值)，goroutine 数，GC 触发频率和相关指标(是否有较长的 stw，mark 阶段是否时间较长等)，平均延迟，p99 延迟。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;极限 QPS 压测：极限 QPS 压测一般只是为了 benchmark show，没有太大意义。系统满负荷时，基本 p99 已经超出正常用户的忍受范围了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;压测过程中需要采集不同 QPS 下的 CPU profile，内存 profile，记录 goroutine 数。与历史情况进行 AB 对比。&lt;/p&gt;&lt;p&gt;Go 的 pprof 还提供了 --base 的 flag，能够很直观地帮我们发现不同版本之间的指标差异：&lt;span&gt;用 pprof 比较内存使用差异&lt;/span&gt;&lt;span&gt;[6]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;总之记住一点，接口的性能一定是通过压测来进行优化的，而不是通过硬啃代码找瓶颈点。关键路径的简单修改往往可以带来巨大收益。如果只是啃代码，很有可能将 1% 优化到 0%，优化了 100% 的局部性能，对接口整体影响微乎其微。&lt;/p&gt;&lt;h2&gt;寻找性能瓶颈&lt;/h2&gt;&lt;p&gt;在压测时，我们通过以下步骤来逐渐提升接口的整体性能：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用固定 QPS 压测，以阶梯形式逐渐增加压测 QPS，如 1000 -&amp;gt; 每分钟增加 1000 QPS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;压测过程中观察系统的延迟是否异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观察系统的 CPU 使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 CPU 使用率在达到一定值之后不再上升，反而引起了延迟的剧烈波动，这时大概率是发生了阻塞，进入 pprof 的 web 页面，点击 goroutine，查看 top 的 goroutine 数，这时应该有大量的 goroutine 阻塞在某处，比如 Semacquire&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 CPU 上升较快，未达到预期吞吐就已经过了高水位，则可以重点考察 CPU 使用是否合理，在 CPU 高水位进行 profile 采样，重点关注火焰图中较宽的“平顶山”&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;重复上述步骤，直至系统性能达到或超越我们设置的性能目标。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;一些优化案例&lt;/h2&gt;&lt;h3&gt;gc mark 占用过多 CPU&lt;/h3&gt;&lt;p&gt;在 Go 语言中 gc mark 占用的 CPU 主要和运行时的对象数相关，也就是我们需要看 inuse_objects。&lt;/p&gt;&lt;p&gt;定时任务，或访问流量不规律的应用，需要关注 alloc_objects。&lt;/p&gt;&lt;p&gt;优化主要是下面几方面：&lt;/p&gt;&lt;h4&gt;减少变量逃逸&lt;/h4&gt;&lt;p&gt;尽量在栈上分配对象，关于逃逸的规则，可以查看 Go 编译器代码中的逃逸测试部分：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.87265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbfzcTCwKbhfoQCudo70ibSNq1nEeqMuqibAWI1K4ibU25pBY7xF3gWTdrQfeBxVu3kdf7zs6cALiaWULQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;查看某个 package 内的逃逸情况，可以使用 build + 全路径的方式，如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;go build -gcflags=&quot;-m -m&quot; github.com/cch123/elasticsql&lt;/code&gt;&lt;/p&gt;&lt;p&gt;需要注意的是，逃逸分析的结果是会&lt;strong&gt;随着版本变化&lt;/strong&gt;的，所以去背诵网上逃逸相关的文章结论是没有什么意义的。&lt;/p&gt;&lt;h4&gt;使用 sync.Pool 复用堆上对象&lt;/h4&gt;&lt;p&gt;sync.Pool 用出花儿的就是 fasthttp 了，可以看看我之前写的这一篇：&lt;span&gt;fasthttp 为什么快&lt;/span&gt;&lt;span&gt;[7]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;最简单的复用就是复用各种 struct，slice，在复用时 put 时，需要判断 size 是否已经扩容过头，小心因为 sync.Pool 中存了大量的巨型对象导致进程占用了大量内存。&lt;/p&gt;&lt;h3&gt;调度占用过多 CPU&lt;/h3&gt;&lt;p&gt;goroutine 频繁创建与销毁会给调度造成较大的负担，如果我们发现 CPU 火焰图中 schedule，findrunnable 占用了大量 CPU，那么可以考虑使用开源的 workerpool 来进行改进，比较典型的 &lt;span&gt;fasthttp worker pool&lt;/span&gt;&lt;span&gt;[8]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;如果客户端与服务端之间使用的是短连接，那么我们可以使用长连接来减少连接创建的开销，这里就包含了 goroutine 的创建与销毁。&lt;/p&gt;&lt;h3&gt;进程占用大量内存&lt;/h3&gt;&lt;p&gt;当前大多数的业务后端服务是不太需要关注进程消耗的内存的。&lt;/p&gt;&lt;p&gt;我们经常看到做 Go 内存占用优化的是在网关(包括 mesh)、存储系统这两个场景。&lt;/p&gt;&lt;p&gt;对于网关类系统来说，Go 的内存占用主要是因为 Go 独特的抽象模型造成的，这个很好理解：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lq0XA1b7xbfzcTCwKbhfoQCudo70ibSNqiaMsnicxicY4BicL2IYVQml2OJItShrQZbvNxsggKibmx7Y70uMgtOicv6TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;海量的连接加上海量的 goroutine，使网关和 mesh 成为 Go OOM 的重灾区。所以网关侧的优化一般就是优化：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;goroutine 占用的栈内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;read buffer 和 write buffer 占用的内存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;很多项目都有相关的分享，这里就不再赘述了。&lt;/p&gt;&lt;p&gt;对于存储类系统来说，内存占用方面的不少努力也是在优化各种 buffer，比如 dgraph 使用 cgo + jemalloc 来优化他们的产品&lt;span&gt;内存占用&lt;/span&gt;&lt;span&gt;[9]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;堆外内存不会在 Go 的 GC 系统里进行管辖，所以也不会影响到 Go 的 GC Heap Goal，所以不会因为分配大量对象造成 Go 的 Heap Goal 被推高，系统整体占用的 RSS 也被推高。&lt;/p&gt;&lt;h3&gt;锁冲突严重，导致吞吐量瓶颈&lt;/h3&gt;&lt;p&gt;我在 &lt;span&gt;几个 Go 系统可能遇到的锁问题&lt;/span&gt;&lt;span&gt;[10]&lt;/span&gt; 中分享过实际的线上 case。&lt;/p&gt;&lt;p&gt;进行锁优化的思路无非就一个“拆”和一个“缩”字：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;拆：将锁粒度进行拆分，比如全局锁，我能不能把锁粒度拆分为连接粒度的锁；如果是连接粒度的锁，那我能不能拆分为请求粒度的锁；在 logger fd 或 net fd 上加的锁不太好拆，那么我们增加一些客户端，比如从 1-&amp;gt; 100，降低锁的冲突是不是就可以了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缩：缩小锁的临界区，业务允许的前提下，可以把 syscall 移到锁外面；有时只是想要锁 map 的读写逻辑，但是却不小心锁了连接读写的逻辑，或许简单地用 sync.Map 来代替 map Lock，defer Unlock 就能简单地缩小临界区了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;timer 相关函数占用大量 CPU&lt;/h3&gt;&lt;p&gt;同样是在网关和海量连接的应用中较常见，优化手段：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用时间轮/粗粒度的时间管理，精确到 ms 级一般就足够了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;升级到 Go 1.14+，享受官方的升级红利&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;模拟真实工作负载&lt;/h2&gt;&lt;p&gt;在前面的论述中，我们对问题进行了简化。真实世界中的后端系统往往不只一个接口，压测工具、平台往往只支持单接口压测。&lt;/p&gt;&lt;p&gt;公司的业务希望知道的是后端系统整体性能，即这些系统作为一个整体，在限定的资源条件下，能够承载多少业务量(如并发创建订单)而不崩溃。&lt;/p&gt;&lt;p&gt;虽然大家都在讲微服务，但单一服务往往也不只有单一功能，如果一个系统有 10 个接口(已经算是很小的服务了)，那么这个服务的真实负载是很难靠人肉去模拟的。&lt;/p&gt;&lt;p&gt;这也就是为什么互联网公司普遍都需要做全链路压测。像样点的公司会定期进行全链路压测演练，以便知晓随着系统快速迭代变化，系统整体是否出现了严重的性能衰退。&lt;/p&gt;&lt;p&gt;通过真实的工作负载，我们才能发现真实的线上性能问题。讲全链路压测的文章也很多，本文就不再赘述了。&lt;/p&gt;&lt;h2&gt;当前性能问题定位工具的局限性&lt;/h2&gt;&lt;p&gt;本文中几乎所有优化手段都是通过 Benchmark 和压测来进行的，但真实世界的软件还会有下列场景：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;做 ToB 生意，我们的应用是部署在客户侧(比如一些数据库产品)，客户说我们的应用会 OOM，但是我们很难拿到 OOM 的现场，不知道到底是哪些对象分配导致了 OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做大型平台，平台上有各种不同类型的用户编写代码，升级用户代码后，线上出现各种 CPU 毛刺和 OOM 问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些问题在压测中是发现不了的，需要有更为灵活的工具和更为强大的平台，关于这些问题，我将在 4 月 10 日的武汉 Gopher Meetup 上进行分享，欢迎关注。&lt;/p&gt;&lt;p&gt;推荐阅读：&lt;/p&gt;&lt;p&gt;&lt;span&gt;cache contention&lt;/span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;every-programmer-should-know&lt;/span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;go-perfbook&lt;/span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Systems Performance&lt;/span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;latency numbers every programmer should know: &lt;em&gt;https://colin-scott.github.io/personal_website/research/interactive_latency.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;rockstar thanks gta online player who fixed poor load times: &lt;em&gt;https://www.pcgamer.com/rockstar-thanks-gta-online-player-who-fixed-poor-load-times-official-update-coming/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;how I cut GTA Online loading times by 70%: &lt;em&gt;https://nee.lv/2021/02/28/How-I-cut-GTA-Online-loading-times-by-70/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;long stw: &lt;em&gt;https://github.com/golang/go/issues/19378&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;gc trace 阻塞调度: &lt;em&gt;http://xiaorui.cc/archives/6232&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;用 pprof 比较内存使用差异: &lt;em&gt;https://colobu.com/2019/08/20/use-pprof-to-compare-go-memory-usage/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;fasthttp 为什么快: &lt;em&gt;https://xargin.com/why-fasthttp-is-fast-and-the-cost-of-it/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;fasthttp worker pool: &lt;em&gt;https://github.com/valyala/fasthttp/blob/master/workerpool.go#L19&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;内存占用: &lt;em&gt;https://dgraph.io/blog/post/manual-memory-management-golang-jemalloc/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;几个 Go 系统可能遇到的锁问题: &lt;em&gt;https://xargin.com/lock-contention-in-go/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;cache contention: &lt;em&gt;https://web.eecs.umich.edu/~zmao/Papers/xu10mar.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;every-programmer-should-know: &lt;em&gt;https://github.com/mtdvio/every-programmer-should-know&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;go-perfbook: &lt;em&gt;https://github.com/dgryski/go-perfbook&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;Systems Performance: &lt;em&gt;https://www.amazon.com/Systems-Performance-Brendan-Gregg/dp/0136820158/ref=sr_1_1?dchild=1&amp;amp;keywords=systems+performance&amp;amp;qid=1617092159&amp;amp;sr=8-1&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>29fb31b2791771170f26120ef3520d72</guid>
<title>[译] Uber：面向领域的微服务架构</title>
<link>https://toutiao.io/k/0yy2iga</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>da8089e883535318c60273af016b3778</guid>
<title>你该如何为 Kubernetes 定制特性</title>
<link>https://toutiao.io/k/ea28kfh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-content&quot;&gt;&lt;p&gt;Kubernetes 是非常复杂的集群编排系统，然而哪怕包含丰富的功能和特性，因为容器的调度和管理本身就有较高的复杂性，所以它无法满足所有场景下的需求。虽然 Kubernetes 能够解决大多数场景中的常见问题，但是为了实现更加灵活的策略，我们需要使用 Kubernetes 提供的扩展能力实现特定目的。&lt;/p&gt;&lt;p&gt;每个项目在不同的周期会着眼于不同的特性，我们可以将项目的演进过程简单分成三个不同的阶段：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最小可用&lt;/strong&gt;：项目在早期更倾向于解决通用的、常见的问题，给出开箱即用的解决方案以吸引用户，这时代码库的规模还相对比较小，提供的功能较为有限，能够覆盖领域内 90% 的场景；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;功能完善&lt;/strong&gt;：随着项目得到更多的使用者和支持者，社区会不断实现相对重要的功能，社区治理和自动化工具也逐渐变得完善，能够解决覆盖内 95% 的场景；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;扩展能力&lt;/strong&gt;：因为项目的社区变得完善，代码库变得逐渐庞大，项目的每个变动都会影响下游的开发者，任何新功能的加入都需要社区成员的讨论和审批，这时社区会选择增强项目的扩展性，让使用者能够为自己的场景定制需求，能够解决覆盖内 99% 的场景；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/evolving-of-open-source-project-2021-03-24-16165170057421.png&quot; alt=&quot;evolving-of-open-source-project&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 1 - 开源项目的演进&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从 90%、95% 到 99%，每个步骤都需要社区成员花费很多精力，但是哪怕提供了较好的扩展性也无法解决领域内的全部问题，在一些极端场景下仍然需要维护自己的分支或者另起炉灶满足业务上的需求。&lt;/p&gt;&lt;p&gt;然而无论是维护自己的分支，还是另起炉灶都会带来较高的开发和维护成本，这需要结合实际需求进行抉择。但是能够利用项目提供的配置能力和扩展能力就可以明显地降低定制化的开发成本，而我们今天要梳理的就是 Kubernetes 的可扩展性。&lt;/p&gt;&lt;h2 id=&quot;扩展接口&quot;&gt;扩展接口&lt;/h2&gt;&lt;p&gt;API 服务器是 Kubernetes 中的核心组件，它承担着集群中资源读写的重任，虽然社区提供的资源和接口可以满足大多数的日常需求，但是我们仍然会有一些场景需要扩展 API 服务器的能力，这一节简单介绍几个扩展该服务的方法。&lt;/p&gt;&lt;h3 id=&quot;自定义资源&quot;&gt;自定义资源&lt;/h3&gt;&lt;p&gt;自定义资源（Custom Resource Definition、CRD）应该是 Kubernetes 最常见的扩展方式&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，它是扩展 Kubernetes API 的方式之一。Kubernetes 的 API 就是我们向集群提交的 YAML，系统中的各个组件会根据提交的 YAML 启动应用、创建网络路由规则以及运行工作负载。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;v1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;Pod&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;static-web&lt;/span&gt;
  &lt;span&gt;labels&lt;/span&gt;:
    &lt;span&gt;role&lt;/span&gt;: &lt;span&gt;myrole&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;containers&lt;/span&gt;:
    - &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;web&lt;/span&gt;
      &lt;span&gt;image&lt;/span&gt;: &lt;span&gt;nginx&lt;/span&gt;
      &lt;span&gt;ports&lt;/span&gt;:
        - &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;web&lt;/span&gt;
          &lt;span&gt;containerPort&lt;/span&gt;: &lt;span&gt;80&lt;/span&gt;
          &lt;span&gt;protocol&lt;/span&gt;: &lt;span&gt;TCP&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Pod&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt; 以及 &lt;code&gt;Ingress&lt;/code&gt; 都是 Kubernetes 对外暴露的接口，当我们在集群中提交上述 YAML 时，Kubernetes 中的控制器会根据配置创建满足条件的容器。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;apiextensions.k8s.io/v1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;CustomResourceDefinition&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;crontabs.stable.example.com&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;group&lt;/span&gt;: &lt;span&gt;stable.example.com&lt;/span&gt;
  &lt;span&gt;versions&lt;/span&gt;:
    - &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;v1&lt;/span&gt;
      &lt;span&gt;served&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;
      &lt;span&gt;storage&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;
      &lt;span&gt;schema&lt;/span&gt;:
        &lt;span&gt;openAPIV3Schema&lt;/span&gt;:
          &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;object&lt;/span&gt;
          &lt;span&gt;properties&lt;/span&gt;:
            &lt;span&gt;spec&lt;/span&gt;:
              &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;object&lt;/span&gt;
              &lt;span&gt;properties&lt;/span&gt;:
                &lt;span&gt;cronSpec&lt;/span&gt;:
                  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;
                &lt;span&gt;image&lt;/span&gt;:
                  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;string&lt;/span&gt;
                &lt;span&gt;replicas&lt;/span&gt;:
                  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;integer&lt;/span&gt;
  &lt;span&gt;scope&lt;/span&gt;: &lt;span&gt;Namespaced&lt;/span&gt;
  &lt;span&gt;names&lt;/span&gt;:
    &lt;span&gt;plural&lt;/span&gt;: &lt;span&gt;crontabs&lt;/span&gt;
    &lt;span&gt;singular&lt;/span&gt;: &lt;span&gt;crontab&lt;/span&gt;
    &lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;CronTab&lt;/span&gt;
    &lt;span&gt;shortNames&lt;/span&gt;:
    - &lt;span&gt;ct&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了这些系统内置的 API 之外，想要实现定制的接口就需要使用 CRD，然而 CRD 仅仅是实现自定义资源的冰山一角，因为它只定义了资源中的字段，我们还需要遵循 Kubernetes 的控制器模式，实现消费 CRD 的 Operator，通过组合 Kubernetes 提供的资源实现更复杂、更高级的功能。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/modular-kubernetes-api-2021-03-24-16165170057450.png&quot; alt=&quot;modular-kubernetes-api&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 2 - Kubernetes API 模块化设计&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如上图所示，Kubernetes 中的控制器等组件会消费 &lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;StatefulSet&lt;/code&gt; 等资源，而用户自定义的 CRD 会由自己实现的控制器消费，这种设计极大地降低了系统之间各个模块的耦合，让不同模块可以无缝协作。&lt;/p&gt;&lt;p&gt;当我们想要让 Kubernetes 集群提供更加复杂的功能时，选择 CRD 和控制器是首先需要考虑的方法，这种方式与现有的功能耦合性非常低，同时也具有较强的灵活性，但是在定义接口时应该遵循社区 API 的最佳实践设计出优雅的接口&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h3 id=&quot;聚合层&quot;&gt;聚合层&lt;/h3&gt;&lt;p&gt;Kubernetes API 聚合层是 v1.7 版本实现的功能，它的目的是将单体的 API 服务器拆分成多个聚合服务，每个开发者都能够实现聚合 API 服务暴露它们需要的接口，这个过程不需要重新编译 Kubernetes 的任何代码&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-api-aggregation-2021-03-24-16165170057457.png&quot; alt=&quot;kubernetes-api-aggregation&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 3 - Kubernetes API 聚合&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当我们需要在集群中加入新的 API 聚合服务时，需要提交一个 &lt;code&gt;APIService&lt;/code&gt; 资源，这个资源描述了接口所属的组、版本号以及处理该接口的服务，下面是 Kubernetes 社区中 metrics-server 服务对应的 &lt;code&gt;APIService&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;apiregistration.k8s.io/v1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;APIService&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;v1beta1.metrics.k8s.io&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;service&lt;/span&gt;:
    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;metrics-server&lt;/span&gt;
    &lt;span&gt;namespace&lt;/span&gt;: &lt;span&gt;kube-system&lt;/span&gt;
  &lt;span&gt;group&lt;/span&gt;: &lt;span&gt;metrics.k8s.io&lt;/span&gt;
  &lt;span&gt;version&lt;/span&gt;: &lt;span&gt;v1beta1&lt;/span&gt;
  &lt;span&gt;insecureSkipTLSVerify&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;
  &lt;span&gt;groupPriorityMinimum&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;
  &lt;span&gt;versionPriority&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们将上述资源提交到 Kubernetes 集群中后，用户在访问 API 服务器的 &lt;code&gt;/apis/metrics.k8s.io/v1beta1&lt;/code&gt; 路径时，会被转发到集群中的 &lt;code&gt;metrics-server.kube-system.svc&lt;/code&gt; 服务上。&lt;/p&gt;&lt;p&gt;与应用范围很广的 CRD 相比，API 聚合机制在项目中比较少见，它的主要目的还是扩展 API 服务器，而大多数的集群都不会有类似的需求，在这里也就不过多介绍了。&lt;/p&gt;&lt;h3 id=&quot;准入控制&quot;&gt;准入控制&lt;/h3&gt;&lt;p&gt;Kubernetes 的准入控制机制可以修改和验证即将被 API 服务器持久化的资源，API 服务器收到的全部写请求都会经过如下所示的阶段持久化到 etcd 中&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-admission-control-2021-03-24-16165170057463.png&quot; alt=&quot;kubernetes-admission-control&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 4 - Kubernetes 准入控制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Kubernetes 的代码仓库中包含 20 多个准入控制插件&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;，我们以 &lt;code&gt;TaintNodesByCondition&lt;/code&gt; 插件&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;为例简单介绍一下它们的实现原理：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;p&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Plugin&lt;/span&gt;) &lt;span&gt;Admit&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;a&lt;/span&gt; &lt;span&gt;admission&lt;/span&gt;.&lt;span&gt;Attributes&lt;/span&gt;, &lt;span&gt;o&lt;/span&gt; &lt;span&gt;admission&lt;/span&gt;.&lt;span&gt;ObjectInterfaces&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetResource&lt;/span&gt;().&lt;span&gt;GroupResource&lt;/span&gt;() &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nodeResource&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetSubresource&lt;/span&gt;() &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}

&lt;span&gt;node&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetObject&lt;/span&gt;().(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;.&lt;span&gt;Node&lt;/span&gt;)
&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok&lt;/span&gt; {
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;admission&lt;/span&gt;.&lt;span&gt;NewForbidden&lt;/span&gt;(&lt;span&gt;a&lt;/span&gt;, &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Errorf&lt;/span&gt;(&lt;span&gt;&quot;unexpected type %T&quot;&lt;/span&gt;, &lt;span&gt;a&lt;/span&gt;.&lt;span&gt;GetObject&lt;/span&gt;()))
}

&lt;span&gt;addNotReadyTaint&lt;/span&gt;(&lt;span&gt;node&lt;/span&gt;)
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所有的准入控制插件都可以实现上述的 &lt;code&gt;Admit&lt;/code&gt; 方法修改即将提交到存储中的资源，也就是上面提到的 Mutating 修改阶段，这段代码会为所有传入节点加上 &lt;code&gt;NotReady&lt;/code&gt; 污点保证节点在更新期间不会有任务调度到该节点上；除了 &lt;code&gt;Admit&lt;/code&gt; 方法之外，插件还可以实现 &lt;code&gt;Validate&lt;/code&gt; 方法验证传入资源的合法性。&lt;/p&gt;&lt;p&gt;在 Kubernetes 实现自定义的准入控制器相对比较复杂，我们需要构建一个实现准入控制接口的 API 服务并将该 API 服务通过 &lt;code&gt;MutatingWebhookConfiguration&lt;/code&gt; 和 &lt;code&gt;ValidatingWebhookConfiguration&lt;/code&gt; 两种资源将服务的地址和接口注册到集群中，而 Kubernetes 的 API 服务器会在修改资源时调用 &lt;code&gt;WebhookConfiguration&lt;/code&gt; 中定义的服务修改和验证资源。Kubernetes 社区中的比较热门的服务网格 Istio 就利用该特性实现了一些功能&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h2 id=&quot;容器接口&quot;&gt;容器接口&lt;/h2&gt;&lt;p&gt;Kubernetes 作为容器编排系统，它的主要逻辑还是调度和管理集群中运行的容器，虽然它不需要从零开始实现新的容器运行时，但是因为网络和存储等模块是容器运行的必需品，所以它要与这些模块打交道。Kubernetes 选择的方式是设计网络、存储和运行时接口隔离实现细节，自己把精力放在容器编排上，让第三方社区实现这些复杂而且极具专业性的模块。&lt;/p&gt;&lt;h3 id=&quot;网络插件&quot;&gt;网络插件&lt;/h3&gt;&lt;p&gt;容器网络接口（Container Network Interface、CNI）包含一组用于开发插件去配置 Linux 容器中网卡的接口和框架。CNI 仅会关注容器的网络连通性并在容器删除时回收所有分配的网络资源&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/cni-banner-2021-03-24-16165170057469.png&quot; alt=&quot;cni-banner&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 5 - 容器网络接口&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CNI 插件虽然与 Kubernetes 有密切的关系，但是不同的容器管理系统都可以使用 CNI 插件来创建和管理网络，例如：mesos、Cloud Foundry 等。&lt;/p&gt;&lt;p&gt;所有的 CNI 插件都应该实现包含 &lt;code&gt;ADD&lt;/code&gt;、&lt;code&gt;DEL&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 操作的二进制可执行文件，容器管理系统会执行二进制文件来创建网络&lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;在 Kubernetes 中，无论使用哪种网络插件都需要遵循它的网络模型，除了每个 Pod 都需要有独立的 IP 地址之外，Kubernetes 还对网络模型做出了以下的需求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;任意节点上的 Pod 在不使用 NAT 的情况下都访问到所有节点上的所有 Pod；&lt;/li&gt;&lt;li&gt;节点上的 Kubelet 和守护进程等服务可以访问节点上的其他 Pod；&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;CNI&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;AddNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;CheckNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;DelNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;GetNetworkListCachedResult&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;GetNetworkListCachedConfig&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) ([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)

&lt;span&gt;AddNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;CheckNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;DelNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt;
&lt;span&gt;GetNetworkCachedResult&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) (&lt;span&gt;types&lt;/span&gt;.&lt;span&gt;Result&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;GetNetworkCachedConfig&lt;/span&gt;(&lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;, &lt;span&gt;rt&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;) ([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;RuntimeConf&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)

&lt;span&gt;ValidateNetworkList&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfigList&lt;/span&gt;) ([]&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
&lt;span&gt;ValidateNetwork&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;net&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NetworkConfig&lt;/span&gt;) ([]&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开发 CNI 插件对于多数工程师来说都非常遥远，在正常情况下，我们只需要在一些常见的开源框架中根据需求做出选择，例如：Flannel、Calico 和 Cilium 等，当集群的规模变得非常庞大时，也自然会有网络工程师与 Kubernetes 开发者配合开发相应的插件。&lt;/p&gt;&lt;h3 id=&quot;存储插件&quot;&gt;存储插件&lt;/h3&gt;&lt;p&gt;容器存储接口（Container Storage Interface、CSI）是 Kubernetes 在 v1.9 引入的新特性，该特性在 v1.13 中达到稳定，目前常见的容器编排系统 Kubernetes、Cloud Foundry、Mesos 和 Nomad 都选择使用该接口扩展集群中容器的存储能力。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/csi-banner-2021-03-24-16165170057477.png&quot; alt=&quot;csi-banner&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 6 - 容器存储接口&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CSI 是在容器编排系统向容器化的工作负载暴露块存储和文件存储的标准，第三方的存储提供商可以通过实现 CSI 插件在 Kubernetes 集群中提供新的存储&lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;Kubernetes 的开发团队在 CSI 的文档中给出了开发和部署 CSI 插件的最佳实践&lt;sup id=&quot;fnref:11&quot;&gt;&lt;a href=&quot;#fn:11&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;，其中最主要的工作是创建实现 &lt;code&gt;Identity&lt;/code&gt;、&lt;code&gt;Node&lt;/code&gt; 和可选的 &lt;code&gt;Controller&lt;/code&gt; 接口的容器化应用，并通过官方的 &lt;a href=&quot;https://github.com/kubernetes-csi/csi-test/tree/master/pkg/sanity&quot;&gt;&lt;code&gt;sanity&lt;/code&gt;&lt;/a&gt; 包测试 CSI 插件的合法性，需要实现的接口都定义在 CSI 的规格文档中&lt;sup id=&quot;fnref:12&quot;&gt;&lt;a href=&quot;#fn:12&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;service&lt;/span&gt; Identity {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;rpc&lt;/span&gt; GetPluginInfo(GetPluginInfoRequest)&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;returns&lt;/span&gt; (GetPluginInfoResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;rpc&lt;/span&gt; GetPluginCapabilities(GetPluginCapabilitiesRequest)&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;returns&lt;/span&gt; (GetPluginCapabilitiesResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;rpc&lt;/span&gt; Probe (ProbeRequest)&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;returns&lt;/span&gt; (ProbeResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; Controller {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;...&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; Node {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;  &lt;span&gt;...&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CSI 的规格文档非常复杂，除了详细地定义了不同接口的请求和响应参数。它还定义不同接口在出现相应错误时应该返回的 gRPC 错误码，开发者想要实现一个完全遵循 CSI 接口的插件还是很麻烦的。&lt;/p&gt;&lt;p&gt;Kubernetes 在较早的版本中分别接入了不同的云厂商的接口，其中包括 Google PD、AWS、Azure 以及 OpenStack，但是随着 CSI 接口的成熟，社区未来会在上游移除云厂商特定的实现，减少上游的维护成本，也能加快各个厂商自身存储的迭代和支持&lt;sup id=&quot;fnref:13&quot;&gt;&lt;a href=&quot;#fn:13&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h3 id=&quot;运行时接口&quot;&gt;运行时接口&lt;/h3&gt;&lt;p&gt;容器运行时接口（Container Runtime Interface、CRI）是一系列用于管理容器运行时和镜像的 gRPC 接口，它是 Kubernetes 在 v1.5 中引入的新接口，Kubelet 可以通过它使用不同的容器运行时。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/cri-and-container-runtimes-2021-03-24-16165170057484.png&quot; alt=&quot;cri-and-container-runtimes&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 7 - CRI 和容器运行时&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CRI 主要定义的是一组 gRPC 方法，我们能在规格文档中找到 &lt;code&gt;RuntimeService&lt;/code&gt; 和 &lt;code&gt;ImageService&lt;/code&gt; 两个服务&lt;sup id=&quot;fnref:14&quot;&gt;&lt;a href=&quot;#fn:14&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;，它们的名字很好地解释了各自的作用：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;service&lt;/span&gt; RuntimeService {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; Version(VersionRequest) &lt;span&gt;returns&lt;/span&gt; (VersionResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RunPodSandbox(RunPodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (RunPodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; StopPodSandbox(StopPodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (StopPodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RemovePodSandbox(RemovePodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (RemovePodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; PodSandboxStatus(PodSandboxStatusRequest) &lt;span&gt;returns&lt;/span&gt; (PodSandboxStatusResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ListPodSandbox(ListPodSandboxRequest) &lt;span&gt;returns&lt;/span&gt; (ListPodSandboxResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; CreateContainer(CreateContainerRequest) &lt;span&gt;returns&lt;/span&gt; (CreateContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; StartContainer(StartContainerRequest) &lt;span&gt;returns&lt;/span&gt; (StartContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; StopContainer(StopContainerRequest) &lt;span&gt;returns&lt;/span&gt; (StopContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RemoveContainer(RemoveContainerRequest) &lt;span&gt;returns&lt;/span&gt; (RemoveContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ListContainers(ListContainersRequest) &lt;span&gt;returns&lt;/span&gt; (ListContainersResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ContainerStatus(ContainerStatusRequest) &lt;span&gt;returns&lt;/span&gt; (ContainerStatusResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; UpdateContainerResources(UpdateContainerResourcesRequest) &lt;span&gt;returns&lt;/span&gt; (UpdateContainerResourcesResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ReopenContainerLog(ReopenContainerLogRequest) &lt;span&gt;returns&lt;/span&gt; (ReopenContainerLogResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ExecSync(ExecSyncRequest) &lt;span&gt;returns&lt;/span&gt; (ExecSyncResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; Exec(ExecRequest) &lt;span&gt;returns&lt;/span&gt; (ExecResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; Attach(AttachRequest) &lt;span&gt;returns&lt;/span&gt; (AttachResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; PortForward(PortForwardRequest) &lt;span&gt;returns&lt;/span&gt; (PortForwardResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;...&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; ImageService {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ListImages(ListImagesRequest) &lt;span&gt;returns&lt;/span&gt; (ListImagesResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ImageStatus(ImageStatusRequest) &lt;span&gt;returns&lt;/span&gt; (ImageStatusResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; PullImage(PullImageRequest) &lt;span&gt;returns&lt;/span&gt; (PullImageResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; RemoveImage(RemoveImageRequest) &lt;span&gt;returns&lt;/span&gt; (RemoveImageResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;rpc&lt;/span&gt; ImageFsInfo(ImageFsInfoRequest) &lt;span&gt;returns&lt;/span&gt; (ImageFsInfoResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;容器运行时的接口相对比较简单，上面的这些接口不仅暴露了 Pod 沙箱管理、容器管理以及命令执行和端口转发等功能，还包含用于管理镜像的多个接口，容器运行时只要实现上面的二三十个方法可以为 Kubelet 提供服务。&lt;/p&gt;&lt;h2 id=&quot;设备插件&quot;&gt;设备插件&lt;/h2&gt;&lt;p&gt;CPU、内存、磁盘是主机上常见的资源，然而随着大数据、机器学习和硬件的发展，部分场景可能需要异构的计算资源，例如：GPU、FPGA 等设备。异构资源的出现不仅需要节点代理 Kubelet 的支持，还需要调度器的配合，为了良好的兼容后出现的不同计算设备，Kubernetes 社区在上游引入了设备插件（Device Plugin）用于支持多种类型资源的调度和分配&lt;sup id=&quot;fnref:15&quot;&gt;&lt;a href=&quot;#fn:15&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;15&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/device-plugin-overview-2021-03-24-16165170057491.png&quot; alt=&quot;device-plugin-overview&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 8 - 设备插件概述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设备插件是独立在 Kubelet 之外单独运行的服务，它通过 Kubelet 暴露的 &lt;code&gt;Registration&lt;/code&gt; 服务注册自己的相关信息并实现 &lt;code&gt;DevicePlugin&lt;/code&gt; 服务用于订阅和分配自定义的设备&lt;sup id=&quot;fnref:16&quot;&gt;&lt;a href=&quot;#fn:16&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;16&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-protobuf&quot; data-lang=&quot;protobuf&quot;&gt;&lt;span&gt;service&lt;/span&gt; Registration {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;rpc&lt;/span&gt; Register(RegisterRequest) &lt;span&gt;returns&lt;/span&gt; (Empty) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;service&lt;/span&gt; DevicePlugin {&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; GetDevicePluginOptions(Empty) &lt;span&gt;returns&lt;/span&gt; (DevicePluginOptions) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; ListAndWatch(Empty) &lt;span&gt;returns&lt;/span&gt; (stream ListAndWatchResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; Allocate(AllocateRequest) &lt;span&gt;returns&lt;/span&gt; (AllocateResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; GetPreferredAllocation(PreferredAllocationRequest) &lt;span&gt;returns&lt;/span&gt; (PreferredAllocationResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;      &lt;span&gt;rpc&lt;/span&gt; PreStartContainer(PreStartContainerRequest) &lt;span&gt;returns&lt;/span&gt; (PreStartContainerResponse) {}&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;}&lt;span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当设备插件刚刚启动时，它会调用 Kubelet 的注册接口传入自己的版本号、Unix 套接字和资源名，例如：&lt;code&gt;nvidia.com/gpu&lt;/code&gt;；Kubelet 会通过 Unix 套接字与设备插件通信，它会通过 &lt;code&gt;ListAndWatch&lt;/code&gt; 接口持续获得设备中资源的最新状态，并在 Pod 申请资源时通过 &lt;code&gt;Allocate&lt;/code&gt; 接口分配资源。设备插件的实现逻辑相对比较简单，感兴趣的读者可以研究 Nvidia GPU 插件的实现原理&lt;sup id=&quot;fnref:17&quot;&gt;&lt;a href=&quot;#fn:17&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;17&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h2 id=&quot;调度框架&quot;&gt;调度框架&lt;/h2&gt;&lt;p&gt;调度器是 Kubernetes 中的核心组件之一，它的主要作用是在 Kubernetes 集群中的一组节点中为工作负载做出最优的调度决策，不同场景下的调度需求往往都是很复杂的，然而调度器在 Kubernetes 项目早期并不支持易用的扩展能力，仅支持调度器扩展（Extender）这种比较难用的方法。&lt;/p&gt;&lt;p&gt;Kubernetes 从 v1.15 引入的调度框架才是今天比较主流的调度器扩展技术，通过在 Kubernetes 调度器的内部抽象出关键的扩展点（Extension Point）并通过插件的方式在扩展点上改变调度器做出的调度决策&lt;sup id=&quot;fnref:18&quot;&gt;&lt;a href=&quot;#fn:18&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;18&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/scheduling-framework-extensions-2021-03-24-16165170057498.png&quot; alt=&quot;scheduling-framework-extensions&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 9 - 调度框架扩展点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;目前的调度框架总共支持 11 个不同的扩展点，每个扩展点都对应 Kubernetes 调度器中定义的接口，这里仅展示 &lt;code&gt;FilterPlugin&lt;/code&gt; 和 &lt;code&gt;ScorePlugin&lt;/code&gt; 两个常见接口中的方法&lt;sup id=&quot;fnref:19&quot;&gt;&lt;a href=&quot;#fn:19&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;19&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;FilterPlugin&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;Plugin&lt;/span&gt;
&lt;span&gt;Filter&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;state&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;CycleState&lt;/span&gt;, &lt;span&gt;pod&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;.&lt;span&gt;Pod&lt;/span&gt;, &lt;span&gt;nodeInfo&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;NodeInfo&lt;/span&gt;) &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;
}

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;ScoreExtensions&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;NormalizeScore&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;state&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;CycleState&lt;/span&gt;, &lt;span&gt;p&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;.&lt;span&gt;Pod&lt;/span&gt;, &lt;span&gt;scores&lt;/span&gt; &lt;span&gt;NodeScoreList&lt;/span&gt;) &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;
}

&lt;span&gt;type&lt;/span&gt; &lt;span&gt;ScorePlugin&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;span&gt;Plugin&lt;/span&gt;
&lt;span&gt;Score&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;, &lt;span&gt;state&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;CycleState&lt;/span&gt;, &lt;span&gt;p&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;.&lt;span&gt;Pod&lt;/span&gt;, &lt;span&gt;nodeName&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) (&lt;span&gt;int64&lt;/span&gt;, &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;)
&lt;span&gt;ScoreExtensions&lt;/span&gt;() &lt;span&gt;ScoreExtensions&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调度框架的出现让实现复杂的调度策略和调度算法变得更加容易，社区通过调度框架替代更早的谓词和优先级并实现了协作式调度、基于容量调度等功能更强大的插件&lt;sup id=&quot;fnref:20&quot;&gt;&lt;a href=&quot;#fn:20&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;20&lt;/a&gt;&lt;/sup&gt;。虽然今天的调度框架已经变得非常灵活，但是串行的调度器可能无法满足大集群的调度需求，而 Kubernetes 目前也很难实现多调度器，不知道未来是否会提供更灵活的接口。&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;Kubernetes 从 2014 年发布至今已经过去将近 7 年了，从一个最小可用的编排系统到今天的庞然大物，社区的每个代码贡献者和成员都有&lt;del&gt;责任&lt;/del&gt;。从这篇文章中，我们可以看到随着 Kubernetes 项目的演进方向，社区越来越关注系统的可扩展性，通过设计接口、移除第三方代码降低社区成员的负担，让 Kubernetes 能够更专注于容器的编排和调度。&lt;/p&gt;&lt;section class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Custom Resources · Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&quot;&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;API Conventions · Kubernetes Community &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Aggregated API Servers · Kubernetes Community &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Using Admission Controllers &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&quot;&gt;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;kubernetes/plugin/pkg/admission/ · Kubernetes &lt;a href=&quot;https://github.com/kubernetes/kubernetes/tree/master/plugin/pkg/admission&quot;&gt;https://github.com/kubernetes/kubernetes/tree/master/plugin/pkg/admission&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;kubernetes/plugin/pkg/admission/nodetaint/admission.go · Kubernetes &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/admission/nodetaint/admission.go&quot;&gt;https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/admission/nodetaint/admission.go&lt;/a&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:7&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Dynamic Admission Webhooks Overview &lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/mesh/webhook/&quot;&gt;https://istio.io/latest/docs/ops/configuration/mesh/webhook/&lt;/a&gt; &lt;a href=&quot;#fnref:7&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:8&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;CNI - the Container Network Interface cni &lt;a href=&quot;https://github.com/containernetworking/cni&quot;&gt;https://github.com/containernetworking/cni&lt;/a&gt; &lt;a href=&quot;#fnref:8&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:9&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Container Network Interface Specification &lt;a href=&quot;https://github.com/containernetworking/cni/blob/master/SPEC.md&quot;&gt;https://github.com/containernetworking/cni/blob/master/SPEC.md&lt;/a&gt; &lt;a href=&quot;#fnref:9&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:10&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Kubernetes Container Storage Interface (CSI) Documentation &lt;a href=&quot;https://kubernetes-csi.github.io/docs/#kubernetes-container-storage-interface-csi-documentation&quot;&gt;https://kubernetes-csi.github.io/docs/#kubernetes-container-storage-interface-csi-documentation&lt;/a&gt; &lt;a href=&quot;#fnref:10&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:11&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Recommended Mechanism (for Developing and Deploying a CSI driver for Kubernetes) &lt;a href=&quot;https://kubernetes-csi.github.io/docs/#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes&quot;&gt;https://kubernetes-csi.github.io/docs/#recommended-mechanism-for-developing-and-deploying-a-csi-driver-for-kubernetes&lt;/a&gt; &lt;a href=&quot;#fnref:11&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:12&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;RPC Interface · Container Storage Interface (CSI) &lt;a href=&quot;https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface&quot;&gt;https://github.com/container-storage-interface/spec/blob/master/spec.md#rpc-interface&lt;/a&gt; &lt;a href=&quot;#fnref:12&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:13&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;In-tree Storage Plugin to CSI Migration Design Doc &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-migration.md&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/csi-migration.md&lt;/a&gt; &lt;a href=&quot;#fnref:13&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:14&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes. &lt;a href=&quot;https://github.com/kubernetes/cri-api/blob/master/pkg/apis/runtime/v1/api.proto&quot;&gt;https://github.com/kubernetes/cri-api/blob/master/pkg/apis/runtime/v1/api.proto&lt;/a&gt; &lt;a href=&quot;#fnref:14&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:15&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Device Plugins &lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/&quot;&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/&lt;/a&gt; &lt;a href=&quot;#fnref:15&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:16&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;API Specification · Device Manager Proposal &lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md#api-specification&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md#api-specification&lt;/a&gt; &lt;a href=&quot;#fnref:16&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:17&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;k8s-device-plugin &lt;a href=&quot;https://github.com/NVIDIA/k8s-device-plugin&quot;&gt;https://github.com/NVIDIA/k8s-device-plugin&lt;/a&gt; &lt;a href=&quot;#fnref:17&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:18&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Scheduling Framework &lt;a href=&quot;https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework&quot;&gt;https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/624-scheduling-framework&lt;/a&gt; &lt;a href=&quot;#fnref:18&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:19&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;kubernetes/pkg/scheduler/framework/interface.go &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/framework/interface.go&quot;&gt;https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/framework/interface.go&lt;/a&gt; &lt;a href=&quot;#fnref:19&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:20&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Repository for out-of-tree scheduler plugins based on scheduler framework. &lt;a href=&quot;https://github.com/kubernetes-sigs/scheduler-plugins&quot;&gt;https://github.com/kubernetes-sigs/scheduler-plugins&lt;/a&gt; &lt;a href=&quot;#fnref:20&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;img src=&quot;https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png&quot; alt=&quot;wechat-account-qrcode&quot;/&gt;&lt;h3&gt;转载申请&lt;/h3&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://img.draveness.me/creative-commons.png&quot;/&gt;&lt;/a&gt;&lt;p&gt;本作品采用&lt;/p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;知识共享署名 4.0 国际许可协议&lt;/a&gt;&lt;p&gt;进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。&lt;/p&gt;&lt;h3&gt;文章图片&lt;/h3&gt;&lt;p&gt;你可以在 &lt;/p&gt;&lt;a href=&quot;/sketch-and-sketch&quot;&gt;技术文章配图指南&lt;/a&gt;&lt;p&gt; 中找到画图的方法和素材。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>