<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ff734ba57005bfd1d8ec658f73dd70e8</guid>
<title>2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</title>
<link>https://toutiao.io/k/0iue4f4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇《Java 基础知识总结》是 JavaGuide 上阅读量最高的一篇文章，由于我对其进行了重构完善并且修复了很多小问题，所以，在公号再同步一下！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章内容比较多，公号不太适合长文阅读。小伙伴们可以点击阅读原文进行在线阅读，体验会更好一点（有侧边目录）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整篇文章的目录如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;3.0180722891566263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmccvaBDmUlibcWZlrZ4AMB3dYS6nibeSTgcDPY2nuDx1wljqZf32qJJfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础概念与常识&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 语言有哪些特点?&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单易学；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向对象（封装，继承，多态）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;平台无关性（ Java 虚拟机实现平台无关性）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可靠性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编译与解释并存；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;修正（参见：issue#544）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用&lt;code&gt;std::thread&lt;/code&gt;和&lt;code&gt;std::async&lt;/code&gt;来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JVM vs JDK vs JRE&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JVM&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是字节码?采用字节码的好处是什么?&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在 Java 中，JVM 可以理解的代码就叫做&lt;code&gt;字节码&lt;/code&gt;（即扩展名为 &lt;code&gt;.class&lt;/code&gt; 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Java 程序从源代码到运行一般有下面 3 步：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2242503259452412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmibxCRvs5tpciaTMwWibJwF9MBosS8cf62uHJk7wCncyYkv8xkBdhl4nIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;figcaption&gt;Java程序运行过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要格外注意的是 .class-&amp;gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JDK 和 JRE&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么说 Java 语言“编译与解释并存”？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，
有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（&lt;code&gt;\*.class&lt;/code&gt; 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Oracle JDK 和 OpenJDK 的对比&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？&lt;/p&gt;&lt;p&gt;答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🌈 拓展一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;BCL 协议（Oracle Binary Code License Agreement）： 可以使用JDK（支持商用），但是不能进行修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的JDK用的都是这个协议，可以自己私下用，但是商用需要付费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5356466876971608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmWG8SQZ1Q0pNLKQrpGLRarZicz7ZIyr1DJee1ZXdWyfxvfT1AibzXwic2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1585&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关阅读👍：《Differences Between Oracle JDK and OpenJDK》&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 和 C++的区别?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;都是面向对象的语言，都支持封装、继承和多态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java 不提供指针来直接访问内存，程序内存更加安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;......&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;import java 和 javax 有什么区别？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，实际上 java 和 javax 没有区别。这都是一个名字。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本语法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;字符型常量和字符串常量的区别?&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;形式&lt;/strong&gt; : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;含义&lt;/strong&gt; : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;占内存大小&lt;/strong&gt; ：字符常量只占 2 个字节; 字符串常量占若干个字节 (&lt;strong&gt;注意：char 在 Java 中占两个字节&lt;/strong&gt;),&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;字符封装类 &lt;code&gt;Character&lt;/code&gt; 有一个成员常量 &lt;code&gt;Character.SIZE&lt;/code&gt; 值为 16,单位是&lt;code&gt;bits&lt;/code&gt;,该值除以 8(&lt;code&gt;1byte=8bits&lt;/code&gt;)后就可以得到 2 个字节&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;java 编程思想第四版：2.2.2 节&lt;img data-ratio=&quot;0.45161290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0Pm33L3yUDLVRQdkLia00BU1VLrYaP7DzVcrrUBoHroKCDng9wlrm3CO7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注释&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中的注释有三种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;单行注释&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;多行注释&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;文档注释。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Clean Code》这本书明确指出：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;举个例子：&lt;/p&gt;&lt;p&gt;去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// check to see if the employee is eligible for full benefits&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; ((employee.flags &amp;amp; HOURLY_FLAG) &amp;amp;&amp;amp; (employee.age &amp;gt; &lt;span&gt;65&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;应替换为&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (employee.isEligibleForFullBenefits())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标识符和关键字的区别是什么？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 中有哪些常见的关键字？&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;访问控制&lt;/th&gt;&lt;th&gt;private&lt;/th&gt;&lt;th&gt;protected&lt;/th&gt;&lt;th&gt;public&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;类，方法和变量修饰符&lt;/td&gt;&lt;td&gt;abstract&lt;/td&gt;&lt;td&gt;class&lt;/td&gt;&lt;td&gt;extends&lt;/td&gt;&lt;td&gt;final&lt;/td&gt;&lt;td&gt;implements&lt;/td&gt;&lt;td&gt;interface&lt;/td&gt;&lt;td&gt;native&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;new&lt;/td&gt;&lt;td&gt;static&lt;/td&gt;&lt;td&gt;strictfp&lt;/td&gt;&lt;td&gt;synchronized&lt;/td&gt;&lt;td&gt;transient&lt;/td&gt;&lt;td&gt;volatile&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;程序控制&lt;/td&gt;&lt;td&gt;break&lt;/td&gt;&lt;td&gt;continue&lt;/td&gt;&lt;td&gt;return&lt;/td&gt;&lt;td&gt;do&lt;/td&gt;&lt;td&gt;while&lt;/td&gt;&lt;td&gt;if&lt;/td&gt;&lt;td&gt;else&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;for&lt;/td&gt;&lt;td&gt;instanceof&lt;/td&gt;&lt;td&gt;switch&lt;/td&gt;&lt;td&gt;case&lt;/td&gt;&lt;td&gt;default&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;错误处理&lt;/td&gt;&lt;td&gt;try&lt;/td&gt;&lt;td&gt;catch&lt;/td&gt;&lt;td&gt;throw&lt;/td&gt;&lt;td&gt;throws&lt;/td&gt;&lt;td&gt;finally&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;包相关&lt;/td&gt;&lt;td&gt;import&lt;/td&gt;&lt;td&gt;package&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;基本类型&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;byte&lt;/td&gt;&lt;td&gt;char&lt;/td&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;float&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;long&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;short&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;td&gt;true&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;变量引用&lt;/td&gt;&lt;td&gt;super&lt;/td&gt;&lt;td&gt;this&lt;/td&gt;&lt;td&gt;void&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;保留字&lt;/td&gt;&lt;td&gt;goto&lt;/td&gt;&lt;td&gt;const&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自增自减运算符&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;++和--运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 &lt;code&gt;b = ++a&lt;/code&gt; 时，先自增（自己增加 1），再赋值（赋值给 b）；当 &lt;code&gt;b = a++&lt;/code&gt; 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;continue、break、和 return 的区别是什么？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;continue ：指跳出当前的这一次循环，继续下一次循环。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;break ：指跳出整个循环体，继续执行循环下面的语句。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;return;&lt;/code&gt; ：直接使用 return 结束方法执行，用于没有返回值函数的方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;return value;&lt;/code&gt; ：return 一个特定值，用于有返回值函数的方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;list.add(&lt;span&gt;12&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//这里直接添加会报错&lt;/span&gt;&lt;br/&gt;list.add(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;Class&amp;lt;? extends List&amp;gt; clazz = list.getClass();&lt;br/&gt;Method add = clazz.getDeclaredMethod(&lt;span&gt;&quot;add&quot;&lt;/span&gt;, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//但是通过反射添加，是可以的&lt;/span&gt;&lt;br/&gt;add.invoke(list, &lt;span&gt;&quot;kl&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(list);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.泛型类&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//在实例化泛型类时，必须指定T的具体类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Generic&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; T key;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Generic&lt;/span&gt;&lt;span&gt;(T key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; key;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何实例化泛型类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Generic&amp;lt;Integer&amp;gt; genericInteger = &lt;span&gt;new&lt;/span&gt; Generic&amp;lt;Integer&amp;gt;(&lt;span&gt;123456&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.泛型接口&lt;/strong&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Generator&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现泛型接口，不指定类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GeneratorImpl&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Generator&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现泛型接口，指定类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GeneratorImpl&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Generator&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.泛型方法&lt;/strong&gt; ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt; E &amp;gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;printArray&lt;/span&gt;&lt;span&gt;( E[] inputArray )&lt;/span&gt;&lt;br/&gt;   &lt;/span&gt;{&lt;br/&gt;         &lt;span&gt;for&lt;/span&gt; ( E element : inputArray ){&lt;br/&gt;            System.out.printf( &lt;span&gt;&quot;%s &quot;&lt;/span&gt;, element );&lt;br/&gt;         }&lt;br/&gt;         System.out.println();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建不同类型数组：Integer, Double 和 Character&lt;/span&gt;&lt;br/&gt;Integer[] intArray = { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; };&lt;br/&gt;String[] stringArray = { &lt;span&gt;&quot;Hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;World&quot;&lt;/span&gt; };&lt;br/&gt;printArray( intArray  );&lt;br/&gt;printArray( stringArray  );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;常用的通配符为：T，E，K，V，？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;？表示不确定的 java 类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;T (type) 表示具体的一个 java 类型&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;K V (key value) 分别代表 java 键值中的 Key Value&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;E (element) 代表 Element&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;==和 equals 的区别&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/strong&gt; 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。&lt;code&gt;equals()&lt;/code&gt;方法存在于&lt;code&gt;Object&lt;/code&gt;类中，而&lt;code&gt;Object&lt;/code&gt;类是所有类的直接或间接父类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object&lt;/code&gt; 类 &lt;code&gt;equals()&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; == obj);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;equals()&lt;/code&gt; 方法存在两种使用情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;类没有覆盖 &lt;code&gt;equals()&lt;/code&gt;方法&lt;/strong&gt; ：通过&lt;code&gt;equals()&lt;/code&gt;比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 &lt;code&gt;Object&lt;/code&gt;类&lt;code&gt;equals()&lt;/code&gt;方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;类覆盖了 &lt;code&gt;equals()&lt;/code&gt;方法&lt;/strong&gt; ：一般我们都覆盖 &lt;code&gt;equals()&lt;/code&gt;方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String a = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;ab&quot;&lt;/span&gt;); &lt;span&gt;// a 为一个引用&lt;/span&gt;&lt;br/&gt;        String b = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;ab&quot;&lt;/span&gt;); &lt;span&gt;// b为另一个引用,对象的内容一样&lt;/span&gt;&lt;br/&gt;        String aa = &lt;span&gt;&quot;ab&quot;&lt;/span&gt;; &lt;span&gt;// 放在常量池中&lt;/span&gt;&lt;br/&gt;        String bb = &lt;span&gt;&quot;ab&quot;&lt;/span&gt;; &lt;span&gt;// 从常量池中查找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (aa == bb) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;aa==bb&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (a == b) &lt;span&gt;// false，非同一对象&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;a==b&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (a.equals(b)) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;aEQb&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;42&lt;/span&gt; == &lt;span&gt;42.0&lt;/span&gt;) { &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;true&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;String&lt;/code&gt; 中的 &lt;code&gt;equals&lt;/code&gt; 方法是被重写过的，因为 &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法是比较的对象的内存地址，而 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;equals&lt;/code&gt; 方法比较的是对象的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当创建 &lt;code&gt;String&lt;/code&gt; 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 &lt;code&gt;String&lt;/code&gt; 对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String&lt;/code&gt;类&lt;code&gt;equals()&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object anObject)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; == anObject) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (anObject &lt;span&gt;instanceof&lt;/span&gt; String) {&lt;br/&gt;        String anotherString = (String)anObject;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; n = value.length;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (n == anotherString.value.length) {&lt;br/&gt;            &lt;span&gt;char&lt;/span&gt; v1[] = value;&lt;br/&gt;            &lt;span&gt;char&lt;/span&gt; v2[] = anotherString.value;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (n-- != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (v1[i] != v2[i])&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                i++;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;hashCode()与 equals()&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官可能会问你：“你重写过 &lt;code&gt;hashcode&lt;/code&gt; 和 &lt;code&gt;equals&lt;/code&gt;么，为什么重写 &lt;code&gt;equals&lt;/code&gt; 时必须重写 &lt;code&gt;hashCode&lt;/code&gt; 方法？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1)hashCode()介绍:&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hashCode()&lt;/code&gt; 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。&lt;code&gt;hashCode()&lt;/code&gt;定义在 JDK 的 &lt;code&gt;Object&lt;/code&gt; 类中，这就意味着 Java 中的任何类都包含有 &lt;code&gt;hashCode()&lt;/code&gt; 函数。另外需要注意的是：&lt;code&gt;Object&lt;/code&gt; 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2)为什么要有 hashCode？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以“&lt;code&gt;HashSet&lt;/code&gt; 如何检查重复”为例子来说明为什么要有 hashCode？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你把对象加入 &lt;code&gt;HashSet&lt;/code&gt; 时，&lt;code&gt;HashSet&lt;/code&gt; 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，&lt;code&gt;HashSet&lt;/code&gt; 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 &lt;code&gt;equals()&lt;/code&gt; 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，&lt;code&gt;HashSet&lt;/code&gt; 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3)为什么重写 &lt;code&gt;equals&lt;/code&gt; 时必须重写 &lt;code&gt;hashCode&lt;/code&gt; 方法？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。&lt;strong&gt;因此，equals 方法被覆盖过，则 &lt;code&gt;hashCode&lt;/code&gt; 方法也必须被覆盖。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;hashCode()&lt;/code&gt;的默认行为是对堆上的对象产生独特值。如果没有重写 &lt;code&gt;hashCode()&lt;/code&gt;，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 &lt;code&gt;hashCode()&lt;/code&gt; 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 &lt;code&gt;hashCode&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚也提到了 &lt;code&gt;HashSet&lt;/code&gt;,如果 &lt;code&gt;HashSet&lt;/code&gt; 在对比的时候，同样的 hashcode 有多个对象，它会使用 &lt;code&gt;equals()&lt;/code&gt; 来判断是否真的相同。也就是说 &lt;code&gt;hashcode&lt;/code&gt; 只是用来缩小查找成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于 &lt;code&gt;hashcode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 的内容可以查看：Java hashCode() 和 equals()的若干问题解答&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本数据类型&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中有 8 种基本数据类型，分别为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;6 种数字类型 ：&lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 种字符类型：&lt;code&gt;char&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 种布尔型：&lt;code&gt;boolean&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 8 种基本数据类型的默认值以及所占空间的大小如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;基本类型&lt;/th&gt;&lt;th&gt;位数&lt;/th&gt;&lt;th&gt;字节&lt;/th&gt;&lt;th&gt;默认值&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;long&lt;/code&gt;&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;0L&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;byte&lt;/code&gt;&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;&#x27;u0000&#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;0f&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;0d&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，对于 &lt;code&gt;boolean&lt;/code&gt;，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java 里使用 &lt;code&gt;long&lt;/code&gt; 类型的数据一定要在数值后面加上 &lt;strong&gt;L&lt;/strong&gt;，否则将作为整型解析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;char a = &#x27;h&#x27;&lt;/code&gt;char :单引号，&lt;code&gt;String a = &quot;hello&quot;&lt;/code&gt; :双引号。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这八种基本类型都有对应的包装类分别为：&lt;code&gt;Byte&lt;/code&gt;、&lt;code&gt;Short&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt;、&lt;code&gt;Long&lt;/code&gt;、&lt;code&gt;Float&lt;/code&gt;、&lt;code&gt;Double&lt;/code&gt;、&lt;code&gt;Character&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包装类型不赋值就是 &lt;code&gt;Null&lt;/code&gt; ，而基本类型有默认值且不是 &lt;code&gt;Null&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，这个问题建议还可以先从 JVM 层面来分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型**（boolean、byte、char、short、int、float、long、double）**、&lt;strong&gt;对象引用&lt;/strong&gt;（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自动装箱与拆箱&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;装箱&lt;/strong&gt;：将基本类型用它们对应的引用类型包装起来；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;拆箱&lt;/strong&gt;：将包装类型转换为基本数据类型；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer i = &lt;span&gt;10&lt;/span&gt;;  &lt;span&gt;//装箱&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; n = i;   &lt;span&gt;//拆箱&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两行代码对应的字节码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   L1&lt;br/&gt;&lt;br/&gt;    LINENUMBER &lt;span&gt;8&lt;/span&gt; L1&lt;br/&gt;&lt;br/&gt;    ALOAD &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    BIPUSH &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;&lt;br/&gt;&lt;br/&gt;    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;&lt;br/&gt;&lt;br/&gt;   L2&lt;br/&gt;&lt;br/&gt;    LINENUMBER &lt;span&gt;9&lt;/span&gt; L2&lt;br/&gt;&lt;br/&gt;    ALOAD &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ALOAD &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;&lt;br/&gt;&lt;br/&gt;    INVOKEVIRTUAL java/lang/Integer.intValue ()I&lt;br/&gt;&lt;br/&gt;    PUTFIELD AutoBoxTest.n : I&lt;br/&gt;&lt;br/&gt;    RETURN&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字节码中，我们发现装箱其实就是调用了 包装类的&lt;code&gt;valueOf()&lt;/code&gt;方法，拆箱其实就是调用了 &lt;code&gt;xxxValue()&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Integer i = 10&lt;/code&gt; 等价于 &lt;code&gt;Integer i = Integer.valueOf(10)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;int n = i&lt;/code&gt; 等价于 &lt;code&gt;int n = i.intValue()&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8 种基本类型的包装类和常量池&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 基本类型的包装类的大部分都实现了常量池技术。&lt;code&gt;Byte&lt;/code&gt;,&lt;code&gt;Short&lt;/code&gt;,&lt;code&gt;Integer&lt;/code&gt;,&lt;code&gt;Long&lt;/code&gt; 这 4 种包装类默认创建了数值 &lt;strong&gt;[-128，127]&lt;/strong&gt; 的相应类型的缓存数据，&lt;code&gt;Character&lt;/code&gt; 创建了数值在[0,127]范围的缓存数据，&lt;code&gt;Boolean&lt;/code&gt; 直接返回 &lt;code&gt;True&lt;/code&gt; Or &lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Integer 缓存源码：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;&lt;br/&gt;*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。&lt;br/&gt;&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Integer &lt;span&gt;valueOf&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; IntegerCache.cache[i + (-IntegerCache.low)];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Integer(i);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IntegerCache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; low = -&lt;span&gt;128&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; high;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer cache[];&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Character&lt;/code&gt; 缓存源码:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Character &lt;span&gt;valueOf&lt;/span&gt;&lt;span&gt;(&lt;span&gt;char&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c &amp;lt;= &lt;span&gt;127&lt;/span&gt;) { &lt;span&gt;// must cache&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; CharacterCache.cache[(&lt;span&gt;int&lt;/span&gt;)c];&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Character(c);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CharacterCache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;CharacterCache&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Character cache[] = &lt;span&gt;new&lt;/span&gt; Character[&lt;span&gt;127&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cache.length; i++)&lt;br/&gt;&lt;br/&gt;            cache[i] = &lt;span&gt;new&lt;/span&gt; Character((&lt;span&gt;char&lt;/span&gt;)i);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;Boolean&lt;/code&gt; 缓存源码：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Boolean &lt;span&gt;valueOf&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (b ? TRUE : FALSE);&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种浮点数类型的包装类 &lt;code&gt;Float&lt;/code&gt;,&lt;code&gt;Double&lt;/code&gt; 并没有实现常量池技术。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer i1 = &lt;span&gt;33&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Integer i2 = &lt;span&gt;33&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;System.out.println(i1 == i2);&lt;span&gt;// 输出 true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Float i11 = &lt;span&gt;333f&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Float i22 = &lt;span&gt;333f&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;System.out.println(i11 == i22);&lt;span&gt;// 输出 false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Double i3 = &lt;span&gt;1.2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Double i4 = &lt;span&gt;1.2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;System.out.println(i3 == i4);&lt;span&gt;// 输出 false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看一下问题。下面的代码的输出结果是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;flase&lt;/code&gt; 呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer i1 = &lt;span&gt;40&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Integer i2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;40&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(i1==i2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Integer i1=40&lt;/code&gt; 这一行代码会发生拆箱，也就是说这行代码等价于 &lt;code&gt;Integer i1=Integer.valueOf(40)&lt;/code&gt; 。因此，&lt;code&gt;i1&lt;/code&gt; 直接使用的是常量池中的对象。而&lt;code&gt;Integer i1 = new Integer(40)&lt;/code&gt; 会直接创建新的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，答案是 &lt;code&gt;false&lt;/code&gt; 。你答对了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记住：&lt;strong&gt;所有整型包装类对象之间值的比较，全部使用 equals 方法比较&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2055944055944056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0Pm7Nm5N5J0MQ2DXPhoE5KjibiawxW4Pq2Uvic2wXtfdF2dQQ0sov5x6wwiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法（函数）&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是方法的返回值?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法有哪几种类型？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.无参数无返回值的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;无参数无返回值的方法&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.有参数无返回值的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt;* 有参数无返回值的方法&lt;br/&gt;* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, String b, &lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(a + &lt;span&gt;&quot;--&amp;gt;&quot;&lt;/span&gt; + b + &lt;span&gt;&quot;--&amp;gt;&quot;&lt;/span&gt; + c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.有返回值无参数的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;有返回值无参数的方法&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.有返回值有参数的方法&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 有返回值有参数的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f4&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a * b;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.return 在无返回值方法的特殊使用&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// return在无返回值方法的特殊使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;f5&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (a &amp;gt; &lt;span&gt;10&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(a);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;在一个静态方法内调用一个非静态成员为什么是非法的?&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需要结合 JVM 的相关知识，静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;静态方法和实例方法有何不同？&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，&lt;strong&gt;调用静态方法可以无需创建对象。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么 Java 中只有值传递？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;按值调用(call by value)&lt;/strong&gt; 表示方法接收的是调用者提供的值，&lt;strong&gt;按引用调用（call by reference)&lt;/strong&gt; 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下面通过 3 个例子来给大家说明&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;example 1&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; num1 = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; num2 = &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    swap(num1, num2);&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;num1 = &quot;&lt;/span&gt; + num1);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;num2 = &quot;&lt;/span&gt; + num2);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; temp = a;&lt;br/&gt;    a = b;&lt;br/&gt;    b = temp;&lt;br/&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;a = &quot;&lt;/span&gt; + a);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;b = &quot;&lt;/span&gt; + b);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a = 20&lt;br/&gt;b = 10&lt;br/&gt;num1 = 10&lt;br/&gt;num2 = 20&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8037190082644629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmqnM3uJUBbVptT5fn3fr80YDp6yKfy386OzVgKx62XWIl6P8vxIzzKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;figcaption&gt;example 1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;example 2&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt;[] arr = { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt; };&lt;br/&gt;  System.out.println(arr[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;  change(arr);&lt;br/&gt;  System.out.println(arr[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;change&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] array)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 将数组的第一个元素变为0&lt;/span&gt;&lt;br/&gt;  array[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1&lt;br/&gt;0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5437062937062938&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmlVsfdjOJ6iab6PZqg0BO5ZBWVc4bfSdLVZd6ejhyhaLZkAO21EKWNlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;figcaption&gt;example 2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。因此，外部对引用对象的改变会反映到所对应的对象上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;example 3&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;br/&gt;  Student s1 = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;小张&quot;&lt;/span&gt;);&lt;br/&gt;  Student s2 = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;小李&quot;&lt;/span&gt;);&lt;br/&gt;  Test.swap(s1, s2);&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;s1:&quot;&lt;/span&gt; + s1.getName());&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;s2:&quot;&lt;/span&gt; + s2.getName());&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(Student x, Student y)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Student temp = x;&lt;br/&gt;  x = y;&lt;br/&gt;  y = temp;&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;x:&quot;&lt;/span&gt; + x.getName());&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;y:&quot;&lt;/span&gt; + y.getName());&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;x:小李&lt;br/&gt;y:小张&lt;br/&gt;s1:小张&lt;br/&gt;s2:小李&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交换之前：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5125184094256259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmLHvjibV6Dy1lMUpds3EbjL9DQ0oXapL61ygGJ8ZZ4Y9M9At1bVia9gUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交换之后：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5125184094256259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0Pm5NFHuHIqtbfZx0jYxic5vGxbVj2rmvs6ZW5WuRf4vHMaFUQzZiaaWQzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面两张图可以很清晰的看出：&lt;strong&gt;方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按
值传递的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面再总结一下 Java 中方法参数的使用情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个方法可以改变一个对象参数的状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个方法不能让对象参数引用一个新的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重载和重写的区别&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理&lt;/p&gt;&lt;p&gt;重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重载&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是《Java 核心技术》对重载这个概念的介绍：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6707105719237435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmT56LEyPSGcHTpkmwILwvnsobm96zVElW6v6QKOUZ0KAByiaYAU9p1EQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2308&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重写&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果父类方法访问修饰符为 &lt;code&gt;private/final/static&lt;/code&gt; 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;构造方法无法被重写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;暖心的 Guide 哥最后再来个图表总结一下！&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;区别点&lt;/th&gt;&lt;th&gt;重载方法&lt;/th&gt;&lt;th&gt;重写方法&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;发生范围&lt;/td&gt;&lt;td&gt;同一个类&lt;/td&gt;&lt;td&gt;子类&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;参数列表&lt;/td&gt;&lt;td&gt;必须修改&lt;/td&gt;&lt;td&gt;一定不能修改&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;返回类型&lt;/td&gt;&lt;td&gt;可修改&lt;/td&gt;&lt;td&gt;子类方法返回值类型应比父类方法返回值类型更小或相等&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异常&lt;/td&gt;&lt;td&gt;可修改&lt;/td&gt;&lt;td&gt;子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;访问修饰符&lt;/td&gt;&lt;td&gt;可修改&lt;/td&gt;&lt;td&gt;一定不能做更严格的限制（可以降低限制）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;发生阶段&lt;/td&gt;&lt;td&gt;编译期&lt;/td&gt;&lt;td&gt;运行期&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方法的重写要遵循“两同两小一大”&lt;/strong&gt;（以下内容摘录自《疯狂 Java 讲义》,issue#892 ）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;“两同”即方法名相同、形参列表相同；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⭐️ 关于 &lt;strong&gt;重写的返回值类&lt;/strong&gt;型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Hero&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;超级英雄&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SuperMan&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Hero&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;超人&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Hero &lt;span&gt;hero&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Hero();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SuperSuperMan&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SuperMan&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;超级超级英雄&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SuperMan &lt;span&gt;hero&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SuperMan();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;深拷贝 vs 浅拷贝&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmeWI4yczObCLUDkRWlGmlk47UtbbQVCstSQmNs8ewnErAwuBc3jzQlg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;deep and shallow copy&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 面向对象&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;面向对象和面向过程的区别&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;面向过程&lt;/strong&gt; ：&lt;strong&gt;面向过程性能比面向对象高。&lt;/strong&gt; 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，&lt;strong&gt;面向过程没有面向对象易维护、易复用、易扩展。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;面向对象&lt;/strong&gt; ：&lt;strong&gt;面向对象易维护、易复用、易扩展。&lt;/strong&gt; 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，&lt;strong&gt;面向对象性能比面向过程低&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参见 issue : 面向过程 ：面向过程性能比面向对象高？？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。&lt;/p&gt;&lt;p&gt;而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;成员变量与局部变量的区别有哪些？&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 &lt;code&gt;public&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;,&lt;code&gt;static&lt;/code&gt; 等修饰符所修饰，而局部变量不能被访问控制修饰符及 &lt;code&gt;static&lt;/code&gt; 所修饰；但是，成员变量和局部变量都能被 &lt;code&gt;final&lt;/code&gt; 所修饰。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从变量在内存中的存储方式来看,如果成员变量是使用 &lt;code&gt;static&lt;/code&gt; 修饰的，那么这个成员变量是属于类的，如果没有使用 &lt;code&gt;static&lt;/code&gt; 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 &lt;code&gt;final&lt;/code&gt; 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;创建一个对象用什么运算符?对象实体与对象引用有何不同?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对象的相等与指向他们的引用相等,两者有什么不同?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法主要作用是完成对类对象的初始化工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;构造方法有哪些特点？是否可被 override?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;名字与类名相同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有返回值，但不能用 void 声明构造函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成类的对象时自动执行，无需调用。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;面向对象三大特征&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;封装&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;span&gt;//id属性私有化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;span&gt;//name属性私有化&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//获取id的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//设置id的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setId&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//获取name的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//设置name的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;继承&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于继承如下 3 点请记住：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，&lt;strong&gt;只是拥有&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子类可以拥有自己属性和方法，即子类可以对父类进行扩展。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子类可以用自己的方式实现父类的方法。（以后介绍）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多态&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;多态的特点:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对象类型和引用类型之间具有继承（类）/实现（接口）的关系；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多态不能调用“只在子类存在但在父类不存在”的方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可变性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的来说：&lt;code&gt;String&lt;/code&gt; 类中使用 final 关键字修饰字符数组来保存字符串，&lt;code&gt;private final char value[]&lt;/code&gt;，所以&lt;code&gt;String&lt;/code&gt; 对象是不可变的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;补充（来自issue 675）：在 Java 9 之后，String 、&lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的实现改用 byte 数组存储字符串 &lt;code&gt;private final byte[] value&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 &lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 都继承自 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 类，在 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; 中也是使用字符数组保存字符串&lt;code&gt;char[]value&lt;/code&gt; 但是没有用 &lt;code&gt;final&lt;/code&gt; 关键字修饰，所以这两种对象都是可变的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的构造方法都是调用父类构造方法也就是&lt;code&gt;AbstractStringBuilder&lt;/code&gt; 实现的，大家可以自行查阅源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AbstractStringBuilder.java&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractStringBuilder&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Appendable&lt;/span&gt;, &lt;span&gt;CharSequence&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The value is used for character storage.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;[] value;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * The count is the number of characters used.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count;&lt;br/&gt;&lt;br/&gt;    AbstractStringBuilder(&lt;span&gt;int&lt;/span&gt; capacity) {&lt;br/&gt;        value = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[capacity];&lt;br/&gt;    }}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String&lt;/code&gt; 中的对象是不可变的，也就可以理解为常量，线程安全。&lt;code&gt;AbstractStringBuilder&lt;/code&gt; 是 &lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的公共父类，定义了一些字符串的基本操作，如 &lt;code&gt;expandCapacity&lt;/code&gt;、&lt;code&gt;append&lt;/code&gt;、&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 等公共方法。&lt;code&gt;StringBuffer&lt;/code&gt; 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。&lt;code&gt;StringBuilder&lt;/code&gt; 并没有对方法进行加同步锁，所以是非线程安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次对 &lt;code&gt;String&lt;/code&gt; 类型进行改变的时候，都会生成一个新的 &lt;code&gt;String&lt;/code&gt; 对象，然后将指针指向新的 &lt;code&gt;String&lt;/code&gt; 对象。&lt;code&gt;StringBuffer&lt;/code&gt; 每次都会对 &lt;code&gt;StringBuffer&lt;/code&gt; 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 &lt;code&gt;StringBuilder&lt;/code&gt; 相比使用 &lt;code&gt;StringBuffer&lt;/code&gt; 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对于三者使用的总结：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;操作少量的数据: 适用 &lt;code&gt;String&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单线程操作字符串缓冲区下操作大量数据: 适用 &lt;code&gt;StringBuilder&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程操作字符串缓冲区下操作大量数据: 适用 &lt;code&gt;StringBuffer&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Object 类的常见方法总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Class&amp;lt;?&amp;gt; getClass()&lt;span&gt;//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt;&lt;span&gt;//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Object &lt;span&gt;clone&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; CloneNotSupportedException&lt;span&gt;//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notify&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;notifyAll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeout)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;span&gt;//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeout, &lt;span&gt;int&lt;/span&gt; nanos)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;span&gt;//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;span&gt;//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;finalize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{ }&lt;span&gt;//实例被垃圾回收器回收的时候触发的操作&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;何为反射？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射机制优缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射的应用场景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 &lt;code&gt;Method&lt;/code&gt; 来调用指定的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DebugInvocationHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 代理类中的真实对象&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object target;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DebugInvocationHandler&lt;/span&gt;&lt;span&gt;(Object target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InvocationTargetException, IllegalAccessException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;before method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        Object result = method.invoke(target, args);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;after method &quot;&lt;/span&gt; + method.getName());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，像 Java 中的一大利器 &lt;strong&gt;注解&lt;/strong&gt; 的实现也用到了反射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么你使用 Spring 的时候 ，一个&lt;code&gt;@Component&lt;/code&gt;注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 &lt;code&gt;@Value&lt;/code&gt;注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;异常&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 异常类层次结构图&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6001712328767124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmQSF4qmibjDCYDtwSVmb3QNj6n09shiaM60zoXpenJ1mvvXGiaM8Z6dS2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4892086330935252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmPFzMa8stp8C4AGhjboa5tr5Xhxol9fLQgYkX5oFp4Xjlq4rliahOD5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1946&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来自：https://chercher.tech/java-programming/exceptions-java&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 中，所有的异常都有一个共同的祖先 &lt;code&gt;java.lang&lt;/code&gt; 包中的 &lt;code&gt;Throwable&lt;/code&gt; 类。&lt;code&gt;Throwable&lt;/code&gt; 类有两个重要的子类 &lt;code&gt;Exception&lt;/code&gt;（异常）和 &lt;code&gt;Error&lt;/code&gt;（错误）。&lt;code&gt;Exception&lt;/code&gt; 能被程序本身处理(&lt;code&gt;try-catch&lt;/code&gt;)， &lt;code&gt;Error&lt;/code&gt; 是无法处理的(只能尽量避免)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Exception&lt;/code&gt; 和 &lt;code&gt;Error&lt;/code&gt; 二者都是 Java 异常处理的重要子类，各自都包含大量子类。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/strong&gt; :程序本身可以处理的异常，可以通过 &lt;code&gt;catch&lt;/code&gt; 来进行捕获。&lt;code&gt;Exception&lt;/code&gt; 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/strong&gt; ：&lt;code&gt;Error&lt;/code&gt; 属于程序无法处理的错误 ，我们没办法通过 &lt;code&gt;catch&lt;/code&gt; 来进行捕获 。例如，Java 虚拟机运行错误（&lt;code&gt;Virtual MachineError&lt;/code&gt;）、虚拟机内存不够错误(&lt;code&gt;OutOfMemoryError&lt;/code&gt;)、类定义错误（&lt;code&gt;NoClassDefFoundError&lt;/code&gt;）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;受检查异常&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 代码在编译过程中，如果受检查异常没有被 &lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;throw&lt;/code&gt; 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8247422680412371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmadxU2vLkLL46qMToiaqxKia9Gs5MWiaRqaMHXF7VjJ8lL6I0ib7WoYcRsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;figcaption&gt;check-exception&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&lt;code&gt;RuntimeException&lt;/code&gt;及其子类以外，其他的&lt;code&gt;Exception&lt;/code&gt;类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、&lt;code&gt;ClassNotFoundException&lt;/code&gt; 、&lt;code&gt;SQLException&lt;/code&gt;...。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不受检查异常&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt; 及其子类都统称为非受检查异常，例如：&lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;NumberFormatException&lt;/code&gt;（字符串转换为数字）、&lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;（数组越界）、&lt;code&gt;ClassCastException&lt;/code&gt;（类型转换错误）、&lt;code&gt;ArithmeticException&lt;/code&gt;（算术错误）等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Throwable 类常用方法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public string getMessage()&lt;/code&gt;&lt;/strong&gt;:返回异常发生时的简要描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public string toString()&lt;/code&gt;&lt;/strong&gt;:返回异常发生时的详细信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public string getLocalizedMessage()&lt;/code&gt;&lt;/strong&gt;:返回异常对象的本地化信息。使用 &lt;code&gt;Throwable&lt;/code&gt; 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 &lt;code&gt;getMessage（）&lt;/code&gt;返回的结果相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;public void printStackTrace()&lt;/code&gt;&lt;/strong&gt;:在控制台上打印 &lt;code&gt;Throwable&lt;/code&gt; 对象封装的异常信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;try-catch-finally&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;try&lt;/code&gt;块：&lt;/strong&gt; 用于捕获异常。其后可接零个或多个 &lt;code&gt;catch&lt;/code&gt; 块，如果没有 &lt;code&gt;catch&lt;/code&gt; 块，则必须跟一个 &lt;code&gt;finally&lt;/code&gt; 块。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;catch&lt;/code&gt;块：&lt;/strong&gt; 用于处理 try 捕获到的异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;finally&lt;/code&gt; 块：&lt;/strong&gt; 无论是否捕获或处理异常，&lt;code&gt;finally&lt;/code&gt; 块里的语句都会被执行。当在 &lt;code&gt;try&lt;/code&gt; 块或 &lt;code&gt;catch&lt;/code&gt; 块中遇到 &lt;code&gt;return&lt;/code&gt; 语句时，&lt;code&gt;finally&lt;/code&gt; 语句块将在方法返回之前被执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在以下 3 种特殊情况下，&lt;code&gt;finally&lt;/code&gt; 块不会被执行：&lt;/strong&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;try&lt;/code&gt; 或 &lt;code&gt;finally&lt;/code&gt;块中用了 &lt;code&gt;System.exit(int)&lt;/code&gt;退出程序。但是，如果 &lt;code&gt;System.exit(int)&lt;/code&gt; 在异常语句之后，&lt;code&gt;finally&lt;/code&gt; 还是会被执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序所在的线程死亡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭 CPU。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这部分内容来自 issue:https://github.com/Snailclimb/JavaGuide/issues/190。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt; 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value * value;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用 &lt;code&gt;f(2)&lt;/code&gt;，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 &lt;code&gt;try-with-resources&lt;/code&gt; 来代替&lt;code&gt;try-catch-finally&lt;/code&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;适用范围（资源的定义）：&lt;/strong&gt; 任何实现 &lt;code&gt;java.lang.AutoCloseable&lt;/code&gt;或者 &lt;code&gt;java.io.Closeable&lt;/code&gt; 的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;关闭资源和 finally 块的执行顺序：&lt;/strong&gt; 在 &lt;code&gt;try-with-resources&lt;/code&gt; 语句中，任何 catch 或 finally 块在声明的资源关闭后运行&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Effecitve Java》中明确指出：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;面对必须要关闭的资源，我们总是应该优先使用 &lt;code&gt;try-with-resources&lt;/code&gt; 而不是&lt;code&gt;try-finally&lt;/code&gt;。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。&lt;code&gt;try-with-resources&lt;/code&gt;语句让我们更容易编写必须要关闭的资源的代码，若采用&lt;code&gt;try-finally&lt;/code&gt;则几乎做不到这点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中类似于&lt;code&gt;InputStream&lt;/code&gt;、&lt;code&gt;OutputStream&lt;/code&gt; 、&lt;code&gt;Scanner&lt;/code&gt; 、&lt;code&gt;PrintWriter&lt;/code&gt;等的资源都需要我们调用&lt;code&gt;close()&lt;/code&gt;方法来手动关闭，一般情况下我们都是通过&lt;code&gt;try-catch-finally&lt;/code&gt;语句来实现这个需求，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;//读取文本文件的内容&lt;/span&gt;&lt;br/&gt;        Scanner scanner = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            scanner = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;D://read.txt&quot;&lt;/span&gt;));&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (scanner.hasNext()) {&lt;br/&gt;                System.out.println(scanner.nextLine());&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (FileNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (scanner != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                scanner.close();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Java 7 之后的 &lt;code&gt;try-with-resources&lt;/code&gt; 语句改造上面的代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; (Scanner scanner = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;))) {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (scanner.hasNext()) {&lt;br/&gt;        System.out.println(scanner.nextLine());&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (FileNotFoundException fnfe) {&lt;br/&gt;    fnfe.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然多个资源需要关闭的时候，使用 &lt;code&gt;try-with-resources&lt;/code&gt; 实现起来也非常简单，如果你还是用&lt;code&gt;try-catch-finally&lt;/code&gt;可能会带来很多问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用分号分隔，可以在&lt;code&gt;try-with-resources&lt;/code&gt;块中声明多个资源。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; (BufferedInputStream bin = &lt;span&gt;new&lt;/span&gt; BufferedInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;)));&lt;br/&gt;             BufferedOutputStream bout = &lt;span&gt;new&lt;/span&gt; BufferedOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;out.txt&quot;&lt;/span&gt;)))) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((b = bin.read()) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                bout.write(b);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;I\O 流&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是序列化?什么是反序列化?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;序列化&lt;/strong&gt;：将数据结构或对象转换成二进制字节流的过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维基百科是如是介绍序列化的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上：&lt;strong&gt;序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4006024096385542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmdkuOzRoF32s4L0ZPB6ib1MKfe2MflhRWqateEEl967ff0VSDr22Gnbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.corejavaguru.com/java/serialization/interview-questions-1&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 序列化中如果有些字段不想进行序列化，怎么办？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;对于不想进行序列化的变量，使用&lt;/code&gt;transient&lt;code&gt;关键字修饰。&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;transient&lt;/code&gt; 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 &lt;code&gt;transient&lt;/code&gt; 修饰的变量值不会被持久化和恢复。&lt;code&gt;transient&lt;/code&gt; 只能修饰变量，不能修饰类和方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取用键盘输入常用的两种方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法 1：通过 &lt;code&gt;Scanner&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Scanner input = &lt;span&gt;new&lt;/span&gt; Scanner(System.in);&lt;br/&gt;String s  = input.nextLine();&lt;br/&gt;input.close();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法 2：通过 &lt;code&gt;BufferedReader&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BufferedReader input = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(System.in));&lt;br/&gt;String s = input.readLine();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java 中 IO 流分为几种?&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;按照流的流向分，可以分为输入流和输出流；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照操作单元划分，可以划分为字节流和字符流；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照流的角色划分为节点流和处理流。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按操作方式分类结构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmDJPvAPWFTLWfq9o77Wicib5JL5QP3LiclXavTeIFOBCaNRicvc0WaUappA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;IO-操作方式分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按操作对象分类结构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7430555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TxV7QiaUkEKuXprqsGAFa0PmNDp5EBPicwuWRITg2YVO2iciaCtIZX6FXI0Ce5rMwGicibiavkYXHAths6Sg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;IO-操作对象分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;既然有了字节流,为什么还要有字符流?&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题本质想问：&lt;strong&gt;不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://www.educba.com/oracle-vs-openjdk/&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top## 基础概念与常识&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21040e79831dea6451793beb09269497</guid>
<title>线程的安全性（并发基础篇）</title>
<link>https://toutiao.io/k/2e818j0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：汤圆&lt;/p&gt;

&lt;p&gt;个人博客：&lt;a href=&quot;http://www.javalover.cc&quot;&gt;javalover.cc&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;官人们好啊，我是汤圆，今天给大家带来的是《线程的安全性 - 并发基础篇》，希望有所帮助，谢谢&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章纯属原创，个人总结难免有差错，如果有，麻烦在评论区回复或后台私信，谢啦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就说这个类是线程安全的&lt;/p&gt;

&lt;h2&gt;目录&lt;/h2&gt;

&lt;p&gt;这次分三步走：关于相关知识点，放在文末的脑图里了，大家想看结论的，可直接下拉观看哦&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建一个线程安全的类&lt;/li&gt;
&lt;li&gt;创建一个线程不安全的类：有一个状态变量&lt;/li&gt;
&lt;li&gt;创建一个线程不安全的类：有多个状态变量&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;线程的安全性主要是针对对象的状态（实例属性或静态属性）而言的，如果在多线程中，访问到的对象状态不一致（比如常见的自增属性），那么就是线程不安全的&lt;/p&gt;

&lt;p&gt;下面我们一步步来&lt;/p&gt;

&lt;p&gt;先来个无状态类&lt;/p&gt;

&lt;h3&gt;第一步：无状态类&lt;/h3&gt;

&lt;p&gt;这里我们写一个简单的线程安全类，简单到什么地步呢？如下所示&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class SafeDemo {

    public int sum(int n, int m){
        return n + m;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这么简单，我们说&lt;strong&gt;这个类是线程安全的&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为啥安全呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为这个类没有状态，即无状态类；&lt;/p&gt;

&lt;p&gt;只有局部变量n,m，而这些局部变量是存在于栈中的，栈是每个线程独有的，不跟其他线程共享，堆才共享&lt;/p&gt;

&lt;p&gt;所以每个线程操作sum时，对应的n,m只有自己可见，当然就安全了&lt;/p&gt;

&lt;p&gt;好了，通过上面的例子，我们知道了什么是线程安全类，那本节的内容就到此结束了，再见&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/24/RliUoIWu7C8hd4s.jpg&quot; alt=&quot;疑问&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的例子，我们举了一个无状态类，接下来我们添加一个状态试试&lt;/p&gt;

&lt;h3&gt;第二步：加一个状态变量&lt;/h3&gt;

&lt;p&gt;加一个状态变量（静态属性），代码如下&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class UnSafeDemo {

    static int a = 0;

    public static void main(String[] args) throws InterruptedException {
                // 线程1
        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;100000;j++){
                a++;
            }

        }).start();
                // 线程2
        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;100000;j++){
                a++;
            }
        }).start();

        Thread.sleep(3000);
        // 这里不是每次运行都会输出200,000
        System.out.println(a);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们创建了两个线程，每个线程都执行10万次的自增操作&lt;/p&gt;

&lt;p&gt;但是因为&lt;strong&gt;自增不是原子操作&lt;/strong&gt;，实际分三步：读-改-写&lt;/p&gt;

&lt;p&gt;此时如果两个线程同时读到相同的值，则累加次数就会少一次&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这种在并发编程中，由于不恰当的执行时序而出现不正确的结果的情况，叫做竞态条件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p&gt;期望的是正常执行，每个线程交替执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/24/rsf24XOSu3A58qg.png&quot; alt=&quot;自增-正常&quot;/&gt;&lt;/p&gt;

&lt;p&gt;结果却有可能是不正常的，如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/24/CKEIBVwkeHjldcX.png&quot; alt=&quot;自增-不正常&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这时我们就可以说，上面加的这个状态是不安全的，结果就是整个类也是不安全的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不安全的状态有二&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可变状态（变量）：非final修饰的变量&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;共享状态（变量）：非局部变量&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像上面这个例子，状态就同时属于可变状态和共享状态&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那要怎么确保安全&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;同步：synchronized、volatile、显式锁、原子变量（比如AtomicInteger）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不可变变量：final（都不能改了，当然安全了）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不共享变量：不在多线程中共享变量（即局部变量）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;PS：代码的封装性越好，访问可变变量的代码块越少，越容易确保线程安全&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里的自增我们就可以用同步中的原子变量来解决&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;关于原子变量的细节，后面章节再介绍，这里只需要知道，原子变量内部的操作是原子操作就可以了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改后的代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class SafeDemo {
    static final AtomicInteger a = new AtomicInteger(0);
//    static int a = 0;

    public static void main(String[] args) throws InterruptedException {
                // 线程1
        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;100000;j++){
                // 这里的自增是原子操作
                a.incrementAndGet();
            }
        }).start();
                // 线程2
        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;100000;j++){
              // 这里的自增是原子操作
                a.incrementAndGet();
            }
        }).start();

        Thread.sleep(3000);
        System.out.println(a.get());
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，加了AtomicInteger.incrementAndGet()方法，这个方法是原子操作&lt;/p&gt;

&lt;p&gt;这时，不管怎么运行，都是输出200,000&lt;/p&gt;

&lt;h3&gt;第三步：加多个状态变量&lt;/h3&gt;

&lt;p&gt;上面我们加了一个状态变量，可以用&lt;strong&gt;原子变量&lt;/strong&gt;来保证线程安全&lt;/p&gt;

&lt;p&gt;那如果是多个状态变量呢？此时就算用了&lt;strong&gt;原子变量&lt;/strong&gt;也不行了&lt;/p&gt;

&lt;p&gt;因为原子变量只是保证它内部是原子操作，但是当多个原子变量放到一起组合操作时，他们之间又存在&lt;strong&gt;竞态条件&lt;/strong&gt;了，就又不是原子操作了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;竞态条件：并发编程中，由于不恰当的执行时序而出现不正确的结果的情况，就是竞态条件（重复陈述ing，加深记忆）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class UnSafeDemo2 {
    static final AtomicInteger a = new AtomicInteger(0);
    static final AtomicInteger b = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {

        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;10000;j++){
                a.incrementAndGet();
                b.incrementAndGet();
                if(a.get()!=b.get()){
                    // 理想状态的话，不会运行到这里，因为a和b是一起自增的
                    // 但是大部分时候都是不正常的，因为a和b各自是原子操作，但是放到一起就不是原子操作了
                    System.out.println(1);
                }
            }
        }).start();

        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;10000;j++){
                a.incrementAndGet();
                b.incrementAndGet();
                if(a.get()!=b.get()){
                    // 理想状态的话，不会运行到这里，因为a和b是一起自增的
                    // 但是大部分时候都是不正常的，因为a和b各自是原子操作，但是放到一起就不是原子操作了
                    System.out.println(2);
                }
            }
        }).start();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面多次运行，会发现基本上每次都会打印1和2，就是因为这两个线程之间存在竞态条件&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那怎么解决呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上锁&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class UnSafeDemo2 {
    static final AtomicInteger a = new AtomicInteger(0);
    static final AtomicInteger b = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        // 单独创建一个对象，用来充当锁
        UnSafeDemo2 unSafeDemo2 = new UnSafeDemo2();
        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;10000;j++){
                // 这里加了锁
                synchronized (unSafeDemo2){
                    a.incrementAndGet();
                    b.incrementAndGet();
                    if(a.get()!=b.get()){
                        // 现在肯定是理想状态，不会运行到这里
                        System.out.println(1);
                    }
                }
            }
        }).start();

        new Thread(()-&amp;gt; {
            for(int j=0;j&amp;lt;10000;j++){
                // 这里加了锁
                synchronized (unSafeDemo2){
                    a.incrementAndGet();
                    b.incrementAndGet();
                    if(a.get()!=b.get()){
                        // 现在肯定是理想状态，不会运行到这里
                        System.out.println(2);
                    }
                }
            }
        }).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用到的锁为内置锁，还有很多其他锁，这里就不展开了（后面章节再介绍）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里要注意：同步代码必须上同一个锁才有用，比如上面的例子，两个线程都是上的unsafeDemo2这个锁&lt;/p&gt;

&lt;p&gt;官人们可以试一下，一个上unsafeDemo2锁，一个上Object锁，看会输出啥&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内置锁也叫监视器锁&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;好了，差不多先这些吧，后面还有太多东西了，慢慢来吧。&lt;/p&gt;

&lt;p&gt;毕竟我们都一大把年纪了，身体要紧呐。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;懒了懒了，直接贴图了（敲的脑仁疼），图做的不是很好，不过应该能看懂，望见谅哈&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/24/Cfq3iZHISznVyDK.png&quot; alt=&quot;线程的安全性&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考内容：&lt;/p&gt;



&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;

&lt;p&gt;原创不易，期待官人们的三连哟&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>057e75614fe1fbf3a0c59d310e1c2841</guid>
<title>腾讯技术大牛书单</title>
<link>https://toutiao.io/k/ykohxmm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660215266&amp;amp;idx=2&amp;amp;sn=54400f6300be9d601500e59d737997e2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;牛年行牛运！加入「码农周刊VIP会员」，一起牛起来！&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;牛年行牛运！加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1033&quot; data-ratio=&quot;20.502083333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavibfEGnGRskMJN9MClbWe4jTCTZLbRfMh3jFDJeqFyiaibfDQjeAoo7O00nYz04UzG2zmu0DBJdpkCqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d2f799ce9b69a2990394656df519e68</guid>
<title>了不起的 Chrome 浏览器：Chrome 90 将默认使用 HTTPS，Web 更安全了</title>
<link>https://toutiao.io/k/i3wcv9p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-lake-id=&quot;8265fc7384285e74a119fbd89c2bcb87&quot;&gt;4月13日正式发布的Chrome 90，带来了哪些有意思的新特性呢？&lt;/p&gt;&lt;p data-lake-id=&quot;9a926dd9864daabaca475e279df7711d&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;5e1a5d7f0cd7e248e9709a5f9a70a60c&quot;&gt;背景&lt;/h1&gt;&lt;p data-lake-id=&quot;a377561e9b7bb7e5373fcc85c65960d5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7e1bf659c3073fa9c03e4476af444fd2&quot;&gt;十多年来，Web技术突飞猛进，这其中，Chrome功劳是最大的，可以说没有之一。身处大前端这个领域，了解Chrome可以帮助我们理解整个行业的发展趋势。&lt;/p&gt;&lt;p data-lake-id=&quot;54fbae1c7f493215ee8a193e36d1a987&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d016ed967af3d4a1c1c962c0ea892caa&quot;&gt;其实，我一直都挺关注Chrome的，也写过一些关于Chrome的博客：&lt;/p&gt;&lt;p data-lake-id=&quot;0b2b18644633284503e664f7650612c0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2544a38145c502e5691e0829b4618fe0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4c87218277e776d37f13baccbbd62c8e&quot;&gt;写&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483736&amp;amp;idx=1&amp;amp;sn=48b87e3902fe8f6752aae18b9fe2a18d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Chrome 89&lt;/a&gt;博客的过程中，我意识到，关于Chrome的写作，我可以做得更加专注、更加深入、更加体系化一些。这样，一方面我可以提高专业能力和写作能力，另一方面也可以提高影响力。我也希望自己可以在&lt;span&gt;&lt;strong&gt;5年之内出版一本关于Chrome的书&lt;/strong&gt;&lt;/span&gt;，毕竟出书是每一个写作者最高的追求。&lt;/p&gt;&lt;p data-lake-id=&quot;a85aa5e7723e7004eaa53fcbea2b9967&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a08664611f6b8cb26c801cecbcde45b6&quot;&gt;因此，我将以&lt;span&gt;《了不起的Chrome浏览器》&lt;/span&gt;为题，对Chrome的每一个版本进行详细解读，同时也会深入去介绍Chrome各方面的细节，分享一些自己一些并不成熟的思考，欢迎大家关注&lt;strong&gt;寒雁Talk&lt;/strong&gt;公众号。&lt;/p&gt;&lt;p data-lake-id=&quot;52ae17415aa20b3c9010b9575935a835&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;6d3b3195ba707aec56ee09e4dc541306&quot;&gt;TL;TR&lt;/h1&gt;&lt;p data-lake-id=&quot;0b94e4c15614512924d30795fc545db1&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;591085acb9655c906405b079d4aa036a_ul_1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Chrome 90是哪天发布的？2021-04-13&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 90更新了多少个特性？23个，具体有哪些特性可以查看Chrome Platform Status&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 90将使用哪个版本的V8引擎？v9.0&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Chrome 90最大的亮点是什么？默认使用HTTPS协议&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，其实是非常小的改动，但是还是蛮重要的，HTTP裸奔的时代终于快要结束了，可惜这个特性还在灰度没有完全发布&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我感兴趣的新特性依次有哪些？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-lake-id=&quot;bb96aa652940da4b94d0d133cdaf26c8&quot; lake-indent=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;ul data-lake-id=&quot;5d7ffda105ac10b339cbe46783bc4c5c_ul_2&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;A safer default for navigation: HTTPS&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;AV1 Encoder&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WebXR Depth API和WebXR AR Lighting Estimation&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Feature: Block HTTP port 554&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;7b1041ce187fcd2c719dcbd238040902&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1ffdc765cd27e1e0ae2e6a857d28f0d4&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;120d0961f05c93a87ee85bbf809789d0&quot;&gt;详细解读&lt;/h1&gt;&lt;p data-lake-id=&quot;ad80a0e904d06e8586c840ca77b72e9a&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;75184b075fd836d17ef379c1f6c10a84&quot;&gt;&lt;span&gt;A safer default for navigation: HTTPS&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;6fca2e6e6f079570bb6f62482678bb6f&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2d502af43d9d7795229b8c7906fd7f49&quot;&gt;在浏览器地址栏输入URL，然后回车，之后发生了什么？这是一个非常经典的面试题。&lt;/p&gt;&lt;p data-lake-id=&quot;65249bd9a222556815bf089e5fd90cd9&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;05d0d36ef0b08f254c51cbee29623477&quot;&gt;Chrome 90开始，将会默认使用HTTPS协议打开URL，让这个面试题的答案变了一点点，喜欢背面试题的同学可以重点关注一下。。。&lt;/p&gt;&lt;p data-lake-id=&quot;51a878c6cbb1b13c77f80ba2088a1396&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;cb8cf6d55f574188890e6ad636a52370&quot;&gt;当我们输入example.com，Chrome 90之前的版本会默认访问http://example.com，服务端如果配置了重定向，则会重定向到https://example.com；而Chrome 90会默认访问https://example.com。&lt;/p&gt;&lt;p data-lake-id=&quot;f9ef0090ac5b0b5ba56378e29516e10a&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;61d714647292c49280d2831304c505df&quot;&gt;眼见为实，不妨简单测试一下（果然翻车了）。PS：测试之前需要清除浏览数据，否则Chrome第二次访问时会默认使用HTTPS。&lt;/p&gt;&lt;p data-lake-id=&quot;053afd2a8a7b8b73616afb34b319db9d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0bd2eda8cff81aa49c329cde303a5447&quot;&gt;当我使用Chrome 89打开kiwenlau.com时，会发现第一个请求使用的是HTTP协议（http://kiwenlau.com/），返回状态301，重定向到https://kiwenlau.com/，之后所有的请求使用的都是HTTPS协议：&lt;/p&gt;&lt;p data-lake-id=&quot;d86463024055a818cb3f4239408180f6&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d4598b4ee4b79327d9896618948ba7a2&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fpng%2F928098%2F1618133357494-959c0ebc-ab13-4257-88b6-f114c7ee1a86.png%22%2C%22originWidth%22%3A2158%2C%22originHeight%22%3A1046%2C%22name%22%3A%22chrome89-kiwenlau.com.png%22%2C%22size%22%3A250612%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A32.742554%2C%22y%22%3A16.280014%2C%22width%22%3A93.427162%2C%22height%22%3A22.490076000000002%2C%22text%22%3A%22General%22%7D%2C%7B%22x%22%3A48.77645%2C%22y%22%3A63.904083%2C%22width%22%3A459.78195%2C%22height%22%3A26.891312%2C%22text%22%3A%22RequestURL%3Ahttp%3A%2F%2Fkiwetu.com%22%7D%2C%7B%22x%22%3A47.946747%2C%22y%22%3A102.848976%2C%22width%22%3A256.74929299999997%2C%22height%22%3A27.096204%2C%22text%22%3A%22RequestMethod%3AGET%22%7D%2C%7B%22x%22%3A48.78751%2C%22y%22%3A146.07024%2C%22width%22%3A160.0626%2C%22height%22%3A25.79410999999999%2C%22text%22%3A%22StatusCode%3A%22%7D%2C%7B%22x%22%3A222.39268%2C%22y%22%3A146.67903%2C%22width%22%3A323.82795999999996%2C%22height%22%3A27.54577999999998%2C%22text%22%3A%22301MovedPermanentty%22%7D%2C%7B%22x%22%3A50.183968%2C%22y%22%3A188.02057%2C%22width%22%3A417.563632%2C%22height%22%3A25.13661000000002%2C%22text%22%3A%22RemoteAddress%3A127.0.0.1%3A9999%22%7D%2C%7B%22x%22%3A48.529343%2C%22y%22%3A224.29173%2C%22width%22%3A645.668597%2C%22height%22%3A33.47643000000002%2C%22text%22%3A%22ReferrerPolicy%3Astrict-originwhen-csorgi%22%7D%2C%7B%22x%22%3A299.28784%2C%22y%22%3A289.27695%2C%22width%22%3A141.41265999999996%2C%22height%22%3A24.429779999999994%2C%22text%22%3A%22viewsource%22%7D%2C%7B%22x%22%3A23.255478%2C%22y%22%3A289.47644%2C%22width%22%3A234.081402%2C%22height%22%3A23.640899999999988%2C%22text%22%3A%22ResponseHeaders%22%7D%2C%7B%22x%22%3A48.22475%2C%22y%22%3A336.26288%2C%22width%22%3A302.18044999999995%2C%22height%22%3A25.605680000000007%2C%22text%22%3A%22Connection%3Akeep-alive%22%7D%2C%7B%22x%22%3A50.460033%2C%22y%22%3A378.2163%2C%22width%22%3A244.42390699999999%2C%22height%22%3A25.44508000000002%2C%22text%22%3A%22Content-Length%3A194%22%7D%2C%7B%22x%22%3A49.484966%2C%22y%22%3A419.598%2C%22width%22%3A309.34749400000004%2C%22height%22%3A28.49340000000001%2C%22text%22%3A%22Content-Type%3Atext%2Fhtml%22%7D%2C%7B%22x%22%3A49.06015%2C%22y%22%3A459.09192%2C%22width%22%3A497.83669999999995%2C%22height%22%3A30.489280000000008%2C%22text%22%3A%22Date%3Asun%2C11Apr202109%3A22%3A11GMT%22%7D%2C%7B%22x%22%3A48.94674%2C%22y%22%3A504.25723%2C%22width%22%3A425.29142%2C%22height%22%3A27.800070000000062%2C%22text%22%3A%22Location%3Ahttps%3A%2F%2Fkiwentau.com%22%7D%2C%7B%22x%22%3A48.771023%2C%22y%22%3A545.1826%2C%22width%22%3A398.695807%2C%22height%22%3A28.787429999999972%2C%22text%22%3A%22Server%3Anginx%2F1.14.0(Ubuntu)%22%7D%2C%7B%22x%22%3A16.514977%2C%22y%22%3A601.7791%2C%22width%22%3A403.05600300000003%2C%22height%22%3A30.92579999999998%2C%22text%22%3A%22RequestHeadersviewsource%22%7D%2C%7B%22x%22%3A47.98635%2C%22y%22%3A650.542%2C%22width%22%3A2059.35695%2C%22height%22%3A29.57319999999993%2C%22text%22%3A%22%E5%95%8Am%22%7D%2C%7B%22x%22%3A48.63646%2C%22y%22%3A694.0612%2C%22width%22%3A415.33906%2C%22height%22%3A25.767400000000066%2C%22text%22%3A%22Accept-Encoding%3Agzipdeftate%22%7D%2C%7B%22x%22%3A48.682602%2C%22y%22%3A736.7683%2C%22width%22%3A735.830698%2C%22height%22%3A26.358530000000087%2C%22text%22%3A%22Accept-Language%3Azh-cnh7%22%7D%2C%7B%22x%22%3A50.77157%2C%22y%22%3A779.655%2C%22width%22%3A303.20703%2C%22height%22%3A24.615099999999984%2C%22text%22%3A%22Cache-Control%3Ano-cache%22%7D%2C%7B%22x%22%3A48.526752%2C%22y%22%3A820.9022%2C%22width%22%3A250.78064799999999%2C%22height%22%3A24.834429999999998%2C%22text%22%3A%22Host%3Akiwenlau.com%22%7D%2C%7B%22x%22%3A48.77791%2C%22y%22%3A865.11646%2C%22width%22%3A230.37703000000002%2C%22height%22%3A24.128109999999992%2C%22text%22%3A%22Pragma%3Ano-cache%22%7D%2C%7B%22x%22%3A48.504726%2C%22y%22%3A902.435%2C%22width%22%3A378.258854%2C%22height%22%3A29.8825700000001%2C%22text%22%3A%22Proxy-Connection%3Akeep-alive%22%7D%2C%7B%22x%22%3A48.76176%2C%22y%22%3A945.2903%2C%22width%22%3A364.42562000000004%2C%22height%22%3A32.12149999999997%2C%22text%22%3A%22Upgrade-lnsecure-Requests%3A1%22%7D%2C%7B%22x%22%3A49.744625%2C%22y%22%3A985.7128%2C%22width%22%3A1904.324675%2C%22height%22%3A35.27035000000001%2C%22text%22%3A%22%E5%BF%83%E5%9C%B0%E5%BF%83%2F.o%E4%BB%96%E5%9C%B0%E7%A1%AE%E5%8F%AB5..m.%E5%BF%83%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22General%20RequestURL%3Ahttp%3A%2F%2Fkiwetu.com%20RequestMethod%3AGET%20StatusCode%3A%20301MovedPermanentty%20RemoteAddress%3A127.0.0.1%3A9999%20ReferrerPolicy%3Astrict-originwhen-csorgi%20viewsource%20ResponseHeaders%20Connection%3Akeep-alive%20Content-Length%3A194%20Content-Type%3Atext%2Fhtml%20Date%3Asun%2C11Apr202109%3A22%3A11GMT%20Location%3Ahttps%3A%2F%2Fkiwentau.com%20Server%3Anginx%2F1.14.0(Ubuntu)%20RequestHeadersviewsource%20%E5%95%8Am%20Accept-Encoding%3Agzipdeftate%20Accept-Language%3Azh-cnh7%20Cache-Control%3Ano-cache%20Host%3Akiwenlau.com%20Pragma%3Ano-cache%20Proxy-Connection%3Akeep-alive%20Upgrade-lnsecure-Requests%3A1%20%E5%BF%83%E5%9C%B0%E5%BF%83%2F.o%E4%BB%96%E5%9C%B0%E7%A1%AE%E5%8F%AB5..m.%E5%BF%83%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A540%2C%22height%22%3A262%2C%22id%22%3A%22bMghS%22%7D&quot;&gt;&lt;img data-height=&quot;262px&quot; data-ratio=&quot;0.4846666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hibZ30plEggwZSeLPSer9j5kNmjP9wHGND5JPKCQm29y48hZua6W2HJMnRrBJGRZicaoGBquzR4lcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;chrome89-kiwenlau.com.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;100069463e5f54361e9960fba4b97855&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;40c8c30521372199c83385fd294d5362&quot;&gt;当我使用Chrome 90打开kiwenlau.com时，会发现&lt;strong&gt;&lt;span&gt;第一个请求居然使用的依然还是是HTTP协议&lt;/span&gt;&lt;/strong&gt;（http://kiwenlau.com/），而不是HTTPS协议，这就很尴尬了：&lt;/p&gt;&lt;p data-lake-id=&quot;04d71f5b14df0bd81387faa2499a9e61&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;25c0ea05739aff7f8768d3b8d1eadae7&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fpng%2F928098%2F1619253085467-23a99489-ad80-4c9a-8fe3-19d81bf0b038.png%22%2C%22originWidth%22%3A2112%2C%22originHeight%22%3A1042%2C%22name%22%3A%22chrome90-kiwenlau.com.png%22%2C%22size%22%3A252003%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A24.508596%2C%22y%22%3A13.134404%2C%22width%22%3A97.111124%2C%22height%22%3A23.951564%2C%22text%22%3A%22General%22%7D%2C%7B%22x%22%3A46.881084%2C%22y%22%3A61.30569%2C%22width%22%3A462.072116%2C%22height%22%3A28.304060000000007%2C%22text%22%3A%22RequestURL%3Ahttp%3A%2F%2Fkiweu.com%22%7D%2C%7B%22x%22%3A46.359695%2C%22y%22%3A99.014084%2C%22width%22%3A254.88118500000002%2C%22height%22%3A29.586345999999992%2C%22text%22%3A%22RequestMethod%3AGET%22%7D%2C%7B%22x%22%3A229.41191%2C%22y%22%3A141.45438%2C%22width%22%3A313.47149%2C%22height%22%3A29.207580000000007%2C%22text%22%3A%22301MovedPermanently%22%7D%2C%7B%22x%22%3A45.75136%2C%22y%22%3A143.35019%2C%22width%22%3A155.92344%2C%22height%22%3A26.9144%2C%22text%22%3A%22StatusCode%3A%22%7D%2C%7B%22x%22%3A48.382347%2C%22y%22%3A185.38295%2C%22width%22%3A416.872323%2C%22height%22%3A26.166020000000003%2C%22text%22%3A%22RemoteAddress%3A127.0.0.1%3A9999%22%7D%2C%7B%22x%22%3A46.859848%2C%22y%22%3A226.0714%2C%22width%22%3A644.5959519999999%2C%22height%22%3A29.68871999999999%2C%22text%22%3A%22ReferrerPolicy%3Astrict-originhen-cs-orgi%22%7D%2C%7B%22x%22%3A20.121874%2C%22y%22%3A286.18558%2C%22width%22%3A241.42289600000004%2C%22height%22%3A27.57299999999998%2C%22text%22%3A%22ResponseHeaders%22%7D%2C%7B%22x%22%3A299.49872%2C%22y%22%3A286.6892%2C%22width%22%3A142.41378000000003%2C%22height%22%3A27.176519999999982%2C%22text%22%3A%22Viewsource%22%7D%2C%7B%22x%22%3A45.583477%2C%22y%22%3A333.1808%2C%22width%22%3A304.705643%2C%22height%22%3A28.177660000000003%2C%22text%22%3A%22Connection%3Akeep-altive%22%7D%2C%7B%22x%22%3A46.672432%2C%22y%22%3A374.6035%2C%22width%22%3A250.81090799999998%2C%22height%22%3A28.746019999999987%2C%22text%22%3A%22Content-Length%3A194%22%7D%2C%7B%22x%22%3A47.252396%2C%22y%22%3A417.14218%2C%22width%22%3A312.29814400000004%2C%22height%22%3A29.773619999999994%2C%22text%22%3A%22Content-Type%3Atext%2Fhtml%22%7D%2C%7B%22x%22%3A49.03634%2C%22y%22%3A458.56696%2C%22width%22%3A497.04380000000003%2C%22height%22%3A34.31099999999998%2C%22text%22%3A%22Date%3ASatApr202108%3A28%3A04GMT%22%7D%2C%7B%22x%22%3A49.23199%2C%22y%22%3A502.0204%2C%22width%22%3A423.61869%2C%22height%22%3A25.92050000000006%2C%22text%22%3A%22Location%3Ahttps%3A%2F%2Fkiwentau.com%22%7D%2C%7B%22x%22%3A47.944225%2C%22y%22%3A542.6044%2C%22width%22%3A398.690635%2C%22height%22%3A28.334699999999998%2C%22text%22%3A%22Servernginx%2F1.14.(Ubuntu)%22%7D%2C%7B%22x%22%3A14.5905%2C%22y%22%3A601.85034%2C%22width%22%3A226.33205%2C%22height%22%3A26.644229999999993%2C%22text%22%3A%22RequestHeaders%22%7D%2C%7B%22x%22%3A277.78247%2C%22y%22%3A603.3829%2C%22width%22%3A143.288%2C%22height%22%3A23.657140000000027%2C%22text%22%3A%22Viewsource%22%7D%2C%7B%22x%22%3A46.23818%2C%22y%22%3A647.2392%2C%22width%22%3A2054.70712%2C%22height%22%3A30.07684000000006%2C%22text%22%3A%22%E6%89%B9iemutmm%22%7D%2C%7B%22x%22%3A46.51092%2C%22y%22%3A692.4849%2C%22width%22%3A411.81468%2C%22height%22%3A28.003399999999942%2C%22text%22%3A%22Accept-Encoding%3Agzipdefate%22%7D%2C%7B%22x%22%3A46.294186%2C%22y%22%3A730.9143%2C%22width%22%3A736.132114%2C%22height%22%3A32.79639999999995%2C%22text%22%3A%22Accept-Language%3Azh-cn%2Chq7%22%7D%2C%7B%22x%22%3A47.933285%2C%22y%22%3A777.92096%2C%22width%22%3A306.593635%2C%22height%22%3A24.691889999999944%2C%22text%22%3A%22Cache-Control%3Ano-cache%22%7D%2C%7B%22x%22%3A48.52207%2C%22y%22%3A818.9932%2C%22width%22%3A252.16906%2C%22height%22%3A24.75392999999997%2C%22text%22%3A%22Host%3Akiwentau.com%22%7D%2C%7B%22x%22%3A47.872177%2C%22y%22%3A863.34875%2C%22width%22%3A226.59102299999998%2C%22height%22%3A22.137249999999995%2C%22text%22%3A%22Pragma%3Ano-cache%22%7D%2C%7B%22x%22%3A47.128174%2C%22y%22%3A903.10187%2C%22width%22%3A376.185946%2C%22height%22%3A25.37657999999999%2C%22text%22%3A%22Proxy-Connection%3Akeep-alive%22%7D%2C%7B%22x%22%3A44.533684%2C%22y%22%3A944.3745%2C%22width%22%3A369.50471600000003%2C%22height%22%3A26.029199999999946%2C%22text%22%3A%22Upgrade-lnsecure-Requests%3A1%22%7D%2C%7B%22x%22%3A46.24375%2C%22y%22%3A985.7505%2C%22width%22%3A1889.65185%2C%22height%22%3A27.169200000000046%2C%22text%22%3A%22tmejt%3A40momx%E5%8A%9Bm..%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22General%20RequestURL%3Ahttp%3A%2F%2Fkiweu.com%20RequestMethod%3AGET%20301MovedPermanently%20StatusCode%3A%20RemoteAddress%3A127.0.0.1%3A9999%20ReferrerPolicy%3Astrict-originhen-cs-orgi%20ResponseHeaders%20Viewsource%20Connection%3Akeep-altive%20Content-Length%3A194%20Content-Type%3Atext%2Fhtml%20Date%3ASatApr202108%3A28%3A04GMT%20Location%3Ahttps%3A%2F%2Fkiwentau.com%20Servernginx%2F1.14.(Ubuntu)%20RequestHeaders%20Viewsource%20%E6%89%B9iemutmm%20Accept-Encoding%3Agzipdefate%20Accept-Language%3Azh-cn%2Chq7%20Cache-Control%3Ano-cache%20Host%3Akiwentau.com%20Pragma%3Ano-cache%20Proxy-Connection%3Akeep-alive%20Upgrade-lnsecure-Requests%3A1%20tmejt%3A40momx%E5%8A%9Bm..%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A528%2C%22height%22%3A261%2C%22id%22%3A%22wTTLs%22%7D&quot;&gt;&lt;img data-height=&quot;261px&quot; data-ratio=&quot;0.49333333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hibZ30plEggwZSeLPSer9j5TwoOHdLKwWfU6XZ9DEHxlKbYsIcmhpfptkfFp8ORJ7rAwAUPZeNFqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;chrome90-kiwenlau.com.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9a156e925fbba252218facb1fc8b18e5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;74e41671abe15dc78510fd21ead87328&quot;&gt;我本来以为这是BUG，于是提了一个issue：&lt;/p&gt;&lt;p data-lake-id=&quot;29ed15fe81c9b1fb76e4fa6ba934cf28&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;71a6e26688b8fedbd1497321f24ffc9e&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f271f88d8090230a8bfaec1cc41d0210&quot;&gt;根据回复，Chrome团队还在对这个特性进行灰度，如果希望开启这个特性，可以到&lt;span&gt;chrome://flags把#omnibox-default-typed-navigations-to-https设为&quot;Enabled&quot;：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7c8fe6f6de04074a58f0096a90b8ec3b&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f9c0ccce4b9527a93a865beb5fb4f1b0&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fpng%2F928098%2F1619253565558-c976457a-05fe-42a9-b490-e4ce64124882.png%22%2C%22originWidth%22%3A1474%2C%22originHeight%22%3A316%2C%22name%22%3A%22omnibox-default-typed-navigations-to-https.png%22%2C%22size%22%3A106792%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A52.09723%2C%22y%22%3A24.391947%2C%22width%22%3A716.51097%2C%22height%22%3A32.059388999999996%2C%22text%22%3A%22Omnibox-UseHTTPSasthedefaultprotocolfornavigations%22%7D%2C%7B%22x%22%3A54.4118%2C%22y%22%3A66.04734%2C%22width%22%3A999.9040000000001%2C%22height%22%3A30.038129999999995%2C%22text%22%3A%22UseHTTPSasthedefaultprotocolwhentheuetypesaURLwhoutaprotocolinthe%22%7D%2C%7B%22x%22%3A55.382397%2C%22y%22%3A104.954636%2C%22width%22%3A1040.959803%2C%22height%22%3A26.249743999999993%2C%22text%22%3A%22omboxsuchasxamplecom.Pentylo%22%7D%2C%7B%22x%22%3A55.39589%2C%22y%22%3A137.63405%2C%22width%22%3A1013.3346099999999%2C%22height%22%3A30.249769999999984%2C%22text%22%3A%22Whenthisfeatureisenablediwinvgatohtp%2Fxample.com%22%7D%2C%7B%22x%22%3A1235.654%2C%22y%22%3A140.06026%2C%22width%22%3A100.47810000000004%2C%22height%22%3A24.897199999999998%2C%22text%22%3A%22Enabled%22%7D%2C%7B%22x%22%3A56.38351%2C%22y%22%3A176.03831%2C%22width%22%3A1041.4122900000002%2C%22height%22%3A25.667419999999993%2C%22text%22%3A%22available.homdiih%22%7D%2C%7B%22x%22%3A54.74789%2C%22y%22%3A210.65643%2C%22width%22%3A867.56091%2C%22height%22%3A26.611469999999997%2C%22text%22%3A%22willfallbacktotheHTTPURL.-MacWindowLiuChmid%22%7D%2C%7B%22x%22%3A55.1292%2C%22y%22%3A253.01755%2C%22width%22%3A518.5401%2C%22height%22%3A28.563470000000024%2C%22text%22%3A%22%23omnibox-default-typed-navigations-to-http%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22Omnibox-UseHTTPSasthedefaultprotocolfornavigations%20UseHTTPSasthedefaultprotocolwhentheuetypesaURLwhoutaprotocolinthe%20omboxsuchasxamplecom.Pentylo%20Whenthisfeatureisenablediwinvgatohtp%2Fxample.com%20Enabled%20available.homdiih%20willfallbacktotheHTTPURL.-MacWindowLiuChmid%20%23omnibox-default-typed-navigations-to-http%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A369%2C%22height%22%3A79%2C%22id%22%3A%22hQxig%22%7D&quot;&gt;&lt;img data-height=&quot;79px&quot; data-ratio=&quot;0.21438263229308005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hibZ30plEggwZSeLPSer9j5nYGrMXya1WjJeicrZ0LNIe6vLic2aibDD4Z97ecu3aWc1qlwaETFicM88w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1474&quot; title=&quot;omnibox-default-typed-navigations-to-https.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;692c0aca7ad39a58d1c5621794dde821&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2919de5693ea6c604ce43bd0dc9fef3a&quot;&gt;严格来讲，只有第一次访问kiwenlau.com的第一个请求使用了HTTP协议，貌似也没什么大不了的。不过，要知道&lt;strong&gt;&lt;span&gt;HTTP协议本身是明文传输的&lt;/span&gt;&lt;/strong&gt;（其实HTTP/2也没有要求非得加密，只是所有的浏览器都要求HTTP/2必须加密，这样的话，只有HTTPS才能升级HTTP/2），这意味着网络中每一个节点都是能查看并且篡改HTTP的通信内容，这也是页面劫持的基本原理，想想是不是有点后怕，尤其对于那些喜欢访问奇奇怪怪网站的同学来说。&lt;/p&gt;&lt;p data-lake-id=&quot;16727164a8aa3f06ecf8f573dbc94321&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;66253aa807eff4b3ed63d5f4e371f5dd&quot;&gt;如果使用Charles抓包来对比一下，可以发现，对于HTTP请求，Contents是明文：&lt;/p&gt;&lt;p data-lake-id=&quot;a5f8e713ade4f0e818871499c5bc5e9a&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;212c58da8010a0a5a93d7260196b8b99&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fpng%2F928098%2F1619254445308-bd4cf4c4-cb6a-4dd3-9266-600bb03f0b6b.png%22%2C%22originWidth%22%3A2642%2C%22originHeight%22%3A816%2C%22name%22%3A%22http-charles.png%22%2C%22size%22%3A197012%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A1144.1323%2C%22y%22%3A18.431784%2C%22width%22%3A78.56310000000008%2C%22height%22%3A28.153833%2C%22text%22%3A%22Chart%22%7D%2C%7B%22x%22%3A34.312458%2C%22y%22%3A19.154966%2C%22width%22%3A124.895242%2C%22height%22%3A28.919889999999995%2C%22text%22%3A%22Structure%22%7D%2C%7B%22x%22%3A204.98636%2C%22y%22%3A19.364006%2C%22width%22%3A129.97794%2C%22height%22%3A26.579536%2C%22text%22%3A%22Sequence%22%7D%2C%7B%22x%22%3A1277.4142%2C%22y%22%3A19.871834%2C%22width%22%3A78.89340000000016%2C%22height%22%3A25.252670000000002%2C%22text%22%3A%22Notes%22%7D%2C%7B%22x%22%3A638.3909%2C%22y%22%3A20.528416%2C%22width%22%3A115.55780000000004%2C%22height%22%3A25.046694000000002%2C%22text%22%3A%22Overview%22%7D%2C%7B%22x%22%3A978.3897%2C%22y%22%3A21.473793%2C%22width%22%3A122.8569%2C%22height%22%3A25.200806999999998%2C%22text%22%3A%22summary%22%7D%2C%7B%22x%22%3A807.756%2C%22y%22%3A22.105919%2C%22width%22%3A114.8596%2C%22height%22%3A24.988113%2C%22text%22%3A%22Contents%22%7D%2C%7B%22x%22%3A967.583%2C%22y%22%3A63.899185%2C%22width%22%3A179.2501000000001%2C%22height%22%3A23.726405%2C%22text%22%3A%22GET%2FHTTP%2F1.1%22%7D%2C%7B%22x%22%3A76.84287%2C%22y%22%3A64.31756%2C%22width%22%3A232.08418999999998%2C%22height%22%3A26.424130000000005%2C%22text%22%3A%22http%3A%2F%2Fkiwenlau.com%22%7D%2C%7B%22x%22%3A896.2307%2C%22y%22%3A104.44507%2C%22width%22%3A235.23850000000004%2C%22height%22%3A25.12456999999999%2C%22text%22%3A%22Hostkiwenlau.com%22%7D%2C%7B%22x%22%3A78.806114%2C%22y%22%3A140.83418%2C%22width%22%3A242.24643600000002%2C%22height%22%3A26.198759999999993%2C%22text%22%3A%22https%3A%2F%2Fkiwenlau.com%22%7D%2C%7B%22x%22%3A860.56195%2C%22y%22%3A141.29059%2C%22width%22%3A226.06935%2C%22height%22%3A26.527709999999985%2C%22text%22%3A%22Pragmano-cache%22%7D%2C%7B%22x%22%3A776.25305%2C%22y%22%3A178.1643%2C%22width%22%3A304.21415%2C%22height%22%3A27.62870000000001%2C%22text%22%3A%22Cache-Controlno-cache%22%7D%2C%7B%22x%22%3A607.4874%2C%22y%22%3A212.93158%2C%22width%22%3A384.2839%2C%22height%22%3A32.25778%2C%22text%22%3A%22Upgrade-lnsecure-Requests1%22%7D%2C%7B%22x%22%3A808.4683%2C%22y%22%3A253.11363%2C%22width%22%3A1630.2666%2C%22height%22%3A30.801969999999983%2C%22text%22%3A%22UoABmtistiM5ol%22%7D%2C%7B%22x%22%3A858.912%2C%22y%22%3A288.5166%2C%22width%22%3A1731.1422%2C%22height%22%3A30.40405000000004%2C%22text%22%3A%22Ag%40nbmtpzzdtuwhimt.mbomm%22%7D%2C%7B%22x%22%3A746.4285%2C%22y%22%3A329.07367%2C%22width%22%3A384.7667000000001%2C%22height%22%3A30.22577000000001%2C%22text%22%3A%22Accept-Encodinggzip%2Cdelate%22%7D%2C%7B%22x%22%3A738.24066%2C%22y%22%3A364.48972%2C%22width%22%3A696.72844%2C%22height%22%3A33.99810000000002%2C%22text%22%3A%22Accept-Languagezh-cn%2Czhq-.%22%7D%2C%7B%22x%22%3A811.8965%2C%22y%22%3A405.0862%2C%22width%22%3A295.88430000000005%2C%22height%22%3A28.89179999999999%2C%22text%22%3A%22ConnectionKeep-alive%22%7D%2C%7B%22x%22%3A795.3586%2C%22y%22%3A497.60883%2C%22width%22%3A57.46320000000003%2C%22height%22%3A25.72086999999999%2C%22text%22%3A%22Raw%22%7D%2C%7B%22x%22%3A639.2345%2C%22y%22%3A499.57956%2C%22width%22%3A102.41234999999995%2C%22height%22%3A23.948639999999955%2C%22text%22%3A%22Headers%22%7D%2C%7B%22x%22%3A688.92725%2C%22y%22%3A544.9476%2C%22width%22%3A85.23374999999999%2C%22height%22%3A24.629549999999995%2C%22text%22%3A%22chtmls%22%7D%2C%7B%22x%22%3A643.11017%2C%22y%22%3A576.44214%2C%22width%22%3A22.138029999999958%2C%22height%22%3A22.138029999999958%2C%22text%22%3A%22%E4%B8%80%22%7D%2C%7B%22x%22%3A685.76135%2C%22y%22%3A577.5488%2C%22width%22%3A653.5191500000001%2C%22height%22%3A28.327699999999936%2C%22text%22%3A%22sheadxtitle301MovedPermanentlytitlead%22%7D%2C%7B%22x%22%3A688.2183%2C%22y%22%3A609.9134%2C%22width%22%3A310.405%2C%22height%22%3A27.0933%2C%22text%22%3A%22%3Cbodybgcolor-%5C%22white%5C%22%3E%22%7D%2C%7B%22x%22%3A689.8592%2C%22y%22%3A640.40295%2C%22width%22%3A649.6788%2C%22height%22%3A28.303049999999985%2C%22text%22%3A%22ccentersh13301MovedPermanently%2F13x%2Fcenter%22%7D%2C%7B%22x%22%3A689.68713%2C%22y%22%3A673.04803%2C%22width%22%3A562.23777%2C%22height%22%3A25.929019999999923%2C%22text%22%3A%22chpccentersnginx%2F.14.0Ubuntu)s%2Fcenter%22%7D%2C%7B%22x%22%3A691.1521%2C%22y%22%3A705.9789%2C%22width%22%3A97.72649999999999%2C%22height%22%3A26.27696000000003%2C%22text%22%3A%22%3C%2Fbody%3E%22%7D%2C%7B%22x%22%3A689.6734%2C%22y%22%3A735.74677%2C%22width%22%3A92.65314000000001%2C%22height%22%3A26.789730000000077%2C%22text%22%3A%22%2Fhtml%3E%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22Chart%20Structure%20Sequence%20Notes%20Overview%20summary%20Contents%20GET%2FHTTP%2F1.1%20http%3A%2F%2Fkiwenlau.com%20Hostkiwenlau.com%20https%3A%2F%2Fkiwenlau.com%20Pragmano-cache%20Cache-Controlno-cache%20Upgrade-lnsecure-Requests1%20UoABmtistiM5ol%20Ag%40nbmtpzzdtuwhimt.mbomm%20Accept-Encodinggzip%2Cdelate%20Accept-Languagezh-cn%2Czhq-.%20ConnectionKeep-alive%20Raw%20Headers%20chtmls%20%E4%B8%80%20sheadxtitle301MovedPermanentlytitlead%20%3Cbodybgcolor-%5C%22white%5C%22%3E%20ccentersh13301MovedPermanently%2F13x%2Fcenter%20chpccentersnginx%2F.14.0Ubuntu)s%2Fcenter%20%3C%2Fbody%3E%20%2Fhtml%3E%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A661%2C%22height%22%3A204%2C%22id%22%3A%22YDdRR%22%7D&quot;&gt;&lt;img data-height=&quot;204px&quot; data-ratio=&quot;0.30866666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hibZ30plEggwZSeLPSer9j5KWuedgPbtsvsptdsN9MD751qBraypiabQWLqfXAA88Ml6F8qvCUnHnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;http-charles.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9efd13ceddf4c9814b64b8ce9f428938&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f2a486e78a6369220f2c04d264e313b1&quot;&gt;对于HTTPS请求，Content是加密后的，看起来是乱码：&lt;/p&gt;&lt;p data-lake-id=&quot;f2a486e78a6369220f2c04d264e313b1&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;fba053cee8813d4f3fc34571852c2a01&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fpng%2F928098%2F1619254558057-416fd914-722a-4869-8329-11912ab1c002.png%22%2C%22originWidth%22%3A2880%2C%22originHeight%22%3A1222%2C%22name%22%3A%22https-charles.png%22%2C%22size%22%3A504252%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A33.347385%2C%22y%22%3A17.213451%2C%22width%22%3A123.00053499999999%2C%22height%22%3A28.197014000000003%2C%22text%22%3A%22Structure%22%7D%2C%7B%22x%22%3A805.439%2C%22y%22%3A17.472399%2C%22width%22%3A124.38516000000004%2C%22height%22%3A26.213291%2C%22text%22%3A%22Contents%22%7D%2C%7B%22x%22%3A1275.6909%2C%22y%22%3A17.94851%2C%22width%22%3A78.59269999999992%2C%22height%22%3A26.574607%2C%22text%22%3A%22Notes%22%7D%2C%7B%22x%22%3A638.59607%2C%22y%22%3A18.102533%2C%22width%22%3A113.91967999999997%2C%22height%22%3A25.208093999999996%2C%22text%22%3A%22Overview%22%7D%2C%7B%22x%22%3A1152.4893%2C%22y%22%3A18.24194%2C%22width%22%3A68.74970000000008%2C%22height%22%3A24.994934%2C%22text%22%3A%22Chart%22%7D%2C%7B%22x%22%3A976.8417%2C%22y%22%3A18.322851%2C%22width%22%3A120.63580000000002%2C%22height%22%3A26.895209%2C%22text%22%3A%22Summary%22%7D%2C%7B%22x%22%3A209.11052%2C%22y%22%3A19.492105%2C%22width%22%3A124.20704999999998%2C%22height%22%3A23.932275%2C%22text%22%3A%22Sequence%22%7D%2C%7B%22x%22%3A651.27826%2C%22y%22%3A56.86476%2C%22width%22%3A185.32713999999999%2C%22height%22%3A35.85325000000001%2C%22text%22%3A%221LUE%22%7D%2C%7B%22x%22%3A79.31052%2C%22y%22%3A63.72793%2C%22width%22%3A227.07455%2C%22height%22%3A27.035070000000005%2C%22text%22%3A%22http%3A%2F%2Fkiwenlau.com%22%7D%2C%7B%22x%22%3A805.13385%2C%22y%22%3A62.84806%2C%22width%22%3A115.18657999999994%2C%22height%22%3A26.83186%2C%22text%22%3A%22E%2CwHOL-%22%7D%2C%7B%22x%22%3A645.7084%2C%22y%22%3A90.592026%2C%22width%22%3A175.2256%2C%22height%22%3A34.24467399999999%2C%22text%22%3A%222Aracx6%2CB%3B%22%7D%2C%7B%22x%22%3A2022.144%2C%22y%22%3A112.27203%2C%22width%22%3A356.307%2C%22height%22%3A51.362750000000005%2C%22text%22%3A%22Kiwenlau.comNyM%22%7D%2C%7B%22x%22%3A1360.9467%2C%22y%22%3A122.22247%2C%22width%22%3A609.5849000000001%2C%22height%22%3A31.1939%2C%22text%22%3A%22A%2BAIAAOLOIAAL5T%22%7D%2C%7B%22x%22%3A643.4486%2C%22y%22%3A123.720505%2C%22width%22%3A28.969499999999925%2C%22height%22%3A28.969499999999925%2C%22text%22%3A%22%22%7D%2C%7B%22x%22%3A974.16425%2C%22y%22%3A123.887726%2C%22width%22%3A146.37564999999995%2C%22height%22%3A30.995053999999996%2C%22text%22%3A%22N*Z1LEAY%22%7D%2C%7B%22x%22%3A685.46326%2C%22y%22%3A125.35781%2C%22width%22%3A265.62264000000005%2C%22height%22%3A31.623670000000004%2C%22text%22%3A%22EE%25DPpE-eS-6f%5C%22%22%7D%2C%7B%22x%22%3A1145.4213%2C%22y%22%3A123.260506%2C%22width%22%3A182.0761%2C%22height%22%3A35.990183999999985%2C%22text%22%3A%22yaA%3ESkezz%22%7D%2C%7B%22x%22%3A61.333534%2C%22y%22%3A141.55415%2C%22width%22%3A258.748646%2C%22height%22%3A22.163820000000015%2C%22text%22%3A%22https%3A%2Fkiwenlau.com%22%7D%2C%7B%22x%22%3A1125.3892%2C%22y%22%3A179.83636%2C%22width%22%3A302.2228%2C%22height%22%3A42.253119999999996%2C%22text%22%3A%22h2http%2F.1T%22%7D%2C%7B%22x%22%3A115.67799%2C%22y%22%3A179.92967%2C%22width%22%3A141.49334000000002%2C%22height%22%3A22.430930000000018%2C%22text%22%3A%22cuinknownz%22%7D%2C%7B%22x%22%3A977.9288%2C%22y%22%3A183.86209%2C%22width%22%3A131.40960000000007%2C%22height%22%3A70.33354%2C%22text%22%3A%22%E5%93%81%22%7D%2C%7B%22x%22%3A1153.6216%2C%22y%22%3A218.7279%2C%22width%22%3A551.7246%2C%22height%22%3A31.009500000000003%2C%22text%22%3A%22CHJX9C%2FOAENOUD%26AT%22%7D%2C%7B%22x%22%3A981.49384%2C%22y%22%3A249.16103%2C%22width%22%3A78.14996000000008%2C%22height%22%3A35.06836999999999%2C%22text%22%3A%22ID%22%7D%2C%7B%22x%22%3A685.1925%2C%22y%22%3A258.63153%2C%22width%22%3A67.4724%2C%22height%22%3A21.22980000000001%2C%22text%22%3A%22zz%22%7D%2C%7B%22x%22%3A921.0174%2C%22y%22%3A285.92752%2C%22width%22%3A83.7972400000001%2C%22height%22%3A24.961209999999994%2C%22text%22%3A%22T%2FID--6%22%7D%2C%7B%22x%22%3A687.71796%2C%22y%22%3A288.3092%2C%22width%22%3A220.13488000000007%2C%22height%22%3A25.876770000000022%2C%22text%22%3A%22YeaTESyh%23-(4c%22%7D%2C%7B%22x%22%3A1042.9165%2C%22y%22%3A310.7323%2C%22width%22%3A739.6737%2C%22height%22%3A39.666049999999984%2C%22text%22%3A%22ITIATFEAIRORVESBYOLT%22%7D%2C%7B%22x%22%3A1826.8837%2C%22y%22%3A313.69504%2C%22width%22%3A532.7576999999999%2C%22height%22%3A36.813319999999976%2C%22text%22%3A%223%3A*r6yLoiHAh%26yEiCAED%2Bfyd%26PAck%22%7D%2C%7B%22x%22%3A645.75006%2C%22y%22%3A317.25%2C%22width%22%3A27%2C%22height%22%3A27%2C%22text%22%3A%228%22%7D%2C%7B%22x%22%3A685.2349%2C%22y%22%3A318.70233%2C%22width%22%3A260.2042%2C%22height%22%3A30.226969999999994%2C%22text%22%3A%22VUDYA3%E6%9C%88%22%7D%2C%7B%22x%22%3A809.27545%2C%22y%22%3A348.53116%2C%22width%22%3A1025.31585%2C%22height%22%3A32.80423999999999%2C%22text%22%3A%22ESLAAAIWk%22%7D%2C%7B%22x%22%3A684.37103%2C%22y%22%3A350.26706%2C%22width%22%3A179.19501000000002%2C%22height%22%3A29.29210999999998%2C%22text%22%3A%22CVIKMFAEs%22%7D%2C%7B%22x%22%3A632.2361%2C%22y%22%3A372.3383%2C%22width%22%3A41.82725000000005%2C%22height%22%3A41.82725000000005%2C%22text%22%3A%228FY%22%7D%2C%7B%22x%22%3A684.69824%2C%22y%22%3A380.29483%2C%22width%22%3A263.34646%2C%22height%22%3A32.791049999999984%2C%22text%22%3A%22%EF%BF%A5QQuFEIaRAaMa%22%7D%2C%7B%22x%22%3A845.98816%2C%22y%22%3A381.7966%2C%22width%22%3A1818.02864%2C%22height%22%3A33.69149999999996%2C%22text%22%3A%22%E5%8A%A0%E9%97%B4%25w..%22%7D%2C%7B%22x%22%3A701.98346%2C%22y%22%3A407.73642%2C%22width%22%3A2048.86754%2C%22height%22%3A42.72165000000001%2C%22text%22%3A%220%E8%B6%85W%E5%BF%83%E4%BB%A5%E5%92%8C%E5%8F%8A8oobomq%22%7D%2C%7B%22x%22%3A795.595%2C%22y%22%3A445.817%2C%22width%22%3A2086.0215%2C%22height%22%3A30.99345999999997%2C%22text%22%3A%22%E7%9C%9F%E9%83%BDw%E5%BF%83%E5%BF%83%E6%98%AF..g%E7%A7%98%E8%80%8C%E5%9C%B0.%22%7D%2C%7B%22x%22%3A750.0431%2C%22y%22%3A445.4975%2C%22width%22%3A114.05894999999998%2C%22height%22%3A32.41976999999997%2C%22text%22%3A%22A-is.kdo%22%7D%2C%7B%22x%22%3A679.7016%2C%22y%22%3A447.75%2C%22width%22%3A55.71659999999997%2C%22height%22%3A26.635199999999998%2C%22text%22%3A%226rv%22%7D%2C%7B%22x%22%3A800.2949%2C%22y%22%3A493.99933%2C%22width%22%3A56.05776000000003%2C%22height%22%3A26.0462%2C%22text%22%3A%22Text%22%7D%2C%7B%22x%22%3A1013.3922%2C%22y%22%3A495.2949%2C%22width%22%3A58.9683%2C%22height%22%3A26.088030000000003%2C%22text%22%3A%22Raw%22%7D%2C%7B%22x%22%3A640.37164%2C%22y%22%3A495.96332%2C%22width%22%3A105.12776000000008%2C%22height%22%3A25.732680000000016%2C%22text%22%3A%22Headers%22%7D%2C%7B%22x%22%3A910.5147%2C%22y%22%3A497.25003%2C%22width%22%3A54.9534000000001%2C%22height%22%3A23.704440000000034%2C%22text%22%3A%22Hex%22%7D%2C%7B%22x%22%3A720.43726%2C%22y%22%3A531.5819%2C%22width%22%3A1256.6742399999998%2C%22height%22%3A44.31714999999997%2C%22text%22%3A%22NTIUMOA%2BOWKE2APREAOTTTTETh%22%7D%2C%7B%22x%22%3A2242.6982%2C%22y%22%3A535.6689%2C%22width%22%3A87.76620000000003%2C%22height%22%3A43.73185999999998%2C%22text%22%3A%22%5C%22%22%7D%2C%7B%22x%22%3A2432.2551%2C%22y%22%3A537.2355%2C%22width%22%3A144.12490000000025%2C%22height%22%3A45.23557000000005%2C%22text%22%3A%22%3A%5C%22o%2C0%2C%22%7D%2C%7B%22x%22%3A2640.9253%2C%22y%22%3A536.69037%2C%22width%22%3A237.85620000000017%2C%22height%22%3A36.77572999999995%2C%22text%22%3A%22AAEI46PflyR%2Beow%22%7D%2C%7B%22x%22%3A647.07715%2C%22y%22%3A541.0794%2C%22width%22%3A40.53570000000002%2C%22height%22%3A40.53570000000002%2C%22text%22%3A%22NUUWFY%22%7D%2C%7B%22x%22%3A859.698%2C%22y%22%3A576.19196%2C%22width%22%3A50.13819999999998%2C%22height%22%3A28.55233999999996%2C%22text%22%3A%22HT%22%7D%2C%7B%22x%22%3A850.06915%2C%22y%22%3A600.8352%2C%22width%22%3A41.035049999999956%2C%22height%22%3A32.42930000000001%2C%22text%22%3A%22u%22%7D%2C%7B%22x%22%3A717.7637%2C%22y%22%3A603.924%2C%22width%22%3A109.80106%2C%22height%22%3A32.38746000000003%2C%22text%22%3A%220210%22%7D%2C%7B%22x%22%3A910.50854%2C%22y%22%3A604.85986%2C%22width%22%3A122.24145999999996%2C%22height%22%3A29.640139999999974%2C%22text%22%3A%22US10U%22%7D%2C%7B%22x%22%3A1054.6489%2C%22y%22%3A671.41895%2C%22width%22%3A58.22460000000001%2C%22height%22%3A23.715649999999982%2C%22text%22%3A%22R30%22%7D%2C%7B%22x%22%3A709.06165%2C%22y%22%3A672.53204%2C%22width%22%3A190.07115%2C%22height%22%3A26.525159999999914%2C%22text%22%3A%22Let&#x27;sencrypt10%22%7D%2C%7B%22x%22%3A705.0548%2C%22y%22%3A702.1401%2C%22width%22%3A224.95979999999997%2C%22height%22%3A28.83660000000009%2C%22text%22%3A%22210421140404Z%22%7D%2C%7B%22x%22%3A705.3744%2C%22y%22%3A732.8328%2C%22width%22%3A563.5805999999999%2C%22height%22%3A30.576900000000023%2C%22text%22%3A%22210720140404Z010UKiwenlau.como.%5C%22%22%7D%2C%7B%22x%22%3A832.18634%2C%22y%22%3A767.83246%2C%22width%22%3A95.94676000000004%2C%22height%22%3A24.13549999999998%2C%22text%22%3A%22%E4%B8%ADH%E8%8A%82%22%7D%2C%7B%22x%22%3A708.105%2C%22y%22%3A784.4059%2C%22width%22%3A48.177799999999934%2C%22height%22%3A48.177799999999934%2C%22text%22%3A%22%22%7D%2C%7B%22x%22%3A750.82806%2C%22y%22%3A787.5156%2C%22width%22%3A55.2826399999999%2C%22height%22%3A37.841330000000085%2C%22text%22%3A%22c%22%7D%2C%7B%22x%22%3A730.20026%2C%22y%22%3A825.03394%2C%22width%22%3A1009.96844%2C%22height%22%3A34.58305999999993%2C%22text%22%3A%226AABBOUA000B222INAEKUCOYD%22%7D%2C%7B%22x%22%3A728.946%2C%22y%22%3A853.7981%2C%22width%22%3A1924.2685999999999%2C%22height%22%3A44.70170000000007%2C%22text%22%3A%22%E5%86%A0%E7%94%B5u%E4%B8%AD%E5%BF%83%E6%B5%99*e%22%7D%2C%7B%22x%22%3A1347.0138%2C%22y%22%3A888.90894%2C%22width%22%3A1329.0584999999999%2C%22height%22%3A40.10996%2C%22text%22%3A%22EG0UQU0%2BoUQoumluxWU%22%7D%2C%7B%22x%22%3A718.5258%2C%22y%22%3A893.4619%2C%22width%22%3A592.2164999999999%2C%22height%22%3A30.55269999999996%2C%22text%22%3A%22GEOCOA5CYXATHEADAEAJRPOYe%22%7D%2C%7B%22x%22%3A2558.7527%2C%22y%22%3A896.5066%2C%22width%22%3A210.76929999999993%2C%22height%22%3A29.29449999999997%2C%22text%22%3A%22*XVEP%40a%22%7D%2C%7B%22x%22%3A722.7566%2C%22y%22%3A912.5756%2C%22width%22%3A1062.4634%2C%22height%22%3A49.15535999999997%2C%22text%22%3A%22AREOU%2BLOGOLOTHTP.OLNGRROHTP3ILNRRIOUO%22%7D%2C%7B%22x%22%3A1772.3193%2C%22y%22%3A918.32526%2C%22width%22%3A996.5095999999999%2C%22height%22%3A54.60247000000004%2C%22text%22%3A%22%2Ckiwenlau.comoluEocogo7%2Be%22%7D%2C%7B%22x%22%3A700.5245%2C%22y%22%3A952.31506%2C%22width%22%3A485.7043000000001%2C%22height%22%3A39.50213999999994%2C%22text%22%3A%22%2Boyooov-Vors.%5C%22%22%7D%2C%7B%22x%22%3A2151.2463%2C%22y%22%3A984.1399%2C%22width%22%3A527.2537000000002%2C%22height%22%3A37.97119999999995%2C%22text%22%3A%22ZALSAA4vDOYUHKAAERGY%2BAX%22%7D%2C%7B%22x%22%3A698.4656%2C%22y%22%3A986.01917%2C%22width%22%3A546.5898%2C%22height%22%3A34.45312999999999%2C%22text%22%3A%22NUMNIOAONXMCATXO8TGOE%22%7D%2C%7B%22x%22%3A1264.0814%2C%22y%22%3A984.4583%2C%22width%22%3A742.723%2C%22height%22%3A37.351%2C%22text%22%3A%22eroc7a.%2FaBAluspomiolpfwEz-en*b1199-E%5C%22oX%22%7D%2C%7B%22x%22%3A705.5807%2C%22y%22%3A1022.0233%2C%22width%22%3A540.8499999999999%2C%22height%22%3A31.674700000000144%2C%22text%22%3A%22%E5%B0%8FH~xIxowsTGoECaYm%5C%22%25%22%7D%2C%7B%22x%22%3A1266.3918%2C%22y%22%3A1025.6072%2C%22width%22%3A189.45129999999995%2C%22height%22%3A29.223400000000083%2C%22text%22%3A%22M-x*%E7%94%9FgW%22%7D%2C%7B%22x%22%3A703.20325%2C%22y%22%3A1051.0891%2C%22width%22%3A596.81555%2C%22height%22%3A38.87660000000005%2C%22text%22%3A%22eouucaPite%23RuiAflouarja780P2o%22%7D%2C%7B%22x%22%3A794.0672%2C%22y%22%3A1088.6992%2C%22width%22%3A442.674%2C%22height%22%3A25.893499999999904%2C%22text%22%3A%22%E4%B8%ADH%E4%B8%AD%2B%22%7D%2C%7B%22x%22%3A712.4512%2C%22y%22%3A1112.4913%2C%22width%22%3A480.40959999999995%2C%22height%22%3A42.548500000000104%2C%22text%22%3A%225gOxLOBMDRPuAe*Eah%22%7D%2C%7B%22x%22%3A1147.6904%2C%22y%22%3A1114.3049%2C%22width%22%3A985.5994000000001%2C%22height%22%3A35.42709999999988%2C%22text%22%3A%22hK%3AANB%E6%A5%BCvHEY%25zMTMW%22%7D%2C%7B%22x%22%3A705.329%2C%22y%22%3A1150.1211%2C%22width%22%3A171.30924000000005%2C%22height%22%3A29.29139999999984%2C%22text%22%3A%22woze%5B2tud%22%7D%2C%7B%22x%22%3A1150.2921%2C%22y%22%3A1180.8748%2C%22width%22%3A58.21630000000005%2C%22height%22%3A31.055599999999913%2C%22text%22%3A%22sY)%22%7D%2C%7B%22x%22%3A904.9959%2C%22y%22%3A1183.0858%2C%22width%22%3A182.99760000000003%2C%22height%22%3A28.59719999999993%2C%22text%22%3A%22OPqoeSoDw%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22Structure%20Contents%20Notes%20Overview%20Chart%20Summary%20Sequence%201LUE%20http%3A%2F%2Fkiwenlau.com%20E%2CwHOL-%202Aracx6%2CB%3B%20Kiwenlau.comNyM%20A%2BAIAAOLOIAAL5T%20%20N*Z1LEAY%20EE%25DPpE-eS-6f%5C%22%20yaA%3ESkezz%20https%3A%2Fkiwenlau.com%20h2http%2F.1T%20cuinknownz%20%E5%93%81%20CHJX9C%2FOAENOUD%26AT%20ID%20zz%20T%2FID--6%20YeaTESyh%23-(4c%20ITIATFEAIRORVESBYOLT%203%3A*r6yLoiHAh%26yEiCAED%2Bfyd%26PAck%208%20VUDYA3%E6%9C%88%20ESLAAAIWk%20CVIKMFAEs%208FY%20%EF%BF%A5QQuFEIaRAaMa%20%E5%8A%A0%E9%97%B4%25w..%200%E8%B6%85W%E5%BF%83%E4%BB%A5%E5%92%8C%E5%8F%8A8oobomq%20%E7%9C%9F%E9%83%BDw%E5%BF%83%E5%BF%83%E6%98%AF..g%E7%A7%98%E8%80%8C%E5%9C%B0.%20A-is.kdo%206rv%20Text%20Raw%20Headers%20Hex%20NTIUMOA%2BOWKE2APREAOTTTTETh%20%5C%22%20%3A%5C%22o%2C0%2C%20AAEI46PflyR%2Beow%20NUUWFY%20HT%20u%200210%20US10U%20R30%20Let&#x27;sencrypt10%20210421140404Z%20210720140404Z010UKiwenlau.como.%5C%22%20%E4%B8%ADH%E8%8A%82%20%20c%206AABBOUA000B222INAEKUCOYD%20%E5%86%A0%E7%94%B5u%E4%B8%AD%E5%BF%83%E6%B5%99*e%20EG0UQU0%2BoUQoumluxWU%20GEOCOA5CYXATHEADAEAJRPOYe%20*XVEP%40a%20AREOU%2BLOGOLOTHTP.OLNGRROHTP3ILNRRIOUO%20%2Ckiwenlau.comoluEocogo7%2Be%20%2Boyooov-Vors.%5C%22%20ZALSAA4vDOYUHKAAERGY%2BAX%20NUMNIOAONXMCATXO8TGOE%20eroc7a.%2FaBAluspomiolpfwEz-en*b1199-E%5C%22oX%20%E5%B0%8FH~xIxowsTGoECaYm%5C%22%25%20M-x*%E7%94%9FgW%20eouucaPite%23RuiAflouarja780P2o%20%E4%B8%ADH%E4%B8%AD%2B%205gOxLOBMDRPuAe*Eah%20hK%3AANB%E6%A5%BCvHEY%25zMTMW%20woze%5B2tud%20sY)%20OPqoeSoDw%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A720%2C%22height%22%3A306%2C%22id%22%3A%22itIbU%22%7D&quot;&gt;&lt;img data-height=&quot;306px&quot; data-ratio=&quot;0.424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hibZ30plEggwZSeLPSer9j5atQSU6n8mmNicQibjKfaZjEUNhicsUqElKCr4oEp3ic9vBHoQeH9AyNY7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;https-charles.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;6b827fe21b3766ef7e7ce83f5fbc4e5c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;540bb1a212b69f202e5dd159cf4bc17a&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;859f87e0c68fc3dac680edf7e1ac8ceb&quot;&gt;当然，对于支持HTTPS的站点，省去了HTTP到HTTPS重定向这一步，也是可以提高访问性能的，不过这个问题倒是其次的，毕竟只有一个HTTP请求，而且很多网站本来就很慢了，不在乎这几十毫秒。。。&lt;/p&gt;&lt;p data-lake-id=&quot;dcc8bc27e670b72ab63902998fa27b6e&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;6697b5f79537042e51b688980a39fffd&quot;&gt;Chrome一直在推进HTTPS协议在业界的应用，关于这一点，我之后写一篇博客详述（&lt;strong&gt;&lt;span&gt;挖坑&lt;/span&gt;&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-lake-id=&quot;dae44ca5e933602797069baf7be3f835&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;13a774bb71916baccc330dfba2b18fb6&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;44f7c2ab57410a75828694e57c1bef1e&quot;&gt;&lt;span&gt;AV1 Encoder&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;7277f699617692895fa4344119f3134e&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;11a0302c819f95c7bc6408127d2af3d0&quot;&gt;AV1的全称为AOMedia Video 1，是一个开源、免费的视频编码格式，编码效率更高。根据Netflix、Facebook的数据，AV1相对于VP9，可以将压缩效率提升20% ~ 30%左右。爱奇艺也在去年启用了AV1格式，可以节省20%的带宽。Youtube最新定制的视频芯片（VCU，Video Coding Unit）Argos也支持了AV1。&lt;/p&gt;&lt;p data-lake-id=&quot;11a0302c819f95c7bc6408127d2af3d0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;11a0302c819f95c7bc6408127d2af3d0&quot;&gt;对于视频类应用来说，昂贵宽带费用一直是非常沉重的负担，这也是一些知名长视频网站一直无法盈利的关键原因之一（另外一个关键原因是内容成本）。根据爱奇艺最新的2020年财报，其2020年净亏损70亿人民币，其中带宽开支高达24亿人民币，占了亏损的34.3%。对于视频类应用来说，使用AV1这种更高效的视频编码格式，有利于减少宽带费用。&lt;/p&gt;&lt;p data-lake-id=&quot;9ccd363a792db4122126cf7312568d96&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e1657426c17a42517af00d1ca29293d0&quot;&gt;WebRTC的全称为Web Real-Time Communication，用于在Web应用中实现实时的视频和语音通信。其实WebRTC已经是个已经有10年历史的技术了，疫情的爆发促进了视频会议需求的爆发，使得WebRTC变得更加重要了。&lt;/p&gt;&lt;p data-lake-id=&quot;ec3c4630ddda5ca75df8a94486ba909c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7b4ac5adcbb5dce2d5d30686a6654110&quot;&gt;Chrome 90支持了AV1 Encoder，用于优化WebRTC视频通信：提升压缩效率，减少带宽使用；支持30kbps以及更低码率的视频，服务低带宽的用户；优化了屏幕共享效率。&lt;/p&gt;&lt;p data-lake-id=&quot;e109ff5547623736ac3a4243cffc21cd&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7cbd94b480096c349f2370cd837bc99d&quot;&gt;疫情在全球范围内爆发已经1年多了，这极大地增强了用户对于视频会议、直播的需求，AV1 Encoder这样的技术进步也可以帮助大家渡过现在的难关，这也是技术最大的意义。&lt;/p&gt;&lt;p data-lake-id=&quot;a8a0061d76ff85430c0316bea2fb837f&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;66e788be8f59c2cbdde1ede10a184872&quot;&gt;AV1是由AOMedia（Alliance for Open Media）开发的，旨在取代Google开发的VP9，同时与需要收取专利费的H.263展开竞争。AOMedia其实也不是外人，Google是其核心成员，且AV1也是由Google主导开发的。作为程序员，不得不服&lt;strong&gt;&lt;span&gt;Google对于技术进步推进是全方位的&lt;/span&gt;&lt;/strong&gt;，哪里都能看到它的身影。关于Google是如何推进视频编码格式技术的进步，这又是另外一个话题了，我之后写一篇博客详述（&lt;strong&gt;&lt;span&gt;再次挖坑&lt;/span&gt;&lt;/strong&gt;）。&lt;/p&gt;&lt;p data-lake-id=&quot;caddbaedbe9a16628cab5d5c56c582c3&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c20d72b4d1420214048730f9b07535a9&quot;&gt;对于使用WebRTC开发Web视频会议应用的同学，不妨试用一下AV1 Encoder，也可以给大家分享一下到底效果怎么样。&lt;/p&gt;&lt;p data-lake-id=&quot;b95e16ae59b3ad1bfb1df0b9036057e1&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;a121b18fce9cd4180d76b97c39cae94d&quot;&gt;&lt;span&gt;WebXR Depth API和WebXR AR Lighting Estimation&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;3db631685cc155cf81c032b47becbca4&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3ceab1853f6c1fb3f8713a9de15d78d7&quot;&gt;WebXR Depth API和WebXR AR Lighting Estimation都是WebXR相关的特性更新，WebXR Depth API可以用来获取用户的设备与现实环境中物体的距离，WebXR AR Lighting Estimation可以用来获取环境的光线情况。&lt;/p&gt;&lt;p data-lake-id=&quot;2ea49c7b394666b853077c46000167f2&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2a3ebcf61a7f28c65da8e862ad49a03f&quot;&gt;估计绝大部分人都没用过WebXR，所以还是先了解一下WebXR是啥...&lt;/p&gt;&lt;p data-lake-id=&quot;0c7b06f62cc72824cf26c26990fca1a6&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c1bb5950904f577a32a478d14686e85e&quot;&gt;WebXR其实就是在Web上开发AR（Augmented Reality）和VR（Virtual Reality）应用的API，AR和VR都是以字母R结尾，所以就取了个XR的名字。&lt;/p&gt;&lt;p data-lake-id=&quot;42d9798407e2b59a25697b04b9dd397d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;84e73c2266e236425998b04a9c5038e1&quot;&gt;在WebXR Experiments，有一些WebXR的示例，可以让大家实际感受一下WebXR能干嘛。&lt;/p&gt;&lt;p data-lake-id=&quot;4de322c575475a9f70034bbad76c84f2&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;fb275d72a941b2d3d05f93fdf52e1b2b&quot;&gt;比如，Sodar就可以用来测量2m社交距离：&lt;/p&gt;&lt;p data-lake-id=&quot;fb275d72a941b2d3d05f93fdf52e1b2b&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d5921780af5eb2dd7ae20b304f903fa8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fgif%2F928098%2F1619262000639-addf8c4a-15f8-4fd8-88fa-f79b5a6140f3.gif%22%2C%22originWidth%22%3A600%2C%22originHeight%22%3A338%2C%22name%22%3A%22sodar.gif%22%2C%22size%22%3A3833230%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A600%2C%22height%22%3A338%2C%22id%22%3A%22acQUv%22%7D&quot;&gt;&lt;img data-height=&quot;338px&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/UnKibSlmUib8hibZ30plEggwZSeLPSer9j58UwzBQiahCT0fe0gdZ0fXic83apx0icO193Uw9Q3XRxTZ88d0jP9iaFKBQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; title=&quot;sodar.gif&quot; data-ratio=&quot;0.5633333333333334&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1b658c6000f61a7c7b8f0125b88f4d27&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d88766b5f17bc4999698926f5467b429&quot;&gt;还有一个没有正式发布的示例Picturescape，看起来还挺有意思的，不过没太看懂具体是做什么的，等正式发布之后可以再看看：&lt;/p&gt;&lt;p data-lake-id=&quot;d88766b5f17bc4999698926f5467b429&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/UnKibSlmUib8hibZ30plEggwZSeLPSer9j5T039EtULYSibreQCDibia4iaKLQYdicNF9tg66ibxh2Q8EvyqdEIgsIPEnoA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7eedccaac30eb448a7b8c36a3c4a45ea&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7eedccaac30eb448a7b8c36a3c4a45ea&quot;&gt;&lt;span&gt;‍&lt;/span&gt;从WebXR的示例来看，目前WebXR所实现的应用还比较简单，毕竟VR和AR技术本身目前的应用也比较简单粗糙。我最感兴趣的还是其在游戏领域的应用，《&lt;strong&gt;&lt;span&gt;头号玩家》中的游戏体验什么时候可以实现呢？&lt;/span&gt;&lt;/strong&gt;拭目以待！&lt;/p&gt;&lt;p data-lake-id=&quot;ff6a5c117da2fe307965d233627f95ca&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;7ad9bc5e8663f68dc86281527503dbd8&quot;&gt;&lt;span&gt;Feature: Block HTTP port 554&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;164cbbda584bcf21f021e508fb222d26&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;164cbbda584bcf21f021e508fb222d26&quot;&gt;Chrome 90屏蔽了554端口，这是为了缓解NAT Slipstream 2.0攻击。注意，这里用的词是缓解而不是解决，Chrome没法从根本上阻止NAT Slipstream 2.0攻击。&lt;/p&gt;&lt;p data-lake-id=&quot;164cbbda584bcf21f021e508fb222d26&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;164cbbda584bcf21f021e508fb222d26&quot;&gt;NAT Slipstream是去年10月底由Samy Kamkar发现的一种&lt;strong&gt;&lt;span&gt;非常巧妙也非常危险的攻击方式&lt;/span&gt;&lt;/strong&gt;，后来他又与Armis研究员Ben Seri和Gregory Vishnipolsky发现了新一版的NAT Slipstream 2.0的攻击方式。&lt;/p&gt;&lt;p data-lake-id=&quot;u6b71da84&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u6d3bc926&quot;&gt;简单来说，受害者只需要访问黑客的网站，该网站嵌入了黑客的JavaScript脚本，黑客就可以绕开受害者所在的局域网的防火墙，访问受害者所在的局域网中的任意TCP/UDP服务。&lt;/p&gt;&lt;p data-lake-id=&quot;uacc791e3&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u46bc55b8&quot;&gt;大家不妨通过NAT Slipstreaming 2.0 - Enterprise Network Bypass这个视频感受一下整个攻击流程是怎样的。&lt;/p&gt;&lt;p data-lake-id=&quot;u46bc55b8&quot;&gt;&lt;/p&gt;&lt;p/&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u144a4eb7&quot;&gt;受害者位于局域网中，局域网中连接的设备有受害者的智能手机、打印机、网络摄像头、打印机以及路由器，理论上局域网中的设备都是受到防火墙的保护的。而黑客位于Internet中，理论上是无法绕过防火墙直接访问局域网中的设备，比如打印机和网络摄像头。&lt;/p&gt;&lt;p data-lake-id=&quot;u7a855939&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;uf8b6b038&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fpng%2F928098%2F1619330765596-f03c9a7a-127c-458c-8bcb-9f2b152acf41.png%22%2C%22originWidth%22%3A2150%2C%22originHeight%22%3A668%2C%22name%22%3A%22nat-splipstreaming1.png%22%2C%22size%22%3A374782%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A83.91493%2C%22y%22%3A262.16818%2C%22width%22%3A284.70921999999996%2C%22height%22%3A30.951359999999966%2C%22text%22%3A%22Smartphone(Victim)%22%7D%2C%7B%22x%22%3A486.93854%2C%22y%22%3A263.14154%2C%22width%22%3A259.08216000000004%2C%22height%22%3A29.351560000000006%2C%22text%22%3A%22Wi-FiAccessPoint%22%7D%2C%7B%22x%22%3A935.67535%2C%22y%22%3A391.11923%2C%22width%22%3A292.89345000000003%2C%22height%22%3A28.802249999999958%2C%22text%22%3A%22FortinetFirewaIl%2FNAT%22%7D%2C%7B%22x%22%3A1674.7577%2C%22y%22%3A406.78485%2C%22width%22%3A118.24529999999982%2C%22height%22%3A28.014009999999985%2C%22text%22%3A%22Attacker%22%7D%2C%7B%22x%22%3A122.62505%2C%22y%22%3A513.23175%2C%22width%22%3A208.81227%2C%22height%22%3A30.220649999999978%2C%22text%22%3A%22AxisIPCamera%22%7D%2C%7B%22x%22%3A561.2459%2C%22y%22%3A521.1354%2C%22width%22%3A97.79750000000001%2C%22height%22%3A29.117160000000013%2C%22text%22%3A%22Printer%22%7D%2C%7B%22x%22%3A1676.8002%2C%22y%22%3A563.8665%2C%22width%22%3A112.58940000000007%2C%22height%22%3A26.854400000000055%2C%22text%22%3A%22lnternet%22%7D%2C%7B%22x%22%3A394.54932%2C%22y%22%3A614.76575%2C%22width%22%3A62.81295%2C%22height%22%3A28.95245%2C%22text%22%3A%22LAN%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22Smartphone(Victim)%20Wi-FiAccessPoint%20FortinetFirewaIl%2FNAT%20Attacker%20AxisIPCamera%20Printer%20lnternet%20LAN%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A538%2C%22height%22%3A167%2C%22id%22%3A%22u64fa840a%22%7D&quot;&gt;&lt;img data-height=&quot;167px&quot; data-ratio=&quot;0.31066666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UnKibSlmUib8hibZ30plEggwZSeLPSer9j54zA0RgwArrdmoh8xSicMtSJ7qnFjHiaAEYeMmNucUgHPkysCGo0NyCpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot; title=&quot;nat-splipstreaming1.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u981c2961&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ue95e7dba&quot;&gt;受害者使用智能手机访问了黑客所提供的链接，攻击者成功绕过防火墙，获取打印机和网络摄像头的访问地址，远程给打印机发送打印任务，并且通过默认的账户密码远程访问网络摄像头。&lt;/p&gt;&lt;p data-lake-id=&quot;u0ea36bf7&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u3c1357ca&quot;&gt;如果你家的摄像头可以被黑客查看，是不是很可怕，赶紧把默认密码改了吧！&lt;/p&gt;&lt;p data-lake-id=&quot;u1f7b5bb0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u3637f749&quot;&gt;当然，如果打印机和网络摄像头都设置了比较严格的密码的话，攻击者也是没法访问它们的。所以，局域网中的设备也是必须做好安全防范的。但是这并不是重点，重点是攻击者绕过了防火墙，这又是怎么做到的呢？&lt;/p&gt;&lt;p data-lake-id=&quot;u3b0ff376&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u57c6f4b7&quot;&gt;Samy Kamkar的原文很长，所涉及的技术细节非常多，其实最关键的就是以下这段JavaScript代码：&lt;/p&gt;&lt;p data-lake-id=&quot;u57c6f4b7&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; sipmsg = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;REGISTER sip:samy.pl;transport=TCP SIP/2.0\r\n&#x27;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Contact: &amp;lt;sip:samy@192.168.0.109:1234;transport=TCP&amp;gt;\r\n\r\n&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; iframe = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;iframe&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iframe.name = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;iframe&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iframe.style.display = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;none&#x27;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; form = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;form&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;form.setAttribute(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;target&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;iframe&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;form.setAttribute(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;method&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;POST&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;form.setAttribute(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;action&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;http://samy.pl:5060&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;form.setAttribute(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;enctype&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;multipart/form-data&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; textarea = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;textarea&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;textarea.setAttribute(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;name&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;textname&#x27;&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;textarea.innerHTML = sipmsg&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;form.appendChild(textarea)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.body.appendChild(iframe)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.body.appendChild(form)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;form.submit()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;u406425dc&quot;&gt;这段代码，其实就是发送了一个特殊定制的POST请求，而这个POST请求由于体积过大，会被分成多个TCP包。从代码中可知，这些TCP包所请求的端口是5060，这恰好是SIP协议所使用的端口。黑客可以通过定制POST请求的大小来控制TCP包，让其中一个TCP包恰好会被NAT设备理解为SIP REGISTER包，NAT设备的ALG（&lt;span&gt;Application Level Gateway&lt;/span&gt;）看到这个包，则会为黑客打开一个公网端口，并且转发到黑客所需要访问的内网TCP服务，代码中为192.168.0.109:1234。这样，黑客就可以通过NAT上的公网端口来访问内网服务192.168.0.109:1234。NAT设备则傻傻地帮黑客转发请求。&lt;/p&gt;&lt;p data-lake-id=&quot;u80a7ff1e&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u026a3a90&quot;&gt;这种攻击方式非常有创意，涉及的技术细节非常多，我之后写一篇博客详细解释一下（&lt;strong&gt;&lt;span&gt;又挖了一个坑&lt;/span&gt;&lt;/strong&gt;）。当然，这种攻击方式也非常危险，Samy Kamkar真是个天才，还好他是白帽黑客。&lt;/p&gt;&lt;p data-lake-id=&quot;u77c989e5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u13ed5f4d&quot;&gt;Chrome屏蔽端口这种做法其实也是治标不治本，黑客确实没办法给所屏蔽端口发送请求了，但是如果受害者不更新浏览器的话，还是会被攻击。要从根本上解决这个问题，还是需要NAT设备尤其是ALG以及防火墙来想办法。&lt;/p&gt;&lt;p data-lake-id=&quot;ufe420423&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u55e9f221&quot;&gt;物联网时代，家里联网的设备越来越多了，作为用户，我们还是需要做好保护措施：&lt;/p&gt;&lt;p data-lake-id=&quot;u455df922&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u1b71ca18&quot;&gt;当然，你也可以选择断网，哈哈:(&lt;/p&gt;&lt;p data-lake-id=&quot;3bb96324edad4bbb10b26683039ec759&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;71f63d41edf08a9051e26065e496c632&quot;&gt;总结&lt;/h1&gt;&lt;p data-lake-id=&quot;2ce2b954690178927217f1c735c82ecb&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8a596798819fb9d7c06d96edc0e0fafd&quot;&gt;在我看来，Chrome 90最重要的更新，是默认使用HTTPS协议，其实是非常小的改动，但是还是蛮重要的。可惜这个特性还在灰度发布过程中，并没有真正发布。HTTP裸奔的时代终于快要结束了，站在现在的角度去看过去，一想到以前Web居然是基于明文传输协议的，感觉那是一个刀耕火种的时代。当然，那也是一个伟大的时代，&lt;strong&gt;&lt;span&gt;Web的诞生本身就是一件改变人类文明的事情，我们都是幸运地站在巨人的肩膀上。&lt;/span&gt;&lt;/strong&gt;如果未来量子计算机把RSA给破解了，现在的HTTPS也是裸奔。&lt;/p&gt;&lt;p data-lake-id=&quot;746b0d77ec2388bb0820857e13759900&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f10e145b674520d8d496fd418dab7e30&quot;&gt;另外，本文还介绍了AV1、WebXR以及NAT Slipstreaming相关的特性，我把重点放在了背景知识的介绍，这是因为这些特性本身对绝大多数开发者都用不到，并没有什么价值，且比较枯燥无味，不过这些关于这些特性的背景知识还是需要了解一下的，可以帮助我们更加全面的理解大前端的各个知识点以及应用场景。《了不起的Chrome浏览器》之后的博客，我也会延续这种写作风格，希望大家喜欢。&lt;/p&gt;&lt;p data-lake-id=&quot;4a999cc00fa9e9fa4ef1809c601ca078&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;34d29ed0a09b1f7d1dba62d38a1f8545&quot;&gt;我在文章后面列了非常多的参考资料，这是我读研的时候写论文养成的习惯，只要我有参考过的资料，我都会列出来，这个其实主要是为了方便我自己以后查阅，其次是分享给感兴趣的读者。其中，有一些高质量的内容我把字体加粗了，不妨重点关注一下。&lt;/p&gt;&lt;p data-lake-id=&quot;07fea80518b6061e3d39d9745e057112&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;999bed49cc6eea0e8cd989bea3693d3b&quot;&gt;在写作的过程中，我也发现了3个比较有意思的话题，是可以深入展开的，第1点是关于Chrome对于HTTPS技术推广所做的事情，第2点是关于Google推动视频编码技术进步所做的贡献，第3点是NAT Slipstreaming，后面我也会分别写博客介绍，欢迎关注。&lt;/p&gt;&lt;p data-lake-id=&quot;3d8a47020b6cf0eda1effa13fe0b4151&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;063bba3d834e10c7cf5ff1f81f57dd27&quot;&gt;欢迎关注&lt;strong&gt;寒雁Talk&lt;/strong&gt;公众号，关注&lt;strong&gt;《了不起的Chrome浏览器》&lt;/strong&gt;系列博客，与我一起见证大前端的星辰大海！&lt;/p&gt;&lt;p data-lake-id=&quot;56a8093c9a6ff284182636fa7286c412&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;88658dee1804ca7657c6809d40fde9c0&quot;&gt;参考资料&lt;/h1&gt;&lt;ul data-lake-id=&quot;79afe271c4fee93ffe6f4a0c9c138610_ul_6&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Chrome 90 Beta: AV1 Encoder for WebRTC, New Origin Trials, and More&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A safer default for navigation: HTTPS&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;New in Chrome 90: Overflow Clip, Permissions Policy, the Declarative Shadow DOM, and more!&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Chrome 90 will use HTTPS (port 443) by Default - Let us discuss&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483736&amp;amp;idx=1&amp;amp;sn=48b87e3902fe8f6752aae18b9fe2a18d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;了不起的Chrome浏览器：Chrome 89开启Web应用的物联网时代&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Real time communication with WebRTC&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Get Started with WebRTC&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Google supercharges YouTube with a custom video chip&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Netflix Now Streaming AV1 on Android&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Facebook turns on AV1 technology to speed up video streaming&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;爱奇艺成为国内首家启用AV1格式的视频网站 同画质播放节省超20%流量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NzAxMDI4MA==&amp;amp;mid=2649705087&amp;amp;idx=2&amp;amp;sn=a6fb710879e3c9d52251b0b53eceacb9&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;新一代AV1编码格式，H.265的最大对手来了&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WebXR Experiments&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Experiment with AR and VR made for the web&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NAT Slipstreaming v2.0&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NAT Slipstreaming v2.0: New Attack Variant Can Expose All Internal Network Devices to The Internet&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;NAT Slipstreaming 2.0 - Enterprise Network Bypass&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;A New Attack Allows Access to any TCP/UDP service on a Machine behind NAT - NAT Slipstreaming&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Understanding Nat Slipstreaming&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 浏览器将屏蔽 554 端口以阻止 NAT Slipstreaming 攻击&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 屏蔽多个 TCP 端口，以阻止 NAT Slipstreaming 攻击&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;ua43bf672&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;DO8cv&quot;&gt;招聘&lt;/h1&gt;&lt;p data-lake-id=&quot;u53195345&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u80563e66&quot;&gt;&lt;span data-mce-style=&quot;font-size: 15px&quot;&gt;阿里巴巴业务平台事业部长期招聘P6及以上前端大佬，参与建设最前沿的阿里前端生态系统，推动行业技术发展，内推地址：&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 15px&quot;&gt;hanyan.lk@alibaba-inc.com&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d70c59f6f7c939e93fb5a4e28a84b577&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;u4be379a4&quot;&gt;&lt;span data-mce-style=&quot;font-size: 15px&quot;&gt;欢迎大家关注我的微信公众号&lt;/span&gt;&lt;strong&gt;&lt;span data-mce-style=&quot;font-size: 11px&quot;&gt;寒雁Talk&lt;/span&gt;&lt;/strong&gt;&lt;span data-mce-style=&quot;font-size: 15px&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ueba95c63&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fwebp%2F928098%2F1619341927214-9586185e-dfc0-4bf1-a2b8-222f7059c1bd.webp%22%2C%22originWidth%22%3A1080%2C%22originHeight%22%3A394%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A1080%2C%22height%22%3A394%2C%22id%22%3A%22uafa74778%22%7D&quot;&gt;&lt;img data-height=&quot;394px&quot; data-ratio=&quot;0.3648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/UnKibSlmUib8hibZ30plEggwZSeLPSer9j5VvVHm5vMa3bibXLQKILyPxEOrPjpnORl8QNNz4OiaFib0O6HtSTw4JicsQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot; title=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>536459c3d0aa2a5fb7093239a8dc048b</guid>
<title>偷偷学会让程序主动监测死锁，然后惊艳所有人</title>
<link>https://toutiao.io/k/6wnrpgg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;SpringBoot2.x引入了Micrometer,重点支持了tag,而tag是prometheus和influxdb这类新兴监控存储相关中间件天然特性.&lt;/p&gt;&lt;p&gt;而本文主要讲述检测程序中是否有死锁发生,这部分使用的是dropwizard-metrics的metrics-healthchecks来实现的.&lt;/p&gt;&lt;h1&gt;&lt;span&gt;死锁检测配置&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;首先引入对应的包依赖,maven:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.dropwizard.metrics&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;metrics-healthchecks&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;4.1.19&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.dropwizard.metrics&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;metrics-jvm&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;4.1.19&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;String healthCheckName = &lt;span&gt;&quot;thread_dead_lock&quot;&lt;/span&gt;;&lt;br/&gt;HealthCheckRegistry healthCheckRegistry = &lt;span&gt;new&lt;/span&gt; HealthCheckRegistry();&lt;br/&gt;healthCheckRegistry.register(healthCheckName,&lt;span&gt;new&lt;/span&gt; ThreadDeadlockHealthCheck());  &lt;br/&gt;healthCheckRegistry.runHealthCheck(healthCheckName).isHealthy();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就加入了一个死锁检测,每次运行&lt;code&gt;healthCheckRegistry.runHealthCheck(healthCheckName).isHealthy()&lt;/code&gt;时就可以知道当前程序是否有死锁了.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;protected&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt; ScheduledThreadPoolExecutor SCHEDULE_EXECUTOR = &lt;span&gt;new&lt;/span&gt; ScheduledThreadPoolExecutor(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; io.micrometer.core.instrument.MeterRegistry meterRegistry;&lt;br/&gt;...&lt;br/&gt;            AtomicInteger current = &lt;span&gt;new&lt;/span&gt; AtomicInteger(healthCheckRegistry.runHealthCheck(healthCheckName).isHealthy()?&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            SCHEDULE_EXECUTOR.scheduleAtFixedRate(()-&amp;gt;{&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(meterRegistry.find(healthCheckName).gauge()==&lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;                    meterRegistry.gauge(healthCheckName,current);&lt;br/&gt;                }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;                    HealthCheck.Result result = healthCheckRegistry.runHealthCheck(healthCheckName);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt;(!result.isHealthy()){&lt;br/&gt;                        log.error(&lt;span&gt;&quot;run healthCheck:&quot;&lt;/span&gt;+result.getMessage());&lt;br/&gt;                    }&lt;br/&gt;                    current.set(result.isHealthy()?&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            },&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;, TimeUnit.SECONDS);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就可以定时检测程序中是否有死锁存在,如果有,&lt;code&gt;thread_dead_lock&lt;/code&gt;这个metrics会显示为0.也可以通过&lt;code&gt;HealthCheck.Result result&lt;/code&gt;这个对象,把死锁相关信息打印在程序log中,这样可以将信息收集到专门的日志系统去.比如Elasticsearch.&lt;/p&gt;&lt;h1&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;需要配置的内容和编写的代码并不多,只需要少量代码就可以做到检测程序死锁了.那么这一切是如何做到的呢?一起来看一下.&lt;/p&gt;&lt;p&gt;首先从最外面的入口点进源码看看逻辑.&lt;/p&gt;&lt;p&gt;点进&lt;code&gt;ThreadDeadlockHealthCheck&lt;/code&gt;类看看有什么代码,可以看到只有很少的代码,有一个重写的check方法:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadDeadlockHealthCheck&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HealthCheck&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadDeadlockDetector detector;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Creates a new health check.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadDeadlockHealthCheck&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; ThreadDeadlockDetector());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Creates a new health check with the given detector.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; detector a thread deadlock detector&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadDeadlockHealthCheck&lt;/span&gt;&lt;span&gt;(ThreadDeadlockDetector detector)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.detector = detector;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Result &lt;span&gt;check&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Set&amp;lt;String&amp;gt; threads = detector.getDeadlockedThreads();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (threads.isEmpty()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Result.healthy();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Result.unhealthy(threads.toString());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从&lt;code&gt;getDeadlockedThreads&lt;/code&gt;方法名可以看明白这个方法是获取当前死锁线程集合.点进去看看是如何获取的.感觉离原理越来越近了.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt; &lt;span&gt;getDeadlockedThreads&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[] ids = threads.findDeadlockedThreads();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ids != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Set&amp;lt;String&amp;gt; deadlocks = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (ThreadInfo info : threads.getThreadInfo(ids, MAX_STACK_TRACE_DEPTH)) {&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; StringBuilder stackTrace = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (StackTraceElement element : info.getStackTrace()) {&lt;br/&gt;                    stackTrace.append(&lt;span&gt;&quot;\t at &quot;&lt;/span&gt;)&lt;br/&gt;                            .append(element.toString())&lt;br/&gt;                            .append(String.format(&lt;span&gt;&quot;%n&quot;&lt;/span&gt;));&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                deadlocks.add(&lt;br/&gt;                        String.format(&lt;span&gt;&quot;%s locked on %s (owned by %s):%n%s&quot;&lt;/span&gt;,&lt;br/&gt;                                info.getThreadName(),&lt;br/&gt;                                info.getLockName(),&lt;br/&gt;                                info.getLockOwnerName(),&lt;br/&gt;                                stackTrace.toString()&lt;br/&gt;                        )&lt;br/&gt;                );&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Collections.unmodifiableSet(deadlocks);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Collections.emptySet();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;点进去后发现是通过&lt;code&gt;final long[] ids = threads.findDeadlockedThreads();&lt;/code&gt;获取到死锁的线程id数字,看看&lt;code&gt;threads&lt;/code&gt;变量是一个什么东西.&lt;/p&gt;&lt;p&gt;&lt;code&gt;java 
private final ThreadMXBean threads;&lt;/code&gt;  &lt;/p&gt;&lt;p&gt;可以看到这是ThreadMXBean提供的方法,而这个类是&lt;code&gt;java.lang.management&lt;/code&gt;包下的.这个包是JDK提供的一些用于检测JVM状态的API类.可以拿到当前JVM的内存,GC,线程,class等各种信息.&lt;/p&gt;&lt;p&gt;我们这里是用的其中一种MXBean类:ThreadMXBean,来获取线程相关的信息.感兴趣的可以自己去研究下,例如获取内存信息的一个类:&lt;code&gt;MemoryMXBean&lt;/code&gt;,这里不展开讲述.&lt;/p&gt;&lt;p&gt;细心的同学可以发现我们目前已经拿到了死锁线程的ID数组,如果数组有内容其实就说明当前程序有发生死锁.&lt;/p&gt;&lt;p&gt;后面的逻辑是拿一些死锁线程具体的信息,例如线程名,锁名,锁持有者.&lt;/p&gt;&lt;p&gt;因此对于没有接入或不希望接入&lt;code&gt;dropwizard.metrics&lt;/code&gt;的同学来说,完全可以自己实现一个检测程序是否有死锁的逻辑.&lt;/p&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;对于当前没有检测死锁的程序来说,发生死锁时所产生的未知影响是很大的.而如果程序能够自己定时检测是否有死锁并且发生时能够快速的发出警告,很大程度上可以避免一些不必要的损失.&lt;/p&gt;&lt;p&gt;如果你的程序当前还没有死锁检测,赶紧偷偷加上监控死锁的逻辑,然后惊艳所有人!!!&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>