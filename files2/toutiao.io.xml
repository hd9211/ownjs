<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>01a64307c166b12788ee7b8b35a7a339</guid>
<title>生成唯一 ID，为什么 NanoID 会取代 UUID？</title>
<link>https://toutiao.io/k/vykwkmg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014059&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0APKic5Gu4BficgXpaaEyTSJQBQ3XpQqSHMVI5ZlHjcvibl0ThqGRLEBkrffjn2aETOBVYibQPWKphefTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;UUID&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 是软件开发中最常用的通用标识符之一。然而，在过去几年中，其他替代品挑战了它的存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，NanoID 是取代 UUID 的主要竞争对手之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在本文中，我将讨论 NanoID 的功能、它的亮点以及它的局限性，以便您更好地了解何时使用它。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;了解 NanoID 及其用法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 JavaScript，生成 UUID 或 NanoID 非常简单，他们都有 NPM 包来帮助你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你所需要做的就是用 &lt;code&gt;npm i nanoid&lt;/code&gt; 命令安装NanoID NPM库，并在你的项目中使用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { nanoid } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;nanoid&#x27;&lt;/span&gt;;&lt;br/&gt;model.id = nanoid();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你知道NanoID每周有超过11,754K的NPM下载量，并且比UUID快60%吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，NanoID比UUID年轻近7年，而且它在GitHub上的星级已经超过了UUID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图显示了这两个的npm趋势比较，我们可以看到NanoID的上升趋势，而UUID的进展平平。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014061&quot; data-ratio=&quot;0.7344173441734417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APKic5Gu4BficgXpaaEyTSJQB4eEb4HoGiaSfUr5963uFzH7Ag4ty8MKicz10cpUCz0opMJYVLTzXy6og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1107&quot;/&gt;&lt;figcaption&gt;https://www.npmtrends.com/nanoid-vs-uuid&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我希望这些数字已经说服了你去尝试NanoID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，这两者之间的主要区别很简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 NanoID 使用比 UUID 更大的字母表，因此较短的 ID 可以用于与较长的 UUID 相同的目的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.NanoID 的大小只有 108 个字节&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 UUID 不同，NanoID 的大小要小 4.5 倍，并且没有任何依赖关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大小减少直接影响数据的大小。例如，使用 NanoID 的对象小而紧凑，用于数据传输和存储。随着应用程序的增长，这些数字变得可见。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.更安全&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大多数随机生成器中，它们使用不安全的 &lt;code&gt;Math.random()&lt;/code&gt;。但是，NanoID 使用更安全的 &lt;code&gt;crypto module&lt;/code&gt; 和 &lt;code&gt;Web Crypto API&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，NanoID 在 ID 生成器的实现过程中使用了自己的称为统一算法的算法，而不是使用 &lt;code&gt;random % alphabet&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1634907685735&quot; data-category_id_list=&quot;48|32|26|49|1|27|28|45|46|55|39|8|3|47|35|41|5|31|6|7|24|37|22|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1634907685735&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.它快速而紧凑&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NanoID比UUID快60%。与UUID的36个字符不同，NanoID只有21个字符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz-&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，NanoID 支持 14 种不同的编程语言，它们是&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;C#, C++, Clojure and ClojureScript, Crystal, Dart &amp;amp; Flutter, Deno, Go, Elixir, Haskell, Janet, Java, Nim, Perl, PHP, Python with dictionaries, Ruby , Rust, Swift&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.兼容性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它还支持 PouchDB、CouchDB WebWorkers、Rollup 以及 React 和 Reach-Native 等库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以通过使用 &lt;code&gt;npx nanoid&lt;/code&gt; 在终端获得一个唯一的ID，唯一的先决条件是要安装NodeJS。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014057&quot; data-ratio=&quot;0.08579881656804733&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APKic5Gu4BficgXpaaEyTSJQBWKPldhZsRupDVeYibsN4IPvC6zMBVwCZtzBr0GJ7DtpolroxI17ibic8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;676&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你也可以在&lt;span&gt;Redux toolkit&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;内找到NanoID，并将其用于其他使用情况，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { nanoid } &lt;span&gt;from&lt;/span&gt; ‘@reduxjs/toolkit’&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nanoid()) &lt;span&gt;//‘dgPXxUz_6fWIQBD8XmiSy’&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.自定义字母&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NanoID 的另一个现有功能是它允许开发人员使用自定义字母表。您可以更改文字或 id 的大小，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { customAlphabet } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;nanoid&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; nanoid = customAlphabet(&lt;span&gt;&#x27;ABCDEF1234567890&#x27;&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;);&lt;br/&gt;model.id = nanoid();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的示例中，我将自定义字母表定义为 &lt;code&gt;ABCDEF1234567890&lt;/code&gt;，并将 Id 的大小定义为 12。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.没有第三方依赖&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 NanoID 不依赖任何第三方依赖，随着时间的推移，它变得更加稳定自治。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从长远来看，这有利于优化bundle的大小，使其不容易出现依赖关系带来的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;局限性和未来重点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 StackOverflow 中的许多专家意见，使用 NanoID 没有明显的缺点或限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非人类可读性是许多开发者认为NanoID的主要缺点，因为它使调试更加困难。但是，与UUID相比，NanoID要短得多，可读性强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，如果你使用 NanoID 作为表的主键，如果你使用相同的列作为聚集索引也会出现问题，这是因为 NanoID 不是连续的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在未来...&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NanoID 正逐渐成为最流行的 JavaScript 唯一 id 生成器，大多数开发人员更喜欢选择它而不是 UUID。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;529014058&quot; data-ratio=&quot;0.8723404255319149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APKic5Gu4BficgXpaaEyTSJQBYTsqxdgNq85gf4WdKliahbKMBchvkBBSNaydyg2TgVTs4L84E5N94tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;figcaption&gt;Source: https://www.npmjs.com/package/nanoid&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上基准测试显示了NanoID与其他主要id生成器相比的性能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在使用其默认字母表时，它每秒可生成超过220万个独特的ID，在使用自定义字母表时，每秒可生成超过180万个独特的ID。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我使用 UUID 和 NanoID 的经验，考虑到它的小尺寸、URL 友好性、安全性和速度，我建议在任何未来的项目中使用 NanoID 而不是 UUID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我邀请你在你的下一个项目中尝试使用NanoID，并在评论区与其他人分享你的想法。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;&lt;span&gt;原文：https://blog.bitsrc.io/why-is-nanoid-replacing-uuid-1b5100e62ed2&lt;br/&gt;&lt;span&gt;作者：Charuka Herath&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mpsearch class=&quot;js_mpsearch appmsg_search_iframe js_uneditable custom_select_card&quot; data-keywords=&quot;%5B%7B%22label%22%3A%22VSCode%22%7D%2C%7B%22label%22%3A%22Vue3%22%7D%2C%7B%22label%22%3A%22%E5%B0%8F%E6%8A%80%E5%B7%A7%22%7D%2C%7B%22label%22%3A%22Flutter%22%7D%5D&quot; data-parentclass=&quot;appmsg_search_iframe_wrp&quot; data-ratio=&quot;1.5664335664335665&quot; data-w=&quot;286&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;UUID: &lt;em&gt;https://en.wikipedia.org/wiki/Universally_unique_identifier&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Redux toolkit: &lt;em&gt;https://redux-toolkit.js.org/api/other-exports&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3af9655ed4eaf4af155fa8c4dadc0f1</guid>
<title>亿级流量实验平台设计实践</title>
<link>https://toutiao.io/k/rlhre5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关注公众号:【虫爸说说】， 回复[资料]，免费获取&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3MTE5MDM2Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3ky6qxFGrVdeMBSqICRuIeVqJzqvBib6U4n7NicHS6Sq1U5CnqBCrYRqKgeoYBjgy7ibAY06MfPQHDuA/0?wx_fmt=png&quot; data-nickname=&quot;虫爸说说&quot; data-alias=&quot;&quot; data-signature=&quot;我是虫爸，85后程序员，现任某互联网公司高级技术专家一职。分享一些工作中的心得，杂谈。聊聊架构，扯扯算法，就酱😭。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;243&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4349157733537519&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCjJ019gLibD9PreFjKtPQyrODcsicvaz405bk2bvBoNDUYOdC6TibIib6iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是虫爸。今天给大家分享一款亿级流量实验平台。在互联网行业，要上线一个策略(CTR预估、CVR预估等)，或者一个功能，如果贸然全量上线，那么如果新策略效果不佳，可能会造成不小的损失，要么丢失用户，要么损失收入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么怎样才能避免此问题发生呢？这就引入了实验平台，通过对流量打标签，然后分析实验效果，从而再决定是否实验推全还是下线。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、概念&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验平台，从字面意思来看，就是一个用来做实验的平台。其 &lt;strong&gt;&lt;em&gt;基本原理&lt;/em&gt;&lt;/strong&gt; 就是把流量进行分流，特定流量，匹配特定策略。不同批次的用户，看到的不同的策略。然后通过曝光、点击等数据进行统计分析，得出实验效果的好坏，从而决定是否推全该实验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，就是为同一个目标制定两个方案（比如两个页面），将产品的用户流量根据特定策略分割成 A/B 两组，一组实验组，一组对照组，两组实验同时运行一段时间后分别统计两组用户的表现，再将相关结果数据（比如 pv/uv、商机转化率等）进行对比，就可以科学地帮助决策。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对流量进行分流，运行实验，统计实验数据，进行数据分析，然后得出实验效果。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;291&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5233555767397522&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCznlp7BGpPwiaPEkibsicHOtHm6mghyvvUfRWc8JZJdnAJTwgYPZyahr3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1049&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再根据实验效果，进行反向数据分析，定位出实验效果不好的源，进行头脑风暴，再次做实验，从而最终达到理想的实验目的。如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;238&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.42649842271293376&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCIw3lz5C5FtS7P5v5oXTZNIXagkPJJzHQPX9SL1L6YLYLAN0Na6I2lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1585&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、分层实验模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行实验平台讲解之前，先介绍下实验平台的理论基础，以便大家能够更好的理解后面的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在业界大部分实验平台，都基于谷歌2017年的一篇论文《Overlapping Experiment Infrastructure: More, Better, Faster Experimentation》,其模型架构如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;305&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5475708502024291&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCaKiap4V0goibWR5X0WKENUmRQT3Bumg99NORiaLyibqcWap0X3ZHoJg63Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该模型中，有几个概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;域（domain）：划分的一部分流量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;层（layer）：系统参数的一个子集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实验（exp）：在一个域上，对一个或者多个参数修改，都将影响效果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流量在每个层被打散(分配函数)，层与层之间流量正交&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图【图四】为笔者线上实验的一个简略图，在该图中，总共有三个实验层，分别为CTR预估层，用户画像层和频次策略层。&lt;img data-backh=&quot;335&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5991792065663475&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCzrqrt4WmiaGrLJbHOB3zJQxr5BDcYE6F4CXzSxlFibl45BzstH7juvyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;731&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图四可以看到，流量在层之间穿梭，而一个流量只能命中一个层中的一个实验，一个流量请求过程可能会命中多个层中的多个实验(每层命中一个实验)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用分层实验模型，需要满足以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;相关联的策略参数位于同一实验层（即都是做CTR预估，那么CTR预估相关的实验，就放在同一层，即CTR预估层，以方便做实验对比）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;相互独立的策略参数分属于不同的实验层（如上图中 ，CTR预估的实验和频次实验是两种性质不同的实验，因此要放在两层来实现，如果在一层的话，由于实验性质不同，难以比较实验效果）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个流量只能命中一个层中的一个实验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;层之间的流量正交，不会互相影响（即层与层之间的实验不会互相影响,如【图五】）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;300&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5372750642673522&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCb7EmI3iatZuiats8KgTDC4r7U0GR8AeeUyaTS2ibSND5ichF3spibAlg9Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1167&quot;/&gt;&lt;figcaption&gt;图五&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用该分层模型作为实验平台理论基础的好处有以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以作为一个独立的部分，不与系统中的其他业务或者功能相互 影响&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一层流量都是100%的全量，可以避免流量切分过细，保证实验间的可对比性、客观性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;层与层之间，流量独立正交，不会互相影响&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、功能特点&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可用或者完善的实验平台，需要有以下几个功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持多实验并发迭代&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持白名单体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供便捷的管理工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;便捷的查看实验效果分析数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持实验的切流和关闭&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证线上实验安全性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持实验推全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持功能定制化&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我们将从几个功能点出发，详细讲述各个功能的原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持多实验并发迭代，指的是一个完善的实验平台，在功能上，需要支持多个实验同时运行(包括同一层和不同层之间)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持白名单体验：因为实验分流有自己的策略，创建实验的用户不一定能够命中这个实验，而白名单的功能就是让在白名单的用户能够每次都命中该实验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;便捷的管理工具：这个指的是实验后台，一个实验后台需要能够创建实验，打开关闭实验等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看实验效果分析数据：判断一个实验效果的好坏，就是通过实验标签分析实验数据，能够很直观的观察到实验效果，从进行下一步实验决策&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验的切流和关闭：实验的切流，指的是该实验需要一定百分比的流量进行实验，而实验关闭，则指的是停掉该实验&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持线上安全性：实验平台，本身就是起锦上添花的作用，其只是用来打实验标签的，不可本末倒置，影响了线上业务的正常功能&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持实验推全：一个实验效果如果好的话，就需要将全部的流量都命中该实验，而实验推全就是达到此效果&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持功能定制：没有一个实验平台能够满足不同公司，甚至同一个公司不同部门之间的业务需求，但是，为了尽可能的向这个目标靠拢，实验平台需要尽可能的灵活，低耦合，能够尽量的配置化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3MTE5MDM2Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3ky6qxFGrVdeMBSqICRuIeVqJzqvBib6U4n7NicHS6Sq1U5CnqBCrYRqKgeoYBjgy7ibAY06MfPQHDuA/0?wx_fmt=png&quot; data-nickname=&quot;虫爸说说&quot; data-alias=&quot;&quot; data-signature=&quot;我是虫爸，85后程序员，现任某互联网公司高级技术专家一职。分享一些工作中的心得，杂谈。聊聊架构，扯扯算法，就酱😭。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;四、架构及模块&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验平台必备的三个模块，分别为：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;管理后台主要是管理实验的，包括创建和停止实验等。&lt;/p&gt;&lt;p&gt;实验后台与管理后台进行数据上的交互，将管理后台的消息转换成特有的消息，进行转发和持久化。&lt;/p&gt;&lt;p&gt;分流平台，其一接收实验后台的实验消息建立内部维度索引，其二接收线上流量，根据流量属性，给流量打上对应的标签。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;440&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7886855241264559&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCd04GKzU6Wk9KdUAr3q5cA3BicjrFv7gqOr3Pk12H5liaFlpHEtsPmvzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图，是一个实验平台架构图，下面从创建实验角度，和流量的角度进行讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建实验角度：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、在管理后台创建对应的实验&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、管理后台将创建的实验信息发送给实验后台&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、实验后台将实验首先发送至消息系统(kafka等)，然后将实验落地持久化(DB)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、分流平台消耗消息系统中的实验消息，加载至内存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量角度：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 流量携带其基本属性(用户画像，app信息等)请求分流平台&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 分流平台根据流量属性，进行定制化匹配，然后使用分流算法，计算实验标签&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、流量返回至调用方SDK后，SDK上报曝光、点击等信息至数据总线(大数据集群)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、数据计算服务分析大数据集群的数据，计算对应的指标展示在管理后台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验平台，从模块划分上 ，如下图所示：&lt;img data-backh=&quot;295&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5284609978917779&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrC0ZW6jYBV6jCGCK33EGFfv5yicMqb4BbssJJ7Fc7KicjPIU8T4FAD1HsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1423&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、设计与实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体介绍下文之前，我们先理解一个概念，以便能更方便的理解下述内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;464&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.8310249307479224&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCgEvMUq4T5DZUVkvNuxJj0ibqGCe0AicTnk9d2hNaVk4OAkK5IDtVTC5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot;/&gt;&lt;figcaption&gt;桶&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bucket即桶。实验平台最底层，将流量进行hash之后，只能流入某一个桶里。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3MTE5MDM2Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3ky6qxFGrVdeMBSqICRuIeVqJzqvBib6U4n7NicHS6Sq1U5CnqBCrYRqKgeoYBjgy7ibAY06MfPQHDuA/0?wx_fmt=png&quot; data-nickname=&quot;虫爸说说&quot; data-alias=&quot;&quot; data-signature=&quot;我是虫爸，85后程序员，现任某互联网公司高级技术专家一职。分享一些工作中的心得，杂谈。聊聊架构，扯扯算法，就酱😭。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;流量划分&lt;span/&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般有以下几种划分方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;完全随机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户id哈希。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该流量划分会使同一个用户会一直命中同一实验，从而保证了用户体验的一致性；而且也满足对同一用户具有累积效应的策略的实验需求。但存在的问题就是，对于一些工具类属性，没有用户id一说，只有设备id比如idfa和imei这些标记，但是随着系统升级，这俩标记很难再获取到，所以就需要系统能够生成用户唯一id&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;用户id + 日期作为一个整体进行哈希 这是一种更为严格的保证流量均匀性的分流方式，可以保证流量划分在跨时间维度上更为均匀。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;会牺牲用户请求跨时间区间的一致性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跟上面这种用户id哈希存在同样的问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;用户id尾号进行哈希&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了兼容上述几种哈希划分方式的优点，而摒弃其缺点，我们引入了第四种流量划分方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;bucket_id = &lt;span&gt;hash&lt;/span&gt;(uid + layer_id) % 1000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的哈希算法有md5，crc以及MurmurHash等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），MD5算法将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。由美国密码学家 Ronald Linn Rivest设计，于1992年公开并在 RFC 1321 中被加以规范。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CRC循环冗余校验（Cyclic Redundancy Check）是一种根据网络数据包或电脑文件等数据，产生简短固定位数校验码的一种散列函数，由 W. Wesley Peterson 于1961年发表。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。由于本函数易于用二进制的电脑硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。由 Austin Appleby 在2008年发明，并出现了多个变种，与其它流行的哈希函数相比，对于规律性较强的键，MurmurHash的随机分布特征表现更良好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，第三种MurmurHash算法，已经被很多开源项目使用，比如libstdc++ (4.6版)、Perl、nginx (不早于1.0.1版)、Rubinius、 libmemcached、maatkit、Hadoop以及redis等。而且经过大量的测试，其流量分布更加均匀，所以笔者采用的是此种哈希算法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;白名单&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;白名单，在实验平台中算是比较重要的功能，其目的就是存在于白名单中的用户优先于流量分桶，命中某个实验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的一点是，假如白名单所在实验和流量经过哈希分桶之后的实验是两个不同的实验，这就只能以白名单优先级为最高，换句话说，如果白名单命中了某个实验，那么在该层上，就不该再命中其他实验。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;管理后台&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来管理实验的，比如权限管理、层管理等，如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;299&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5348837209302325&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCjibKVXvvxBiaDowJE6zANh20QcIK6qK5HyKqp0PKpvRPicbww6zvTu6xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1376&quot;/&gt;在上图中，管理后台，主要有以下几个模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实验管理，顾名思义，管理现有实验和创建新实验&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实验列表：现有已经创建的所有实验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建实验：创建新实验&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;基础配置，一些配置管理信息都在此模块中&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实验层：增删改实验层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他：针对实验做的一些定制化，比如增加广告位定向、年龄定向等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;系统管理，主要针对用户及其分组&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分组管理，管理用户属于某个分组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实验平台的用户权限管理，比如普通权限或者管理员权限&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，用户管理这块的权限非常重要，因为实验平台可能涉及到很核心的实验，比如商业化中策略影响的实验，所以用户之间不能看到其他人创建的实验，这层物理隔离非常重要。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分流平台&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分流评估 ，顾名思义，对流量进行分离，有两个功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;承接实验后台的实验消息，建立维度索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收线上流量，根据维度索引、白名单以及对用户设备哈希分桶后，给流量打标签&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分流平台，是整个实验平台的核心模块，一定要高性能，高可靠。&lt;img data-backh=&quot;295&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5275862068965518&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrCovl6ibbcGcxjxN9739v1uoibM7BcGS2Rn1P59Pbr2CyYSrz6pzeZNuqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2320&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、实验效果&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求的实验信息会以标签的形式上报给sdk，sdk在进行曝光点击的时候，会将这些信息上报，比如&quot;123_456_789&quot;格式。最终，这些会经过广告实时流系统进行消费、数据清洗、实验效果指标计算等工作。由于广告系统是多业务指标系统，包括售卖率，ECPM， CTR， ACPE，负反馈率、财务消耗计算等。广告实时流系统还需要日志的关联工作，比如关联广告互动日志，广告负反馈日志。实时流的计算的结果，会落地到druid 系统，方便实验效果数据的快速检索和二度加工。实验效果实时指标数据计算延迟控制在一定的范围内。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;374&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.6714579055441479&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/nHhIb6Amn3kc0pofpGf1vFsZJ0RUamrC014iaFXibWqMa45voB2zkhf3sYz1SLvric3MmcPxqTOzPxa6ib3xNE9j7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1948&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、结语&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后需要提的是，实验平台在效果跟踪决策方面是有一定的局限性的。实验平台可以进行实验效果的快速跟踪，但是却很难进行实验效果好坏的决策。比如：如果对比实验效果指标值全部提高或下降了，可以简单认为对比实验的策略调整起正向作用或者反向作用；如果对比实验的实验效果指标值部分提高了，部分下降了，就不太好认定了。还有，实验效果的短期效应和长期效应也可能是不一致，这将大大增加了实验效果好坏的决策难度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，实验平台是可以快速提升广告业务策略迭代效率的工具，但是要想进行实验好坏评定的决策，还需要很长的路要走。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b6375cb4e058a43fcc735d9f0fbd2ca9</guid>
<title>图解：什么是 TCP 拥塞控制及谷歌的 BBR 算法</title>
<link>https://toutiao.io/k/6j6atev</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;&lt;span&gt;1.拥塞控制简史&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;来看下维基百科对TCP/IP协议栈的一些介绍，笔者做了少量的修改来确保语句通顺：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;互联网协议套件是一个网络通信模型以及整个网络传输协议家族，由于该协议簇包含两个核心协议：TCP（传输控制协议）和IP（网际协议），因此常被通称为&lt;span&gt;TCP/IP协议族&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;span&gt; &lt;/span&gt;&lt;p&gt;TCP/IP协议对于数据应该如何封装、定址、传输、路由以及在目的地如何接收等基本过程都加以标准化。它将通信过程&lt;span&gt;抽象化为四个层次&lt;/span&gt;，并采取协议堆栈的方式分别实现出不同通信协议，实际使用的四层结构是七层OSI模型的简化。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;我们可以看到TCP/IP协议栈是一个简化的分层模型，是互联网世界连接一切的基石，一起来看一张&lt;/span&gt;&lt;span&gt;七层模型vs四层模型&lt;/span&gt;&lt;span&gt;的简图：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6981519507186859&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0yACFrqcHYTLO9WUbVhtNAu3kmSo8h504FHVYeVgCicticLD2FDmQVicaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大约在1988年之前TCP/IP是没有拥塞控制的，但是随着网络接入规模的发展之前仅有的端到端窗口控制已经无法满足要求，在1986年引发大规模网络瘫痪，此时就要提到一个重量级人物：&lt;/span&gt;&lt;span&gt;Van Jacobson范·雅各布森&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这位力挽狂澜的人物入选了&lt;/span&gt;&lt;strong&gt;&lt;span&gt;计算机名人堂Internet Hall of Fame&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，Van Jacobson大神提出并设计实施了TCP/IP拥塞控制，解决了当时最大的问题，来简单看下Van Jacobson的维基百科简介(&lt;/span&gt;&lt;span&gt;&lt;strong&gt;笔者做了部分删减&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;)：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;范·雅各布森Van Jacobson是目前作为&lt;/span&gt;&lt;span&gt;互联网技术基础的TCP/IP协议栈的主要起草者&lt;/span&gt;&lt;span&gt;，他以其&lt;/span&gt;&lt;span&gt;在网络性能的提升和优化的开创性成就而闻名&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2006年8月，他加入了帕洛阿尔托研究中心担任研究员，并在位于相邻的施乐建筑群的Packet Design公司担任首席科学家。在此之前，他曾是思科系统公司首席科学家，并在位于劳伦斯伯克利国家实验室的网络研究小组任领导者。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;范·雅各布森因为在提高IP网络性能提升和优化所作的工作而为人们所知，&lt;/span&gt;&lt;span&gt;1988到1989年间，他重新设计了TCP/IP的流控制算法（Jacobson算法）&lt;/span&gt;&lt;span&gt;，他因设计了RFC 1144中的TCP/IP头压缩协议即范·雅各布森TCP/IP头压缩协议而广为人知。此外他也曾与他人合作设计了一些被广泛使用的网络诊断工具，如&lt;/span&gt;&lt;span&gt;traceroute&lt;/span&gt;&lt;span&gt;，pathchar以及&lt;/span&gt;&lt;span&gt;tcpdump&lt;/span&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;范·雅各布森于&lt;/span&gt;&lt;span&gt;2012年4月入选第一批计算机名人堂，计算机名人堂简介：https://www.internethalloffame.org/inductees/van-jacobson&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;如图为Van Jacobson计算机名人堂的简介：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0596205962059622&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIot1gQ7IGBbibztcQ2920lXkLeeFDl4MibJfP51p2nJianvC7icxIYSGUkeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;738&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者找了&lt;span&gt;Van Jacobson&lt;/span&gt;和Michael J. Karels在1988年11月发布的关于拥塞避免和控制的论文，总计25页，感兴趣的读者可以查阅：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;https://ee.lbl.gov/papers/congavoid.pdf&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;我们常用的tracetoute和tcpdump也是van-jacobson大神的杰作，作为互联网时代的受益者不由得对这些互联网发展早期做出巨大贡献的开拓者、创新者、变革者心生赞叹和敬意。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.流量控制和拥塞控制&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;TCP是一种面向连接的、可靠的、全双工传输协议，前辈们写了很多复杂的算法为其保驾护航，其中有一组像&lt;/span&gt;&lt;strong&gt;&lt;span&gt;海尔兄弟一样&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的算法：&lt;/span&gt;&lt;span&gt;流量控制和拥塞控制&lt;/span&gt;&lt;span&gt;，这也是我们今天的主角。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7460063897763578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH05QlHBhUfxXeN49kvMcnEGclYH1eQ1OJhZYPpymwmS4SfoLrxAbzCOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.1 流量控制简介&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;流量控制和拥塞控制从汉语字面上并不能很好的区分，本质上这一对算法既有区别也有联系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维基百科对于&lt;/span&gt;&lt;span&gt;流量控制Flow Control&lt;/span&gt;&lt;span&gt;的说明：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;In data communications, flow control is the process of managing the rate of data transmission between two nodes to prevent a fast sender from overwhelming a slow receiver. &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;It provides a mechanism for the receiver to control the transmission speed, so that the receiving node is not overwhelmed with data from transmitting node.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;翻译一下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;在数据通信中，流量控制是管理两个节点之间数据传输速率的过程，以防止快速发送方压倒慢速接收方。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;它为接收机提供了一种控制传输速度的机制，这样接收节点就不会被来自发送节点的数据淹没。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;可以看到流量控制是通信双方之间约定数据量的一种机制，具体来说是借助于TCP协议的确认ACK机制和窗口协议来完成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;窗口分为&lt;/span&gt;&lt;span&gt;固定窗口和可变窗口&lt;/span&gt;&lt;span&gt;，可变窗口也就是&lt;/span&gt;&lt;span&gt;滑动窗口&lt;/span&gt;&lt;span&gt;，简单来说就是通信双方根据接收方的接收情况动态告诉发送端可以发送的数据量，从而实现发送方和接收方的数据&lt;/span&gt;&lt;span&gt;收发能力匹配&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个过程非常容易捕捉，使用&lt;/span&gt;&lt;span&gt;wireshark在电脑上抓或者tcpdump在服务器&lt;/span&gt;&lt;span&gt;上抓都可以看到，大白在自己电脑上用wireshark抓了一条：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6434210526315789&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0KJqEic1V3Z6iam8Ju6J9GWOQ7FibDpVsOgKtEHqGA7giaw8KqrLQgXTvPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们以两个主机交互来简单理解流量控制过程：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.37850467289719625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0Vib96PWdiayoVL3vt6dTia2ibPeKSndYibicVibAlzjokBib3UIBqPdGFlHFQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接收方回复报文头部解释：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7160356347438753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0JsCDtNZibC9AASXshY5Zmr9PFcfRyUuqEydzPWZic1PrYvAibV33y8p0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;图中RcvBuffer是接收区总大小，buffered data是当前已经占用的数据，而free buffer space是当前剩余的空间，rwnd的就是free buffer space区域的字节数。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;HostB把当前的rwnd值放入报文头部的接收窗口receive window字段中，以此通知HostA自己还有多少可用空间， 而HostA则将未确认的数据量控制在rwnd值的范围内，从而避免HostB的接收缓存溢出。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;可见&lt;/span&gt;&lt;span&gt;流量控制是端到端微观层面的数据策略&lt;/span&gt;&lt;span&gt;，双方在数据通信的过程中并不关心链路带宽情况，只关心通信双方的接收发送缓冲区的空间大小，可以说是个&lt;/span&gt;&lt;span&gt;速率流量匹配策略&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流量控制就像现实生活中物流领域中A和B两个仓库，A往B运送货物时只关心仓库B的剩余空间来调整自己的发货量，而不关心高速是否拥堵。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.2 拥塞控制的必要性&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前面我们提到了微观层面点到点的流量控制，但是我们不由地思考一个问题：&lt;/span&gt;&lt;span&gt;只有流量控制够吗？答案是否定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们还需要一个宏观层面的控去避免网络链路的拥堵，否则再好的端到端流量控制算法也面临&lt;/span&gt;&lt;span&gt;丢包、乱序、重传&lt;/span&gt;&lt;span&gt;问题，只能造成恶性循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42441054091539526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0rHLRXk7JAYy8KYug8qgwHib2NTXOyPTq2HzMPEkzrVg2jmzMXgPiaQJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们从一个更高的角度去看&lt;/span&gt;&lt;span&gt;大量TCP连接复用网络链路&lt;/span&gt;&lt;span&gt;的通信过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7414050822122571&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gVfr2dlRsiciaFP85icESibib6zpxLva1vXOKticfzH2N6OUKd0uxUEywmVsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以拥塞控制和每一条端到端的连接关系非常大，这就是流量控制和拥塞控制的深层次联系，所谓每一条连接都顺畅那么整个复杂的网络链路也很大程度是通畅的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.49047619047619045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qYxV7iaTicF5XgunD36BA3YH0FlegVJhvC3uVhpLhYzL7kRnIlXWIicN1XmZ8vStakxBKhkfG3YXJ6aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在展开拥塞控制之前我们先考虑几个问题：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;TCP连接的发送方在向对端发送数据的过程中，需要根据当前的网络状况来调整发送速率，所以感知能力很关键。&lt;/section&gt;&lt;section&gt;在TCP连接的发送方一般是&lt;span&gt;基于丢包&lt;/span&gt;来判断当前网络是否发生拥塞，丢包可以由&lt;span&gt;重传超时RTO和重复确认&lt;/span&gt;来做判断。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5222841225626741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51g1b20eDwj9E49hPBdaebBIVRYsxia8aCjo83eqnFicMxUfszicAvgZo5Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;/section&gt;&lt;section&gt;诚然拥塞影响很大，但是一直低速发包对带宽利用率很低也是很不明智的做法，因此要充分利用带宽就不能过低过高发送数据，而是保持在一个动态稳定的速率来提高带宽利用率，这个还是比较难的，&lt;span&gt;就像茫茫黑夜去躲避障碍物&lt;/span&gt;。&lt;/section&gt;&lt;section&gt;拥塞发生时我们需要有一套应对措施来防止拥塞恶化并且恢复连接流量，这也是拥塞控制算法的精要所在。&lt;/section&gt;&lt;h2&gt;&lt;span&gt;3.理解拥塞控制&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;看到一篇文章说到&lt;/span&gt;&lt;span&gt;TCP 传输层拥塞控制算法并不是简单的计算机网络的概念，也属于控制论范畴&lt;/span&gt;&lt;span&gt;，感觉这个观点很道理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TCP拥塞控制算法的目的可以简单概括为：&lt;/span&gt;&lt;span&gt;公平竞争、充分利用网络带宽、降低网络延时、优化用户体验，&lt;/span&gt;&lt;span&gt;然而就目前而言要实现这些目标就难免有&lt;/span&gt;&lt;span&gt;权衡和取舍。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在理解拥塞控制算法之前我们需要明确一个核心的思想：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;闻道有先后 术业有专攻&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，笔者觉得这是一个非常重要的共识问题，把A踩在泥土里，把B吹捧到天上去，都不是很好的做法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际的网络环境十分复杂并且变化很快，&lt;/span&gt;&lt;span&gt;并没有哪个拥塞控制算法可以全部搞定，每一种算法都有自己的特定和适用领域&lt;/span&gt;&lt;span&gt;，每种算法都是对几个关键点的权衡，在无法兼得的条件下有的算法选择带宽利用率，有的算法选择通信延时等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在明确这个&lt;strong&gt;共识问题&lt;/strong&gt;之后，我们对待各个拥塞控制算法的态度要&lt;/span&gt;&lt;span&gt;平和一些，不要偏激&lt;/span&gt;&lt;span&gt;地认为谁就是最好，几十年前的网络状况和现在是截然不同的，&lt;/span&gt;&lt;span&gt;我们永远都是站在巨人的肩膀之上的，这也是科学和文明进步的推动力&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统拥塞控制算法并&lt;/span&gt;&lt;span&gt;不是一蹴而就&lt;/span&gt;&lt;span&gt;的，&lt;/span&gt;&lt;span&gt;复杂的网络环境和用户的高要求推动着拥塞控制算法的优化和迭代&lt;/span&gt;&lt;span&gt;，我们看下&lt;strong&gt;基于丢包策略&lt;/strong&gt;的传统拥塞控制算法的几个迭代版本，如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.37299338999055714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoqpYh7el2Jxng4Ir7cCyPmiaBMuqHYDBbsNjWLNOwM1dIvBMds2ZC6MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时还有一类算法是&lt;strong&gt;基于RTT延时策略&lt;/strong&gt;来进行控制的，但是这类算法在发包速率上可能&lt;/span&gt;&lt;span&gt;不够激进&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;竞&lt;/span&gt;&lt;span&gt;争性能不如其他算法&lt;/span&gt;&lt;span&gt;，因此在共享网络带宽时&lt;/span&gt;&lt;span&gt;有失公平性&lt;/span&gt;&lt;span&gt;，但是算法速率曲线却是很&lt;/span&gt;&lt;span&gt;平滑&lt;/span&gt;&lt;span&gt;，我们暂且把这类算法当做&lt;/span&gt;&lt;span&gt;君子&lt;/span&gt;&lt;span&gt;吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4484304932735426&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIo6Yyb3iaI4aIqxALaDAOO9ricmSqMJRWyAZXX51IayLgpvhpClpncjnAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中比较有名的Vegas算法是大约在1995年由亚利桑那大学的研究人员拉里·彼得森和劳伦斯·布拉科夫提出，这个新的TCP拥塞算法以内华达州最大的城市拉斯维加斯命名，后成为TCP Vegas算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于基于RTT的TCP Vegas算法的详细介绍可以查阅文档&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;文档对Vegas算法和New Reno做了一些对比，我们从直观图形上可以看到Vegas算法更加&lt;/span&gt;&lt;span&gt;平滑&lt;/span&gt;&lt;span&gt;，相反New Reno则表现除了较大的波动呈&lt;/span&gt;&lt;span&gt;锯齿状&lt;/span&gt;&lt;span&gt;，如图所示：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5253664036076663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoucj9g0iaroZdKPpm84B7T3rWa0cXzBMqHaibT9hCvjqRDu6NuMntEKWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;887&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上还有更细粒度的分类，由于不是今天的重点，就不再深入展开了，当前使用的拥塞控制算法还是基于丢包Loss-Based作为主流。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.1 拥塞窗口cwnd&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;从流量控制可以知道接收方在header中给出了rwnd接收窗口大小，发送方不能自顾自地按照接收方的rwnd限制来发送数据，因为网络链路是复用的，需要考虑当前链路情况来确定数据量，这也是我们要提的另外一个变量cwnd，笔者找了一个关于rwnd和cwnd的英文解释：&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;Congestion Window (cwnd) is a TCP state variable that limits the amount of data the TCP can send into the network before receiving an ACK. &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;The Receiver Window (rwnd) is a variable that advertises the amount of data that the destination side can receive. &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Together, the two variables are used to regulate data flow in TCP connections, minimize congestion, and improve network performance.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;笔者在rfc5681文档中也看到cwnd的定义：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16338582677165353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gxSQEHy181HmKIBsSibXLv5qpEvcjVskUCmfrcL8ribHTmfaibLNVXRfWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个解释指出了cwnd是在发送方维护的，cwnd和rwnd并不冲突，发送方需要结合rwnd和cwnd两个变量来发送数据，如图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8203017832647462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gGPrSOWYar5DlPw4Uhdibf7jFgtFlRAicWn5u5W1sYhDKicER3jHGqrEUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cwnd的大小和MSS最大数据段有直接关系，MSS是TCP报文段中的数据字段的最大长度，即MSS=TCP报文段长度-TCP首部长度。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2 拥塞控制基本策略&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;拥塞控制是一个动态的过程&lt;/span&gt;，它既要提高带宽利用率发送尽量多的数据又要避免网络拥堵丢包RTT增大等问题，基于这种高要求并不是单一策略可以搞定的，因此TCP的拥塞控制策略实际上是&lt;span&gt;分阶段分策略的综合过程&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42254901960784313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51giaa2fVVYynDUwDeX5KkKmRrebbvBZOpAHCfFysuZfGIof5dE6a8c1PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;有的版本的TCP算法不一定没有快速恢复阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图为典型的包含4个策略的拥塞控制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.513677811550152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51g5hBL8IaeCPuZAUVke9gTEU8CzuQV8o64mice9uwBKVU7e9227gfO6yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;/p&gt;&lt;p&gt;如图为发生超时重传RTO时的过程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5806938159879337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gPjFWGZBk2qzRRx35ZicYtprQTMHRibbxrcC1WEH07s5aHAicTnCeicsiahA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.3 TCP拥塞控制算法常见版本&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;实际上TCP算法有很多版本，每个版本存在一些差异，在这里简单看一下维基百科的介绍：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;TCP+算法名的命名方式最早出现在Kevin Fall和Sally Floyd1996年发布的论文中。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;这两个算法代号取自太浩湖Lake Tahoe和里诺市，两者算法大致一致，对于丢包事件判断都是以重传超时retransmission timeout和重复确认为条件，但是对于重复确认的处理两者有所不同，对于&lt;span&gt;超时重传RTO情况两个算法都是将拥塞窗口降为1个MSS&lt;/span&gt;，然后进入慢启动阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;TCP Tahoe算法&lt;/span&gt;：如果收到三次重复确认即第四次收到相同确认号的分段确认，并且分段对应包无负载分段和无改变接收窗口的话，Tahoe算法则进入快速重传，将慢启动阈值改为当前拥塞窗口的一半，将拥塞窗口降为1个MSS，并重新进入慢启动阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;TCP Reno算法&lt;/span&gt;：如果收到三次重复确认，Reno算法则进入快速重传只将拥塞窗口减半来跳过慢启动阶段，将慢启动阈值设为当前新的拥塞窗口值，进入一个称为快速恢复的新设计阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;TCP New Reno是对TCP Reno中快速恢复阶段的重传进行改善的一种改进算法，New Reno在低错误率时运行效率和选择确认SACK相当，在高错误率仍优于Reno。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;TCP BIC旨在优化高速高延迟网络的拥塞控制，其拥塞窗口算法使用二分搜索算法尝试找到能长时间保持拥塞窗口最大值，&lt;span&gt;Linux内核在2.6.8至2.6.18使用该算法作为默认TCP拥塞算法&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;CUBIC则是比BIC更温和和系统化的分支版本，其使用三次函数代替二分算法作为其拥塞窗口算法，并且使用函数拐点作为拥塞窗口的设置值，&lt;span&gt;Linux内核在2.6.19后使用该算法作为默认TCP拥塞算法&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;TCP PRR是旨在恢复期间提高发送数据的准确性，该算法确保恢复后的拥塞窗口大小尽可能接近慢启动阈值。在Google进行的测试中，能将平均延迟降低3~10%恢复超时减少5%，&lt;span&gt;PRR算法后作为Linux内核3.2版本默认拥塞算法&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt; &lt;p&gt;&lt;span&gt;TCP BBR是由Google设计于2016年发布的拥塞算法&lt;/span&gt;，该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Google在YouTube上应用该算法，将全球平均的YouTube网络吞吐量提高了4%，&lt;span&gt;BBR&lt;/span&gt;&lt;span&gt;之后移植入Linux内核4.9版本&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;3.4 拥塞控制过程详解&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们以典型&lt;span&gt;慢启动、拥塞避免、快速重传、快速恢复&lt;/span&gt;四个过程进行阐述。&lt;/p&gt;&lt;p&gt;慢启动就是对于刚启动的网络连接，发送速度不是一步到位而是试探性增长，具体来说：连接最初建立时发送方初始化拥塞窗口cwnd为m，之后发送方在一个RTT内&lt;span&gt;每收到一个ACK数据包时cwnd线性自增1&lt;/span&gt;，发送方&lt;span&gt;每经过一个RTT时间，cwnd=cwnd*2&lt;/span&gt;指数增长，经过一段时间增长直到cwnd达到慢启动阈值ssthresh。&lt;/p&gt;&lt;p&gt;之后cwnd不再呈指数增长从而进入拥塞避免阶段(注cwnd增长的单位是MSS)，当然如果在慢启动阶段还未到达阈值ssthresh而出现丢包时进入快速重传等阶段，需要注意的是&lt;span&gt;如果网络状况良好RTT时间很短，那么慢启动阶段将很快到达一个比较高的发送速率&lt;/span&gt;，所以将&lt;span&gt;慢启动理解为试探启动&lt;/span&gt;更形象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9506172839506173&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gwNeVoDrtKc4ztKiaJnYv3bckNZL4nfw2nH98iayrpXKl6RMWTHarqYwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;648&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;当慢启动阶段cwnd的值到达ssthresh时就不再疯狂增长，进入更加理性的线性阶段直至发送丢包，本次的阈值ssthresh是上一次发生丢包时cwnd的1/2，因此这是一个承上启下的过程。&lt;/p&gt;&lt;p&gt;本次发送丢包时仍然会调整ssthresh的值，具体拥塞避免增长过程：&lt;span&gt;发送方每收到一个ACK数据包时将cwnd=cwnd+1/cwnd，每经过一个RTT将cwnd自增1&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;TCP作为一个可靠的协议面临的很大的问题就是丢包，丢包就要重传因此发送方需要根据接收方回复的ACK来确认是否丢包了，并且发送方在发送数据之后启动定时器，如图所示：&lt;/p&gt;&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9181446111869032&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51gyu1WibX54jVEVtCgaNp8ia8Vl8Emxbo5KQgOUgrOZoQq23QwqbOY3Vqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;p&gt;RTO是随着复杂网络环境而动态变化的，在拥塞控制中发生超时重传将会极大拉低cwnd，如果网络状况并没有那么多糟糕，&lt;span&gt;偶尔出现网络抖动造成丢包或者阻塞也非常常见&lt;/span&gt;，因此触发的慢启动将降低通信性能，故出现了快速重传机制。&lt;/p&gt;&lt;p&gt;所谓&lt;span&gt;快速重传时相比超时重传而言的&lt;/span&gt;，重发等待时间会降低并且后续尽量避免慢启动，来保证性能损失在最小的程度，如图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8612191958495461&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZUiay9hEHxK6SWYfTdJZ51geyvmD1oNxXzBjIjicibDUMvSnEW6GfhhEbJq8SIwc9mqctz94pib2MvVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;771&quot;/&gt;&lt;/p&gt;&lt;p&gt;快速重传和超时重传的区别在于cwnd在发生拥塞时的取值，&lt;span&gt;超时重传会将cwnd修改为最初的值，也就是慢启动的值，快速重传将cwnd减半，二者都将ssthresh设置为cwnd的一半&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;从二者的区别可以看到，快速重传更加主动，有利于保证链路的传输性能，但是有研究表明3个ACK的机制同样存在问题，本文就不做深入阐述了，感兴趣的读者可以自主查阅。&lt;/p&gt;&lt;p&gt;快速重传是基于对网络状况没有那么糟糕的假设，因此在实际网络确实还算好的时候，快速重传还是很有用的，在很差的网络环境很多算法都很难保证效率的。&lt;/p&gt;&lt;section&gt;在快速重传之后就会进入快速恢复阶段，此时的cwnd为上次发生拥塞时的cwnd的1/2，之后cwnd再线性增加重复之前的过程。&lt;/section&gt;&lt;h2&gt;&lt;span&gt;4.弱网环境的AIMD特性&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我们知道在网络链路中连接的数量是&lt;/span&gt;&lt;span&gt;动态变化且数量巨大的&lt;/span&gt;&lt;span&gt;，每一条连接都面临着一个黑盒子式的网络环境，这并不像我们平时出行时看看地图就知道哪里堵了，为了维护一个好的网络环境，每一条连接都需要遵守一些约定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果连接端都无所顾忌地发生数据包，那么网络链路很快就到了瓶颈了，数据通信完全无法保障，所以要到达一个&lt;/span&gt;&lt;span&gt;稳定高效的网络环境&lt;/span&gt;&lt;span&gt;还是需要费很大心思的，这其中有两个重要的概念：&lt;/span&gt;&lt;span&gt;公平性和收敛性&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说来惭愧笔者在网络上找了很多资料去理解TCP拥塞控制的&lt;/span&gt;&lt;span&gt;公平性和收敛性&lt;/span&gt;&lt;span&gt;，但是仍然没有获得一个很好的权威解释，所以只能结合一些资料和自身的理解去阐述所谓的公平性和收敛性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者认为公平性是相对于网络链路中的所有连接而言的，这些共享链路的连接启动和结束的时间不同，在实际的交互过程中每条连接占有带宽的机会是均等的，并且由于带宽限制连接双方通信的数据量是动态调整并且近似收敛于某个值，也就是呈现一个锯齿状或者更加平滑的波动曲线，对于基于丢包的拥塞控制算法而言&lt;/span&gt;&lt;strong&gt;&lt;span&gt;AIMD线性增乘性减&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;策略起了关键控制作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们来重点看下AIMD特性，先来贴一张经典的图，直观看AIMD的过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.39344262295081966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoh9zic4x7tMaCvtKf3mBFkEtTFp9oD5icA1E2icqSGxicvvsia0CcyJ9IZHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;看看维基百科对于AIMD的定义：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;span&gt;additive-increase/multiplicative-decrease&lt;/span&gt;(AIMD) algorithm is a &lt;span&gt;feedback control algorithm&lt;/span&gt; best known for its use in TCP congestion control.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;AIMD combines &lt;span&gt;linear growth&lt;/span&gt; of the congestion window with an &lt;span&gt;exponential reduction&lt;/span&gt; when congestion is detected.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Multiple flows using AIMD congestion control will &lt;span&gt;eventually converge&lt;/span&gt; to use equal amounts of a shared link.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;The related schemes of multiplicative-increase/multiplicative-decrease (MIMD) and additive-increase/additive-decrease (AIAD) do not reach stability.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;简单翻译一下：线性增加乘性减少算法是一个&lt;/span&gt;&lt;span&gt;反馈控制算法&lt;/span&gt;&lt;span&gt;，因其在TCP拥塞控制中的使用而广为人知，&lt;/span&gt;&lt;span&gt;AIMD将线性增加拥塞窗口和拥塞时乘性减少窗口相结合&lt;/span&gt;&lt;span&gt;，基于AIMD的多个连接理想状态下会达到&lt;/span&gt;&lt;span&gt;最终收敛&lt;/span&gt;&lt;span&gt;，共享相同数量的网络带宽，与其相关的&lt;/span&gt;&lt;span&gt;乘性增乘性减MIMD策略&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;增性加增性减少AIAD&lt;/span&gt;&lt;span&gt;都&lt;/span&gt;&lt;span&gt;无法保证稳定性&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AIMD相比MIMD和AIAD在连接进入拥塞避免阶段使用试探线性加策略而不是乘性加策略&lt;/span&gt;&lt;span&gt;更加安全&lt;/span&gt;&lt;span&gt;，在探测丢包时则大幅度乘性减少到1/2这样对于缓解拥塞会有比较好的效果&lt;/span&gt;&lt;span&gt;更加快速&lt;/span&gt;&lt;span&gt;，相反如果探测到丢包时采用线性减少AD可能拥塞持续的时间会更长，总体来说AIMD算是一个比较简单实用的工程版本的反馈控制，也具备可&lt;/span&gt;&lt;span&gt;工程收敛性&lt;/span&gt;&lt;span&gt;，因而被广泛实用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间拉回20多年前，在&lt;/span&gt;&lt;span&gt;互联网早期&lt;/span&gt;&lt;span&gt;几乎所有的设备都是通过&lt;/span&gt;&lt;span&gt;有线网络&lt;/span&gt;&lt;span&gt;进行连接通信的，这也是拥塞控制在设计之后一直都起到不错作用的重要因素，有线连接的&lt;/span&gt;&lt;span&gt;网络稳定性比较好&lt;/span&gt;&lt;span&gt;，因此把丢包作为网络拥堵的一个特征也很正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再拉回到现在，从2010年之后&lt;/span&gt;&lt;span&gt;移动互联网&lt;/span&gt;&lt;span&gt;蓬勃发展，移动终端的持有量已经可以称为海量，无线网络的引入让网络环境变得更加复杂，因此&lt;/span&gt;&lt;span&gt;不稳定丢包变得更加频繁&lt;/span&gt;&lt;span&gt;，但是这时的&lt;/span&gt;&lt;span&gt;丢包就不一定是网络拥堵&lt;/span&gt;&lt;span&gt;造成的了，因为整个数据包经过多重路由、交换机、基站等基础通信设备每个环节都可能发生异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在弱网环境下，尤其是移动互联网中之前的&lt;/span&gt;&lt;span&gt;基于AIMD的拥塞控制策略可能会由于丢包的出现而大幅降低网络吞吐量&lt;/span&gt;&lt;span&gt;，从而对网络带宽的利用率也大大下降，这时我们采用&lt;/span&gt;&lt;span&gt;更加激进的控制策略&lt;/span&gt;&lt;span&gt;，或许可以获得更好的效果和用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;恶意丢包&lt;/span&gt;&lt;span&gt;的情况下，基于AIMD的拥塞控制确实就相当于被限速了，因为AIMD确实有些&lt;/span&gt;&lt;span&gt;保守谨慎&lt;/span&gt;&lt;span&gt;了，这个其实也很好理解的哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道在移动网络环境下是由终端以无线形式和附近的基站交互数据，之后数据传输至核心网，最后落到具体的服务器所在的有线网络，其中最后一公里的区域属于高延时场景，有线网络属于低延时高带宽场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在国外有相关实验证明弱网环境下RTT的变化对于使用传统拥塞控制算法下网络吞吐量的影响，数据和曲线如图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3291338582677165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIoWUJwqykfZT3KMQICRl3ib66KTeOTmkx2zibY7V1icThr66lZafbn8w2kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5945945945945946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZnFECVAqlaz8tvSsLvZTIo4T7iaC5r5B7jWb2NtRBXnmcdkDRzgRvkp6hsoUTZ2wOhpByDpdGPCtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;实验含义&lt;/strong&gt;：RTT的增大影响了比如CUBIC这类拥塞控制算法的慢启动等阶段，我们知道慢启动阶段&lt;span&gt;每经过1个RTT周期拥塞窗口cwnd将加倍&lt;/span&gt;，但是更大的RTT就意味着发送方以很低的速率发送数据，更多的时间是空闲的，发包的加速度极大将低了，所以整个吞吐量就下降很明显。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看下实验者的原文表述：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The delay before acknowledgment packets are received (= latency) will &lt;span&gt;have an impact on how fast the TCP congestion window increases&lt;/span&gt; (hence the throughput). &lt;/p&gt;&lt;p&gt;When latency is high, it means that &lt;span&gt;the sender spends more time idle (not sending any new packets)&lt;/span&gt;, which reduces how fast throughput grows.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;5.BBR算法基本原理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;BBR算法是个&lt;span&gt;主动的闭环反馈系统&lt;/span&gt;，通俗来说就是根据带宽和RTT延时来不断动态探索寻找合适的发送速率和发送量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看下维基百科对BBR算法的说明和资料：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;相关文献：&lt;span&gt;https://queue.acm.org/detail.cfm?id=3022184&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;TCP BBR(&lt;span&gt;Bottleneck Bandwidth and Round-trip propagation time&lt;/span&gt;)是由Google设计，并于2016年发布的拥塞算法，以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而&lt;span&gt;BBR基于模型主动探测&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;该算法使用网络最近出站数据分组当时的&lt;span&gt;最大带宽&lt;/span&gt;和&lt;span&gt;往返时间&lt;/span&gt;来创建网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;该算法认为随着网络接口控制器逐渐进入千兆速度时，&lt;span&gt;分组丢失不应该被认为是识别拥塞的主要决定因素&lt;/span&gt;，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法例如CUBIC。Google在YouTube上应用该算法，将全球平均的YouTube网络吞吐量提高了4%，在一些国家超过了14%。BBR之后&lt;span&gt;移植入Linux内核4.9版本&lt;/span&gt;，并且对于QUIC可用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;5.1 基于丢包反馈策略可能在的问题&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;基于丢包反馈属于&lt;span&gt;被动式机制&lt;/span&gt;，根源在于这些拥塞控制算法依据是否出现丢包事件来判断网络拥塞做减窗调整，这样就可能会出现一些问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;丢包即拥塞&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;现实中网络环境很复杂会存在错误丢包，很多算法无法很好区分拥塞丢包和错误丢包，因此在存在一定错误丢包的前提下在某些网络场景中并不能充分利用带宽。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;缓冲区膨胀问题BufferBloat&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;网络连接中路由器、交换机、核心网设备等等为了平滑网络波动而存在缓冲区，这些缓存区就像输液管的膨胀部分让数据更加平稳，但是Loss-Based策略在最初就像网络中发生数据类似于灌水，此时是将Buffer全部算在内的，一旦buffer满了，就可能出现RTT增加丢包等问题，就相当于有的容量本不该算在其中，但是策略是基于包含Buffer进行预测的，特别地在深缓冲区网络就会出现一些问题。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;网络负载高但无丢包事件&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;假设网络中的负载已经很高了，只要没有丢包事件出现，算法就不会主动减窗降低发送速率，这种情况下虽然充分利用了网络带宽，同时由于一直没有丢包事件出现发送方仍然在加窗，表现出了较强的网络带宽侵略性，加重了网络负载压力。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;高负载丢包&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;高负载无丢包情况下算法一直加窗，这样可以预测丢包事件可能很快就出现了，一旦丢包出现窗口将呈现乘性减少，由高位发送速率迅速降低会造成整个网络的瞬时抖动性，总体呈现较大的锯齿状波动。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;低负载高延时丢包&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在某些弱网环境下RTT会增加甚至出现非拥塞引起丢包，此时基于丢包反馈的拥塞算法的窗口会比较小，对带宽的利用率很低，吞吐量下降很明显，但是实际上网络负载并不高，所以在弱网环境下效果并不是非常理想。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;5.2 TCP BBR算法基本原理&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前面我们提到了一些Loss-Based算法存在的问题，TCP BBR算法是一种&lt;/span&gt;&lt;span&gt;主动式机制&lt;/span&gt;&lt;span&gt;，简单来说BBR算法不再基于丢包判断并且也不再使用AIMD线性增乘性减策略来维护拥塞窗口，而是分别采样估计极大带宽和极小延时，并用二者乘积作为发送窗口，并且BBR引入了Pacing Rate限制数据发送速率，配合cwnd使用来降低冲击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.1 一些术语&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;BDP&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;BDP是&lt;/span&gt;&lt;span&gt;Bandwidth-Delay Product&lt;/span&gt;&lt;span&gt;的缩写，可以翻译为&lt;/span&gt;&lt;span&gt;带宽延时积&lt;/span&gt;&lt;span&gt;，我们知道带宽的单位是bps(bit per second)，延时的单位是s，这样BDP的量纲单位就是bit，从而我们知道BDP就是衡量一段时间内链路的数据量的指标。这个可以形象理解为&lt;/span&gt;&lt;strong&gt;&lt;span&gt;水管灌水&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;问题，&lt;/span&gt;&lt;span&gt;带宽就是水管的水流速度立方米/s，延时就是灌水时间单位s，二者乘积我们就可以知道当前水管内存储的水量&lt;/span&gt;&lt;span&gt;了，这是BBR算法的一个关键指标，来看一张&lt;/span&gt;&lt;span&gt;陶辉大神文章&lt;/span&gt;&lt;span&gt;中的图以及一些&lt;/span&gt;&lt;span&gt;网络场景中的BDP计算&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8405466970387244&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiahOd3lPQgCnImemQQylP81QiaEUDU9uuSIIRPcTozWQvSarSZmDEZyWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;439&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.2 带宽和延时的测量&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;BBR算法的一些思想在之前的基于延时的拥塞控制算法中也有出现，其中必有有名的是TCP WestWood算法。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;TCP Westwood改良自New Reno，不同于以往其他拥塞控制算法使用丢失来测量，其通过对确认包测量来确定一个合适的发送速度，并以此调整拥塞窗口和慢启动阈值。其改良了慢启动阶段算法为敏捷探测和设计了一种持续探测拥塞窗口的方法来控制进入敏捷探测，使链接尽可能地使用更多的带宽。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;TCP WestWood算法也是基于带宽和延时乘积进行设计的，但是带宽和延时两个指标无法同时测量，因为这两个值是有些矛盾的极值，要测量最大带宽就要发送最大的数据量但是此时的RTT可能会很大，如果要测量最小的RTT那么久意味着数据量非常少最大带宽就无法获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TCP BBR算法采用&lt;/span&gt;&lt;span&gt;交替采样测量两个指标&lt;/span&gt;&lt;span&gt;，取一段时间内的带宽极大值和延时极小值作为估计值，具体的实现本文就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.3 发送速率和RTT曲线&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;前面提到了BBR算法核心是寻找BDP最优工作点，在相关论文中给出了一张组合的曲线图，我们一起来看下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.3318649045521291&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiarUUyiaS2QyCplCFaQhsx2B3BWUz9h3b8K5vtaW65vfO51dB6s9b3lsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.曲线图示说明：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;这张图是由两个图组合而成，目前是展示[&lt;/span&gt;&lt;span&gt;数据发送速率vs网络数据&lt;/span&gt;&lt;span&gt;]和[&lt;/span&gt;&lt;span&gt;RTTvs网络数据]&lt;/span&gt;&lt;span&gt;的关系&lt;/span&gt;&lt;span&gt;，横轴是网络数据数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两个纵轴从上到下分别为RTT和发送速率，并且整个过程分为了3个阶段：&lt;/span&gt;&lt;span&gt;应用限制阶段、带宽限制阶段、缓冲区限制阶段&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.曲线过程说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;app limit应用限制阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在这个阶段是应用程序开始发送数据，目前网络通畅RTT基本保持固定且很小，发送速率与RTT成反比，因此发送速率也是线性增加的，可以简单认为这个阶段有效带宽并没有达到上限，RTT是几乎固定的没有明显增长。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;band limit带宽限制阶段&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;随着发送速率提高，网络中的数据包越来越多开始占用链路Buffer，此时RTT开始增加发送速率不再上升，有效带宽开始出现瓶颈，但是此时链路中的缓存区并没有占满，因此数据还在增加，RTT也开始增加。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;buffer limit缓冲区限制阶段&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;随着链路中的Buffer被占满，开始出现丢包，这也是探测到的最大带宽，这个节点BDP+BufferSize也是基于丢包的控制策略的作用点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;3.一些看法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网上有一些资料都提及到了这张图，其中的一些解释也并不算非常清晰，结合这些资料和自己的认识，笔者认为在网络链路的缓存区没有被使用时RTT为最小延时MinRTT，在网络链路缓冲区被占满时出现最大带宽MaxBW(链路带宽+链路缓存)，但是此时的MaxBW和MinRTT并不是最优的而是水位比较高的水平，有数据表明按照2ln2的增益计算此时为3BDP，&lt;/span&gt;&lt;span&gt;整个过程中MinRTT和MaxBW是分开探测的，因为这二者是不能同时被测量的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;5.2.4 BBR算法的主要过程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;BBR算法和CUBIC算法类似，也同样有几个过程：&lt;/span&gt;&lt;span&gt;StartUp、Drain、Probe_BW、Probe_RTT，来看下这几个状态的迁移情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0029850746268656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaXzsdKUuA6tfmR8FsQGbl2ic6R4JxibXhvLLCgAKCG5efop4BniaMjYiaBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;StartUp慢启动阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;BBR的慢启动阶段类似于CUBIC的慢启动，同样是进行探测式加速区别在于BBR的慢启动使用2ln2的增益加速，过程中即使发生丢包也不会引起速率的降低，而是依据返回的确认数据包来判断带宽增长，直到带宽不再增长时就停止慢启动而进入下一个阶段，需要注意的是在寻找最大带宽的过程中产生了多余的2BDP的数据量，关于这块可以看下英文原文的解释：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;To handle Internet link bandwidths spanning 12 orders of magnitude, Startup implements a binary search for BtlBw by using a gain of 2/ln2 to double the sending rate while delivery rate is increasing. This discovers BtlBw in log2BDP RTTs but creates up to 2BDP excess queue in the process.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Drain排空阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;排空阶段是为了把慢启动结束时多余的2BDP的数据量清空，此阶段发送速率开始下降，也就是单位时间发送的数据包数量在下降，直到未确认的数据包数量&amp;lt;BDP时认为已经排空，也可以认为是RTT不再下降为止，排空阶段结束。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ProbeBW带宽探测阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;经过慢启动和排空之后，目前发送方进入稳定状态进行数据的发送，由于网络带宽的变化要比RTT更为频繁，因此ProbeBW阶段也是BBR的主要阶段，在探测期中增加发包速率如果数据包ACK并没有受影响那么就继续增加，探测到带宽降低时也进行发包速率下降。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ProbeRTT延时探测阶段&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;前面三个过程在运行时都可能进入ProbeRTT阶段，当某个设定时间内都没有更新最小延时状态下开始降低数据包发送量，试图探测到更小的MinRTT，探测完成之后再根据最新数据来确定进入慢启动还是ProbeBW阶段。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;我&lt;/span&gt;&lt;span&gt;们来看一下这四个过程的示意图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.878234398782344&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiagVP4g575v25OZHvpyzsGf0VzicE7lOoRoSBFtCcqXjkkTMy7WGKUN1A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;曲线说明&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;这两个坐标给出了10Mbps和40msRTT的网络环境下CUBIC和BBR的一个对比过程，在上面的图中蓝色表示接收者，红色表示CUBIC，绿色表示BBR，在下面的图中给出了对应上图过程中的RTT波动情况，红色代表CUBIC，绿色代表BBR。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5.3 TCP-BBR算法效果&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;有一些文章认为BBR有鲜明的特点，把拥塞控制算法分为BBR之前和BBR之后，可见BBR还是有一定影响，但是&lt;/span&gt;&lt;span&gt;BBR算法也不是银弹&lt;/span&gt;&lt;span&gt;，不过可以先看看BBR算法在谷歌推动下的一些应用效果，其中包括&lt;/span&gt;&lt;span&gt;吞吐量、RTT、丢包率影响&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5726872246696035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaXdGY3SNFyOGsGWGicMqicabV9SVpIWch8NrtzE9oMzfJfVr0kIWZWvSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6067746686303387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaB4Ev09wu4ZliavL6X6ibTIQDqSlSRBAsnfGic5cA81fEh1icaZjEQjF21g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41853932584269665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ0yd7nJ3kUFTLuQ2Un1EPiaycd5HSmfubJWyp9wmQRe8wsQwa006fu5WLAvL3SFy2qJNz96tqL0VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图中我们可以看到在YouTube应用BBR算法之后，就吞吐量普遍有4%左右的提升，特别地在日本的提升达到14%，RTT的下降更为明显平均降低33%，其中IN(印度地区)达到50%以上，在丢包率测试中BBR并不想CUBIC那么敏感，在丢包率达到5%是吞吐量才开始明显下降。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;6.参考文献&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://cloud.tencent.com/developer/article/1369617&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://cloud.tencent.com/developer/article/1383232&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://queue.acm.org/detail.cfm?id=3022184&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/63888741&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wAkAIFs11qbyZrib5esibV5twhiauuVc7BZicfibEHTSOuIHlnRIQ2mmbwwT1GA7GwG32NFMYIbDNehVUTqqfoZmPoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;个人微信 欢迎交流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>43423e3f62bd4dde8718ed3e8a8790df</guid>
<title>Spring-boot-devtools 快速重启的秘密</title>
<link>https://toutiao.io/k/jcoggn5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文写了 &lt;strong&gt;AOP 插件&lt;/strong&gt; 后，咱们也了解到这个 &lt;strong&gt;ClassLoader&lt;/strong&gt; 的重要，所以今天咱们来聊聊这个热部署神器 &lt;strong&gt;spring-boot-devtools&lt;/strong&gt; 的源码，看看它是怎么用这个 &lt;strong&gt;ClassLoader&lt;/strong&gt;  来实现快速重启，帮我们节省时间的！😝&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;文章概要&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章的主旋律如下👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOIBho3dOxx0npRP8uWLm534FvCqjMTJHfLAQRcraEfmFThWgicicq27Cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;spring.factories&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了 &lt;strong&gt;Springboot 的自动装配原理&lt;/strong&gt; 后（不了解可以看看 4ye 之前写的这篇 👉 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487780&amp;amp;idx=1&amp;amp;sn=618b88be9f5e81659a6a6ce4450972e8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Springboot自动装配原理探索》&lt;/a&gt;），我们直接打开 &lt;strong&gt;spring-boot-devtools&lt;/strong&gt; 源码 ，找到 &lt;strong&gt;spring.factories&lt;/strong&gt; 文件，&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42812006319115326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOSMo7WFNVggRgnvEqY9L6EOXPW0cughQRQqwW7hJAnmn9t6mcjMAeCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一般都本地开发调试的，所以就直接看这个 &lt;strong&gt;LocalDevToolsAutoConfiguration&lt;/strong&gt; 类啦😋&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;LocalDevToolsAutoConfiguration&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到核心点在 &lt;strong&gt;重启和重载&lt;/strong&gt; 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5916824196597353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOMVkHCHRjPcOmjWMJygpJaTtOa6LmicReLcr3m9KOaSjrryAyWnEz19g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主角👇&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5021037868162693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOv9tLibOljS5CuRbXDEKGickNbPOZAz1tGibCuVs3980wib60Hzj3qibvCXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看看这个 &lt;strong&gt;重启&lt;/strong&gt; 中有什么叭😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重启原理介绍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概这么一个思路👇 下面就跟着源码分析啦😄（&lt;strong&gt;文末有源码重启要点流程图&lt;/strong&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6090686274509803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOj0m7l3tJKV9Sdl9xan0H30VhicZJkuN8jy0ibaticIQtetYUemgMKTM4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RestartConfiguration&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有这么些方法👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6709183673469388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgODw7zwpMMgezyXDYMlLuVxNp86dMpGAv1sox3hJVmMpYIkRL5qK9pSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字上分析，这两个方法应该是重点，逻辑上应该是 有一个 &lt;strong&gt;watcher&lt;/strong&gt; 在盯着 &lt;strong&gt;classpath&lt;/strong&gt; ，如果有变动的话，就触发这个 &lt;strong&gt;ClassPathChangedEvent&lt;/strong&gt; 事件 😝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么看看这个 &lt;strong&gt;watcher&lt;/strong&gt; 叭 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClassPathFileSystemWatcher&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2476290832455216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHdfob8717g30kS4EeOlaZwPNMRPfqLB7dsIJdM2k5o9ZZj7T3YJhvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;949&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这里就创建了这个 &lt;strong&gt;ClassPathFileSystemWatcher&lt;/strong&gt; 类 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3411016949152542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOwwGN4mvDTliazWY4UpTM7LJBZARqsPiauibJZcZZXKmmVNcOVxenjzMzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们注意到它实现了三个接口，经过前面 &lt;strong&gt;Spring&lt;/strong&gt; 文章的学习，咱们知道第一步就该看啥了😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247488776&amp;amp;idx=1&amp;amp;sn=d2a396220165427ef155e5ec7470bb00&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《16张图解锁Spring的整体脉络》&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据类的初始化，先看看有 &lt;strong&gt;static&lt;/strong&gt; 相关的代码没，接着看 &lt;strong&gt;构造器&lt;/strong&gt; ，最后就来到这个初始化方法 &lt;strong&gt;afterPropertiesSet&lt;/strong&gt; 啦😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里没有 &lt;strong&gt;static&lt;/strong&gt; 方法，构造器也很简单，就是获取 &lt;strong&gt;FileSystemWatcherFactory&lt;/strong&gt;  ，&lt;strong&gt;ClassPathRestartStrategy&lt;/strong&gt; 和 监视的文件路径，那么就看看 &lt;strong&gt;afterPropertiesSet&lt;/strong&gt; 写了什么叭 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2799208704253215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgO5xurUpTOBGmqncpYEK3QsN1MsPcjGicNN82sh1PFOL9ND23X46gM3lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1011&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClassPathFileChangeListener&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个也不复杂，就监听到文件改变后，发布事件 &lt;strong&gt;ClassPathChangedEvent&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6427860696517413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHopJRkxUEfKVxkfJiblibzyH6dAHjncZbkaiaA7pFibtx0xianY8GMZPsuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FileSystemWatcher&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着就是这个 &lt;strong&gt;start&lt;/strong&gt; 方法啦👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显就是开启一个线程，那么咱们来看看线程中到底在 &lt;strong&gt;run&lt;/strong&gt; 什么🐷&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5205078125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOJYx3pKLVDzG9Vp6DBVkOpVsibRejza5adLvb3UygYaD4fYxp7DXQ7tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到这个任务类 &lt;strong&gt;Watcher&lt;/strong&gt; 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7388888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOcEOa4icGhMnFXxloaPTvvrnIDV7Yn31sBlPibyUdg8TlhlGbZiaBjzb3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现它的任务就是一直 &lt;strong&gt;scan&lt;/strong&gt; ，&lt;strong&gt;pollInterval&lt;/strong&gt; 默认是 &lt;strong&gt;1s&lt;/strong&gt; ，&lt;strong&gt;quietPeriod&lt;/strong&gt; 默认是 &lt;strong&gt;0.4s&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;意思是每次轮询的时间是 &lt;strong&gt;1s&lt;/strong&gt; ，包含中间休息的 &lt;strong&gt;0.4s&lt;/strong&gt; ，休息事件是来确认文件在这个期间没有再次被改动。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改动了的话会回调 &lt;strong&gt;FileChangeListener&lt;/strong&gt; 的 &lt;strong&gt;onChange&lt;/strong&gt; ，对应我们上面的这个 &lt;strong&gt;ClassPathFileChangeListener&lt;/strong&gt; ，会去发布事件 &lt;strong&gt;ClassPathChangedEvent&lt;/strong&gt; 😋&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ApplicationListener&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绕了一大圈，终于描述完了这个监视器 &lt;strong&gt;ClassPathFileSystemWatcher&lt;/strong&gt; ，同时，我们也得把目光移到这个&lt;strong&gt;RestartConfiguration&lt;/strong&gt; 的第二个核心 &lt;strong&gt;监听器&lt;/strong&gt; 👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，这个方法的作用就是&lt;strong&gt;重启应用 restart&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20310880829015543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOW4vzVibdcLW5Slvs0poxcPJojUGQYkjnGpo0oFulK4Lk4I1wJTibSiaGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;965&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重启应用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重启的过程中呢，包括两个步骤，第一步 &lt;strong&gt;stop&lt;/strong&gt; ，第二步 &lt;strong&gt;start&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;stop&lt;/strong&gt; 部分就是毁灭这些东西了，这里也藏了很多细节，有很多并发相关的知识点 😋&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一. &lt;strong&gt;ReentrantLock&lt;/strong&gt;  是写在 &lt;strong&gt;try catch&lt;/strong&gt; 的里面还是外面？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二. 循环里的 &lt;strong&gt;rootContexts&lt;/strong&gt; 其实是 &lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt; 类型的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三. 通过强制的 &lt;strong&gt;OOM&lt;/strong&gt; 来清除所有的 &lt;strong&gt;软/弱引用&lt;/strong&gt; (😱 还有这种操作的！)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.638676844783715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOWgfLvzCOtXdjjoMCNN8a2SxHkBmRGTED10pFOvWe58w9VnODb9crNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;start&lt;/strong&gt; 的过程中，是通过创建这个&lt;strong&gt;重启线程&lt;/strong&gt; &lt;strong&gt;RestartLauncher&lt;/strong&gt; 来实现的，可以发现该类的任务就是找到 &lt;strong&gt;mainclass&lt;/strong&gt; 并调用 &lt;strong&gt;main&lt;/strong&gt; 方法，完成重启。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28982300884955753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOs7XvSUnMUqNQwbIeSGoTmJkWgcG1dzoQjPtxp7nONF1D76qI6iceiccQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在这个过程中，就涉及到这个 &lt;strong&gt;classloader&lt;/strong&gt; 啦。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ClassLoader&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的小伙伴可以发现上面这行代码中，调用到了这个 &lt;strong&gt;ClassLoader&lt;/strong&gt; ，这个 &lt;strong&gt;getContextClassLoader()&lt;/strong&gt; 是属于 &lt;strong&gt;Thread&lt;/strong&gt; 类的，通过它可以获取到当前线程上下文的 &lt;strong&gt;ClassLoader&lt;/strong&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Class.forName(this.mainClassName, &lt;span&gt;false&lt;/span&gt;, getContextClassLoader());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建这个 &lt;strong&gt;RestartLauncher&lt;/strong&gt; 线程时，就已经将咱们这个 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  给传进来了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2573454913880446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHSiaB6vyv9xKEH34MSiccUwPJr35odlEWA3At2IkTaXyXvjmbqviajLPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29514824797843664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOHX9X6YPBKWIGOaWTqn65BrH2F2t6LqUTJ2hEgXa9WyR2Dffa0gQslw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重启时，就直接通过 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  去找到 &lt;strong&gt;main&lt;/strong&gt; 方法，完成重启。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5336225596529284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgO35OAYbCnI57V4Xeial8MsGMhlCnslEgV5bFCEZPSLHxuSn5lUhic1w6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;很明显这里 &lt;strong&gt;破坏了双亲委派机制，先从自身查找，没有的话再去父类查找&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;strong&gt;业务代码&lt;/strong&gt; 都被 &lt;strong&gt;RestartClassLoader&lt;/strong&gt; 加载了，而每次重启都会重新创建这个 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  ，然后去加载业务代码 🐖 （通过传进来的 &lt;strong&gt;URL&lt;/strong&gt;  可以发现）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么到此，这个 &lt;strong&gt;重启&lt;/strong&gt; 的过程就完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;差点忘了，这里还有个默认的监视范围🐷&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;监视策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图👇 默认策略中，这些路径下的文件变化&lt;strong&gt;不被检测&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3897216274089936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOdShgfL1Lia3fHmpPTclgcYpTibnbCeQf77P1He9MJAwUlqoIsiau3ePJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;figcaption&gt;image-20210920230435492&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可通过配置修改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; spring.devtools.restart.exclude=static/**,public/**&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过阅读源码，我们知道了 &lt;strong&gt;spring-boot-devtools&lt;/strong&gt; 是通过自定义 &lt;strong&gt;RestartClassLoader&lt;/strong&gt;  来加载业务代码，并在重启时销毁它，再重新创建，进而重新获取代码，实现这个快速重启的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而其他 &lt;strong&gt;jar&lt;/strong&gt; 包等由另外的 &lt;strong&gt;ClassLoader&lt;/strong&gt;  加载，不受影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，也可以看到 Spring 事件机制 无处不在的身影，还有各种初始化的操作，以及&lt;strong&gt;线程，并发，锁&lt;/strong&gt;在重启过程中的使用，这些就需要小伙伴们打开源码自身感受了，如 &lt;strong&gt;守护线程&lt;/strong&gt;，&lt;strong&gt;ReentrantLock&lt;/strong&gt; ，&lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt; ，&lt;strong&gt;CountDownLatch&lt;/strong&gt; ，甚至 &lt;strong&gt;OOM&lt;/strong&gt; 都能这么用！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有 &lt;strong&gt;重启&lt;/strong&gt; 原来就是 &lt;strong&gt;反射调用 main 方法&lt;/strong&gt; 呀🐷&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重启过程源码要点&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6621923937360179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgOSprdN2BC7DwThL09t34S5g1qPqDCh42qzMibGlPaKETH5JpjyxGicIOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6382289416846653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFdHbCxgHsUmyeCc38jrTgORuc9Tt8ibWiaF5mragdDzwib6wicbpuiaznzGvZW0rfmHBN3x9BoBRbHB2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cbc8c4ff0f2290082c8fbf5a532ecb25</guid>
<title>不管多复杂的系统设计，都离不开这 9 个字</title>
<link>https://toutiao.io/k/636ewsu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7894736842105263&quot; data-type=&quot;png&quot; data-w=&quot;19&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7QRTvkK2qC7JrnsdoLClToqibt8hpbOMraWEXD5Ul8puptGwibA1DKaKqbcY4hOvTicHkWicVSIlgSuEadoRZbnsqg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;无论做什么事情时，我们总是希望能深谙其道、举一反三，找到底层逻辑和运转规律，这就需要我们多加观察、学习、积累、总结，继而形成自己的方法论，上学、做研究、创业、做产品规划、系统设计无不如此。本篇文章想以木笔本人切身经验分享一些B端系统设计的方法和步骤，资浅望轻但赤诚所至，希望对一些新老朋友有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;50%&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7894736842105263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7QRTvkK2qC7JrnsdoLClToqibt8hpbOMraWEXD5Ul8puptGwibA1DKaKqbcY4hOvTicHkWicVSIlgSuEadoRZbnsqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;19&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;几周前的周末和前同事聚餐，回忆一下子被拉回十年前，当时&lt;span&gt;移动互联网刚刚兴起，BAT一夫当关，百团大战热火朝天，微信还在和米聊纷争天下，&lt;/span&gt;大家也正值当年，个个意气风发、横刀立马，&lt;span&gt;记忆最深的事情之一是大家在会议室里分享并讨论互联网和电商是什么关系，京东到底算不算互联网公司，O2O模式是什么？几个一知半解的人以为自己掌握了前沿，为了几个新兴概念争的面红耳赤。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十年一梦，如今互联网早已渗透到我们工作和生活的每一个角落，淘宝京东已被冠以传统电商，移动互联网和O2O早已成了陈旧概念，新零售、直播电商、社区电商、工业互联网、产业互联网这些概念和模式逐一登台亮相，层出不穷，岁月也把我们这帮曾经的小鲜肉打磨成了白发依稀的中年油腻大叔。但值得庆幸的是我们依旧还身处浪潮之中，并没有掉队，大家聊起供应链和互联网模式时依旧热血和好奇，这一刻像极了十年前，时光似乎并没有走远。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我始终相信，在这日新月异的社会里，很多东西外表在不停的变迁，但总能找到一些不变的底层逻辑，就像楼房，装修风格可以千奇百怪，但主体结构建设却大同小异，这才是支撑起整个结构的根本和基石，包含着以客观规律为基础的物理理论和无数前人的智慧结晶，是不会轻易改变的。再比如商业的本质、供应链的模式，还有系统的设计之道等，只要我们在各自的领域里多加观察和提炼，总能找到一些处事的规律和方法，这便是我们自己的方法论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5RzvnmjuSeh0RdibJ7t4rFxls7qtztPIvh3xBHT5WheKictn8pgnUviaGjHQlJjrx445nK8Ol0DkOibX0jvXk2fKNw/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1268.9273356401386&quot; data-cropy1=&quot;181.59169550173013&quot; data-cropy2=&quot;832.6643598615917&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5141955835962145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5RzvnmjuSeh0RdibJ7t4rFxls7qtztPIvIepTO2VSVvTDlEQtkVAqZ2XT93KXtbm2k1Wia6RuQRxpnZcgQk1ceBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做系统设计时，遇到一个业务提的一个新的需求丢过来时，新手小Z经常焦头烂额，就算对既有系统和流程已经很熟悉了，在涉及新的功能时还是漏洞百出，而老道的产品的老A却总能得心应手，即便对过往业务不是很了解，经过几天的学习，也总能设计出一份业务方比较满意的方案，而且漏洞较少。两人的差距在哪呢？不是责任心，不是态度，而是产品底层设计能力。因为老A经过多年摸爬滚打，总结了一套放之四海而皆准的产品法则，这套法则足以让老A驰骋产品界，立马定江山。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小Z对老A仰慕至极，虚心求教，老A笑着送给了小Z9个字：&lt;strong&gt;理流程，定单据，填功能&lt;/strong&gt;。而这9个字正是老A总结的产品箴言，可放诸四海，童叟无欺。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 第一步：理流程。当接到一个新的项目需求时，不要上来就开始聊系统实现，应该先和业务方一起把主干流程梳理一遍，保证流程是通畅无阻且切实可行的。流程理顺了，业务方的诉求也就清晰了，是否可行，哪些环节有坑都一目了然了，同时在梳理的过程中，系统层面的流程节点也比较清晰了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  第二步：定单据。基于业务流程各关键环节的产出归纳出系统的单据和状态，用单据存储业务的过程数据，用状态管理流程的关键节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  第三步：填功能。针对需要系统支持的环节，设计系统功能，并与流程和单据相对应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做系统设计和盖实体大楼流程是一样的，理流程的过程就像做规划，是搞清楚业务诉求和分析可行性的过程，比如这块地未来是要做商业中心还是盖住房，楼间距几何、地面规划如何等；定单据就是打地基，把楼宇的主体结构固定下来，确定结构框架、材质和关键施工环节，然后开始动工；填功能是最后的装修阶段，是在主体结构上进行包装、把最终成果呈现出来。流程是方向、单据是执行，功能是落地，流程决定了要什么，单据设计决定了怎么做，功能实现则决定做成什么样子，三者相应相辉，一起达成业务目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5RzvnmjuSeh0RdibJ7t4rFxls7qtztPIv3swrcI6Qpwd7OWIDjUjXtjry0IWfuoe1ouNn75htNnAXXYGXOnDH5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▲系统设计核心3要素：流程、单据和功能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87843&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;01  &lt;span&gt;理流程：庖丁解牛，理清业务和系统流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在B端业务里，尤其是供应链这一类偏重业务流程和多系统交互的领域，流程是业务开展的基础，几乎所有的需求都来源于流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们接到一个新的需求时，应该花50%以上的时间用于梳理流程，流程的梳理分为业务流程和系统流程两部分，业务流程由业务负责规划，用于描述操作流程的顺序，关键元素是[操作角色][操作节点]；&lt;/span&gt;&lt;span&gt;系统流程由产品经理负责出具，是对业务流程分析后产出的系统交互流程，重在梳理系统之间的交互逻辑，关键元素是[操作系统][系统功能]，下图是业务流程和系统流程的泳道图对比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.43979591836734694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5RzvnmjuSeh0RdibJ7t4rFxls7qtztPIvzPAVHexkUJKheyUoG34qNicLdOVHlbQKfCTSF6e67iabe1IGiaUA0Gf1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▲系统流程图与业务流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据不同的业务场景，流程可以分为主干流程、辅助流程、异常流程三种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）主干流程：处理业务必不可少的主流程，就像树的主干一样，不实现就没法满足业务诉求，比如采购的建单、仓库的收货、上架等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）辅助流程：从主干流程分出来的子流程，如同树的细枝末节，属于锦上添花，实现了有利于业务更好开展，不实现也不会影响，比如导入采购明细、批量收货、批量上架等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）异常流程：出现异常情况的处理流程，也必须实现，否则遇到异常了就出现了流程卡点，比如采购单的驳回、收货错误修改、出库拣货异常等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常来说，主干流程和异常流程优先级最高，必须在项目上线时就要具备，但异常流程因为不经常发生，如果工期赶不上，可以考虑用简单的方案替代（比如业务方线下处理）。辅助流程一般不紧急，可根据资源情况安排，如果项目第一期排不上，可放到后续迭代版本中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.31306081754735793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5RzvnmjuSeh0RdibJ7t4rFxls7qtztPIvkJP061WonVhaSvDRSyiaZ1ZvRtpRdwZ0icnVkQphmWdLwe4qxIrZ8vkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1003&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▲如何梳理流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在梳理业务流程时，我们可以遵循先主干再异常，最后分支的原则，尽量把项目中涉及到的流程以及每一个操作角色、操作环节都清晰的描绘出来，然后再对着操作节点梳理系统功能，有些操作节点是需要系统功能支持的（比如采购建单、收货），就需要有与之对应的系统功能，还有一些是纯线下行为（比如搬运、清扫），则不需要系统功能。另外，操作节点和系统功能并不是一对一的，有的操作可能需要多个功能支持，也可能多个操作只对应一个功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统功能梳理出来以后，我们接着梳理每个功能对应的输入和输出，有些输入和输出只体现在信息流上，有些则需要其它形式的产出。例如仓库收货完成时，我们需要对收货的结果和过程数据保存下来，这是信息层面的输出，同时还需要为收货员打印一张纸质的收货单，这是实体单据输出，在梳理的过程中要对各环节的输入和输出做详细的记录和拆解，这是我们下一步设计单据和状态的依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程梳理的最后一步是做系统划分，将系统功能与当前已有的系统进行匹对，定位每个系统功能的系统边界，如果还没有系统，正好以此梳理结果为依据做系统规划。系统的划分并没有严格的执行标准，有些处于两个系统交界的功能放在A系统也行，B系统也行（例如两个系统交互时，枚举值的映射），这时可以根据架构合理性、资源情况和操作便捷性等因素综合评估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87843&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;02  &lt;span&gt;定单据：框架构建，明确单据和状态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在B端系统中，单据是用来存储和流转业务信息的凭证。系统流程及各环节的产出梳理出来以后，就可以以此规划系统单据和单据状态了。单据有两大核心要素：关键属性和流转状态。&lt;span&gt;关键属性来源于流程各环节的产出，记录业务开展过程中的详细数据，流转状态设计来源于系统关键节点的变化，记录流程的流转过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统流程的每一个环节都会有输入和输出，输出的信息需要保存下来，这些信息就是单据的属性，也是最原始的单据数据，还是下一环节的输入数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们试着对各环节的产出数据进行提炼，如果发现下一环节与上一环节的信息集合一样，只有个别信息不同，则可以将这两个环节设计为一个单据，但如果差异非常大，就需要设计成不同的单据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 例如下图中，采购的结果会生成采购单，我们需要设计一张采购单来承载采购的所有信息，收货的输入信息来源于采购明细，但由于收货结论与采购明细相差很大，两者并不是一个维度的数据集合，采购单产生于采购系统，收货则是在仓储系统，一条采购明细会生成多条收货明细，所以收货结论需要单独设计一张收货单来承载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，收货结论会作为验收的输入信息，但验收和收货只是入库流程中的两个环节，并无很大的差异，所以可以统一设计到收货单中，根据状态加以区分（当然不同业务形态下的流程不尽相同，如果验收需要对收货结论进一步拆分或合并，则二者就无法共用单据存储，就需要设计不同的单据了）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4544544544544545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5RzvnmjuSeh0RdibJ7t4rFxls7qtztPIvHAI2ib6lYUMurUQqu8RFQhpRv2ebaSRGhT4w5smaamSNbo5YzDDsBNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;999&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▲如何定义单据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统流程的流转是基于单据的流转状态来的，单据流转状态是单据的非常重要的属性，也是驱动流程流转的灵魂。状态设计来源于&lt;span&gt;系统关键节点的变化，在规划状态时，我们需要把系统流程从头到尾所有的节点都整理成线，然后挑出哪些是影响流程流转的关键节点，对节点的流向结果进行提炼，便得到了单据的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如仓库入库流程中，供应商到货以后，会分别进行①供应商签到→②仓库收货或拒收（合格品验收，不合格拒收）→③仓库验收→④仓库入门上架 等4个节点，根据4个节点的输出结论，便能分别设计出供应商签到、收货完成、拒收、验收完成、上架完成等5个收货单状态（当然这只是最简单的举例，实际仓库收货流程会复杂的多），如图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4864864864864865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5RzvnmjuSeh0RdibJ7t4rFxls7qtztPIvKn7jKt2OVtiaJVDrvCfKasiajMJgEvHA06ZUf3va5G5c4QYsceYd1OyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;999&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;▲&lt;/span&gt;&lt;span&gt;根据系统节点设计单据状态&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在设计单据状态时，需要遵循几个原则：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）状态之间应该是平行且互斥的，不能存在交集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）状态之间流转应该有清晰流向，是线型而不是网型，不要相互穿插跳跃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）状态的设计不是凭空捏造的，必须和某个关键节点相呼应，由节点触发状态机流转。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）状态设计最好只有一个开始节点，但可以有多个结束节点（正常结束状态和异常结束状态分开）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5）状态设计应该足够精简，只有对关键逻辑产生影响的节点，才适合设计为状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87843&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;03  &lt;span&gt;填功能：破茧而出，实现系统功能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当流程和单据梳理清晰以后，系统设计就成功了80% 了，最后20%在于系统功能的填充和实现，将功能按照业务需要的风格输出，形成系统原型和需求文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在填充系统功能时，也是有章可循的，我们需要依赖前面所做的流程梳理和系统单据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）首先，将流程节点中的线下操作流程和系统处理流程进行分类，只有系统处理流程是需要实现系统功能的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）接着，基于各环节的输入和输出信息设计对应的功能。功能包含带页面的操作性功能，以及不需要页面的系统逻辑处理功能，输入信息对应到系统功能上通常是查询条件、信息录入、导入等功能，输出信息通常对应查询结果、存储信息、操作日志、导出等功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）然后，将关键功能与&lt;span&gt;单据的状态变更结合起来，梳理出每个功能的详细逻辑以及对应的单据状态变更，系统功能便设计完成了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）最后，功能设计完以后，将系统功能和非系统功能串在一起验证一下是否和业务流程预期一致，不能出现流程盲区和卡点，若有，则继续完善，直到整个业务流程通畅无阻。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在设计B端系统功能设计时，可以参考尼尔森经典十原则，同时一定要遵循实用大于美观的原则，这里总结几个设计小贴士：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）页面功能应该分清主次，页面越简单越好，这样的学习成本和实现成本最低，拒绝花里胡哨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）同一个系统内各页面设计的控件、页面布局、风格、颜色、字体应该统一，且符合大众操作习惯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）如果可以，页面应该聚焦，尽量在一个页面完成核心操作，少做跳转，因为每一次跳转都是动作和时间上的浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）批量操作很有用，例如查询时可以查多个SKU、操作时可以批量审核等，系统的一个批量功能，可能会给业务的操作效率带来飞跃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5）操作记录很重要，当出现问题需要排查时，日志是案发现场最好的黑匣子，所以无论如何，核心操作的日志功能不要省，否则总有一天，会为自己的一时懒惰埋单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（6）设计一个好的灰度策略，通过新老流程并行，由老流程逐步过渡到新流程，有问题了也可以随时切换，可以极大的降低项目风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上便是老A的系统设计9字箴言了，掌握了这个方法，再复杂的系统设计也能够层层剖析，直到最终落地，如庖丁解牛。方法本身并不神奇，其实就是需求分析和拆解的过程，但&lt;span&gt;知易行难，每一步的技能磨练都需要我们怀谦卑之心深扎到一线去摸爬滚打才能慢慢领悟，这个过程叫做经验，不经历就无法得验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果问我有没有更快的系统设计成长技巧，答案是肯定的，就两个字：实战！百闻不如一见，百看不如一试，唯有多加实战才能在真实的业务环境和项目压力中迅速成长，继而逐渐找到自己的方法论，以不变之策应万变之事。 到那时，你且看他&lt;/span&gt;…&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（正文完）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;吃饭席间，我问了森哥一个问题：”创业十多年了，你最大的收获是什么？”。森哥是我们当年的项目经理，团队的带头大哥，酒量惊人，曾经和甲方的一位意气相投的同乡相见恨晚，喝了个通宵，后来连续创业，现在已经是两家公司的创始人，虽然公司还不够大，但都已经盈利了，而且茁壮成长，未来可期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;森哥想了想，自豪的说：“最大的收获是找到了一些创业和让企业盈利的方法，现在就算换个赛道，给我两年时间，我也可以把一家公司做到盈利”。盈利，听起来并不难，但要想持续发展，却是非常困难的，我查了一下数据，互联网公司的扭亏为盈的平均周期是5年，2018年2019年期间，在港股和美股上市的48家互联网公司，有28家处于亏损状态，其中有19家已经至少连续三年亏损。可想而知，就算是上市，想盈利依旧很难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;森哥的话是一句没有对赌的玩笑，无从考证，但从他另外两家公司的经营模式和现状来看，我选择相信，同时更加相信创业和盈利都是有章可循的，就像我们做系统设计一样，掌握了方向和底层个规律，连续成功是完全可以的，只要足够努力、足够勤奋，当然，还需要有足够的远见和魄力，以及资源、人脉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老当益壮，宁移白首之心。&lt;span&gt;对于强者而言，时光可以摧毁他们的外表，却无法吞噬他们的内心，经历越多他们只会更加通透，继而越加强大，越加能够驾驭时光。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;—&lt;/span&gt;END&lt;/span&gt;&lt;span&gt;—&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4MjAyMzMzMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5RzvnmjuSeh4ia0kLmjnyyWWVIE6wSrz6PvB4BQiaWHfwa9VvYbsuxre5LpXAkicdBD0KK7M0ZYRRhNBEqL3emfnw/0?wx_fmt=png&quot; data-nickname=&quot;供应链产品笔记&quot; data-alias=&quot;mubi_note&quot; data-signature=&quot;产品一俗生，耕于供应链，偶有绵薄书，奋笔同君阅。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你喜欢这篇文章，欢迎关注作者公众号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也欢迎你扫码添加我的个人微信，并加入中国(可能)&lt;/span&gt;&lt;span&gt;最大的SaaS微信群&lt;/span&gt;&lt;span&gt;。已有1.4万+来自Salesforce、SAP、企业微信、阿里云、北森等公司的SaaS产品经理、高管和创始人加入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在加入，还可以加入星友会，&lt;/span&gt;&lt;span&gt;和CEO做同学&lt;/span&gt;&lt;span&gt;哦~&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100004409&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/d4z2rM2rYKPP9MNJm0VHYa8QGFBTTSQxNLxvFjfakbT3OqhhoGy4Dby5CmZ2ibftGDsA7TekAMf48I5icudRC6lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;您的随手&lt;/span&gt;&lt;strong&gt;&lt;span&gt;“在看”&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;是我莫大的鼓励&lt;/span&gt;&lt;span&gt; &lt;span&gt;↓&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>