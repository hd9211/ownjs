<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>083ba4851def872a5d5de52dd01cce64</guid>
<title>Golang 调试分析的高阶技巧</title>
<link>https://toutiao.io/k/p2sogse</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;大纲&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Golang tools&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;nm&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;compile&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;objdump&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;pprof&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;trace&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;单元测试&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;程序 Debug&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;小技巧&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;Golang 高阶调试&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文专注 golang debug 的一些技巧应用，以及相关工具的实用用法，再也不用怕 golang 怎么调试。golang 作为一门现代化语音，出生的时候就自带完整的 debug 手段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;golang tools 是直接集成在语言工具里，支持内存分析，cpu分析，阻塞锁分析等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;delve，gdb 作为最常用的 debug 工具，让你能够更深入的进入程序调试；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;delve 当前是最友好的 golang 调试程序，ide 调试其实也是调用 dlv 而已，比如 goland；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;单元测试的设计深入到语言设计级别，可以非常方便执行单元测试并且生成代码覆盖率；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Golang tools&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang 从语言原生层面就集成了大量的实用工具，这些都是 Robert Griesemer, Rob Pike, Ken Thompson 这几位大神经验沉淀下的精华。你安装好 golang 之后，执行 &lt;code&gt;go tool&lt;/code&gt; 就能看到内置支持的所有工具了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@ubuntu:~&lt;span&gt;# go tool&lt;/span&gt;&lt;br/&gt;addr2line&lt;br/&gt;asm&lt;br/&gt;buildid&lt;br/&gt;cgo&lt;br/&gt;compile&lt;br/&gt;cover&lt;br/&gt;dist&lt;br/&gt;doc&lt;br/&gt;fix&lt;br/&gt;link&lt;br/&gt;nm&lt;br/&gt;objdump&lt;br/&gt;pack&lt;br/&gt;pprof&lt;br/&gt;test2json&lt;br/&gt;trace&lt;br/&gt;vet&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里专注挑选几个 debug 常用的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;nm：查看符号表（等同于系统 &lt;code&gt;nm&lt;/code&gt; 命令）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;objdump：反汇编工具，分析二进制文件（等同于系统 &lt;code&gt;objdump&lt;/code&gt; 命令）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pprof：指标，性能分析工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cover：生成代码覆盖率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;trace：采样一段时间，指标跟踪分析工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compile：代码汇编&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;nm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看符号表的命令，等同于系统的 nm 命令，非常有用。在断点的时候，如果你不知道断点的函数符号，那么用这个命令查一下就知道了（命令处理的是二进制程序文件）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# exmple 为你编译的二进制文件&lt;/span&gt;&lt;br/&gt;go tool nm ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一列是地址，第二列是类型，第三列是符号：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.43540183112919634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtzErnNyN1xZP029OJnpl4Ira8cQ7tq9YK42ibXEaBszVyLnEibZzSBYibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;compile&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇编某个文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool compile -N -l -S example.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你就能看到你 golang 语言对应的汇编代码了（注意了，命令处理的是 golang 代码文本），酷。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;objdump&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反汇编二进制的工具，等同于系统 &lt;code&gt;objdump&lt;/code&gt;（注意了，命令解析的是二进制格式的程序文件）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool objdump example.o&lt;br/&gt;go tool objdump -s DoFunc example.o  // 反汇编具体函数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;汇编代码这个东西在 90% 的场景可能都用不上，但是如果你处理过 c 的程序，在某些特殊场景，通过反汇编一段逻辑来推断应用程序行为将是你唯一的出路。因为线上的代码一般都是会开启编译优化，所以这里会导致你的代码对不上。再者，线上不可能让你随意 attach 进程，很多时候都是出 core 了，你就只有一个 core 文件去排查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;pprof&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 支持四种类型的分析：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU ：CPU 分析，采样消耗 cpu 的调用，这个一般用来定位排查程序里耗费计算资源的地方；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memroy ：内存分析，一般用来排查内存占用，内存泄露等问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Block ：阻塞分析，会采样程序里阻塞的调用情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Mutex ：互斥锁分析，采样互斥锁的竞争情况；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里详细以内存占用分析举例（其他的类似），pprof 这个是内存分析神器。基本上，golang 有了这个东西，99% 的内存问题（比如内存泄露，内存占用过大等等）都是可以非常快的定位出来的。首先，对于 golang 的内存分析（或者其他的锁消耗，cpu 消耗）我们明确几个重要的点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;golang 内存 pprof 是采样的，每 512KB 采样一次；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang 的内存采样的是堆栈路径，而不是类型信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang 的内存采样入口一定是通过&lt;code&gt;mProf_Malloc&lt;/code&gt;，&lt;code&gt;mProf_Free&lt;/code&gt; 这两个函数。所以，如果是 cgo 分配的内存，那么是没有机会调用到这两个函数的，所以如果是 cgo 导致的内存问题，go tool pprof 是分析不出来的；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细原理，可以复习另一篇文章：内存分析；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析的形式有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是 &lt;code&gt;net/http/pporf&lt;/code&gt; 方式开启的，那么可以直接在控制台上输入，浏览器就能看；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种方式是先把信息 dump 到本地文件，然后用 &lt;code&gt;go tool&lt;/code&gt; 去分析（我们以这个举例，因为这种方式才是生产环境通用的方式）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 查看累计分配占用&lt;/span&gt;&lt;br/&gt;go tool pprof -alloc_space ./29075_20190523_154406_heap&lt;br/&gt;&lt;span&gt;# 查看当前的分配占用&lt;/span&gt;&lt;br/&gt;go tool pprof -inuse_space ./29075_20190523_154406_allocs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以不指定类型，直接 &lt;code&gt;go tool pprof ./xxx&lt;/code&gt; ，进入分析之后，调用 &lt;code&gt;o&lt;/code&gt; 选项，指定类型：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我写了一个 demo 程序，然后 dump 出了一份 heap 的 pprof 采样文件，我们先通过这个 pprof 得出一些结论，最后我再贴出源代码，再品一品。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool pprof ./29075_20190523_154406_heap&lt;br/&gt;(pprof) o              &lt;br/&gt;...          &lt;br/&gt;  sample_index              = inuse_space          //: [alloc_objects | alloc_space | inuse_objects | inuse_space]&lt;br/&gt;...       &lt;br/&gt;(pprof) alloc_space&lt;br/&gt;(pprof) top&lt;br/&gt;Showing nodes accounting &lt;span&gt;for&lt;/span&gt; 290MB, 100% of 290MB total&lt;br/&gt;      flat  flat%   sum%        cum   cum%&lt;br/&gt;     140MB 48.28% 48.28%      140MB 48.28%  main.funcA (inline)&lt;br/&gt;     100MB 34.48% 82.76%      190MB 65.52%  main.funcB (inline)&lt;br/&gt;      50MB 17.24%   100%      140MB 48.28%  main.funcC (inline)&lt;br/&gt;         0     0%   100%      290MB   100%  main.main&lt;br/&gt;         0     0%   100%      290MB   100%  runtime.main&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 top 信息表明了这么几点信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcA&lt;/code&gt;  这个函数现场分配了 140M 的内存，&lt;code&gt;main.funcB&lt;/code&gt; 这个函数现场分配了 100M 内存，&lt;code&gt;main.funcC&lt;/code&gt; 现场分配了 50M 内存；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;现场的意思：纯粹自己函数直接分配的，而不是调用别的函数分配的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些信息通过 flat 得知；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcA&lt;/code&gt;  分配的 140M 内存纯粹是自己分配的，没有调用别的函数分配过内存；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcA&lt;/code&gt; flat 和 cum 都为 140 M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcB&lt;/code&gt;  自己分配了 100MB，并且还调用了别的函数，别的函数里面涉及了 90M 的内存分配；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcB&lt;/code&gt; flat 和 cum 分别为 100 M，190M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.funcC&lt;/code&gt;  自己分配了 50MB，并且还调用了别的函数，别的函数里面涉及了 90M 的内存分配；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个信息通过 &lt;code&gt;main.funcC&lt;/code&gt; flat 和 cum 分别为 50 M，140 M 得出；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;main.main&lt;/code&gt; ：所有分配内存的函数调用都是走这个函数出去的。main 函数本身没有函数分配，但是他调用的函数分配了 290M；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;demo 的源代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcB&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; b := funcA()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a, b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;funcC&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;([]&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;, []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; b, c := funcB()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a, b, c&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++ {&lt;br/&gt;  funcA()&lt;br/&gt;  funcB()&lt;br/&gt;  funcC()&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;0.0.0.0:9999&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;dump 命令&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -sS &lt;span&gt;&#x27;http://127.0.0.1:9999/debug/pprof/heap?seconds=5&#x27;&lt;/span&gt; -o heap.pporf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对照着代码，再品一品。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;trace&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序 trace 调试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool trace -http=&lt;span&gt;&quot;:6060&quot;&lt;/span&gt; ./ssd_336959_20190704_105540_trace&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;trace 这个命令允许你跟踪采集一段时间的信息，然后 dump 成文件，最后调用 &lt;code&gt;go tool trace&lt;/code&gt; 分析 dump 文件，并且以 web 的形式打开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;单元测试&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试的重要性就不再论述。golang 里面 &lt;code&gt;_test.go&lt;/code&gt; 结尾的文件认为是测试文件，golang 作为现代化的语言，语言工具层面支持单元测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;执行单元测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行单元测试有两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;go test 直接运行，这个是最简单的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;先编译测试文件，再运行。这种方式更灵活；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;go test 运行&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 直接在你项目目录里运行 go &lt;span&gt;test&lt;/span&gt; .&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; .&lt;br/&gt;// 指定运行函数&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -run=TestPutAndGetKeyValue&lt;br/&gt;// 打印详细信息&lt;br/&gt;go &lt;span&gt;test&lt;/span&gt; -v&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编译，运行&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上，golang 跑单测是先编译 &lt;code&gt;*_test.go&lt;/code&gt; 文件，编译成二进制后，再运行这个二进制文件。你执行 &lt;code&gt;go test&lt;/code&gt; 的时候，工具帮你做好了，这些动作其实也是可以拆开来自己做的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译生成单元测试可执行文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 先编译出 .&lt;span&gt;test&lt;/span&gt; 文件&lt;br/&gt;$ go &lt;span&gt;test&lt;/span&gt; -c &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 指定跑某一个文件&lt;br/&gt;$ ./raftexample.test -test.timeout=10m0s -test.v=&lt;span&gt;true&lt;/span&gt; -test.run=TestPutAndGetKeyValue&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式通常会出现在以下几种场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这台机器上编译，另一个地方跑单测；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;debug 单测程序；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;统计代码覆盖率&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang 的代码覆盖率是基于单测的，由单测作为出发点，来看你的业务代码覆盖率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作很简单：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加一个 &lt;code&gt;-coverprofile&lt;/code&gt; 的参数，声明在跑单测的时候，记录代码覆盖率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;go tool cover&lt;/code&gt; 命令分析，得出覆盖率报告；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -coverprofile=coverage.out&lt;br/&gt;go tool cover -func=coverage.out&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@ubuntu:~/opensource/readcode-etcd-master/src/go.etcd.io/etcd/contrib/raftexample&lt;span&gt;# go tool cover -func=coverage.out&lt;/span&gt;&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/httpapi.go:33: ServeHTTP  25.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/httpapi.go:108: serveHttpKVAPI  0.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:41: newKVStore  100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:50: Lookup   100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:57: Propose   75.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:71: readCommits  55.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:107: getSnapshot  100.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/kvstore.go:113: recoverFromSnapshot 85.7%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/listener.go:30: newStoppableListener 75.0%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/listener.go:38: Accept   92.9%&lt;br/&gt;go.etcd.io/etcd/v3/contrib/raftexample/main.go:24: main   0.0%&lt;br/&gt;total:       (statements)  57.1%&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话，你就知道每个函数的代码覆盖率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;程序 Debug&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的调试主要由两个工具：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;dlv&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gdb&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里推荐 dlv，因为 gdb 功能实在是有限，gdb 不理解 golang 的业务类型和协程。但是 gdb 有一个功能是无法替代的，就是 gcore 的功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;dlv 调试用法&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试二进制&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; &amp;lt;path/to/binary&amp;gt; [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dlv 调试二进制，并带参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv &lt;span&gt;exec&lt;/span&gt; ./example -- --audit=./d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试进程&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv attach &lt;span&gt;${pid}&lt;/span&gt; [executable] [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程号是必选的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv attach 12808 ./example&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试 core 文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dlv 调试core文件；并且标准输出导出到文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv core &amp;lt;executable&amp;gt; &amp;lt;core&amp;gt; [flags]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dlv core ./example core.277282&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调试常用语法&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;系统整理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;程序运行&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;call ：call 函数（注意了，这个会导致整个程序运行的）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;continue ：往下运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next ：单步调试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;restart ：重启&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;step ：单步调试，某个函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;step-instruction ：单步调试某个汇编指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stepout ：从当前函数跳出&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;断点相关&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;break (alias: b) ：设置断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;breakpoints (alias: bp)  ：打印所有的断点信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clear ：清理断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clearall ：清理所有的断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;condition (alias: cond)  ：设置条件断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;on ：设置一段命令，当断点命中的时候&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;trace (alias: t) ：设置一个跟踪点，这个跟踪点也是一个断点，只不过运行道德时候不会断住程序，只是打印一行信息，这个命令在某些场景是很有用的，比如你断住程序就会影响逻辑（业务有超时），而你仅仅是想打印某个变量而已，那么用这种类型的断点就行；；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;信息打印&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;args : 打印程序的传参&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;examinemem (alias: x)  ：这个是神器，解析内存用的，和 gdb 的 x 命令一样；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;locals ：打印本地变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;print (alias: p) ：打印一个表达式，或者变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;regs ：打印寄存器的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set ：set 赋值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;vars ：打印全局变量（包变量）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;whatis ：打印类型信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;协程相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;goroutine (alias: gr) ：打印某个特定协程的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutines (alias: grs)  ：列举所有的协程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;thread (alias: tr) ：切换到某个线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threads ：打印所有的线程信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;栈相关&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;deferred ：在 defer 函数上下文里执行命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;down ：上堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;frame ：跳到某个具体的堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stack (alias: bt)  ：打印堆栈信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;up ：下堆栈&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他命令&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;config ：配置变更&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;disassemble (alias: disass) ：反汇编&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;edit (alias: ed) ：略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exit (alias: quit | q) ：略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;funcs ：打印所有函数符号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libraries ：打印所有加载的动态库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;list (alias: ls | l) ：显示源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;source ：加载命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sources ：打印源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;types ：打印所有类型信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是完整的 dlv 的支持的命令，从这个来看，是完全满足我们的调试需求的（有的只适用于开发调试环节，比如线上的程序不可能让你随意单步调试的，有的使用于线上生产环节）。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用举例&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印全局变量&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) vars&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个非常有用，帮助你看一些全局变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;条件断点&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 先断点&lt;/span&gt;&lt;br/&gt;(dlv) b &lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 查看断点信息&lt;/span&gt;&lt;br/&gt;(dlv) bp&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 然后定制条件&lt;/span&gt;&lt;br/&gt;(dlv) condition 2 i==2 &amp;amp;&amp;amp; j==7 &amp;amp;&amp;amp; z==32&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看堆栈&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 展示所有堆栈&lt;/span&gt;&lt;br/&gt;(dlv) goroutines&lt;br/&gt;&lt;span&gt;# 所有堆栈展开&lt;/span&gt;&lt;br/&gt;(dlv) goroutines -t&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解析内存&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(dlv) x -fmt hex -len 20 0xc00008af38&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;x&lt;/code&gt; 命令和 gdb 的 &lt;code&gt;x&lt;/code&gt; 是一样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gdb 调试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gdb 对 golang 的调试支持是通过一个 python 脚本文件 &lt;code&gt;src/runtime/runtime-gdb.py&lt;/code&gt; 来扩展的，所以功能非常有限。gdb 只能做到最基本的变量打印，却理解不了 golang 的一些特殊类型，比如 channel，map，slice 等，gdb 原生是无法调适 goroutine 协程的，因为这个是用户态的调度单位，gdb 只能理解线程。所以只能通过 python 脚本的扩展，把协程结构按照链表输出出来，支持的命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.43457943925233644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtKelWeTNYiaWaDr9BrbjuyC4YORJcKttKnlMyNl6ZGUQs17a9Qksedbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gdb当前只支持6个命令：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3个 cmd 命令&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;info goroutines；打印所有的goroutines&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutine ${id} bt；打印一个goroutine的堆栈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iface；打印静态或者动态的接口类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3个函数&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;len；打印string，slices，map，channels 这四种类型的长度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cap；打印slices，channels 这两种类型的cap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dtype；强制转换接口到动态类型。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印全局变量&lt;/strong&gt; (注意单引号)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(gdb) p &lt;span&gt;&#x27;runtime.firstmoduledata&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 gdb 不理解 golang 的一些类型系统，所以调试打印的时候经常打印不出来，这个要注意下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打印数组变量长度&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(gdb) p &lt;span&gt;$len&lt;/span&gt;(xxx)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我一般只用 gdb 来 gcore 而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;小技巧&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道怎么断点函数？&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候不知道怎么断点函数：可以通过nm查询下，然后再断点，就一定能断到了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.22040816326530613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtJjIAnEVLaCISe9ibaPELKN18v9GprR970Jonh6mSCAjNjxuwlcEFkYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.07482014388489208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChOjKKUqUH7qJInwJdQGPKmtvtDBf67HhQantibQ4RscF07VSNic1lMkDXJTlsSPL1pnDFianLT3Wic5Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道调用上下文？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在你的代码里添加一行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;debug.PrintStack()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能当前代码位置的堆栈给打印出来，这样你就直到怎么函数的调用路径了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不知道怎么开启 pprof ？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 功能有两种开启方式，对应两种包：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;net/http/pprof ：使用在 web 服务器的场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime/pprof  ：使用在非服务器应用程序的场景；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个本质上是一致的，&lt;code&gt;net/http/pporf&lt;/code&gt; 也只是在 &lt;code&gt;runtime/pprof&lt;/code&gt; 上的一层 web 封装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;net/http/pprof&lt;/code&gt; 方式&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;runtime/pprof&lt;/code&gt; 方式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种通常用于程序调优的场景，程序只是一个应用程序，跑一次就结束，你想找到瓶颈点，那么通常会使用到这个方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// cpu pprof 文件路径&lt;/span&gt;&lt;br/&gt;    f, err := os.Create(&lt;span&gt;&quot;cpufile.pprof&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;    &lt;span&gt;// 开启 cpu pprof&lt;/span&gt;&lt;br/&gt; pprof.StartCPUProfile(f)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; pprof.StopCPUProfile()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么有时候单点调试的时候，总是非预期的执行代码？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况一般是被编译器优化了，比如函数内联了，编译出的二进制删减了无效逻辑、无效参数。这种情况就会导致你 dlv 单步调试的时候，总是非预期的执行，或者打印某些变量打印不出来。这种情况解决方法就是：禁止编译优化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go build -gcflags &lt;span&gt;&quot;-N -l&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5268817204301075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsesdolc6YJHWRf1C8UTPs3scrsXWFoCHYsntUfbpKFrDicJ5tFbLPxBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.5520833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gBJOYg4SEEUvEqC5oO30octlCXHubelsl8Q8jryjW8fJDBj8r4A48RcHDMj7ibJfRRhRWSJUUWNTqiaibDr9dmstQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;192&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该篇文章系统的分享了 golang 程序调试的技巧和用法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;语言工具包里内置 tool 工具，支持汇编，反汇编，pprof 分析，符号表查询等实用功能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语言工具包集成单元测试，代码覆盖率依赖于单元测试的触发；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常用 dlv/gdb 这两个工具作为大杀器，可以分析二进制，进程，core 文件；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5bd19e08f8f16c59decd5ccb2a34626</guid>
<title>十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>13bdd87dbb4eb947074d03a4b4371577</guid>
<title>一顿操作，我把 Table 组件性能提升了十倍</title>
<link>https://toutiao.io/k/tm5eo26</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 表格组件在 Web 开发中的应用随处可见，不过当表格数据量大后，伴随而来的是性能问题：渲染的 DOM 太多，渲染和交互都会有一定程度的卡顿。&lt;/p&gt;&lt;p&gt;通常，我们有两种优化表格的方式：一种是分页，另一种是虚拟滚动。这两种方式的优化思路都是减少 DOM 渲染的数量。在我们公司的项目中，会选择分页的方式，因为虚拟滚动不能正确的读出行的数量，会有 Accessibility 的问题。&lt;/p&gt;&lt;p&gt;记得 19 年的时候，我在 Zoom 已经推行了基于 Vue.js 的前后端分离的优化方案，并且基于 ElementUI 组件库开发了 ZoomUI。其中我们在重构用户管理页面的时候使用了 ZoomUI 的 &lt;code&gt;Table&lt;/code&gt; 组件替换了之前老的用 jQuery 开发的 &lt;code&gt;Table&lt;/code&gt; 组件。&lt;/p&gt;&lt;p&gt;因为绝大部分场景 &lt;code&gt;Table&lt;/code&gt; 组件都是分页的，所以并不会有性能问题。但是在某个特殊场景下：基于关键词的搜索，可能会出现 200 * 20 条结果且不分页的情况，且表格是有一列是带有 &lt;code&gt;checkbox&lt;/code&gt; 的，也就是可以选中某些行进行操作。&lt;/p&gt;&lt;p&gt;当我们去点选其中一行时，发现过了好久才选中，有明显的卡顿感，而之前的 jQuery 版本却没有这类问题，这一比较令人大跌眼镜。难道好好的技术重构，却要牺牲用户体验吗？&lt;/p&gt;&lt;h2&gt;Table 组件第一次优化尝试&lt;/h2&gt;&lt;p&gt;既然有性能问题，那么我们的第一时间的思路应该是要找出产生性能问题的原因。&lt;/p&gt;&lt;h3&gt;列展示优化&lt;/h3&gt;&lt;p&gt;首先，ZoomUI 渲染的 DOM 数量是要多于 jQuery 渲染的 &lt;code&gt;Table&lt;/code&gt; 的，因此第一个思考方向是让 &lt;code&gt;Table&lt;/code&gt; 组件&lt;b&gt;尽可能地减少 DOM 的渲染数量&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;20 列数据通常在屏幕下是展示不全的，老的 jQuery Table 实现很简单，底部有滚动条，而 ZoomUI 在这种列可滚动的场景下，支持了左右列的固定，这样在左右滑动过程中，可以固定某些列一直展示，用户体验更好，但这样的实现是有一定代价的。&lt;/p&gt;&lt;p&gt;想要实现这种固定列的布局，ElementUI 用了 6 个 &lt;code&gt;table&lt;/code&gt; 标签来实现，那么为什么需要 6 个 &lt;code&gt;table&lt;/code&gt; 标签呢？&lt;/p&gt;&lt;p&gt;首先，为了让 &lt;code&gt;Table&lt;/code&gt; 组件支持丰富的表头功能，表头和表体都是各自用一个 &lt;code&gt;table&lt;/code&gt; 标签来实现。因此对于一个表格来说，就会有 2 个 &lt;code&gt;table&lt;/code&gt; 标签，那么再加上左侧 &lt;code&gt;fixed&lt;/code&gt; 的表格，和右侧 &lt;code&gt;fixed&lt;/code&gt; 的表格，总共有 6 个 &lt;code&gt;table&lt;/code&gt; 标签。&lt;/p&gt;&lt;p&gt;在 ElementUI 实现中，左侧 &lt;code&gt;fixed&lt;/code&gt; 表格和右侧 &lt;code&gt;fixed&lt;/code&gt; 表格从 DOM 上都渲染了完整的列，然后从样式上控制它们的显隐：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1528&quot; data-rawheight=&quot;974&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1528&quot; data-rawheight=&quot;974&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-472b8cb204377b120f07e19b6c6933ce_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1546&quot; data-rawheight=&quot;834&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1546&quot; data-rawheight=&quot;834&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-394b1dbcb7fdf3c5b8d53f514c7d8889_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;但这么实现是有性能浪费的，因为完全不需要渲染这么多列，实际上只需要渲染固定展示的列的 DOM，然后做好高度同步即可。ZoomUI 就是这么实现的，效果如下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1570&quot; data-rawheight=&quot;746&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1570&quot; data-rawheight=&quot;746&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9f438772d7d2fce3b4ada403739da210_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;当然，仅仅减少 &lt;code&gt;fixed&lt;/code&gt; 表格渲染的列，性能的提升还不够明显，有没有办法在列的渲染这个维度继续优化呢？&lt;/p&gt;&lt;p&gt;这就是从业务层面的优化了，对于一个 20 列的表格，往往关键的列并没有多少，那么我们可不可以初次渲染仅仅渲染关键的列，其它列通过配置方式的渲染呢？&lt;/p&gt;&lt;p&gt;根据上述需求，我给 &lt;code&gt;Table&lt;/code&gt; 组件添加了如下功能：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1530&quot; data-rawheight=&quot;674&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1530&quot; data-rawheight=&quot;674&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-153d3f80d6015463f0a25319288cb668_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 组件新增一个 &lt;code&gt;initDisplayedColumn&lt;/code&gt; 属性，通过它可以配置初次渲染的列，同时当用户修改了初次渲染的列，会在前端存储下来，便于下一次的渲染。&lt;/p&gt;&lt;p&gt;通过这种方式，我们就可以少渲染一些列。显然，列渲染少了，表格整体渲染的 DOM 数就会变少，对性能也会有一定的提升。&lt;/p&gt;&lt;h3&gt;更新渲染的优化&lt;/h3&gt;&lt;p&gt;当然，仅仅通过优化列的渲染还是不够的，我们遇到的问题是当点选某一行引起的渲染卡顿，为什么会引起卡顿呢？&lt;/p&gt;&lt;p&gt;为了定位该问题，我用 &lt;code&gt;Table&lt;/code&gt; 组件创建了一个 1000 * 7 的表格，开启了 Chrome 的 Performance 面板记录 &lt;code&gt;checkbox&lt;/code&gt; 点选前后的性能。&lt;/p&gt;&lt;p&gt;在经过几次 &lt;code&gt;checkbox&lt;/code&gt; 选择框的点选后，可以看到如下火焰图：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;574&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;574&quot; data-rawheight=&quot;96&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-05c3dca110282efedc3cf91db2538603_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;其中黄色部分是 &lt;code&gt;Scripting&lt;/code&gt; 脚本的执行时间，紫色部分是 &lt;code&gt;Rendering&lt;/code&gt; 所占的时间。我们再截取一次更新的过程：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-64bdb0d4325a88c58becc2903622afab_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;154&quot; data-rawheight=&quot;122&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;154&quot; data-rawheight=&quot;122&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-64bdb0d4325a88c58becc2903622afab_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;然后观察 JS 脚本执行的 Call Tree，发现时间主要花在了 &lt;b&gt;&lt;code&gt;Table&lt;/code&gt; 组件的更新渲染上&lt;/b&gt;：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;172&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;172&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d016846b0d6b2692642d67f2f0126b98_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现组件的 &lt;code&gt;render to vnode&lt;/code&gt; 花费的时间约 600ms；&lt;code&gt;vnode patch to DOM&lt;/code&gt; 花费的时间约 160ms。&lt;/p&gt;&lt;p&gt;为什么会需要这么长时间呢，因为点选了 &lt;code&gt;checkbox&lt;/code&gt;，在组件内部修改了其维护的选中状态数据，而整个组件的 &lt;code&gt;render&lt;/code&gt; 过程中又访问了这个状态数据，因此当这个数据修改后，会引发整个组件的重新渲染。&lt;/p&gt;&lt;p&gt;而又由于有 1000 * 7 条数据，因此整个表格需要循环 1000 * 7 次去创建最内部的 &lt;code&gt;td&lt;/code&gt;，整个过程就会耗时较长。&lt;/p&gt;&lt;p&gt;那么循环的内部是不是有优化的空间呢？对于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件，这里有非常大的优化空间。&lt;/p&gt;&lt;p&gt;其实优化思路主要参考我之前写的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzIxNDc4MjEzNw%3D%3D%26amp%3Bmid%3D2247484346%26amp%3Bidx%3D1%26amp%3Bsn%3Dca9c3c752c96ce99f5370919ac3354bb%26amp%3Bchksm%3D97a31a6ca0d4937abb4c446498c29ab380d486c141cf0a937124c2d5aa2eb54030e9305b5ef9%26token%3D866091504%26lang%3Dzh_CN%23rd&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《揭秘 Vue.js 九个性能优化技巧》&lt;/a&gt; 其中的 &lt;code&gt;Local variables&lt;/code&gt; 技巧。举个例子，在 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件中，在渲染每个 &lt;code&gt;td&lt;/code&gt; 的时候，有这么一段代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;_self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$vnode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;$index&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的代码相信很多小伙伴随手就写了，但却忽视了其内部潜在的性能问题。&lt;/p&gt;&lt;p&gt;由于 Vue.js 响应式系统的设计，在每次访问 &lt;code&gt;this.store&lt;/code&gt; 的时候，都会触发响应式数据内部的 &lt;code&gt;getter&lt;/code&gt; 函数，进而执行它的依赖收集，当这段代码被循环了 1000 * 7 次，就会执行 &lt;code&gt;this.store&lt;/code&gt; 7000 次的依赖收集，这就造成了性能的浪费，而真正的依赖收集只需要执行一次就足够了。&lt;/p&gt;&lt;p&gt;解决这个问题其实也并不难，由于 &lt;code&gt;Table&lt;/code&gt; 组件中的 &lt;code&gt;TableBody&lt;/code&gt; 组件是用 &lt;code&gt;render&lt;/code&gt; 函数写的，我们可以在组件 &lt;code&gt;render&lt;/code&gt; 函数的入口处定义一些局部变量：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$vnode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在渲染整个 &lt;code&gt;render&lt;/code&gt; 的过程中，把局部变量当作内部函数的参数传入，这样在内部渲染 &lt;code&gt;td&lt;/code&gt; 的渲染中再次访问这些变量就不会触发依赖收集了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;rowRender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ...其它变量 */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;_self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;disableTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;isSelectedRow&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过这种方式，我们把类似的代码都做了修改，就实现了 &lt;code&gt;TableBody&lt;/code&gt; 组件渲染函数内部访问这些响应式变量，只触发一次依赖收集的效果，从而优化了 &lt;code&gt;render&lt;/code&gt; 的性能。&lt;/p&gt;&lt;p&gt;来看一下优化后的火焰图：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9b525075005c56628816abd76107e848_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;412&quot; data-rawheight=&quot;90&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;412&quot; data-rawheight=&quot;90&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9b525075005c56628816abd76107e848_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从面积上看似乎 &lt;code&gt;Scripting&lt;/code&gt; 的执行时间变少了，我们再来看它一次更新所需要的 JS 执行时间：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;156&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;984&quot; data-rawheight=&quot;156&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-db3bd275c63b19dbbae744db5ff8c34c_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现组件的 &lt;code&gt;render to vnode&lt;/code&gt; 花费的时间约 240ms；&lt;code&gt;vnode patch to DOM&lt;/code&gt; 花费的时间约 127ms。&lt;/p&gt;&lt;p&gt;可以看到，ZoomUI &lt;code&gt;Table&lt;/code&gt; 组件的 &lt;code&gt;render&lt;/code&gt; 的时间和 &lt;code&gt;update&lt;/code&gt; 的时间都要明显少于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件。&lt;code&gt;render&lt;/code&gt; 时间减少是由于响应式变量依赖收集的时间大大减少，&lt;code&gt;update&lt;/code&gt; 的时间的减少是因为 &lt;code&gt;fixed&lt;/code&gt; 表格渲染的 DOM 数量减少。&lt;/p&gt;&lt;p&gt;从用户的角度来看，DOM 的更新除了 &lt;code&gt;Scripting&lt;/code&gt; 的时间，还有 &lt;code&gt;Rendering&lt;/code&gt; 的时间，它们是共享一个线程的，当然由于 ZoomUI &lt;code&gt;Table&lt;/code&gt; 组件渲染的 DOM 数量更少，执行 &lt;code&gt;Rendering&lt;/code&gt; 的时间也更短。&lt;/p&gt;&lt;h3&gt;手写 benchmark&lt;/h3&gt;&lt;p&gt;仅仅从 Performance 面板的测试并不是一个特别精确的 benchmark，我们可以针对 &lt;code&gt;Table&lt;/code&gt; 组件手写一个 benchmark。&lt;/p&gt;&lt;p&gt;我们可以先创建一个按钮，去模拟 &lt;code&gt;Table&lt;/code&gt; 组件的选中操作：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;zm-button&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;toggleSelection(computedData[1])
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;切换第二行选中状态
  &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;zm-button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  更新所需时间: {{ renderTime }}
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后实现这个 &lt;code&gt;toggleSelection&lt;/code&gt; 函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;toggleSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$refs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toggleRowSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;renderTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;performance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toFixed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;ms&#x27;&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们在点击事件的回调函数中，通过 &lt;code&gt;window.performance.now()&lt;/code&gt; 记录起始时间，然后在 &lt;code&gt;setTimeout&lt;/code&gt; 的回调函数中，再去通过时间差去计算整个更新渲染需要的时间。&lt;/p&gt;&lt;p&gt;由于 JS 的执行和 UI 渲染占用同一线程，因此在一个宏任务执行过程中，会执行这俩任务，而 &lt;code&gt;setTimeout 0&lt;/code&gt; 会把对应的回调函数添加到下一个宏任务中，当该回调函数执行，说明上一个宏任务执行完毕，此时做时间差去计算性能是相对精确的。&lt;/p&gt;&lt;p&gt;基于手写的 benchmark 得到如下测试结果：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2502&quot; data-rawheight=&quot;552&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2502&quot; data-rawheight=&quot;552&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c9a65a72fd74a5fc4fbbb1725652a161_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;ElementUI &lt;code&gt;Table&lt;/code&gt;组件一次更新的时间约为 900ms。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2634&quot; data-rawheight=&quot;570&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2634&quot; data-rawheight=&quot;570&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2cb6a7c046836c57d580161a75521572_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;ZoomUI &lt;code&gt;Table&lt;/code&gt;组件一次更新的时间约为 280ms，相比于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件，&lt;b&gt;性能提升了约三倍&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;v-memo 的启发&lt;/h2&gt;&lt;p&gt;经过这一番优化，基本解决了文章开头提到的问题，在 200 * 20 的表格中去选中一列，已经并无明显的卡顿感了，但相比于 jQuery 实现的 Table，效果还是要差了一点。&lt;/p&gt;&lt;p&gt;虽然性能优化了三倍，但我还是有个心结：明明只更新了一行数据的选中状态，却还是重新渲染了整个表格，仍然需要在组件 &lt;code&gt;render&lt;/code&gt; 的过程中执行多次的循环，在 &lt;code&gt;patch&lt;/code&gt; 的过程中通过 &lt;code&gt;diff&lt;/code&gt; 算法来对比更新。&lt;/p&gt;&lt;p&gt;最近我研究了 Vue.js 3.2 &lt;code&gt;v-memo&lt;/code&gt; 的实现，看完源码后，我非常激动，因为发现这个优化技巧似乎可以应用到 ZoomUI 的 Table 组件中，尽管我们的组件库是基于 Vue 2 版本开发的。&lt;/p&gt;&lt;p&gt;我花了一个下午的时间，经过一番尝试，果然成功了，那么具体是怎么做的呢？先不着急，我们从 &lt;code&gt;v-memo&lt;/code&gt; 的实现原理说起。&lt;/p&gt;&lt;h3&gt;v-memo 的实现原理&lt;/h3&gt;&lt;p&gt;&lt;code&gt;v-memo&lt;/code&gt; 是 Vue.js 3.2 版本新增的指令，它可以用于普通标签，也可以用于列表，结合 &lt;code&gt;v-for&lt;/code&gt; 使用，在官网文档中，有这么一段介绍：&lt;/p&gt;&lt;blockquote&gt;&lt;code&gt;v-memo&lt;/code&gt; 仅供性能敏感场景的针对性优化，会用到的场景应该很少。渲染 &lt;code&gt;v-for&lt;/code&gt; 长列表 (长度大于 1000) 可能是它最有用的场景：&lt;br/&gt; &lt;/blockquote&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;v-for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;item in list&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;:key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;item.id&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;v-memo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[item.id === selected]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;ID: {{ item.id }} - selected: {{ item.id === selected }}&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;...more child nodes&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt; 当组件的 &lt;code&gt;selected&lt;/code&gt; 状态发生变化时，即使绝大多数 &lt;code&gt;item&lt;/code&gt; 都没有发生任何变化，大量的 VNode 仍将被创建。此处使用的 &lt;code&gt;v-memo&lt;/code&gt; 本质上代表着“仅在 item 从未选中变为选中时更新它，反之亦然”。这允许每个未受影响的 &lt;code&gt;item&lt;/code&gt; 重用之前的 VNode，并完全跳过差异比较。注意，我们不需要把 &lt;code&gt;item.id&lt;/code&gt; 包含在记忆依赖数组里面，因为 Vue 可以自动从 &lt;code&gt;item&lt;/code&gt; 的 &lt;code&gt;:key&lt;/code&gt; 中把它推断出来。&lt;br/&gt; &lt;/blockquote&gt;&lt;p&gt;其实说白了 &lt;code&gt;v-memo&lt;/code&gt; 的核心就是复用 &lt;code&gt;vnode&lt;/code&gt;，上述模板借助于&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//vue-next-template-explorer.netlify.app/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在线模板编译工具&lt;/a&gt;，可以看到其对应的 &lt;code&gt;render&lt;/code&gt; 函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderList&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Fragment&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;openBlock&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createElementBlock&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;toDisplayString&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createElementVNode&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isMemoSame&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;withMemo&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_withMemo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;vue&quot;&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_hoisted_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*#__PURE__*/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;...more child nodes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* HOISTED */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;___&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; - selected: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* TEXT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_hoisted_1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* KEYED_FRAGMENT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基于 &lt;code&gt;v-for&lt;/code&gt; 的列表内部是通过 &lt;code&gt;renderList&lt;/code&gt; 函数来渲染的，来看它的实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;number&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// source 是数字
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// source 是对象
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们只分析 &lt;code&gt;source&lt;/code&gt;，也就是列表 &lt;code&gt;list&lt;/code&gt; 是数组的情况，对于每一个 &lt;code&gt;item&lt;/code&gt;，会执行 &lt;code&gt;renderItem&lt;/code&gt; 函数来渲染。&lt;/p&gt;&lt;p&gt;从生成的 &lt;code&gt;render&lt;/code&gt; 函数中，可以看到 &lt;code&gt;renderItem&lt;/code&gt; 的实现如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;___&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_createElementVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ID: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; - selected: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_toDisplayString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* TEXT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_hoisted_1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_memo&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_item&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;renderItem&lt;/code&gt; 函数内部，维护了一个 &lt;code&gt;_memo&lt;/code&gt; 变量，它就是用来判断是否从缓存里获取 &lt;code&gt;vnode&lt;/code&gt; 的条件数组；而第四个参数 &lt;code&gt;_cached&lt;/code&gt; 对应的就是 &lt;code&gt;item&lt;/code&gt; 对应缓存的 &lt;code&gt;vnode&lt;/code&gt;。接下来通过 &lt;code&gt;isMemoSame&lt;/code&gt; 函数来判断 &lt;code&gt;memo&lt;/code&gt; 是否相同，来看它的实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isMemoSame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;isMemoSame&lt;/code&gt; 函数内部会通过 &lt;code&gt;cached.memo&lt;/code&gt; 拿到缓存的 &lt;code&gt;memo&lt;/code&gt;，然后通过遍历对比每一个条件来判断和当前的 &lt;code&gt;memo&lt;/code&gt; 是否相同。&lt;/p&gt;&lt;p&gt;而在 &lt;code&gt;renderItem&lt;/code&gt; 函数的结尾，就会把 &lt;code&gt;_memo&lt;/code&gt; 缓存到当前 &lt;code&gt;item&lt;/code&gt; 的 &lt;code&gt;vnode&lt;/code&gt; 中，便于下一次通过  &lt;code&gt;isMemoSame&lt;/code&gt; 来判断这个 &lt;code&gt;memo&lt;/code&gt; 是否相同，如果相同，说明该项没有变化，直接返回上一次缓存的 &lt;code&gt;vnode&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那么这个缓存的 &lt;code&gt;vnode&lt;/code&gt; 具体存储到哪里呢，原来在初始化组件实例的时候，就设计了渲染缓存：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;nx&quot;&gt;renderCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在执行 &lt;code&gt;render&lt;/code&gt; 函数的时候，把这个缓存当做第二个参数传入：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instance&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;normalizeVNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;proxyToUse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;proxyToUse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;renderCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;setupState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在执行 &lt;code&gt;renderList&lt;/code&gt; 函数的时候，把 &lt;code&gt;_cahce&lt;/code&gt; 作为第三个参数传入：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_openBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_createElementBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;___&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// renderItem 实现
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* KEYED_FRAGMENT */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以实际上列表缓存的 &lt;code&gt;vnode&lt;/code&gt; 都保留在 &lt;code&gt;_cache&lt;/code&gt; 中，也就是 &lt;code&gt;instance.renderCache&lt;/code&gt; 中。&lt;/p&gt;&lt;p&gt;那么为啥使用缓存的 &lt;code&gt;vnode&lt;/code&gt; 就能优化 &lt;code&gt;patch&lt;/code&gt; 过程呢，因为在 &lt;code&gt;patch&lt;/code&gt; 函数执行的时候，如果遇到新旧 &lt;code&gt;vnode&lt;/code&gt; 相同，就直接返回，什么也不用做了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;patch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;anchor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parentComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parentSuspense&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isSVG&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;slotScopeIds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;optimized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然，由于使用缓存的 &lt;code&gt;vnode&lt;/code&gt;，它们&lt;b&gt;指向同一个对象引用&lt;/b&gt;，直接返回，节约了后续执行 &lt;code&gt;patch&lt;/code&gt; 过程的时间。&lt;/p&gt;&lt;h3&gt;在 Table 组件的应用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;v-memo&lt;/code&gt; 的优化思路很简单，就是复用缓存的 &lt;code&gt;vnode&lt;/code&gt;，这是一种空间换时间的优化思路。&lt;/p&gt;&lt;p&gt;那么，前面我们提到在表格组件中选择状态没有变化的行，是不是也可以从缓存中获取呢？&lt;/p&gt;&lt;p&gt;顺着这思路，我给 &lt;code&gt;Table&lt;/code&gt; 组件设计了 &lt;code&gt;useMemo&lt;/code&gt; 这个 &lt;code&gt;prop&lt;/code&gt;，它其实是专门用于有选择列的场景。&lt;/p&gt;&lt;p&gt;然后在 &lt;code&gt;TableBody&lt;/code&gt; 组件的 &lt;code&gt;created&lt;/code&gt; 钩子函数中，创建了用于缓存的对象：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;created&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rowKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;for useMemo, row-key is required.&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里之所以把 &lt;code&gt;vnodeCache&lt;/code&gt; 定义到 &lt;code&gt;created&lt;/code&gt; 钩子函数中，是因为它并不需要变成响应式对象。&lt;/p&gt;&lt;p&gt;另外注意，我们会根据每一行的 &lt;code&gt;key&lt;/code&gt; 作为缓存的 &lt;code&gt;key&lt;/code&gt;，因此 &lt;code&gt;Table&lt;/code&gt; 组件的 &lt;code&gt;rowKey&lt;/code&gt; 属性是必须的。&lt;/p&gt;&lt;p&gt;然后在渲染每一行的过程中，添加了 &lt;code&gt;useMemo&lt;/code&gt; 相关的逻辑：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowRender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 各种变量参数 */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getKeyOfRow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowKey&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentSelection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;states&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;selection&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isRowSelectionChanged&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cached&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentSelection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 渲染 row，返回对应的 vnode
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowVnode&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;memo&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;memo&lt;/code&gt; 变量用于记录已选中的行数据，并且它也会在函数最后存储到 &lt;code&gt;vnode&lt;/code&gt; 的 &lt;code&gt;memo&lt;/code&gt;，便于下一次的比对。&lt;/p&gt;&lt;p&gt;在每次渲染 &lt;code&gt;row&lt;/code&gt; 的 &lt;code&gt;vnode&lt;/code&gt; 前，会根据 &lt;code&gt;row&lt;/code&gt; 对应的 &lt;code&gt;key&lt;/code&gt; 尝试从缓存中取；如果缓存中存在，再通过 &lt;code&gt;isRowSelectionChanged&lt;/code&gt; 来判断行的选中状态是否改变；如果没有改变，则直接返回缓存的 &lt;code&gt;vnode&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果没有命中缓存或者是行选择状态改变，则会去重新渲染拿到新的 &lt;code&gt;rowVnode&lt;/code&gt;，然后更新到 &lt;code&gt;vnodeCache&lt;/code&gt; 中。&lt;/p&gt;&lt;p&gt;当然，这种实现相比于 &lt;code&gt;v-memo&lt;/code&gt; 没有那么通用，只去对比行选中的状态而不去对比其它数据的变化。你可能会问，如果这一行某列的数据修改了，但选中状态没变，再走缓存不就不对了吗？&lt;/p&gt;&lt;p&gt;确实存在这个问题，但是在我们的使用场景中，遇到数据修改，是会发送一个异步请求到后端，然获取新的数据再来更新表格数据。因此我只需要观测表格数据的变化清空 &lt;code&gt;vnodeCache&lt;/code&gt; 即可：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s1&quot;&gt;&#x27;store.states.data&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此外，我们支持列的可选则渲染功能，以及在窗口发生变化时，隐藏列也可能发生变化，于是在这两种场景下，也需要清空 &lt;code&gt;vnodeCache&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s1&quot;&gt;&#x27;store.states.columns&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;columnsHidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;useMemo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;valueEquals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;vnodeCache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上实现就是基于 &lt;code&gt;v-memo&lt;/code&gt; 的思路实现表格组件的性能优化。我们从火焰图上看一下它的效果：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;458&quot; data-rawheight=&quot;90&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;458&quot; data-rawheight=&quot;90&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-271c295ec40d3d9f55639d27b25d4456_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现黄色的 &lt;code&gt;Scripting&lt;/code&gt; 时间几乎没有了，再来看它一次更新所需要的 JS 执行时间：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_b.png&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1256&quot; data-rawheight=&quot;154&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1256&quot; data-rawheight=&quot;154&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cf0b4269a029eb66573fba5d0fed36ad_b.png&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;我们发现组件的 &lt;code&gt;render to vnode&lt;/code&gt; 花费的时间约 20ms；&lt;code&gt;vnode patch to DOM&lt;/code&gt; 花费的时间约 1ms，整个更新渲染过程，JS 的执行时间大幅减少。&lt;/p&gt;&lt;p&gt;另外，我们通过 &lt;code&gt;benchmark&lt;/code&gt; 测试，得到如下结果：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2546&quot; data-rawheight=&quot;558&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2546&quot; data-rawheight=&quot;558&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ef4bec729742ec52a24ba560f75d0d95_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;优化后，ZoomUI &lt;code&gt;Table&lt;/code&gt;组件一次更新的时间约为 80ms，相比于 ElementUI 的 &lt;code&gt;Table&lt;/code&gt; 组件，&lt;b&gt;性能提升了约十倍&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这个优化效果还是相当惊人的，并且从性能上已经不输 jQuery Table 了，我两年的心结也随之解开了。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 表格性能提升主要是三个方面：减少 DOM 数量、优化 &lt;code&gt;render&lt;/code&gt; 过程以及复用 &lt;code&gt;vnode&lt;/code&gt;。有些时候，我们还可以从业务角度思考，去做一些优化。&lt;/p&gt;&lt;p&gt;虽然 &lt;code&gt;useMemo&lt;/code&gt; 的实现还比较粗糙，但它目前已满足我们的使用场景了，并且当数据量越大，渲染的行列数越多，这种优化效果就越明显。如果未来有更多的需求，更新迭代就好。&lt;/p&gt;&lt;p&gt;由于一些原因，我们公司仍然在使用 Vue 2，但这并不妨碍我去学习 Vue 3，了解它一些新特性的实现原理以及设计思想，能让我开拓不少思路。&lt;/p&gt;&lt;p&gt;从分析定位问题到最终解决问题，希望这篇文章能给你在组件的性能优化方面提供一些思路，并应用到日常工作中。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9259d0ebe1d5486431f2a57255ffcb27</guid>
<title>ToTTo：受控表到文本生成数据集</title>
<link>https://toutiao.io/k/6k5ve1v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在过去几年中，用于文本摘要等任务的自然语言生成研究取得了巨大进展。然而，尽管实现了高水平的流畅性，神经系统仍然容易产生幻觉（即生成可理解但不忠实于来源的文本），这可能会阻止这些系统用于许多需要高度准确性的应用程序。考虑来自Wikibio 数据集的一个示例，其中负责总结比利时足球运动员Constant Vanden Stock的 Wikipedia 信息框条目的神经基线模型错误地总结了他是美国花样滑冰运动员。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGicwTeJAV5ibC3eoNiaNRffCDqUa3SUFUkGMTbIaOSQYp3wQSjqHLBepAYN981kgSAmk1T5TliaJ0aAg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然评估生成的文本对源内容的忠实度的过程可能具有挑战性，但当源内容是结构化的（例如，以表格格式）时，通常会更容易。此外，结构化数据还可以测试模型的推理和数值推理能力。然而，现有的大规模结构化数据集通常是嘈杂的（即无法从表格数据中完全推断出参考句子），这使得它们在模型开发中用于测量幻觉是不可靠的。&lt;/p&gt;&lt;p&gt;在“ ToTTo: A Controlled Table-To-Text Generation Dataset ”中，我们展示了一个开放域表到文本生成数据集，该数据集使用一种新颖的注释过程（通过句子修订）以及一个受控文本生成任务来创建，该任务可用于评估模型幻觉。ToTTo（“Table-To-Text”的简写）包含 121,000 个训练示例，以及每个用于开发和测试的 7,500 个示例。由于注释的准确性，该数据集适合作为高精度文本生成研究的具有挑战性的基准。数据集和代码在我们的 GitHub 存储库上开源。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;Table-to-Text 生成&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;ToTTo 引入了一个受控生成任务，其中包含一组选定单元格的给定 Wikipedia 表格用作生成单个句子描述任务的源材料，该描述总结表格上下文中的单元格内容. 下面的示例演示了该任务带来的许多挑战中的一些，例如数值推理、大量的开放域词汇表和不同的表结构。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGicwTeJAV5ibC3eoNiaNRffCDqmQxCIhmsUMqY9qGPdQwt3QO0zSSkYStiaqnOeC0GzBBcxgK2dSpogg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;注释过程&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;设计注释过程以从表格数据中获得自然但干净的目标句子是一项重大挑战。许多数据集（如Wikibio和RotoWire）将自然出现的文本与表格配对，这是一个嘈杂的过程，很难确定幻觉主要是由数据噪声还是模型缺陷引起的。另一方面，可以引出注释者从头开始编写句子目标，这些目标忠实于表格，但生成的目标在结构和风格方面往往缺乏多样性。&lt;/p&gt;&lt;p&gt;相比之下，ToTTo 是使用一种新颖的数据注释策略构建的，其中注释者分阶段修改现有的维基百科句子。这导致目标句子既干净又自然，包含有趣且多样的语言特性。数据收集和注释过程从从维基百科收集表格开始，其中根据启发式将给定的表格与从支持页面上下文收集的摘要句子配对，例如页面文本和表格之间的单词重叠以及引用表格数据的超链接。此摘要句子可能包含表格不支持的信息，并且可能包含仅在表格中找到先行词的代词，而不是句子本身。&lt;/p&gt;&lt;p&gt;注释器然后突出显示表中支持该句子的单元格并删除该表中不支持的句子中的短语。在必要时，他们还对句子进行去上下文化，使其独立（例如，具有正确的代词解析）和正确的语法。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGicwTeJAV5ibC3eoNiaNRffCD2qIOfPtoGksyYW64OgNWoB2wspJZ08AJ81c2tLrZK159sibcVXYGfFg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们表明注释者在上述任务上获得了很高的一致性：0.856 Fleiss Kappa用于单元格突出显示，以及 67.0 BLEU用于最终目标句子。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;数据集分析&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们对 ToTTo 数据集进行了超过 44 个类别的主题分析，发现 Sports 和 Country 主题，每个主题都包含一系列细粒度的主题，例如，体育的足球/奥运会和国家的人口/建筑，共占数据集的 56.4%。其余 44% 的主题范围更广，包括表演艺术、交通和娱乐。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGicwTeJAV5ibC3eoNiaNRffCD6Ct5AK5EM8cFt3Ds2FhnBcuHqy3vn8Or4ebDlxAnl4OaOibRRHyrQ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;此外，我们对超过 100 个随机选择的示例数据集中不同类型的语言现象进行了手动分析。下表总结了需要参考页面和章节标题的部分示例，以及数据集中可能对当前系统构成新挑战的一些语言现象。&lt;/p&gt;&lt;p&gt;语言现象 百分比&lt;/p&gt;&lt;p&gt;需要参考页面标题 82%&lt;/p&gt;&lt;p&gt;需要参考章节标题 19%&lt;/p&gt;&lt;p&gt;需要参考表格说明 3%&lt;/p&gt;&lt;p&gt;推理（逻辑、数字、时间等） 21%&lt;/p&gt;&lt;p&gt;跨行/列/单元格的比较 13%&lt;/p&gt;&lt;p&gt;需要背景资料 12%&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;基线结果&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们展示了文献中的三个最先进模型（BERT-to-BERT、Pointer Generator和Puduppully 2019 模型）在两个评估指标BLEU和PARENT上的一些基线结果。除了报告整体测试集的分数之外，我们还在由域外示例组成的更具挑战性的子集上评估每个模型。如下表所示，BERT-to-BERT 模型在 BLEU 和 PARENT 方面表现最佳。此外，所有模型在挑战集上的表现都相当低，表明域外泛化的挑战。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;蓝色&lt;/span&gt;  &lt;span&gt;家长&lt;/span&gt;  &lt;span&gt;蓝色&lt;/span&gt;  &lt;span&gt;家长&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型 （总体） （总体） （挑战） （挑战）&lt;/p&gt;&lt;p&gt;BERT 到 BERT 43.9 52.6 34.8 46.7&lt;/p&gt;&lt;p&gt;指针生成器 41.6 51.6 32.2 45.2&lt;/p&gt;&lt;p&gt;Puduppully 等人。2019年 19.2 29.2 13.9 25.8&lt;/p&gt;&lt;p&gt;虽然自动指标可以给出一些性能指标，但它们目前不足以评估文本生成系统中的幻觉。为了更好地理解幻觉，我们手动评估表现最好的基线，以确定它对源表中内容的忠实度，假设差异表明幻觉。为了计算“专家”性能，对于我们多参考测试集中的每个示例，我们提供一个参考并要求注释者将其与其他参考进行比较以确保其忠实度。结果显示，表现最好的基线似乎在大约 20% 的时间里产生幻觉信息。&lt;/p&gt;&lt;p&gt;模型 （总体） （挑战）&lt;/p&gt;&lt;p&gt;专家 93.6 91.4&lt;/p&gt;&lt;p&gt;BERT 到 BERT 76.2 74.2&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;模型错误和挑战&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在下表中，我们展示了一些观察到的模型错误，以突出 ToTTo 数据集的一些更具挑战性的方面。我们发现最先进的模型在幻觉、数值推理和稀有主题中挣扎，即使使用干净的引用（红色错误）。最后一个例子表明，即使模型输出是正确的，它有时也不如包含更多关于表格的推理的原始参考（以蓝色显示）提供信息。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;参考 模型预测&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在 1939 年的咖喱杯中，西部省份在开普敦以 17-6 输给了德兰士瓦。在第一Currie杯子在1939年发挥transvaal1在新-土地，与西部省份赢得17-6。&lt;/p&gt;&lt;p&gt;ibm 于 2000 年发布了第二代微型驱动器，容量增加到 512 mb 和 1 gb。2000 年有512 个微驱动器型号：1 GB。1956 年的摩托车大奖赛赛季包括 5 个级别的 6 场大奖赛：500cc、350cc、250cc、125cc 和 sidecars 500cc。1956 年大奖赛摩托车赛季包括8场大奖赛，分为五个级别：500cc、350cc、250cc、125cc 和 sidecars 500cc。&lt;/p&gt;&lt;p&gt;在特拉维斯·凯尔斯 (travis kelce) 的最后一个大学赛季中，他在接球 (45)、接球码数 (722)、每次接球码数 (16.0) 和接球达阵 (8) 方面均创下个人职业生涯新高。travis kelce 完成了 2012 赛季，完成了 45 次接球，传球 722 码（场均 16.0 次）和 8 次达阵。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;结论&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在这项工作中，我们展示了 ToTTo，这是一个大型的英文表格到文本数据集，它提供了一个受控的生成任务和一个基于迭代句子修订的数据注释过程。我们还提供了几个最先进的基线，并证明了 ToTTo 可能是一个有用的数据集，用于建模研究以及开发可以更好地检测模型改进的评估指标。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b75bde319aa1b218b34b61087e5c5884</guid>
<title>你们要的环球影城攻略，来了</title>
<link>https://toutiao.io/k/e2ipbrc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;🤙🤙🤙 三连更香🤙🤙&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>