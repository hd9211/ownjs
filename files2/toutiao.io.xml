<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>de4e52a1ed88eb2d79ac53fd3ad0b090</guid>
<title>JavaScript for 循环、in、of 用法详解：有效云开发平台开发技巧</title>
<link>https://toutiao.io/k/jrdwcu5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;pre&gt;&lt;code&gt;我们知道在java script中 for 用来实现循环结构，而for...in 用来实现遍历，for...of用来对象迭代遍历。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1、for循环&lt;/h2&gt;

&lt;p&gt;与其他开发语言相同，JS中for用来实现循环结构之一，&lt;/p&gt;

&lt;h3&gt;1.1、基本语法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;for ([initialization]; [condition]; [final-expression]) {
  statement
}

1.2、实例：

for(let i=1;i&amp;lt;=10;i++){
    console.log(&quot;i=&quot;,i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.3、break关键词&lt;/h3&gt;

&lt;p&gt;break关键词用户终止循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(let i=1;i&amp;lt;=10;i++){
    if(i&amp;gt;5) 
        break;

    console.log(&quot;i=&quot;,i);
}

循环到第5次终止循环。

执行结果：

i=1
i=2
i=3
i=4
i=5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.4、conitue关键词&lt;/h3&gt;

&lt;p&gt;continue关键词用户跳过本次循环，继续下一次&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
for(let i=1;i&amp;lt;=10;i++){

    if(i % 2 === 0 ) continue;

    console.log(&quot;i=&quot;,i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果i是偶数跳过，执行下一次循环，输出i为奇数&lt;/p&gt;

&lt;p&gt;i=1
i=3
i=5
i=7
i=9&lt;/p&gt;

&lt;p&gt;for循环是js中基础的循环结构，适用于任何情况，而for...in和for...of则更适合于不同的应用场景。
JavaScript for循环、in、of 用法详解——有效云开发平台开发技巧&lt;/p&gt;

&lt;h2&gt;2、for...in&lt;/h2&gt;

&lt;p&gt;for...in循环遍历对象的所有可枚举属性。什么是可枚举呢？你可以理解为可枚举就是可表现为键值对的对象，for...in枚举得到的是键值对的键值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objs={mp_v:&quot;可视化&quot;,mp_a:&quot;低代码&quot;,mp_name:&quot;有效云&quot;};
for(let objk in objs){
        console.log(&quot;key：&quot;,objk,&quot;值：&quot;,objs[objk]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//执行结果：
key： mp_v 值： 可视化
key： mp_a 值： 低代码
key： mp_name 值： 有效云&lt;/p&gt;

&lt;p&gt;从上例中可以看到，for...in 循环枚举得到了键值对 key-value中的key属性值，检索适用键值对的值，将键视为数组中的索引并将其放在方括号 -&amp;gt;objs[key]中，如上面代码中的：objs[objk]。&lt;/p&gt;

&lt;p&gt;注意：一维数组也可以理解为键值对，key即为数组的索引，但是for...in枚举是无序的，无法保证枚举得到的顺序，所以不建议使用for...in用来枚举数组，应该使用for，for...of 或for each 来遍历数组。
JavaScript for循环、in、of 用法详解——有效云开发平台开发技巧&lt;/p&gt;

&lt;p&gt;3、for..of&lt;/p&gt;

&lt;p&gt;ES6引入for...of之后，它已经成为广大开发者们常用以迭代枚举对象的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pmname=&quot;有效云开发平台&quot;
for(letter of pmname){
        console.log(letter);
}
//执行结果：
有
效
云
开
发
平
台
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例使用for...of枚举了字符串中的每个字符，我们注意到，for...of是有序的，这与for...in不同。&lt;/p&gt;

&lt;p&gt;for...of可以用来迭代枚举任何，除字符串外还可以是数组、对象等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const arrA = [1,2,3,4,5,6];
for( let v of arrA ){
        console.log(v);
}
//执行结果：
1
2
3
4
5
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码使用 for...of 遍历了数组arrA，接下来使用for..of迭代对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objs={mp_v:&quot;可视化&quot;,mp_a:&quot;低代码&quot;,mp_name:&quot;有效云&quot;};

for(const [k,v] of Object.entries(objs)){
        console.log(&quot;key：&quot;,k,&quot;val：&quot;,v);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//    key： mp_v val： 可视化
//    key： mp_a val： 低代码
//    key： mp_name val： 有效云&lt;/p&gt;

&lt;p&gt;通过这个示例，我们看到在遍历对象时，通过[v,k]，同时获得键值对的键和值。&lt;/p&gt;

&lt;p&gt;感谢阅读。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a06bf0c3c339d3bc909552736be43ea</guid>
<title>使用 Rancher 部署 k8s 集群</title>
<link>https://toutiao.io/k/f9wmnb8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.66484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxibnNhV8hxKQagAAiacf9Yt5icQd3DqrpIeHLHmpz41dGTgVQLqUPibjXGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;非常详细的长文，建议先收藏关注：&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1Njk2NjkxNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSylGO1l57ytuOCLjSa4Ow7S80jEdADvlickRR9bfWrDGtf4Wia2p4WeSjbnr1vLn7Aib6iao7rRu4Ejmw/0?wx_fmt=png&quot; data-nickname=&quot;持续交付实践指南&quot; data-alias=&quot;&quot; data-signature=&quot;分享持续交付的实践经验、软件工程感悟&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3&gt;概述&lt;/h3&gt;&lt;p&gt;随着容器的普及和Kubernetes 的日渐成熟，企业内部运行多个Kubernetes 集群已变得颇为常见，然而部署kubernetes集群的方式也多样化，二进制部署、rancher、kubeadm、minikube等。然而本篇文章主要讲解的是如何使用rancher快速部署一个k8s集群。Rancher是一个开源的企业级容器管理平台。通过Rancher，我们不必再使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。&lt;/p&gt;&lt;h3&gt;主机整体规划&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzx0oIzWPpqhqbCzveeMRf8TneUPPRo5yiaqic8uZP1Gnzm5upDebQyK3yA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span&gt;一、docker容器安装&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p/&gt;&lt;p&gt;每台机器都需要安装。&lt;/p&gt;&lt;h3&gt;1、删除已存在的docker&lt;/h3&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum remove docker \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;client \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;client&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;latest \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;common \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;latest \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;latest&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;logrotate \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;logrotate \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;selinux \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;engine&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;selinux \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                  docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;engine&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;2、配置repo源和epel源&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;先备份原来的源&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;mv &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repos&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;CentOS&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Base&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repo &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repos&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;CentOS&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Base&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repo&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;backup&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;下载新的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;CentOS&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Base&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repo &lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repos&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;wget &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;O &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repos&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;CentOS&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Base&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repo https&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//mirrors.aliyun.com/repo/Centos-7.repo&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;或&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;curl &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;o &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repos&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;CentOS&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;Base&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;repo http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//mirrors.aliyun.com/repo/Centos-7.repo&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;运行&lt;/span&gt;&lt;span&gt; yum makecache &lt;/span&gt;&lt;span&gt;生成缓存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum makecache&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span&gt;epel&lt;/span&gt;&lt;span&gt;源&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;y install epel&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;release&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;&#x27;--showduplicates&#x27;&lt;/span&gt;&lt;span&gt;选项对于显示软件包的多个版本很有用。当您有非常特定的依赖项并尝试查找要安装的软件包的特定名称时，它将起着非常大的作用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# yum list docker --show-duplicates&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;3、安装依赖&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;y install yum&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;utils device&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;persistent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;data lvm2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;4、添加软件源信息&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;manager &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;repo http&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;5、更新并安装Docker-CE&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum makecache fast&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum list docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;ce &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;duplicates&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;y install docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;ce   &lt;/span&gt;&lt;span&gt;#这种方式是安装最新的docker-ce&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;6、安装指定版本的docker&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum list docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;ce &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;duplicates&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;y install docker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;ce&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;19.03&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3.el7&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;7、添加镜像加速&lt;/p&gt;&lt;p&gt;可参考文档：https://www.cnblogs.com/myitnews/p/11509546.html&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;mkdir &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;cat &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/etc/&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;daemon&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json &lt;/span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span&gt; EOF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&quot;registry-mirrors&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;https://i******.mirror.aliyuncs.com&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;//这里请添加自己的阿里云镜像加速&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;EOF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;8、启动docker&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# 添加开启启动&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;systemctl enable docker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# 更新xfsprogs&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;yum &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;y update xfsprogs   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# 启动&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;systemctl start docker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;docker info&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# 测试docker是否已经能够正常使用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# 启动第一个容器&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;docker run hello&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;二、启动rancher&lt;/h2&gt;&lt;p&gt;1、启动rancher&lt;/p&gt;&lt;p&gt;在rancher那台机器上运行：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# docker run -d --restart=unless-stopped --name rancher -p 80:80 -p 443:443 rancher/rancher:stable&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;2、查看日志&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# docker logs -f rancher&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;ERROR&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Rancher&lt;/span&gt;&lt;span&gt; must be ran &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; the &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;privileged flag &lt;/span&gt;&lt;span&gt;when&lt;/span&gt;&lt;span&gt; running outside o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动时需要添加 --privileged 参数&lt;/p&gt;&lt;p&gt;3、再次启动&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# docker run -d --restart=unless-stopped --privileged --name rancher -p 80:80 -p 443:443 rancher/rancher:stable&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;4、查看日志&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# docker logs -f rancher&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;如果不出现明显的错误就可以了&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;5、查看运行状态&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# docker ps&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;CONTAINER ID   IMAGE                    COMMAND           CREATED          STATUS          PORTS                                      NAMES&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;9868df9a9a6e&lt;/span&gt;&lt;span&gt;   rancher&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;rancher&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;stable   &lt;/span&gt;&lt;span&gt;&quot;entrypoint.sh&quot;&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; minutes ago   &lt;/span&gt;&lt;span&gt;Up&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; minutes   &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tcp&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;tcp   rancher&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;6、在Web界面登录&lt;/p&gt;&lt;p&gt;https://192.168.241.138/&lt;/p&gt;&lt;p&gt;因为是使用https的方式登录，所以会报以下错误。点继续前往就可以了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.41854838709677417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxpMrGicUicopuVvaRicJxibfvIzsLMULFtpcyZs1xia1mUxIG7oeuvcUXTkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;7、登录设置密码&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8088235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxIJkBJOoTGKCyjTurWJIZxibOuh9NiaxE7lhFYtuPN04ajz19PLjsCQFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 1.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;使用默认的url即可&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7536945812807881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxHS4Bh1Te7HQvhOxXBItFWbKpVBsj2Nn71yzAq9j08MmnrqGefPyP7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 2.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;8、语言更换&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5096774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxpcic4O9iccY3OvtB0TXTicDH1jOguAvP17oHe5ia7bvd1ZqTClKNjicfIRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 3.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;三、集群添加&lt;/h2&gt;&lt;p&gt;1、添加一个k8s集群&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3096774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxLPO9xPM3vROestHHdk7IK0L5licvKTkjgIfib2ZS3K8PrWnaBCyvK3PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 4.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;2、选择自定义&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5701612903225807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxhB4oVPTHs96tkvDYDaOickzsnSxxES3AGyHX0KIJZvBVBJYnkm7Eesg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 5.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;3、编写集群信息&lt;/p&gt;&lt;p&gt;这里使用的选择的是kubernetes 1.18.20的版本。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5314516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxeNDROJLugmXv082OTNC29NNrfia9HgwfF75XrBsPC0Xo8icf0oicIWRicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 6.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4475806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzx3kErbTTHNkZNqQ8MU0JtpiaV5ibg3D2RuB9GAQ9TRJlqTfLrswlM5ezA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 7.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Master节点上这个control组件是必须的！！！&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6282258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxUjBDQrVibPibYD1zgvItjRmnKXlibXwFsPYDmekJfnfrJSNcicEvRtIRFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 8.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;4、登录到master01&lt;/p&gt;&lt;p&gt;执行上面copy过来的命令&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;sudo docker run &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;privileged &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;restart&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;unless&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;stopped &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;host &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;v &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/etc/&lt;/span&gt;&lt;span&gt;kubernetes &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;v &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;run  rancher&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;rancher&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;5.9&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;server https&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//192.168.241.138 --token 4692pw82n2jhm7qmtzz7dptlpvhwz7ls9f27v2mkv5n9s89mwp6684 --ca-checksum 9cfb504b8d3f05bd9e37477173524ccf1a2b24129ffc941f52dcc2e9c9175310 --node-name k8s-master01 --controlplane --worker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;然后就是静静等待集群的启动&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.23387096774193547&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxF939qDlPOCSetn9GTWKSIrkQLVftf5eXgGCwApqwM93A2vdicf3wyLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 9.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;等到显示active就说明部署好了&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2120967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxBSojG6EOTvudTW8icVCH3H3ianliaZzy9QGAYIZQW8O68fuicc8wfyrpjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p/&gt;&lt;h3&gt;四、worker-node节点的添加&lt;/h3&gt;&lt;p&gt;1、编辑集群&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2782258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxvobic7GJPesRLmnRDuIjk1szaRGZpxHT4UdUBzJELibvTgACKzLlHgkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p/&gt;&lt;p&gt;2、直接点击保存&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4064516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxS5Oqx1pzILKIMyPT5VCzrcib0bDsBq0dW17KiaibjIzVcaJ7eOC3BhSicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p/&gt;&lt;p&gt;3、选择组件&lt;/p&gt;&lt;p&gt;由于机器的限制，etcd就部署在了worker-node上。etcd尽量以单数形式部署1、3、5、7......&lt;/p&gt;&lt;p&gt;我这里是选择3台机器部署etcd组件。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzx65dF3z9gxRDkvJeHJp4KqaicM4icbgibEN1m5MLEaiaqgicjxmscUX7SSLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p/&gt;&lt;p&gt;4、登录node01机器&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;sudo docker run &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;privileged &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;restart&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;unless&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;stopped &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;host &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;v &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/etc/&lt;/span&gt;&lt;span&gt;kubernetes &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;v &lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;/var/&lt;/span&gt;&lt;span&gt;run  rancher&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;rancher&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;5.9&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;server https&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//192.168.241.138 --token 4tldjd8szx8ndgk9k88hmscdx46q2k8lf6l9z7kg5mbjgmwpb452nd --ca-checksum 9cfb504b8d3f05bd9e37477173524ccf1a2b24129ffc941f52dcc2e9c9175310 --node-name k8s-worker-node01 --etcd --worker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;5、以后添加node节点只需要添加以下参数就可以了&lt;/p&gt;&lt;p&gt;主机名：&lt;/p&gt;&lt;p&gt;--node-name k8s-worker-node02&lt;/p&gt;&lt;p&gt;--node-name k8s-worker-node03&lt;/p&gt;&lt;p&gt;组件：&lt;/p&gt;&lt;p&gt;--etcd&lt;/p&gt;&lt;p&gt;--controlplane&lt;/p&gt;&lt;p&gt;--worker&lt;/p&gt;&lt;h3&gt;五、kubectl工具的安装&lt;/h3&gt;&lt;p&gt;我这里是将kubectl工具安装在master上&lt;/p&gt;&lt;p&gt;1、使用wget命令下载或者将它下载到本地再上传到服务器。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;wget https&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//storage.googleapis.com/kubernetes-release/release/v1.18.20/bin/linux/amd64/kubectl&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;2、加x权限&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# chmod +x kubectl&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;3、将二进制文件移到PATH中&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# mv kubectl /usr/local/bin/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;4、查看版本&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# kubectl version --client&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;Client&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Version&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; version&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Info&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;Major&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Minor&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;18&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GitVersion&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;v1.18.20&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GitCommit&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;1f3e19b7beb1cc0110255668c4238ed63dadb7ad&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GitTreeState&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;clean&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BuildDate&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;2021-06-16T12:58:51Z&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;GoVersion&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;go1.13.15&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Compiler&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;gc&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Platform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;linux/amd64&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;5、创建kube目录&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;mkdir &lt;/span&gt;&lt;span&gt;~/.&lt;/span&gt;&lt;span&gt;kube&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;6、编辑config文件&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5387096774193548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzx9HakQXI1TT09BlIeXefXsO0JlpmjHWfqV1jONPR62zdG8PiaoGh0Ewg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 14.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.28601921024546423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxw0x5fuurczamq08wwFiamzwU2kJqib1FBXDrIYhzJg2I0we2LJ7N8sdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 15.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在~/.kube目录下创建config&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;vim &lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;/.kube/&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;查看node状态&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# kubectl get nodes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAME                STATUS   ROLES                 AGE     VERSION&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;k8s&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;master01        &lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;span&gt;    controlplane&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;worker   &lt;/span&gt;&lt;span&gt;30m&lt;/span&gt;&lt;span&gt;     v1&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;18.20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;k8s&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;worker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;node01   &lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;span&gt;    etcd&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;worker           &lt;/span&gt;&lt;span&gt;5m50s&lt;/span&gt;&lt;span&gt;   v1&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;18.20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;k8s&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;worker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;node02   &lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;span&gt;    etcd&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;worker           &lt;/span&gt;&lt;span&gt;5m1s&lt;/span&gt;&lt;span&gt;    v1&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;18.20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;k8s&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;worker&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;node03   &lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;span&gt;    etcd&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;worker           &lt;/span&gt;&lt;span&gt;30m&lt;/span&gt;&lt;span&gt;     v1&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;18.20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;查看所有pod状态&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;# kubectl get pods -A&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;NAMESPACE       NAME                                      READY   STATUS      RESTARTS   AGE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;system   cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;66dcc68754&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7lp4q&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;29m&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;system   cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5twkm&lt;/span&gt;&lt;span&gt;                   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;5m57s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;system   cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;v7c5l                   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;29m&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;system   cattle&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;wsnnr                   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;Running&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;6m46s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;........&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;如下&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSzVWdHh79wEXtkNDUByuvzxEFJoA8bD2RPibYKxicibubCLlPhotOyN7Syv8b65eYKUEWedKoUriaic7nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;Untitled 16.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;到这里，rancher部署k8s集群就完成了。可以发现我们只需要在rancher控制台上面点点点的操作就可以简单的把k8s集群部署下来。并且还提供了丰富的可视化功能管理模块。非常方便。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎关注公众号：持续交付实践指南&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1Njk2NjkxNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/FBPFm28kpSylGO1l57ytuOCLjSa4Ow7S80jEdADvlickRR9bfWrDGtf4Wia2p4WeSjbnr1vLn7Aib6iao7rRu4Ejmw/0?wx_fmt=png&quot; data-nickname=&quot;持续交付实践指南&quot; data-alias=&quot;&quot; data-signature=&quot;分享持续交付的实践经验、软件工程感悟&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;往期好文：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>722cba5ca4852ba7a082f0ac33e9f122</guid>
<title>CompletableFuture 真香，可以替代 CountDownLatch</title>
<link>https://toutiao.io/k/j0uuaz1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650524593&amp;amp;idx=1&amp;amp;sn=99d335849dc1fc92f65dc618106aa844&amp;amp;chksm=8780cc75b0f745637ee03a63d7ea640ad1d4638478e8af5d811e92e985b1509219957408ec27&amp;amp;token=1556116051&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;类的命名这篇长文&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;类的命名这篇长文&lt;/a&gt;中，我们提到了&lt;code&gt;Future&lt;/code&gt;和&lt;code&gt;Promise&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Future相当于一个占位符，代表一个操作将来的结果。一般通过get可以直接阻塞得到结果，或者让它异步执行然后通过callback回调结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果回调中嵌入了回调呢？如果层次很深，就是回调地狱。Java中的CompletableFuture其实就是Promise，用来解决回调地狱问题。Promise是为了让代码变得优美而存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有多优美？这么说吧，一旦你使用了CompletableFuture，就会爱不释手，就像初恋女友一样，天天想着她。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一系列静态方法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从它的源代码中，我们可以看到，CompletableFuture直接提供了几个便捷的静态方法入口。其中有&lt;code&gt;run&lt;/code&gt;和&lt;code&gt;supply&lt;/code&gt;两组。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5076923076923077&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLpsgAkLzXYicDoxwahBdiaaHM0ZpSk3Zk1GHA3tib55XlXYOibBiatlVcDPYLFoKDlF9JdqB4icJoOyC5rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;run的参数是Runnable，而supply的参数是Supplier。前者没有返回值，而后者有，否则没有什么两样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两组静态函数，都提供了传入自定义线程池的功能。如果你用的不是外置的线程池，那么它就会使用默认的ForkJoin线程池。默认的线程池，大小和用途你是控制不了的，所以还是建议自己传递一个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;典型的代码，写起来是这个样子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(()-&amp;gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;});&lt;br/&gt;String result = future.join();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿到CompletableFuture后，你就可以做更多的花样。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;这些花样有很多&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说面说了，CompletableFuture的主要作用，就是让代码写起来好看。配合Java8之后的stream流，可以把整个计算过程抽象成一个流。前面任务的计算结果，可以直接作为后面任务的输入，就像是管道一样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;thenApply&lt;br/&gt;thenApplyAsync&lt;br/&gt;thenAccept&lt;br/&gt;thenAcceptAsync&lt;br/&gt;thenRun&lt;br/&gt;thenRunAsync&lt;br/&gt;thenCombine&lt;br/&gt;thenCombineAsync&lt;br/&gt;thenCompose&lt;br/&gt;thenComposeAsync&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLpsgAkLzXYicDoxwahBdiaaHMgyic5p2HKkqgYWM38ibBX9nmaQ3viakEpTzwXF1XpG0c13SBLuvTnLkbg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;326&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，下面代码的执行结果是99，并不因为是异步就打乱代码执行的顺序了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CompletableFuture&amp;lt;Integer&amp;gt; cf = CompletableFuture.supplyAsync(() -&amp;gt; &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;                .thenApplyAsync((e) -&amp;gt; {&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;10000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException ex) {&lt;br/&gt;                        ex.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; e * &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;                }).thenApplyAsync(e -&amp;gt; e - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;cf.join();&lt;br/&gt;System.out.println(cf.get());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的，函数的作用还要看then后面的动词。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;apply 有入参和返回值，入参为前置任务的输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;accept 有入参无返回值，会返回CompletableFuture&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;run 没有入参也没有返回值，同样会返回CompletableFuture&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;combine 形成一个复合的结构，连接两个CompletableFuture，并将它们的2个输出结果，作为combine的输入&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compose 将嵌套的CompletableFuture平铺开，用来串联两个CompletableFuture&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;when和handle&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的函数列表，其实还有很多。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;whenComplete&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;when的意思，就是任务完成时候的回调。比如我们上面的例子，打算在完成任务后，输出一个&lt;code&gt;done&lt;/code&gt;。它也是属于只有入参没有出参的范畴，适合放在最后一步进行观测。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CompletableFuture&amp;lt;Integer&amp;gt; cf = CompletableFuture.supplyAsync(() -&amp;gt; &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;                .thenApplyAsync((e) -&amp;gt; {&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException ex) {&lt;br/&gt;                        ex.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; e * &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;                }).thenApplyAsync(e -&amp;gt; e - &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                .whenComplete((r, e)-&amp;gt;{&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;done&quot;&lt;/span&gt;);&lt;br/&gt;                })&lt;br/&gt;                ;&lt;br/&gt;&lt;br/&gt;cf.join();&lt;br/&gt;System.out.println(cf.get());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;handle和exceptionally的作用，和whenComplete是非常像的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; CompletableFuture&amp;lt;T&amp;gt; &lt;span&gt;exceptionally&lt;/span&gt;&lt;span&gt;(Function&amp;lt;Throwable, ? extends T&amp;gt; fn)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;U&amp;gt; &lt;span&gt;CompletionStage&amp;lt;U&amp;gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, Throwable, ? extends U&amp;gt; fn)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CompletableFuture的任务是串联的，如果它的其中某一步骤发生了异常，会影响后续代码的运行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;exceptionally从名字就可以看出，是专门处理这种情况的。比如，我们强制某个步骤除以0，发生异常，捕获后返回-1，它将能够继续运行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CompletableFuture&amp;lt;Integer&amp;gt; cf = CompletableFuture.supplyAsync(() -&amp;gt; &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;                .thenApplyAsync(e-&amp;gt;e/&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                .thenApplyAsync(e -&amp;gt; e - &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                .exceptionally(ex-&amp;gt;{&lt;br/&gt;                    System.out.println(ex);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;                });&lt;br/&gt;&lt;br/&gt;cf.join();&lt;br/&gt;System.out.println(cf.get());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;handle更加高级一些，因为它除了一个异常参数，还有一个正常的入参。处理方法也都类似，不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，CompletableFuture的函数不仅仅这些，还有更多，根据函数名称很容易能够了解到它的作用。它还可以替换复杂的CountDownLatch，这要涉及到几个比较难搞的函数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;替代CountDownLatch&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑下面一个场景。某一个业务接口，需要处理几百个请求，请求之后再把这些结果给汇总起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果顺序执行的话，假设每个接口耗时100ms，那么100个接口，耗时就需要10秒。假如我们并行去获取的话，那么效率就会提高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用CountDownLatch可以解决。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ExecutorService executor = Executors.newFixedThreadPool(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;CountDownLatch countDown = &lt;span&gt;new&lt;/span&gt; CountDownLatch(requests.size());&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(Request request:requests){&lt;br/&gt;    executor.execute(()-&amp;gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//some opts&lt;/span&gt;&lt;br/&gt;        }&lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;            countDown.countDown();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;countDown.await(&lt;span&gt;200&lt;/span&gt;,TimeUnit.MILLISECONDS);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用CompletableFuture来替换它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ExecutorService executor = Executors.newFixedThreadPool(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;CompletableFuture&amp;lt;Result&amp;gt;&amp;gt; futureList = requests&lt;br/&gt;    .stream()&lt;br/&gt;    .map(request-&amp;gt;&lt;br/&gt;        CompletableFuture.supplyAsync(e-&amp;gt;{&lt;br/&gt;            &lt;span&gt;//some opts&lt;/span&gt;&lt;br/&gt;        },executor))&lt;br/&gt;    .collect(Collectors.toList());&lt;br/&gt;&lt;br/&gt;CompletableFuture&amp;lt;Void&amp;gt; allCF = CompletableFuture.allOf(futureList.toArray(&lt;span&gt;new&lt;/span&gt; CompletableFuture[&lt;span&gt;0&lt;/span&gt;]));&lt;br/&gt;&lt;br/&gt;allCF.join();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里用到了一个主要的函数，那就是allOf，用来把所有的CompletableFuture组合在一起；类似的还有anyOf，表示只运行其中一个。常用的，还有三个函数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;thenAcceptBoth 处理两个任务的情况，有两个任务结果入参，无返回值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;thenCombine  处理两个任务的情况，有入参有返回值，最喜欢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runAfterBoth 处理两个任务的情况，无入参，无返回值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自从认识了CompletableFuture，我已经很少硬编码Future了。相对于各种回调的嵌套，CompletableFuture为我们提供了更直观、更优美的API。在“多个任务等待完成状态”这个应用场景，CompletableFuture已经成了我的首选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唯一的问题是，它的函数有点多，你需要熟悉一小段时间。另外，有一个小小的问题，个人觉得，这个类如果叫做&lt;code&gt;Promise&lt;/code&gt;的话，就能够和JS的统一起来，算是锦上添花吧。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：小姐姐味道 (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6a161ef43fe8cba520a091fb7a269222</guid>
<title>阅读器排版探索</title>
<link>https://toutiao.io/k/cxt72og</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p/&gt;&lt;h1&gt;&lt;span&gt;一、待实现需求&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;调整字体大小、字体&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;调整行间距、段间距&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;动态获取可展示内容高度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改字体颜色&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持夜间模式和不同背景模式&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;二、方案探索&lt;/h2&gt;&lt;h3&gt;2.1 为什么不用TextView&lt;/h3&gt;&lt;p&gt;不能根据TextView的高度获取可展示的内容的长度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;2.2 如何做&lt;/h3&gt;&lt;p&gt;根据屏幕宽度逐行计算可展示字符个数，根据内容区域计算可展示的行数&lt;/p&gt;&lt;h2&gt;三、排版流程&lt;/h2&gt;&lt;h3&gt;3.1 layout-分页&lt;/h3&gt;&lt;p&gt;阅读器根据内容区域大小、文字字号、文字字体、行间距、段间距等信息，将内容分页；&lt;/p&gt;&lt;h3/&gt;&lt;h3&gt;3.2 draw-绘制&lt;/h3&gt;&lt;p&gt;分页数据如何绘制到屏幕上&lt;/p&gt;&lt;p&gt;文字大小、字号、行间距、段间距修改则需要重新分页重新绘制；如果只是字体颜色修改则仅需重绘，不需要重新分页&lt;/p&gt;&lt;h2&gt;四、方案实现&lt;/h2&gt;&lt;h3&gt;4.1 如何分页&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;448&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7754629629629629&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UZibibiaQhjHtniabGRQgxsEZL0ojVuS86ywe9beL8U8lXaDicylcYAEK5UjWMLFbABUhHnQG8mZpECRL6PBxD7BPoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;分页流程：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将内容按照换行符拆分成段落&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Paint#breakText&lt;/strong&gt;方法根据宽度返回可以容纳的文字个数，重置内容展示区域：内容区域减去字符的高度和行间距&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;段落结束则内容显示区域减去段间距&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;剩余高度小于0或者展示内容已经全部计算完，则本页分页结束&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h6&gt;核心代码：&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;    /**&lt;br/&gt;     *  @param  content:待分页的内容&lt;br/&gt;     *  @param  pageProperty:分页所需属性：内容区域的大小、行间距、段间距、字体大小&lt;br/&gt;     * @return 分页数组，每一页的内容是一个String的List，表示每一行显示的内容&lt;br/&gt;     */&lt;br/&gt;    fun getLines(content: String, pageProperty: PageProperty): SparseArray&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; {&lt;br/&gt;        var lines: ArrayList&amp;lt;String&amp;gt; = ArrayList&amp;lt;String&amp;gt;()&lt;br/&gt;        var sparseArray:SparseArray&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; = SparseArray()&lt;br/&gt;        var height: Int = pageProperty.visibilityHeight;&lt;br/&gt;        if (content != null &amp;amp;&amp;amp; content.isNotEmpty()) {&lt;br/&gt;            val split: Array&amp;lt;String&amp;gt; = content.split(&quot;\n&quot;).toTypedArray()&lt;br/&gt;&lt;br/&gt;            for (s in split) {&lt;br/&gt;                if (s.trim().isEmpty()) {//空行&lt;br/&gt;                    continue;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                var paragraph = &quot;　　&quot; + s.trim()+&quot;\n&quot; //新段落添加两个字符，增加一个换行符&lt;br/&gt;                while (paragraph.isNotEmpty()) {&lt;br/&gt;                    height -= pageProperty.textPaint.textSize.toInt();&lt;br/&gt;                    if (height &amp;gt;= 0) {//剩余的高度可以放下文字&lt;br/&gt;                        //测量一行占用的字节数&lt;br/&gt;                        val measuredWidth = FloatArray(1)&lt;br/&gt;                        var count: Int = pageProperty.textPaint.breakText(paragraph, true, pageProperty.visibilityWidth.toFloat(), measuredWidth)&lt;br/&gt;                        val subStr = paragraph.substring(0, count)&lt;br/&gt;                        lines.add(subStr)&lt;br/&gt;                        paragraph = paragraph.substring(count)&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    height -= pageProperty.intervalSize&lt;br/&gt;                    if (height &amp;lt; 0) {//本页已经绘制完&lt;br/&gt;                        sparseArray.put(sparseArray.size(),ArrayList(lines))&lt;br/&gt;                        height = pageProperty.visibilityHeight;&lt;br/&gt;                        lines.clear();&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                }&lt;br/&gt;                //段落结束&lt;br/&gt;                height+=pageProperty.intervalSize&lt;br/&gt;                height -=pageProperty.paragraphSize&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            if (lines.isNotEmpty()){//最后一页&lt;br/&gt;                sparseArray.put(sparseArray.size(),ArrayList(lines))&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        return sparseArray;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;4.2 如何绘制&lt;/h3&gt;&lt;p&gt;使用分页时的字体大小，canvas.drawText 一行一行绘制文字，改变top改变文字绘制的位置&lt;/p&gt;&lt;h6&gt;核心代码：&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;    override fun onDraw(canvas: Canvas) {&lt;br/&gt;        super.onDraw(canvas)&lt;br/&gt;        if (pageData == null) {&lt;br/&gt;            return&lt;br/&gt;        }&lt;br/&gt;        //设置总距离&lt;br/&gt;        val interval = mTextInterval + textPaint!!.textSize.toInt()&lt;br/&gt;        val para = mTextPara + textPaint!!.textSize.toInt()&lt;br/&gt;        var str: String? = null&lt;br/&gt;        var top: Float&lt;br/&gt;        top = mMarginHeight - textPaint!!.fontMetrics.top&lt;br/&gt;        //对内容进行绘制&lt;br/&gt;        for (i in pageData!!.lines.indices) {&lt;br/&gt;            str = pageData!!.lines[i]&lt;br/&gt;            canvas.drawText(str, mMarginWidth, top, textPaint!!)&lt;br/&gt;            top += if (str.endsWith(&quot;\n&quot;)) { //段落&lt;br/&gt;                para.toFloat()&lt;br/&gt;            } else {&lt;br/&gt;                interval.toFloat()&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;五、踩坑记录&lt;/h2&gt;&lt;h3&gt;5.1 &lt;strong&gt;Java String#trim()&lt;/strong&gt;不掉的空格，ASCII 160引起的排版问题&lt;/h3&gt;&lt;h4&gt;5.1.1 问题背景&lt;/h4&gt;&lt;p&gt;在阅读器排版的时候，会统一&lt;strong&gt;Java String#trim()&lt;/strong&gt;去掉段落的前后的空白字符，然后统一添加两个空格。但是某些情况会出现下图情况&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;722&quot; data-backw=&quot;532&quot; data-ratio=&quot;1.3571428571428572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UZibibiaQhjHtniabGRQgxsEZL0ojVuS86ywib2Hz8mPLUlJl8FHBrrS2QKudkvPuSCwNw0049DgUib0NFkQhNGM67ZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;532&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;5.1.2 问题分析&lt;/h4&gt;&lt;p&gt;debug发现char的值是160。&lt;/p&gt;&lt;p&gt;维基百科的解释是&lt;br/&gt;&lt;code&gt;不换行空格（英语：no-break space，NBSP）是空格字符，用途是禁止自动换行。HTML页面显示时会自动合并多个连续的空白字符，但该字符是禁止合并的，因此该字符也称作“硬空格”（hard space、fixed space）。Unicode码点为：U+00A0 no-break space。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;那为什么&lt;strong&gt;Java String#trim()&lt;/strong&gt;方法对160不生效？&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Java String#trim()&lt;/strong&gt;方法实现&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;    public String trim() {&lt;br/&gt;        int len = length();&lt;br/&gt;        int st = 0;&lt;br/&gt;&lt;br/&gt;        while ((st &amp;lt; len) &amp;amp;&amp;amp; (charAt(st) &amp;lt;= &#x27; &#x27;)) {&lt;br/&gt;            st++;&lt;br/&gt;        }&lt;br/&gt;        while ((st &amp;lt; len) &amp;amp;&amp;amp; (charAt(len - 1) &amp;lt;= &#x27; &#x27;)) {&lt;br/&gt;            len--;&lt;br/&gt;        }&lt;br/&gt;        return ((st &amp;gt; 0) || (len &amp;lt; length())) ? substring(st, len) : this;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见&lt;strong&gt;Java String#trim()&lt;/strong&gt;只是将ASCII值&amp;lt;=32的空白字符去掉，而对于160则无效&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;kotlin String#trim()&lt;/strong&gt;方法实现&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public inline fun CharSequence.trim(predicate: (Char) -&amp;gt; Boolean): CharSequence {&lt;br/&gt;    var startIndex = 0&lt;br/&gt;    var endIndex = length - 1&lt;br/&gt;    var startFound = false&lt;br/&gt;&lt;br/&gt;    while (startIndex &amp;lt;= endIndex) {&lt;br/&gt;        val index = if (!startFound) startIndex else endIndex&lt;br/&gt;        val match = predicate(this[index])&lt;br/&gt;&lt;br/&gt;        if (!startFound) {&lt;br/&gt;            if (!match)&lt;br/&gt;                startFound = true&lt;br/&gt;            else&lt;br/&gt;                startIndex += 1&lt;br/&gt;        } else {&lt;br/&gt;            if (!match)&lt;br/&gt;                break&lt;br/&gt;            else&lt;br/&gt;                endIndex -= 1&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    return subSequence(startIndex, endIndex + 1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public actual fun Char.isWhitespace(): Boolean = Character.isWhitespace(this) || Character.isSpaceChar(this)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public static boolean isSpaceChar(int codePoint) {&lt;br/&gt;        // We don&#x27;t just call into icu4c because of the JNI overhead. Ideally we&#x27;d fix that.&lt;br/&gt;        // SPACE or NO-BREAK SPACE?&lt;br/&gt;        if (codePoint == 0x20 || codePoint == 0xa0) {&lt;br/&gt;            return true;&lt;br/&gt;        }&lt;br/&gt;        if (codePoint &amp;lt; 0x1000) {&lt;br/&gt;            return false;&lt;br/&gt;        }&lt;br/&gt;        // OGHAM SPACE MARK or MONGOLIAN VOWEL SEPARATOR?&lt;br/&gt;        if (codePoint == 0x1680 || codePoint == 0x180e) {&lt;br/&gt;            return true;&lt;br/&gt;        }&lt;br/&gt;        if (codePoint &amp;lt; 0x2000) {&lt;br/&gt;            return false;&lt;br/&gt;        }&lt;br/&gt;        if (codePoint &amp;lt;= 0xffff) {&lt;br/&gt;            // Other whitespace from General Punctuation...&lt;br/&gt;            return codePoint &amp;lt;= 0x200a || codePoint == 0x2028 || codePoint == 0x2029 || codePoint == 0x202f || codePoint == 0x205f ||&lt;br/&gt;                codePoint == 0x3000; // ...or CJK Symbols and Punctuation?&lt;br/&gt;        }&lt;br/&gt;        // Let icu4c worry about non-BMP code points.&lt;br/&gt;        return isSpaceCharImpl(codePoint);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;kotlin String#trim()&lt;/strong&gt;是通过Character.isWhitespace(this) || Character.isSpaceChar(this)来删除的，Character.isSpaceChar(this) ASCII=160返回true&lt;/p&gt;&lt;h4&gt;正则表达式&lt;/h4&gt;&lt;p&gt;正则表达式也可以实现去除ASCII=160&lt;/p&gt;&lt;pre&gt;&lt;code&gt; private static final Pattern pattern = Pattern.compile(&quot;^\\s*|\\s*$&quot;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;5.1.3 问题总结&lt;/h3&gt;&lt;p&gt;正则表达式和&lt;strong&gt;Kotlin String#trim()&lt;/strong&gt;方法可以实现过滤ASCII=160&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;解决后&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;725&quot; data-backw=&quot;530&quot; data-ratio=&quot;1.3679245283018868&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UZibibiaQhjHtniabGRQgxsEZL0ojVuS86ywv8o4J2aHJ9zEO8ibY5vv4uUic9omobaKc1WnJnpJqliavRu1eaAXh6LYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;530&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>84a7fca0e285c5c422395f09283561da</guid>
<title>携程酒店 AWS 实践</title>
<link>https://toutiao.io/k/poizebg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; role=&quot;option&quot; title=&quot;链接&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot;&gt;
                                            
                                                                                    &lt;span class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5MDI3MjA5MQ==&amp;amp;action=getalbum&amp;amp;album_id=1764480959015354375#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1764480959015354375&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;#&lt;/span&gt;云计算&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span class=&quot;article-tag-card__right&quot;&gt;&lt;span class=&quot;weui-hidden_abs&quot;&gt;,&lt;/span&gt;4个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;微末，携程软件技术专家，关注系统架构，致力于高可用高性能的支撑业务系统开发。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一、背景&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着携程海外酒店业务的发展，遍布全球的海外供应商与携程总部IDC之间的数据传输量快速增长。技术上，这种日益增长的数据量对跨境网络专线的带宽、延迟等提出了更高的要求；业务上，由于当前有限的跨境网络专线资源对业务处理效率及用户体验也造成了一定的影响；成本上，跨境网络专线作为一种昂贵的资源，通过单纯的专线扩容又会给IT成本造成巨大压力。所以我们开始思考是否可以通过公有云结&lt;/span&gt;&lt;span&gt;合酒店直连的&lt;/span&gt;&lt;span&gt;业务特性来解决日益增长的带宽压力和供应商接口延迟的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;酒店直连系统主要是使用自动化接口实现供应商或集团与携程之间的系统对接，实现静态信息、动态信息、订单功能等都通过系统的方式流转交互。目前携程大量海外酒店业务是通过酒店直连系统对接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文将主要从携程酒店直连服务迁移部署至AWS过程中所进行的应用架构调整及云原生改造，使用AWS后取得的技术和业务收益，在部署过程中对EKS（Amazon Elastic Kubernates Service）、DNS查询延时和跨AZ流量降低所做的成本优化等几方面进行详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;二、痛点&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程酒店海外直连对接了上千家海外供应商，所有的接口访问都通过代理出去（见图1），由于酒店直连的业务特性，当一个用户请求过来时会根据人数、国籍、会员非会员等裂变成多个请求，最多的时候可能一个请求会裂变成数十个请求，而且请求报文十分巨大（通常为几十Kb到上百Kb不等），虽然我们可能只需要返回报文中的一小部分信息，但是因为目前架构的限制只能将所有报文全部请求回来再处理，这无疑浪费了大量的带宽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4083769633507853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWIoe9Ik6zzalcvZLa98ba5tmEt3uQBFENyvyFcDWvnB3xibsFZOBU0WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时因为供应商遍布全球，所有的请求/响应都需要经过集团的代理出口，导致了部分供应商接口响应受到物理距离的影响延迟变高了，会降低用户的体验。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;三、云服务选择及初步方案&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次核心目标之一是为了提高对接全球供应商的网络传输能力和延时改进，提升用户体验，必须选择一个在全球有广泛资源分布的云厂商帮助携程尽量靠近供应商访问数据。经过与多个公有云厂商的多轮交流，综合考虑各厂商技术水平、服务能力、成本价格等多方面因素，我们认为AWS无论是在全球覆盖及网络能力（见图2）（AWS在全球分布的25个区域和80个可用区提供广泛的服务能力，同时数据中心通过其骨干网互联，提升了未来不同数据中心的数据互访能力），云服务的先进性和成熟度、现场团队的服务能力、响应时间、专业水平都具有明显的优势，最终我们选择AWS作为资源部署的云厂商合作伙伴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4755520504731861&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCW4ZYoVe0LNJqC0PUej10u2PUQnCOHP1EpA4vhFOXJVibib6CyQr7pULbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了更好地与云上资源使用集成，我们采用IDC的容器化部署方案，最终考虑到托管容器平台的高可用性设计及SLA保证，及&lt;/span&gt;&lt;span&gt;对社区的兼容性&lt;/span&gt;&lt;span&gt;，使用AWS托管容器平台EKS作为部署的平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源方面我们对服务进行改造后，大量使用竞价实例作为EKS工作节点，大幅降低成本并提高效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时利用公有云的网络和平台优势，将原本部署在携程总部IDC的相应业务服务部署到离供应商距离更近的海外公有云站点，实现携程与海外供应商之间高可靠、低延迟的网络直连，并将部分数据预处理逻辑剥离出来前置部署到海外公有云上，实现仅将经过处理的有价值的数据（而非原始、全量的裸数据）压缩后再传输到携程总部数据中心，进而达到降低对跨境网络专线的压力、提升业务数据处理效率、降低成本、优化用户体验等目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;四、酒店直连上云经验&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;4.1 云业务应用的云原生改造&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了充分的使用云服务带来的便利和成本优化，经过调研分析，我们如果直接将应用迁移至公有云上，虽然业务上会产生相应的价值，但成本会相对较高，因此我们对酒店直连服务进行了相应的云原生架构优化，相关的主要调整如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1 ）访问供应商模块上云&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要节省带宽需要减少通过从代理出去的请求同时减少每个请求的报文大小。我们的做法是将请求拆分的逻辑搬到AWS上，这样每次一个用户请求过来通过代理出去只有一次请求/响应。同时我们在AWS上将供应商返回的报文中无用属性剔除，然后再根据业务属性合并相关节点最后再压缩返回，这样就达到了缩减报文大小的目的(见图3)。从目前运行的数据上看，整个代理的带宽流量只用到了之前的30%~40%。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.29921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWCGdbcXAQN2faqhhHYMvF6luQCkVoslI1FIWsFHWiaYqMHnKCC7MU94g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公有云厂商普遍采用按流量收费的价格策略，在设计网络出入站网络访问的技术方案过程中，默认情况下会使用AWS NAT网关，这样网络流量费用相对较高。考虑到酒店直连请求有个特性，通常情况下请求报文不到1K，而响应报文平均有10k到100K，利用这个特点，我们在AWS上采用了基于EKS自建Squid代理方案（见图4），这样只有出站的请求报文会产生流量费用，而大量入站的响应报文不收费，从而大大降低AWS上产生的网络流量费用。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.512014787430684&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWibAPovqJnaVib1ibLsyiaYQmrbBAp8oNBw3O2cIoaZxwdXRRqHGF2DYdNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）降低网络延迟，利用AWS全球数据中心对供应商就近访问&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多海外的供应商服务部署在全球各地，而我们所有的海外访问都统一从代理出去，这样一些服务器部署较远的供应商因为物理距离上的原因导致网络延迟很高。通过AWS的在全球各地的数据中心，我们可以将服务就近部署在供应商机房附近，同时利用AWS的骨干网络降低各数据中心到代理所在地附近的AWS数据中心的延迟，最后通过专线连接该AWS数据中心与携程IDC（见图5），整个过程对那些因物理距离对网络延迟影响较大的供应商性能提升较明显，最多可降低50%的响应时间。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1830065359477124&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWxd8SjwxeGLlhR1a26cMYztc2dkqH8UEiaNlf7DBZQpWRTgDDIictEEsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;4.2 持续的架构改造和性能及成本优化&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在目前的方案中，我们为了上云单独开发了一套全新的应用，这样带来的问题就是，当有业务变更时我们同时需要调整携程IDC和AWS上部署的两个应用，提高了系统维护成本。主要原因是原应用中大量依赖携程的基础组件，本次上云尝试使用的是完全独立的账号和VPC网络，如果在云上同样部署一套不太现实，一是成本太大，二是一些敏感数据不能放在在云端存储，所以后续我们会对适配器架构再进行优化，在不依赖携程基础组件的情况&lt;/span&gt;&lt;span&gt;下复用一&lt;/span&gt;&lt;span&gt;套应用以适应不同的云环境。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务上线后为了验证未来更大规模的负载上云的可能性，我们同时也在对性能，成本，高可用性方面做持续不断的优化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;4.2.1 利用云弹性伸缩能力&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以计算资源成本为例：计算实例成本 = 实例运行时长 * 实例价格。如果只是简单粗暴把本地机房的运行模式套用到云上计算，云服务计算资源的费用是高于本地机房的。所以我们需要充分利用云上按需收费的特性，减少闲置资源成本。实例的运行时长和Kubernetes集群内的服务数量，以及分配给这些服务的计算资源成正比，同时服务的数量又是和流量成正比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;酒店直连业务场景存在不可预测的业务流量，比如临近节假日颁布的旅游政策，或者营销直播活动。云原生的弹性特性很好地利用合理的资源应对突发的流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kubernetes的HPA弹性架构会实时采集集群整体的负载指标，判断是否满足弹性伸缩条件和执行pod的伸缩。仅仅是pod的伸缩还不够，我们还需要在集群中使用Cluster Autoscaler组件，监控集群中由于资源分配不足无法被正常调度的pod，自动从云平台的实例池中申请增加节点，同时在流量下降的时候，Cluster Autoscaler组件也会检测集群中资源利用率较低的节点，将其中的pod调度到其他可用节点上，回收这部分闲置节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.3928571428571428&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWZibuAgWa6oF11j8FaTX8flH9K1HmruMp5BiagXY17DCBcq6pCWxk7xzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;364&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;弹性伸缩案例&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云原生的弹性特性不仅帮助减少资源使用成本，也提高服务对基础架构故障的容错率，在基础设施部分可用区中断不可用期间，其他可用区域会增加相应数量的节点继续保持整个集群的可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kubernetes支持对pod容器所需的CPU和内存调整，找到一个合理的配额以合理的成本达到最佳的性能。所以我们在服务上云前会做一些接近真实环境的负载测试，观察业务流量的变化对集群性能的影响（业务周期性高峰和低峰的资源使用率，服务的资源瓶颈，合适的余量资源buffer应对尖刺流量等等）。既不会因为实际利用率过高导致稳定性问题，比如OOM或者频繁的CPU throttling，也不会因为过低浪费资源（毕竟，即使你的应用只使用了实例的1%，也要支付该实例100%的费用）。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;4.2.2 采用公有云竞价实例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;某些云平台会把一些闲置计算资源作为竞价实例，以比按需实例更低的定价出租，顾名思义竞价实例的最终费用是按市场供需出价决定的。按照我们实际使用的体验，如果不是特别热门的机型定价基本在按需实例费用的10-30%左右。低价的竞价实例自然有它的限制，云平台会可能会调整竞价实例池的资源比例回收部分实例，一般回收的概率根据统计通常&amp;lt;3%, 同时在回收前会提前2分钟通知到这些实例。我们通过AWS提供的Terminal handler组件在收到回收通知后提前把容器调度到其他可用的实例上，减少了资源回收对服务的影响。下图是某云对竞价实例的资源池划分，我们可以看到，即使相同的实例资源，在不同的可用区也是独立的资源池。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8687350835322196&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWhovO4yX7s2aXj6ic9CO5ZT5QUBgVmyHdXCanjiaPnDXMPEnSG0LyzSRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了能最大限度减少竞价实例的中断影响，包括实例在多可用区的再平衡影响，我们在通过ASG（AWS auto scaling Group 弹性扩展组）选择不同实例类型的情况下还将不同的实例资源池独立使用ASG进行管理，这样保证了资源的最大利用效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5374310480693459&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWUhlJp3fS4ToQb8sRsQQOcJic1ZWf1ibSLocyQOAtBjmj3wU5UVzHAI4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程酒店直连使用按需实例和竞价实例的混合部署，保证低成本和高可用。一些系统关键组件（比如Cluster Autoscaler)，中断就会丢失数据的有状态服务（比如Prometheus）运行在按需实例。而对错误容忍度高，使用灵活无状态的业务应用运行在竞价实例上。通过kubernetes的节点亲和性控制不同类型的服务调度到对应类型标签的实例上。（见图8）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5586897179253867&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWxruH8DuXVMwGibeTYAKg4nic88CYafsB6qQVvFBUQ9CLz7vJrYhEXGGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1099&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过 kubernates 原生的 HPA 和 ClusterAutoscaler 组件结合 AWS ASG 及竞价资源的充分利用，可以将成本降低50%-80%。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;4.2.3 DNS 解析性能优化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当服务规模逐渐增大的时候，我们发现服务间的调用延时明显上升，平均达到1.5S，高峰达到2.5秒，经过分析发现，主要是因为 DNS 解析负载过高造成的性能解析瓶颈，最终我们采用社区比较主流的 localdns 方式，对热点解析域名做本地缓存，来降低对核心 DNS 频繁的解析请求从而提高性能：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8050541516245487&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCW35xDicSZLDpbFfMoqyibLnxcJt5dla1rpgiaeAkKRaKM4jsDpic1I7MPdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图9所示，在每个Node部署基于DaemonSet的NodeLocal DNSCache，通过Node LocalDNS缓解CoreDNS服务的DNS查询压力，LocalDNS Cache 会监听所在的 node上每个 Client Pod 的 DNS 解析请求，通过本地的解析行为配置，Local DNS Cache 会尝试先通过缓存解析请求，如果未命中则去 CoreDNS 查询解析结果并缓存为下一次本地解析请求使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图，通过使用 LocalDNS 方案我们将高峰的延时从 2.5S 降低到 300ms，缩短了80%的响应时间：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;未使用LocalDNS前，平均响应在1.5-2.5S。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWmyQss8MlR6UicVxb5e0Eytbc4jXD6l2GUMeicfOc0S0u2ibDIuznGCgVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未优化前&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用LocalDNS 方案后，响应请求降低到300-400ms，延时优化了80%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWSSFyeYjy0BbfibDDfr6mE8mibBXj9mRk6z548IFCxMVINc5CNNQghjVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化后&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;4.2.4 公有云跨可用区流量优化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在使用竞价实例对资源进行大幅优化后，我们注意到跨可用区的流量在服务大幅扩展后占比非常高（60%），这是因为在服务之间调用时，我们将服务单元部署到不同可用区，最大限度提高服务的可用性，同时带来的问题是服务间大量的流量交互带来了跨可用区的流量费用（见图10）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.415748031496063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWibXjKIaGFf8XxjV0iacCY0HCP26fCzpTPQQ8TbJXoWkOEFUSNic8xGnRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是为了整个系统的高可用性，我们并不想将服务部署在单可用区，降低服务SLA。我们需要降低跨可用区流量的同时保证服务的高可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过不同的方案调研最终我们使用 AWS NLB 来暴露服务，通过 NLB 的 disable cross-az 功能，对同可用区的上下游服务进行流量可用区管控。同时使用之前提到的 local dns 组件，将上游服务访问NLB不同可用区的域名解析进行固化，保证了上下游的服务流量只能在可用区内部进行互通。改造后如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.43014996053670085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWMwzVzrY6KUYeveewYwGzUibDSor9doiaeDict16icyzM0vQaOfibgp767EA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1267&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后段服务因为会通过 K8s 的 Kube-proxy 进行转发造成跨可用区跨节点，我们选择使用 externalTrafficPolicy 本地策略，将转发流量固化在本地节点的服务上，但是同时本地转发策略也带来了一些问题（见图12）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7057673509286413&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWaGHvssBYT1nVN57SRxrd4Xc5UEcXhdWyE1WDLAFibHlmKo5uf4ricKmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，本地转发策略可能因为后端服务分布不均衡导致了流量黑洞和服务负载的不均衡，所以在这个基础上，我们利用 EKS 弹性扩展组策略对底层节点资源均衡分布到不同的可用区，同时利用 K8s 反亲和性策略，将服务尽量分布到不同可用区的节点上，最大程度的保证了流量的均衡性，同时保证了服务的跨可用区部署的高可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化后跨可用区流量降低了95.4%。（见图13）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35822401614530774&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dDUBJq6Eic1Ckmo0JYj0LCWutKlCMhrGj9bwRO5SYLoLrWTYsRXbAibM6gG7LeDp8nlekLNuDFeWXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;991&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图13&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;五、后续的优化改进方向&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前的架构虽然解决了我们业务上的一些问题，但还是有一些不足之处可以改进。为了可以就近访问供应商，我们使用了一个独立的VPC网络来部署和测试我们的集群，所以需要单独在云端部署相关的存储依赖以及日志监控组件，这样无疑增加了运维的难度以及服务在不同云上的迁移难度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在最新的架构设计中针对这个问题我们计划做如下改造，首先将需要在云端计算并且依赖持久化存储数据的功能迁移回携程IDC，这样这部分数据就不用再传到云端。其次因为公司在AWS的其他数据中心已经有一套成熟的环境，所以我们只需要配合OPS打通两个AWS数据中心之间的VPC网络，便可使用公司的日志和监控框架，减少运维成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;六、总结&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文通过携程酒店直连在云原生的实践，分享了如何快速在云上搭建一套稳定高效的生产环境实现快速交付、智能弹性，以及在云上的一些成本优化经验。借助云原生体系实现了基础设施自动化，释放一部分的运维工作，可以更多地投入到业务迭代，更敏捷地响应业务需求迭代，通过监控和日志实现快速试错和反馈。希望借此能帮助到更多想上云的团队，少走弯路，拥抱云原生带来的好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;团队招聘信息&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们是携程酒店研发团队，聚焦于通过技术创新提升酒店行业效率及全球用户的预订体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对海量的全球酒店数据，我们打造了中台服务，提供高并发、高稳定性的微服务。通过数据驱动的方式，不断提升AI算法在场景上的优化，为用户创造价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;期待你的加入，目前后端/前端/移动端/数据/算法等方向均有职位开放。&lt;/span&gt;&lt;span&gt;简历投递邮箱：&lt;/span&gt;&lt;strong&gt;tech@trip.com&lt;/strong&gt;&lt;span&gt;，邮件标题:【姓名】-【携程酒店研发】- 【职位】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1cv3UIOgXY9rASuDMliboCdRo672rVc84tpmE8ic1pWM0MVKNOicFfmniau7KOPP3icnPJtsksGOTGeIlQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>