<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8b4e05bc547156c0a7b2dd3ab3fbb541</guid>
<title>2块大号猫抓板送猫薄荷送小块</title>
<link>https://toutiao.io/k/2qh6etz</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;


&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7286ab39f1252fbe4dc39c87ea20ac1b</guid>
<title>[推荐] 作为研发Leader，如何做总结</title>
<link>https://toutiao.io/k/1g7flto</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1NDMwNDI0Mg==&amp;amp;action=getalbum&amp;amp;album_id=1659077022029004801#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1659077022029004801&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#技术管理&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;12个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;作为研发Leader，如何做总结&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;为什么要总结&lt;/h1&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;行有不得，反求诸己。—— 出自《孟子》&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学会从自身寻找原因，可以帮助我们成为更好的人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，无论是个人还是团队，在年底进行一些有针对性的总结（建议是数据化呈现），对于找到自身问题，提高和改进，还是有挺大帮助的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切忌，不是为了总结而总结。应该学会从客观的事实（数据化是个不错的手段），寻找问题的发生原因，从而尝试做改变，去改善问题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;准备工作&lt;/h1&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;💡 思考的框架 优于 思考的内容&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;避免流水账&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为研发Leader，在做总结时，我会首先避免流水账，不要先思考这1年来，我们做了什么，这样很容易陷入到细节中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;思考：我们需要什么样子的团队&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小时候，经常被问到，你想成为什么样的人。其实，管理团队也是一样的逻辑，先思考「我们需要什么样的团队」。在2021年初，我们团队定下的指导思想是「成为专业的团队」，所以，在接下来的1年时间里，我们都在遵循这个指导思想。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;建设团队的指导思想&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1214848143982001&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY9ermQ5zEHSTSkuzibePX4mOvTmP6wTXHaoCLSWmVBE1iaDBeQhX9KMwIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;抽象团队的工作分类&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.709375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY9qNYcJQxNtE5W5WGQTDdfT7yrQtcwEyib5xic6YDf1O32qFTT8V1kEIJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;我的思路&lt;/h1&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;做了什么&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议按照工作分类进行重点事项的陈述&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;做到了什么，没做到什么&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从做的事情，客观的数据反馈，和年初的目标，进行综合对比，进行分析，找到问题原因，为来年提供改善思路&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;分享自己或团队其他人的做事心得（方法）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意在提高团队认知，授人以鱼不如授人以渔&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;我的2021总结（部分）&lt;/h1&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;做了什么&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.53125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY9veQpJrAWPNgPOBgicdotmmovtVrQlibtTfDoYneTX12iavpBia9kzA2yrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY9qqvBsXLDAicbUl4SCvPBvAHPianGtcpqnz6Jf9FJe1uH3xweyue5HVvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY9BF20iciaehxWzsnOXERRAIzK7QE5F0G6xh9psHZxCEfPRttZhqeGFVnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Arch 架构&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Assets 技术资产&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY9iaObBgEdxo7X9tMlWRAOGlYAOwrXeypUXMoRgJwlWaSsqa8ia09aPekQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY9SfxG7SQkler7Tic2oKS3JOUrGuZrDq7HOyRibiadKec7Xvj2TB2icic69fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;团队&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;做到了什么，没做到什么&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;涉及&lt;/span&gt;&lt;span&gt;内容较敏感&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;分享自己或团队其他人的做事心得（方法）&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Jq6sJhMhoXXjbOm5NdflYTia6lFTXuqY96XrvFg81YQqla24asdwalNj7h5icyELgQ73XVFvv9hicGTcXUaG4jNuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15573e1dc54e414dec166f29636d73db</guid>
<title>[推荐] 真香啊！接私活必备的 N 个开源项目（附源码合集第一期）！收藏走起！</title>
<link>https://toutiao.io/k/he7umju</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context wx_tap_card js_wx_tap_highlight&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                                
                                &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;GitHub源码&lt;/strong&gt;
                                                                            &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                                        &lt;p class=&quot;original_primary_desc&quot;&gt;专注于GitHub项目源代码分析， 每日分享精品开源库。&lt;/p&gt;
                                                                    &lt;/div&gt;
                                &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                            &lt;/a&gt;
                        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a83ade3bd82e01dceec2c32d4fda8ca</guid>
<title>[推荐] Go 原生并发原语和最佳实践</title>
<link>https://toutiao.io/k/rdpao5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 编程语言是用并发作为一等公民创建的。它是一种语言，通过抽象出语言中并发原语1背后的并行性细节，您可以轻松编写高度并行的程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数语言都将并行化作为标准库的一部分，或者期望开发者生态系统提供并行化库。通过在 Go 语言中包含并发原语，你可以编写并行性的程序，而无需了解编写并行代码的来龙去脉。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、并发（Concurrent）设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的设计者非常重视并发设计，将其作为一种方法论，这种方法论的基础是交流关键信息，而不是阻塞和共享这些信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对并发设计的强调允许应用程序代码正确地按顺序或并行执行，而无需设计和实现并行化，这是常态。并发设计的想法并不新鲜，事实上一个很好的例子是从瀑布式开发到敏捷开发，这实际上是向并发工程实践（早期迭代、可重复过程）的转变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发设计是关于编写“正确”程序与编写“并行”程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中构建并发程序时要问的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我是否堵塞在临界区？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否有更正确（如以 Go 为中心）的方式来编写此代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我可以通过通信来提高代码的功能性和可读性吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果其中任何一个是 Yes，那么你应该重新考虑你的设计，考虑用 Go 的最佳实践。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Communicating Sequential Processes (CSP)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的一部分的基础来自 Hoare 的一篇论文，该论文讨论了语言需要将并发视为语言的一部分而不是事后的想法。该论文提出了一种线程安全队列，它允许应用程序中不同进程之间的数据通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通读这篇论文，你会发现Go 中的  &lt;code&gt;channel&lt;/code&gt; 原语与论文中对原语的描述非常相似，实际上这来自 Rob Pike 之前基于 CSP 构建语言的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pike 的一次演讲中，他将真正的问题确定为“需要一种方法来编写并发软件，以指导我们的设计和实现。”他接着说并发编程不是让程序并行化以更快地运行，而是“利用流程和通信的力量来设计优雅、响应迅速、可靠的系统。”&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通过通信实现并发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从 Go 的创建者那里听到的最常见的短语之一是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Don’t communicate by sharing memory, share memory by communicating. - Rob Pike&lt;/p&gt;&lt;p&gt;即：不要通过共享内存来通信，而是通过通信来共享内存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种观点反映了 Go 是基于 CSP 的事实，并且该语言具有用于在线程之间通信的本机原语（goroutine）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的代码是使用通信而不是使用 mutex 来管理对共享资源的访问的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Adapted from https://github.com/devnw/ttl&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// a TTL cache implementation for Go.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readwriteloop&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;   &lt;span&gt;// Create a channel to send data to.&lt;/span&gt;&lt;br/&gt;  outgoing = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    outgoing &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    )&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(outgoing)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// `value` is the shared &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// resource or critical section.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// incoming is the channel where data is&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// sent to set the shared resource.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; v, ok := &amp;lt;-incoming:&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// Exit the go routine.&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Write the data to the shared resource.&lt;/span&gt;&lt;br/&gt;        value = v.v&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// outgoing is the channel that &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// the shared resource on request&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- value:&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(incoming, outgoing)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; outgoing&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们看一下代码，看看它做了什么。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请注意，这没有使用 &lt;code&gt;sync&lt;/code&gt; 包或任何阻塞函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此代码仅使用 Go 并发原语 &lt;code&gt;go&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;chan&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;共享资源的所有权由 goroutine 管理。（第 17 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使该方法包含一个 goroutine，对共享资源的访问也不会并行发生。（第 30 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该 &lt;code&gt;select&lt;/code&gt; 语句用于检查读取或写入请求。（第 24 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 incoming 会更新该值。（第 24 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 goroutine 外部读取的通道使用共享资源的当前值执行对 outgoing 写入。（第 34 行）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于单个 goroutine 本身没有并行性，因此可以通过返回的只读通道安全地访问共享资源 。事实上，&lt;code&gt;select&lt;/code&gt; 这里使用该语句提供了许多好处。选择原语部分对此进行了更详细的介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堵塞 vs 通信&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堵塞：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;暂停临界区读/写的进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解阻塞的&lt;strong&gt;必要性&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解如何避免竞争和死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素由多个进程/线程直接共享&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通信：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据要求共享临界区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当有事情要做时，进程开始工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素是通过通信共享，而不是直接共享的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Go 原生并发原语&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Goroutine&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 Goroutine？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goroutine 是轻量级的线程。一旦 goroutine 从父 goroutine 中分离出来，它就会被移交给 Go 运行时执行。然而，与&amp;amp;in不同的是，bash这些进程被安排在 Go 运行时中执行，而不必并行执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2294455066921606&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowRmDVNKzB72JQwjiaFbUqiaz6lwnibYdtV5HkMD8hIKGgIaVR6NeIpWYGZAheTjDXlLVgWCGgOat49VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;Goroutine 拆分示例&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里“调度”的区别很重要，因为 Go 运行时多路复用 goroutine 的执行，以提高操作系统调度之上的性能。这意味着无法对 goroutine 何时执行做出任何假设。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 的泄露&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 &lt;code&gt;go&lt;/code&gt; 原语创建的 goroutine 很轻量，但重要的是要知道它们&lt;strong&gt;不是&lt;/strong&gt;免费的。清理 goroutine 对于确保在 Go 运行时中正确收集资源非常重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该花时间在设计上考虑清理。确保长时间运行的 goroutine 在发生故障时正确退出。同样重要的是不要创建无数的 goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成一个 goroutine 很简单，因此很容易无节制的生成新的 goroutine，生成的每个 goroutine 的最小开销约为 2kb。如果你的代码创建了太多 goroutine，并且每个 goroutine 都有很大的开销，那么栈空间可能不够。这在生产环境中调试起来非常困难，因为很难判断堆栈在哪里溢出以及堆栈在哪里泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发生堆栈溢出时，运行时将 panic，程序将退出，每个 goroutine 都会将堆栈信息打印到标准错误。这会在日志中产生大量噪音并且不是很有用。不仅堆栈信息没有用，而且还会输出大量数据（每个 goroutine 的日志，包括它的标识符和状态）。这也很难调试，因为通常操作系统上的日志缓冲区可能太小而无法容纳所有堆栈信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：公平地说，我只在应用程序使用&lt;strong&gt;超过 400,000 个&lt;/strong&gt;大型 goroutine 的生产环境中看到这种情况。这可能很少见，对于大多数应用程序来说都不是问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TL;DR：设计 goroutines 时要考虑到最终结果，以便它们在完成时正确停止。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 中的 panic&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，Go 应用程序中的 panic 是违反最佳实践的，应该避免。代替 panic，你应该返回并处理函数中的错误。但是，如果有必要使用  &lt;code&gt;panic&lt;/code&gt;，必须知道，在 goroutine 如果没有 defer 的 recover，panic 会导致整个应用程序崩溃。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;最佳实践：&lt;/strong&gt;不要 Panic！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在生产环境中非常难以调试，因为它需要&lt;code&gt;stderr&lt;/code&gt;重定向到文件，因为你的应用程序很可能作为守护进程运行。如果你有一个日志聚合器并且它被设置为监控标准错误或文件日志，这会更容易。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果不确定，可以在 goroutine 增加 defer/recover&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; r := &lt;span&gt;recover&lt;/span&gt;(); r != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// Handle Panic HERE&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Channels&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 中的 Channel 是什么？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源自 Hoare (1977) 的 Communicating Sequential Processes 论文通道是 Go 中的一种通信机制，它支持以线程安全的方式传输数据。它可用于安全有效地在并行 goroutine 之间进行通信，而无需 mutex。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道将构建并行代码的困难抽象到 Go 运行时，并提供了一种在 goroutine 之间进行通信的简单方法。从本质上讲，通道的最简单形式是数据队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 Rob Pike 的话来说：“Channels orchestrate; mutexes serialize.”&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通道在 Go 中是如何工作的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，通道是阻塞的。这意味着，如果你尝试从通道读取，它将阻止该 goroutine 的处理，直到有要读取的内容（即数据发送到通道）。同样，如果你尝试写入通道并且没有数据消费者（即从通道读取），它将阻止该 goroutine 的处理，直到有消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，围绕通道有一些非常重要的行为。Go 运行时被设计为非常高效，因此如果有一个 goroutine 在读取或写入通道上被阻塞，则运行时将在等待执行某些操作时使 goroutine 休眠。一旦通道有生产者或消费者，它将唤醒阻塞的 goroutine 并继续处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解这一点非常重要，因为它允许你通过使用通道显式地利用系统的 CPU 争用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 一个 nil 通道总是堵塞&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭 Channel&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 完成后，最好关闭它。这通过 &lt;code&gt;close&lt;/code&gt; 实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时可能无法关闭通道，因为它会在应用程序的其他地方引起 panic（即往关闭的通道写入）。在这种情况下，当通道超出作用范围时，它将被垃圾收集。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果通道被限制在同一个作用域（即函数），你可以使用 &lt;code&gt;defer&lt;/code&gt;关键字来保证函数返回时通道是关闭的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ch) &lt;span&gt;// Close the channel when func returns&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个通道关闭时，不允许再写入。注意关闭通道的方式非常重要，因为如果你尝试写入已关闭的通道，运行时将 panic。因此，过早关闭通道可能会产生意想不到的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道关闭后，它将不再阻塞读取。这意味着所有阻塞在通道上的 goroutine 都将被唤醒并继续处理。读取时返回的零值将是通道类型的值，读取返回的第二个值将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Read from closed channel&lt;/span&gt;&lt;br/&gt;  data, ok := &amp;lt;-ch&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;// Channel is closed&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在上面的示例中关闭了通道，则 &lt;code&gt;ok&lt;/code&gt;参数将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;  只读 channel 不能关闭&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中有几种不同类型的通道。它们每个都有各自的优点和缺点。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Unbuffered channels are the simplest type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建无缓冲通道，请调用 make 函数，并提供通道类型。不要在第二个参数中提供大小值，如上例所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无缓冲通道默认是阻塞的，并且会阻塞 goroutine 直到有东西要读取或写入。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Buffered channels are the other primary type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建缓冲通道，调用 make 函数，提供通道类型和缓冲区大小。上面的示例将创建一个缓冲区大小为 10 的通道。如果你尝试写入已满的通道，它将阻塞 goroutine，直到缓冲区中有空间。如果你试图从一个空的通道中读取，它将阻塞 goroutine，直到有东西要读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你想写入通道并且缓冲区有可用空间，则它不会阻塞 goroutine。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 通常，仅在真的需要时才使用缓冲通道。最佳实践是使用无缓冲通道。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;只读和只写 Channels&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道的一个有趣用例是拥有一个仅用于读取或写入的通道。当你有一个需要从通道读取但你不希望该 goroutine 写入时，这很有用，反之亦然。这对于下面描述的所有者模式特别有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是创建只读或只写通道的语法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Define the variable with var&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; writeOnly &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; readOnly &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  mychan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Assign the channel to the variable&lt;/span&gt;&lt;br/&gt;  readOnly = mychan&lt;br/&gt;  writeOnly = mychan&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;箭头指示通道的方向。&lt;code&gt;chan&lt;/code&gt;前面的箭头表示数据流进入通道，而 &lt;code&gt;chan&lt;/code&gt; 后面的箭头表示数据流流出通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读通道的一个示例是&lt;code&gt;time.Tick&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Tick is a convenience wrapper for NewTicker providing access to the ticking&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// channel only&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Tick&lt;/span&gt;&lt;span&gt;(d Duration)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;Time&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法返回一个只读通道，&lt;code&gt;time&lt;/code&gt;包以指定的时间间隔在内部写入该通道。这种模式确保了时钟滴答的实现逻辑与&lt;code&gt;time&lt;/code&gt;包隔离，因为用户不需要往通道写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要写入通道但你知道 goroutine 不需要从中读取时，只写通道非常有用。下面描述的所有者模式就是一个很好的例子 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 的设计注意事项&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计注意事项包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;哪个作用域拥有 channel？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非所有者有什么能力？&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;完全所有权&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;channel 将如何清理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个 goroutine 负责清理 channel？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;所有者模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Owner Pattern 是 Go 中的一种常见设计模式，用于确保通道的所有权由创建或拥有 goroutine 正确管理。这允许 goroutine 管理通道的整个生命周期并确保正确关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是 Go 中所有者模式的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewTime&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  tchan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; time.Time)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(tchan &lt;span&gt;chan&lt;/span&gt;&amp;lt;- time.Time)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(tchan)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; tchan &amp;lt;- time.Now():&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(tchan)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tchan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;NewTime 控制通道实例化和清理（第 2 行和第 5 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过定义只读/只写边界避免乱用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制行为不一致的可能性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于此示例的重要说明。上下文 &lt;code&gt;ctx&lt;/code&gt; 传递给函数 &lt;code&gt;NewTime&lt;/code&gt;并用于指示 goroutine 停止。&lt;code&gt;tchan&lt;/code&gt; 通道是普通的无缓冲通道，但以只读方式返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当传递给内部 goroutine 时，&lt;code&gt;tchan&lt;/code&gt;通道作为只写通道传递。因为内部 goroutine 提供了一个只写通道，所以它有责任在完成时关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;select&lt;/code&gt; 语句，&lt;code&gt;time.Now()&lt;/code&gt; 调用仅在从通道读取时执行。这确保&lt;code&gt;time.Now()&lt;/code&gt; 调用的执行与从通道读取同步。这种类型的模式有助于抢先减少 CPU 周期。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从通道读取的一种方法是使用&lt;code&gt;for&lt;/code&gt;循环。这在某些情况下可能很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; t := &lt;span&gt;range&lt;/span&gt; tchan {&lt;br/&gt;    fmt.Println(t)&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不推荐这种方法有几个原因。首先，不能保证通道会关闭（打破循环）。其次，循环不遵守上下文，这意味着如果取消上下文，循环将永远不会退出。&lt;strong&gt;第二点特别重要，因为没有优雅的方式来退出 goroutine。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我建议不要在通道上循环，而是使用以下模式，在该模式中使用带有&lt;code&gt;select&lt;/code&gt;语句的无限循环。这种模式确保检查上下文，如果它被取消，循环退出，同时还允许循环仍然从通道中读取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done(): &lt;span&gt;// Graceful exit&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; t, ok := &amp;lt;-tchan: &lt;span&gt;// Read from the time ticker&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; !ok { &lt;span&gt;// Channel closed, exit&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      fmt.Println(t)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文会详细讨论这个。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;转发 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在适当的情况下，将通道从一个转发到另一个也是一种有用的模式。这是使用&lt;code&gt;&amp;lt;- &amp;lt;-&lt;/code&gt;运算符完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是将一个通道转发到另一个通道的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;forward&lt;/span&gt;&lt;span&gt;(ctx context.Context, from &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  to := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; to &amp;lt;- &amp;lt;-from: &lt;span&gt;// Forward from into the to channel&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; to&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 使用此模式，你无法检测&lt;code&gt;from&lt;/code&gt;通道何时关闭。这意味着&lt;code&gt;from&lt;/code&gt;通道将不断地向 &lt;code&gt;to&lt;/code&gt; 通道发送数据，并且内部 goroutine 将永远不会退出，从而导致大量零值数据和 goroutine 泄漏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据你的使用场景，这可能是可取的，但是，重要的是要注意，当你需要检测关闭的通道时，这种模式不是一个好方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Select 语句&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt; 语句允许在 Go 应用程序中管理多个通道，并可用于触发操作、管理数据或以其他方式创建逻辑并发流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; data, ok := &amp;lt;- incoming: &lt;span&gt;// Data Read&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- data: &lt;span&gt;// Data Write&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;// Non-blocking default action&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;select&lt;/code&gt; 本质上是&lt;em&gt;随机&lt;/em&gt;的。这意味着如果有多个通道准备好同时读取或写入，该&lt;code&gt;select&lt;/code&gt;语句将随机选择一个 case 语句来执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 Select 语句&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select 语句的随机性会使测试 select 语句有点棘手，尤其是在测试以确保上下文取消正确退出例程时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个如何使用统计测试来测试 select 语句的示例，其中测试执行的次数确保测试失败的统计可能性很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此测试通过在并行例程中运行相同的已取消上下文 100 次来工作，其中两个上下文中只有一个已被取消。在这种情况下，总会有一个通道的消费者，因此每次循环运行时，都有 50% 的可能性会执行 context case。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过运行 100 次，有 50% 的机会选择触发上下文情况，测试将无法检测到所有 100 个测试的上下文取消的可能性非常非常低。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带上下文的 Work 取消&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建 Go 应用程序的早期，用户构建具有&lt;code&gt;done&lt;/code&gt;通道的应用程序，他们将在其中创建一个看起来像这样的通道：&lt;code&gt;done := make(chan struct{})&lt;/code&gt;，这是一种非常简单的方法，可以向 goroutine 发出它应该退出的信号，因为你所要做的就是关闭通道并将其用作退出信号。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Example of a simple done channel&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; doWork(done)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Exit anything using the done channel&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(done)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Do some more work&lt;/span&gt;&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &amp;lt;-done&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(done &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;      &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式变得如此普遍，以至于 Go 团队创建了context 包 作为替代。该包提供了一个接口&lt;code&gt;context.Context&lt;/code&gt;，可用于向 goroutine 发出信号，告知它在&lt;code&gt;Done&lt;/code&gt; 方法返回的只读通道返回时退出 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，他们还提供了一些用于创建分层上下文、超时上下文和可以取消的上下文的方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;context.WithCancel&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回 &lt;code&gt;context.Context&lt;/code&gt;以及&lt;code&gt;context.CancelFunc&lt;/code&gt;，可用于取消上下文的函数字面值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithTimeout&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与&lt;code&gt;WithCancel&lt;/code&gt;返回一致，但具有超时，将在指定&lt;code&gt;time.Duration&lt;/code&gt;时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithDeadline&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与 WithCancel 返回一致，但有一个截止日期，将在指定的时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：接受上下文的函数的第一个参数应该 &lt;strong&gt;始终&lt;/strong&gt; 是 context，并且应该命名为 &lt;code&gt;ctx&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://benjiv.com/go-native-concurrency-primitives/。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0ce6332a80e1c8c88a3c6cb74cd1dc00</guid>
<title>[推荐] 如何撰写好的技术方案设计-真实案例干货分享</title>
<link>https://toutiao.io/k/0f5fv4t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;一、 前言&lt;br/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个技术开发者，特别是高级、资深开发、架构师等，往往会遇到根据需求撰写技术方案。那么如何撰写一篇好的技术方案设计，我们今天就来聊一聊这个话题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、 技术方案是否有必要&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是肯定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我见过太多由于前期规划不到位（甚至是没有技术方案设计，开个技术讨论会口头沟通一下，就直接评工期开干的），这其中不乏很重要，工期很长的项目。而最后呢，到联调阶段各组串不起来，更可笑的是，产品和产品同学之间都没沟通清楚。导致最终很被动，到处挖坑补洞，而且花费了更多的时间和精力，甚至导致项目延期，后续扩张性不强等等问题。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我认为，技术方案是必不可少的一个环节。往往很多坑在这个阶段就可以避免的。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;古人云:&quot;磨刀不误砍柴工&quot;，技术方案就是磨刀的过程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.282339707536558&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67WicOEAfAcyiaosXCicREoJVkCPrLdvThA88KIdpqSibJ3aiatGQqWRxbwfJ6kicGjaxZk3kSUCB5yUnWLOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;方案设计&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、 如何写好技术方案&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要贴合需求，满足需求是大方向。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可实施。要考虑当前条件下是否可落地，如：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;团队人员接受能力:技术选型的时候，要考虑团队成员接受能力，盲目引入新技术，可能造成不可预知的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时间成本:  一般来说Java 或者 PHP 后端项目(c语言项目可能会做一年甚至更长时间)，3个月时间周期算是比较长的了，假如按照此方案，需要半年甚至更长时间，那可能也不切实际。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源成本: 例如，项目可能需要引入Redis，Mysql，ES， MongoDB 等基础资源，那公司是否能提供这些资源(服务器是要钱的)。如果不能，在写技术方案时候，可能就需要考虑是否有替代方案。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应急处理&amp;amp;可靠性保障
只要人能想到的问题，就一定会发生，不能有侥幸心理。所以要做好出现问题的应对策略，这里就必须做好如：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、技术方案模板&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是我总结的技术方案设计模板，希望对大家所有帮助。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、背景&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前的背景现状，简要说明以往业务所遇到的问题，给出本次项目迭代的原因，解决的技术痛点或业务痛点&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、目标&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过次方案要达到什么样的业务指标，例如，支撑多少QPS，性能相比现在提升多少倍，为后期水平扩展做铺垫&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、整体方案&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1)架构图
2)流程图
3)时序图
4)调用链路图&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、存储设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如Mysql表结构设计，缓存设计，ES存储设计等等，说明Schema、字段类型、默认值、描述信息等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、接口定义&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列举出接口的结构，参数，返回值等&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6、灰度方案&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按什么方式灰度，如何做灰度方案，用表格的形式列出分几个阶段灰度，每个阶段大概时间多长。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7、降级方案&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当出现问题如何降级操作，如何回滚。将风险降到最低程度。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8、关联系统(功能)影响&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点需要各组注意的地方，相关人员需要特别关注，一一确认到位&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9、资源分配情况&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;人力资源: 实现方案需要多少人力投入(开发人力，测试人力，运维人力)等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;硬件资源: 实现上述方案，列举需要哪些物理机器资源，运维人员需提前准备。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10、预估工期及时间节点&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列举出工期及关键时间节点，如，什么时候联调，什么时候提测，什么时候开始灰度上线，以及后续的迭代完善计划等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、温馨提示&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也给大家总结了我之前做系统重构写的技术方案设计文档（线上真实版本，已脱敏)，给大家总结了2套， 有需要的朋友可以公众号后台留言&quot;方案&quot;即可获取，也欢迎有兴趣的朋友一起交流学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67WicS8obXBjC9RqxibSJcgOsnicwSlKjFSxuEECwjZjYS8Y9zpmCdyv6z4yeSicSQSDNz2XUzRppBjuGXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>