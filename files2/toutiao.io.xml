<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ed1a3f9574dc4a82f905bed79de88918</guid>
<title>解析分布式系统的缓存设计</title>
<link>https://toutiao.io/k/pucrtli</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;25&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Zhang Peng&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、缓存简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 什么是缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存就是数据交换的缓冲区。缓存的本质是一个内存 Hash。缓存是一种利用空间换时间的设计，其目标就是更快、更近：极大的提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将数据写入/读取速度更快的存储（设备）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将数据缓存到离应用最近的位置；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将数据缓存到离用户最近的位置。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存命中率是缓存的重要度量指标，命中率越高越好。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;缓存命中率 = 从缓存中读取次数 / 总读取次数&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 何时需要缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;引入缓存，会增加系统的复杂度。所以，引入缓存前，需要先权衡是否值得，考量点如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据层引入缓存，有以下几个好处：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 缓存的基本原理&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;根据业务场景，通常缓存有以下几种使用方式：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;懒汉式(读时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;饥饿式(写时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.4 缓存淘汰策略&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存淘汰的类型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）基于空间&lt;/strong&gt;：设置缓存空间大小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）基于容量&lt;/strong&gt;：设置缓存存储记录数。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）基于时间&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缓存淘汰算法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）FIFO：先进先出&lt;/strong&gt;。在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）LRU：最近最少使用算法&lt;/strong&gt;。在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在 1 个小时的前 59 分钟访问了 1 万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）LFU：最近最少频率使用&lt;/strong&gt;。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、缓存的分类&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存从部署角度，可以分为客户端缓存和服务端缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;客户端缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;HTTP 缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;浏览器缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;APP 缓存（1、&lt;span&gt;Android  2、&lt;/span&gt;&lt;span&gt;IOS）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务端缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;CDN 缓存：存放 HTML、CSS、JS 等静态资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;反向代理缓存：动静分离，只缓存用户请求的静态资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库缓存：数据库（如 MySQL）自身一般也有缓存，但因为命中率和更新频率问题，不推荐使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程内缓存：缓存应用字典等常用数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式缓存：缓存数据库中的热点数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中，CDN 缓存、反向代理缓存、数据库缓存一般由专职人员维护（运维、DBA）。&lt;span&gt;后端开发一般聚焦于进程内缓存、分布式缓存。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 HTTP 缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 CDN 缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;321&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyib8hzr838nIZicibTqibaqzR6WloDHz8S5o3bG5f06v6F97dv8f3wwghvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片引用自：&lt;/span&gt;&lt;a href=&quot;https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Why use a CDN&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.1.1 CDN 原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）未部署 CDN 应用前的网络路径：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）部署 CDN 应用后网络路径：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;请求&lt;/strong&gt;：本机网络（局域网） =&amp;gt; 运营商网络&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;响应&lt;/strong&gt;：运营商网络 =&amp;gt; 本机网络（局域网）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高了系统的响应速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1.2 CDN 特点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地 Cache 加速&lt;/strong&gt;：提升访问速度，尤其含有大量图片和静态页面站点；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;实现跨运营商的网络加速&lt;/strong&gt;：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;远程加速&lt;/strong&gt;：远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;带宽优化&lt;/strong&gt;：自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;集群抗攻击&lt;/strong&gt;：广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;31&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;67&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;1.解决方案（主要是在性能和数据一致性二者间寻找一个平衡）。&lt;/p&gt;&lt;p&gt;2.设置缓存失效时间（1 个小时，过期后同步数据）。&lt;/p&gt;&lt;p&gt;3.针对资源设置版本号。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 反向代理缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5885558583106267&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtykNRn1bK3lEibicbVgYibCHgxSYn62bxI0h7kulr8D0PxXibbfkAagbEic7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1101&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2.1 反向代理缓存原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。反向代理缓存的原理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理。常用的缓存应用服务器有 Varnish，Ngnix，Squid。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.2.2 反向代理缓存比较&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、进程内缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.1 ConcurrentHashMap&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最简单的进程内缓存可以通过 JDK 自带的 HashMap 或 ConcurrentHashMap 实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;适用场景：不需要淘汰的缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缺点：无法进行缓存淘汰，内存会无限制的增长。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 LRUHashMap&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以通过继承 LinkedHashMap 来实现一个简单的 LRUHashMap。重写 removeEldestEntry 方法，即可完成一个简单的最近最少使用算法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;锁竞争严重，性能比较低。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不支持过期时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不支持自动刷新。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3  Guava Cache&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;解决了LRUHashMap 中的几个缺点。Guava Cache 采用了类似 ConcurrentHashMap 的思想，分段加锁，减少锁竞争。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。直接通过查询，判断其是否满足刷新条件，进行刷新。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4  Caffeine&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Caffeine 实现了 W-TinyLFU(LFU + LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。其实现原理较复杂，可以&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903660653117447#comment&quot; textvalue=&quot;参考你应该知道的缓存进化史&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;参考你应该知道的缓存进化史&lt;/a&gt;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 Ehcache&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;快速、简单;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持多种缓存策略：LRU、LFU、FIFO 淘汰算法；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存数据有两级：内存和磁盘，因此无需担心容量问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存数据会在虚拟机重启的过程中写入磁盘；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以通过 RMI、可插入 API 等方式进行分布式缓存；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;具有缓存和缓存管理器的侦听接口；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持多缓存管理器实例，以及一个实例的多个缓存区域；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提供 Hibernate 的缓存实现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.6 进程内缓存对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;常用进程内缓存技术对比：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5877502944640753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFty1y6mRsm9kwvAyrPuwQSoajLA97CwMauXsASQA8LPUZxug5yZ7iawIgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总结一下：如果不需要淘汰算法则选择 ConcurrentHashMap，如果需要淘汰算法和一些丰富的 API，推荐选择。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、分布式缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存。&lt;span&gt;分布式缓存的应用场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存经过复杂计算得到的数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存系统中频繁访问的热点数据，减轻数据库压力。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 Memcached&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Memcached 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 &lt;span&gt;Hash&lt;/span&gt; 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.1 Memcached 特性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.1.2 Memcached 工作原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1）内存管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 利用 slab allocation 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）缓存淘汰策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 的缓存淘汰策略是 LRU + 到期失效策略。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：Memcached 不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）分区&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Memcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而这种选取集群节点的算法常见的有三种：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 Redis&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.2.1 Redis 特性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;201&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;volatile-ttl &lt;/strong&gt;：从已设置过期时间的数据集中挑选将要过期的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：从已设置过期时间的数据集中任意选择数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;：从所有数据集中挑选最近最少使用的数据淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：从所有数据集中任意选择数据进行淘汰；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;noeviction&lt;/strong&gt; ：禁止驱逐数据。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;提供两种持久化方式 - RDB 和 AOF。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过 Redis cluster 提供集群模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.2.2 Redis 原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1）缓存淘汰&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 有两种数据淘汰实现；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）分区&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）主从复制&lt;/strong&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;174&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;完整重同步&lt;/strong&gt;（full resychronization） - 用于初次复制。执行步骤与 SYNC 命令基本一致。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;部分重同步&lt;/strong&gt;（partial resychronization） - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4）数据一致性&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.3  分布式缓存对比&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;95&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.16484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyicZQSWfYwFXlF57YX4OpaqoO9wzrCuJKPrtBhTnAP4Nicica79UrXj0iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;242&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.41813898704358066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyEXK2WQ488siamOyMcia9c5C6XSxBl3sNXNEmWs2N3ykTiam3iamVYdOJuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;MemCache&lt;/strong&gt;：只适合基于内存的缓存框架；且不支持数据持久化和容灾。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;：支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tair&lt;/strong&gt;：支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Memcached。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、多级缓存&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.1 整体缓存框架&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通常，一个大型软件系统的缓存采用多级缓存方案：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;278&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.48125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyEELHaavtTEhnoTRJxcOYWqAicciaDZFop5TQiamRhS7FVeEMOHkTYic00A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;请求过程：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果 CDN 无缓存，则访问反向代理服务器；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果反向代理服务器有缓存则直接返回；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果反向代理服务器无缓存或动态请求，则访问应用服务器；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据（动态请求不缓存）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.2 使用进程内缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果应用服务是单点应用，那么进程内缓存当然是缓存的首选方案。对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种方案存在以下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.3 使用分布式缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。&lt;span&gt;其应用场景如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;567&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.9809220985691574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyXVxSdRPbjQ3rpicCIYf2icAbUVZdaAsuKsugfX86sqtc64hrLB3FGIEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。&lt;span&gt;这种方案存在以下问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;5.4 使用多级缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个典型的二级缓存架构，可以使用进程内缓存（如：Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;5.4.1 多级缓存查询&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;612&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.0585683297180044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFty5dhCH92Ldn6I0qenjQySsWum1jkibRPVJuic8lmNOEia64HJ3YfnYRB1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;多级缓存查询流程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;5.4.2 多级缓存更新&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;设置成写入后多少时间后过期；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置成写入后多少时间刷新。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于 L2 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。&lt;span&gt;为了解决进程内缓存不一致的问题，设计可以进一步优化；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyqZ7ZgCgtHDE3cMEACcd83kDoO3ichSdvuSPpJ65gCdiaEoaicLpCBLGWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、缓存问题&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.1 缓存雪崩&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举例来说，对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决缓存雪崩的主要手段如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;增加缓存系统可用性（事前）&lt;/strong&gt;。例如：部署 Redis Cluster（主从+哨兵），以实现 Redis 的高可用，避免全盘崩溃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;采用多级缓存方案（事中）&lt;/strong&gt;。例如：本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限流、降级、熔断方案&lt;/strong&gt;（事中），避免被流量打死。如：使用 Hystrix 进行熔断、降级。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缓存如果支持&lt;strong&gt;持久化&lt;/strong&gt;，可以在恢复工作后恢复数据（事后）。如：Redis 支持持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面的解决方案简单来说，就是多级缓存方案。系统收到一个查询请求，先查本地缓存，再查分布式缓存，最后查数据库，只要命中，立即返回。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决缓存雪崩的辅助手段如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.2 缓存穿透&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;解决缓存穿透，一般有两种方法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）缓存空值&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5835095137420718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyxQnpuZxFgzLpeDup59ZN9XLZlMqoXS2UI7NF0Hj185hAUcpZlHW1uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2）过滤不可能存在的数据&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5483193277310925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtylc4NiaR6gRAtojMPBV1eM7gFNZaHHXyoMMWQvZVnsp0LSrUvQPGVGrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;制定一些规则过滤一些不可能存在的数据。可以使用布隆过滤器（针对二进制操作的数据结构，所以性能高），比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;193&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.3 缓存击穿&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存击穿是指，热点数据失效瞬间，大量请求直接访问数据库。例如，某些 key 是热点数据，访问非常频繁。如果某个 key 失效的瞬间，大量的请求过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了避免这个问题，我们可以采取下面的两个手段:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;6.4 小结&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面逐一介绍了缓存使用中常见的问题。这里，从发生时间段的角度整体归纳一下缓存问题解决方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事前&lt;/strong&gt;：Redis 高可用方案（Redis Cluster + 主从 + 哨兵），避免缓存全面崩溃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事中&lt;/strong&gt;：（一）采用多级缓存方案，本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。（二）限流 + 熔断 + 降级（Hystrix），避免极端情况下，数据库被打死。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;事后&lt;/strong&gt;：Redis 持久化（RDB+AOF），一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分布式缓存 Memcached ，由于数据类型不如 Redis 丰富，并且不支持持久化、容灾。所以，一般会选择 Redis 做分布式缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、缓存策略&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.1 缓存预热&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存预热是指系统启动后，直接查询热点数据并缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.2 如何缓存&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;7.2.1 不过期缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存更新模式：&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开启事务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写 SQL；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提交事务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不要把写缓存操作放在事务中，尤其是写分布式缓存。因为网络抖动可能导致写缓存响应时间很慢，引起数据库事务阻塞。如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种模式存在这样的情况：存在事务成功，但缓存写失败的可能。但这种情况相对于上面的问题，影响较小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;7.2.2 过期缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;采用懒加载。对于热点数据，可以设置较短的缓存时间，并定期异步加载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7.3 缓存更新&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将读请求和写请求串行化。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般来说缓存的更新有两种情况:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;先删除缓存，再更新数据库；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;先更新数据库，再删除缓存；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;97&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;为什么是删除缓存，而不是更新缓存呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;你可以想想当有多个并发的请求更新数据，你并不能保证更新数据库的顺序和更新缓存的顺序一致，那就会出现数据库中和缓存中数据不一致的情况。所以一般来说考虑删除缓存。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于一个更新操作简单来说，就是先去各级缓存进行删除，然后更新数据库。&lt;span&gt;这个操作有一个比较大的问题，在对缓存删除完之后，有一个读请求，这个时候由于缓存被删除所以直接会读库，读操作的数据是老的并且会被加载进入缓存当中，后续读请求全部访问的老数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.2846580406654344&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyeLibVGWQibiciaWia5xaR1wt5bohatPaf9GfialNMlWPlRmEeegdCYQzYomg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对缓存的操作不论成功失败都不能阻塞我们对数据库的操作，那么很多时候删除缓存可以用异步的操作，但是先删除缓存不能很好的适用于这个场景。先删除缓存也有一个好处是，如果对数据库操作失败了，那么由于先删除的缓存，最多只是造成 Cache Miss。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）先更新数据库，再删除缓存&lt;/strong&gt;（注：更推荐使用这种策略）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果我们使用更新数据库，再删除缓存就能避免上面的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是同样的引入了新的问题：假设执行更新操作时，又接收到查询请求，此时就会返回缓存中的老数据。更麻烦的是，如果数据库更新操作执行失败，则缓存中可能永远是脏数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）应该选择哪种更新策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过上面的内容，我们知道，两种更新策略都存在并发问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但是建议选择先更新数据库，再删除缓存，因为其并发问题出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且同时有一个并发写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果需要数据库和缓存保证强一致性，则可以通过 2PC 或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。更详细的分析可以参考：&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/rjzheng/p/9041659.html&quot; textvalue=&quot;分布式之数据库和缓存双写一致性方案解析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;分布式之数据库和缓存双写一致性方案解析&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;八、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后，通过一张思维导图来总结一下本文所述的知识点，帮助大家对缓存有一个系统性的认识。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;247&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jhMgm28ic4icVjibwJZknFtyczlLSaLVPgEsh7ick39BQ7S9aPzrtsicrKZ4Pv1ON7l8p9GP8WICZo8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;九、参考资料&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;https://book.douban.com/subject/25723064/&quot; textvalue=&quot;《大型网站技术架构：核心原理与案例分析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;《大型网站技术架构：核心原理与案例分析》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903660653117447&quot; textvalue=&quot;你应该知道的缓存进化史&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;你应该知道的缓存进化史&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;https://juejin.cn/post/6844903665845665805&quot; textvalue=&quot;如何优雅的设计和使用缓存？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;如何优雅的设计和使用缓存？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;4、&lt;a target=&quot;_blank&quot; href=&quot;https://www.jianshu.com/p/73ce0ef820f9&quot; textvalue=&quot;理解分布式系统中的缓存架构(上)&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;理解分布式系统中的缓存架构(上)&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;5、&lt;a target=&quot;_blank&quot; href=&quot;https://tech.meituan.com/2017/03/17/cache-about.html&quot; textvalue=&quot;缓存那些事&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;缓存那些事&lt;/a&gt;&lt;/p&gt;&lt;p&gt;6、&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/rjzheng/p/9041659.html&quot; textvalue=&quot;分布式之数据库和缓存双写一致性方案解析&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;分布式之数据库和缓存双写一致性方案解析&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:203.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>562cc9a42b9444c5bd359425cdcb2153</guid>
<title>Go 内存泄漏排查实战</title>
<link>https://toutiao.io/k/6dmhylq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;例1：&lt;/span&gt;&lt;span&gt;Goroutine 泄漏&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;现象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NumGoroutine 指标持续上涨，且低峰期未下降，判断出现了 Goroutine 泄漏现象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2786885245901639&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8s9j5x5AtuZzX3UcDicNV8at2I9nCfxwgczicyzhZ5GJMnbPd6YOVsrIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;排查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过访问线上服务 pprof 暴露出来的 HTTP 接口，拿到当前所有协程的堆栈信息；curl http://「ip:port」/debug/pprof/goroutine?debug=2&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5887978142076503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8icd5vibqpaTVQ3BjDwYVCFTbibl5dyTic9pl88SDUS9mQpEzQdVqiam9odQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发现存在大量存活时间超过上千分钟的 Goroutine，观察堆栈疑似是 http 连接未释放导致，通过对下图 net.sockets.tcp.inuse（正在使用的tcp socket数量）指标的观察进行了进一步的确认；&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28825136612021857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8ZPe7BMpAHYgqfwiax3ghjZ1YVKNgJSE17lzNOIogZPxEXJFUN9BUy9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;结论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;http&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以本次 case http 服务为例，做简单介绍：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;上游服务作为客户端使用了 http1.1 并且将连接设置为 keepalive；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本服务作为服务端未设置 idletimeout 与 readtimeout；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这两种情况同时发生时，如果上游持有对本服务的连接不进行释放，那么服务端会一直维持这个连接的存在，不进行回收，进而导致协程泄漏；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;client&lt;/strong&gt;上游客户端可能为 GO、Java 等，以下为 GO 语言 http 客户端的空闲连接超时设置；&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2398843930635838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8x2ssG80ydbST6eeNHLbe4VSEE5VGevYlbZCcNOTUFEXLI9pHzmuf4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;strong&gt;server&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23319027181688126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV88f4Xia4hm4fJOk6ibvSxm959dYMJibU6qAV4lpmNYZ09zsP4PfiaCGu7Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18442622950819673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8KAq6DOmrqEy3J7vOhI5CAJgOXtoaB5ibChic3gYTJKW4ab4qgz73WnYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;建议启动 http server 尽量用后者，前者虽然简单，但是服务不够健壮；&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;thrift&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;server&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24180327868852458&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV86F1r18JxHIu80QPrH76atCpqiacozj2ptMOVDeZibzXWaf8zm6SlLHsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19672131147540983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV8Aj1QOpSTRVnUMxeBeGaIFjxQ5C0ugiaGdwHqQafMf4sqY3ymR80UkIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Tips&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的一点是，这个 Goroutine 泄漏问题不止在 http 下会发生，在 thrift、grpc 中也是同样的道理，如果服务端不对连接设置 timeout，某些情况下就会被上游拖死。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一起 goroutine 泄漏问题的排查&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例2：&lt;/span&gt;&lt;span&gt;内存居高不下&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;现象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存使用量（mem.rss）居高不下，且低峰期未下降，怀疑发生了内存泄漏现象；&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3975409836065574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkYNiaZsfpqZQ2cxK3UYReXcgiaxYbtpV81rhgxEMichNGXst0uM1Ut4bGGErftqibrXzZAg5BUTdUCRtAICqGTu7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;排查&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;刚开始怀疑时内存泄漏，但是抓取 pprof heap 图观察后，未发现泄露问题，且内存分配符合预期；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发现内存使用虽然居高不下，但未呈上涨趋势，因此修改关键字为“go 内存占用居高不下”，发现有相同问题；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;结论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来自于 GO 在将内存归还给操作系统时的内存释放策略，详情见官方 &lt;span&gt;issues&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，以下做简单介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GO 内存释放策略&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（此节内容整理自 &lt;span&gt;压测后go服务内存暴涨&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同策略的释放机制&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MADV_DONTNEED：内核将会在合适的时机去释放内存，但进程的 RSS（常驻内存）将会立即减少。如果再次申请内存，内核会重新分配一块新的空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MADV_FREE：只能在 linux 内核版本 4.5 以上才能使用，此操作理论上只是打了一个标记位，只有在内核感觉到内存压力的时候才会将这些打标记的内存回收掉，分配给其他进程使用。这个策略下进程的 RSS 不会立即减少。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同策略的实际差别&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;理论上 MADV_FREE 效率要高一些，通过在页表中做标记的方式，延迟内存的分配和回收，可以提高内存管理的效率，毕竟内存的回收和分配都是会消耗系统性能的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;导致的 RSS 指标变化
MADV_DONTNEED 会导致进程 RSS 会有明显的下降；MADV_FREE 会导致进程 RSS 平稳在高峰，不会得到立即释放；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同 GO 版本的释放策略&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 GO1.12 之前，默认均选择的 MADV_DONTNEED 策略进行内存回收；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 GO1.12~GO1.15，官方默认选择 MADV_FREE 策略进行内存回收；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 GO1.16 及之后，又改回了 MADV_DONTNEED 策略进行回收内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在 GO1.12~GO1.15 且内核版本 4.5 以上，mem.rss 指标已经无法准确观测服务内存占用；&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决方法&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不解决，对程序性能有利，但是会降低一些可观测性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以下任一方法可以解决，但会损失一定性能
把 export GODEBUG=madvdontneed=1 写进服务 control.sh 脚本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;升级 GO 版本至 1.16 及以上；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;一起 goroutine 泄漏问题的排查: &lt;span&gt;https://zhuanlan.zhihu.com/p/100740270&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;issues: &lt;span&gt;https://github.com/golang/go/issues/42330&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;压测后go服务内存暴涨: &lt;span&gt;http://soiiy.com/go/17114.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ad9e74da4a2ab152030830fc291f410</guid>
<title>深度解密（三）：OpenYurt边缘容器架构与原理</title>
<link>https://toutiao.io/k/r0ac2aw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;巨子嘉&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;juzijia-club&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;容器，微服务及开源产品在大企业中的平台产品化建设之路&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb0a51d8ebddc6b71980236f4745b12e</guid>
<title>「码农周刊 VIP 会员专属邮件周报」每周五发送，赶紧上车吧！</title>
<link>https://toutiao.io/k/5tfu473</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca9d91c40ed260456a4e28fbae17f7b2</guid>
<title>K8s 安全策略最佳实践</title>
<link>https://toutiao.io/k/oyzcd21</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 K8s 在生产和测试环境中用的越来越多，对安全性的关注也会越来越多，所以本次演讲主要是给大家分享以下内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;了解 K8s 环境面临的安全风险&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解 K8s 提供的安全机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;改善 K8s 安全状况的最佳实践&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. K8s 安全风险&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5243619489559165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqR3heVne1ntXlelEWTH7afkvlDnWE3KgnvDJvqTnBPpibCdXn5Yb2l3Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2586&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图是 CNCF 金融用户小组总结的 K8s 信任边界图，它把在 K8s 环境中的信任边界划分成三大块儿。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;容器镜像相关部分&lt;/strong&gt;，主要涉及到的安全攻击点就是镜像仓库和镜像本身。红色曲线可以被视为独立边界的系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;K8s 控制平面相关部分&lt;/strong&gt;，如果说一个攻击者攻击你的 K8s 集群的话，首先会攻击 K8s 的控制平面，中间涉及到的组件就是 K8s 的 apiserver、scheduler 和 controller-manager，所以说这些组件之间调用链的安全也需要去注意。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;节点上运行时的安全&lt;/strong&gt;，其中包括 kubelet、kube-proxy 和容器运行时环境也容易被攻击，要避免运行环境被渗透。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5267452402538532&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqRTRibULO2Aq06NFYM1eVgDricAllO9x197D0LcZshficJXhtPeluNqLKcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2206&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们根据不同的攻击类型划分，首先最容易规避的就是来自外部的攻击。通常情况下，来自外部的攻击会有 2 种类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种是系统层面的漏洞，需要及时更新，及时跟进 K8s 社区和安全领域相关的最新消息，可以很好的规避。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个是应用本身带来的渗透或者是提权的风险，业务部署在 K8s 之上，应用的漏洞可能造成容器越权或者容器逃逸之类的风险。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5460405156537753&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqRUMfiaquaVeDQHXwjfNArvNic8oj9m3AJ68cQLl3j528s3zZic3z67yLvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2172&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助恶意容器进行攻击也比较常见，在使用容器的过程种主要会面临以下风险：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用了不受信任的镜像仓库或者是使用了被篡改的容器镜像会导致恶意代码被执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容器执行恶意代码存在提权或者逃逸的风险。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使容器运行时足够安全，无法提权或逃逸，内部暴露的服务也容易成为被攻击的点，造成数据被恶意访问。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5401662049861495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqReCPCUP1s1LIOSicxDCgl6jrpIWZGKvmtk2J8UaUQ5AacaJUJ24nQ5rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2166&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 集群的规模变大，运维人员与终端用户也会变多，安全凭证的泄露，会对整个集群的安全造成威胁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使集群保护的非常好，在安全凭证没有泄漏的情况下，来自内部成员的恶意攻击也难以规避，即使是在测试环境也需要一定程度的租户隔离，避免来自内部的攻击、对数据的恶意访问。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. K8s 安全机制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5401662049861495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqRIhLmLAfs3Tb1HpTSRibTJYHfdmciaGg2gRCaESHibnDhCKG1NkXL6yQyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2166&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 K8s 社区，安全问题的关注度是非常高的，在 K8s 的设计中，各组件都有安全相关的特性。在 API 认证层面，控制平面中各个组件之间，需要开启 mTLS 进行组件之间的互认证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 也支持丰富的认证、访问控制的机制，通常我们会借助 RBAC 对用户的权限进行限制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5401662049861495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqR8GWKI72GTZctgPKVMgPCJqstcLYic4Mzqx3LLlnZ2nKkW4P0e7QejzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2166&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 还提供了针对容器能力的限制机制，我们可以通过 Security Context 去限制容器运行时的用户、用户组，对容器特权进行限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 中 Pod Security Policy 可以为集群应用安全策略，但是这个特性会在 1.25 之后被后面提到的 pod security admission webhook 替代。这是 K8s 提供的安全策略机制，非常建议大家去深入了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以用到 Resource Quota 结合 request、limit 限制容器的资源用量，尽可能的利用 linux 提供的安全特性，针对网络、cpu、内存等资源进行用量的限制。Limit Range 可以帮助我们为 Pod 设置默认的资源限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还可以针对 K8s 集群网络进行划分，通过 network policy 来支持网络隔离策略，设置黑名单或者白名单，为 namespace 去分配一独立的 IP 池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以借助 K8s 节点调度策略、污点管理，node selector 等机制去限制容器能够调度的节点，实现一定程度的物理隔离。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5401662049861495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqR4ElibI2SuLwunEHkFj8MVeufMKZhJG77tZJPZRYgicUDGxDxuOUqLyJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2166&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 还有一些和安全相关的内容，一个是审计日志，需要在 kube-apiserver 中进行开启。然后是 Pod Security Admission Webhook，这将是一个新的特性，帮助我们为集群应用安全策略。最后就是和数据安全相关，我们可以借助 KMS 来加密 etcd 中的数据，在容器运行时进行解密。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. K8s 安全最佳实践&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8s 安全最佳实践，大部分都是来自于社区用户和我们实际生产中环境中的经验总结。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5992939099735216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqR6sFnSv1r4qTV9ic5CewX30aKJlQqSbquk6eibgoBOSDiayb9y63JT0PQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是 K8s 社区的对云原生安全的安全总结，在云原生中主要分四个比较重要的层级：代码安全、容器安全，K8s 集群安全和云平台、数据中心的安全。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5992939099735216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqR1LYhKPGiaYUZZPCiaYTiatUsXQ6cGfr0DwwJg1Y9zVETl854yOs6UERAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这四个层面的安全问题，有不同的解决策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码安全&lt;/strong&gt;往往可以通过以下方式进行应对，比如说应用之间的通讯，尽量使用 TLS 或 mTLS，保证数据的加密传输。即使集群中大部分都是可信的环境，TLS 带来的性能损耗我认为也是在可以承受的范围之内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对代码安全的增强，通常需要我们在在 CI 或 CD 过程中对代码进行扫描，对容器镜像进行扫描，对应用安全进行扫描，即使很多工具会存在误报的情况，但在大规模的项目中这些步骤是必不可少的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5992939099735216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqRycDJA84LnnlVcGGlJ7Y3ERQxpT2CpZFic0MJK2GbDmaMiadG1tbYAeQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;容器安全方面&lt;/strong&gt;，我们建议尽可能的使用可信的基础镜像，除此之外，尽可能去删掉不必要的二进制，避免基础镜像中操作系统漏洞带来的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在容器运行的过程中尽可能的使用非 root 用户，除非是有特定的数据读写要求，可能会有一些问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5992939099735216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqRTOQNUZIzuiaylEMarvyiaxcIs0roWyzPJTeXysOsZA2b3V88Pq0qRELg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;集群安全&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;K8s 集群安全层面的建议，首先我们需要整理集群中所有关键组件的通讯矩阵，要知道哪些组件会用到哪些端口，比如说 K8s 控制平面常用的 10250,6443 端口等。对系统组件所用到的端口进行合理的管控，通过防火墙来提供最基础的保障。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据安全&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;在 K8s 集群中我们可以实现或接入已有的 KMS 服务，对 etcd 中的数据进行加密，在 etcd 数据泄漏的情况下也可以保证集群中 secret 数据的安全。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;网络安全&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;在 K8s 中我们可以借助 Network Policy 实现网络隔离，常用的网络插件 calico 和 Cilium 都可以很好的支持。不要开放不必要的端口，不仅是不对外开放端口甚至对于容器内部暴露的端口也要尽可能的去屏蔽。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对所部署的应用安全&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;尽可能的为每一个部署到 K8s 的容器配置 Security Context，限制容器内的运行用户和容器特权，禁止其直接读取或读写整个宿主机的网络和文件。再就是 K8s 针对安全策略的的增强，我们可以利用一些安全策略管理工具如 Gatekeeper，为整个集群运用一些安全策略以抵抗风险。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5992939099735216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqRY2CcfZAORvWYiaFYQGicFia7vEUGGjLKc8azrLm0SJtT2V8TzDUqfZdxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可观测性部分&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;不论是限制节点调度，还是配置网络隔离策略等，这些都是以很被动的方式主动进行防御。在复杂的分布式容器化环境中数据的可见性降低，借助可观测性工具，我们就可以及时的发现集群中异常，比如异常流量、异常的日志、异常的 API 访问等，这些对整个系统安全来说显得尤为重要。借助可观测性工具，无论是监控数据还是异常日志，都可以帮助我们在第一时间去发现问题，我们可以设置合理的告警策略进行防御。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;安全策略管理&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;K8s 集群安全策略，除了在使用过程中规范对使用者的要求，比如限制不可信的镜像仓库、特权容器、hostPath 挂载，也可以借助 Gatekeeper 这类安全策略管理工具进行主动的拦截。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5992939099735216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/u5Pibv7AcsEX4JFlqIPqS8xORxOUojNqR4TIqAJx6obdR5HMnLIrdS4uLYuGHbpraHTI8Oz0TjK1HZhD2VFXYPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;KubeSphere 中的安全增强&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;KubeSphere 是一个构建在 K8s 之上的容器管理平台，我们针对 K8s 安全问题提供了以下增强：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、借助可观测性组件增强异常的感知能力。借助日志、监控数据结合告警策略来提高异常感知的能力，增加数据的能见度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、支 Network Policy 实现网络隔离，支持 IP 池的管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、支持接入 Kata Containers 等更安全的运行时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、KubeSphere 社区中开源的 KubeEye，是一个可以实现集群自动巡检的小工具，可以帮助我们扫描集群中存在的安全风险、不合理的配置等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、KubeSphere 提供了 Gatekeeper 的集成，并计划提供可视化的管理界面，实现安全策略的管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、在 DevOps 流水线中我们可以集成代码、镜像等安全扫描工具。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>