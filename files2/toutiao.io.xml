<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6c90b68742c6a5dd955a3886ac1853a0</guid>
<title>疫情下的失业程序员；参与开源项目很难吗？Go语言之父介绍泛型｜码农周刊VIP会员专属邮件周报 Vol.086</title>
<link>https://toutiao.io/k/07qzhk3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2fcca9fc02fa57f74259e12fc987c578</guid>
<title>系统架构的11条原则</title>
<link>https://toutiao.io/k/xbwjqgj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;基本原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则一：价值为王&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;价值为王的另一种说法叫做YAGNI。YAGNI 是 You aren’t gonna need it 的缩写。该原则的基本含义就是，不应该开发任何当前不使用的功能。因为这些占用开发成本的功能，可能根本没有人用。而且不仅仅是开发成本打了水漂，你还要不断投入维护成本，来保证这些无人使用的功能可以正常运行。&lt;/p&gt;&lt;p&gt;要了解阿姆达尔定律，它告诉我们，我们不可能无限制的提升系统某一部分的效率。要提升的总体效果有没有产生相应的价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则二：以终为始&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484524&amp;amp;idx=1&amp;amp;sn=471a7ea978dece958c3b0285435551fe&amp;amp;chksm=fafdeec2cd8a67d43af8ef1a346b2f2b012eb738b44d0755e3b6d5a49f2ccede10fae94efe72&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;以终为始&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;以终为始&lt;/strong&gt;&lt;/a&gt;是一种思维模式，最早出自《黄帝内经》，先人是在告诫后人要在人生的春天就认真思考人生终点的意义和价值。其引申义有三：一是凡事要有目标；二是凡事要有计划；三是凡事要有原则。正所谓“凡事预则立，不预则废”。&lt;/p&gt;&lt;p&gt;白话来说，以终为始，就是在做事之前，先想想结果是什么样子的，这个结果是否能达到最初的目标。小心X-Y问题：为了解决 X问题，觉得用 Y 可以解，于是研究 Y 问题，结果搞到最后，发现原来要解决的 X 问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则三：分治原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;做架构时不要想着一次性把所有的功能都做好，要拥抱 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485060&amp;amp;idx=1&amp;amp;sn=02720887a28154ede413f85fa0af29f6&amp;amp;chksm=fafdec2acd8a653cbbbc8995eb9dd17053288aaa1509a2fc5f74d1ccc7f33d9d307ca76dbe7f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MVP&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;MVP&lt;/strong&gt;&lt;/a&gt;（Minimal Viable Product），最小可运行版本。先让程序完成最基本功能上线，根据反馈调整和决定下一步的迭代。&lt;/p&gt;&lt;p&gt;迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑，然后去迭代。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则四：服务自治&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;在系统设计时，要考虑服务上线后，对于问题要自感知、自修复、自优化、自运维及自安全。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则五：拥抱变化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;h1&gt;&lt;span&gt;重视架构扩展性和可运维性。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484368&amp;amp;idx=1&amp;amp;sn=b3c8d41b98ecf2b976d0b025c0322055&amp;amp;chksm=fafde97ecd8a6068cc4d25f2766261870a67baa4cbf9dc0d4920302fcf09e74ee682025efabc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;无状态的系统&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;无状态的系统&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来。否则，一旦需要改变，成本很高。&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则六：简单即正义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485195&amp;amp;idx=1&amp;amp;sn=9aa72718cdcc24d872f0a89cf63ea34f&amp;amp;chksm=fafdeda5cd8a64b3a55f4de3fdc48d2ee396074d851f686b70a7e679dbcf26862348a79182eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;简单即正义&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;简单即正义&lt;/strong&gt;&lt;/a&gt;的另一种说法叫做KISS。KISS(Keep it simple,sutpid)保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则七：尽量自动化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;人力成本既慢又贵，还有经常不断的人工失误。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;稳定性原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则八：依赖最简&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;p&gt;依赖原则是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484076&amp;amp;idx=1&amp;amp;sn=0c2b291a31ed53e9c8af06d131aabdd4&amp;amp;chksm=fafde802cd8a6114430a5c1eb8609481059341089ba2c4113012764578152570b6149780e3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;去除依赖、弱化依赖、控制依赖&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;去除依赖、弱化依赖、控制依赖&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;。多一个依赖多一分风险。能不依赖则不依赖，能异步弱依赖不要同步强依赖。实在不能弱依赖的，比如必须要调用加密存储来获取数据库的密码，不然无法连接数据库，可以控制获取密码在服务启动时进行，如果获取不到则服务启动失败，因为现在都是集群部署，一台无法启动不影响整体提供服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原则九：不作不死&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;p&gt;尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了。&lt;/p&gt;&lt;p&gt;等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则十：容灾容错&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485188&amp;amp;idx=1&amp;amp;sn=3618568ba3bf9c396195d8e2c4e6723d&amp;amp;chksm=fafdedaacd8a64bca74024452fb88a56ff99aa6bcd9ae841fca1b91cbff40d4dd78698b09dcc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Everything fails! &quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;Everything fails!&lt;/span&gt; &lt;/strong&gt;&lt;/a&gt;人都是要死的，机器都是要坏的。&lt;span&gt;如果一件事情有可能发生则在生产环境中一定会发生，架构中要做好容错设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原则十一：用成熟的技术&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解析：&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484324&amp;amp;idx=1&amp;amp;sn=78986320566babe59cc2c0da81c7f5b6&amp;amp;chksm=fafde90acd8a601ceff0bb501a0c1f6cd10b5408d3e4fed43d9e6c8605f800297abead8abdf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;不要给别人的技术当小白鼠&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;不要给别人的技术当小白鼠&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;，不要因技术本身的问题影响系统的稳定。尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改。在技术选型上，千万不要被——“你看某个公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一张图总结今天的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.939443535188216&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRliccwBMXSp9icdrUcDBcn7aU7asr1qCfg79N67CR0uKsu5FONagZrGE0x2WgiaMVChYcPYMvSYGqzjtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;611&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;&lt;span&gt;编程一生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因&lt;/span&gt;&lt;span&gt;为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486113&amp;amp;idx=1&amp;amp;sn=f3623b2cf257aa37ea83768fd4325762&amp;amp;chksm=fafde00fcd8a691928c66f7e484ab2b7f6fa7797dc32833a7f777bb4ebde58c010750f13c118&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PDCA方法论&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;PDCA方法论&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，检查自己是否错过更新：&lt;/span&gt;&lt;span&gt;每周三晚上8点左右，我都会更新文章，如果你没有收到，记得点开【编程一生】公众号找一下(*^▽^*)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>997facc71b928314cd27274f6f21ff5d</guid>
<title>Lyft微服务研发效能提升实践 | 3. 利用覆盖机制在预发环境中扩展服务网格</title>
<link>https://toutiao.io/k/cuqzep3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;怎样才能提高研发效率？是依赖于各自独立的本地开发测试环境，还是依赖完整的端到端测试？Lyft的这一系列文章介绍了其开发环境的历史和发展，帮助我们思考如何打造一套适合大规模微服务的高效研发环境。本系列共4篇文章，这是第3篇。原文：Scaling productivity on microservices at Lyft (Part 3): Extending our Envoy mesh with staging overrides&lt;span&gt;[1]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0ViakuqpKG829aZCvhDorrxxQgxEfGiaUFTgAGGibMRWfHeuSsiaEic80m63AgCVsAmOodh2MqBPicake6A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;本系列介绍的是Lyft在面对越来越多的开发人员和服务时，如何高效扩展开发实践，本文是第三篇。&lt;/p&gt;&lt;p&gt;在之前的文章中，我们描述了为快速迭代本地服务而设计的笔记本电脑开发工作流程。在这篇文章中，将详细介绍安全且隔离的端到端(E2E)测试解决方案：预生产共享环境。在深入研究实现细节之前，我们将简要回顾促使我们构建这一系统的问题。&lt;/p&gt;&lt;h3&gt;以前的集成环境&lt;/h3&gt;&lt;p&gt;在本系列的第1部分中，我们介绍了在之前用于多服务端到端测试的工具Onebox。Onebox的用户需要租用大型AWS EC2虚拟机来启动100多个服务，以验证修改是否能够跨服务边界工作。这种解决方案为每个开发人员提供了一个沙盒，运行自己版本的Lyft，控制每个服务的版本、数据库内容和运行时配置。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0ViakuqpKG829aZCvhDorrxx1s3xbch2V8icg0LY1KqUrv1icRKwMye8UB1q5QahBCvsInL2ZOl4gYnw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个开发人员都运行并管理自己独立的Onebox&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不幸的是，随着Lyft的工程师和服务数量的增加，Onebox遇到了规模问题(详情见第一篇文章)，我们需要找到可持续的替代方案来执行端到端测试。&lt;/p&gt;&lt;p&gt;我们将共享的预发环境视为一种可行的替代品。预发环境与生产环境的相似性让我们充满信心，但我们需要添加缺失的部分，从而提供一个安全的开发环境：隔离。&lt;/p&gt;&lt;h3&gt;预发环境（Staging Environment）&lt;/h3&gt;&lt;p&gt;预发环境运行与生产环境相同的技术栈，但使用了弹性资源、模拟用户数据以及人造web流量生成器。预发环境是Lyft一级环境，如果环境变得不稳定，SLO&lt;span&gt;[2]&lt;/span&gt;受到影响，随时待命的工程师和开发人员就会提升SEV&lt;span&gt;[3]&lt;/span&gt;。尽管预发环境的可用性和真正的流量增加了端到端的可信度，但如果我们鼓励广泛使用预发环境，就可能会出现一些问题：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;预发环境是完全共享的环境，就像生产环境一样，如果有人将一个故障实例部署到预发集群，就会影响到其他(可能是传递性的)依赖该服务的人。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;交付新代码的方式是将PR合并到主线，从而触发一个新的部署流水线。为了测试实验性变更如何在端到端环境中工作，需要承受大量的过程负担：编写测试、代码审查、合并，并通过CI/CD进行进展。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;这个繁重的过程可能会导致用户使用“逃生口”：将PR分支直接部署到预发环境。当未处理的提交在预发环境下运行时，将进一步放大降低环境稳定性的缺陷问题。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们的目标是克服这些挑战，使预发环境更适合手工验证端到端工作流。我们想让用户在准备阶段测试他们的代码，而不是被过程所困。如果他们的修订出现问题的话，最小化变更的影响半径。为了实现这一点，我们创建了&lt;code&gt;staging override&lt;/code&gt;。&lt;/p&gt;&lt;h5&gt;Staging Overrides（预发覆盖）&lt;/h5&gt;&lt;p&gt;Staging override是一组用于在预发环境中安全快速的验证用户变更的工具。&lt;span&gt;我们从根本上改变了隔离模型的方法：在共享环境中隔离请求，而不是提供完全隔离的环境。&lt;/span&gt;其核心是，我们允许用户重写通过预发环境的请求，并有条件的执行实验代码。大致的工作流程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在预发环境上创建一个不向服务发现注册的新部署，就是我们所说的&lt;em&gt;卸载部署（offloaded deployment）&lt;/em&gt;，并且保证向这个服务发出请求的其他用户不会被路由到这个(可能被破坏的)实例。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基础架构应该知道如何解释在请求头中嵌入的覆盖信息，从而确保覆盖元数据（override metadata）在整个调用图（request call graph）中传播。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改每个服务的路由规则，从而可以利用请求头中提供的覆盖信息，根据覆盖元数据指定的规则，路由到对应的卸载部署（offloaded deployment）。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5&gt;示例场景&lt;/h5&gt;&lt;p&gt;假设一个用户想要在端到端场景中测试新版本的&lt;code&gt;onboarding&lt;/code&gt;服务。之前基于Onebox，用户可以启动Lyft堆栈的整个副本，并修改相应服务，以验证是否如预期般工作。&lt;/p&gt;&lt;p&gt;如今在预发环境中，用户可以共享环境，但可以替换已卸载的实例，这些实例不会影响到正常的预发流量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0ViakuqpKG829aZCvhDorrxxC5aQQqmOn1mVRJXia0dq6QfzjBEcKQg2AK09sPaxJGpRvCupZOaoYxQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;典型用户向预发环境发出的请求不会通过任何被实时卸载的实例&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过给请求附加特定的头(&quot;&lt;em&gt;request baggage&lt;/em&gt;&quot;)，用户可以选择将请求路由到新实例：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0ViakuqpKG829aZCvhDorrxx4Yqw4cm7cBg07W8hr3JmVZto5418HBM9mXyZTzicth9AdrACHs1RF4g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;头部元数据允许用户在每个请求的基础上修改调用流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在本文的其余部分，我们将深入探讨如何构建这些组件来提供集成调试体验。&lt;/p&gt;&lt;h3&gt;卸载部署（Offloaded Deployments）&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5791666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0ViakuqpKG829aZCvhDorrxxv3yl7tLn8264ia93fGv89uib2sF8ickBeibic8iaaRhlibdOEfmoRyJdFaW6A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lyft使用Envoy作为服务网络代理，处理众多服务之间的通信&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在Lyft，每项服务的每个实例都被部署在一个Envoy&lt;span&gt;[4]&lt;/span&gt; sidecar旁边，作为该服务的唯一出入口。通过确保所有网络流量都通过Envoy，我们为开发人员提供了一个简化的流量视图，该视图以一种与语言无关的方式提供了服务抽象、可观察性和可扩展性。&lt;/p&gt;&lt;p&gt;服务通过向其Envoy sidecar发送请求来调用上游&lt;span&gt;[5]&lt;/span&gt;服务，Envoy将请求转发到上游的健康实例。我们通过控制平面更新Envoy的配置，控制平面基于Kubernetes事件通过xDS API&lt;span&gt;[6]&lt;/span&gt;进行更新。&lt;/p&gt;&lt;h5&gt;避免服务发现&lt;/h5&gt;&lt;p&gt;如果我们希望创建一个不会从网格中正常获取服务流量的实例，我们需要指示控制平面将其排除在服务发现之外。为了实现这一点，我们在Kubernetes pod标签中嵌入额外的信息，表示该pod已被卸载：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;app=foo&lt;br/&gt;environment=staging&lt;br/&gt;offloaded&lt;span&gt;-&lt;/span&gt;deploy=true&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们可以修改控制平面来过滤这些实例，确保它们在准备阶段不接收标准流量。&lt;/p&gt;&lt;p&gt;当用户准备在预发环境(本地迭代后)创建卸载部署时，首先必须在Github中创建一个pull request。我们的持续集成将自动启动部署所需的容器镜像构建。然后用户可以利用Github机器人显式的卸载部署他们的服务到预发环境：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0ViakuqpKG829aZCvhDorrxxpsmFSoCMOBeB8xq5JxJykvcL9pseKajicNOp3nyREicPnkqcMpM7cJNw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的Github机器人可以从PR简单的创建一个卸载部署&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过这一方式，用户可以为某个服务创建独立的部署，与普通的临时部署共享完全相同的环境：与标准数据库的交互，出口调用到其他服务，并且可以被标准的指标/日志/分析系统所观测。对于那些只想&lt;code&gt;ssh&lt;/code&gt;到实例并测试脚本或运行调试器而不担心影响预发环境其余部分的开发人员来说，这被证明非常有用。然而，当开发人员可以在手机上打开Lyft应用，并确保请求在一个卸载部署中得到PR代码的服务时，卸载部署才真正具有威力。&lt;/p&gt;&lt;h3&gt;覆盖报头和上下文传播（Override Headers and Context Propagation）&lt;/h3&gt;&lt;p&gt;要将请求路由到已卸载的部署，需要在请求中嵌入元数据，以便通知基础设施何时修改调用流。元数据包含想要覆盖的服务的路由规则，以及应该将流量引导到哪些卸载的部署上去。我们决定将这些元数据携带在请求头中，从而对服务和服务所有者保持透明。&lt;/p&gt;&lt;p&gt;不过，我们需要确保头信息可以通过使用不同语言编写的服务在网格中传播。我们已经使用OpenTracing报头(&lt;code&gt;x-ot-span-context&lt;/code&gt;)将跟踪信息从一个请求传播到下一个请求。OpenTracing有一个叫做“baggage&lt;span&gt;[7]&lt;/span&gt;”的概念，这是一个嵌在跨服务边界的报头中的持久化键/值结构。将元数据编码到baggage中，通过请求和跟踪库将其从一个请求传播到下一个请求，使我们能够进行快速的处理。&lt;/p&gt;&lt;h5&gt;构造和附加Baggage&lt;/h5&gt;&lt;p&gt;实际的HTTP报头是一个base64编码的trace protobuf&lt;span&gt;[8]&lt;/span&gt;。我们创建了自己的protobuf，命名为&lt;code&gt;Overrides&lt;/code&gt;，注入到跟踪的baggage中，如下代码演示：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;syntax = &quot;proto3&quot;;&lt;br/&gt;&lt;br/&gt;/* container for override metadata */&lt;br/&gt;message Overrides {&lt;br/&gt;  &lt;br/&gt;  // maps cluster_name -&amp;gt; ip_port&lt;br/&gt;  map&amp;lt;string, string&amp;gt; routing_overrides = 1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们可以将样本数据结构嵌入到跟踪baggage中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; base64 &lt;span&gt;import&lt;/span&gt; standard_b64decode&lt;span&gt;,&lt;/span&gt; standard_b64encode&lt;br/&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt; Flask&lt;span&gt;,&lt;/span&gt; request&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; lightstep&lt;span&gt;.&lt;/span&gt;lightstep_carrier_pb2 &lt;span&gt;import&lt;/span&gt; BinaryCarrier&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; overrides_pb2&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;header_from_overrides&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;overrides&lt;span&gt;:&lt;/span&gt; overrides_pb2&lt;span&gt;.&lt;/span&gt;Overrides&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;    Attach the `overrides` to the trace&#x27;s baggage and return the new `x-ot-span-context` header&lt;br/&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# decode the trace from the current request context&lt;/span&gt;&lt;br/&gt;    header &lt;span&gt;=&lt;/span&gt; request&lt;span&gt;.&lt;/span&gt;headers&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;x-ot-span-context&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    trace_proto &lt;span&gt;=&lt;/span&gt; BinaryCarrier&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    trace_proto&lt;span&gt;.&lt;/span&gt;ParseFromString&lt;span&gt;(&lt;/span&gt;standard_b64decode&lt;span&gt;(&lt;/span&gt;header&lt;span&gt;))&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# b64encode the provided custom `overrides` and place in the baggage&lt;/span&gt;&lt;br/&gt;    b64_overrides &lt;span&gt;=&lt;/span&gt; standard_b64encode&lt;span&gt;(&lt;/span&gt;overrides&lt;span&gt;.&lt;/span&gt;SerializeToString&lt;span&gt;())&lt;/span&gt;&lt;br/&gt;    trace_proto&lt;span&gt;.&lt;/span&gt;basic_ctx&lt;span&gt;.&lt;/span&gt;baggage_items&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&#x27;overrides&#x27;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; b64_overrides&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# re-encode the modified trace for use as an outgoing HTTP header&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; standard_b64encode&lt;span&gt;(&lt;/span&gt;trace_proto&lt;span&gt;.&lt;/span&gt;SerializeToString&lt;span&gt;())&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# create a sample `Overrides` proto that overrides routing for `users` service&lt;/span&gt;&lt;br/&gt;overrides_proto &lt;span&gt;=&lt;/span&gt; overrides_pb2&lt;span&gt;.&lt;/span&gt;Overrides&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;overrides_proto&lt;span&gt;.&lt;/span&gt;routing_overrides&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;users&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;10.0.0.42:80&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; Flask&lt;span&gt;(&lt;/span&gt;__name__&lt;span&gt;).&lt;/span&gt;test_request_context&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;/add-baggage&#x27;&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;br/&gt;    new_header_with_baggage &lt;span&gt;=&lt;/span&gt; header_from_overrides&lt;span&gt;(&lt;/span&gt;overrides_proto&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;span&gt;&quot;x-ot-span-context&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; new_header_with_baggage&lt;span&gt;})&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# {&#x27;x-ot-span-context&#x27;: b&#x27;Ei8iLQoJb3ZlcnJpZGVzEiBDaFVLQlhWelpYSnpFZ3d4TUM0d0xqQXVOREk2T0RBPQ==&#x27;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如何提取当前的trace并覆盖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;为了从开发人员那里抽象出这种数据序列化，我们为现有的代理应用程序添加了创建头的工具(请阅读更多关于代理的信息)。开发人员将客户端指向代理，从而可以用用户定义的Typescript代码拦截请求/响应数据。我们创建了一个助手函数&lt;code&gt;setEnvoyOverride(service: string, sha: string)&lt;/code&gt;，它将通过&lt;code&gt;sha&lt;/code&gt;查找IP地址，创建&lt;code&gt;Override&lt;/code&gt; protobuf，编码头部，并确保它被附加到通过代理的每个请求上。&lt;/p&gt;&lt;h5&gt;上下文传播（Context Propagation）&lt;/h5&gt;&lt;p&gt;上下文传播在任何一个分布式跟踪系统中都很重要。我们需要元数据在请求的整个生命周期内都可用，以确保许多深层调用的服务能够访问用户指定的覆盖。我们希望确保每个服务都能将元数据正确转发到请求流中后续的服务中——即使服务本身并不关心其内容。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/9utHkjMdE0ViakuqpKG829aZCvhDorrxxVlud0KyUjgEBibFiaeu53nsFEhCmczpAz6DT5YJlYY0kib84Wf0NeZKKA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调用图中的每个服务都必须传播元数据以实现完整的跟踪覆盖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Lyft的基础设施用我们最常用的语言(Python、Go、Typescript)维护标准的请求库，为开发人员处理上下文传播。如果服务所有者使用这些库调用另一个服务，上下文传播对用户就是透明的。&lt;/p&gt;&lt;p&gt;不幸的是，在这个项目推出期间，我们发现上下文传播并不像我们希望的那样普遍。最初经常有用户来找我们，说他们的请求没有被覆盖，罪魁祸首通常是trace丢失。我们投入了大量资金，以确保上下文传播能够跨各种语言特性(例如Python gevent/greenlets)、多种请求协议(HTTP/gRPC)以及各种异步作业/队列(SQS&lt;span&gt;[9]&lt;/span&gt;)工作。我们还添加了可观察性和工具来诊断涉及trace丢失的问题，例如标识没有添加头部的服务出口的指示板。&lt;/p&gt;&lt;h3&gt;扩展Envoy&lt;/h3&gt;&lt;p&gt;既然我们已经在请求中传播了重写元数据，就需要修改网络层来读取元数据并重定向到想要的卸载实例。&lt;/p&gt;&lt;p&gt;因为我们所有服务都是通过Envoy sidecar发出请求的，所以可以在这些代理中嵌入一些中间件来读取覆盖并适当修改路由规则。我们利用Envoy的HTTP过滤系统&lt;span&gt;[10]&lt;/span&gt;处理请求，因此在HTTP过滤器中实现了两个步骤：读取请求头的覆盖信息，并修改路由规则，从而将路由重定向到已卸载的部署。&lt;/p&gt;&lt;h5&gt;利用Envoy HTTP过滤器跟踪&lt;/h5&gt;&lt;p&gt;我们决定创建一个解码过滤器&lt;span&gt;[10]&lt;/span&gt;，允许我们在请求被发送到上游集群之前解析并对覆盖做出反应。HTTP过滤系统提供了简单的API，可以获取当前的目的路由以及正在处理的请求的所有报头。虽然是用C++实现的，但下面的伪代码反映了基本要点：&lt;/p&gt;&lt;p&gt;&lt;span aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;routing_overrides_filter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;route&lt;span&gt;,&lt;/span&gt; headers&lt;span&gt;):&lt;/span&gt;&lt;br/&gt;    routing_overrides &lt;span&gt;=&lt;/span&gt; headers&lt;span&gt;.&lt;/span&gt;trace&lt;span&gt;().&lt;/span&gt;baggage&lt;span&gt;()[&lt;/span&gt;&lt;span&gt;&#x27;overrides&#x27;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# {&#x27;users&#x27;: &#x27;10.0.0.42:80&#x27;}&lt;/span&gt;&lt;br/&gt;    next_cluster &lt;span&gt;=&lt;/span&gt; route&lt;span&gt;.&lt;/span&gt;cluster&lt;span&gt;()&lt;/span&gt; &lt;span&gt;# &#x27;users&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# modify the route if there&#x27;s an override for the cluster we are going to&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; next_cluster &lt;span&gt;in&lt;/span&gt; routing_overrides&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;# the user provided the ip/port of their offloaded deploy in the header baggage&lt;/span&gt;&lt;br/&gt;        offloaded_instance_ip_port &lt;span&gt;=&lt;/span&gt; routing_overrides&lt;span&gt;[&lt;/span&gt;next_cluster&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# &#x27;10.0.0.42:80&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;# redirect the request to the ORIGINAL_DST cluster with the new ip/port header&lt;/span&gt;&lt;br/&gt;        headers&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;x-envoy-original-dst-host&#x27;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; ip_port&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        route&lt;span&gt;.&lt;/span&gt;set_cluster&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&#x27;original_dst_cluster&#x27;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;过滤器使用Envoy的跟踪实用程序提取baggage中包含的覆盖。虽然过滤器总是可以访问像&lt;code&gt;traceId&lt;/code&gt;和&lt;code&gt;isSampled&lt;/code&gt;这样的跟踪信息，但我们首先必须修改Envoy，从而可以提取baggage中的信息&lt;span&gt;[11]&lt;/span&gt;。合并了这个更改后，过滤器就可以使用新的API来提取底层trace中的baggage：&lt;code&gt;routing_overrides = headers.trace().baggage()[&#x27;overrides&#x27;]&lt;/code&gt;&lt;/p&gt;&lt;h5&gt;最初目的集群（Original Destination Cluster）&lt;/h5&gt;&lt;p&gt;假设覆盖应用于当前目标集群，则必须将请求重定向到已卸载的部署。我们使用Envoy的原始目的地&lt;span&gt;[12]&lt;/span&gt;(&lt;code&gt;ORIGINAL_DST&lt;/code&gt;)将请求发送到一个由baggage提供的覆盖。&lt;/p&gt;&lt;p&gt;对于我们配置的&lt;code&gt;ORIGINAL_DST&lt;/code&gt;集群，最终目的地是由一个特殊的&lt;code&gt;x-envoy-original-dst-host&lt;/code&gt;&lt;span&gt;[13]&lt;/span&gt;报头决定的，它包含一个ip/port，如&lt;code&gt;10.0.42:80&lt;/code&gt;，HTTP过滤器可以改变这个报头来重定向请求。&lt;/p&gt;&lt;p&gt;例如，如果请求最初是为&lt;code&gt;user&lt;/code&gt;集群准备的，但是用户重写了ip/port，我们将把&lt;code&gt;x-envoy-original-dst-host&lt;/code&gt;更改为所提供的ip/port。&lt;/p&gt;&lt;p&gt;当&lt;code&gt;x-envoy-original-dst-host&lt;/code&gt;被修改后，过滤器需要将请求发送到&lt;code&gt;ORIGINAL_DST&lt;/code&gt;集群，以确保发送到新的目的地。这一需求促使我们对Envoy做出了第二个变更：支持路由可变性&lt;span&gt;[14]&lt;/span&gt;。合并此变更后，过滤器就可以改变目标集群：&lt;code&gt;route.set_cluster(&#x27;original_dst_cluster&#x27;)&lt;/code&gt;。&lt;/p&gt;&lt;h3&gt;结果&lt;/h3&gt;&lt;p&gt;通过卸载部署、传播baggage和Envoy过滤器，我们现在已经展示了预发覆盖🎉的所有主要组件。&lt;/p&gt;&lt;p&gt;这个工作流程极大改进了端到端测试的开销。我们现在每个月都有100个独立的服务部署，与以前的Onebox解决方案相比，预发覆盖有以下优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;环境配置：&lt;/span&gt; Onebox要求用户启动数百个容器并运行定制的种子脚本，需要开发人员花上至少1个小时准备环境。通过预发覆盖，用户可以在10分钟内通过端到端环境部署某个变更。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低成本基础设施：&lt;/span&gt; Onebox运行的是完全独立于预发/生产环境的技术栈，所以底层基础设施组件(例如网络、可观察性)通常是单独实现的。通过将端到端测试转移到预发环境，由于环境改进为集中维护，降低了基础设施支持的成本。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低成本功能验证：&lt;/span&gt; 由于Onebox和产品之间的差异，即使在Onebox端到端测试之后，用户也经常(合理的)怀疑代码的正确性。预发与生产环境在数据和流量模式方面更为接近，使用户更有信心相信如果变更在预发环境中就绪，也就意味着在生产环境中就绪。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;额外的工作&lt;/h5&gt;&lt;p&gt;启动预发覆盖是一项涉及网络、部署、可观察性、安全性和开发工具的跨组织工作。以下是一些没有涉及到的额外工作流程：&lt;/p&gt;&lt;h5&gt;未来的工作&lt;/h5&gt;&lt;p&gt;展望未来，我们可以通过预发覆盖做更多的事情，让用户重新创建想要验证的端到端场景：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可共享的baggage：&lt;/span&gt; 为用户提供一个集中管理的baggage存储，允许持久化一组独特的覆盖(服务&lt;code&gt;foo&lt;/code&gt;是X，服务&lt;code&gt;bar&lt;/code&gt;是Y，标签&lt;code&gt;baz&lt;/code&gt;是Z)，通过与团队成员共享确切的场景而改善协作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;覆盖用例：&lt;/span&gt; 让我们的基础设施了解其他覆盖，以便让用户控制请求的行为。例如，我们可以使用Envoy错误注入&lt;span&gt;[15]&lt;/span&gt;将人造延迟注入到请求中，临时启用调试日志记录，或者重定向到不同的数据库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;与本地开发集成：&lt;/span&gt; 我们可以允许重写请求，直接将请求重路由到用户的笔记本电脑，而不是要求用户在准备阶段启动他们的PR实例。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;请继续关注我们系列中的下一篇文章，我们将展示如何在交付阶段使用自动化验收测试对生产部署进行验收！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;References:&lt;/span&gt;&lt;br/&gt;[1] Scaling productivity on microservices at Lyft (Part 3): Extending our Envoy mesh with staging overrides: https://eng.lyft.com/scaling-productivity-on-microservices-at-lyft-part-3-extending-our-envoy-mesh-with-staging-fdaafafca82f&lt;br/&gt;[2] Service Level Objective: https://en.wikipedia.org/wiki/Service-level_objective&lt;br/&gt;[3] Severity Levels: https://response.pagerduty.com/before/severity_levels/&lt;br/&gt;[4] Envoy Proxy: https://www.envoyproxy.io/&lt;br/&gt;[5] Terminology: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/intro/terminology#:~:text=Upstream%3A%20An%20upstream%20host%20receives%20connections%20and%20requests%20from%20Envoy%20and%20returns%20responses.&lt;br/&gt;[6] xDS protocol: https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&lt;br/&gt;[7] Tags, logs and baggage: https://opentracing.io/docs/overview/tags-logs-baggage/&lt;br/&gt;[8] lightstep_carrier.proto: https://github.com/lightstep/lightstep-tracer-protos/blob/13cdeec9bd4a0ba2cd7062fecde3a057071edcb8/src/lightstep/lightstep_carrier.proto&lt;br/&gt;[9] Amazon Simple Queue Service: https://aws.amazon.com/sqs/&lt;br/&gt;[10] HTTP filters: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_filters&lt;br/&gt;[11] tracing: add baggage methods to Tracing::Span: https://github.com/envoyproxy/envoy/pull/12260&lt;br/&gt;[12] Original destination: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/original_dst&lt;br/&gt;[13] Original destination host request header: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/original_dst#original-destination-host-request-header&lt;br/&gt;[14] http: support route mutability: https://github.com/envoyproxy/envoy/pull/15266&lt;br/&gt;[15] Fault Injection: https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/fault_filter&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>59d91f46c428474f0caeea8d94ef512d</guid>
<title>云原生网络利器--Cilium 之 eBPF 篇</title>
<link>https://toutiao.io/k/12919uh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;245&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;361&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuC3hoRXeibWYXqlVcESFAHruVte7bickB6crt4jaTrHz2BvRzRTpb6NSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在上一篇《&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5NTUxNzE4MQ==&amp;amp;mid=2659274355&amp;amp;idx=1&amp;amp;sn=68acffa0684ad8546682e4a4d40bbdd8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;云原生网络利器--Cilium 总览&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;》的文章中，整体的介绍了一下 Cilium 中常见技术术语和总体的架构介绍。接下来的篇幅会重点介绍 eBPF 的一些关键特性，以及在 Cilium 中使用 eBPF 做了哪些工作，并介绍基本的原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;hr data-style=&quot;border-style: solid; border-width: 0px 0px 0px; border-color: rgba(0, 0, 0, 0.1); transform-origin: 0px 0px; transform: scale(1, 0.5);&quot; class=&quot;js_darkmode__10&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;总述&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;eBPF 是一种可以在不改变 Kernel 的前提下，开发 Kernel 相关能力的一种技术。开发 eBPF 的程序需要使用 C 语言，因为 Kernel 是 C 语言开发的，eBPF 在开发的过程中会依赖 Kernel 的 uapi 以及 Linux 的 Hepler 方法来完成处理。Linux 是基于事件模型的系统，也支持了 eBPF 类型 Hook，在一些 Hook 点执行挂载的 eBPF 程序。在不同的挂载点，支持不同类型的 eBPF 程序类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么 eBPF 会有类型？主要考虑的是，Linux 本身的能力非常多，而提供给外部可调用的方法是很少的，那就需要为不同的场景和能力，开放不同的系统调用能力，哪些能力在哪些类型下可以被调用，就跟 eBPF 的程序类型有关系了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例，对于处理网络的 eBPF 程序，不需要给这类型的程序开放处理存储的能力。对于一个程序而言，主要就包含了数据结构和算法两个部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 eBPF 中也是一样，程序自己的数据结构是可以自由定义的，但是有一 些和内核相关的能力以及 eBPF 内置提供的数据处理，就必须要依赖特定的数据结构，这里的数据结构就是 eBPF 的不同类型的 Maps。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来就是算法，eBPF 的算法是有一定的限制的，对于要调用内核的能力的，需要通过 Linux Hepler 的方式来完成调用，而 Linux Hepler 是跟着 Linux 的内核版本走的，当需要 Linux 开放一些新的能力给外部，就需要开发 Linux 的 Helper，合并到 Kernel 之后，eBPF 的程序才可以使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一部分的算法就是 eBPF 程序自己的业务逻辑了，同时在 eBPF 的算法部分中，有一个很重要的部分，就是 eBPF 程序之间互相调用的能力，这里有一个专业术语叫 Tail Call (尾部调用)。可以理解成，eBPF A 程序，调用 eBPF B 程序的时候，是经过 Tail Call 的方式，这种方式的调用，程序调用不会有返回，而是直接进入到另外一个程序，但是不同 eBPF 程序之间是可以通过 Pin 的机制共享这些数据结构的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cilium 中使用了大量得 eBPF 技术，实现了 K8s 的容器网络的能力。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;技术术语&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了更好的理解 Cilium 实现的数据平面的能力，首先需要对一些常见的 eBPF 的相关概念，有一个初步的认识，这样能更好的帮助理解原理。以下整理一些技术术语，不包含所有的，只是列出来一些主要的点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;eBPF 的命令：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对 eBPF 的常见操作是通过系统调用 SYSCALL 完成的。常见的操作：对 eBPF Map 的增删改查操作；Object 对象的 Pin 和 Get 操作；eBPF 程序的挂载和卸载。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3740458015267176&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibu5jnmntPmll31vM5zicQ7dvFwKaqxFlr7TE4KmgibQlreYg1O0zLGGYnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;eBPF 的 Map 类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里描述了 eBPF Maps 支持哪些类型的 Maps，不同类型 Map 的使用方式和场景会不一样。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.6478405315614617&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuicDrEr8iciaKP7GqbOQeWEkrWTMgy9MwLhOSpJTlyRy9Ih0icgdtYIG7tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;eBPF 的程序类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下描述了 eBPF 程序的类型种类，不同种类的 eBPF 会完成不同的能力。举例，如果是和 XDP 相关的能力，程序的类型就是 BPF_PROG_TYPE_XDP；如果是 tc 相关的能力，程序的类型就是 BPF_PROG_TYPE_SCHED_CLS 和 BPF_PROG_TYPE_SCHED_ACT。什么样的 Linux Helper 被加载，是由 eBPF 的程序类型决定的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4025974025974026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibukticpYU0Q9LqBToMlibZ7EbMUNnzic4Qv92Uk43Ln31XxnJVicfsM1v0iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;770&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;eBPF 的挂载类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的 eBPF 程序类型，就会有不同的挂载类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.053231939163498&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuaVWvicicTrWVFvNkic8R74sa9qd7V9DVeXWSg5PB5eK0TOgqYceia6Rchg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;eBPF Tail Call：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;顾名思义就是尾部调用，&lt;/span&gt;&lt;span&gt;主要的特点就&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;程序从一个调用到另一个，不像一般的程序语言的方法调用是有返回值，&lt;/span&gt;&lt;span&gt;Tail Call &lt;/span&gt;&lt;span&gt;不会有返回值的，而是从一&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;直&lt;/span&gt;&lt;span&gt;接就执行到下一&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;程&lt;/span&gt;&lt;span&gt;序，两&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;之&lt;/span&gt;&lt;span&gt;间是同级的，&lt;/span&gt;&lt;span&gt;不是方法调用的关系。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3669201520912547&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuSD2WAqykAQoNmgkuVyToCAnibghDX2N8pR3XC7IjR3f93soS1Bg3Zng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;eBPF Section：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以简单理解成 eBPF 程序的执行入口，可以在程序中指定 Section。举例：__section(&quot;from-netdev&quot;)。如果不指定的话，会有默认的 Section。在学习 Cilium 的 eBPF 程序的时候，推荐阅读的入口就是以每一种 eBPF 的 C 语言程序的 Section 部分为学习入口。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3904761904761905&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibunoqqrxhCVQ66YL4DHoKU2UKc6Sia8gmPtb9oiadQVNcMlTTsHEoqMSiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;eBPF Object Pin：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如字面意思，指的是将 eBPF Map Pin 到 Linux 的 bpffs 这个虚拟的文件系统中。主要的作用是让 eBPF 的 Maps，可以被 eBPF 程序或者用户态的应用读取和共享，在通过 Obj Get 之前，是需要先完成 Pin 动作，才可以被 Get。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7763888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuuRplX6keU7dddJsSwib7k0buFTicwjvKs7KPUwJrS7UHyia9iaibez1Rcyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Linux Helper：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 Linux 系统的角度，提供一些对外访问 Linux 系统能力的方法，供外部程序去使用。外部程序要使用 Kernel 的接口，那就只能通过 Linux Helper 来完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的 Kernel 版本支持的 Linux Helper 是不同的，版本越高，支持的能力越多，高级的能力也越多，使用这些高级能力的实现时，网络性能也会越高，这也是为什么很多 Cilium 的高级能力都需要特定版本的 Kernel。更多详情请参加 &lt;/span&gt;&lt;span&gt;bpf-helpers&lt;/span&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;XDP&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;eXpress Data Path，是数据包进入主机后，最早的一个支持 eBPF 的 Hook 点。可以在此阶段完成如过滤包、LB 等场景的能力。同时从运行的时机，又可以分为是硬件级的、网络驱动级的、内核级的，依次执行时机是硬件级的最早 (性能最好)，网络驱动级的其次，内核级的是最晚 (性能最差，一般用于 Poc，不建议生产使用)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;挂载 XDP 的 eBPF 程序 (这里的 sec 就是代表 eBPF 的 Section)：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ip link set dev em1 xdp obj prog.o sec foobar&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.279027902790279&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuVKf8pnET01MCVuvgoe6n5D1bsQq6kiaG974dOjgc0UfFib3Wic5Sb63Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1111&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;XDP 返回码：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;返回码代表的是在处理过程中，根据不同的逻辑需要对数据包进行不同的处理行为。举例，当觉得数据包需要被丢弃的时候，就需要在 eBPF 程序中返回 XDP_DROP，当觉得数据包被重定向出去的时候，可以返回 XDP_TX / XDP_REDIRECT；当觉得数据包需要继续进入到内核的时候，可以返回 XDP_PASS。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3559322033898305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibutibAsnE2cKgVFrHrlRhPPgGAkRe9TaoXsCc00PWqLFhmsgPG9lFRYiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;tc：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Traffic Control，每一个 Linux 识别的网络设备都支持 tc 的能力，包括物理的和虚拟的。在容器网络相关的网络设备的进出口的地方，&lt;span&gt;可以&lt;/span&gt;利用 tc 的能力来完成对网络数据包的控制能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时， tc 是支持两个方向的，一个是 ingress 的方向，一个 egress 的方向。而 XDP 只支持 ingress 的方向。可以理解成使用了 tc 的能力，可以在数据包进入一个网络设备的时候，进行相关处理，在出去的时候，也可以进行数据包的处理。而使用 XDP 的时候，只能在进入网络设备的时候，进行数据包的处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;挂载 tc 的 eBPF 程序 (这里的 egress 就是方向，sec 就是代表 eBPF 的 Section)：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;tc filter add dev em1 egress bpf da obj prog.o sec foobar&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2800718132854578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuIzygo3ZictHqo1lp9Astpia0icOgK3pTXXjBEgEw9ianaNS58IOkzB3bWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1114&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;tc 返回码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;返回码代表的是在处理过程中，根据不同的逻辑需要对数据包进行不同的处理行为。举例，当觉得数据包需要被丢弃的时候，就需要在 eBPF 程序中返回 TC_ACT_SHOT / TC_ACT_STOLEN，当觉得数据包被重定向出去的时候，可以返回 TC_ACT_REDIRECT；当觉得数据包需要继续进入到内核的时候，可以返回 TC_ACT_OK。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2144638403990025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuzfIgvXnTa9ql3f0lk6qCBGVy3gjypvcXw7UK6CyY2HLfnUHjkibt6lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Socket Redirect：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一种可以直接将一个 Socket 的数据包 redirect 到另一个 Socket 的能力，无需经过内核的网络协议栈，就可以加速本地的网络通信能力。注意这里是只在本地 Socket 之间数据包的通信，可以使用这种机制。这个能力也是 Kernel 提供的，属于 eBPF 范畴能力的体现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体的使用场景主要包含 Pod 内容器之间的通信，以及主机上的 Socket 网络之间的通信，以及所有可以本地通过 Socket 互相通信的程序之间。不局限于容器，二进制运行的主机进程也可以。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图提供一种从 Pod 内两个容器的 Socket Redirect 加速场景为例，介绍一下 Socket Redirect 的能力。可以看到 Socket Redirect 大概的使用方式，帮助理解，但是 Socket Redirect 不仅仅局限于这个场景，只要是本地的 Socket 都是可以使用这种特性。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4374429223744292&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibuysicwZuEHjiagtujq5Z9Bh3gGVEwqCicT82khZlqCAsBiaYicEZIwicjJNfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1095&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CTX Redirect：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;这是 Cilium 网络区别于其它网络方案的特点之一，通过 Kernel 的 redirect 完成网络设备到网络设备的数据包的传输能力。ctx_redirect(const struct __sk_buff *ctx __maybe_unused, int ifindex, __u32 flags)，从方法的定义中就可以看出来，将数据包转发到 ifindex 这个网络设备去。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Cilium 中，核心思想就是 bypass netfilter/iptables，直接通过 redirect 将数据包转来转去，缩短数据包的传输路径，提升网络性能。传统的玩法是所有网络设备的数据包，都要经过内核网络协议栈进行传递，数据路径比较长，对 netfilter/iptables 的体系依赖性比较强。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如下图，这里的数据包的 redirect 的方向是哪一个，取决于使用的内核的版本，大致可以帮助理解 CTX Redirect 的作用。下图仅仅是为了说明 redirect 是什么意思，不包含所有的数据路径，因为有一些数据流是一定要经过内核的处理，不在此图中具体分析。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里在内核版本较高的情况下，还可以使用 CTX Redirect 的升级能力，也就是 CTX Redirect Peer 和 CTX Redirect Neigh，网络性能会更好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6178414096916299&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibutwVXGUicsjVqBjicaAxdnRkia24qmKMIKolQN1ZgcXicibOOCxDN9wkLAhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;NodePort Acceleration：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 XDP 的技术，在南北向 NodePort 访问 K8s 服务的时候，进行网络加速的能力。包括直接 redirect 到本地 Pod；包括 redirect 到当前物理网卡或其它物理网卡的方式，forward 数据包去真正运行 Pod 的机器，这种情况下，会使用到 XDP_REDIRECT 或者 XDP_TX，具体取决于当前使用的 Cilium 版本是不是使用了支持 XDP 多网卡的 Feature。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管是本地的 Pod，还是其它机器的 Pod，都是使用的 eBPF 的网络技术完成数据包的处理能力，缩短了数据包在整个网络上的传输路径。如上图，物理网卡上的数据包的路径部分的箭头。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原理概述&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;这里的原理概述主要是，从 Cilium 中使用到的网络设备，以及网络设备上被挂载的 eBPF 程序，来理解 Cilium 在数据路径中，实现了哪些有特色的网络能力，以及从中可以看出来实现的大概原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5185512367491166&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibu3E32HkR4AvUGYOnYvunNswccX47Liaz5pQlV2QTb3iaLKJU14j2zPc7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cilium_host/cilium_net：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cilium Agent 在启动的时候，会初始化这一对虚拟网络设备。这是一对 veth pair 的虚拟的网络设备。其中 cilium_net 是 cilium_host 的 parent，而且没有 ip 地址，它是一种 netdevice，可以看成和物理网卡类似的设备。cilium_host 有设置 ip 地址，这个 ip 地址会作为 Pod 的网关，可以查看 Pod 的路由信息，看到对应的网关地址就是 cilium_host 的 ip 地址。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那是不是会理解成容器 Pod 里的数据包要想出去，就先将数据包发往 cilium_host？其实不是，通过 arp 的命令查看对应的 mac 地址，可以看到对应的 mac 地址，其实是 lxc-xxx 的地址，lxc-xxx 是什么，会在下面提到。所以 Pod 出来的数据包的第一跳，真正要经过的路径是 lxc-xxx。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那数据包到达 lxc-xxx 之后会发生什么？这个就要提到挂载在 lxc-xxx 的 tc ingress 的 from-container，这个 Section 对应的 eBPF 程序。那 cilium_net 是负责处理什么？cilium_net 的网络设备上也会挂载 eBPF 程序，这个程序是 bpf_host_cilium_net.o 文件中的 to-host Section，挂载的方向是 tc ingress。主要完成 ctx 的 encrypt 相关的 mark 操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Kernel 和 Cilium 版本比较低的时候，数据包要进入 Pod，都需要经过 cilium_host 设备，但是在高内核版本和比较新的版本 Cilium 版本中，cilium_host 就显得不那么重要了，主要用来处理本地流量访问 Pod 的情况。cilium_host 挂载的 eBPF 程序通过 tc 的方式完成，包括 from-host 和 to-host。cilium_net 挂载的 eBPF 程序通过 tc 的方式完成，包括 to-host。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cilium_vxlan：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;Cilium Agent 在启动的时候，会初始化这个虚拟的网络设备。主要的作用就是完成在 overlay 网络模式下，基于 vxlan/vtep 完成跨主机的网络数据通信。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Cilium 使用 UDP 8472 端口作为 vtep 端点的服务。vxlan 的数据包路由，也是通过 Kernel 的路由子系统完成路由发现，最后通过物理网卡，完成跨主机的 overlay 网络。cilium_vxlan 挂载的 eBPF 程序通过 tc 的方式完成，包括 from-overlay 和 to-overlay，具体 from-overlay 和 to-overlay 在下面会有相关说明。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;lxc-xxx/eth0：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个 Pod 都会有的一对 veth pair。这也是容器网络中最常见 Linux 提供的虚拟网络设备。一端在主机的网络空间，一端在容器的网络空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中 eth0 是容器端的，lxc-xxx 是主机端的。eth0 有自己的 ip 地址，lxc-xxx 是没有 ip 地址的。对于容器的出口流量，使用了 tc ingress 的方式，在 lxc-xxx 主机端的设备上挂载了 eBPF 程序，程序的 Section 是 from-container，具体 from-container 是负责什么，会在下面有相关说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个 Pod 的对应的 eBPF 程序是在创建 Pod 的时候，由 CNI 调用 Cilium Agent 的 create endpoint 的接口，由这个接口完成 Pod 相关 eBPF 程序的编译和挂载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在有了 from-container 来处理 Pod 的出口流量，那是不是应该也有一个 to-container 来负责处理 Pod 的入口流量，同时也挂载在 lxc-xxx 的 tc 上？&lt;/span&gt;&lt;span&gt;的确是&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt; t&lt;/span&gt;&lt;span&gt;o-container&lt;/span&gt;&lt;span&gt;，但是却不是挂载&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt; l&lt;/span&gt;&lt;span&gt;xc-xx&lt;/span&gt;&lt;span&gt;x &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; t&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;的，而是保存&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;种&lt;/span&gt;&lt;span&gt; M&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;，这&lt;/span&gt;&lt;span&gt;种&lt;/span&gt;&lt;span&gt; M&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;专门用来保&lt;/span&gt;&lt;span&gt;存&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;程&lt;/span&gt;&lt;span&gt;序的&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;BPF_MAP_TYPE_PROG_ARRAY&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;，见图中&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; P&lt;/span&gt;&lt;span&gt;OLICY_CALL_MA&lt;/span&gt;&lt;span&gt;P &lt;/span&gt;&lt;span&gt;这&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt; m&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;tem&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;tc ingress/egress：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;tc 是 Linux 中的能力，也是有 Hook 的，同时支持给 tc 挂载 eBPF 程序，来处理网络数据包。tc 对数据包的处理，支持 ingress 和 egress。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ingress 可以理解成数据包进入时候的 Hook，还有一个是 egress 的 Hook。两个 Hook 处理数据包的时机不一样，用来处理的能力也就不一样。tc 在 Cilium 中使用的是最多的，所有的网络设备都可以使用 tc，不管是物理的，还是虚拟的都一样。这也是 tc 为什么在 Cilium 中被广泛使用。在 Cilium 还没有支持 XDP 的南北向的 LB 的时候，就是由 tc 来完成 LB 能力的。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;XDP ingress：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;XDP 也是 eBPF 的 Hook 点，是数据路径最靠前的 Hook 点，一般可以用于对数据的快速过滤，以及可以基于 XDP 实现 LB 的能力。除了已经在数据路径比较靠前，XDP 的支持方式还有 3 种类型，一种是由硬件来支持，实现 XDP 的 Offload 效果；一种是基于硬件网卡驱动，在驱动层实现；一种是 Linux 内置实现的，也是性能最差的一种，不推荐生产上使用这种方式。越早处理性能越好，所以 Offload 机制的 XDP 效果最好，其次是网卡驱动的方式，最后是 Linux 内置的实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;eBPF Section：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;Section 是 eBPF 程序的执行入口，类似 main 函数，但是每一个 object 文件中是可以包含多个 Section 的。在 Cilium 中主要包含 XDP from-netdev，tc from-netdev，to-netdev，from-network，from-overlay，to-overlay，from-host，to-host，from-container，to-container，cgroup/connect，cgroup/bind，cgroup/post_bind，cgroup/sendmsg，cgroup/recvmsg，cgroup/getpeername，sk_msg，sockops。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;eBPF Maps：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;Cilium 中使用了很多 eBPF 中的 Maps。从文章开始的技术术语中，了解了相关概念之后，可以从 map 的 name 上看得出，这个 map 主要负责的是哪一部分的能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体主要包括以下这些：cilium_call_policy，cilium_ct4_global，cilium_ct_any4_global，cilium_events，cilium_ipcache，cilium_ipv4_frag_datagrams，cilium_lb4_affinity，cilium_lb4_backends，cilium_lb4_reverse_nat，cilium_lb4_reverse_sk，cilium_lb4_service_v2，cilium_lb_affinity_match，cilium_lxc，cilium_metrics，cilium_nodeport_neigh4，cilium_singals，cilium_snat_v4_external，cilium_tunnel_map，cilium_lb4_maglev，cilium_lb4_source_range，cilium_ipmasq_v4，cilium_encrypt_state，cilium_egress_gw_policy_v4，cilium_ep_to_policy。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有一小部分是根据运行时生成出来的，如：cilium_policy_[epid]，cilium_calls_hostns_[epid]，cilium_calls_netdev_[ifindex]，cilium_calls_[epid]，cilium_policy_[epid]。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;XDP from-netdev：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section，挂载在物理网卡的 tc ingress 上的 eBPF 程序。主要的作用是，完成主机数据包到达主机，对数据包进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有当开启了 ENABLE_NODEPORT_ACCELERATION 能力，才会在 XDP 阶段直接接手处理 NodePort 的访问。如果是没有开启的，数据包会直接进入内核，由 tc 的 from-netdev 来完成 NodePort 的处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当开启了之后，主要还是和 tc 的 from-netdev 类似，调用 nodeport_lb4 完成 nodeport 类型的 LB 操作。可以处理外部通过 K8s NodePort 的服务访问方式，访问服务，包括 dnat、lb、ct 等操作，将外部的访问流量打到本地的 Pod，或者通过 XDP 的 redirect 的方式，将数据流量转发到相同网卡或者不同网卡，然后最终将数据流量转发到提供服务的 Pod 所在的主机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上述能力，对于 XDP 的 from-netdev，如果开启了 ENABLE_PREFILTER，还会负责 Pre-Filter，可以理解成类似 ddos 的场景，当不被允许的访问流量到达之后，可以进行一个快速的验证，如果不被允许的，会快速的被 Drop 掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;tc from-netdev：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section，挂载在物理网卡的 tc ingress 上的 eBPF 程序。主要的作用是，完成主机数据包到达主机，对数据包进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里主要有两个场景会涉及到 from-netdev，第一个就是开启了主机的防火墙，这里的防火墙不是 iptables 实现的，而是基于 eBPF 实现的 Host Network Policy，用于处理什么样的数据包是可以访问主机的；第二个就是开启了 NodePort，可以处理外部通过 K8S NodePort 的服务访问方式，访问服务，包括 dnat、lb、ct 等操作，将外部的访问流量打到本地的 Pod，或者通过 tc 的 redirect 的方式，将数据流量转发到 to-netdev 进行 snat 之后，再转发到提供服务的 Pod 所在的主机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;to-netdev：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section，挂载在物理网卡的 tc egress 上的 eBPF 程序。主要的作用是，完成主机数据包出主机，对数据包进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里主要有两个场景会涉及到 to-netdev，第一个就是开启了主机的防火墙，这里的防火墙不是 iptables 实现的，而是基于 eBPF 实现的 Host Network Policy，用于处理什么样的数据包是可以出主机的，通过 handle_to_netdev_ipv4 方法完成；第二个就是开启了 NodePort 之后，在需要访问的 Backend Pod 不在主机的时候，会在这里完成 snat 操作，通过 handle_nat_fwd 方法和 nodeport_nat_ipv4_fwd 方法完成 snat。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;from-host：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section。挂载在 cilium_host 的 tc egress 上 eBPF 程序。主要完成数据流量导入到 Cilium-managed 的 network 中去。举例，如本地进程访问本地主机的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体完成的事情大致包含：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. 通过 tail call 机制完成要进入到 Pod 的数据包。&lt;/span&gt;&lt;span&gt;参见：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ep_tail_call&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ctx, CILIUM_CALL_IPV4_FROM_HOST&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;pv4_host_policy_egress&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ctx, secctx, ipcache_srcid, &amp;amp;monitor&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;完&lt;/span&gt;&lt;span&gt;成&lt;/span&gt;&lt;span&gt; h&lt;/span&gt;&lt;span&gt;ost polic&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;验证，也就&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;BP&lt;/span&gt;&lt;span&gt;F &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;主机防火墙，这个是在&lt;/span&gt;&lt;span&gt; cilium_hos&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;gress pat&lt;/span&gt;&lt;span&gt;h &lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;，也就是即将要进入&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt; P&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;一侧；&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; r&lt;/span&gt;&lt;span&gt;ewrite_dmac_to_host&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ctx, secctx&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;完&lt;/span&gt;&lt;span&gt;成&lt;/span&gt;&lt;span&gt; d&lt;/span&gt;&lt;span&gt;st &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; m&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;地&lt;/span&gt;&lt;span&gt;址的设置，将&lt;/span&gt;&lt;span&gt;其&lt;/span&gt;&lt;span&gt; d&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; m&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;设&lt;/span&gt;&lt;span&gt;置&lt;/span&gt;&lt;span&gt;成&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;ilium-hos&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;主机端&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ilium_ne&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; m&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;地&lt;/span&gt;&lt;span&gt;址，也就是下一跳，&lt;/span&gt;&lt;span&gt;当经&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ilium-hos&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; p&lt;/span&gt;&lt;span&gt;acket&lt;/span&gt;&lt;span&gt;，需经过下面步骤查询到&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;ndpoin&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt; local hos&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;ndpoint&lt;/span&gt;&lt;span&gt;，这个时候就需要回&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt; h&lt;/span&gt;&lt;span&gt;ost&lt;/span&gt;&lt;span&gt;，那回&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt; h&lt;/span&gt;&lt;span&gt;os&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;时候，就需要设&lt;/span&gt;&lt;span&gt;置&lt;/span&gt;&lt;span&gt; p&lt;/span&gt;&lt;span&gt;acke&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;目&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; m&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;地&lt;/span&gt;&lt;span&gt;址&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ilium_ne&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; m&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;地&lt;/span&gt;&lt;span&gt;址，这&lt;/span&gt;&lt;span&gt;样&lt;/span&gt;&lt;span&gt; p&lt;/span&gt;&lt;span&gt;acke&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;就&lt;/span&gt;&lt;span&gt;会被发送&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt; K&lt;/span&gt;&lt;span&gt;ernel Stac&lt;/span&gt;&lt;span&gt;k &lt;/span&gt;&lt;span&gt;去&lt;/span&gt;&lt;span&gt;，回到主机上&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;4. &lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; l&lt;/span&gt;&lt;span&gt;ookup_ip4_endpoin&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;找&lt;/span&gt;&lt;span&gt;到要访问&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;ndpoint&lt;/span&gt;&lt;span&gt;，然后使&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;pv4_local_deliver&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;方&lt;/span&gt;&lt;span&gt;法&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;完成数据包的转发处理&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在处理的过程中&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;会根据是不是&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt; N&lt;/span&gt;&lt;span&gt;etwork Polic&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;来&lt;/span&gt;&lt;span&gt;决定是不是要做验证。&lt;/span&gt;&lt;span&gt;具&lt;/span&gt;&lt;span&gt;体&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;pv4_local_deliver&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;作用如下：&lt;/span&gt;&lt;span&gt;ipv4_local_delivery 这个方法的主要作用，是处理本地的 packet 到 Pod 的核心方法。不管是 Pod 到 Pod 的，还是 cilium_host 到 Pod 的，还是 overlay 到 Pod 的，还是物理网卡到 Pod 的，只要是确定了是本地的 endpoint，那 packet 要进入 Pod 就是要这个方法来处理的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;to-host：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是一个 eBPF Section，挂载在 cilium_host 的 tc ingress 上 eBPF 程序。to-host 主要处理的是 ENCRYPT 加密操作和 TO_PROXY。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 ENCRYPT，主要是将 ctx→cb[CB_ENCRYPT_IDENTITY] 的 src identity 转换成 24 bit 的 identity，然后设置到 ctx 的 mark 的 value 中，用于标记数据包的安全身份；TO_PROXY 主要作用是当开启了基于 eBPF 的 tproxy 时候，提前抓取 proxy socket，然后将其与 ctx 关联起来，这是 tproxy 需要的配置，为真正的 packet 转发到代理做好准备。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;from-container：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是一个 eBPF Section，这个 Section 是和 Pod 最直接关联的 eBPF 的程序。挂载在 Pod 主机侧的虚拟网络设备上，也就是 lxc-xxx 这个网络设备，方向为 ingress。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;主要完成的事情包括如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. 当 packet 要从 Pod 出去，首先 packet 会经过 eth0 到达 Pod 对应的 lxc-xxx 的 tc ingress，这里的 ebpf 程序的 Section 是 from-container。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 数据包是从 Pod 发出去的，如果是 original 类型的数据包，会在这里完成数据包的 dnat 操作，管理连接跟踪；如果是 reply 类型的数据包，会完成 reverse dnat 的操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 对于有 Network Policy 验证需要的数据包，会经过 tproxy 的方式，将数据包发往 cilium proxy 去验证是不是可以 access，对于正常的从服务端返回的 reply 数据包，会标记成 skip policy，也就是不需要做验证。具体实现参考 policy_can_egress4 方法。从 Pod 里出来的数据包的目的方向大致可以分为几个路径：第一个是 Pod 访问本地的 Pod，经过 ipv4_local_delivery 来完成数据包的转发；第二个是 Pod 访问外网，经过 Kernel Stack 完成解析后，经过物理网卡的 to-netdev 出去；第三个是 Pod 访问本地的非 Pod 的，也是经过 Kernel Stack 完成；第四个是 Pod 访问非本机的集群其它机器中的 Pod，经过 Kernel Stack 完成解析后，经过物理网卡 to-netdev 出去；第五个是 Pod 经过 overlay 网络访问非本机的集群其它机器中的 Pod，经过 cilium_vxlan，然后经过 Kernel Stack 完成解析后经过物理网卡出去。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;to-container：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section，这是一个比较特别的 eBPF 的程序。它和 Pod 相关，但是却不是挂载在 tc egress 上的，而是以 eBPF 程序，保存在 eBPF 中的 map 中的，eBPF 中有一种 map 类型，是可以保存 eBPF 程序的 (BPF_MAP_TYPE_PROG_ARRAY) ，同时 map 中的程序都有自己的 id 编号，可以用来在 tail call 中直接调用，to-container 就是其中之一，而且是每一个 Pod 都有自己独立的 to-container，和其它和 Pod 相关的 eBPF 程序一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的主要作用就是，在数据包进入 Pod 进入之前，完成 Policy 的验证，如果验证通过了会使用 Linux 的 redirect 方法，将数据包转发到 Pod 的虚拟网络设备上。至于是 lxc-xxx 还是 eth0，看内核的版本支持不支持 redirect peer，如果支持 redirect peer，就会直接转发到 Pod 的 eth0，如果不支持就会转发到 Pod 的主机侧的 lxc-xxx 上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;from-overlay：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section，在选择使用 Cilium 的 overlay 网络模型时，会使用到和 overlay 相关的虚拟网络设备，这些设备是 Agent 在启动的时候，在主机空间创建出来的，基于 vxlan 的技术完成 overlay 网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;from-overla&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;挂载点&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;就是挂载&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ilium_vxla&lt;/span&gt;&lt;span&gt;n &lt;/span&gt;&lt;span&gt;这&lt;/span&gt;&lt;span&gt;个网络设备&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; t&lt;/span&gt;&lt;span&gt;c ingres&lt;/span&gt;&lt;span&gt;s &lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;的，主要处理的数据包是进&lt;/span&gt;&lt;span&gt;入&lt;/span&gt;&lt;span&gt; P&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;，在进&lt;/span&gt;&lt;span&gt;入&lt;/span&gt;&lt;span&gt; P&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;之&lt;/span&gt;&lt;span&gt;前会先经&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ilium_vxla&lt;/span&gt;&lt;span&gt;n &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; f&lt;/span&gt;&lt;span&gt;rom-overla&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;处&lt;/span&gt;&lt;span&gt;理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;主要完成的工作包括以下几点：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;1. &lt;/span&gt;&lt;span&gt;包&lt;/span&gt;&lt;span&gt;括&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;pse&lt;/span&gt;&lt;span&gt;c &lt;/span&gt;&lt;span&gt;安&lt;/span&gt;&lt;span&gt;全相关的处理；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;包括将数据包通&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;pv4_local_deliver&lt;/span&gt;&lt;span&gt;y &lt;/span&gt;&lt;span&gt;方&lt;/span&gt;&lt;span&gt;法&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;传递到后端服务在本机&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; P&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ase&lt;/span&gt;&lt;span&gt;，其中也会经&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; t&lt;/span&gt;&lt;span&gt;o-container&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; N&lt;/span&gt;&lt;span&gt;odePor&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;访&lt;/span&gt;&lt;span&gt;问服务时，服务不在本地的时候，使用&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt; f&lt;/span&gt;&lt;span&gt;rom-netde&lt;/span&gt;&lt;span&gt;v &lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;似的方式&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;去处&lt;/span&gt;&lt;span&gt;理&lt;/span&gt;&lt;span&gt; N&lt;/span&gt;&lt;span&gt;odePor&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;请求，其中包&lt;/span&gt;&lt;span&gt;括&lt;/span&gt;&lt;span&gt; d&lt;/span&gt;&lt;span&gt;nat&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;span&gt;操作，最后通过，&lt;/span&gt;&lt;span&gt;ep_tail_call&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ctx, CILIUM_CALL_IPV4_NODEPORT_NAT&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;者&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;p_tail_call&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ctx, CILIUM_CALL_IPV4_NODEPORT_DSR&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;方法完成数据包的处理，具体是哪种，取决&lt;/span&gt;&lt;span&gt;于&lt;/span&gt;&lt;span&gt; N&lt;/span&gt;&lt;span&gt;odePor&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; L&lt;/span&gt;&lt;span&gt;B &lt;/span&gt;&lt;span&gt;策&lt;/span&gt;&lt;span&gt;略&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;na&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;还&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt; d&lt;/span&gt;&lt;span&gt;sr&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;4. &lt;/span&gt;&lt;span&gt;数据包都是从物理网卡到达主机的，那是怎样到&lt;/span&gt;&lt;span&gt;达&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ilium_vxla&lt;/span&gt;&lt;span&gt;n 的？&lt;/span&gt;&lt;span&gt;这个是由挂载在物理网卡&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; f&lt;/span&gt;&lt;span&gt;rom-netdev &lt;/span&gt;&lt;span&gt;，根据隧道类型，将数据包通&lt;/span&gt;&lt;span&gt;过&lt;/span&gt;&lt;span&gt; r&lt;/span&gt;&lt;span&gt;edirec&lt;/span&gt;&lt;span&gt;t &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;方式&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;传递&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt; c&lt;/span&gt;&lt;span&gt;ilium_vxla&lt;/span&gt;&lt;span&gt;n &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;参见：&lt;/span&gt;&lt;span&gt;from-netde&lt;/span&gt;&lt;span&gt;v &lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;ncap_and_redirect_with_nodei&lt;/span&gt;&lt;span&gt;d &lt;/span&gt;&lt;span&gt;方&lt;/span&gt;&lt;span&gt;法，&lt;/span&gt;&lt;span&gt;其中主要有两个方法，一是__encap_with_nodeid(ctx, tunnel_endpoint, seclabel, monitor) 方法完成 encapsulating ，二是 ctx_redirect(ctx, ENCAP_IFINDEX, 0) 方法完成将数据包 redirect 到 cilium_vxlan 对应的 ENCAP_IFINDEX 这个 ifindex。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;to-overlay：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section，在选择使用 Cilium 的 overlay 网络模型时，会使用到和 overlay 相关的虚拟网络设备，这些设备是 Cilium Agent 在启动的时候在主机空间创建出来的，基于 vxlan 的技术完成 overlay 网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;to-overlay 的挂载点就是挂载在 cilium_vxlan 这个网络设备的 egress 上的。主要完成的工作包括：通过 nodeport_nat_ipv4_fwd 和 snat_v4_process 完成 egress 方向的 snat 操作，snat 的作用是跨主机访问的时候，需要将源地址改成主机的地址。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;to-overlay 处理的数据包是通过 lxc-xxx 的 from-container 程序 redirect 过来的数据包，这说明 to-overlay 处理的是 Pod 通过 vxlan 出去的数据包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;from-network：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个 eBPF Section，挂载在物理网络的设备中 tc ingress，如物理机器的 eth0 网卡，但是这个 eBPF 的程序是可选的，只有当设置了 EncryptInterface 的时候，才会编译和挂载这个程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要完成的工作是对数据包的解密操作，如果没有使用 ipsec 的加密，也就是 ENABLE_IPSEC 为 false，这里不会对数据包有任何修改，直接将数据包放回 Kernel。如果使用了 IPSEC，解密的时候，才会使用到这个程序，如果没有使用到，这个程序是不需要编译和挂载的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要实现的方式是设置 ctx 的 mark 为 MARK_MAGIC_DECRYPT(0x0D00) ，然后将数据包放回 Kernel Stack，由 Kernel Stack 完成 IPsec decryption。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cgroup/connect，cgroup/bind，cgroup/post_bind，cgroup/sendmsg，cgroup/recvmsg，cgroup/getpeername：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一些 eBPF Section，在 Cilium 中，使用了和 cgroup 相关的 eBPF 的能力，主要完成的事情是监测 socket 的 ops。在 socket 的操作过程中，执行相关的 eBPF 程序来完成 Socket LB 能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例，当要创建连接的时候，会先做一次 dnat，找到真正的后端的 Pod 的真实 ip 地址，用真实的 ip 地址来完成客户端和服务端的连接，而不是通过中间一层代理的方式，这样数据通信的效率得到提升，也是上文提到的 Host Reachable Service 的能力体现。包括在创建连接，指定 bind 的地址，以及发送和接受数据包的过程中，都可以做一些特殊的处理，来提升网络性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sk_msg / sockops：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一些 eBPF Section，在 Cilium 中支持 socket 加速的特性，可以完成本地 socket 和 socket 之间数据包的 redirect，而不需要经过内核底层的网络协议栈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例：在一个 Pod 中有两个容器，这两个容器之间会基于 socket 进行通信，这个场景是可以基于这个特性完成加速，当然不仅仅支持这一种 case，只要是本地的 socket 之间，都是可以完成加速，因为加速的范围是基于 cgroup 监听的所有主机上的 socket。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要实现的方式是依赖于 eBPF 中的 sockmap 和 msg_redirect_hash。sockmap 中保存的是 socket，msg_redirect_hash 是内核提供的，配合 sockmap 完成 socket 到 socket 的数据包的直接 redirect。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体哪些 socket 需要被处理，通过使用 sockops 中的能力，监测已经建立连接的 socket，将状态为 BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB 的 socket 放到 sockmap 中。sockmap 具体对应的 eBPF 的 map 类型可以是 BPF_MAP_TYPE_SOCKHASH。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Cilium 是一个使用 eBPF 的技术实现数据路径，在不同的网络设备中 redirect 数据包，缩短数据路径，达到加速的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特点是高级的特性对 Kernel 的要求比较高，而且不同的 Kernel 版本，会导致不同的数据路径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想达到最好的网络性能，推荐最低的 Kernel 的最低版本为 5.10。如果只是想让 Cilium 可以运行起来，那最低的 Kernel 的最低版本是 4.9.17。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6680440771349863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04lheX9aIvU5iabXFr4iaceFibucknN86D6C2z2GwPeEpicFc3Oa0xhgunOoibRqaVBAAWichDmPXTgAfJFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;hr data-style=&quot;border-style: solid; border-width: 0px 0px 0px; border-color: rgba(0, 0, 0, 0.1); transform-origin: 0px 0px; transform: scale(1, 0.5);&quot; class=&quot;js_darkmode__10&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 本文作者 &lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-15886644409858=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15886644409858=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 5px; margin-bottom: 5px; max-width: 100%; background-color: rgb(255, 255, 255); min-height: 1em; letter-spacing: 0.544px; white-space: normal; text-align: center; box-sizing: border-box !important; overflow-wrap: break-word !important; color: rgba(230, 230, 230, 0.9);&quot; class=&quot;js_darkmode__6&quot; data-darkmode-bgcolor-16372053747624=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16372053747624=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16372053747624=&quot;rgba(163, 163, 163, 0.9)&quot; data-darkmode-original-color-16372053747624=&quot;#fff|rgba(230, 230, 230, 0.9)&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;117&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;114&quot; data-ratio=&quot;0.98565965583174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04keMUUKWIVfK2vq0U4OWjZW0ibeLucpCYKfe8j9xibIy58icgEZ0zWiaJNWCuy2iaAlooxdlVO4JUZR7SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;熊中祥&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;「Dao&lt;/span&gt;&lt;span&gt;Cloud 道客&lt;/span&gt;&lt;span&gt;」技术合伙人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云原生技术专家&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;hr data-style=&quot;border-style: solid; border-width: 0px 0px 0px; border-color: rgba(0, 0, 0, 0.1); transform-origin: 0px 0px; transform: scale(1, 0.5);&quot; class=&quot;js_darkmode__10&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://cilium.io/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://docs.cilium.io/en/stable/bpf/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.man7.org/linux/man-pages/man7/bpf-helpers.7.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icGWTH9VkFq3qkSDQic93bFVw7hfdhjWInq4jtwTQk0tmSP823b4XOVbibm63dxzwAPyvXia151ZFQ2K5sDvcTl5Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;DaoCloud 公司简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;「DaoCloud 道客」云原生领域的创新领导者，成立于 2014 年底，拥有自主知识产权的核心技术，致力于打造开放的云操作系统为企业数字化转型赋能。产品能力覆盖云原生应用的开发、交付、运维全生命周期，并提供公有云、私有云和混合云等多种交付方式。成立迄今，公司已在金融科技、先进制造、智能汽车、零售网点、城市大脑等多个领域深耕，标杆客户包括交通银行、浦发银行、上汽集团、东风汽车、海尔集团、屈臣氏、金拱门（麦当劳）等。目前，公司已完成了 D 轮超亿元融资，被誉为科技领域准独角兽企业。公司在北京、武汉、深圳、成都设立多家分公司及合资公司，总员工人数超过 400 人，是上海市高新技术企业、上海市“科技小巨人”企业和上海市“专精特新”企业，并入选了科创板培育企业名单。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;网址：&lt;/span&gt;&lt;span&gt;www.daocloud.io&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;邮件：info@daocloud.io&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;电话：400 002 6898&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5900621118012422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1DjrTiaica04nnwnvanKwk0ym0zoD77xItIh02tUNoicUUbD7WibONpElX4j6sp8cx13q3jBZgVZXM8fiaic5scLwKjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>98156602effec14cab5bc7b963b6b55f</guid>
<title>谷歌工程最佳实践</title>
<link>https://toutiao.io/k/q19mmjh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近公司同事作了个Code Review的分享，于是乎我系统学习了下《谷歌工程实践》，里面主要讲的是Code Review。写下本文作为笔记。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;术语&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码审查者指南&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Code Review 标准&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Code Review 要点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看CL的步骤&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Code Review 速度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何撰写 Code Review 评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理 Code Review 中的拖延&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;代码开发者指南&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《谷歌工程实践》是 Google 团队长期以来的内部项目最佳实践。其目的是帮助开发者更好地进行代码审查工作，通过 Code Review 来提升并优化当前项目的代码质量，便于开发人员维护和维护旧项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管你是代码开发者还是代码的审查者都值得读一读。&lt;span&gt;本文主要是基于&lt;/span&gt;&lt;span&gt;《谷歌工程实践》&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;span&gt;，摘取了关键部分，并做了笔记和扩展。&lt;/span&gt;&lt;span&gt;建议看下英文原版&lt;/span&gt;&lt;span&gt;《Google Engineering Practices Documentation
》&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;术语&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CL（&lt;span&gt;Change List&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;表示变更列表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LGTM（&lt;span&gt;Looks Good to &lt;/span&gt;&lt;span&gt;Me&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;我觉得不错。表示认可这次PR，同意merge合并代码到远程仓库。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MR（&lt;span&gt;Merge Request&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;合并请求，GitLab中术语。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PR（Pull Request）&lt;/section&gt;&lt;section&gt;合并请求，GitHub中术语。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CR（Code Review）&lt;/section&gt;&lt;section&gt;代码审查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ACK（Acknowledgement）&lt;/section&gt;&lt;section&gt;我确认了或者我接受了,我承认了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WIP（Work in progress）&lt;/section&gt;&lt;section&gt;do not merge yet.   开发中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ASAP（As Soon As Possible）&lt;/section&gt;&lt;section&gt;尽快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TL;DR（Too Long; Didn’t Read）&lt;/section&gt;&lt;section&gt;「太长懒得看」README 文档常见。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PTAL（Please take a look ）&lt;/section&gt;&lt;section&gt;帮我看下，一般都是请别人 review 自己的 PR。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CC（Carbon copy ）&lt;/section&gt;&lt;section&gt;一般代表抄送别人的意思。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RFC（Request for comments）&lt;/section&gt;&lt;section&gt;我觉得这个想法很好, 我们来一起讨论下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NACK/NAK（Negative acknowledgement）&lt;/section&gt;&lt;section&gt;不同意。i.e. disagree with change and/or concept。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RFC（Request For Comments）&lt;/section&gt;&lt;section&gt;请求进行讨论 i.e. I think this is a good idea, lets discuss。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AFAIK/AFAICT（&lt;span&gt;As Far As I Know / Can Tell &lt;/span&gt;）&lt;/section&gt;&lt;section&gt;据我所知；就我所知。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TBR（&lt;span&gt;To Be Reviewed&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;提示维护者进行 review。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展参考&lt;span&gt;Git 团队协作常用术语&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;、&lt;span&gt;LGTM : code review 行话&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码审查者指南&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 标准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有 Code Review 指南中的高级原则：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般来说，审核人员应该倾向于批准CL，只要CL确实可以提高系统的整体代码健康状态，即使CL并不完美。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 要点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设计：主要是看CL整体设计是否合理，比如代码的分层是否合理等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;功能：主要看是否符合开发者的意图，并考虑到一些边缘情况，如并发问题等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复杂度：阅读代码的人无法快速理解。还要注意过度工程（over-engineering）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试：确保 CL 中的测试正确，合理且有用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命名：一个好名字应该足够长，可以完全传达项目的内容或作用，但又不会太长，以至于难以阅读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注释：是否所有注释都是必要的？通常，注释解释为什么某些代码存在时很有用，且不应该用来解释某些代码正在做什么。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;风格：参考&lt;span&gt;《Google Style Guides》&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; ，里面包含Google的多种语言的风格指南。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文档：如果 CL 变更了，请检查相关文档是否有更新。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一行：查看分配给您审查的每行代码。如果不了解某些部分的审查，请确保 CL 上有一个合格的审查人，特别是对于安全性、并发性、可访问性、国际化等复杂问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上下文：通常，代码审查工具只会显示变更的部分的周围的几行。有时您必须查看整个文件以确保变更确实有意义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;好的事情：&lt;/span&gt;&lt;span&gt;比起告诉他们做错了什么，有时更有价值的是告诉开发人员他们做&lt;/span&gt;&lt;span&gt;对了什么。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查看CL的步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一步：全面了解变更。&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二步：检查 CL 的主要部分。&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通常，包含大量的逻辑变更的文件就是 CL 的主要部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 CL 太大而无法确定哪些部分是主要部分，请向开发人员询问您应该首先查看的内容或者要求他们将 CL 拆分为多个 CL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在该部分发现存在一些主要的设计问题时，即使没有时间立即查看 CL 的其余部分，也应立即留下评论告知此问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三步：以适当的顺序查看CL的其余部分。&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通常在查看主要文件之后，最简单的方法是按照代码审查工具向您提供的顺序浏览每个文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有时在阅读主代码之前先阅读测试也很有帮助，因为这样您就可以了解该变更应当做些什么。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 速度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么尽快进行 Code Review？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不然就会发生：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;整个团队的速度降低了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发者开始抗议代码审查流程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码健康状况可能会受到影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Code Review 应该有多快？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您没有处于重点任务的中，那么您应该在收到代码审查后尽快开始。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;速度 vs. 中断&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果您正处于重点任务中，例如编写代码，请不要打断自己进行代码审查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在回复审查请求之前，请等待工作中断点。可能是当你的当前编码任务完成，午餐后，从会议返回等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快速响应&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速的个人响应比整个过程快速发生更为重要。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带评论的LGTM&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了加快代码审查，在某些情况下，即使他们也在 CL 上留下未解决的评论，审查者也应该给予 LGTM/Approva。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大型CL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有人向您发送了代码审查太大，您不确定何时有时间查看，那么您应该要求开发者将 CL 拆分为几个较小的 CL 而不是一次审查的一个巨大的 CL。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码审查随时间推移而改进&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要为了提高想象中的代码审查速度，而在代码审查标准或质量方面妥协，实际上这样做对于长期来说不会有任何帮助。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;紧急情况&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CL必须非常快速地通过整个审查流程，并且质量准则将放宽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧急 CL 是这样的小更新：允许主要发布继续而不是回滚，修复显著影响用户生产的错误，处理紧迫的法律问题，关闭主要安全漏洞等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何撰写 Code Review 评论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;保持友善。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释你的推理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在给出明确的指示与只指出问题并让开发人员自己决定间做好平衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;鼓励开发人员简化代码或添加代码注释，而不仅仅是向你解释复杂性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;礼貌&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，对于那些正在被您审查代码的人，除了保持有礼貌且尊重以外，重要的是还要确保您（的评论）是非常清楚且有帮助的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;糟糕的示例&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么这里你使用了线程，显然并发并没有带来什么好处？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;好的示例&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里的并发模型增加了系统的复杂性，但没有任何实际的性能优势，因为没有性能优势，最好是将这些代码作为单线程处理而不是使用多线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解释为什么&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于上面的“好”示例，您会注意到的一件事是，它可以帮助开发人员理解您发表评论的原因。并不总是需要您在审查评论中包含此信息，但有时候提供更多解释，对于表明您的意图，您在遵循的最佳实践，或为您建议如何提高代码健康状况是十分恰当的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;给予指导&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，修复 CL 是开发人员的责任，而不是审查者。您无需为开发人员详细设计解决方案或编写代码。但这并不意味着审查者应该没有帮助。一般来说，您应该在指出问题和提供直接指导之间取得适当的平衡。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接受解释&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您要求开发人员解释一段您不理解的代码，那通常会导致他们更清楚地重写代码。偶尔，在代码中添加注释也是一种恰当的响应，只要它不仅仅是解释过于复杂的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;处理 Code Review 中的拖延&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时开发人员会拖延（Pushback）代码审查。他们要么不同意您的建议，要么抱怨您太严格。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;谁是对的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当开发人员不同意您的建议时，请先花点时间考虑一下是否正确。通常，他们比你更接近代码，所以他们可能真的对它的某些方面有更好的洞察力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时需要几轮解释一个建议才能才能让对方真正理解你的用意。只要确保始终保持礼貌，让开发人员知道你有听到他们在说什么，只是你不同意该论点而已。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;沮丧的开发者&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审查者有时认为，如果审查者人坚持改进，开发人员会感到不安。有时候开发人员会感到很沮丧，但这样的感觉通常只会持续很短的时间，后来他们会非常感谢您在提高代码质量方面给他们的帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，如果您在评论中表现得很有礼貌，开发人员实际上根本不会感到沮丧，这些担忧都仅存在于审核者心中而已。开发者感到沮丧通常更多地与评论的写作方式有关，而不是审查者对代码质量的坚持。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;稍后清理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经验表明，在开发人员编写原始 CL 后，经过越长的时间这种清理发生的可能性就越小。实际上，通常除非开发人员在当前 CL 之后立即进行清理，否则它就永远不会发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在代码进入代码库并“完成”之前，通常最好坚持让开发人员现在清理他们的 CL。让人们“稍后清理东西”是代码库质量退化的常见原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 CL 引入了新的复杂性，除非是紧急情况，否则必须在提交之前将其清除。如果 CL 暴露了相关的问题并且现在无法解决，那么开发人员应该将 bug 记录下来并分配给自己，避免后续被遗忘。又或者他们可以选择在程序中留下 TODO 的注释并连结到刚记录下的 bug。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于严格性的抱怨&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您以前有相当宽松的代码审查，并转而进行严格的审查，一些开发人员会抱怨得非常大声。通常提高代码审查的速度会让这些抱怨逐渐消失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，这些投诉可能需要数月才会消失，但最终开发人员往往会看到严格的代码审查的价值，因为他们会看到代码审查帮助生成的优秀代码。而且一旦发生某些事情时，最响亮的抗议者甚至可能会成为你最坚定的支持者，因为他们会看到审核变严格后所带来的价值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决冲突&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上述所有操作仍无法解决您与开发人员之间的冲突，请参阅 “Code Review 标准”以获取有助于解决冲突的指导和原则。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码开发者指南&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写好 CL 描述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CL 描述是进行了哪些更改以及为何更改的公开记录。CL 将作为版本控制系统中的永久记录，可能会在长时期内被除审查者之外的数百人阅读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;首行&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;正在做什么的简短摘要。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完整的句子，使用祈使句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后面跟一个空行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Body 是信息丰富的&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其余描述应该是提供信息的。可能包括对正在解决的问题的简要描述，以及为什么这是最好的方法。如果方法有任何缺点，应该提到它们。如果相关，请包括背景信息，例如错误编号，基准测试结果以及设计文档的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使是小型 CL 也需要注意细节。在 CL 描述中提供上下文以供参照。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;糟糕的 CL 描述&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“Fix bug ”是一个不充分的 CL 描述。什么 bug？你做了什么修复？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他类似的不良描述包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;“Fix build.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Add patch.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Moving code from A to B.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Phase 1.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Add convenience functions.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“kill weird URLs.”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中一些是真正的 CL 描述。他们的作者可能认为自己提供了有用的信息，却没有达到 CL 描述的目的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;好的 CL 描述&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一些很好的描述示例。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;功能变化例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;rpc：删除 RPC 服务器消息空闲列表的大小限制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;像 FizzBuzz 这样的服务器有非常大的消息，并且可以从重用中受益。使 freelist 更大，并添加一个 goroutine，随着时间的推移缓慢释放 freelist 条目，以便空闲服务器最终释放所有 freelist 条目。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几个词描述了 CL 的实际作用。描述的其余部分讨论了正在解决的问题，为什么这是一个好的解决方案，以及有关具体实现的更多信息。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重构例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 TimeKeeper 构造一个 Task 以使用其 TimeStr 和 Now 方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;给Task添加一个Now方法，这样borglet()的getter方法就可以被移除了（它只被OOMCandidate用来调用borglet的Now方法）。这替换了 Borglet 上委托给 TimeKeeper 的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;允许 Tasks 提供 Now 是消除对 Borglet 依赖的一步。最终，依赖于从 Task 获取 Now 的协作者应
该改为直接使用 TimeKeeper，但这是对小步骤重构的一种适应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;继续重构 Borglet Hierarchy 的长期目标。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一行描述了 CL 的作用以及与过去相比的变化。描述的其余部分讨论了具体的实现、CL 的上下文、解决方案并不理想以及可能的未来方向。它还解释了为什么要进行这种更改。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;需要一些上下文的小型 CL例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为 status.py 创建一个 Python3 构建规则。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这允许已经在 Python3 中使用它的消费者依赖于原始状态构建规则旁边的规则，而不是他们自己树中的某个位置。它鼓励新消费者尽可能使用 Python3，而不是 Python2，并显着简化当前正在开发的一些自动构建文件重构工具。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一句话描述了实际正在做的事情。描述的其余部分解释了为什么要进行更改，并为审阅者提供了很多背景信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小型 CL&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么提交小型 CL?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小且简单的 CL 是指：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查更快&lt;/strong&gt;。审查者更容易抽多次五分钟时间来审查小型 CL，而不是留出 30 分钟来审查一个大型 CL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查得更彻底&lt;/strong&gt;。如果是大的变更，审查者和提交者往往会因为大量细节的讨论翻来覆去而感到沮丧——有时甚至到了重要点被遗漏或丢失的程度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不太可能引入错误&lt;/strong&gt;。由于您进行的变更较少，您和您的审查者可以更轻松有效地推断 CL 的影响，并查看是否已引入错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果被拒绝，减少浪费的工作&lt;/strong&gt;。如果您写了一个巨大的 CL，您的评论者说整个 CL 的方向都错误了，你就浪费了很多精力和时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更容易合并&lt;/strong&gt;。处理大型 CL 需要很长时间，在合并时会出现很多冲突，并且必须经常合并。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更容易设计好&lt;/strong&gt;。打磨一个小变更的设计和代码健康状况比完善一个大变更的所有细节要容易得多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;减少对审查的阻碍&lt;/strong&gt;。发送整体变更的自包含部分可让您在等待当前 CL 审核时继续编码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更简单的回滚&lt;/strong&gt;。大型 CL 更有可能触及在初始 CL 提交和回滚 CL 之间更新的文件，从而使回滚变得复杂（中间的 CL 也可能需要回滚）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是小型 CL？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，CL 的正确大小是自包含的变更。这意味着：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CL 进行了一项最小的变更，只解决了一件事。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;审查者需要了解的关于 CL 的所有内容（除了未来的开发）都在 CL 的描述、现有的代码库或已经审查过的 CL 中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对其用户和开发者来说，在签入 CL 后系统能继续良好的工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CL 不会过小以致于其含义难以理解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于多大算“太大”没有严格的规则。对于 CL 来说，100 行通常是合理的大小，1000 行通常太大，但这取决于您的审查者的判断。变更中包含的文件数也会影响其“大小”。一个文件中的 200 行变更可能没问题，但是分布在 50 个文件中通常会太大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么时候大 CL 是可以的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些情况下，大变更也是可以接受的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;您通常可以将整个文件的删除视为一行变更，因为审核人员不需要很长时间审核。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有时一个大的 CL 是由您完全信任的自动重构工具生成的，而审查者的工作只是检查并确定想要这样的变更。但这些 CL 可以更大，尽管上面的一些警告（例如合并和测试）仍然适用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分离出重构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常最好在功能变更或错误修复的单独 CL 中进行重构。例如，移动和重命名类应该与修复该类中的错误的 CL 不同。审查者更容易理解每个 CL 在单独时引入的更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，修复本地变量名称等小清理可以包含在功能变更或错误修复 CL 中。如果重构大到包含在您当前的 CL 中，会使审查更加困难的话，需要开发者和审查者一起判断是否将其拆开。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将相关的测试代码保存在同一个 CL 中&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免将测试代码拆分为单独的 CL。验证代码修改的测试应该进入相同的 CL，即使它增加了代码行数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，独立的测试修改可以首先进入单独的 CL，类似于重构指南。包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用新测试验证预先存在的已提交代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构测试代码（例如引入辅助函数）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入更大的测试框架代码（例如集成测试）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不要破坏构建&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您有几个相互依赖的 CL，您需要找到一种方法来确保在每次提交 CL 后整个系统能够继续运作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如果不能让它足够小&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时你会遇到看起来您的 CL 必须如此庞大，但这通常很少是正确的。习惯于编写小型 CL 的提交者几乎总能找到将功能分解为一系列小变更的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编写大型 CL 之前，请考虑在重构 CL 之前是否可以为更清晰的实现铺平道路。与你的同伴聊聊，看看是否有人想过如何在小型 CL 中实现这些功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果以上的努力都失败了（这应该是非常罕见的），那么请在事先征得审查者的同意后提交大型 CL，以便他们收到有关即将发生的事情的警告。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何处理审查者的评论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当您发送 CL 进行审查时，您的审查者可能会对您的 CL 发表一些评论。以下是处理审查者评论的一些有用信息。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不是针对您&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审查的目标是保持代码库和产品的质量。当审查者对您的代码提出批评时，请将其视为在帮助您、代码库，而不是对您或您的能力的个人攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;永远不要愤怒地回应代码审查评论。这严重违反了专业礼仪且将永远存在于代码审查工具中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修复代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果审查者说他们不了解您的代码中的某些内容，那么您的第一反应应该是澄清代码本身。如果无法澄清代码，请添加代码注释，以解释代码存在的原因。只有在想增加的注释看起来毫无意义时，您才能在代码审查工具中进行回复与解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果审查者不理解您的某些代码，那么代码的未来读者可能也不会理解。在代码审查工具中回复对未来的代码读者没有帮助，但澄清代码或添加代码注释确可以实实在在得帮助他们。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自我反思&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写 CL 可能需要做很多工作。在终于发送一个 CL 用于审查后，我们通常会感到满足的，认为它已经完成，并且非常确定不需要进一步的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这通常是令人满意的。因此，当审查者回复对可以改进的事情的评论时，很容易本能地认为评论是错误的，审查者正在不必要地阻止您，或者他们应该让您提交 CL。但是，无论您目前多么确定，请花一点时间退一步，考虑审查者是否提供有助于对代码库和公司有价值的反馈。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决冲突&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决冲突的第一步应该是尝试与审查者达成共识。如果您无法达成共识，请参阅“代码审查标准”，该标准提供了在这种情况下遵循的原则。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码审查者视角&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以制定审核标准为前提，尽可能快速、及时的反馈代码开发者的合并请求。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于评论要保持友善、提供引导，以最终代码质量、公司价值为导向。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;做好沟通，有疑问及时沟通、接受解释。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码开发者视角&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写好CL的描述。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提供小的CL、相关测试代码不分离、重构代码分离、不破坏构建。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以代码质量、公司价值为结果导向，及时修复、做好沟通。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;《谷歌工程实践》: &lt;em&gt;https://jimmysong.io/eng-practices/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;《Google Engineering Practices Documentation
》: &lt;em&gt;https://github.com/google/eng-practices&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Git 团队协作常用术语: &lt;em&gt;https://blog.csdn.net/qq_15988951/article/details/108331701&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;LGTM : code review 行话: &lt;em&gt;&quot;https://blog.csdn.net/weixin_41287260/article/details/108676433&quot;&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;《Google Style Guides》: &lt;em&gt;https://google.github.io/styleguide/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>