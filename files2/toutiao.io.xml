<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8311f3f2ed9157b03eb2977465510bc</guid>
<title>MyBatis 的本质和原理</title>
<link>https://toutiao.io/k/613ifih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    项目需要，我们需要自己做一套mybatis，或者使用大部分mybatis的原始内容。对其改造，以适应需要。这就要求我再次学习一下mybatis，对它有更深入的了解。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;是什么&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    MyBatis是一个持久层框架，用来处理对象关系映射。说白了就是以相对面向对象的方式来提交sql语句给jdbc。如果想找个简单、快速上手的例子，最好是和spring想结合的。直接用官网的吧，简单清晰也没谁了：http://mybatis.org/spring/getting-started.html&lt;/p&gt;&lt;p&gt;https://mybatis.org/mybatis-3/getting-started.html&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    Java开发都是面向对象的思维，如果用传统下面自己去调用连接拼装sql的方式，维护成本高，代码可读性差。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;span&gt;main&lt;/span&gt;(String[] args) {&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库连&lt;/span&gt;&lt;span&gt;接&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Connection conn = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;操作&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;PreparedStatement stmt = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//1&lt;/span&gt;&lt;span&gt;、加&lt;/span&gt;&lt;span&gt;载驱动&lt;/span&gt;&lt;span&gt;程序&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        Class.&lt;span&gt;forName&lt;/span&gt;(&lt;span&gt;DBDRIVER&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(ClassNotFoundException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//2&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过连&lt;/span&gt;&lt;span&gt;接管理器&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接的&lt;/span&gt;&lt;span&gt;时&lt;/span&gt;&lt;span&gt;候直接&lt;/span&gt;&lt;span&gt;输&lt;/span&gt;&lt;span&gt;入用&lt;/span&gt;&lt;span&gt;户&lt;/span&gt;&lt;span&gt;名和密&lt;/span&gt;&lt;span&gt;码&lt;/span&gt;&lt;span&gt;才可以&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;conn = DriverManager.&lt;span&gt;getConnection&lt;/span&gt;(&lt;span&gt;DBURL&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;USERNAME&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;PASSWORD&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//3&lt;/span&gt;&lt;span&gt;、向数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;中插入一条数据&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;String sql = &lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (?,?)&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    try &lt;/span&gt;{&lt;br/&gt;        stmt = conn.prepareStatement(sql)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.setString(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;陈&lt;/span&gt;&lt;span&gt;昆&lt;/span&gt;&lt;span&gt;仑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.setInt(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.executeQuery()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//4&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;执&lt;/span&gt;&lt;span&gt;行&lt;/span&gt;&lt;span&gt;语&lt;/span&gt;&lt;span&gt;句&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        ResultSet resultSet = stmt.executeQuery()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;//5&lt;/span&gt;&lt;span&gt;、关&lt;/span&gt;&lt;span&gt;闭&lt;/span&gt;&lt;span&gt;操作，步&lt;/span&gt;&lt;span&gt;骤&lt;/span&gt;&lt;span&gt;相反哈&lt;/span&gt;&lt;span&gt;~&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;        stmt.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;conn.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;        e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;怎么做&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    我们来看一下底层是怎么处理和交互的。基本流程如下：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8kINd9hW6JctZMvRNg5GibNvYQySUAKMgmDiaib46wVLhFZuYU1ZA4cGxIRvD4KIIyiaIVNJoCAdUNFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1336971350613916&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;p&gt;    看着头大？没事，我们先从最简化的版本开始添枝加叶。MyBatis可以用配置文件或者注解形式注入sql。因为配置文件方式可以方便的处理动态SQL(动态SQL就是sql语句里有if else for这些的，可以根据参数的变化最终sql也跟着变化)等优点，用的更为普遍。&lt;/p&gt;&lt;p&gt;    假设现在是2000年，Clinton Begin还没有发起ibatis(mybatis的前身)项目。而apache基金会内部发起了讨论要设计这样一个产品，指派你作为项目负责人。现在思考，你的思路是什么？&lt;/p&gt;&lt;p&gt;    一般思路是先把架构搭建起来，做成一个MVP最小可行性版本，然后再做功能增强。&lt;/p&gt;&lt;p&gt;    从功能最简化方面来看，需要两步：第一步要将sql及所需要的元素以对象的形式输入，第二步是获取到这些信息转换成jdbc信息处理。&lt;/p&gt;&lt;p&gt;    这样拆解后的思路是将sql及所需要的元素拆解成类方法的参数形式，方法本身要做的事情就是将这些参数以jdbc编程需要的形式传给jdbc执行。这里方法内部做的事情是一样的，那就自然而然的想到不用每个类都有一个实现。只要定义好接口，把实现用代理或者上层切面的方式统一处理就可以了。&lt;/p&gt;&lt;p&gt;    根据这个思路，首先要用代理来获取参数。我设计使用方式是Insert、Select等注解里写sql元语句。通过方法参数注入参数。最终返回结果。如下&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public interface &lt;/span&gt;UserMapper {&lt;br/&gt;&lt;/pre&gt;&lt;pre&gt;    &lt;span&gt;@Insert&lt;/span&gt;(&lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (#{name},#{age})&quot;&lt;/span&gt;)&lt;br/&gt;    Integer &lt;span&gt;insertUser&lt;/span&gt;(User user)&lt;span&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;    要实现接口的解析。先建立一个类，里面构造一个代理类，实现类似于SqlSession，所以起名叫YunaSession（yuna是我给经典java学习场景工程https://github.com/xiexiaojing/yuna 起的名字）&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public class &lt;/span&gt;YunaSession {&lt;br/&gt;   &lt;span&gt;public static &lt;/span&gt;Object &lt;span&gt;dealSql&lt;/span&gt;(Class clazz) {&lt;br/&gt;       Class c[] = &lt;span&gt;new &lt;/span&gt;Class[]{clazz}&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;       return &lt;/span&gt;Proxy.&lt;span&gt;newProxyInstance&lt;/span&gt;(YunaSession.&lt;span&gt;class&lt;/span&gt;.getClassLoader()&lt;span&gt;, &lt;/span&gt;c&lt;span&gt;,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;new &lt;/span&gt;YunaInvocationHandler())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;span&gt;   &lt;/span&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;    下面要实现的是代理中YunaInvocationHandler真正要实现的逻辑：将这些参数以jdbc编程需要的形式传给jdbc执行。也就是说把上面【为什么】部分一开始的那段执行jdbc的代码贴进去，将sql和参数的部分做替换。&lt;/p&gt;&lt;p&gt;     我们把关键再贴一遍便于说明问题&lt;/p&gt;&lt;pre&gt;&lt;span&gt;//3&lt;/span&gt;&lt;span&gt;、向数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;中插入一条数据&lt;br/&gt;&lt;/span&gt;String sql = &lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (?,?)&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;    stmt = conn.prepareStatement(sql)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;stmt.setString(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;陈&lt;/span&gt;&lt;span&gt;昆&lt;/span&gt;&lt;span&gt;仑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;stmt.setInt(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;stmt.executeQuery()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;    e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;    这里有两个?，而jdbc的预处理语句传入参数的时候要明确的知道第一个参数的类型是什么，如果传过来是对象的话，要知道对应对象的哪个值。这就是为什么接口里的预处理语句传入是&lt;/p&gt;&lt;pre&gt;&lt;span&gt;INSERT INTO person(name,age) VALUES (#{name},#{age})&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;    因为可以通过匹配#{XX}这样的确定都是哪些参数，因为User对象里有定义参数的类型。所以类型和值都确定了。这个就是MappedStatement对象做的事情。以下是用正则表达式匹配+反射来达到解析sql并和对象值做匹配的实现：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;span&gt;main&lt;/span&gt;(String[] args) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    Matcher m= &lt;span&gt;pattern&lt;/span&gt;.matcher(&lt;span&gt;&quot;INSERT INTO person(name,age) VALUES (#{name},#{age})&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;User user1 = &lt;span&gt;new &lt;/span&gt;User()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;user1.setId(&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;user1.setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;贾&lt;/span&gt;&lt;span&gt;元春&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;user1.setAge(&lt;span&gt;27&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    int &lt;/span&gt;i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    while&lt;/span&gt;(m.find()) {&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(m.group())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String group = m.group()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String fieldName = group.replace(&lt;span&gt;&quot;#{&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;}&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Field field = User.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(fieldName)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;field.setAccessible(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.Integer&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;stmt.setInt(&quot;&lt;/span&gt;+i+&lt;span&gt;&quot;,&quot;&lt;/span&gt;+field.get(user1)+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;} &lt;span&gt;else if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot; stmt.setString(&quot;&lt;/span&gt;+i+&lt;span&gt;&quot;,&quot;&lt;/span&gt;+field.get(user1)+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;        i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;运行结果是&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7423469387755102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicPPxcYCb63l1j0KiaRkeQmuXvCSdnab1V0YLVt2ibCDGIrW6Up2b6QAKJMR0jApnicUVYaOb8l4o6xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以看到实现了效果。下面就是和jdbc连接结合起来。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;public class &lt;/span&gt;YunaInvocationHandler &lt;span&gt;implements &lt;/span&gt;InvocationHandler {&lt;br/&gt;    &lt;span&gt;public static final &lt;/span&gt;String &lt;span&gt;DBDRIVER &lt;/span&gt;= &lt;span&gt;&quot;org.xx.mm.mysql.Driver&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public static final &lt;/span&gt;String &lt;span&gt;DBURL &lt;/span&gt;= &lt;span&gt;&quot;jdbc:mysql://localhost:3306/mydb&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现&lt;/span&gt;&lt;span&gt;在使用的是&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库&lt;/span&gt;&lt;span&gt;，是直接&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接的，所以此&lt;/span&gt;&lt;span&gt;处&lt;/span&gt;&lt;span&gt;必&lt;/span&gt;&lt;span&gt;须&lt;/span&gt;&lt;span&gt;有用&lt;/span&gt;&lt;span&gt;户&lt;/span&gt;&lt;span&gt;名和密&lt;/span&gt;&lt;span&gt;码&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public static final &lt;/span&gt;String &lt;span&gt;USERNAME &lt;/span&gt;= &lt;span&gt;&quot;root&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public static final &lt;/span&gt;String &lt;span&gt;PASSWORD &lt;/span&gt;= &lt;span&gt;&quot;mysqladmin&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Override&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public &lt;/span&gt;Object &lt;span&gt;invoke&lt;/span&gt;(Object proxy&lt;span&gt;, &lt;/span&gt;Method method&lt;span&gt;, &lt;/span&gt;Object[] args) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;        Object result = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Insert &lt;/span&gt;insert = method.getAnnotation(&lt;span&gt;Insert&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        if &lt;/span&gt;(insert != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            String sql = insert.value()[&lt;span&gt;0&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;&lt;span&gt;语&lt;/span&gt;&lt;span&gt;句&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+s)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;YunaSqlDeal yunaSqlDeal = &lt;span&gt;new &lt;/span&gt;YunaSqlDeal()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;yunaSqlDeal.&lt;span&gt;insert&lt;/span&gt;(s&lt;span&gt;, &lt;/span&gt;Arrays.&lt;span&gt;toString&lt;/span&gt;(args))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;//1&lt;/span&gt;&lt;span&gt;、加&lt;/span&gt;&lt;span&gt;载驱动&lt;/span&gt;&lt;span&gt;程序&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;try &lt;/span&gt;{&lt;br/&gt;                Class.&lt;span&gt;forName&lt;/span&gt;(&lt;span&gt;DBDRIVER&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(ClassNotFoundException e) {&lt;br/&gt;                e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;            &lt;span&gt;//2&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通&lt;/span&gt;&lt;span&gt;过连&lt;/span&gt;&lt;span&gt;接管理器&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数据&lt;/span&gt;&lt;span&gt;库&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;库连&lt;/span&gt;&lt;span&gt;接&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;Connection conn = &lt;span&gt;null;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            try &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接的&lt;/span&gt;&lt;span&gt;时&lt;/span&gt;&lt;span&gt;候直接&lt;/span&gt;&lt;span&gt;输&lt;/span&gt;&lt;span&gt;入用&lt;/span&gt;&lt;span&gt;户&lt;/span&gt;&lt;span&gt;名和密&lt;/span&gt;&lt;span&gt;码&lt;/span&gt;&lt;span&gt;才可以&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;conn = DriverManager.&lt;span&gt;getConnection&lt;/span&gt;(&lt;span&gt;DBURL&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;USERNAME&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;PASSWORD&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;} &lt;span&gt;catch &lt;/span&gt;(SQLException e) {&lt;br/&gt;                e.printStackTrace()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;            &lt;span&gt;composeStatement&lt;/span&gt;(sql&lt;span&gt;, &lt;/span&gt;args[&lt;span&gt;0&lt;/span&gt;]&lt;span&gt;, &lt;/span&gt;conn)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;private static final &lt;/span&gt;String &lt;span&gt;PATTERN &lt;/span&gt;= &lt;span&gt;&quot;#&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;{[A-Za-z0-9]+&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;}&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private static &lt;/span&gt;Pattern &lt;span&gt;pattern &lt;/span&gt;= Pattern.&lt;span&gt;compile&lt;/span&gt;(&lt;span&gt;&quot;(&quot;&lt;/span&gt;+&lt;span&gt;PATTERN&lt;/span&gt;+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public static void &lt;/span&gt;&lt;span&gt;composeStatement&lt;/span&gt;(String sql&lt;span&gt;, &lt;/span&gt;Object obj&lt;span&gt;, &lt;/span&gt;Connection conn) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;        PreparedStatement stmt = conn.prepareStatement(sql.replaceAll(&lt;span&gt;PATTERN&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Matcher m= &lt;span&gt;pattern&lt;/span&gt;.matcher(sql)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        int &lt;/span&gt;i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        while&lt;/span&gt;(m.find()) {&lt;br/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(m.group())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;String group = m.group()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;String fieldName = group.replace(&lt;span&gt;&quot;#{&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;}&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;Field field = User.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(fieldName)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;field.setAccessible(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.Integer&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;                System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;stmt.setInt(&quot;&lt;/span&gt;+i+&lt;span&gt;&quot;,&quot;&lt;/span&gt;+field.get(obj)+&lt;span&gt;&quot;)&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;stmt.setInt(i&lt;span&gt;, &lt;/span&gt;Integer.&lt;span&gt;parseInt&lt;/span&gt;(field.get(obj).toString()))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;} &lt;span&gt;else if&lt;/span&gt;(&lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;.equals(field.getType().getName())) {&lt;br/&gt;                stmt.setString(i&lt;span&gt;, &lt;/span&gt;field.get(obj).toString())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;}&lt;br/&gt;            i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;        stmt.execute()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;stmt.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;conn.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;    这个实现的是insert的，返回值类型固定，如果是select查询语句，涉及到返回的结果封装成对象。思路也是通过反射，和参数转换步骤差不多，就不贴代码了。&lt;/p&gt;&lt;p&gt;    到此，我们实现了一个简化版的mybatis框架。比贴的架构图简化在少用了很多设计模式的东西，和出于性能考虑重用的东西。mybatis的核心就实现完了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总结&lt;/p&gt;&lt;p&gt;    本文从mybatis的设计者角度出发，构造了一个简化的mybatis框架。具体可运行的完整代码放到了我的github上，地址：&lt;/p&gt;&lt;p&gt;https://github.com/xiexiaojing/yuna。&lt;/p&gt;&lt;p&gt;    很多原理性的东西看过之后会忘，但是如果真正站在设计者角度实现过一个简化的版本，相信会增强记忆。同时也能和真正的实现做对比，更深层学习技术大牛们的设计精华。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>82857b8beacde9c1566c4da9f55eb124</guid>
<title>高并发高性能服务器是如何实现的</title>
<link>https://toutiao.io/k/e3xq8ad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;Ctrump才是世界上最好的语言&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>17094f3fb7e8f7bdf25bccf351722970</guid>
<title>谈一谈 TCP 连接</title>
<link>https://toutiao.io/k/ncz653e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;
      &lt;h1 id=&quot;套接字编程&quot;&gt;套接字编程&lt;/h1&gt;
&lt;h1 id=&quot;什么是套接字&quot;&gt;什么是套接字&lt;/h1&gt;
&lt;p&gt;在因特网中，我们用&lt;code&gt;IP地址&lt;/code&gt;区分不同的主机。而一个主机上往往运行着多个进程，比如qq和微信。我们使用qq发出去的消息，必然是希望对方用qq接收到。那么如何区分一个主机上的不同进程呢？答案是&lt;code&gt;端口号(Port)&lt;/code&gt;。&lt;code&gt;端口号&lt;/code&gt;是一个16比特的数，其大小在&lt;code&gt;0~65535&lt;/code&gt;之间。其中&lt;code&gt;0~1023&lt;/code&gt;范围的端口号是受限制的，被特定的应用层协议使用，比如&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;ftp&lt;/code&gt;。客户端可以选择剩余的端口号来使用。&lt;/p&gt;
&lt;p&gt;当一个新的应用程序（有网络通信的）开发完之后，必须为其分配一个端口号。这样，&lt;code&gt;IP:Port&lt;/code&gt;就可以唯一标识一个主机上的应用程序，并用这个标识进行通信。&lt;u&gt;我们称&lt;code&gt;IP:Port&lt;/code&gt;为套接字。&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&quot;python实例&quot;&gt;python实例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6tns1y8j30da0dnwex.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端-服务端请求应答模型如上图所示。&lt;/p&gt;
&lt;h3 id=&quot;服务端&quot;&gt;服务端&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;11
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;12
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;13
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;14
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;15
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;16
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8090&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;The server is ready to recieve!&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Get your: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 将客户端消息转为大写&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connectionSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;ne&quot;&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;serverSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;首先使用&lt;code&gt;socket&lt;/code&gt;创建一个TCP嵌套字，其中&lt;code&gt;SOCK_STREAM&lt;/code&gt;用于指示这是一个TCP连接而非UDP连接；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind&lt;/code&gt;绑定主机名和端口号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;令服务器监听&lt;code&gt;8090&lt;/code&gt;端口来自客户端的TCP连接请求。其中的参数&lt;code&gt;1&lt;/code&gt;表示请求的最大连接数为1；&lt;/li&gt;
&lt;li&gt;最后在&lt;code&gt;while&lt;/code&gt;循环中，使用&lt;code&gt;accept()&lt;/code&gt;方法。接收到来自客户端的请求之后会重新分配一个名为&lt;code&gt;connectionSocket&lt;/code&gt;的新的套接字，给这个特定的用户使用。这样可以让一个套接字专门用来接收请求，生成的连接套接字用于不同客户端的通信，防止欢迎套接字被一个请求占用之后，其他请求无法再响应了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6uepevyj30ki0ke1hc.jpg&quot; alt=&quot;image-20201109160840609&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中的&lt;code&gt;try&lt;/code&gt;和&lt;code&gt;except&lt;/code&gt;可以先不用管，这个是为了中断程序时可以自动释放端口号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;客户端&quot;&gt;客户端&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt; 1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 2
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 3
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 4
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 5
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 6
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 7
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 8
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt; 9
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;10
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;serverName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;127.0.0.1&#x27;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8090&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello world!&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 发送&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 接受响应&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;Data from server ==&amp;gt;&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;首先使用&lt;code&gt;socket&lt;/code&gt;创建一个TCP嵌套字，与服务端一样；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connect&lt;/code&gt;与服务端建立连接，发生了三次握手的过程；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;运行程序&quot;&gt;运行程序&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# server&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;The&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recieve&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;
&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot;&gt;1
&lt;/span&gt;&lt;span class=&quot;lnt&quot;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;lntd&quot;&gt;
&lt;pre class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# client&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Get&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;your&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HELLO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WORLD&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&quot;wireshark抓包&quot;&gt;wireshark抓包&lt;/h2&gt;
&lt;p&gt;尝试用&lt;code&gt;wireshark&lt;/code&gt;抓包看一下我们程序运行的过程。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6zoh8wdj32800la10t.jpg&quot; alt=&quot;截屏2020-11-09 下午4.23.42&quot;/&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端默认工作在&lt;code&gt;51171&lt;/code&gt;端口，服务端监听&lt;code&gt;8090&lt;/code&gt;端口。&lt;code&gt;1～3&lt;/code&gt;是三次握手的过程，&lt;code&gt;8/10/11/12&lt;/code&gt;是四次挥手的过程。中间是数据传输与应答过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第5个包中，客户端发送了&lt;code&gt;hello world!&lt;/code&gt;；第6个包是服务端发送&lt;code&gt;ACK&lt;/code&gt;；第7个包是服务端发送&lt;code&gt;Data from server ==&amp;gt; Get your: HELLO WORLD!&lt;/code&gt;；第9个包是客户端发送的&lt;code&gt;ACK&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从抓包过程中我们可以看出，仅仅是简单地传输两个字符串，就需要这个多次&lt;code&gt;TCP&lt;/code&gt;包的传输。这些传输到底是什么含义呢？&lt;/p&gt;
&lt;h1 id=&quot;连接与可靠&quot;&gt;连接与可靠&lt;/h1&gt;
&lt;p&gt;众所周知，&lt;code&gt;TCP&lt;/code&gt;是面向连接的可靠的传输协议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向连接指的是在传输实体数据之前必须建立连接：上面的&lt;code&gt;connect&lt;/code&gt;就是建立连接的过程；&lt;/li&gt;
&lt;li&gt;可靠即能保证接收到的数据是发送方想发送的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么会发生不可靠的传输呢？主要有两种情况，一种是比特差错；另一种是丢包。&lt;/p&gt;
&lt;h2 id=&quot;比特差错&quot;&gt;比特差错&lt;/h2&gt;
&lt;p&gt;根据香农理论，当通过信道的信号速率超过某个值时，信号的误码率会显著提高，也就是比特差错数会显著提高。同时由于噪声的影响也会使得接收到判断发送端发送的是1还是0的时候发生错误。&lt;/p&gt;
&lt;h2 id=&quot;丢包&quot;&gt;丢包&lt;/h2&gt;
&lt;p&gt;从北京往上海发一个包，中间会经过路由器和交换机中转。大多数分组交换剂在输入端使用&lt;strong&gt;存储转发传输&lt;/strong&gt;：&lt;u&gt;也就是将整个包都接受完了之后，才会向输出链路传输该分组。&lt;/u&gt;分组交换机的每条链路具有一个输出缓存，用于存储准备发往该链路的分组。由于发送速率是有限的，所以如果包到达的速率要大于发送的速率的话，就必须在这个缓存区等待。而缓存区大小往往是有限的，所以超过的部分可能会被丢弃，从而发送&lt;strong&gt;丢包&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;还有一种是当发包的速度过快了，服务器应用程序没来得及消费这些东西，而缓存区也满了，那么就会丢弃这些包。&lt;/p&gt;
&lt;h1 id=&quot;如何保证可靠&quot;&gt;如何保证可靠&lt;/h1&gt;
&lt;h2 id=&quot;比特差错-1&quot;&gt;比特差错&lt;/h2&gt;
&lt;p&gt;首先看一下TCP报文格式：&lt;br/&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk70q2r44j30on0ew74h.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;检验和&lt;/code&gt;用于检验比特差错。目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送方&lt;/strong&gt;计算TCP的检验和的计算方法如下：&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;
&lt;p&gt;将检验和字段设为0；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加12字节的伪头部，包括：源IP地址、目的IP地址、协议版本号（一般为6）和16位的TCP总长度（这个长度是计算获得的，不是直接有的字段）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对所有16比特字求和，求和时遇到的任何溢出都将被&lt;u&gt;回卷&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对和进行反码运算。计算的结果填到检验和字段中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;回卷就是超过16bit的部分重新加到后16bit上。比如0x36666，回卷之后就是0x3 + 0x6666 = 0x6669。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;接收方&lt;/strong&gt;检验&lt;code&gt;checksum&lt;/code&gt;的方式如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加12字节的伪头部，包括：源IP地址、目的IP地址、协议版本号和16位的TCP总长度。&lt;/li&gt;
&lt;li&gt;对所有16比特字求和，求和时遇到的任何溢出都将被&lt;u&gt;回卷&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;判断结果是否为&lt;code&gt;0xFFFF&lt;/code&gt;，如果不是则出错。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用&lt;code&gt;wireshark&lt;/code&gt;抓包时可以发现，抓包之后的&lt;code&gt;checksum&lt;/code&gt;都是错误的：&lt;code&gt;[Header checksum status: Unverified]&lt;/code&gt;。手动进行求和验证发现也是无法通过的。这是为什么呢？&lt;/p&gt;
&lt;p&gt;原来是因为为了减少CPU的开销，检验和的计算会交给硬件（网卡）而不是&lt;code&gt;TCP&lt;/code&gt;来计算。而抓包时还没有到网卡这一层，所以系统会在&lt;code&gt;checksum&lt;/code&gt;这里随机填一些数字，而不是真正的检验和。在windows电脑中可以关闭网卡检验和再尝试。（mac中我还没有找到设置的方法，求指导！）&lt;/p&gt;
&lt;p&gt;&lt;u&gt;但是需要注意的是！检验和并不是只有TCP才有的，UDP和IP计算都会有这个步骤。&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&quot;丢包-1&quot;&gt;丢包&lt;/h2&gt;
&lt;p&gt;客户端发了几个包过去，客户端和服务端如何能保证是不丢失的？保证不丢包的前提是，&lt;u&gt;如果发生了丢包，他们必须是能够知道的&lt;/u&gt;，否则就没法进行重传。&lt;/p&gt;
&lt;p&gt;很容易想到的一种方法是&lt;strong&gt;应答&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;发送一个包之后，等待&lt;code&gt;Server&lt;/code&gt;响应。例如&lt;code&gt;ACK=1&lt;/code&gt;表示我收到了完整的包；&lt;code&gt;ACK=0&lt;/code&gt;表示我收到了受损的包，请重发一次。如果&lt;code&gt;Client&lt;/code&gt;在等待一定时常之后没有收到&lt;code&gt;Server&lt;/code&gt;响应，就认为包是丢失的，开始重传。&lt;/p&gt;
&lt;p&gt;这种方式有一些弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何保证收到的&lt;code&gt;ACK&lt;/code&gt;在途中不会因为噪声干扰发生变化；&lt;/li&gt;
&lt;li&gt;因为客户端都等待服务端的响应，所以在这个过程中无法发送其他包，效率是低下的。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;Server&lt;/code&gt;接收到的是完整的包，但是&lt;code&gt;ACK&lt;/code&gt;在响应过程中丢失了，客户端会在一定时间之后重新发送一个包。服务端无法区别这个是重传的包还是新的包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然无法区分包，那不如就给所有包标上序号吧！这个就是TCP报文头中的&lt;code&gt;序号&lt;/code&gt;和&lt;code&gt;确认号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于TCP是一个全双工的协议，所以客户端和服务端都是可以相互发送报文的。序号用于表示自己这个报文的标号，而确认号表示我希望你能给我发哪个报文（间接表明了你发过来的报文有哪些是安全到达的）。&lt;/p&gt;
&lt;p&gt;这是TCP报文首部中最重要的两个字段，需要好好理解一下！&lt;/p&gt;
&lt;h3 id=&quot;序号与确认号&quot;&gt;序号与确认号&lt;/h3&gt;
&lt;p&gt;TCP把数据看成是一个无结构的、有序的字节流。序号并不是对报文进行编号，而是对字节流进行编号。&lt;/p&gt;
&lt;p&gt;例如主机A的一个进程想通过TCP连接向主机B的一个进程发送一个数据流。这个数据流的大小是500 000字节，一个TCP报文能放的数据大小是1000个字节。那么这个数据流将被拆分成$500000/1000 = 500$个包，第一个报文分配序号&lt;code&gt;0&lt;/code&gt;，第二个报文分配序号&lt;code&gt;1000&lt;/code&gt;，以此类推。&lt;/p&gt;
&lt;p&gt;主机A填充进报文的确认号是主机A希望从主机B收到的下一个字节的序号。例如主机A已经收到了&lt;code&gt;0~999&lt;/code&gt;的所有字节，那么它下一个希望收到的序号是&lt;code&gt;1000&lt;/code&gt;，则A发送的TCP包的确认号是&lt;code&gt;1000&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk71mhau1j30ms0p67wh.jpg&quot; alt=&quot;截屏2020-11-10 下午1.52.18&quot;/&gt;  
&lt;p&gt;这样发送方可以直接通过应答方发送的确认号就可以知道自己之前发送报文的确认情况。如果经过一定时间没有收到应答方的回答的话，就进行重传。由于重传时&lt;code&gt;Seq&lt;/code&gt;是不变的，所以应答方可以通过它来判断是否是重复收到同一个报文了。&lt;/p&gt;
&lt;p&gt;但一次只发一个报文终究是很费时的，所以会一次性传多个报文。虽然发送报文是按序的，但是由于网络链路的影响，接受报文可能不是有序的，甚至可能发生中间的丢包。那么怎么办呢？&lt;/p&gt;

&lt;h3 id=&quot;1-退回n步-go-back-n&quot;&gt;(1) 退回N步 Go-Back-N&lt;/h3&gt;
&lt;p&gt;可以直接在《计算机网络：自顶向下方法》的配套实验网站中看演示动画：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html&quot;&gt;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在GBN算法中，所有分组必须有序到达，否则会被丢弃。也就是接收方丢弃所有失序分组。而当发送方没有收到分组&lt;code&gt;n&lt;/code&gt;的应答，但是却收到了&lt;code&gt;n+1, n+2&lt;/code&gt;的应答时，在等一定时间之后，&lt;code&gt;n, n+1, n+2&lt;/code&gt;都会被重发。&lt;/p&gt;
&lt;p&gt;这种方法的优点是，在接受侧不需要缓存任何失序分组；发送侧需要维护一个发送窗口。&lt;/p&gt;
&lt;p&gt;但是由于一些明明完整到达的报文，由于顺序不对会被丢弃，需要重发，这个会影响性能。尤其是当窗口长度和带宽时延都很大时，可能会需要大量重传分组。而很多分组其实没必要重传。&lt;/p&gt;
&lt;h3 id=&quot;2-选择重传&quot;&gt;(2) 选择重传&lt;/h3&gt;
&lt;p&gt;演示地址：
&lt;a href=&quot;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html&quot;&gt;https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里需要发送方和接收方都维护一个窗口。对于发送方来说，只有当窗口内连续的前&lt;code&gt;x&lt;/code&gt;个包都收到了回应，才会把窗口推进&lt;code&gt;x&lt;/code&gt;。一定时间之后如果还没收到，则重发。&lt;/p&gt;
&lt;h3 id=&quot;tcp的重传&quot;&gt;TCP的重传&lt;/h3&gt;
&lt;p&gt;TCP报文的重传结合了这两种方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先TCP确认是&lt;u&gt;累计式的，并不会对正确接受但是失序的报文逐个确认&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;比如说发送了&lt;code&gt;1, 2, ... n, n+1,n+2&lt;/code&gt;几个包，但是接收方只收到了&lt;code&gt;1, 2, ..., n+1,n+2&lt;/code&gt;，接收方会反复回应&lt;code&gt;ACK=n&lt;/code&gt;，而不会对之后接受的包进行回应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是TCP提供了缓存机制。发送方接收到回应&lt;code&gt;ACK=n&lt;/code&gt;之后只会重传&lt;code&gt;n&lt;/code&gt;包，而不会重传之后的包。不过发送方不是收到一个&lt;code&gt;ACK=n&lt;/code&gt;就会重发的，它会在收到3个冗余&lt;code&gt;ACK&lt;/code&gt;之后才会执行快速重传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk73kz657j30jw0se4qp.jpg&quot; alt=&quot;image-20201110150742521&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于（1）的特性，所以TCP确认并不需要对&lt;code&gt;1, 2, ..., n-1&lt;/code&gt;都进行，只要收到了&lt;code&gt;n&lt;/code&gt;的确认，就可以认为之前的包都有序送达了！这样即便&lt;code&gt;ACK=100&lt;/code&gt;丢失了，也不会有影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk7489ai8j30iu0oq1kx.jpg&quot; alt=&quot;image-20201110144849613&quot;/&gt;&lt;/p&gt;
&lt;center&gt;RFC 5681 产生ACK的建议&lt;/center&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;TCP接收方动作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1~n都到达并ACK了; 现在到了n+1&lt;/td&gt;
&lt;td&gt;延迟ACK。对n+2最多等待500ms，如果没到达则发送一个ACK确认n+1。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1~n-1都到达并确认了，n到达还没确认；现在到了n+1&lt;/td&gt;
&lt;td&gt;立即发送单个累计ACK=n+2，同时确认n和n+1。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1~n-1都到达并确认了，n没到达；现在到了n+1&lt;/td&gt;
&lt;td&gt;立即发送冗余ACK=n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能部分或完全填充接受数据间隔的报文段到达&lt;/td&gt;
&lt;td&gt;如果该报文段填的是对早的空的段，立即发送ACK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;连接与断开的过程&quot;&gt;连接与断开的过程&lt;/h2&gt;
&lt;p&gt;上述是建立完TCP连接之后报文的传输过程。TCP中另一个很重要的是&lt;u&gt;建立连接与断开连接&lt;/u&gt;的过程。其实这个本质和普通的报文传输是一样的，只不过会用一些特殊的位来表示我们正在建立/断开连接。&lt;/p&gt;
&lt;h3 id=&quot;三次握手建立连接&quot;&gt;三次握手🤝建立连接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端的TCP先向服务器端的TCP发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是将报文段的首部&lt;code&gt;SYN&lt;/code&gt;位设置为&lt;code&gt;1&lt;/code&gt;。另外客户端会随机选择生成一个&lt;code&gt;client_isn&lt;/code&gt;放入起始的TCP序号中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器主机收到包含&lt;code&gt;SYN=1&lt;/code&gt;的报文段之后，就知道有客户端想要建立连接了。所以服务器会为该TCP连接分配TCP缓存和变量。然后返回一个响应，表示允许建立连接。这个允许连接的报文也不包含应用层数据，但是有&lt;code&gt;SYN=1&lt;/code&gt;，&lt;code&gt;序号=server_isn&lt;/code&gt;，&lt;code&gt;确认号=client_isn+1&lt;/code&gt;，&lt;code&gt;ACK=1&lt;/code&gt;。（这里虽然没有应用层的数据，但由于它是建立连接的报文，所以确认号是在接收的序号上+1的，这点和单纯的数据传输不太一样）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端接收到服务器的响应之后，客户端也为该连接分配缓存和变量。然后客户端向服务端发送另一个报文：&lt;code&gt;SYN=0&lt;/code&gt;，&lt;code&gt;序号=client_isn+1&lt;/code&gt;，&lt;code&gt;确认号=server_isn+1&lt;/code&gt;。&lt;u&gt;在这个阶段，可以在报文段负载中携带客户端到服务器的数据了！&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之后通信的所有报文段&lt;code&gt;SYN=0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk74tbkvwj30o20nk4qp.jpg&quot; alt=&quot;image-20201110161231022&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上在第二步中，服务器并不会直接为这个TCP连接分配缓存，因为有可能会有黑客不断发送第一步的连接请求，但是不发送第三步的报文，这样会导致服务器建立了大量TCP缓存，但是却都没有用！这个被称为&lt;strong&gt;SYN攻击&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;确认客户端和服务端都有接收和发送的能力。&lt;/li&gt;
&lt;li&gt;如果只有2次握手：万一服务端的应答在过程中丢失了，客户端不会和服务端进行连接，但是服务端会建立连接，这样会白白消耗资源。之后如果客户端再次重发请求，服务器就会认为这是两个TCP连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;四次挥手断开连接&quot;&gt;四次挥手🙋断开连接&lt;/h3&gt;
&lt;p&gt;假设是客户端主动要求关闭连接的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端进程发出一个报文，其中&lt;code&gt;FIN=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器接收到报文之后，发送一个确认报文。&lt;/li&gt;
&lt;li&gt;服务器发送未传输完的数据。&lt;/li&gt;
&lt;li&gt;服务器发送自己的终止报文，有&lt;code&gt;FIN=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务器接收到之后对其进行确认，并定时等待一段时间之后关闭连接。
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk753ihbkj30sm0y8x6p.jpg&quot; alt=&quot;image-20201110161653631&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ol&gt;
&lt;li&gt;客户端发起关闭请求时，它的数据必然是已经发送完毕的。但是服务器的数据可能被发送完毕，所以需要等服务器发送完了之后才会再给一个&lt;code&gt;FIN=1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;ol&gt;
&lt;li&gt;避免客户端发送的ACK没有到达服务端，这样服务端没有接收到ACK会重发FIN且不会释放资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;总结一下&quot;&gt;总结一下&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk75g9ni8j30uo0rsqv5.jpg&quot; alt=&quot;image-20201110161905182&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;回到wireshark抓包&quot;&gt;回到wireshark抓包&lt;/h1&gt;
&lt;p&gt;最后会到之前抓包的结果看一看。中括号内的是首部中的位。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;包序号&lt;/th&gt;
&lt;th&gt;方向&lt;/th&gt;
&lt;th&gt;包内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[SYN], Seq=0, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[SYN, ACK], Seq=0, Ack=1, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[ACK], Seq=1, Ack=1, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[PSH, ACK], Seq=1, Ack=1, Len=12（Data = hello world!）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[ACK], Seq=1, Ack=13, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[PSH, ACK], Seq=1, Ack=13, Len=22（Data = Get your: HELLO WORLD!）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[FIN, ACK], Seq=23, Ack=13, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[ACK], Seq=13, Ack=23, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[ACK], Seq=13, Ack=24, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;51171 ➡️  8090&lt;/td&gt;
&lt;td&gt;[Fin, ACK], Seq=13, Ack=24, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;8090 ➡️  51171&lt;/td&gt;
&lt;td&gt;[Ack], Seq=24, Ack=14, Len=0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;包1中的&lt;code&gt;Seq&lt;/code&gt;实际上是随机生成的数字&lt;code&gt;368303858&lt;/code&gt;，但后面都用相对表示，所以直接认为=0；&lt;/p&gt;
&lt;p&gt;包2中的&lt;code&gt;Ack&lt;/code&gt;也是同理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;挥手流程梳理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gkk76fn6b1j30o40e2gnu.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h1 id=&quot;预告&quot;&gt;预告&lt;/h1&gt;
&lt;p&gt;篇幅比较长了，就先写到这里。我是一名正在自学计算机的大四学生，会在我的博客中记录我的学习之路，欢迎在《开发者头条》中订阅我的独家号「彬Goh的Coding之路」。一起进步吧！&lt;/p&gt;
    &lt;/div&gt;

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5bc287d3291fe6be29b38f378baa7e76</guid>
<title>在 Jitsi 上用 getDisplayMedia 录制本地音频</title>
<link>https://toutiao.io/k/r81ubhx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;事情的起因是这样的，我想往自己的Jitsi Meet实例中添加本地音频，但操作时发现结果并不是我想要的，所以我打算自己开发个简单的程序作为替代。在这过程中，我发现：&lt;/p&gt;



&lt;p&gt;1. 用于屏幕截图的getDisplayMedia缺点多多；&lt;/p&gt;



&lt;p&gt;2. 用于媒体录制的mediaRecorder也有诸多局限；&lt;/p&gt;



&lt;p&gt;3. 在Jitsi Meet里添加HTML / JavaScript的操作非常简单；&lt;/p&gt;



&lt;p&gt;下文是操作的具体细节和一些参考代码。点击&lt;a href=&quot;https://github.com/webrtcHacks/jitsiLocalRecorder&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;这里&lt;/a&gt;可以查看我的成品。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/jitsiRecorder.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;注：如果你想查看Mozilla的Jan-Ivar给出的就此评论和注意事项，请移步&lt;a href=&quot;https://webrtchacks.com/jitsi-recording-getdisplaymedia-audio/#comment-20850&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;评论区&lt;/a&gt;。&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;问题凸显&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;几个月前，我构建了一个Jitsi Meet服务器。当时我想借其来更新我名为&lt;a href=&quot;https://webrtchacks.com/own-phoneco-with-webrtc/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;《两天内用WebRTC建立一家通信公司》&lt;/a&gt;的文章。当然，已经有很多讲解如何开发Jitsi Meet的文章或视频了，而且我也没有什么新鲜的或有趣的意见可分享了。但还有那么一项我迫切想改善的功能——录制。我经常做展示和录制会议，以供他人参考，为将来留存资料。表面上看，我的要求很简单：按需录制我的音频以及Jitsi Meet会话的音频和视频，将文件保存在本地。听起来操作很简单，实则不然。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Jitsi 云录制挑战&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;Jitsi中有一个用于记录的模块，叫&lt;a href=&quot;https://github.com/jitsi/jibri&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Jibri&lt;/a&gt;。Jibri设置和配置的安装要比Jitsi Meet其他部件复杂。但如果你熟悉框架系统，几个小时甚至更少的时间就能把它安装好。Jibri加载了一个无头浏览器去充当呼叫的无声参与者，获取音频并将其保存到磁盘。这会占用大量资源，迫使我把服务器从5美元 / mo升级到了20美元 / mo。但它一次也只处理一条录音。如果你想一次性记录多条，可以设置启动多个Docker容器。但这样也越来越复杂了。除此之外，你还需要建立一种机制来在录制结束后，将文件传输到某个地方或设置Dropbox集成。我只想要一种能快速录制会话，之后进行共享的方法，但现行的功能把这个操作变得很复杂。是时候寻找一种更简单的方法了。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;本地录音&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;另一种方法是仅在本地录制。其实本地记录会更安全，因为你不会把未加密的媒体留在服务器的某处。此外，因为你使用的是本地计算机来保存已经接收的媒体，而不是在云中添加新元素，所以也减少了资源消耗。 Jitsi实际上也有这么个选项，但它只能本地录制音频。而我需要把我看到的也记录下来，所以我开始尝试添加本地屏幕录像。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;如何获得媒体&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;最傻瓜的操作是&lt;a href=&quot;https://support.apple.com/en-us/HT202000&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;把一些音频放在一起进行Quicktime录制&lt;/a&gt;；只使用基于WebRTC的录制API或浏览器扩展程序之一也可以。对此我不做过多叙述，因为该操作并不对所有网络用户通用。我以前做过一个&lt;a href=&quot;https://github.com/cogint/webrtcRecord&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;录音机&lt;/a&gt;，它可以重载createPeerConnection API，获取多个连接中的所有音轨，并将所有音频保存到文件中。实际上它可以和Jitsi Meet的多音频连接配合使用。我原本想设置一些可以同时录屏的canvas，并将其保存。但是我发现用getDisplayMedia操作会更简单。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;getDisplayMedia&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;在&lt;a href=&quot;https://webrtchacks.com/chrome-screensharing-getdisplaymedia/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt;中，我向大家介绍了用于共享桌面媒体的getDisplayMedia API。 其优点是所有主流浏览器都应用了getDisplayMedia。 缺点是应用方式各不相同，且可能会影响用户体验。&lt;/p&gt;



&lt;p&gt;注：下文提到的Edge指的是基于Chromium的新Edge。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;测试代码&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我原以为这是一个容易评估的API，但我想错了。为收集数据，我写了代码来调用getDisplayMedia和测试参数。大家可以在GitHub或我的网站上找到这些&lt;a href=&quot;https://cwh.consulting/gdm-testing/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;代码&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;选择屏幕共享&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;录音器的选择也大有不同。Chrome和Edge允许在全显示窗口、应用程序窗口或浏览器标签中选择录音器。Firefox不允许用浏览器标签选择。而Safari对上述三种方式都不支持，只让你选择当前显示。&lt;/p&gt;



&lt;p&gt;从下面这些图中你能看到各用户界面的差异。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Chrome&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;版本：84&lt;/p&gt;



&lt;p&gt;可选项：全显示、窗口、标签&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-7.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;Edge&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;版本：84&lt;/p&gt;



&lt;p&gt;可选项：全显示、窗口、标签&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-10.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;火狐（firefox）&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;版本：77&lt;/p&gt;



&lt;p&gt;可选项：全显示、窗口&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-5.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;Safari&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;版本：13.1&lt;/p&gt;



&lt;p&gt;可选项：当前显示&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-4.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-3.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;Chrome和Edge在窗口边缘内侧会显示一个蓝色的高亮框，以表明标签页正在被共享。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;displaySurface&lt;/strong&gt;&lt;strong&gt;选择约束无效&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;getDisplayMedia API包含一个displaySurface选项，用于在桌面显示、窗口、应用程序或浏览器标签之间进行选择。而对我来说，我只想记录我的Jitsi Meet标签，所以我就想是否可以通过限制部分选项来简化用户界面。采用约束应该就可以了。&lt;/p&gt;



&lt;p&gt;然而规范中说：&lt;/p&gt;



&lt;p&gt;“用户代理必须让终端用户每次都从所有可选项中来选择共享哪个页面，严禁使用约束来限制选择。”&lt;/p&gt;



&lt;p&gt;事实上，不像getUserMedia，“约束在 &lt;a href=&quot;https://www.w3.org/TR/screen-capture/#dom-mediadevices-getdisplaymedia&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;getDisplayMedia &lt;/a&gt;中的作用与在 &lt;a href=&quot;https://w3c.github.io/mediacapture-main/#local-content&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;getUserMedia &lt;/a&gt;中不同。它们不帮助发现，用户选择后才能应用它。(&lt;a href=&quot;https://www.w3.org/TR/screen-capture/#constrainable-properties-for-captured-display-surfaces&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;原文&lt;/a&gt;)&lt;/p&gt;



&lt;p&gt;这意味着在实践中这些约束毫无意义。想进一步了解的话大家可以去看规范，但基本上这些约束不能起到效果，所以使用它们也没有什么意义。你不能在选择页面启用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;enumerateDevices()&lt;/a&gt;，也不能寻找&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;设备变化&lt;/a&gt;事件。&lt;/p&gt;



&lt;p&gt;（说句题外话：或许这诸多限制是Google Hangouts仍使用自己的扩展机制，不用getDisplayMedia的原因。）&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;分帧器&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;有了getUserMedia，你可以应用视频分辨率和帧率约束。视频分辨率只在捕获后调整视频的大小。如果想减少周期，你也可以降低帧率。事实上，有很多屏幕共享的WebRTC视频会议服务会根据共享的内容，八帧率降到10或更小，以减少占用CPU。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;用户手势要求&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;火狐和Safari需要一个用户手势（比如点击按钮）才能访问getUserMedia。Chrome和Edge不需要。&lt;/p&gt;



&lt;p&gt;把下面的代码粘贴到JavaScript控制台中，亲自体验一下吧！&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-4.png&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;&lt;strong&gt;iFrame&lt;/strong&gt;&lt;strong&gt;权限&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;在&lt;a href=&quot;https://codepen.io/chadwallacehart/pen/GRoNgrE&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;codepen&lt;/a&gt;中进行测试后，我发现iFrames也有限制。火狐和Safari如果没有特别允许权限就不能运行，他们的具体权限也不同。&lt;/p&gt;



&lt;p&gt;火狐需要的权限代码是&amp;lt;iframe allow=”display-capture”&amp;gt; 。Safari的代码是&amp;lt;iframe allow=”display”&amp;gt; 。&lt;/p&gt;



&lt;p&gt;Chrome和Edge没有任何特殊的iFrame要求。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;追踪内容差异&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;这一点并不奇怪，当调用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/getSettings&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;getSettings&lt;/a&gt;时，每个轨道返回的信息是有差异的。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2020/11/WechatIMG11.png&quot; alt=&quot;&quot; class=&quot;wp-image-2956&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;除了Edge增加了一个videoKind的选项之外，Chrome和Edge的内容大致相同。我也不清楚他俩为何是一样的。火狐提供的视频信息最少。Safari只提供了一个值——frameRate。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;MacOS Catalina&lt;/strong&gt;&lt;strong&gt;权限&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;MacOS Catalina在OS引入了新的屏幕录制权限。也就是说你需要授予“屏幕录制”访问应用程序的权限。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-2.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;但是此设置仅在重置应用程序后才会生效，如果你正在开会，需要马上用到电脑，这个操作就很不方便了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-1.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;如果你是第一次实现getDisplayMedia，那就需要提醒Mac用户该操作风险。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;移动端支持&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;该支持并不存在。etDisplayMedia无法在Android或iOS安装的任何浏览器中使用。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;具备音频功能的getDisplayMedia&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;虽然获取多个参与者的音频很难，重载peerConnection并拦截流是可以做到这一点的。然而这样就不能访问系统音频（捕获视频或共享应用程序音频）了。谢天谢地，getDisplayMedia规范允许捕获系统音频。目前我没有看到任何&lt;a href=&quot;https://groups.google.com/forum/#!searchin/discuss-webrtc/PSA%7Csort:date&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;有关webrtc PSA的评论&lt;/a&gt;。但&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=896333&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;去年Chrome引进了此功能&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;音频参数&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;音频捕获参数和getUserMedia获得的参数形式一致。只要添加一个audio: true参数，我们就可以轻松捕获音频：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;navigator.mediaDevices.getDisplayMedia（{video：true，audio：true}）&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;在MacOS上选择Chrome标签后，你会看到“共享音频”选项：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-8.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;MacOS Chrome中带共享音频选项的getDisplayMedia相关界面&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;在Windows上选择“全屏”或选项卡时，会显示以下内容：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtchacks.com/wp-content/uploads/2020/06/pasted-image-0-9.png&quot; alt=&quot;&quot;/&gt;&lt;figcaption&gt;MacOS Edge带共享音频选项的getDisplayMedia相关界面&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;&lt;strong&gt;getDisplayMedia&lt;/strong&gt;&lt;strong&gt;音频捕获的局限性&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;使用getDisplayMedia能捕获到的音频相当有限，且用户体验并不稳定。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;操作系统决定行为&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;如上所示，MacOS只有共享选项卡时音频捕获才可用。Windows全屏或选项卡可用。Linux仅在标签页可用。音频捕获也不适用于OS中任何特定应用程序或窗口。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;浏览器端支持&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;仅Chrome和Edge支持音频捕获，所以整体上浏览器对显示加音频捕获的支持是很差的。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;不稳定的约束检查&lt;/strong&gt;&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;navigator.mediaDevices.getDisplayMedia({audio:true}).then(console.log).catch(console.error);  results in a TypeError: Failed to execute &#x27;getDisplayMedia&#x27; on &#x27;MediaDevices&#x27;: Audio only requests are not supported .&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;我们可以把参数改为{video：true，audio：true}，但是如果用户未选择音频源，这里也不会发出警告或拒绝。如果你的应用需要音频，你需要通过计算音轨来进行检查：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;navigator.mediaDevices.getDisplayMedia({video: true, audio:true}).then(s=&amp;gt;s.getAudioTracks().length&amp;gt;0).catch(console.error);&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;&lt;strong&gt;音频参数&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;在音轨输出上调用getSettings（），如下所示：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;autoGainControl: true
channelCount: 1
deviceId: web-contents-media-stream://37:4
echoCancellation: true
latency: 0.01
noiseSuppression: true
sampleRate: 48000
sampleSize: 16&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;我无法调整参数来调整sampleSize。通过使用各种值进行快速测试，我可以把sampleRate更改为44100或48000。这恰好是PCM和Opus音频（WebRTC支持的强制音频编解码器）的默认速率。我也可以关闭autoGainControl、echoCancellation和noiseSuppression。但我并没有一个很好的方法来测试关掉他们是否真的有效。&lt;/p&gt;



&lt;p&gt;注：关闭echoCancellation确实会返回2条音轨。实际上我们可以使用音频捕获设备进行更多测试，但并不属于我此次的评估范围。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;使用MediaRecorder录制媒体&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;MediaRecorder API&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;mediaRecorder API使录制流变得超级容易。但是：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;recorder = new MediaRecorder(recorderStream, {mimeType: &#x27;video/webm&#x27;}); recorder.start();&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;然后我们可以只听新数据，再将其保存到某个位置的数组中：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;recorder.ondataavailable = e =&amp;gt; {
    if (e.data &amp;amp;&amp;amp; e.data.size &amp;gt; 0) {
        recordingData.push(e.data);
    }
};&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;之后，我们可以重放，或将其保存到磁盘。详见&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;MDN的mediaRecorder API指南&lt;/a&gt;。也可以参阅我有关播放和保存到磁盘的示例。&lt;/p&gt;



&lt;p&gt;注：请谨慎录制&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/start#parameters&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;时段参数&lt;/a&gt;（例如–recorder.start（100））！详情请见有关&lt;a href=&quot;https://github.com/webrtc/samples/issues/1153&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;此问题&lt;/a&gt;WebRTC官方示例的评论。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;各浏览器media Recorder的不同&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我想录制多个流媒体，比如：&lt;/p&gt;



&lt;p&gt;1. getUserMedia本地流，这样我就能知道我在说什么了；&lt;/p&gt;



&lt;p&gt;2. 捕捉他人说话内容和我操作内容的系统音频；&lt;/p&gt;



&lt;p&gt;3. 屏幕截图。&lt;/p&gt;



&lt;p&gt;那我们是不是只需把几个音轨和一个视频轨添加到一个流中，然后将其发送到mediaRecorder呢？并没有这么简单。正如&lt;a href=&quot;http://Chromium%20doc&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;此Chromium说明&lt;/a&gt;所说，如今，Chrome浏览器中的mediaRecorder只能录制单一音轨。 Firefox 支持立体声录制； Safari完全不支持mediaRecorder使用。然而，有这么一段&lt;a href=&quot;https://github.com/ai/audio-recorder-polyfill&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;代码&lt;/a&gt;可以支持我们的录制操作。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebAudio Mixing&lt;/strong&gt;&lt;strong&gt;解决了Chrome mediaRecorder的录制问题&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;Chrome浏览器一次只能录制一条轨道。这个问题有两种解决方法：&lt;/p&gt;



&lt;p&gt;1. 保存单个文件，然后使用&lt;a href=&quot;https://ffmpeg.org/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;ffmpeg&lt;/a&gt;，将其另存为一个多声道流；&lt;/p&gt;



&lt;p&gt;2. 使用WebAudio将多个音频流混合成一个，再将这个音频流发送到recorder。&lt;/p&gt;



&lt;p&gt;第二种方法比较简单，代码数少。输入2个流，混合音频轨，添加所有视频轨道即可（如果mediaRecorder中包含第二个视频流，添加各轨道时该视频流会被忽略）。&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;function mixer(stream1, stream2) {
   const ctx = new AudioContext();
   const dest = ctx.createMediaStreamDestination();

   if(stream1.getAudioTracks().length &amp;gt; 0)
       ctx.createMediaStreamSource(stream1).connect(dest);

   if(stream2.getAudioTracks().length &amp;gt; 0)
       ctx.createMediaStreamSource(stream2).connect(dest);

   let tracks = dest.stream.getTracks();
   tracks = tracks.concat(stream1.getVideoTracks()).concat(stream2.getVideoTracks());

   return new MediaStream(tracks)
}&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;若你需要能更稳定处理混合视频流的方法，可以参阅Muaz Khan的&lt;a href=&quot;https://github.com/muaz-khan/MultiStreamsMixer&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;添加代码到Jitsi&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;下一步操作是将这段代码添加到Jitsi中。你可以在自己的页面中加载这段代码，然后用iFrame将其加载到Jitsi中。你也可以使用&lt;a href=&quot;https://jitsi.github.io/handbook/docs/dev-guide/dev-guide-iframe&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Jitsi iFrame API&lt;/a&gt;把iFrame自动加载到指定元素中。有关该操作的详细说明，大家可以参阅&lt;a href=&quot;https://meet.your.tld/room&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt;。我就不赘述了。在不构建Jitsi源代码的情况下，我们如何完成这个操作呢？&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;使用Jitsi Meet静态文件&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;实际上，Jitsi是通过静态文件来加载各种网络元素的。在安装Debian时，这些文件位于/usr/share/jitsi-meet/ 。如果我们检查/usr/share/jitsi-meet/index.html，可以看到Jitsi Meet使用&amp;lt;！–#include virtual=”yourfile.html”&amp;gt;插入模块。&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;    &amp;lt;script&amp;gt;&amp;lt;!--#include virtual=&quot;/config.js&quot; --&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!-- adapt to your needs, i.e. set hosts and bosh path --&amp;gt;
    &amp;lt;!--#include virtual=&quot;connection_optimization/connection_optimization.html&quot; --&amp;gt;
    &amp;lt;script src=&quot;libs/do_external_connect.min.js?v=1&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;&amp;lt;!--#include virtual=&quot;/interface_config.js&quot; --&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;&amp;lt;!--#include virtual=&quot;/logging_config.js&quot; --&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;libs/lib-jitsi-meet.min.js?v=4025&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;libs/app.bundle.min.js?v=4025&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!--#include virtual=&quot;title.html&quot; --&amp;gt;
    &amp;lt;!--#include virtual=&quot;plugin.head.html&quot; --&amp;gt;
    &amp;lt;!--#include virtual=&quot;static/welcomePageAdditionalContent.html&quot; --&amp;gt;
    &amp;lt;!--#include virtual=&quot;static/settingsToolbarAdditionalContent.html&quot; --&amp;gt;
  &amp;lt;/head&amp;gt;&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;我们只需要在正文部分插入我们的内容，如下所示：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;  &amp;lt;body&amp;gt;
    &amp;lt;!--#include virtual=&quot;body.html&quot; --&amp;gt;
    &amp;lt;div id=&quot;react&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;!--#include virtual=&quot;static/recorder.html&quot; --&amp;gt;
  &amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;该静态目录下的文件会进行加载操作，你需要在此获取recorder文件。我把本地录音功能分成了2个文件:&lt;/p&gt;



&lt;p&gt;1. 带button的&lt;a href=&quot;https://github.com/webrtcHacks/jitsiLocalRecorder/blob/master/recorder.html&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;HTML&lt;/a&gt;及CSS;&lt;/p&gt;



&lt;p&gt;2. 上述提到所有逻辑的&lt;a href=&quot;https://github.com/webrtcHacks/jitsiLocalRecorder/blob/master/recorder.js&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;JavaScript文件&lt;/a&gt;，以及一些基本播放和保存控件。&lt;/p&gt;



&lt;p&gt;文件里还包括一个&lt;a href=&quot;https://github.com/webrtcHacks/jitsiLocalRecorder/blob/master/install.sh&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;bash脚本&lt;/a&gt;，它将复制这些文件并把recorder插入到Jitsi Meet的index.html中。&lt;/p&gt;



&lt;p&gt;完整的文件源码是&lt;a href=&quot;https://github.com/webrtcHacks/jitsiLocalRecorder&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://github.com/webrtcHacks/jitsiLocalRecorder&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;不局限于Jitsi&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;上述方法其实可以录制任何东西，只要加载它就可以了。我的网站上有关于该方法的一个&lt;a href=&quot;https://cwh.consulting/localrecorder/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;演示&lt;/a&gt;，大家可以参考一下。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;有缺憾的方法&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;这个方法对我来说是可行的，但确实不太完美。一方面因为我的CSS真的很烂，更因为这种方法有许多局限性。&lt;/p&gt;



&lt;p&gt;屏幕录制UI差：带音频捕捉功能的getDisplayMedia能做的很少. 我可以通过录制选择来完成操作，但在实际应用中你不能通过询问用户来完成这样的操作。&lt;/p&gt;



&lt;p&gt;没有音频设备选择：在没有指定媒体设备的情况下，我会调用getUserMedia，所以它可能和我在Jitsi Meet会话中使用的设备不一样。通过添加一个媒体设备选择的UI元素来，使用Jitsi的API或者重载getUserMedia能解决该问题。&lt;/p&gt;



&lt;p&gt;没有录音提醒：很多情况下，你有义务告诉别人你正在录音。极简GUI只在本地发挥作用。与内置的Jitsi Meet录音工具不同，我的工具没有录音提醒。所以我试着用&lt;a href=&quot;https://github.com/jitsi/lib-jitsi-meet&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;lib-jitsi-meet API&lt;/a&gt;添加一个新的录音方到通话中。但这有个缺点——它下线了点对点模式（&lt;a href=&quot;https://jitsi.org/blog/p2p4121/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;p2p4121&lt;/a&gt;），这会消耗更多的资源。&lt;/p&gt;



&lt;p&gt;总之，我完成了我的目标，但该方法可能并不适用于所有人。至少我在这个过程中有所收获!&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://webrtchacks.com/jitsi-recording-getdisplaymedia-audio/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://webrtchacks.com/jitsi-recording-getdisplaymedia-audio/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：&lt;a href=&quot;https://webrtchacks.com/author/chad/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Chad Hart&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>