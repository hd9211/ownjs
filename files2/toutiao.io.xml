<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d94851ca017f26ea687c9708250e6a05</guid>
<title>京东不再需要CTO；架构师成长路线；Go1.18泛型编程体验｜码农周刊VIP会员专属邮件周报 Vol.085</title>
<link>https://toutiao.io/k/spdubm8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以下内容节选自「码农周刊VIP会员专属邮件周报 Vol.085」，查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本期，首先分享的是&lt;strong&gt;有效沟通的四个误区&lt;/strong&gt;，供参考。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）我是对的，&lt;strong&gt;错的是你&lt;/strong&gt;；&lt;br/&gt;2）我了解事情的全貌，&lt;strong&gt;你不了解&lt;/strong&gt;；&lt;br/&gt;3）我动机单纯，&lt;strong&gt;你可不一定&lt;/strong&gt;；&lt;br/&gt;4）我不是问题的始作俑者。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicExaAOpFGs2HwoLibfVcbghYjBFH0wjibEvDYjKib0ptt4jic9AtPboeZZNcGehAj7tiaYYtNI6Pa31iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;黑匣子这么重要，为什么数据不能云同步？&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;https://mp.weixin.qq.com/s/VvAGVX_MsXQ8gKIcodSnRw&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;黑匣子最主要的任务是保存数据，其他方面的性能很差，无法搭载实现数据同步所需的操作环境。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;京东不再需要 CTO&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/WT1CB6ORxhHsl4bbIXADpA&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;李大学退休、王亚卿失势、张晨淡出，刘强东找不到心中的理想CTO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;架构师成长路线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/EQZRy63YW58J8dDGqfHM4w&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从各个角度来解读架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;货拉拉全链路监控演进史&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/nrsy3uf&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一年实现降本60%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java开发中那些非常好用的工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/4clfoez&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;太顺手了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;Go1.18泛型编程体验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/fq5drnb&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go 1.18版本发布了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;低代码是什么？有什么优势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/mh3ya24&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;编写信息安全规划的几点经验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/EjFZ2wr5ynzhiqttVAm8ng&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实操内容&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>09bf1272c249da34a93e601769678694</guid>
<title>五个经典的破坏双亲委派场景，Java被啪啪打脸</title>
<link>https://toutiao.io/k/vmx6vhb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486853&amp;amp;idx=1&amp;amp;sn=5af0c8abed9b589d2b221bce92a76dd8&amp;amp;chksm=fafde72bcd8a6e3db14d1d76333954d3efbd8b6b5a204e192bf342e8327e9e3c9dc4cf93bbd4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《深入理解Java类加载机制，再也不用死记硬背了》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《深入理解Java类加载机制，再也不用死记硬背了》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章中提到，&lt;span&gt;从JVM的角度看，加载的读取二进制流和初始化阶段，是开放了主导权给用户的。而剩下的所有部分都是JVM内部完成的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5432372505543237&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib1CWXmoFAMbp4EjiaogUaCvNABab6q28nKichnq0c1wBFuvibUBJauBm1c4rT2sYBVyYciaicDgQqZ97w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;451&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那为什么要这样做呢？这是符合面向对象中的开闭原则和封装思想的设计。JVM将类加载内部复杂的实现封装了起来，拒绝开发者修改。只提供了一个拓展接口，用于二进制流的读取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程上搞懂了，那JVM是怎样使用代码来实现这些步骤的呢？这就要聊到Java的类加载器了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;类加载器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类加载器的分类是Java规范，属于抽象的概念。规范将类加载器分成启动类和非启动类两大类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3632075471698113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib1CWXmoFAMbp4EjiaogUaCvTQey3OwHFzicXIbNrwHibicvcI4CKvaDX98XwZuSy9OZB05uEvYx5YE1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HotSpot对类加载器实现有以下分类(以下描述中省略了HotSpot定语)：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38413685847589424&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib1CWXmoFAMbp4EjiaogUaCvoVN5VibKKEMfOdUfkLZnYudz0iaXM1pXzWkOUHfyghdnUCvhmw8WeZEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动类加载器是C/C++语言实现的，无法作为对象被程序引用。主要用来加载Java的核心类库。类库主要由Java启动参数指定，默认是${JAVA_HOME}/lib。HotSpot还会对类名进行白名单校验来提高安全性。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非启动类加载器都是使用Java来实现，继承自java.lang.ClassLoader，可以作为类对象被程序引用。它也分成3种，简单说一下区别。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扩展类加载器ExtensionClassLoader加载的是${JAVA_HOME}/lib/ext下或者启动时指定的类库。它目标是加载Java类库的扩展，是标准类库的补充。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用类加载器ApplicationClassLoader加载的是环境变量classpath指定的类库。咱们平时使用maven的话，就是使用maven加载的类库和自己编写的代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户类加载器就是用户自己定义的类加载器，也叫自定义类加载器。只要继承于应用类加载器即可。定义不同的类加载器会使用不同的命名空间。因为不同的命名空间是个隐含的限定名区分，是不同的对象。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;双亲委派模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双亲委派的目标是在默认情况下，一个限定名的类只会被一个类加载器加载并解析使用，这样在程序中，它就是唯一的，不会产生歧义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6698002350176263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibI2pg9eY1xTJurMOFyz0wa8m1QicibgN7H1LMDes11hz6Zb7xxibUiaBjoCJ8x3d9R7gRmTYvUCOVCDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;851&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在被动的情况下，当一个类加载器收到类加载请求，它不会首先自己去加载。而是传递给父加载器。这样，所有的类首先都会先由最上层的启动类加载器进行加载，只有父加载器无法完成类加载才会由子加载器完成。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;白话来说：双亲委派模型中，如果类A调用了类B，那类B可能是类A在使用过程中被动加载进来的。那如果类A是用应用程序类加载器加载的，那么类B只能由应用程序类加载器或其父类或者上一层父类来加载。不能由自定义类加载器来来加载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双亲委派模型并不是一个拥有强约束力的模型。它存在设计缺陷，在一些情况下可以被主动破坏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五种经典的破坏双亲委派场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一次破坏&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在《深入理解Java虚拟机》这本书中，记录了怎样破坏双亲委派：因为双亲委派机制原则在java.lang.ClassLoader的loadClass方法中。只要重写loadClass方法就可以破坏。书中还写了一个重写loadClass方法来进行破坏的小样例，这个小样例被称为双亲委派的第一次破坏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Tomcat场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个破坏的样例有没有什么实际价值意义呢？还真有，后来Tomcat就使用这种方式对双亲委派进行破坏，来达到使用一个web容器部署两个或者多个应用程序，不同的应用程序，可能会依赖同一个第三方类库的不同版本，还要能保证每一个应用程序的类库都是独立、相互隔离的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;tomcat自定义了类加载器，重写loadClass方法使其优先加载自己目录下的class文件，来达到class私有的效果。不过咱们现在流行使用的都是嵌入式的web容器了，将来更多的场景还是一个应用程序使用一个单独的web容器。所以这种破坏双亲委派的价值在降低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基于SPI的三种经典破坏场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一种java特性叫做SPI，在《JAVA SPI(Service Provider Interface)原理、设计及源码解析》里，我不仅说了什么是SPI，还提到了三种经典场景都在使用，它们分别是&lt;span&gt;jdbc、Dubbo、Eleasticsearch。没错，这三种经典场景通过SPI都使&lt;/span&gt;&lt;/span&gt;&lt;span&gt;得双亲委派遭到破坏。下面以jdbc为例做说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;jdbc驱动Driver在十几年前，我还手写过用DriverManager来加载的代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Connection conn= DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;1234&quot;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DriverManager初始化时是这样的，注意红框内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8784722222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicrLZSNEsGRTIU9mcFJ1sV6L05ibAQESmwDL8wX1cLOuaNuZ4KxNVE3g6rra9ZSBibw6bibVBR8jt7Qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;红框内容翻译一下就是说：由启动类加载器加载的DriverManager初始化时要去加载Driver驱动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6497844827586207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicrLZSNEsGRTIU9mcFJ1sV6poxXshvqermwGYibsE1rFwCYygmWlROzrkpq8bbC5ia3KQx2BEBU0wWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;jdbc驱动由Serverloader.load加载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1678622668579627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicrLZSNEsGRTIU9mcFJ1sV67oJyXhN0BwAgCPOrAqTO6VuPgUPUgvEYPJ5ffXnWQ4G6yYTwyCWHhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而&lt;span&gt;Serverloader.lo&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;里优先使用当前线程的类加载器而不是自身使用的类加载器来加载Driver。当前线程是使用方要么是应用类加载器要么是自定义类加载器，总归类A调用类B，B没有使用父类而使用了子类加载器，所以破坏了双亲委派。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;双亲委派被破坏的补救措施&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那朋友就问了，java.lang.ClassLoader把loadClass方法定义为final是不是就解决了双亲委派被破坏的问题呢？java.lang.ClassLoader的loadClass方法在Java很早的版本就有了，而双亲委派模型是在JDK1.2中引入的。Java是向下兼容的，所以不是不想改而是改不了了。一个补救措施是推荐使用findClass方法而不是直接重写loadClass。当然了，如果有人登录了服务器，把JDK文件给替换了，也就失效了。这个不在讨论范围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;如果文章对你有帮助，请点【&lt;strong&gt;&lt;span&gt;在看&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果文章你喜欢，&lt;span&gt;请点【&lt;/span&gt;&lt;strong&gt;&lt;span&gt;赞&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果文章既没有帮助又不喜欢，或者有其他建议，欢迎【&lt;/span&gt;&lt;strong&gt;&lt;span&gt;留言&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;】&lt;/span&gt;或者直接加我微信 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;brmayi&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 反馈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;反馈是你的思考，我的成长，我们共同的进步源泉~&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>05294eb6f4d76fc048b2bcb9063d1c33</guid>
<title>Kafka 面试连环炮, 看看你能撑到哪一步?</title>
<link>https://toutiao.io/k/z30ehzv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今天我们就来安排一期关于 Kafka 的核心面试题连环炮,  从&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;基础知识&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;、&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;进阶提升&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;、&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构调优&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt; 三个方向梳理面试题，希望在金三银四的关键节点可以帮助到大家。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;这篇文章干货很多，希望你可以耐心读完。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.39609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyopRDggwq0mKciccdJ3E37uediaQcK4AgJE2khpnGMfylLA9kOvqf4dM6so3JHUD9Yc7QvEMiatehmqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;02 kafka 进阶提升10问&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈你对 kafka 的集群架构是如何理解的？&lt;/span&gt;&lt;/h1&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Kafka 整体架构图&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4150763358778626&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyoeMialZBQdWF9GO2CuBRwpehybWcSN3SsX5n86c7j65TqWZWPg3rb7HQXicmh9Ib6V0FgMUBE9CibxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个典型的 Kafka 集群中包含若干 Producer，若干 Broker「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Kafka支持水平扩展，一般 Broker 数量越多，集群吞吐率越高&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;，若干 Consumer Group，以及一个 Zookeeper集群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka 通过 Zookeeper 管理集群配置，选举 Leader，以及在 Consumer Group 发生变化时进行 Rebalance。Producer 使用 push 模式将消息发布到 Broker，Consumer使用 pull 模式从 Broker 订阅并消费消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Kafka 存储机制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6949860724233984&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyoeMialZBQdWF9GO2CuBRwpeHoYLmew91UsqibD0NrspkD48DqJ3j8At7yRhP8Go2EM54arn8UFfgLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer 端生产的消息会不断追加到 log 文件末尾，这样文件就会越来越大, 为了防止 log 文件过大导致数据定位效率低下，Kafka 采取了分片和索引机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它将每个 Partition 分为多个 Segment每个 Segment 对应3个文件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）.index 索引文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）.log 数据文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）.timeindex 时间索引文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些文件都位于同一文件夹下面，该文件夹的命名规则为：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;topic 名称-分区号&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Kafka 副本机制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46574074074074073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpqp2KIDPBicGrHV0oWKfZJpNp1BbJOhsk42zMibfF9PT5ZG1L95viaQNpPNKPvI8SQW9u2oHc1axAUPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka中的 Partition 为了保证数据安全，每个 Partition 可以设置多个副本。&lt;/span&gt;&lt;span&gt;此时我们对分区0,1,2分别设置3个副本&lt;span&gt;。而且每个副本都是有&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;角色&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;之分的，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它们会选取一个副本作为 Leader 副本，而其他的作为 Follower 副本&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，我们的 Producer 端在发送数据的时候，只能发送到Leader Partition 里面 ，然后 Follower Partition 会去 Leader Partition 自行同步数据, Consumer 消费数据的时候，也只能从 Leader 副本那去消费数据的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Kafka 网络模型&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48703703703703705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazppHLcRRSkQ2jzGhlo2kdR00Le1CQlzNgQv66XxwssQ3cFwXvHSgWPa0H8POg996gTWXud39hBOdIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kafka 采用多路复用方案，Reactor 设计模式，并引用 Java NIO 的方式更好的解决网络超高并发请求问题。&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈Kafka客户端如何巧妙解决JVM GC问题？&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Kafka 客户端缓冲机制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，大家知道的就是在客户端发送消息给 Kafka 服务端的时候，存在一个「&lt;strong&gt;&lt;span&gt;内存缓冲池机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt; &lt;/span&gt;的。即消息会先写入一个内存缓冲池中，然后直到多条消息组成了一个 Batch，达到一定条件才会一次网络通信把 Batch 发送过去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个发送过程图如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7032871972318339&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyrBl44FYHlUic91zUPmsur4XOiaRVtCL8giciafhHGBs9VLbmXL7kDibIZoUU5fcc5HsgjiamkUZj9icicG7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Kafka Producer 发送消息流程如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）进行 Producer 初始化，加载配置参数，开启网络线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）执行拦截器逻辑，预处理消息, 封装 Producer Record。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）调用 Serializer.serialize() 方法进行消息的 key/value 序列化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）调用 partition() 选择合适的分区策略，给消息体 Producer Record 分配要发送的 Topic 分区号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）从 Kafka Broker 集群获取集群元数据 metadata。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6）将消息缓存到 RecordAccumulator 收集器中, 最后判断是否要发送。这个加入消息收集器，首先得从 Deque&amp;lt;RecordBatch&amp;gt; 里找到自己的目标分区，如果没有就新建一个 Batch 消息 Deque 加进入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7）当达到发送阈值，唤醒 Sender 线程，实例化 NetWorkClient 将 batch record 转换成 request client 的发送消息体, 并将待发送的数据按 【Broker Id &amp;lt;=&amp;gt; List】的数据进行归类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8）与服务端不同的 Broker 建立网络连接，将对应 Broker 待发送的消息 List 发送出去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;9）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;批次发送的条件为: 缓冲区数据大小达到 batch.size 或者 linger.ms 达到上限，哪个先达到就算哪个。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;内存缓冲造成的频繁GC问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存缓冲机制说白了，其实就是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;把多条消息组成一个Batch，一次网络请求就是一个Batch 或者多个 Batch&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。这样避免了一条消息一次网络请求，从而提升了吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么问题来了，试想一下一个 Batch 中的数据取出来封装到网络包里，通过网络发送到达 Kafka 服务端。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;此时&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个 Batch 里的数据都发送过去了，里面的数据该怎么处理？&lt;/span&gt;&lt;span&gt;这些 Batch 里的数据还存在客户端的 JVM 的内存里！那么一定要避免任何变量去引用 Batch 对应的数据，然后尝试触发 JVM 自动回收掉这些内存垃圾。这样不断的让 JVM 进行垃圾回收，就可以不断的腾出来新的内存空间让后面新的数据来使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想法是挺好，但&lt;/span&gt;&lt;strong&gt;&lt;span&gt;实际生产运行的时候最大的问题，就是 JVM Full GC 问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。JVM GC 在回收内存垃圾的时候，会有一个「&lt;strong&gt;&lt;span&gt;Stop the World&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;的过程，即垃圾回收线程运行的时候，会导致其他工作线程短暂的停顿，这样可以踏踏实实的回收内存垃圾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;试想一下，在回收内存垃圾的时候，工作线程还在不断的往内存里写数据，那如何让JVM 回收垃圾呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我们看看下面这张图就更加清楚了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6107711138310894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyrBl44FYHlUic91zUPmsur4XicAwTpWCulBEMQbhqcOr05uKo3eAdxTYhlvibVD8X3uI9D79gM5ltiaeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然现在 JVM GC 演进越来越先进，从 CMS 垃圾回收器到 G1 垃圾回收器，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;核心的目标之一就是不断的缩减垃圾回收的时候，导致其他工作线程停顿的时间&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;但是再先进的垃圾回收器这个停顿的时间还是存在的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，如何尽可能在设计上避免 JVM 频繁的 Full GC 就是一个非常考验其设计水平了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Kafka 实现的缓冲机制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;在 Kafka 客户端内部，针对这个问题实现了一个非常优秀的机制，就是「&lt;strong&gt;&lt;span&gt;缓冲池机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;。即&lt;/span&gt;&lt;span&gt;每个 Batch 底层都对应一块内存空间，这个内存空间就是专门用来存放写进去的消息。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个 Batch 数据被发送到了 kafka 服务端，这个 Batch 的内存空间不再使用了。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;此时这个 Batch 底层的内存空间先不交给 JVM 去垃圾回收，而是把&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;这块内存空间给放入一个缓冲池里&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个缓冲池里存放了很多块内存空间，下次如果有一个新的 Batch 数据了，那么直接从缓冲池获取一块内存空间是不是就可以了？然后如果一个 Batch 数据发送出去了之后，再把内存空间还回来是不是就可以了？以此类推，循环往复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看看下面这张图就更加清楚了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7509293680297398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazppn1MKTI37kEBia3ib6zYGoXEmG0clQsW211cHS33aFMHBC2eNw1YRFwiaf8NugZamu6JhsT1StyVEBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3094384707287933&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpqHxJ6FBics1DexDVTLbmDe5x8YzjFQ1xrT2bfFdbH1neZbOU2PTgg3p7khOqdarQ1MCibnp1KFPjvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦使用了这个缓冲池机制之后，就不涉及到频繁的大量内存的 GC 问题了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始化分配固定的内存，即32MB。然后把 32MB 划分为 N 多个内存块，一个内存块默认是16KB，这样缓冲池里就会有很多的内存块&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。然后如果需要创建一个新的 Batch，&lt;/span&gt;&lt;span&gt;就从缓冲池里取一个 16KB 的内存块就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着如果 Batch 数据被发送到 Kafka 服务端了，此时 Batch 底层的内存块就直接还回缓冲池就可以了。这样循环往复就可以利用有限的内存，那么就不涉及到垃圾回收了。没有频繁的垃圾回收，自然就避免了频繁导致的工作线程的停顿了，JVM Full GC 问题是不是就得到了大幅度的优化？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;没错，正是这个设计思想让 Kafka 客户端的性能和吞吐量都非常的高，这里蕴含了大量的优秀的机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈你对 Kafka 消息语义是如何理解的？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;对于 Kafka 来说，当消息从 Producer 到 Consumer，有许多因素来影响消息的消费，因此「&lt;strong&gt;&lt;span&gt;消息传递语义&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;就是 Kafka 提供的 Producer 和 Consumer 之间的消息传递过程中消息传递的保证性。主要分为三种， 如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30462962962962964&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ojWoacgRbyrBl44FYHlUic91zUPmsur4XdBOTqoD9qhhUxD6tQ42pAyTSXdlAjDhbMmSaCV9Lcib1Pbb50wbwvgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这三种语义，我们来看一下可能出现的场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47343957503320055&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyovon6XYrCeoliaRqfhrfbSJReG7ricPdYIBB5CSOPLkGoib5U508QHFwekKQWBKtoHSu6xYLlkO5Kag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1506&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Producer端&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;生产者发送语义：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;首先当 Producer 向 Broker 发送数据后，会进行消息提交，如果成功消息不会丢失。因此发送一条消息后，可能会有几种情况发生&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1）遇到网络问题造成通信中断， 导致 Producer 端无法收到 ack，Producer 无法准确判断该消息是否已经被提交， 又重新发送消息，这就可能造成 &lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;at least once&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;语义。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）在 Kafka 0.11之前的版本，会导致消息在 Broker 上重复写入（保证至少一次语义），但在0.11版本开始，通过引入「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;PID及Sequence Number&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」支持幂等性，保证精确一次&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;exactly once&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;语义&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其中启用幂等传递的方法配置&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：enable.idempotence = true。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;启用事务支持的方法配置&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：设置属性 transcational.id = &quot;指定值&quot;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3）可以&lt;/span&gt;&lt;span&gt;根据 Producer 端 request.required.acks 的配置来取值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;acks = 0：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;由于发送后就自认为发送成功，这时如果发生网络抖动， Producer 端并不会校验 ACK 自然也就丢了，且无法重试。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;acks = 1：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;消息发送 Leader Parition 接收成功就表示发送成功，这时只要 Leader Partition 不 Crash 掉，就可以保证 Leader Partition 不丢数据，保证&lt;span&gt; &lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;at least once&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;语义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;acks = -1 或者 all：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 消息发送需要等待 ISR 中 Leader Partition 和 所有的 Follower Partition 都确认收到消息才算发送成功, 可靠性最高, 但也不能保证不丢数据,比如当 ISR 中只剩下 Leader Partition 了, 这样就变成 acks = 1 的情况了&lt;span&gt;，保证 &lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;at least once&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;语义&lt;/span&gt;。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5020325203252033&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyovon6XYrCeoliaRqfhrfbSJiatwQ74kiaEtKBAOrosqxnic5gTdAwT4ibFlGQBEmLG1zDRtI4n3LQPp0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49214659685863876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyovon6XYrCeoliaRqfhrfbSJOzjudoQLF6licvWS9NVqz5GGtcZsckUbRkthHkia8qyalbC2xYb2dibyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;955&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;Consumer端&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;消费者接收语义：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;从 Consumer 角度来剖析，我们知道 Offset 是由 Consumer 自己来维护的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Consumer 消费消息时，有以下2种选择:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;读取消息 -&amp;gt; 提交offset -&amp;gt; 处理消息:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;如果此时保存 offset 成功，但处理消息失败，Consumer 又挂了，会发生 Reblance，新接管的 Consumer 将从上次保存的 offset 的下一条继续消费，导致消息丢失，保证&lt;/span&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;at most once&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;&lt;/span&gt;&lt;span&gt;语义&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;读取消息 -&amp;gt; 处理消息 -&amp;gt; 提交offset：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果此时消息处理成功，但保存 offset 失败，Consumer 又挂了，导致刚才消费的 offset 没有被成功提交，会发生 Reblance，新接管的 Consumer 将从上次保存的 offset 的下一条继续消费，导致消息重复消费，保证&lt;/span&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;at least once&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;&lt;/span&gt;&lt;span&gt;语义&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;默认 Kafka 提供 &lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;at least once&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;&lt;span&gt;语义的消息传递&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;允许用户通过在处理消息之前保存 Offset 的方式提供 &lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;at most once&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt; 语义。如果我们可以自己实现消费幂等，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;理想情况下这个系统的消息传递就是严格的&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;exactly once&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」, &lt;/span&gt;&lt;span&gt;也就是保证不丢失、且只会被精确的处理一次，但是这样是很难做到的。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈你对 Kafka 副本机制是如何理解的？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;在上篇中，我们简单的分析了 Kafka 副本机制，这里我们再详细分析下 Kafka 的副本机制，说白了就是一个&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;数据备份机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保证集群中的某个节点发生故障时，该节点上的 Partition 数据不丢失，且 Kafka 仍然能够继续工作，提高了系统可用性和数据持久性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同一个分区下的所有副本保存相同的消息数据，这些副本分散保存在不同的 Broker 上，保证了 Broker 的整体可用性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示：一个由 3 台 Broker 组成的 Kafka 集群上的副本分布情况。从这张图中，我们可以看到，主题 1 分区 1 的 3 个副本分散在 3 台 Broker 上，其他主题分区的副本也都散落在不同的 Broker 上，从而实现数据冗余。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44970414201183434&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyp2IZTg1NWIjZ8C1zrhkkAZW26wVwE3sqiaV5nMoNLQv4xvrKfeaJddgQxTSzSNEpu9HO9OC80zCuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;副本同步机制&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然所有副本的消息内容相同，&lt;/span&gt;&lt;span&gt;&lt;span&gt;我们该如何保证副本中所有的数据都是一致的呢？当 Producer 发送消息到某个 Topic 后，消息是如何同步到对应的所有副本 Replica 中的呢？Kafka 中 只有 Leader 副本才能对外进行读写服务，所以解决同步问题，Kafka 是采用基于 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的副本机制来完成的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;在 Kafka 中，一个 Topic 的每个 Partition 都有若干个副本&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;副本分成两类：领导者副本「Leader Replica」和追随者副本「Follower Replica」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;。每个分区在创建时都要选举一个副本作为领导者副本，其余的副本作为追随者副本&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;在 Kafka 中，Follower 副本是不对外提供服务的。也就是说，任何一个&lt;span&gt;Follower 副本&lt;/span&gt;都不能响应客户端的读写请求。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;所有的读写请求都必须先发往 Leader 副本所在的 Broker，由该 Broker 负责处理。&lt;span&gt;Follower 副本&lt;/span&gt;不处理客户端请求，它唯一的任务就是从 &lt;span&gt;Leader 副本&lt;/span&gt;异步拉取消息，并写入到自己的提交日志中，从而实现与 &lt;span&gt;Leader 副本&lt;/span&gt;的同步&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3）在 Kafka 2.X 版本中，&lt;/span&gt;&lt;span&gt;当 &lt;span&gt;Leader 副本 &lt;/span&gt;所在的 Broker 宕机时，ZooKeeper 提供的监控功能能够实时感知到，并立即开启新一轮的 Leader 选举，从 ISR 副本集合中 &lt;span&gt;Follower 副本&lt;/span&gt;中选一个作为新的 Leader ，当旧的 Leader 副本重启回来后，只能作为&lt;span&gt; Follower 副本&lt;/span&gt;加入到集群中&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。3.x 的选举后续会有单篇去介绍。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;副本管理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.668918918918919&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyqFuCYnZkWFk99vXIBFS6qdnUkd8Tia7rc7YYWqU1OJAbMIPuNtyULcLOEzSsIckz23iaFQkrQZ4CKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;AR 副本集合:&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 分区 Partition 中的所有 Replica 组成 AR 副本集合。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ISR 副本集合:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 所有与 Leader 副本能保持一定程度同步的 Replica 组成 ISR&lt;span&gt; 副本集合， 其中也包括 Leader 副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;OSR 副本集合: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;与 Leader 副本同步滞后过多的 Replica 组成 OSR 副本集合&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这里我们重点来分析下 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;ISR 副本集合。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;ISR 副本集合&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面强调过，Follower 副本不提供服务，只是定期地异步拉取 Leader 副本中的数据。既然是异步的，就一定会存在不能与 Leader 实时同步的情况出现&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka 为了解决这个问题， 引入了&lt;/span&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;strong&gt;&lt;span&gt; In-sync Replicas&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;机制&lt;/span&gt;，即 ISR 副本集合。要求 ISR 副本集合中的 Follower 副本都是与 Leader 同步的副本&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么，到底什么样的副本能够进入到 ISR 副本集合中呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先要明确的，Leader 副本天然就在 ISR 副本集合中。也就是说，ISR 不只是有 Follower 副本集合，它必然包括 Leader 副本。另外，能够进入到 ISR 副本集合的 Follower 副本要满足一定的条件&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5907534246575342&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyp2IZTg1NWIjZ8C1zrhkkAZUgl44pMh0P4gK1pf7JSBicjSibT6FMS4G3Kz6JlScfB4t5fuo8exJMvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图中有 3 个副本：1 个 Leader 副本和 2 个 Follower 副本。Leader 副本当前写入了 6 条消息，Follower1 副本同步了其中的 4 条消息，而 Follower2 副本只同步了其中的 3 条消息。那么，对于这 2 个 Follower 副本，你觉得哪个 Follower 副本与 Leader 不同步？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实上，这2个 Follower 副本都有可能与 Leader 副本同步，但也可能不与 Leader 副本同步，这个完全依赖于&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Broker 端参数 replica.lag.time.max.ms 参数值。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个参数是指&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Follower 副本能够落后 Leader 副本的最长时间间隔，当前默认值是 10 秒，从 2.5 版本开始，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;默认值从 10 秒增加到 30 秒&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;即只要一个 Follower 副本落后Leader 副本的时间不连续超过 30 秒，Kafka 就认为该 Follower 副本与 Leader 是同步的，即使 Follower 副本中保存的消息明显少于 Leader 副本中的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时如果这个副本同步过程的速度持续慢于 Leader 副本的消息写入速度的时候，那么在 replica.lag.time.max.ms 时间后，该 Follower 副本就会被认为与 Leader 副本是不同步的，因此 &lt;span&gt;Kafka 会自动收缩，将其&lt;/span&gt;踢出 ISR 副本集合中。后续如果该副本追上了 Leader 副本的进度的话，那么它是能够重新被加回 ISR副本集合的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在默认情况下，当 Leader 副本发生故障时，只有在 ISR 副本集合中的 Follower 副本才有资格被选举为新Leader，而 OSR 中副本集合的副本是没有机会的（可以通过&lt;/span&gt;&lt;strong&gt;&lt;span&gt;unclean.leader.election.enable&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;进行配置执行脏选举）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结：ISR 副本集合是一个动态调整的集合。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈你对Kafka Leader选举机制是如何理解？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;这里所说的 Leader 选举是指分区 Leader 副本的选举，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它是由 Kafka Controller 负责具体执行的，当创建分区或分区副本上线的时候都需要执行 Leader 的选举动作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有以下场景可能会触发选举：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）当 Controller 感知到分区 Leader 下线需要执行 Leader 选举。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时的选举策略是：Controller 会从 AR 副本集合（同时也在ISR 副本集合）中按照副本的顺序取出第一个存活的副本作为 Leader。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;⼀个分区的 AR 副本集合在分配的时候就被指定，并且只要不发⽣重分配集合内部副本的顺序是保持不变的，而分区的 ISR 副本集合中副本的顺序可能会改变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意这里是根据 AR 副本集合的顺序而不是 ISR 副本结合的顺序进行选举的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时如果 ISR 副本集合中没有可用的副本，还需要再检查⼀下所配置的 unclean.leader.election.enable 参数&lt;span&gt;「&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;默认值为false&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如果这个参数配置为true，那么表示允许从非 ISR 副本集合中选举 Leader，从 AR 副本集合列表中找到第⼀个存活的副本即为 Leader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）当分区进行重分配的时候也需要进行 Leader 选举。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;此时的选举策略是&lt;/span&gt;：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;从重分配的 AR 副本集合中找到第⼀个存活的副本，且这个副本在当前的 ISR 副本集合中。当发生优先副本的选举时，直接将优先副本设置为 Leader 即可，AR 副本集合中的第⼀个副本即为优先副本&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）当某节点&lt;span&gt;执⾏ ControlledShutdown &lt;/span&gt;被优雅地关闭时，位于这个节点上的 Leader 副本都会下线，所以与此对应的分区需要执行 Leader 的选举。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;此时的选举策略是&lt;/span&gt;：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;从 AR 副本集合中找到第⼀个存活的副本，且这个副本在当前的 ISR 副本集合中，同时还要确保这个副本不处于正在被关闭的节点上&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈你对Kafka控制器及选举机制是如何理解？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;所谓的控制器&lt;/span&gt;&lt;span&gt;「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Controller&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」&lt;/span&gt;&lt;span&gt;就是通过 ZooKeeper 来管理和协调整个 Kafka 集群的组件。集群中任意一台 Broker 都可以充当控制器的角色，但是在正常运行过程中，只能有一个 Broker 成为控制器&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;控制器的职责主要包括：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）集群元信息管理及更新同步 (Topic路由信息等)&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;主题管理（创建、删除、增加分区等）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）分区重新分配&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）副本故障转移、 Leader 选举、ISR 变更。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）集群成员管理（通过 watch 机制自动检测新增 Broker、Broker 主动关闭、Broker 宕机等）。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;控制器机制&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们知道 &lt;/span&gt;&lt;span&gt;Kafka 2.X 版本是依赖 Zookeeper 来维护集群成员的信息：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;Kafka 使用 Zookeeper 的临时节点来选举 Controller。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;Zookeeper 在 Broker 加入集群或退出集群时通知 Controller&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3）&lt;/span&gt;&lt;span&gt;Controller 负责在 Broker 加入或离开集群时进行分区 Leader 选举&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;控制器数据分布&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;table align=&quot;center&quot; interlaced=&quot;enabled&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;分类&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;数据描述&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; rowspan=&quot;4&quot; colspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相关&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;当前存活的 broker 列表&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;正在关闭中的 broker 列表&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;获取某个 broker 上的所有分区&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;某组 broker 上的所有副本&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; rowspan=&quot;4&quot; colspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;Topic&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相关&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;topic 列表&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;某个 topic 的所有分区和&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有副本&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;移除某个 topic 的所有信息&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;每个分区的 Leader 和 ISR 信息&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td colspan=&quot;1&quot; valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;5&quot;&gt;&lt;p&gt;&lt;span&gt;运维任务&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;副本相关&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;正在进行的&lt;/span&gt;&lt;/p&gt;&lt;span&gt;Leader 选举的分区&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;当前存活的所有副本&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;分配给每个分区的副本列表&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-single&quot;&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;正在进行重分配的分区列表&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;ue-table-interlace-color-double&quot;&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;某组分区下的所有副本&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面表格可以看出,存储的大概有3大类:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;所有topic信息：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;包括具体的分区信息，比如 Leader 副本是谁，ISR 集合中有哪些副本等&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;所有 Broker 信息：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;包括当前都有哪些运行中的 Broker，哪些正在关闭中的 Broker 等&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;涉及运维任务的副本分区：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;包括当前正在进行 Leader 选举以及分区重分配的分区列表等&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;控制器故障转移&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Kafka 集群运行过程中，只能有一台 Broker 充当控制器的角色，存在「&lt;strong&gt;&lt;span&gt;单点故障&lt;/span&gt;&lt;/strong&gt;」的风险，Kafka 如何应对单点故障呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实 Kafka 为控制器提供故障转移功能「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Failover&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;指当运行中的控制器突然宕机时，Kafka 能够快速地感知到，并立即启用备用控制器来代替之前失败控制器的过程&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面通过一张图来展示控制器故障转移的过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4748663101604278&quot; data-type=&quot;png&quot; data-w=&quot;935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpocMOmcxSFibYCGCYagQuUiafiaMN2va2lLtMpFcpGAcKmPKGf3lMDwHZRmQ9tBlkcXc99ia4pjSKMzzA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;控制器触发选举场景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此你一定想知道控制器是如何被选出来的？前面说过，每台 Broker 都能充当控制器，当集群启动后，Kafka 是如何确认控制器在哪台 Broker 呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上这个问题很简单，即 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Broker 启动时，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;会尝试去 ZooKeeper 中创建 /controller 节点，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一个成功创建 /controller 节点的 Broker 会被选为控制器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们看下&lt;/span&gt;&lt;strong&gt;&lt;span&gt;触发 Controller 选举的场景&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;有哪些？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景一、集群首次启动时：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群首次启动时，Controller 还未被选举出来，因此 Broker 启动后，会干4件事：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;先注册 Zookeeper 状态变更监听器，用来监听 Broker 与 Zookeeper 之间的会话是否过期。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;然后将 Startup 这个控制器事件写入到事件队列中&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3）&lt;/span&gt;&lt;span&gt;然后开始启动对应的控制器事件处理线程即「&lt;strong&gt;&lt;span&gt;ControllerEventThread&lt;/span&gt;&lt;/strong&gt;」、以及 「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;ControllerChangeHandler&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」 Zookeeper 监听器，开始处理事件队列中Startup 事件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）最后依赖事件处理线程来选举 Controller&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景二、Broker 监听 /controller 节点消失时&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群运行过程中，当 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Broker 监听到 /controller 节点消失时，就表示此时当前整个集群中已经没有 Controller 了&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。所有监听到 /controller 节点消失的 Broker，此时都会开始执行竞选操作。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么 Broker 是如何监听到 ZooKeeper 上的变化呢？主要依赖 ZooKeeper 监听器提供的功能，所以 Kafka 是依赖 ZooKeeper 来完成 Controller 的选举。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 Kafka 3.X 版本中，内部实现一个类似于 Raft 的共识算法来选举 Controller。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景三、Broker 监听 /controller 节点数据变化时&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群运行过程中，当&lt;/span&gt;&lt;span&gt;&lt;strong&gt; Broker 检测到 /controller 节点数据发生变化，此时 Controller 可能已经被「易主」了&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这时有以下两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）假如 Broker 是 Controller，那么该 Broker 需要首先执「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;退位&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」操作，然后再尝试进行竞选 Controller。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）假如 Broker 不是 Controller，那么，该 Broker 直接去竞选新 Controller。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;05&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;控制器选举机制&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实选举最终都是通过调用底层的 elect 方法进行选举，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyoeMialZBQdWF9GO2CuBRwpeMxyVPsxJ1xuXyRYDB33eiadQf2dg5KicclolcBGrNAQFxg9lQ190Ovqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈 kafka 的数据可靠性是怎么保证的？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;开始数据可靠性之前先看几个重要的概念：AR、OSR、ISR、HW、LEO，前面已经讲了 AR、OSR、ISR。这里我们重点讲下 HW、LEO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HW：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;全称「&lt;strong&gt;&lt;span&gt;Hign WaterMark&lt;/span&gt;&lt;/strong&gt;」 ，即&lt;span&gt;高水位，它标识了一个特定的消息偏移量 offset ，消费者只能拉取到这个水位 offset 之前的消息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;LEO：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;全称「&lt;strong&gt;&lt;span&gt;Log End Offset&lt;/span&gt;&lt;/strong&gt;」，它&lt;span&gt;标识当前日志文件中下一条待写入的消息的 offset，在 ISR 副本集合中的每个副本都会维护自身的LEO。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5879629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr2PPUPywVebvOZDNpMFoJ1bevkv1wR1So1iaAIyZP5kg919B8rwKJmibEF9hSib2CwX3k8TRxic81Wmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可以看出 HW 和 LEO 的作用：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HW 作用：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;用来标识分区下的哪些消息是可以被消费者消费的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;协助 Kafka 完成副本数据同步&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;LEO 作用：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;&lt;span&gt;如果 Follower 和 Leader 的 LEO 数据&lt;/span&gt;&lt;span&gt;同步了, 那么 HW 就可以更新了&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;&lt;span&gt;HW 之前的消息数据对消费者是可见的，&lt;/span&gt;&lt;span&gt;属于 commited 状态,  HW 之后的消息数据对消费者是不可见的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24934383202099739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazprektvj6gaAYp8JobQzcf7Mv65pVWmZz6kyKv2DKeM8pLSEavcv99FUzgaJhiauZibzzLvKiachUI2dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;HW 更新是需要一轮额外的拉取请求才能实现，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Follower 副本要拉取 Leader 副本的数据，&lt;/span&gt;&lt;span&gt;也就是说，Leader 副本 HW 更新和 Follower 副本 HW 更新在时间上是存在错配的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这种错配是很多“数据丢失”或“数据不一致”问题的根源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;因此社区在 0.11 版本正式引入了&lt;/span&gt;&lt;span&gt; 「&lt;strong&gt;&lt;span&gt;&lt;strong&gt;Leader Epoch&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;」 &lt;/span&gt;&lt;span&gt;概念，来规避因 HW 更新错配导致的各种不一致问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 所谓 Leader Epoch，我们大致可以认为是 Leader 版本。它由两部分数据组成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Epoch: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;一个单调递增的版本号。每当副本 Leader 权力发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;起始位移（Start Offset）:&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; Leader 副本在该 Epoch 值上写入的首条消息的位移。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;Kafka Broker 会在&lt;/span&gt;&lt;strong&gt;&lt;span&gt;内存中为每个分区都缓存 Leader Epoch 数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，同时它还会定期地将这些信息&lt;/span&gt;&lt;strong&gt;&lt;span&gt;持久化到一个 checkpoint 文件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;中。当 Leader Partition 写入消息到磁盘时，Broker 会尝试更新这部分缓存。如果该 Leader 是首次写入消息，那么 Broker 会向缓存中增加一个 Leader Epoch 条目，否则就不做更新。这样，每次有 Leader 变更时，新的 Leader 副本会查询这部分缓存，取出对应的 Leader Epoch 的起始位移，以避免数据丢失和不一致的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;严格来说，这个场景发生的前提是 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Broker 端参数 min.insync.replicas 设置为 1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。此时一旦消息被写入到 Leader 副本的磁盘，就会被认为是 commited 状态，但因存在时间错配问题导致 Follower 的 HW 更新是有滞后的。如果在这个短暂的滞后时间内，接连发生 Broker 宕机，那么这类数据的丢失就是无法避免的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来, 我们来看下如何利用 Leader Epoch 机制来规避这种数据丢失。如下图所示:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6563467492260062&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyoeMialZBQdWF9GO2CuBRwpeoQtVdGUtKtJ6jGichmhIAahYak56UVKAIKmk9YudKw5OHZjlwXENMww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;969&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;因此 Kafka 只对 &lt;/span&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;已提交&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」的消息做&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;最大限度的持久化保证不丢失&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;由于篇幅&lt;/span&gt;&lt;span&gt;详细请看：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;amp;mid=2247490489&amp;amp;idx=1&amp;amp;sn=17817f6d9837ad6a8823362d5ed38687&amp;amp;chksm=cefb3288f98cbb9edeb568e51127c25caa90da6dd064936560a851a9c9e5b865bb49ca04312d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;刨根问底: Kafka 到底会不会丢数据？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;刨根问底: Kafka 到底会不会丢数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈 Kafka 消息分配策略都有哪些？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36926360725720386&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ojWoacgRbyoeMialZBQdWF9GO2CuBRwpeu9ibrwaKALeribNCiaIicHY6iaiaAic9xVqcDA2yGg9vLfsMdqkibjANm9OydA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;937&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里主要说的是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;消费的分区分配策略&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，我们知道一个 Consumer Group 中有多个 Consumer，一个 Topic 也有多个 Partition，所以必然会有 Partition 分配问题「&lt;strong&gt;&lt;span&gt; &lt;strong&gt;确定哪个 Partition 由哪个 Consumer 来消费的问题&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka 客户端提供了3 种分区分配策略：RangeAssignor、RoundRobinAssignor 和 StickyAssignor，前两种分配方案相对简单一些StickyAssignor 分配方案相对复杂一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;RangeAssignor &lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;RangeAssignor 是 Kafka 默认的分区分配算法，它是按照 Topic 的维度进行分配的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，首先对 每个Topic 的 Partition 按照分区ID进行排序，然后对订阅该 Topic 的 Consumer Group 的 Consumer 按名称字典进行排序，之后&lt;/span&gt;&lt;strong&gt;&lt;span&gt;尽量均衡的按照范围区段将分区分配给 Consumer&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。此时也可能会造成先分配分区的 Consumer 任务过重（分区数无法被消费者数量整除）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分区分配场景分析如下图所示（同一个消费者组下的多个 consumer）：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5107655502392344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr5zt2hOlk3F9pic5Gyfm4caiap42wPFL44pEMsmslaxK7icTlsM6Fmvkz6flXhcwOiaTKDvibU7QsWviag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6710239651416122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr5zt2hOlk3F9pic5Gyfm4ca6JTibXWSibdFaMloloY0ZHpKLvOtk0ub9EgJVas7oS7Vl3sQg0UibORKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：该分配方式明显的问题就是随着消费者订阅的Topic的数量的增加，不均衡的问题会越来越严重。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;RoundRobinAssignor&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;该分区分配策略是将 Consumer Group 订阅的所有 Topic 的 Partition 及所有 Consumer 按照字典进行排序后尽量均衡的挨个进行分配。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果 Consumer Group 内，每个 Consumer 订阅都订阅了相同的Topic，那么分配结果是均衡的。如果订阅 Topic 是不同的，那么分配结果是不保证「&lt;strong&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;尽量均衡&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;」的，因为某些 Consumer 可能不参与一些 Topic 的分配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;分区&lt;/strong&gt;分配场景分析如下图所示：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1) 当组内每个 Consumer 订阅的相同 Topic ：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4880095923261391&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr5zt2hOlk3F9pic5Gyfm4ca3a3YJ1tp2MS7K7veFmFI1oYSHuPAUAzEzk9yM9ibU6frXN8tV9Pw18Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2) 当组内每个订阅的不同的 Topic ，这样就可能会造成分区订阅的倾斜:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4856262833675565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlcrD0BkNTVpwY19tibdlyE6NtWub5jicygoZ4oZTUicUhU8yciaOG3vXQsibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;StickyAssignor&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该分区分配算法是最复杂的一种，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;可以通过 partition.assignment.strategy 参数去设置&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，从 0.11 版本开始引入，目的就是在执行新分配时，尽量在上一次分配结果上少做调整，其主要实现了以下2个目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、Topic Partition 的分配要尽量均衡。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、当 Rebalance 发生时，尽量与上一次分配结果保持一致。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;当两个目标发生冲突的时候，优先保证第一个目标，这样可以使分配更加均匀&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，其中第一个目标是3种分配策略都尽量去尝试完成的， 而第二个目标才是该算法的精髓所在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们看看该策略与RoundRobinAssignor策略的不同：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;分区&lt;/strong&gt;分配场景分析如下图所示：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）组内每个 Consumer 订阅的相同的 Topic ，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;RoundRobinAssignor 跟&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;StickyAssignor &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;分配一致：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.53125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr5zt2hOlk3F9pic5Gyfm4caRx42Oicbu0qXvP9iaqCAoTwvQicicYRfyvFRxNlPzMz35QB0khdB6Odovw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当发生 Rebalance 情况后，可能分配会不太一样，假如这时候C1发生故障下线：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;RoundRobinAssignor：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5300353356890459&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr5zt2hOlk3F9pic5Gyfm4caHVGQReyaxQVEovicB68yDFQOib7WPZlvRzobux3ZqMiaSB5pUhmBNLhSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;StickyAssignor：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5080459770114942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr5zt2hOlk3F9pic5Gyfm4car7wBTCLicTTsiaMZwhjfpnoQibF8exWSkZ6JuClPS9j7jsoQk3iaE314Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结论: 从上面 Rebalance 发生后的结果可以看出，虽然两种分配策略最后都是均匀分配的，但是 RoundRoubin&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;Assignor 分区分配策略&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; 完全是重新分配了一遍，而 Sticky&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;Assignor&lt;/strong&gt; &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;则是在原先的基础上达到了均匀的状态。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2) 当组内每个 Consumer 订阅的 Topic 是不同情况:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;RoundRobinAssignor：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48897795591182364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlcNLW6KeAbB7pK0qExqp1pf2smxaoyFDGfrcfnDabWNicX1ZVECxGtI9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;StickyAssignor：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4845360824742268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlcIIwp95461y08NWIaJVmdicM4tbmibnexbwbVMpZ4BTwhL4h8SsG9JuOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当发生 Rebalance 情况后，可能分配会不太一样，假如这时候C1发生故障下线：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;RoundRobinAssignor：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45359749739311783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlcpFDBDIJXBPcn8fUQdHGXnNuJPIiaF3fRZNtAZVKOSktaGMia6JZIAPDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;StickyAssignor：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45390070921985815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlcJ6s5oiaM1ib8B0TIda3DvlIkq2pdMMeyHiaystu2ce36bZdjQozy1cwSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面结果可以看出，RoundRoubin 的分配策略在 Rebalance 之后造成了严重的分配倾斜。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;因此在生产环境上如果想要减少重分配带来的开销，可以选用 StickyAssignor 的分区分配策略。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈 Kafka 消费者重平衡机制是怎样的？&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所谓的消费者组的重平衡目的就是让组内所有的消费者实例对消费哪些主题分区达成一致&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 Consumer Group 来说，可能随时都会有 Consumer 加入或退出，那么 Consumer 列表的变化必定会引起 Partition 的重新分配。我们将这个分配过程叫做 Consumer Rebalance，但是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这个分配过程需要借助 Broker 端的 Coordinator 协调者组件，在 Coordinator 的帮助下完成整个消费者组的分区重分配，也是通过监听ZooKeeper 的 /admin/reassign_partitions 节点触发的&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Rebalance 触发与通知&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rebalance 的触发条件有三种:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;当 Consumer Group 组成员数量发生变化(主动加入或者主动离组，故障下线等)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;当订阅主题数量发生变化&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）&lt;/span&gt;&lt;span&gt;当订阅主题的分区数发生变化&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;Rebalance 触发后如何通知其他 Consumer 进程？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;Rebalance 的通知机制就是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;靠 Consumer 端的心跳线程&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，它会定期发送心跳请求到 Broker 端的 Coordinator 协调者组件,当协调者决定开启 Rebalance 后，它会将&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;REBALANCE_IN_PROGRESS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;封装&lt;/span&gt;&lt;span&gt;进心跳请求的响应中发送给 Consumer ,当 Consumer 发现心跳响应中包含了&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;REBALANCE_IN_PROGRESS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;，就知道是 Rebalance 开始了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Rebalance 协议说明&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实 Rebalance 本质上也是一组协议，Consumer Group 与 Coordinator 共同使用它来完成 Consumer Group 的 Rebalance。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我看看这5种协议完成了什么功能：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Heartbeat 请求：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Consumer 需要定期给 Coordinator 发送心跳来证明自己还活着。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;LeaveGroup 请求：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;主动告诉 Coordinator 要离开 Consumer Group。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;SyncGroup 请求：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Group Leader Consumer 把分配方案告诉组内所有成员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;JoinGroup 请求：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;成员请求加入组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;DescribeGroup 请求：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;显示组的所有信息，包括成员信息，协议名称，分配方案，订阅信息等。通常该请求是给管理员使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Coordinator 在 Rebalance 的时候主要用到了前面4种请求。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Consumer Group 状态机&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 Rebalance 一旦发生，就会涉及到 Consumer Group 的状态流转，此时 Kafka 为我们设计了一套完整的状态机机制，来帮助 Broker Coordinator 完成整个重平衡流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解整个状态流转过程可以帮助我们深入理解 Consumer Group 的设计原理。5种状态，定义分别如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Empty 状态&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;表示当前组内无成员， 但是可能存在 Consumer Group 已提交的位移数据，且未过期，这种状态只能响应 JoinGroup 请求。。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Dead 状态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;表示组内已经没有任何成员的状态，组内的元数据已经被 Broker Coordinator 移除，这种状态响应各种请求都是一个Response：UNKNOWN_MEMBER_ID。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PreparingRebalance 状态&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;表示准备开始新的 Rebalance, 等待组内所有成员重新加入组内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CompletingRebalance 状态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;表示组内成员都已经加入成功，正在等待分配方案，旧版本中叫&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;AwaitingSync&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Stable 状态&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;表示 Rebalance 已经完成， 组内 Consumer 可以开始消费了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;5种状态流转图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5453703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlcWO39W7Vpv8ianvNkUrlcS7xJG8TKz3onNiajQEszGgsSvQvlqvoSKuwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Rebalance 流程分析&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面5种状态可以看出，Rebalance 主要分为两个步骤：加入组&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;JoinGroup请求&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;和等待 Leader Consumer 分配方案&lt;span&gt;「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;SyncGroup 请求&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section title=&quot;660，更新于2016-05-06 09:57&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section title=&quot;315，更新于2015-09-25 09:46&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;JoinGroup请求&lt;/section&gt;&lt;img data-fileid=&quot;100004025&quot; data-ratio=&quot;0.8333333333333334&quot; data-type=&quot;png&quot; data-w=&quot;24&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iabWEnNLIJBhGH7rvZ322E9kia1FsphdbhmP25BFRiaeumU5dNszPgzh1pXWbFq9zn1NEw0wFo1aWlkQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;组内所有成员向 Coordinator 发送 JoinGroup 请求，请求加入组，顺带会上报自己订阅的 Topic，这样 Coordinator 就能收集到所有成员的 JoinGroup 请求和订阅 Topic 信息，Coordinator 就会从这些成员中选择一个担任这个Consumer Group 的 Leader「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一般情况下，第一个发送请求的 Consumer 会成为 Leader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里说的 Leader 是指具体的某一个 Consumer，它的任务就是收集所有成员的订阅 Topic 信息，然后制定具体的消费分区分配方案。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;待选出 Leader 后，Coordinator 会把 Consumer Group 的订阅 Topic 信息封装进 JoinGroup 请求的 Response 中，然后发给 Leader ，然后由 Leader 统一做出分配方案后，进入到下一步&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5496828752642706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlcTWo0oVONiaqIic8B5lqUpr8iaYnSxrxv3kGAcrQXff08ck2kT3BOicSXiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section title=&quot;660，更新于2016-05-06 09:57&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section title=&quot;315，更新于2015-09-25 09:46&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;SyncGroup 请求&lt;/section&gt;&lt;img data-fileid=&quot;100004025&quot; data-ratio=&quot;0.8333333333333334&quot; data-type=&quot;png&quot; data-w=&quot;24&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iabWEnNLIJBhGH7rvZ322E9kia1FsphdbhmP25BFRiaeumU5dNszPgzh1pXWbFq9zn1NEw0wFo1aWlkQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;Leader 开始分配消费方案，&lt;strong&gt;&lt;span&gt;即哪个 Consumer 负责消费哪些 Topic 的哪些 Partition&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一旦完成分配，Leader 会将这个分配方案封装进 SyncGroup 请求中发给 Coordinator ，其他成员也会发 SyncGroup 请求，只是内容为空，待 Coordinator 接收到分配方案之后会把方案封装进 SyncGroup 的 Response 中发给组内各成员, 这样各自就知道应该消费哪些 Partition 了。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6267529665587918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpoxy9PicA1zF2ufQsqdhsC5ibmHjEXib1vaSibicPUkrlAMxcwyYwvHE9uZA5oam8cSTKnTNySbFiccSic6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;05&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Rebalance 场景分析&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚刚详细的分析了关于 Rebalance 的状态流转，接下来我们通过时序图来重点分析几个场景来加深对 Rebalance 的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景一：新成员(c1)加入组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里新成员加入组是指组处于 Stable 稳定状态后，有新成员加入的情况。当协调者收到新的 JoinGroup 请求后，它会通过心跳机制通知组内现有的所有成员，强制开启新一轮的重平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5305555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpr9UWArJVFtscdkibLuyfxlc19bPylecR2q7ZAoVGpBEfPqaTfA0Uh8hFQ2DcRicdoSiazCf9LVTiaApQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景二：成员(c2)主动离组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里主动离组是指消费者所在线程或进程调用 close() 方法主动通知协调者它要退出。当协调者收到 LeaveGroup 请求后，依然会以心跳机制通知其他成员，强制开启新一轮的重平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5388888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazppXOMsQggia4DuSGgAMHrjN2wySLbEH4ibp41rT24AoBTrFHS2VTzpaksVrhSkdlDz8gAOEJiapKu1Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;场景三：成员(c2)超时被踢出组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里超时被踢出组是指消费者实例出现故障或者处理逻辑耗时过长导致的离组。此时离组是被动的，协调者需要等待一段时间才能感知到，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一般是由消费者端参数 session.timeout.ms 控制的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5203703703703704&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpoxy9PicA1zF2ufQsqdhsC5ibcr2QoTmW98eXJeUS6iaOgVC319FaaicPQml4bBMZehWFSmLUJOERMaLw/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景四：成员(c2)提交位移数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当重平衡开启时，协调者会要求组内成员必须在这段缓冲时间内快速地提交自己的位移信息，然后再开启正常的 JoinGroup/SyncGroup 请求发送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5157407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FrBePKkiazpoxy9PicA1zF2ufQsqdhsC5ib2x627FLBHVoaP4Yjjsibvt0BBXtwNmb16AygRic7R3xsBg2t3ic7dwMlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;谈谈Kafka线上大量消息积压你是如何处理的？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息大量积压这个问题，直接原因&lt;span&gt;一定是某个环节出现了性能问题，来不及消费消息，才会导致消息积压&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;接着就比较坑爹了，此时假如 Kafka 集群的磁盘都快写满了，都没有被消费，这个时候怎么办？或者消息积压了⼏个⼩时，这个时候怎么办？生产环境挺常⻅的问题，⼀般不出问题，而⼀出就是⼤事故。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们先来分析下，在使用 Kafka 时如何来优化代码的性能，避免出现消息积压。如果你的线上 Kafka 系统出现了消息积压，该如何进行紧急处理，最大程度地避免消息积压对业务的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;优化性能来避免消息积压&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于 Kafka 性能的优化，主要体现在生产者和消费者这两部分业务逻辑中。而 Kafka 本身不需要多关注的主要原因是，对于绝大多数使用Kafka 的业务来说，Kafka 本身的处理能力要远大于业务系统的处理能力。Kafka 单个节点，消息收发的性能可以达到每秒钟处理几十万条消息的水平，还可以通过水平扩展 Broker 的实例数成倍地提升处理能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于业务系统处理的业务逻辑要复杂一些，单个节点每秒钟处理几百到几千次请求，已经非常不错了，所以我们应该更关注的是消息的收发两端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 发送端性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发送端即生产者业务代码都是先执行自己的业务逻辑，最后再发送消息。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如果说性能上不去，需要你优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于发送消息的业务逻辑，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能。我们知道 Producer 发消息给 Broker 且收到消息并返回 ack 响应，&lt;/span&gt;&lt;span&gt;假设这一次过程的平均时延是 1ms，它包括了下面这些步骤的耗时：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;发送端在发送网络请求之前的耗时&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;发送消息和返回响应在网络传输中的耗时&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）&lt;/span&gt;&lt;span&gt;Broker 端处理消息的时延&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;假设此时你的发送端是单线程，每次只能发送 1 条消息，那么每秒只能发送 1000 条消息，这种情况下并不能发挥出 Kafka 的真实性能。此时无论是增加每次发送消息的批量大小，还是增加并发，都可以成倍地提升发送性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果当前发送端是在线服务的话，比较在意请求响应时延，此时可以采用并发方式来提升性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果当前发送端是离线服务的话，更关注系统的吞吐量，发送数据一般都来自数据库，此时更适合批量读取，批量发送来提升性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-spm-anchor-id=&quot;a2c6h.12873639.0.i5.3ee93c41d5v2te&quot;&gt;&lt;strong&gt;&lt;span&gt;另外还需要关注下消息体是否过大&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，如果消息体过大，势必会增加 IO 的耗时，影响 Kafka 生产和消费的速度，也可能会造成消息积压。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 消费端性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在使用 Kafka 时，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。如果只是暂时的，那问题不大，只要消费端的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要是消费速度一直比生产速度慢，时间长了系统就会出现问题，比如Kafka 的磁盘存储被写满无法提供服务，或者消息丢失，对于整个系统来说都是严重故障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们在设计的时候，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费端的性能优化除了优化业务逻辑外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。&lt;/span&gt;&lt;span&gt;需要注意的是，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区数量，确保 Consumer 的实例数和分区数量是相等的&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;消息积压后如何处理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日常系统正常时候，没有积压或者只有少量积压很快就消费掉了，但某时刻，突然开始积压消息且持续上涨。这种情况下需要你在短时间内找到消息积压的原因，迅速解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导致消息积压突然增加，只有两种：发送变快了或者消费变慢了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如&lt;span&gt;赶上大促或者抢购时，&lt;/span&gt;短时间内不太可能优化消费端的代码来提升消费性能，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;此时唯一的办法是通过扩容消费端的实例数来提升总体的消费能力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;如果短时间内没有足够的服务器资源进行扩容，只能降级一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，保证重要业务服务正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如通过内部监控到消费变慢了，需要你检查消费实例，分析一下是什么原因导致消费变慢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、优先查看日志是否有大量的消费错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、此时如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在哪里&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;触发死锁或者卡在某些等待资源&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ec54fb4b9135dc4afd158e8289a2a87</guid>
<title>架构方案：测试场多环境逻辑隔离方案</title>
<link>https://toutiao.io/k/vgkvewd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引&lt;/span&gt;&lt;span&gt;言&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着功能的迭代和业务的增长，一套开发环境和一套测试环境往往很难满足需求。&lt;/span&gt;&lt;span&gt;不同的功能、不同的分支代码在同一套环境测试，难免互相影响。&lt;/span&gt;&lt;span&gt;所以看到公司往往有多套开发环境和多套测试环境，以应对这些冲突。&lt;/span&gt;&lt;span&gt;多套环境带来的运维成本增加，例如：&lt;/span&gt;&lt;span&gt;像中间件、DB、机器等往往需要独立部署。&lt;/span&gt;&lt;span&gt;另外多套环境也难以解决众多开发测试需求，还可能造成冲突。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍通过测试场的方式来解决众多环境的的问题，主要内容有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单套环境对开发测试的影响&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试场启动流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试场调用流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;中间件在测试场中的实现&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-custom=&quot;#138bde&quot; data-id=&quot;86122&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;一、单环境对开发测试的影响&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面整理了同一套环境开发测试中的常见问题，RPC调用错乱、消息消费错乱以及数据问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.服务RPC调用错乱&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40706806282722513&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU7XeVps4BhBae19HqpAEbDAuMhOPDjoWVheQYr6JqiaY3HVTGeD40z0Xt9f5obJa36xicYgL1ia8lrxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1528&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，调用链路调用关系，A调用B，B调用C，接着C调用D，最后D调用E。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在同一套环境中，A和B两个服务分别拉了两个分支开发不同的功能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;A-branch1与B-branch1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A-branch2与B-branch2&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期望A-branch1调用B-branch1，而A-branch2调用B-branch2。但有可能A-branch1调用B-branch2，A-branch2调用了B-branch1。也就是A和B之间的调用随机的，给开发调试造成困扰。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.发送消费消息错乱&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3951011714589989&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU7XeVps4BhBae19HqpAEbDADcLgZkTkz0sEdIsDVw9Bn6eVHFWUQyHicWTBTibkibuD6G5Tmrubujtyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1878&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，调用链路调用关系，A调用B，B发送消息到消息集群，C消费后RPC调用D，最后D调用E。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在同一套环境中，B和C两个服务分别拉了两个分支开发不同的功能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;B-branch1与C-branch1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B-branch2与C-branch2&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期望B-branch1发送的消息被C-branch1消费，而B-branch2发送的消息被C-branch2消费。但有可能B-branch1发送的消息被C-branch2消费了，B-branch2发送的消息被C-branch1消费了。也就是C-branch1和C-branch2消费时随机的，给开发调试造成困扰。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.存储数据被改错乱&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据被改这个容易理解，大家共用一套数据库，各管各的开发调试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于数据修改，影响了其他人的调试，给别人造成困扰。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section data-custom=&quot;#138bde&quot; data-id=&quot;86122&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;二、测试场启动流程&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.测试场启动流程图示&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9159159159159159&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU7XeVps4BhBae19HqpAEbDAGPfrk2BYmaOI7fbRfzRhCWWvXW2dXSkc3Eex6F7pobwD6DBxJ328kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1998&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.测试场启动流程概述&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在发布系统【创建测试场】该测试场中可以拉入联调的上下游服务以及分支&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在发布系统脚本中通过-D将测试场参数（例如：-DtestGround=abcd）传入，RPC框架该标记写入注册中心，完成【节点打标】。例如：在注册中心节点1.2.3.4写入tag=abcd&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息集群通过不同主题来完成【消息流量隔离】，在启动节点可以动态拼接不同的消费组来订阅不同的主题。例如：abcd_melon_consumer 订阅 abcd_melon_topic 完成测试场abcd的流量隔离&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section data-custom=&quot;#138bde&quot; data-id=&quot;86122&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;三、测试场调用流程&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.RPC调用流程&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4124145186743819&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU7XeVps4BhBae19HqpAEbDAs5tfcaBFCE5FaCXCGSaCIbn8H9Nzrvq9WiaricZqyZJyiaFE5yocUvrcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1901&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测试场中提供一套稳定环境，该环境部署了master分支代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在测试场1中，有联调服务A-branch1和B-branch1，没有其他服务。B-branch1调用C转回稳定环境调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在测试场2中，有联调服务A-branch2和B-branch2，没有其他服务。B-branch2调用C转回稳定环境调用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.消息调用流程&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4306883365200765&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/aCASXoK2nU7XeVps4BhBae19HqpAEbDAAYrgYRom3gNM9Uhv4S1iax5YRsxPPq4ttabMgybBibwJuDhPELLC5DMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2092&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测试场中提供一套稳定环境，该环境部署了master分支代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务B发送消息到melon_topic，被服务C的消费组melon_consumer订阅，以及被另一个服务APP-X的消费组melon_appx_consumer订阅&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在测试场1中，有联调服务B-branch1和C-branch1，没有其他服务，B-branch1发的消息被C-branch1消费&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在测试场1中，通过不同主题abcd1_melon_topic和不同消费组abcd1_melon_consumer实现发送和消费流量隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在测试场2中，有联调服务B-branch2和C-branch2，没有其他服务，B-branch2发的消息被C-branch2消费&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在测试场2中，通过不同主题abcd2_melon_topic和不同消费组abcd2_melon_consumer实现发送和消费流量隔离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在稳定环境中，APP-X的消费组melon_appx_consumer没有在测试场联调，需消费melon_topic、abcd1_melon_topic以及abcd2_melon_topic三个主题的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在稳定环境中，当测试场中部署了C-branch1和C-branch2时，稳定环境服务C的消费组melon_consumer，只消费melon_topic的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在稳定环境中，当测试场中只部署了C-branch1，而没有C-branch2时，稳定环境服务C的消费组melon_consumer，需消费melon_topic、abcd2_melon_topic两个主题的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在稳定环境中，当测试场中只部署了C-branch2，而没有C-branch1时，稳定环境服务C的消费组melon_consumer，需消费melon_topic、abcd1_melon_topic两个的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在稳定环境中，当测试场中没有部署了C-branch1和C-branch2时，稳定环境服务C的消费组melon_consumer，需消费melon_topic、abcd1_melon_topic、abcd2_melon_topic三个主题的消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section data-custom=&quot;#138bde&quot; data-id=&quot;86122&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;四、中间件在测试场中的实现&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试场多环境逻辑隔离主要依赖基础组件提供的能力支持，主要涉及标记链路透传、RPC框架节点打标和选择、消息的流量隔离以及网关和分布式调度的标记透传。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.链路标记透传&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链路透传在众多方案中都是必备的，比如：全链路压测、链路tracing，可参考下面两种实现方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;OpenTracing Baggage&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;transmittable-thread-local&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;备注：通过中间件提供公共组件完成链路标记向下透传。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.RPC框架节点打标和选择&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试场中需要对节点打标，再根据上下文透传的标记选出打标节点发起调用，具体RPC框架能力为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;节点打标，比如：对1.2.3.4节点打上测试场的标【abcd】&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点选择，比如：根据链路透传过来的标记【abcd】选择对应的打标节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认节点，如果没有打标节点，需要选择默认节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;链路透传，选择了节点发起RPC调用，继续透传测试场标记【abcd】&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.消息的流量隔离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于消息来说，需要对不同的测试场流量进行隔离，如上第三部分测试场调用流程中的消息调用，场景也比较多，消息的方案复杂的多。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;流量隔离，通过不同的主题和消费组完成测试场流量的隔离&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消息发送侧，如果链路中有测试场标记，则动态拼接隔离主题，将该流量发送到隔离主题，例如：abcd_melon_topic。同时在元数据中心记录【发送侧测试场标记】&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消息消费侧，如果该消费组被拉入测试场，通过隔离消费组订阅隔离主题，实现消费流量隔离，例如：abcd_melon_consumer订阅abcd_melon_topic。同时在元数据中心记录【消费侧测试场标记】&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;稳定环境的消费组，需要监听【发送侧测试场标记】和【消费侧测试场标记】的变化，实现动态接管测试场的流量或者剔除测试场流量，例如：稳定环境消费组melon_consumer除了订阅melon_topic外，是否订阅abcd_melon_topic；取决于测试场中是否有abcd_melon_consumer&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;在实践中可以在RocketMQ/Kafka集群开启自动创建主题和消费组权限，并在新的集群自动创建的主题和消费组与原集群分离，方便清理。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.其他组件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试场的流量隔离主要在RPC框架和消息队列实现，网关和分布式调度等主要参与标记透传。另外，数据可以通过构造偏移数据来规避数据的不一致，降低数据库实现逻辑隔离的复杂性。&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;最&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2943&quot;&gt;最&lt;/span&gt;&lt;span data-raw-text=&quot;后&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2944&quot;&gt;后&lt;/span&gt;&lt;span data-raw-text=&quot;说&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2945&quot;&gt;说&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2946&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;句&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2947&quot;&gt;句&lt;/span&gt;&lt;span data-raw-text=&quot;(&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2948&quot;&gt;(&lt;/span&gt;&lt;span data-raw-text=&quot;求&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2949&quot;&gt;求&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2950&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2951&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2952&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;别&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2953&quot;&gt;别&lt;/span&gt;&lt;span data-raw-text=&quot;白&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2954&quot;&gt;白&lt;/span&gt;&lt;span data-raw-text=&quot;嫖&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2955&quot;&gt;嫖&lt;/span&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2956&quot;&gt;我&lt;/span&gt;&lt;span data-raw-text=&quot;)&quot; data-textnode-index-1641215183112=&quot;112&quot; data-index-1641215183112=&quot;2957&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span data-raw-text=&quot;如&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2958&quot;&gt;如&lt;/span&gt;&lt;span data-raw-text=&quot;果&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2959&quot;&gt;果&lt;/span&gt;&lt;span data-raw-text=&quot;这&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2960&quot;&gt;这&lt;/span&gt;&lt;span data-raw-text=&quot;篇&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2961&quot;&gt;篇&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2962&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2963&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;对&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2964&quot;&gt;对&lt;/span&gt;&lt;span data-raw-text=&quot;您&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2965&quot;&gt;您&lt;/span&gt;&lt;span data-raw-text=&quot;有&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2966&quot;&gt;有&lt;/span&gt;&lt;span data-raw-text=&quot;所&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2967&quot;&gt;所&lt;/span&gt;&lt;span data-raw-text=&quot;帮&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2968&quot;&gt;帮&lt;/span&gt;&lt;span data-raw-text=&quot;助&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2969&quot;&gt;助&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2970&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;或&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2971&quot;&gt;或&lt;/span&gt;&lt;span data-raw-text=&quot;者&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2972&quot;&gt;者&lt;/span&gt;&lt;span data-raw-text=&quot;有&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2973&quot;&gt;有&lt;/span&gt;&lt;span data-raw-text=&quot;所&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2974&quot;&gt;所&lt;/span&gt;&lt;span data-raw-text=&quot;启&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2975&quot;&gt;启&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2976&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2977&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;话&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2978&quot;&gt;话&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2979&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;帮&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2980&quot;&gt;帮&lt;/span&gt;&lt;span data-raw-text=&quot;忙&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2981&quot;&gt;忙&lt;/span&gt;&lt;span data-raw-text=&quot;扫&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2982&quot;&gt;扫&lt;/span&gt;&lt;span data-raw-text=&quot;描&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2983&quot;&gt;描&lt;/span&gt;&lt;span data-raw-text=&quot;下&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2984&quot;&gt;下&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2985&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2986&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2987&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2988&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2989&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2990&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2991&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;下&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2992&quot;&gt;下&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2993&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;您&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2994&quot;&gt;您&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2995&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;支&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2996&quot;&gt;支&lt;/span&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2997&quot;&gt;持&lt;/span&gt;&lt;span data-raw-text=&quot;是&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2998&quot;&gt;是&lt;/span&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;2999&quot;&gt;我&lt;/span&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3000&quot;&gt;坚&lt;/span&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3001&quot;&gt;持&lt;/span&gt;&lt;span data-raw-text=&quot;写&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3002&quot;&gt;写&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3003&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;最&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3004&quot;&gt;最&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3005&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3006&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;动&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3007&quot;&gt;动&lt;/span&gt;&lt;span data-raw-text=&quot;力&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3008&quot;&gt;力&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index-1641215183112=&quot;113&quot; data-index-1641215183112=&quot;3009&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span data-raw-text=&quot;求&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3010&quot;&gt;求&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3011&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;键&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3012&quot;&gt;键&lt;/span&gt;&lt;span data-raw-text=&quot;三&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3013&quot;&gt;三&lt;/span&gt;&lt;span data-raw-text=&quot;连&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3014&quot;&gt;连&lt;/span&gt;&lt;span data-raw-text=&quot;：&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3015&quot;&gt;：&lt;/span&gt;&lt;span data-raw-text=&quot;点&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3016&quot;&gt;点&lt;/span&gt;&lt;span data-raw-text=&quot;赞&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3017&quot;&gt;赞&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3018&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;转&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3019&quot;&gt;转&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3020&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;、&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3021&quot;&gt;、&lt;/span&gt;&lt;span data-raw-text=&quot;在&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3022&quot;&gt;在&lt;/span&gt;&lt;span data-raw-text=&quot;看&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3023&quot;&gt;看&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3024&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIzNzgyMjYxOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvs5UnzjhzrS6h29QXbfK4I0GLibNP4Qlpt1ovSdmwfsoY7D4JYUZzkACtqe3wrKh6icG7oHUTMibJbA/0?wx_fmt=png&quot; data-nickname=&quot;中间件兴趣圈&quot; data-alias=&quot;dingwpmz_zjj&quot; data-signature=&quot;《RocketMQ技术内幕》作者维护，主打成体系剖析JAVA主流中间件架构与设计原理，为构建完备的互联网分布式架构体系而努力，助力突破职场瓶颈。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3025&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3026&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;公&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3027&quot;&gt;公&lt;/span&gt;&lt;span data-raw-text=&quot;众&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3028&quot;&gt;众&lt;/span&gt;&lt;span data-raw-text=&quot;号&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3029&quot;&gt;号&lt;/span&gt;&lt;span data-raw-text=&quot;：&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3030&quot;&gt;：&lt;/span&gt;&lt;span data-raw-text=&quot;「&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3031&quot;&gt;「&lt;/span&gt;&lt;span data-raw-text=&quot;中&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3032&quot;&gt;中&lt;/span&gt;&lt;span data-raw-text=&quot;间&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3033&quot;&gt;间&lt;/span&gt;&lt;span data-raw-text=&quot;件&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3034&quot;&gt;件&lt;/span&gt;&lt;span data-raw-text=&quot;兴&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3035&quot;&gt;兴&lt;/span&gt;&lt;span data-raw-text=&quot;趣&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3036&quot;&gt;趣&lt;/span&gt;&lt;span data-raw-text=&quot;圈&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3037&quot;&gt;圈&lt;/span&gt;&lt;span data-raw-text=&quot;」&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3038&quot;&gt;」&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3039&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;在&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3040&quot;&gt;在&lt;/span&gt;&lt;span data-raw-text=&quot;公&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3041&quot;&gt;公&lt;/span&gt;&lt;span data-raw-text=&quot;众&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3042&quot;&gt;众&lt;/span&gt;&lt;span data-raw-text=&quot;号&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3043&quot;&gt;号&lt;/span&gt;&lt;span data-raw-text=&quot;中&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3044&quot;&gt;中&lt;/span&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3045&quot;&gt;回&lt;/span&gt;&lt;span data-raw-text=&quot;复&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3046&quot;&gt;复&lt;/span&gt;&lt;span data-raw-text=&quot;：&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3047&quot;&gt;：&lt;/span&gt;&lt;span data-raw-text=&quot;「&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3048&quot;&gt;「&lt;/span&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3049&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;D&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3050&quot;&gt;D&lt;/span&gt;&lt;span data-raw-text=&quot;F&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3051&quot;&gt;F&lt;/span&gt;&lt;span data-raw-text=&quot;」&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3052&quot;&gt;」&lt;/span&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3053&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;获&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3054&quot;&gt;获&lt;/span&gt;&lt;span data-raw-text=&quot;取&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3055&quot;&gt;取&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3056&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;量&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3057&quot;&gt;量&lt;/span&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3058&quot;&gt;学&lt;/span&gt;&lt;span data-raw-text=&quot;习&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3059&quot;&gt;习&lt;/span&gt;&lt;span data-raw-text=&quot;资&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3060&quot;&gt;资&lt;/span&gt;&lt;span data-raw-text=&quot;料&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3061&quot;&gt;料&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3062&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3063&quot;&gt;回&lt;/span&gt;&lt;span data-raw-text=&quot;复&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3064&quot;&gt;复&lt;/span&gt;&lt;span data-raw-text=&quot;「&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3065&quot;&gt;「&lt;/span&gt;&lt;span data-raw-text=&quot;专&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3066&quot;&gt;专&lt;/span&gt;&lt;span data-raw-text=&quot;栏&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3067&quot;&gt;栏&lt;/span&gt;&lt;span data-raw-text=&quot;」&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3068&quot;&gt;」&lt;/span&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3069&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;获&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3070&quot;&gt;获&lt;/span&gt;&lt;span data-raw-text=&quot;取&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3071&quot;&gt;取&lt;/span&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3072&quot;&gt;1&lt;/span&gt;&lt;span data-raw-text=&quot;5&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3073&quot;&gt;5&lt;/span&gt;&lt;span data-raw-text=&quot;个&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3074&quot;&gt;个&lt;/span&gt;&lt;span data-raw-text=&quot;主&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3075&quot;&gt;主&lt;/span&gt;&lt;span data-raw-text=&quot;流&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3076&quot;&gt;流&lt;/span&gt;&lt;span data-raw-text=&quot;J&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3077&quot;&gt;J&lt;/span&gt;&lt;span data-raw-text=&quot;a&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3078&quot;&gt;a&lt;/span&gt;&lt;span data-raw-text=&quot;v&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3079&quot;&gt;v&lt;/span&gt;&lt;span data-raw-text=&quot;a&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3080&quot;&gt;a&lt;/span&gt;&lt;span data-raw-text=&quot;中&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3081&quot;&gt;中&lt;/span&gt;&lt;span data-raw-text=&quot;间&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3082&quot;&gt;间&lt;/span&gt;&lt;span data-raw-text=&quot;件&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3083&quot;&gt;件&lt;/span&gt;&lt;span data-raw-text=&quot;源&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3084&quot;&gt;源&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3085&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;分&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3086&quot;&gt;分&lt;/span&gt;&lt;span data-raw-text=&quot;析&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3087&quot;&gt;析&lt;/span&gt;&lt;span data-raw-text=&quot;专&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3088&quot;&gt;专&lt;/span&gt;&lt;span data-raw-text=&quot;栏&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3089&quot;&gt;栏&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3090&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;另&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3091&quot;&gt;另&lt;/span&gt;&lt;span data-raw-text=&quot;外&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3092&quot;&gt;外&lt;/span&gt;&lt;span data-raw-text=&quot;回&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3093&quot;&gt;回&lt;/span&gt;&lt;span data-raw-text=&quot;复&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3094&quot;&gt;复&lt;/span&gt;&lt;span data-raw-text=&quot;：&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3095&quot;&gt;：&lt;/span&gt;&lt;span data-raw-text=&quot;加&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3096&quot;&gt;加&lt;/span&gt;&lt;span data-raw-text=&quot;群&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3097&quot;&gt;群&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3098&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3099&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;以&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3100&quot;&gt;以&lt;/span&gt;&lt;span data-raw-text=&quot;跟&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3101&quot;&gt;跟&lt;/span&gt;&lt;span data-raw-text=&quot;很&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3102&quot;&gt;很&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3103&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;B&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3104&quot;&gt;B&lt;/span&gt;&lt;span data-raw-text=&quot;A&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3105&quot;&gt;A&lt;/span&gt;&lt;span data-raw-text=&quot;T&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3106&quot;&gt;T&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3107&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3108&quot;&gt;厂&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3109&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;前&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3110&quot;&gt;前&lt;/span&gt;&lt;span data-raw-text=&quot;辈&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3111&quot;&gt;辈&lt;/span&gt;&lt;span data-raw-text=&quot;交&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3112&quot;&gt;交&lt;/span&gt;&lt;span data-raw-text=&quot;流&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3113&quot;&gt;流&lt;/span&gt;&lt;span data-raw-text=&quot;和&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3114&quot;&gt;和&lt;/span&gt;&lt;span data-raw-text=&quot;学&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3115&quot;&gt;学&lt;/span&gt;&lt;span data-raw-text=&quot;习&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3116&quot;&gt;习&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3117&quot;&gt;。&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index-1641215183112=&quot;114&quot; data-index-1641215183112=&quot;3024&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index-1641215183112=&quot;115&quot; data-index-1641215183112=&quot;3117&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-style=&quot;white-space: normal; background-color: rgb(255, 255, 255); color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 16px;&quot; class=&quot;js_darkmode__155&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93589&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;走&quot; data-textnode-index-1641215183112=&quot;116&quot; data-index-1641215183112=&quot;3118&quot;&gt;走&lt;/span&gt;&lt;span data-raw-text=&quot;进&quot; data-textnode-index-1641215183112=&quot;116&quot; data-index-1641215183112=&quot;3119&quot;&gt;进&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index-1641215183112=&quot;116&quot; data-index-1641215183112=&quot;3120&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;者&quot; data-textnode-index-1641215183112=&quot;116&quot; data-index-1641215183112=&quot;3121&quot;&gt;者&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzgyMjYxOQ==&amp;amp;mid=2247484618&amp;amp;idx=1&amp;amp;sn=e24d7d19006f0d66e697e8d2be4aa508&amp;amp;chksm=e8c3f33edfb47a286f4515c4b11e822c35eab9b6c7ada25ac2cce3d2f7e5dac0230b54c56646&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6831&quot;&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index-1641215183112=&quot;117&quot; data-index-1641215183112=&quot;3122&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6832&quot;&gt;&lt;span data-raw-text=&quot;0&quot; data-textnode-index-1641215183112=&quot;118&quot; data-index-1641215183112=&quot;3123&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;年&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6833&quot;&gt;&lt;span data-raw-text=&quot;年&quot; data-textnode-index-1641215183112=&quot;119&quot; data-index-1641215183112=&quot;3124&quot;&gt;年&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;I&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6834&quot;&gt;&lt;span data-raw-text=&quot;I&quot; data-textnode-index-1641215183112=&quot;120&quot; data-index-1641215183112=&quot;3125&quot;&gt;I&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;T&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6835&quot;&gt;&lt;span data-raw-text=&quot;T&quot; data-textnode-index-1641215183112=&quot;121&quot; data-index-1641215183112=&quot;3126&quot;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;老&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6836&quot;&gt;&lt;span data-raw-text=&quot;老&quot; data-textnode-index-1641215183112=&quot;122&quot; data-index-1641215183112=&quot;3127&quot;&gt;老&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;兵&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6837&quot;&gt;&lt;span data-raw-text=&quot;兵&quot; data-textnode-index-1641215183112=&quot;123&quot; data-index-1641215183112=&quot;3128&quot;&gt;兵&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;给&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6838&quot;&gt;&lt;span data-raw-text=&quot;给&quot; data-textnode-index-1641215183112=&quot;124&quot; data-index-1641215183112=&quot;3129&quot;&gt;给&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;职&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6839&quot;&gt;&lt;span data-raw-text=&quot;职&quot; data-textnode-index-1641215183112=&quot;125&quot; data-index-1641215183112=&quot;3130&quot;&gt;职&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;场&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6840&quot;&gt;&lt;span data-raw-text=&quot;场&quot; data-textnode-index-1641215183112=&quot;126&quot; data-index-1641215183112=&quot;3131&quot;&gt;场&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;新&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6841&quot;&gt;&lt;span data-raw-text=&quot;新&quot; data-textnode-index-1641215183112=&quot;127&quot; data-index-1641215183112=&quot;3132&quot;&gt;新&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;人&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6842&quot;&gt;&lt;span data-raw-text=&quot;人&quot; data-textnode-index-1641215183112=&quot;128&quot; data-index-1641215183112=&quot;3133&quot;&gt;人&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6843&quot;&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index-1641215183112=&quot;129&quot; data-index-1641215183112=&quot;3134&quot;&gt;的&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6844&quot;&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index-1641215183112=&quot;130&quot; data-index-1641215183112=&quot;3135&quot;&gt;一&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;些&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6845&quot;&gt;&lt;span data-raw-text=&quot;些&quot; data-textnode-index-1641215183112=&quot;131&quot; data-index-1641215183112=&quot;3136&quot;&gt;些&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;建&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6846&quot;&gt;&lt;span data-raw-text=&quot;建&quot; data-textnode-index-1641215183112=&quot;132&quot; data-index-1641215183112=&quot;3137&quot;&gt;建&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;议&quot; data-textnode-index=&quot;489&quot; data-index=&quot;6847&quot;&gt;&lt;span data-raw-text=&quot;议&quot; data-textnode-index-1641215183112=&quot;133&quot; data-index-1641215183112=&quot;3138&quot;&gt;议&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzgyMjYxOQ==&amp;amp;mid=2247486100&amp;amp;idx=1&amp;amp;sn=3166338465f9b4a47ad93ecf13df6e48&amp;amp;chksm=e8c3fd60dfb47476e0c3ff65673eee47a5b99c7455f70252d08d6d0330828ea9050b27526a7d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;“&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3139&quot;&gt;“&lt;/span&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3140&quot;&gt;我&lt;/span&gt;&lt;span data-raw-text=&quot;”&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3141&quot;&gt;”&lt;/span&gt;&lt;span data-raw-text=&quot;被&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3142&quot;&gt;被&lt;/span&gt;&lt;span data-raw-text=&quot;阿&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3143&quot;&gt;阿&lt;/span&gt;&lt;span data-raw-text=&quot;里&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3144&quot;&gt;里&lt;/span&gt;&lt;span data-raw-text=&quot;巴&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3145&quot;&gt;巴&lt;/span&gt;&lt;span data-raw-text=&quot;巴&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3146&quot;&gt;巴&lt;/span&gt;&lt;span data-raw-text=&quot;宠&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3147&quot;&gt;宠&lt;/span&gt;&lt;span data-raw-text=&quot;幸&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3148&quot;&gt;幸&lt;/span&gt;&lt;span data-raw-text=&quot;了&quot; data-textnode-index-1641215183112=&quot;134&quot; data-index-1641215183112=&quot;3149&quot;&gt;了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzgyMjYxOQ==&amp;amp;mid=2247485407&amp;amp;idx=1&amp;amp;sn=0e0de515b3a66ac91e55fdf583be5c0d&amp;amp;chksm=e8c3f02bdfb4793daecebbead9c5cdf6e64da25b80f2fd3f2bcfcc52a6c3a57b2414298bd0b5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;程&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6848&quot;&gt;&lt;span data-raw-text=&quot;程&quot; data-textnode-index-1641215183112=&quot;135&quot; data-index-1641215183112=&quot;3150&quot;&gt;程&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;序&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6849&quot;&gt;&lt;span data-raw-text=&quot;序&quot; data-textnode-index-1641215183112=&quot;136&quot; data-index-1641215183112=&quot;3151&quot;&gt;序&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;员&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6850&quot;&gt;&lt;span data-raw-text=&quot;员&quot; data-textnode-index-1641215183112=&quot;137&quot; data-index-1641215183112=&quot;3152&quot;&gt;员&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;如&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6851&quot;&gt;&lt;span data-raw-text=&quot;如&quot; data-textnode-index-1641215183112=&quot;138&quot; data-index-1641215183112=&quot;3153&quot;&gt;如&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;何&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6852&quot;&gt;&lt;span data-raw-text=&quot;何&quot; data-textnode-index-1641215183112=&quot;139&quot; data-index-1641215183112=&quot;3154&quot;&gt;何&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;提&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6853&quot;&gt;&lt;span data-raw-text=&quot;提&quot; data-textnode-index-1641215183112=&quot;140&quot; data-index-1641215183112=&quot;3155&quot;&gt;提&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;高&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6854&quot;&gt;&lt;span data-raw-text=&quot;高&quot; data-textnode-index-1641215183112=&quot;141&quot; data-index-1641215183112=&quot;3156&quot;&gt;高&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;影&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6855&quot;&gt;&lt;span data-raw-text=&quot;影&quot; data-textnode-index-1641215183112=&quot;142&quot; data-index-1641215183112=&quot;3157&quot;&gt;影&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;响&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6856&quot;&gt;&lt;span data-raw-text=&quot;响&quot; data-textnode-index-1641215183112=&quot;143&quot; data-index-1641215183112=&quot;3158&quot;&gt;响&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;力&quot; data-textnode-index=&quot;490&quot; data-index=&quot;6857&quot;&gt;&lt;span data-raw-text=&quot;力&quot; data-textnode-index-1641215183112=&quot;144&quot; data-index-1641215183112=&quot;3159&quot;&gt;力&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzgyMjYxOQ==&amp;amp;mid=2247485573&amp;amp;idx=1&amp;amp;sn=4d936fa700b38b5158316bdaf1aeac68&amp;amp;chksm=e8c3ff71dfb476675613afe09c682bc5fbd454b35f8d3d6d0458360149d5f0d673965c8852c4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;优&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3160&quot;&gt;优&lt;/span&gt;&lt;span data-raw-text=&quot;秀&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3161&quot;&gt;秀&lt;/span&gt;&lt;span data-raw-text=&quot;程&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3162&quot;&gt;程&lt;/span&gt;&lt;span data-raw-text=&quot;序&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3163&quot;&gt;序&lt;/span&gt;&lt;span data-raw-text=&quot;员&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3164&quot;&gt;员&lt;/span&gt;&lt;span data-raw-text=&quot;必&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3165&quot;&gt;必&lt;/span&gt;&lt;span data-raw-text=&quot;备&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3166&quot;&gt;备&lt;/span&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3167&quot;&gt;技&lt;/span&gt;&lt;span data-raw-text=&quot;能&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3168&quot;&gt;能&lt;/span&gt;&lt;span data-raw-text=&quot;之&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3169&quot;&gt;之&lt;/span&gt;&lt;span data-raw-text=&quot;如&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3170&quot;&gt;如&lt;/span&gt;&lt;span data-raw-text=&quot;何&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3171&quot;&gt;何&lt;/span&gt;&lt;span data-raw-text=&quot;高&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3172&quot;&gt;高&lt;/span&gt;&lt;span data-raw-text=&quot;效&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3173&quot;&gt;效&lt;/span&gt;&lt;span data-raw-text=&quot;阅&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3174&quot;&gt;阅&lt;/span&gt;&lt;span data-raw-text=&quot;读&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3175&quot;&gt;读&lt;/span&gt;&lt;span data-raw-text=&quot;源&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3176&quot;&gt;源&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index-1641215183112=&quot;145&quot; data-index-1641215183112=&quot;3177&quot;&gt;码&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzgyMjYxOQ==&amp;amp;mid=2247484822&amp;amp;idx=1&amp;amp;sn=ecaada01b1bcf73b3a9fb750872b8e9d&amp;amp;chksm=e8c3f262dfb47b74d6f03be903dc734953e83ee720ac5b98e7ffcd92da39df5d68308b26bf85&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;我&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3178&quot;&gt;我&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3179&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;另&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3180&quot;&gt;另&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3181&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;种&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3182&quot;&gt;种&lt;/span&gt;&lt;span data-raw-text=&quot;参&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3183&quot;&gt;参&lt;/span&gt;&lt;span data-raw-text=&quot;与&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3184&quot;&gt;与&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3185&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;R&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3186&quot;&gt;R&lt;/span&gt;&lt;span data-raw-text=&quot;o&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3187&quot;&gt;o&lt;/span&gt;&lt;span data-raw-text=&quot;c&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3188&quot;&gt;c&lt;/span&gt;&lt;span data-raw-text=&quot;k&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3189&quot;&gt;k&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3190&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;t&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3191&quot;&gt;t&lt;/span&gt;&lt;span data-raw-text=&quot;M&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3192&quot;&gt;M&lt;/span&gt;&lt;span data-raw-text=&quot;Q&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3193&quot;&gt;Q&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3194&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;开&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3195&quot;&gt;开&lt;/span&gt;&lt;span data-raw-text=&quot;源&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3196&quot;&gt;源&lt;/span&gt;&lt;span data-raw-text=&quot;社&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3197&quot;&gt;社&lt;/span&gt;&lt;span data-raw-text=&quot;区&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3198&quot;&gt;区&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3199&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;方&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3200&quot;&gt;方&lt;/span&gt;&lt;span data-raw-text=&quot;式&quot; data-textnode-index-1641215183112=&quot;146&quot; data-index-1641215183112=&quot;3201&quot;&gt;式&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-raw-text=&quot;点&quot; data-textnode-index-1641215183112=&quot;147&quot; data-index-1641215183112=&quot;3202&quot;&gt;点&lt;/span&gt;&lt;span data-raw-text=&quot;击&quot; data-textnode-index-1641215183112=&quot;147&quot; data-index-1641215183112=&quot;3203&quot;&gt;击&lt;/span&gt;&lt;span data-raw-text=&quot;查&quot; data-textnode-index-1641215183112=&quot;147&quot; data-index-1641215183112=&quot;3204&quot;&gt;查&lt;/span&gt;&lt;span data-raw-text=&quot;看&quot; data-textnode-index-1641215183112=&quot;147&quot; data-index-1641215183112=&quot;3205&quot;&gt;看&lt;/span&gt;&lt;span data-raw-text=&quot;“&quot; data-textnode-index-1641215183112=&quot;147&quot; data-index-1641215183112=&quot;3206&quot;&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;阅&quot; data-textnode-index-1641215183112=&quot;148&quot; data-index-1641215183112=&quot;3207&quot;&gt;阅&lt;/span&gt;&lt;span data-raw-text=&quot;读&quot; data-textnode-index-1641215183112=&quot;148&quot; data-index-1641215183112=&quot;3208&quot;&gt;读&lt;/span&gt;&lt;span data-raw-text=&quot;原&quot; data-textnode-index-1641215183112=&quot;148&quot; data-index-1641215183112=&quot;3209&quot;&gt;原&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1641215183112=&quot;148&quot; data-index-1641215183112=&quot;3210&quot;&gt;文&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;”&quot; data-textnode-index-1641215183112=&quot;149&quot; data-index-1641215183112=&quot;3211&quot;&gt;”&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index-1641215183112=&quot;149&quot; data-index-1641215183112=&quot;3212&quot;&gt;，&lt;/span&gt;&lt;strong&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3213&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;直&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3214&quot;&gt;直&lt;/span&gt;&lt;span data-raw-text=&quot;接&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3215&quot;&gt;接&lt;/span&gt;&lt;span data-raw-text=&quot;进&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3216&quot;&gt;进&lt;/span&gt;&lt;span data-raw-text=&quot;入&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3217&quot;&gt;入&lt;/span&gt;&lt;span data-raw-text=&quot;[&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3218&quot;&gt;[&lt;/span&gt;&lt;span data-raw-text=&quot;中&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3219&quot;&gt;中&lt;/span&gt;&lt;span data-raw-text=&quot;间&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3220&quot;&gt;间&lt;/span&gt;&lt;span data-raw-text=&quot;件&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3221&quot;&gt;件&lt;/span&gt;&lt;span data-raw-text=&quot;兴&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3222&quot;&gt;兴&lt;/span&gt;&lt;span data-raw-text=&quot;趣&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3223&quot;&gt;趣&lt;/span&gt;&lt;span data-raw-text=&quot;圈&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3224&quot;&gt;圈&lt;/span&gt;&lt;span data-raw-text=&quot;]&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3225&quot;&gt;]&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3226&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3227&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;合&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3228&quot;&gt;合&lt;/span&gt;&lt;span data-raw-text=&quot;集&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3229&quot;&gt;集&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index-1641215183112=&quot;150&quot; data-index-1641215183112=&quot;3230&quot;&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>89201b6eae8d96e209adc743dd43fe3e</guid>
<title>基于 Apache Hudi 构建增量和无限回放事件流的 OLAP 平台</title>
<link>https://toutiao.io/k/dgr4ybi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.56796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brR21T72gFrmTKhyiaiaqic375VKib6NwQ8MrmrqW22LOCzpP13VTklzxJRgoM7TVejUic6ial590tbDF8TB1AdNmzgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;1. 摘要&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;在本博客中，我们将讨论在构建流数据平台时如何利用 Hudi 的两个最令人难以置信的能力。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 增量消费--每 30 分钟处理一次数据，并在我们的组织内构建每小时级别的OLAP平台&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 事件流的无限回放--利用 Hudi 的提交时间线在超级便宜的云对象存储（如 AWS S3）中存储 10 天的事件流（想象一个具有 10 天保留期的 kafka 主题）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 具有部分记录更新的自定义 Hudi Payload 类&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2. 当前状态&lt;/h2&gt;&lt;h3&gt;2.1 问题说明&lt;/h3&gt;&lt;p&gt;对于大多数业务需要手动干预以通过查看 KPI 和数据趋势来决定下一组操作用例以及其他不太实时的用例，我们需要具有成本效益和高性能的近实时系统。&lt;/p&gt;&lt;p&gt;但是我们在数据湖中获得的数据通常以 D -1 的每日批处理粒度出现，即使我们每天不止一次地运行这些日常批处理数据处理系统以获取当前 D 的最新数据，这些批处理系统的固有局限性也无助于我们解决近实时业务用例。&lt;/p&gt;&lt;h3&gt;2.2 挑战&lt;/h3&gt;&lt;p&gt;在将批处理数据摄取到我们的数据湖时，我们支持 S3 的数据集在每日更新日期分区上进行分区。即使我们每天多次运行这些批处理系统，我们从上游 Kafka 或 RDBMS 应用程序数据库中提取的最新批处理也会附加到 S3 数据集中当前日期的分区中。&lt;/p&gt;&lt;p&gt;当下游系统想要从我们的 S3 数据集中获取这些最新记录时，它需要重新处理当天的所有记录，因为下游进程无法在不扫描整个数据分区的情况下从增量记录中找出已处理的记录。&lt;/p&gt;&lt;p&gt;此外如果我们按小时（而不是每日分区）对 S3 数据集进行分区，那么这会将分区粒度设置为每小时间隔。任何试图以低于一小时（例如最后 x 分钟）的粒度获取最新更新的下游作业都必须在每次运行时再次重新处理每小时数据分区，即这些批处理源将错过解决近实时用例所需的关键增量数据消费。&lt;/p&gt;&lt;h3&gt;2.3 无限播放事件流&lt;/h3&gt;&lt;p&gt;现在回到帮助我们解决这些挑战的 Apache Hudi 的特性，让我们首先尝试了解commit（提交）和commit timeline（提交时间线）如何影响增量消费和事件流保留/回放。&lt;/p&gt;&lt;p&gt;Hudi 维护了在不同时刻在表上执行的所有操作的时间表，这些commit（提交）包含有关作为 upsert 的一部分插入或重写的部分文件的信息，我们称之为 Hudi 的提交时间线。&lt;/p&gt;&lt;p&gt;对于每个 Hudi 表，我们可以选择指定要保留多少历史提交，要保留的默认提交是 10 次，即在 10 次提交之后，第 11 次提交将另外运行一个清理服务，该服务将清除第一次提交历史记录。&lt;/p&gt;&lt;p&gt;清理commit（提交）时，清理程序会清理与该提交对应的部分文件的过时版本，相关数据被保留，因为过时的文件中的所有数据无论如何都存在于新版本的文件中，这里重要的是我们可以触发快照查询来获取数据的最新状态，但我们将无法对已清理的提交运行增量查询来获取增量数据。&lt;/p&gt;&lt;p&gt;简而言之，如果清除了commit（提交），我们就失去了从该commit（提交）回放事件流的能力，但是我们仍然可以从任何尚未清理的commit（提交）中回放事件流。&lt;/p&gt;&lt;p&gt;在我们的例子中，我们将 Hudi 表配置为保留 10K 提交，从而为我们提供 10 天的增量读取能力（类似于保留 10 天的 kafka 主题） 我们保留的历史提交数量越多，我们就越有能力及时返回并重放事件流。&lt;/p&gt;&lt;h2&gt;3. 每小时 OLAP&lt;/h2&gt;&lt;p&gt;让我快速展示一下我们的端到端消息 OLAP 计算管道与 10 天事件流的架构&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.127591706539075&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/brR21T72gFrmTKhyiaiaqic375VKib6NwQ8MyB0SiaFIMMlfCqicBBJVEFCqsKj0q9Vibc9gE43zjPlSL277NIpY5dBFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;627&quot;/&gt;&lt;/p&gt;&lt;p&gt;在 kafka 层，我们的 kafka 输入源每个都有 1 天的主题保留期。&lt;/p&gt;&lt;p&gt;在摄取层，我们有 Spark 结构化流作业，从 kafka 源读取数据并将微批处理写入 S3 支持的 Hudi 表。这是我们配置为保持 10k 提交以启用 10 天事件流播放的地方。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.option(&lt;span&gt;&quot;hoodie.cleaner.commits.retained&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;.option(&lt;span&gt;&quot;hoodie.keep.max.commits&quot;&lt;/span&gt;, &lt;span&gt;10002&lt;/span&gt;)&lt;br/&gt;.option(&lt;span&gt;&quot;hoodie.keep.min.commits&quot;&lt;/span&gt;, &lt;span&gt;10001&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;计算层由我们当前每 30 分钟运行一次的批处理 Spark 作业组成，并重新处理我们在过去 60 分钟内摄取到 Hudi 表中的所有事件。每小时 OLAP 作业读取两个跨国表和可选的 N 维表，并将它们全部连接起来以准备我们的 OLAP 增量DataFrame。&lt;/p&gt;&lt;p&gt;我们每 30 分钟处理一次 60 分钟的数据，以增强表连接的一致性。&lt;/p&gt;&lt;p&gt;有趣的是生产系统中通常不建议保留 1 天的 kafka 保留期，但是我们能够进行这种权衡以节省一些 SSD 和 Kafka 代理成本，因为无论如何我们都可以通过 S3 支持的 Hudi 表实现 10 天的事件流播放能力。&lt;/p&gt;&lt;h2&gt;4. 部分记录更新&lt;/h2&gt;&lt;p&gt;上面的管道显示了我们如何通过读取和合并两个增量上游数据源来创建每小时增量 OLAP。&lt;/p&gt;&lt;p&gt;然而这些增量数据处理有其自身的挑战。可能会发生在两个上游表中，对于主键，我们在其中一个数据源中获得更新，但在另一个数据源中没有，我们称之为不匹配的交易问题。&lt;/p&gt;&lt;p&gt;下面的插图试图帮助我们理解这一挑战，并看看我们实施的解决方案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1343283582089552&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/brR21T72gFrmTKhyiaiaqic375VKib6NwQ8McRuHBrPNjmhhAzj7KuQN0ZKYLYTUicSHAqu66OfSAfwAw0Eto18aJFg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;469&quot;/&gt;&lt;/p&gt;&lt;p&gt;在这里，表A和B都有一些对应的匹配事务和一些不匹配的事务。使用内部连接将简单地忽略不匹配的事务，这些事务可能永远不会流入我们的基础 OLAP。相反使用外连接会将不匹配的事务合并到我们的每小时增量数据加载中。但是使用外连接会将缺失的列值添加为 null，现在这些空值将需要单独处理。&lt;/p&gt;&lt;p&gt;在使用默认有效负载类将此每小时增量数据更新到基础 Hudi OLAP 时，它将简单地用我们准备的每小时增量数据中的新记录覆盖基础 Hudi OLAP 中的记录。但是通过这种方式，当我们用传入记录中的空列值覆盖现有记录时，我们将丢失现有记录中可能已经存在的信息。因此为了解决这个问题，我们提供了我们的自定义部分行更新有效负载类，同时将外部连接的每小时增量数据插入到基础 Hudi OLAP。有效负载类定义了控制我们在更新记录时如何合并新旧记录的函数。我们的自定义有效负载类比较存储和传入记录的所有列，并通过将一条记录中的空列与另一条记录中的非空列重叠来返回一条新记录。因此即使只有一个上游表得到了更新，我们的自定义有效负载类也会使用这个部分可用的新信息，它会返回包含部分更新信息的完全最新记录。由于存储和部分行更新记录的主键和分区键相同，因此 Hudi upsert 操作会自动更新旧记录，从而为我们提供基本 OLAP 的去重和一致视图。有关如何编写自己的有效负载类的&lt;span&gt;更多技术细节&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;5. 结语&lt;/h2&gt;&lt;p&gt;结合这三个概念，即增量消费、增量每小时 OLAP 处理和自定义部分行更新有效负载类，我们为我们的独角兽初创公司构建了一个强大的流处理平台，以使其一直扩展成为一个百角兽组织。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIyMzQ0NjA0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/brR21T72gFrSJYpz6hjcEOYH86LMkT7PhEydJe1NtcENI8CvRygysXmDjUnlzobK6f2OkrwWfOWkqwfRia4fmnw/0?wx_fmt=png&quot; data-nickname=&quot;ApacheHudi&quot; data-alias=&quot;ApacheHudi&quot; data-signature=&quot;Apache Hudi是一个支持插入、更新、删除的增量数据湖处理框架；可助力构建高效的企业级数据湖。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488591&amp;amp;idx=1&amp;amp;sn=9eddead1cb8bf1bf370178053527461c&amp;amp;chksm=e81f4139df68c82f8e8c04e0ab6afda5257cd180f2b573a9b7a9bf2cc377fc69852c1bb3bb6d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于Apache Hudi在Google云平台构建数据湖&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于Apache Hudi在Google云平台构建数据湖&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488582&amp;amp;idx=2&amp;amp;sn=6dd06826947b7193165028292b703c53&amp;amp;chksm=e81f4130df68c8260bca16d05f072fd8bea4624e3402b6af53f5cead630258dfa5f5d87be7f3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊一聊Hudi的原理（2）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊一聊Apache Hudi的原理（2）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488537&amp;amp;idx=1&amp;amp;sn=301df0833fc89991fb4699402f140c0a&amp;amp;chksm=e81f416fdf68c879ff96f7064d069f51a8dd56250b7f205e99bd79f42a19416307be646f62c7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;重磅！Apache Hudi联合传智教育推出免费中文视频教程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;重磅！Apache Hudi联合传智教育推出免费中文视频教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488377&amp;amp;idx=1&amp;amp;sn=eef38326fa6f419359dccb258b42618b&amp;amp;chksm=e81f460fdf68cf19527043ed7037d333b8be20a60244fae5d74d1093621f2c60f4b02220befa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Robinhood基于Apache Hudi的下一代数据湖实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Robinhood基于Apache Hudi的下一代数据湖实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzQ0NjA0MQ==&amp;amp;mid=2247488396&amp;amp;idx=2&amp;amp;sn=ef64253ef9d705feee2dabcd0e4819fb&amp;amp;chksm=e81f46fadf68cfec5da9d57a0371138cf82e235ebe55e4cba9e0fac67ce3f54280dc66962589&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Apache Hudi Bucket Index 在字节跳动的设计与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Apache Hudi Bucket Index 在字节跳动的设计与实践&lt;/a&gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 更多技术细节: &lt;em&gt;[https://hudi.apache.org/learn/faq/#can-i-implement-my-own-logic-for-how-input-records-are-merged-with-record-on-storage](https://hudi.apache.org/learn/faq/#can-i-implement-my-own-logic-for-how-input-records-are-merged-with-record-on-storage)&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>