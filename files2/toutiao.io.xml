<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b48dfeb6a4a9b1ae4e6bd6c5f9f7c319</guid>
<title>浙江移动数据中台的建设和应用实践</title>
<link>https://toutiao.io/k/vj95e1k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;最近在TD大数据论坛上我做了一次分享，题目是《浙江移动数据中台的建设和应用实践》，关于中台的文章现在网上很多了，文末我列了主流的数据中台的文章（包括我的），数据中台没有标准架构这种观点我也是认同的，因此，这里会结合片子重点谈谈我的实际感受，大多是超越数据中台本身的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9XCkKniaS5pfKMhR1FpicuOTBYAWibw7AZgDAuNHnEmpdAwLCHuictt7iaYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、为什么做数据的挑战特别巨大？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回顾自己做数据的15年，大多的结果并不乐观，有句话说得蛮有道理：&lt;/span&gt;&lt;span&gt;你要判断一个东西有没有可能继续被使用，就要看它已经被使用了多长时间。比如&lt;/span&gt;&lt;span&gt;我可以预测凳子在一千年内继续会为人所用，因为凳子已经存在了1000年以上了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个规律套用到自己，就有点残酷，回顾10年前自己做的模型、平台或产品，似乎都没有什么东西能留存下来，因此，现在去做数据中台，也是战战兢兢，&lt;span&gt;高大上的东西，在现实面前特别容易倒掉，&lt;/span&gt;&lt;span&gt;更别提数据工作本身的一些限制。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如&lt;span&gt;IT部门&lt;/span&gt;&lt;span&gt;是业务部门的后端&lt;/span&gt;，而数据部门是IT部门的后端，决定了数据工作者往往是后端的后端，因此要直接去创造价值是很难的，当然仅仅满足于报表取数另当别说，但相信有兴趣看我文章的人，都有着自己更高的追求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多数据界的老人对数据中台不屑一顾，认为纯粹是炒作，我很能理解，但如果以这个理由固步自封，那也有点不合时宜，本质不变不代表手段不需要改变，无论是在业务、技术还是数据层面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、数据中台从来不是一个新东西&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据中台的本质是什么，大家现在提的最多的词是业务化，服务化，后来我加了个开放化，内涵下面这页PPT讲的很清楚，业务化是在提醒你不要为了治理而治理，服务化在强调标准化和共享，开放化在讲酒香也怕巷子深。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;305&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9BJariavZWm3DtO5hE58TJIjdTmsNBjffqsACJc0e7MtX10pVRicPPBDg/0?wx_fmt=png&quot; data-ratio=&quot;0.5308441558441559&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9BJariavZWm3DtO5hE58TJIjdTmsNBjffqsACJc0e7MtX10pVRicPPBDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1232&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;你说这些是新概念吗，是阿里巴巴创造了数据中台吗？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;显然不是，阿里巴巴在数据中台上的很大贡献就是创造了一个“数据中台”的名词，降低了企业的沟通成本，让企业的领导意识到数据能发挥出更多的价值。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;应该来讲，数据中台涉及的东西，都是做数据做到一定程度后自然产生的结果，只要你希望让数据产生更多、更直接的价值，你就要演化出相应的功能，形成自己的数据中台。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实早在阿里巴巴以前，无论是网易、OPPO等等，大多数互联网公司其实早就有了自己的数据中台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如笔者进公司以来，凡是想提升业务支撑效率的工作全是数据中台的内容，无论是模型周期从月改为日，用可视化工具替代PL/DEV，用标签库实现客户群复用，用自助取数替代人工取数，都是如此。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在数据变现的第一天，老板就跟我们讲：一定要标准化，API化，否则数据变现是做不大的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3、运营商建设数据中台的时代背景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通信行业天生就是一个数字化程度比较好的行业，随着传统管道业务的红利到顶，技术变革不断驱动的产业升级，AICDE对运营商的价值创造方式、核心理念等提出了新的挑战，要求其加快数字化创新，拓展产业新的空间，如下页所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9NkJB4iatJU4M3l0sxFoMhH4ib1XFicFyIeCGo9dwPeIXuNia8NNgOL8QYw/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9NkJB4iatJU4M3l0sxFoMhH4ib1XFicFyIeCGo9dwPeIXuNia8NNgOL8QYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section class=&quot;page_image_error_loading js_loading&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;互联网企业对运营商业务的挤压是非常厉害的，但互联网的发展有一样对运营商是绝对有利的，那就是管道的线上内容会越来越丰富，线下的轨迹数据也在随着人民生活的提高变得更有价值，运营商这种天然的线上线下数据的&lt;span&gt;全面性、多维性、连续性、完整性&lt;/span&gt;等特点，使得其在新的时期有了一些新的优势&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9UmwP9QbNqGzD0hlENUtJukMGmq4f6VEulgHwGrnQiaiavwRlbUWqa6dQ/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9UmwP9QbNqGzD0hlENUtJukMGmq4f6VEulgHwGrnQiaiavwRlbUWqa6dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9XuMaEnSLSrjAotPLASiamJ6b3dr7s1rh8L6OkhuYzYpribbT6JMKDbKg/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9XuMaEnSLSrjAotPLASiamJ6b3dr7s1rh8L6OkhuYzYpribbT6JMKDbKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4、数据中台需要企业战略的支持&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为实现数字化转型，浙江移动5年前就提出启动智慧运营转型的要求，即：&lt;/span&gt;&lt;span&gt;以大数据为驱动、大IT平台为支撑、流程优化和管理完善为保障、改进客户体验和价值创造为目标，推进生产运营转型提升。&lt;/span&gt;&lt;span&gt;智慧运营鼓励企业中的每一个业务单元都投入进来，倡导首创精神，实行差别化试点,“一点创新、推广全省”，智慧运营逐渐成为公司的核心竞争力之一。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没有公司的战略，就不可能有足够的业务驱动力去创造数据中台的生存空间，以前做数据创新面临的很大问题是没有需求，靠IT人员的自嗨刚开始的时候也许是一种创新，但马上缺乏了后续继续发展的动力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;264&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu90ZKk1cdjPlbOwCyFub2bc83fNcGzRXdxrO4U9xWSoe6h5QibzP5dfEw/0?wx_fmt=png&quot; data-ratio=&quot;0.46015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu90ZKk1cdjPlbOwCyFub2bc83fNcGzRXdxrO4U9xWSoe6h5QibzP5dfEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;公司的战略决定了会给你时间去持续的去做一些公司认可的长期的事情，不是那么急功近利，这对于做数据的太不容易了，智慧运营贵在坚持，不断迭代。&lt;/span&gt;&lt;span&gt;我们的智慧运营项目连续做了6年，你可以看下每一年的项目名称，都是在原来基础上的反思和调整。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9KUjJQJwY83rrH8HMBcDn6J37DUJeur5ia1Aia70ZpvtcTfxSkQFq8rJg/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9KUjJQJwY83rrH8HMBcDn6J37DUJeur5ia1Aia70ZpvtcTfxSkQFq8rJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;5、智慧运营坚持的“搭台唱戏”的理念&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当初并没有数据中台这个名词，但我们早就有了“搭台唱戏”的理念，数据中台就是其中的舞台，大家的目标是一致的，如下页所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9N573ibYpCGo3l74ibkJtucPiaxiaAwDM6ianHicedP4fPJPwicqvKFATP7LHg/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9N573ibYpCGo3l74ibkJtucPiaxiaAwDM6ianHicedP4fPJPwicqvKFATP7LHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section class=&quot;page_image_error_loading js_loading&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们必须要打造与之适配的数据赋能框架，这就是后来的数据中台，我们的数据中台从来不是COPY别人的产物，而是采用“搭台唱戏”模式支撑企业智慧运营战略的需要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9TrnKyKsmicibPlFYaYic7seNTQroFLzw8zYLdGDMntjb9ZeZ6E6ZqZsYQ/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9TrnKyKsmicibPlFYaYic7seNTQroFLzw8zYLdGDMntjb9ZeZ6E6ZqZsYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section class=&quot;page_image_error_loading js_loading&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;6、数据中台的一种架构形式&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们定义的数据中台，主要是实现跨域数据整合并沉淀公共的数据能力，同时提供丰富的数据模型、标准化的数据服务、个性化的开发平台与工具，满足一线数据开放和智慧运营的需要，我们把数据管理的相关工具纳入了能效中台，因此在这里并没有体现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBupzmicvksrV74ZGiaeLbCJkibeicV73EloddfvUd71VsLEQpk2yYBssNTUmbeG7XULhcecn6saLCxdcA/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBupzmicvksrV74ZGiaeLbCJkibeicV73EloddfvUd71VsLEQpk2yYBssNTUmbeG7XULhcecn6saLCxdcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;7、数据中台总是处于演进的过程中&lt;/span&gt;&lt;/strong&gt;&lt;section class=&quot;page_image_error_loading js_loading&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;数据中台&lt;/span&gt;是企业发展到一定阶段的产物，而当企业需要在合适的时机推送合适的服务的时，实时数据中台就成了必需品，它不是技术驱动的产物，而是业务的需要，以下示例了我们数据中台的演进历程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9GfpeOK4I8kDKgc5ZFxLo695NCHzaQtKj3sdjuD9M1KPOiaaaSQBCrEQ/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9GfpeOK4I8kDKgc5ZFxLo695NCHzaQtKj3sdjuD9M1KPOiaaaSQBCrEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;8、数据中台的核心始终是模型&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;数据中台再好的架子也需要好的内涵，这就是模型的能力，不要成了绣花枕头稻草芯，&lt;/span&gt;&lt;span&gt;这里提两类重要模型：实时模型和挖掘模型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;一是实时模型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，为高效支撑实时数据应用，实时数据中台在接入海量实时数据基础上，需要根据不同应用场景，将实时数据清洗、聚合，提炼成动态、事件、时序3类实时模型&lt;/span&gt;&lt;span&gt;，分别存储在Redis 、Kafka 、Hbase等技术组件中供下游应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9ibkJQ2nZ1qs35a9lMQiaMdwL3nsmib5HQ4k2osUvgPvXFgqFcJnz0wR7Q/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9ibkJQ2nZ1qs35a9lMQiaMdwL3nsmib5HQ4k2osUvgPvXFgqFcJnz0wR7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;二是挖掘模型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，社交网络、时间序列、时空轨迹、自然语言处理是运营商未来基于数据进行价值创造的核心算法，只有这些算法才能最大限度的挖掘出运营商数据中的价值，&lt;span&gt;笔者前期在文章《&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655930306&amp;amp;idx=1&amp;amp;sn=253bc2b592f90bc3dc853b9a5ed150ea&amp;amp;chksm=8d79e4ffba0e6de9f550205d6c3f8a247f34d48aae59482e0b363c1156b7ce1d46c4ade16954&amp;amp;token=1059178145&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;什么才是运营商数据中台最大的竞争力？&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》中提到过位置和上网是运营商最核心的数据，这些数据的价值挖掘极度依赖以上的核心算法。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;互联网公司曾经走过的路，付出的代价，运营商是绕不过的，否则，就无法发挥出原生数据的更多价值。&lt;/span&gt;&lt;span&gt;现在中国移动提出要从“要素”竞争向“要素+能力”竞争转型，在这里数据是要素，算法就是能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9oB7vGX6r3ceLHYGbeKYvRZwsSOCWIviaR6oBVVUfVOnnw47XcTB8UpQ/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9oB7vGX6r3ceLHYGbeKYvRZwsSOCWIviaR6oBVVUfVOnnw47XcTB8UpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个例子，基于社交网络识别出&lt;span&gt;家庭&lt;/span&gt;、政企的各种关系&lt;span&gt;对于运营商做好家庭、政企业务非常重要&lt;/span&gt;，以下示例了某位同事的家庭关系，涉及17个人，7个物理家庭，通过这些关系的识别你才能更精准的提供服务。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;341&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9lrN2Xpcp06BshgiaJRrow5DgkMalxfBNHiavqhHfwbIaFOKzS2DNhn2Q/0?wx_fmt=png&quot; data-ratio=&quot;0.5935114503816794&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9lrN2Xpcp06BshgiaJRrow5DgkMalxfBNHiavqhHfwbIaFOKzS2DNhn2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;9、数据中台的开放至关重要&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;授人以鱼不如授人以渔，数据中台要开放能力，不是眉毛胡子一把抓，需要&lt;/span&gt;&lt;span&gt;尊重公司的现状，为不同的角色提供不同的数据开放手段。&lt;/span&gt;&lt;span&gt;比如标签库主要为业务人员服务、DM主要面向会SQL的人员，组件服务则面向技术开发人员等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;page_image_error_loading js_loading&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9h1vX52JGCncibogk1ClHRQLicPfKhXPK3lJvepHJzIVfGpgXlS6pqGicA/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9h1vX52JGCncibogk1ClHRQLicPfKhXPK3lJvepHJzIVfGpgXlS6pqGicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;page_image_error_loading js_loading&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9Zib9wVzVhCic1Y01Tibtsqe4x8FUwIcdicu4npc4icW1M3lcG1ngQhiaeQfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;10、数据中台的出口在哪里？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有了数据中台远远不够，只有之上的数据产品才能解决数据推送的最后一公里问题，很多数据团队最大的问题是没有数据产品，根本不是数据中台本身就能解决的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;凡是数据中台做的好的，前端的数据产品生态肯定是不错的，下图示例了我们的数据产品与阿里巴巴的对标，在我的前期文章中也有详细的阐述，即要从不同的赋能角色角度去思考数据产品的方向。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img custom_select_img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9BXSrK6DVSvdzISJwCMIr4iaR3bvMFVcgkjsqM2eO7EAHn87IuVaiawIw/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9BXSrK6DVSvdzISJwCMIr4iaR3bvMFVcgkjsqM2eO7EAHn87IuVaiawIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section class=&quot;page_image_error_loading js_loading&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;js_cache js_nocatch&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过几年的摸索，赋能对外变现的神灯产品体系已经具备一定的规模，神灯产品以数据价值保护和信息安全为前提，进行数据、模型、标签、接口、应用产品等多层次的合作，探索合作研发、销售代理、资源互换、产品孵化、模型锤炼、大数据联邦等多种新型合作模式，如下页所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9LqvPEcIE38sYnPX8Og48JDlBhmQvVAOrONmz7oY8NCLwOjKhvBgCbw/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9LqvPEcIE38sYnPX8Og48JDlBhmQvVAOrONmz7oY8NCLwOjKhvBgCbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu9mMPUYZ5lEqvNGrasiboYCZGEiaFU3OAB9D02bhTOvPOZf6b7drowf4Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据中台不需要去比框架、比技术或比性能，只要你的企业的业务人员或外部客户利用你的平台创造了更多价值，就是对数据中台最大的褒奖。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但要达到这个目标光有个数据中台是没有用的，除了数据产品，还需要配备相应的战略、组织、机制及人员等等，比如组织中台，也即先进生产力要适配相应的生产关系。下图列出了八个方向的建议，这些能力对传统企业的挑战特别巨大。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-backh=&quot;323&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu961G7JsPTXBn3y3L69dlGYM0AibhxQPQZRqYNj0PJEjVmGpEmzzIhKuw/0?wx_fmt=png&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvLoyW9arstsFNXqUrxpxu961G7JsPTXBn3y3L69dlGYM0AibhxQPQZRqYNj0PJEjVmGpEmzzIhKuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这次演讲基本的思想就是这些了，感谢TD公司的组织，让我们有机会让业界看到浙江移动的做法，但你没必要COPY我们的，因为数据中台没有标准架构，总是要掌握一个原则：&lt;span&gt;参考别人的做法，听取专家的意见，然后&lt;/span&gt;&lt;span&gt;自己做主。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNDI0ODY1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBsbESO4ibFCDqef4scQ0d37tBp3meC5icozRdMAmCZgNG0NTJnMXn3pVne9cibHIqibWzmQXeCeQRkONg/0?wx_fmt=png&quot; data-nickname=&quot;与数据同行&quot; data-alias=&quot;ysjtx_fyp&quot; data-signature=&quot;傅一平博士创办的大数据公众号，分享数据相关的技术干货、思考感悟和学习体会！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>010c21fef6dcf9dbc03a470a659b5063</guid>
<title>WebRTC 漫漫成长路，下一个十年将走向何方？</title>
<link>https://toutiao.io/k/cebk1i5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;本文整理自声网Agora WebRTC 负责人毛玉杰在 RTE2021 实时互联网大会大前端与应用开发技术专场上的演讲分享。在演讲中他主要针对 WebRTC 在过去十年的历程、WebRTC 未来的发展以及结合具体项目场景带来的 WebRTC 具体实践内容。关注本文标签&lt;span&gt;「RTE 技术分享」&lt;/span&gt;，我们将陆续更新更多演讲干货。以下为演讲实录。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibrESV5sLiaa45QOpe9ed3kZL2E3Ktfbb7BkYe6fEM4IlEf5lVJSRg16w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;▲图：声网Agora WebRTC 负责人 毛玉杰&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22037037037037038&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibYpd7HGWib5PgRUicLPDzAzh2Cg4iayUlFlYl8jKfmWK2ibEF9HL0eRqacQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;毛玉杰认为 WebRTC 的发展完全离不开浏览器的发展。会议现场他向观众展示了一张图片，说明 Chrome &lt;/span&gt;&lt;span&gt;浏览器在过去十年的增长非常惊人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5363489499192245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibWSl8BUsdsQ3VMEEhicp2AYEr8srNZNbzibxD5vfMQMObAKJvcJ4ia1x1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;619&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Chrome 背后的技术源于谷歌，也是 WebRTC 的创立者。得益于谷歌在移动端 Android 的优势，以及搜索引擎的优势，Chrome 运行的非常快。此外它的用户体验非常流畅，这也是谷歌可以在发布之后迅速崛起，到 2019 年几乎达到了顶峰，市场份额占有约 65% 的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了 Chrome 之外，Safari 浏览器也值得大家关注。毛玉杰指出苹果自从 2007 年发布了 iPhone，iOS 的增长也是有目共睹的。Safari 占了将近 20% 的市场份额。目前在浏览器业界一共有三大内核，一个是 Chrome 内核，一个是 Firefox 的内核，再加上 Safari 内核，这三个内核几乎占了浏览器内核的 95% 以上，而其他的浏览器或多或少都是来源于 Chrome。这三大浏览器对 WebRTC 的支持，刚好为 WebRTC 的发展奠定了非常扎实的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2011 年 6 月 1 号，谷歌向 WebRTC 社区发了一个邮件，决定把 WebRTC 开源，这为业界埋下了 WebRTC 的种子，经过了十年各方的努力，目前 WebRTC 已完全成长成了一棵参天大树。目前很多应用，比如像语音的应用、移动的直播、视频会议，都是得益于这颗种子，可谓硕果累累。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;毛玉杰完整地回顾了一下过去这十年 WebRTC 的大事件：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5647058823529412&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibrDEcBtGKmicd1gIrV888GtkS0JpygrD4VagvAFXSsj7vtrWtw9A9yMw/640?wx_fmt=png&quot; data-w=&quot;595&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2008 年谷歌发布了 Chrome，两年以后收购了 GIPS，这也是 WebRTC 的原身。2011 年把 WebRTC 的代码开源了，在社区里面第一版 WebRTC 工作草案已经发布。时隔一年以后，谷歌在 23 号版本中正式对外支持了 WebRTC 的功能，Firefox 快速地跟进.在 2013 年 Firefox22 的版本中也默认支持了 WebRTC，同一年 WebRTC 在 Chrome 和 Firefox 达到了可互动的地步。2016 年，谷歌在 52 号版本里第一次支持 H.264，但这在 WebRTC 发展历程里是谷歌不太愿意提及的一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2017 年，因为 Safari 在前六年都没有支持 WebRTC，当 WebRTC 正式成为 Web1.0 候选推荐标准的时候，Safari11 首次支持 WebRTC，也是为整个三大浏览器内核支持 WebRTC 奠定了非常好的基础。2020 年和 2021 年，这两年是 WebRTC 完全大爆发的一年，所有人被困在家里之后，都涌到线上。WebRTC 的流量出现了爆增。今年年初经历过十年的标准演进，WebRTC1.0 正式成为各大浏览器厂商的推荐标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年到 2021 年 WebRTC 的发展有大的突破，在疫情期间从去年 3 月份到今年 1 月份有比较大的增长，比如南美、北美、欧洲等区域的增长更是惊人。根据毛玉杰向观众展示的官方分钟数的数据图显示，从去年 3 月到去年 12 月视频分钟数增长了 100 倍，就像是 4G 的下载速度和 2G 的下载速度相比，4G 比 2G 快了 100 倍，这是比较恐怖的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.555765595463138&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibd5utTHpdf7tRTPCFdsZV1LCE1YL1e7JKtibGE1ptYibasHmLDQ2Y3j0Q/640?wx_fmt=png&quot; data-w=&quot;529&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了浏览器，WebRTC 还有一个至关重要的事件，就是 Codecs。谷歌在 2010 年收购了一家公司叫 On2 Techonlogy，On2 致力于对外提供产品视频的编解码器，并做了一些整合，长达四年的时间内只支持 VP8。在 2015 年，Chrome48 版本支持了 VP9。2014 年WebRTC 峰会的时候谷歌内部有在 2014 年已经去规划下一个Codecs VP10，VP10 也给后面的发展做了铺垫。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5489130434782609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibEKImNomgYic1rICYGZPZlahkac5mUNLpib1Z8NR9pOxEV0jpaUxbITfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于 H.264 的版权谷歌不愿意支持，这个版权有两个标准组织都在研发，之前是分离的，后面合并了。在那时候，264 仍然是全球使用最多的 Codec。由于版权比较繁琐，所以 WebRTC 早期不支持 H.264，即使现在 Android 平台上 264 的支持还不太乐观。为了给互联网打造一个免版权的环境，包括代码可以开源，以实现大快速的迭代，谷歌牵头在 2015 年成立了开放媒体联盟（AOM），此举得到了亚马逊、Intel、微软等很多企业的支持。2016 年AOM标准正式发布了 1.0 的版本，2018 年 Codec AV1 正式问世。Chrome 在今年发布的 90 版本里也是在 WebRTC 里支持了 AV1，所以大家现在可以在最新的 Chrome 里面使用 AV1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于兼容性问题，毛玉杰展示了 Web 开放平台的测试结果。在 2018 年的时候 WebRTC 的覆盖率是非常不足的。到 2021 年几乎所有的 WebRTC 定义的接口都有了不同程度的完整度的覆盖，除了一些少有的东西，这个东西相对来说不同浏览器厂商跟进的比较慢，所以目前来看切口的兼容性也是有了比较好的支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5634028892455859&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmiblvQx6wyzFET7U6Srstj66DPHJ9OdAwdsjPhP3pAAnUjIdiaibZQtyVHA/640?wx_fmt=png&quot; data-w=&quot;623&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;毛玉杰展示了 WebRTC 在浏览器内部的结构图，第一层浏览器对外暴露的 API，下面一层是 WebRTC C++ 的 API，再下一层就是音视频的引擎。之后是音视频的采集，还有网络传输，这些都是浏览器的厂商自己可以定制的，这个也是 WebRTC 有比较多的限制的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5569395017793595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibhRASWPFeicpricAaouuNicluMmoiafE1Jsrbh0FPvKSMSG3tCepIwcGFNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图展示了 WebRTC 媒体流的流向，从麦克风、摄像头的采集，再到音频的 3A，再到视频比较简单的前处理，再到编码器，编码器之后还会做一些简单的加解密，然后往外发送，接收端有解码器，解码完之后在浏览器里做播放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.5585106382978723&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibJxzeu3ztJlRIJhVEvpkplrex51icNB5ib4dgBiaE5ZtR1ttoc0XShz0Ig/640?wx_fmt=png&quot; data-w=&quot;564&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;毛玉杰对在 WebRTC 的十年发展过程当中遇到的问题进行了总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5400641025641025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibzWUUp7nbhFMj5zURQ9wHtMAuD26e4stvblFEFh3Cp4McERUzrrvvIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是设备跟外设的适配，设备具有复杂性，不同的驱动，不同的外设，不同的蓝牙耳机，摄像头都会存在很多兼容性的问题，这些兼容性问题都需要浏览器厂商兼容，然而浏览器厂商不会做这个事情。如果接触过 Chrome 开源项目的人会知道，他们所适配的机型数量是非常少的。同时在浏览器厂商在不同平台上框架层面的实现都是不一样的，因为都要调操作系统的 API，操作系统的 API 各个平台都不一样，造成很多平台上虽然一次性测试过了，但是组合起来的测试就会出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在移动端，WebRTC 相对在市场上是有很多的需求的，很多人需要在钉钉，企业微信里面中使用，方便做一些业务推广。但同时，现在 WebRTC 在移动端存在的问题是非常多的，比如音频路由器切换、音频的 3A，在不同的手机上都要做适配。现在浏览器厂商做的还不够，可能有些定制了浏览器内核的 APP，比如 Android 的微信，整个官方浏览器的适用还是没有做的很好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于 WebRTC 浏览器音视频的模块是不可定制的，声网针对很多不同的网络做了一些算法的适配。现在由于受限于 WebRTC 音视频模块都在浏览器内部，开发者陷入无法作为的境地。同时还有一个在实践中遇到的非常痛苦的问题在于 WebRTC 的质量指标问题。在统计数据里，WebRTC 更多定义的是服务质量，比如像大家熟悉的音频的码率、视频的码率，视频的渲染帧率，这些都不算是真正的体验指标，体验指标是像音频卡不卡，视频卡不卡。（编者注：体验指标的更多干货，可关注本篇文章标签“RTE2021”，后续会整理发布相关演讲内容。）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.1638888888888889&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibFFk3UdibfxDicbenj2Lt3p9HKTxYKQGDTyrDPNsCDysoRj1rVTwRchQQ/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;WebRTC 的标准已经演进到 WebRTC NV这一代，但WebRTC NV到底是什么呢？翻一下 W3C 的标准可以看到各种各样的标准非常多，但到底有哪些标准跟 WebRTC NV 相关？WebRTC 1.0 和 WebRTC 2.0 是说明 WebRTC 下一代是大的改进还是小的改进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一定程度上 WebRTC 的 NV 可以被认为是 ORTC。过去几年这个标准的声音已经没有多少了，但是这个标准在 WebRTC 出现的早期还是非常火的。2013 年有些人不太满意 WebRTC 标准里面的东西。所以对于可深度的编码做了标准的制定，还有之前的裸数据和一些深度信息也做了扩展。对于 WebRTC 现有标准的补充，可以认为是 WebRTC 1.1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于另外的一些标准都是非常独立的，跟 WebRTC 的标准可能不太完全相关，可以用在除了 WebRTC 之外的其他地方。它们始终没有办法在浏览器内部直接用操作系统的Socket，另外 WebRTC 把底层的编辑化能力放出来了，还有一些是 WebRTC 标准分离，比如像 IaaS 的标准，以及 QUIC 的标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55668358714044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibOEDHIR6PSzPLo5AfT3bfvlia1cGECdxF9VPqicfYHme761pwf9abpGbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;WebRTC 的使用完全不能脱离 TCP，如果要建一个连接免不了要去交换 SDP，避免不了需要 WebRTC 使用一个 TCP 的协议栈。WebSocke t其实是一个可选择的框架，可以结合业务场景选择，到底决定用 SV2 还是 SV3 ，相对来说比较灵活的。还有一个是谷歌最近提出的 Raw Sockets 协议，目前还处在非常早期的阶段，但有着非常大的发展前景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5647226173541963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibic4yCKsy6nib27RSG2Ybwy1O1jEteFg0MOY9prZLNIibZQ7cgTTIqbTfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前所有的编解码都是在浏览器的内部，意味着用了 WebSocket 接口收了一条流，解码和编码都发生在浏览器的内部。而 Web Codecs 可以通过 API 可以实现一些编解码，可以会直接调用一个编解码器，做一些前处理，所有的东西都可以打碎组合出来实现自己的应用，具备很大的想象空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5342465753424658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib3x3luGviaWqdbfvNeOxeiax3RPick8mYico0shOs4n9hBOSBXEDwPiaCUcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;毛玉杰还介绍了一种非常火热的技术——Web Assembly，这项技术在前端和后端都受到了很多的关注。这项技术的兼容性是非常好的，原理相对比较简单。毛玉杰认为上述几个技术的结合促成了声网新的技术架构，现在还在做一些技术上的探索。从摄像头、麦克风拿到裸数据，可以做一些很多的前处理，比如做美颜，可以做背景分割（可见往期分享）等等。做完之后自己做编码，做完编码以后可以实现一个 WebRTC 的协议站，做完之后发送，然后在接触端实现相关的能力，拿到这些数据之后再去做解码，再用浏览器上，整体能力可以脱离现在 WebRTC 这么封闭的黑盒子，赋予了更多的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5602094240837696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib1gQJtlYiaEzKemukubia0xO81a94iaibI4l1vFBsoODPXYCHlriaSFMCUrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;573&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于 WebRTC 的未来，毛玉杰总结了两大趋势：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一，移动 WebRTC 有着很大的潜力，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;这个潜力体现在有很多人会用到移动端的浏览器，比如微信、钉钉内制的浏览器。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Android 平台上还有很多人会去开发应用，还会有一些开发者用 WKWEBView 做应用开发。同时也希望浏览器厂商能去做好移动端的 WebRTC，这个对于拓展很多场景会有非常大的帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5621970920840065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibzPyINdbnPYf7rXV1UHV5Vjia74T3DSj7YamYeibxX4SoJdnDic3ONpOqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;619&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二，希望 WebRTC 能把它的模块变成类似于积木一样的东西，&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;WebRTC 整个模块里面内容非常多，有视频引擎、音频引擎，每个引擎下面有很多的模块，3G、加解密等等。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;未来它们能够组合更多非常有意思的应用，这个就是可定制的能力，当只想做一些项目的时候，哪怕用自己的模块，哪怕用谷歌的墨客，也要把它的能力开放出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.541038525963149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibQyhxEzfDzW5TEJfia8dTtUun7ptyQA4mFib1OwnKI5ibZpYRL735vaX4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;597&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，毛玉杰以一张来源于游戏的图片来结束今天的演讲：图片中的主人翁，游戏的制定者说过一句话“作为一个旁观者，他永远没有像深入到这个游戏里面的人来的更有趣”。呼吁大家一起参与到未来的 WebRTC 的标准中来，贡献自己的想法，将整个行业和生态共同推向未来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5345699831365935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibNaPlialaUZ1UeQb3UrXUrOVmlDmMiclDMTqc3Z0VTFjxDv9lzAKvd85w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;593&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3e8baddacbfe7ca18b065aec6b1feae</guid>
<title>Hive 分桶 Bucket</title>
<link>https://toutiao.io/k/hvl3sv4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0OTYwNTQ4Ng==&amp;amp;action=getalbum&amp;amp;album_id=1496183731001278466#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1496183731001278466&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#Hive&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;10个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001609&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nKovjAe6LrqsnLeDu6cYdicFx2Mob79dxiakXhdjeIJtj6JGNf4mz1bmYZYia5SHqOaPoXziaWw8I45juOZIvc7daw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;1. 概述&lt;/h3&gt;&lt;p&gt;通常 Hive 中的分区功能提供了一种将 Hive 表数据分隔成多个文件/目录的方法。当只有有限个分区，分区大小差不多大情况下，分区会产生不错的效果。但在有些情况下并不能如我们所愿，比如，当我们根据国家对表进行分区时，一些较大的国家会有较大的分区（例如：4-5个国家就占总数据的70-80％），然而一些小国家分区会比较小（剩余的所有国家可能只占全部数据的20-30％）。&lt;/p&gt;&lt;p&gt;Hive 中的分区提供了一个隔离数据和优化查询的便利方式，不过并非所有的数据都可形成合理的分区，例如，上面的情形。在这种情形下分区并不理想，为了解决分区的这个问题，Hive 引入分桶的概念。Hive 中的分桶是另一种将数据切分为更小片段的方式。分区就是一个目录，在分桶中，每个桶都是保存实际数据的一个文件(一个桶对应一个文件)。&lt;/p&gt;&lt;p&gt;将表（或者分区）组织成分桶有两个主要的原因：&lt;/p&gt;&lt;p&gt;分桶具有如下特征：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;分桶基于对分桶列值进行哈希并将结果除以桶的个数取余数。哈希函数取决于分桶列的类型。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;具有相同分桶列的记录存储在同一个分桶中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我们使用 &lt;code&gt;CLUSTERED BY&lt;/code&gt; 子句划分分桶。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;从物理上讲，每个桶只是表目录中的一个文件，桶编号从下标1开始。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分桶可以与分区一起使用，也可以不需要分区。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分桶表数据文件分布比较均衡。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;2. 用法&lt;/h3&gt;&lt;p&gt;我们先来看看一个表如何被划分成桶。我们可以在 &lt;code&gt;CREATE TABLE&lt;/code&gt; 语句中使用 &lt;code&gt;CLUSTERED BY&lt;/code&gt; 子句和可选的 &lt;code&gt;SORTED BY&lt;/code&gt; 子句来制定划分桶所用的列和要划分的桶的个数：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; bucketed_user(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  state &lt;span&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  city  &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PARTITIONED &lt;span&gt;BY&lt;/span&gt; (country &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;CLUSTERED &lt;span&gt;BY&lt;/span&gt; (state) &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; BUCKETS;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这里我们使用用户所在的州（state）来确定如何划分分桶（Hive 对值进行哈希并将结果除以桶的个数取余数）。这样，任何一桶里都会有一个随机的用户集合。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;上表使用用户所在的国家（country）来确定如何划分分区。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;桶中的数据可以根据一个或者多个列另外进行排序。如下所示根据 city 进行排序：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; bucketed_users(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  state &lt;span&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  city  &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PARTITIONED &lt;span&gt;BY&lt;/span&gt; (country &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;CLUSTERED &lt;span&gt;BY&lt;/span&gt; (state) SORTED &lt;span&gt;BY&lt;/span&gt; (city) &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; BUCKETS;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;假设我们有一个没有划分桶的用户表：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;hive&amp;gt; SELECT name, country, state, city FROM users;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;OK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Rebbe   AU      TA      Leith&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Stevie  AU      QL      Proston&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mariko  AU      WA      Hamel&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Gerardo AU      NS      Talmalmo&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mayra   AU      NS      Lane Cove&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Idella  AU      WA      Cartmeticup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Sherill AU      WA      Nyamup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Ena     AU      NS      Bendick Murrell&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Vince   AU      QL      Purrawunda&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;要向分桶后的表中填充数据，需要将 &lt;code&gt;hive.enforce.bucketing&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt;。这样 Hive 就知道用表定义中声明的数量创建桶（自动使用正确的 Reducer 个数和 Group By 列，否则你需要手动设置 Reducer 个数跟桶的个数一致），然后使用 &lt;code&gt;INSERT&lt;/code&gt; 命令即可：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;SET&lt;/span&gt; hive.exec.dynamic.partition.mode=nonstrict;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;SET&lt;/span&gt; hive.enforce.bucketing = &lt;span&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;INSERT&lt;/span&gt; OVERWRITE &lt;span&gt;TABLE&lt;/span&gt; bucketed_users&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;PARTITION&lt;/span&gt; (country)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;, state, city, country&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;users&lt;/span&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;属性 &lt;code&gt;hive.enforce.bucketing&lt;/code&gt; 类似于分区中的 &lt;code&gt;hive.exec.dynamic.partition&lt;/code&gt; 属性。通过设置此属性，我们才能将数据加载到 Hive 表时启用动态分桶。&lt;/p&gt;&lt;p&gt;在 Hive 2.x 之前，属性 &lt;code&gt;hive.enforce.bucketing&lt;/code&gt; 默认值为 &lt;code&gt;false&lt;/code&gt;，使用分桶时需要手动设置为 &lt;code&gt;true&lt;/code&gt;。在 Hive 2.x 之后，该属性被删除，表示永远为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;物理上，每个桶就是表（或者分区）目录里的一个文件。它的文件名称并不重要，但是桶 &lt;code&gt;n&lt;/code&gt; 是按照字典序排列的第 &lt;code&gt;n&lt;/code&gt; 个文件。事实上，桶对应于 MapReduce 的输出文件分区：一个作业产生的桶（输出文件）和 Reduce 任务个数相同。我们通过查看刚才创建创建的分桶表的布局来了解这一点。运行如下命令：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;[sjf0115@ying ~]$  hadoop fs -ls /user/hive/warehouse/hive.db/bucketed_users/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Found 5 items&lt;/span&gt;&lt;br/&gt;&lt;span&gt;drwxr-xr-x   - sjf0115 supergroup  0 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=AU&lt;/span&gt;&lt;br/&gt;&lt;span&gt;drwxr-xr-x   - sjf0115 supergroup  0 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=CA&lt;/span&gt;&lt;br/&gt;&lt;span&gt;drwxr-xr-x   - sjf0115 supergroup  0 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=UK&lt;/span&gt;&lt;br/&gt;&lt;span&gt;drwxr-xr-x   - sjf0115 supergroup  0 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=US&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[sjf0115@ying ~]$&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[sjf0115@ying ~]$  hadoop fs -ls /user/hive/warehouse/hive.db/bucketed_users/country=AU/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Found 4 items&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-rwxr-xr-x 3 sjf0115 supergroup 0 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=AU/000000_0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-rwxr-xr-x 3 sjf0115 supergroup 3280 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=AU/000001_0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-rwxr-xr-x 3 sjf0115 supergroup 2903 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=AU/000002_0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-rwxr-xr-x 3 sjf0115 supergroup 4156 2018-08-03 13:12 /user/hive/warehouse/hive.db/bucketed_users/country=AU/000003_0&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我们看到每个分区下都有4个新建的文件。文件名如下：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;000000_0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;000001_0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;000002_0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;000003_0&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3&gt;3. 注意事项&lt;/h3&gt;&lt;p&gt;下面是在 Hive 中使用分桶时应该遵循的一些最佳实践：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;选择唯一值个数比较多的桶键，这样会降低出现数据倾斜的概率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;采用质数作为桶的编号。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分桶对于多表 Join 非常有用。需要注意的是，Join 表的桶个数必须相同，或者一个表的桶个数是另一个表桶个数的因子。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;表建好之后，桶的个数就不能改变了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;仔细考虑桶的个数。一个 CPU 核只会对一个桶进行写入操作，因此对于一个大型集群，如果桶的个数很小，则集群的利用严重不足。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;仔细考虑选择进行分桶的列，因为散列函数会引发数据倾斜。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;参考：　&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>468b432f576eed936f201bddee8e088f</guid>
<title>Go 并发编程一年回顾 (2021)</title>
<link>https://toutiao.io/k/o43fzwc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;
      
      
      
      &lt;p&gt;去年的时候我写了一篇&lt;a href=&quot;https://colobu.com/2020/07/05/the-state-of-go-sync-2020/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Go并发编程一年回顾&lt;/a&gt;,如今2021年也快结束了，Go 1.18的特性已经冻结，美国页很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;h2 id=&quot;TryLock终于要发布&quot;&gt;TryLock终于要发布&lt;/h2&gt;
&lt;p&gt;很久以来(可以追溯到2013年&lt;a href=&quot;https://github.com/golang/go/issues/6123&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#6123&lt;/a&gt;),就有人提议给Mutex增加TryLock的方法，被大佬们无情的拒绝了，断断续续，断断续续的一直有人提议需要这个方法，如今到了2021年，Go team大佬们终于松口了，增加了相应的方法(&lt;a href=&quot;https://github.com/golang/go/issues/45435&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#45435&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;一句话来说，Mutex增加了TryLock， 尝试获取锁, RWMutex 增加了 TryLock和TryRLock方法，尝试获取写锁和读锁。它们都返回bool类型。如果返回true,代表已经获取到了相应的锁，如果返回false,则表示没有获取到相应的锁。&lt;/p&gt;
&lt;p&gt;本质上，要实现这些方法并不麻烦，接下来我们看看相应的实现(去除了race代码)。&lt;/p&gt;
&lt;p&gt;首先是Mutex.TryLock:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (m *Mutex) TryLock() &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; atomic.CompareAndSwapInt32(&amp;amp;m.state,&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt;, mutexLocked) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;true&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;false&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;也就是利用aromic.CAS操作state字段，如果当前没有被锁或者没有等待锁的情况，就可以成功获取到锁。不会尝试spin和与等待者竞争。&lt;/p&gt;
&lt;p&gt;不要吐槽上面的代码风格，可能你觉得不应该写成下面的方式吗？原因在于我删除了race代码，那些代码块中包含race代码，所以不能像下面一样简写：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (m *Mutex) TryLock() &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; atomic.CompareAndSwapInt32(&amp;amp;m.state,&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt;, mutexLocked)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;读写锁有些麻烦，因为它有读锁和写锁两种情况。&lt;/p&gt;
&lt;p&gt;首先看RWMutex.TryLock(去除了race代码):&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (rw *RWMutex) TryLock() &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !rw.w.TryLock() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;false&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !atomic.CompareAndSwapInt32(&amp;amp;rw.readerCount,&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt;, -rwmutexMaxReaders) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        rw.w.Unlock()&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;false&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;true&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先底层的Mutex.TryLock,尝试获取w字段的锁,如果成功，需要检查当前的Reader, 如果没有reader,则成功, 如果此时不幸还有reader没有释放读锁，那么尝试Lock也是不成功的,返回false。注意返回之前一定要把rw.w的锁释放掉。&lt;/p&gt;
&lt;p&gt;接下来看RWMutex.TryRLock(去除了race代码):&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (rw *RWMutex) TryRLock() &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;c := atomic.LoadInt32(&amp;amp;rw.readerCount)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; c &amp;lt;&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;false&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; atomic.CompareAndSwapInt32(&amp;amp;rw.readerCount, c, c&lt;span class=&quot;number&quot;&gt;+1&lt;/span&gt;) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;true&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这段代码首先检查readerCount,如果为负值，说明有writer，此时直接返回false。&lt;/p&gt;
&lt;p&gt;如果没有writer, 则使用atomic.CAS把reader加1, 如果成功，返回。如果不成功，那么此时可能有其它reader加入，或者也可能有writer加入，因为不能判断是reader还是writer加入，那么就用一个for循环再重试。&lt;/p&gt;
&lt;p&gt;如果是writer加入，那么下一次循环c可能就是负数，直接返回false,如果刚才是有reader加入，那么它再尝试加1就好了。&lt;/p&gt;
&lt;p&gt;以上就是新增的代码，不是特别复杂。Go team不情愿的把这几个方法加上了, 同时有很贴心的提示(恐吓):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that while correct uses of TryLock do exist, they are rare,&lt;br/&gt;and use of TryLock is often a sign of a deeper problem&lt;br/&gt; in a particular use of mutexes. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;WaitGroup的字段变化&quot;&gt;WaitGroup的字段变化&lt;/h2&gt;
&lt;p&gt;先前，WaitGroup类型使用&lt;code&gt;[3]uint32&lt;/code&gt;作为&lt;code&gt;state1&lt;/code&gt;字段的类型，在64位和32位编译器情况下，这个字段的byte的意义是不同的，主要是为了对齐。虽然使用一个字段很&quot;睿智&quot;,但是阅读起来却很费劲，现在，Go team把它改成了两个字段，根据对齐规则，64位编译器会对齐相应字段，讲真的，我们不差那4个字节。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;22&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;23&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;24&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;25&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; WaitGroup &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;noCopy noCopy&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 64-bit atomic operations require 64-bit alignment, but 32-bit&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// compilers only guarantee that 64-bit fields are 32-bit aligned.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// For this reason on 32 bit architectures we need to check in state()&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// if state1 is aligned or not, and dynamically &quot;swap&quot; the field order if&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// needed.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;state1 &lt;span class=&quot;typename&quot;&gt;uint64&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;state2 &lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// state returns pointers to the state and sema fields stored within wg.state*.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (wg *WaitGroup) state() (statep *&lt;span class=&quot;typename&quot;&gt;uint64&lt;/span&gt;, semap *&lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; unsafe.Alignof(wg.state1) ==&lt;span class=&quot;number&quot;&gt; 8&lt;/span&gt; || &lt;span class=&quot;typename&quot;&gt;uintptr&lt;/span&gt;(unsafe.Pointer(&amp;amp;wg.state1))&lt;span class=&quot;number&quot;&gt;%8&lt;/span&gt; ==&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// state1 is 64-bit aligned: nothing to do.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;amp;wg.state1, &amp;amp;wg.state2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;} &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// state1 is 32-bit aligned but not 64-bit aligned: this means that&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// (&amp;amp;state1)+4 is 64-bit aligned.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;state := (*&lt;span class=&quot;number&quot;&gt;[3&lt;/span&gt;]&lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;)(unsafe.Pointer(&amp;amp;wg.state1))&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (*&lt;span class=&quot;typename&quot;&gt;uint64&lt;/span&gt;)(unsafe.Pointer(&amp;amp;state&lt;span class=&quot;number&quot;&gt;[1&lt;/span&gt;])), &amp;amp;state&lt;span class=&quot;number&quot;&gt;[0&lt;/span&gt;]&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;64位对齐情况下state1和state2意义很明确，如果不是64位对齐，还得巧妙的转换一下。&lt;/p&gt;
&lt;h2 id=&quot;Pool中使用fastrandn替换fastrand&quot;&gt;Pool中使用fastrandn替换fastrand&lt;/h2&gt;
&lt;p&gt;Go运行时中提供了&lt;code&gt;fastrandn&lt;/code&gt;方法，要比&lt;code&gt;fastrand() % n&lt;/code&gt;快很多，相关的文章可以看下面中的注释中的地址。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;22&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;23&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;24&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;25&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;26&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;27&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//go:nosplit&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fastrand() &lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;mp := getg().m&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Implement wyrand: https://github.com/wangyi-fudan/wyhash&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; goarch.IsAmd64|goarch.IsArm64|goarch.IsPpc64|&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;goarch.IsPpc64le|goarch.IsMips64|goarch.IsMips64le|&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;goarch.IsS390x|goarch.IsRiscv64 ==&lt;span class=&quot;number&quot;&gt; 1&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;mp.fastrand +=&lt;span class=&quot;number&quot;&gt; 0&lt;/span&gt;xa0761d6478bd642f&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;hi, lo := math.Mul64(mp.fastrand, mp.fastrand&lt;span class=&quot;number&quot;&gt;^0&lt;/span&gt;xe7037ed1a0b428db)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;(hi ^ lo)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Implement xorshift64+&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;t := (*&lt;span class=&quot;number&quot;&gt;[2&lt;/span&gt;]&lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;)(unsafe.Pointer(&amp;amp;mp.fastrand))&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;s1, s0 := t&lt;span class=&quot;number&quot;&gt;[0&lt;/span&gt;], t&lt;span class=&quot;number&quot;&gt;[1&lt;/span&gt;]&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;s1 ^= s1 &amp;lt;&amp;lt;&lt;span class=&quot;number&quot;&gt; 17&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;s1 = s1 ^ s0 ^ s1&amp;gt;&lt;span class=&quot;number&quot;&gt;&amp;gt;7&lt;/span&gt; ^ s0&amp;gt;&lt;span class=&quot;number&quot;&gt;&amp;gt;16&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;t&lt;span class=&quot;number&quot;&gt;[0&lt;/span&gt;], t&lt;span class=&quot;number&quot;&gt;[1&lt;/span&gt;] = s0, s1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s0 + s1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//go:nosplit&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; fastrandn(n &lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;) &lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// This is similar to fastrand() % n, but faster.&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt;(&lt;span class=&quot;typename&quot;&gt;uint64&lt;/span&gt;(fastrand()) * &lt;span class=&quot;typename&quot;&gt;uint64&lt;/span&gt;(n) &amp;gt;&amp;gt;&lt;span class=&quot;number&quot;&gt; 32&lt;/span&gt;)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;所以sync.Pool中使用&lt;code&gt;fastrandn&lt;/code&gt;做了一点点修改，用来提高性能。好卷啊，这一点点性能都来压榨,关键，这还是开启race才会执行的代码。&lt;/p&gt;
&lt;h2 id=&quot;sync-Value增加了Swap和CompareAndSwap两个便利方法&quot;&gt;sync.Value增加了Swap和CompareAndSwap两个便利方法&lt;/h2&gt;
&lt;p&gt;如果使用sync.Value,这两个方法的逻辑经常会用到，现在这两个方法已经添加到标准库中了。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (v *Value) Swap(&lt;span class=&quot;built_in&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;{}) (old &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;{}) &lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (v *Value) CompareAndSwap(old, &lt;span class=&quot;built_in&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;{}) (swapped &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt;)&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Go 1.18中虽然实现了泛型，但是一些库的修改有可能在将来的版本中实现了。在泛型推出来之后，atomic对类型的支持会有大大的加强，所以将来Value这个类型有可能退出历史舞台，很少被使用了。(参考Russ Cox的文章&lt;a href=&quot;https://research.swtch.com/gomm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Updating the Go Memory Model&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;整体来说，Go的并发相关的库比较稳定，并没有大的变化。&lt;/p&gt;

      
    &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d4a1a2705764401f027672bcb1ab5422</guid>
<title>[推荐] 高并发系统建设经验总结</title>
<link>https://toutiao.io/k/zcql3fl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502257907&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：listenzhang，腾讯 PCG 后台开发工程师&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期从事运单系统的开发和维护工作，从最早的日均百万单，到日均千万单，业务的快速发展再加上外卖业务的特点是，业务量集中在午高峰和晚高峰两个高峰期，所以高峰期并发请求量也是水涨船高，每天都要面对高并发的挑战。拿运单系统来举例，日常午高峰核心查询服务的 QPS 在 20 万以上，Redis 集群的 QPS 更是在百万级，数据库 QPS 也在 10 万级以上，TPS 在 2 万以上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这么大的流量下，主要的工作也是以围绕如何建设系统的稳定性和提升容量展开，下面主要从基础设施、数据库、架构、应用、规范这几方面谈谈如何建设高并发的系统。以下都是我个人这几年的一些经验总结，架构没有银弹，因此也称不上是最佳实践，&lt;strong&gt;仅供参考&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础设施&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分层架构中，最底层的就是基础设施。基础设置一般来说包含了物理服务器、IDC、部署方式等等。就像一个金字塔，基础设施就是金字塔的底座，只有底座稳定了，上层才能稳定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281515&quot; data-ratio=&quot;0.7694704049844237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GFGJTBibkQSE6UtK1pVFm8XbT9Kp7EolJic6sqRzyUiccaFGmHJfhs0vTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;642&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异地多活&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多活可以分为同城多活、异地多活等等，实现方式也有多种，比如阿里使用的单元化方案，饿了么使用的是多中心的方案，关于多活的实现可以参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32009822&quot; data-linktype=&quot;2&quot;&gt;饿了么多活实现分享&lt;/a&gt;。当时做多活的主要出发点是保证系统的高可用性，避免单 IDC 的单点故障问题，同时由于每个机房的流量都变成了总流量的 1/N，也变相提升了系统容量，在高并发的场景下可以抗更多的流量。下图是活的整体架构，来源于上面多活实现的分享文章中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281518&quot; data-ratio=&quot;0.6073684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8G2d95FyjbeTw9oHNUleu5HyTYqOm0jJI45vdueg2ziabrAFlKFjbkLxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库是整个系统最重要的组成部分之一，在高并发的场景下很大一部分工作是围绕数据库展开的，主要需要解决的问题是如何提升数据库容量。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;读写分离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网的大部分业务特点是读多写少，因此使用读写分离架构可以有效降低数据库的负载，提升系统容量和稳定性。核心思路是由主库承担写流量，从库承担读流量，且在读写分离架构中一般都是 1 主多从的配置，通过多个从库来分担高并发的查询流量。比如现在有 1 万 QPS 的以及 1K 的 TPS，假设在 1 主 5 从的配置下，主库只承担 1K 的 TPS，每个从库承担 2K 的 QPS，这种量级对 DB 来说是完全可接受的，相比读写分离改造前，DB 的压力明显小了许多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281516&quot; data-ratio=&quot;0.47295423023578365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GwZ22RbyBXKLiclsCpwbkvibWpjcOUF5m9BlhefYevibgIAkaj5teXp80g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;721&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式的好处是简单，几乎没有代码改造成本或只有少量的代码改造成本，只需要配置数据库主从即可。缺点也是同样明显的：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主从延迟&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 默认的主从复制是异步的，如果在主库插入数据后马上去从库查询，可能会发生查不到的情况。正常情况下主从复制会存在毫秒级的延迟，在 DB 负载较高的情况下可能存在秒级延迟甚至更久，但即使是毫秒级的延迟，对于实时性要求较高的业务来说也是不可忽视的。所以在一些关键的查询场景，我们会将查询请求绑定到主库来避免主从延迟的问题。关于主从延迟的优化网上也有不少的文章分享，这里就不再赘述。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;从库的数量是有限的&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个主库能挂载的从库数量是很有限的，没办法做到无限的水平扩展。从库越多，虽然理论上能承受的 QPS 就越高，但是从库过多会导致主库主从复制 IO 压力更大，造成更高的延迟，从而影响业务，所以一般来说只会在主库后挂载有限的几个从库。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;无法解决 TPS 高的问题&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从库虽然能解决 QPS 高的问题，但没办法解决 TPS 高的问题，所有的写请求只有主库能处理，一旦 TPS 过高，DB 依然有宕机的风险。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分库分表&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当读写分离不能满足业务需要时，就需要考虑使用分库分表模式了。当确定要对数据库做优化时，应该优先考虑使用读写分离的模式，只有在读写分离的模式已经没办法承受业务的流量时，我们才考虑分库分表的模式。分库分表模式的最终效果是把单库单表变成多库多表，如下图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281517&quot; data-ratio=&quot;0.45271317829457364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GU80ogQl4l5AaB6Xp5q0wW7boZyWyh7etTPe7YNNcYKuhWfWt9O7FSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来说下分表，分表可以分为垂直拆分和水平拆分。垂直拆分就是按业务维度拆，假设原来有张订单表有 100 个字段，可以按不同的业务纬度拆成多张表，比如用户信息一张表，支付信息一张表等等，这样每张表的字段相对来说都不会特别多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281514&quot; data-ratio=&quot;0.7862232779097387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8Gs4qjdLibPRywsIDlueAJT1IBU0CW7OXsXNnBvYbRWjaicocicsDyNsWAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;421&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平拆分是把一张表拆分成 N 张表，比如把 1 张订单表，拆成 512 张订单子表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281520&quot; data-ratio=&quot;0.9524940617577197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GXtZH8iaJnXYhG2KA0xcqQEhtDS2L9C221wneD1TrJNDEy3uTfsXgjow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;421&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实践中可以只做水平拆分或垂直拆分，也可以同时做水平及垂直拆分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281519&quot; data-ratio=&quot;0.9303944315545244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GdFveSZJNlKH4iaeJWEsIOVh860UpzqjQOBGlkZiceHYJYRS9tcRbWNBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;431&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完了分表，那分库是什么呢？分库就是把原来都在一个 DB 实例中的表，按一定的规则拆分到 N 个 DB 实例中，每个 DB 实例都会有一个 master，相当于是多 mater 的架构，同时为了保证高可用性，每个 master 至少要有 1 个 slave，来保证 master 宕机时 slave 能及时顶上，同时也能保证数据不丢失。拆分完后每个 DB 实例中只会有部分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是多 master 的架构，分库分表除了包含读写分离模式的所有优点外，还可以解决读写分离架构中无法解决的 TPS 过高的问题，同时分库分表理论上是可以无限横向扩展的，也解决了读写分离架构下从库数量有限的问题。当然在实际的工程实践中一般需要提前预估好容量，因为数据库是有状态的，如果发现容量不足再扩容是非常麻烦的，应该尽量避免。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分库分表的模式下可以通过不启用查询从库的方式来避免主从延迟的问题，也就是说读写都在主库，因为在分库后，每个 master 上的流量只占总流量的 1/N，大部分情况下能扛住业务的流量，从库只作为 master 的备份，在主库宕机时执行主从切换顶替 master 提供服务使用。说完了好处，再来说说分库分表会带来的问题，主要有以下几点：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;改造成本高&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表一般需要中间件的支持，常见的模式有两种：客户端模式和代理模式。客户端模式会通过在服务上引用 client 包的方式来实现分库分表的逻辑，比较有代表的是开源的 sharding JDBC。代理模式是指所有的服务不是直接连接 MySQL，而是通过连接代理，代理再连接到 MySQL 的方式，代理需要实现 MySQL 相关的协议。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281521&quot; data-ratio=&quot;0.833641404805915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GKZuDXZs3R8cvl8cBIGVS1FjU9ibCDmDUOr7QhtCrPmTU0MgEkbb4aRA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种模式各有优劣势，代理模式相对来说会更复杂，但是因为多了一层代理，在代理这层能做更多的事情，也比较方便升级，而且通过代理连接数据库，也能保证数据库的连接数稳定。使用客户端模式好处是相对来说实现比较简单，无中间代理，理论上性能也会更好，但是在升级的时候需要业务方改造代码，因此升级会比代理模式更困难。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务问题&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务中我们会使用事务来处理多个数据库操作，通过事务的 4 个特性——一致性、原子性、持久性、隔离性来保证业务流程的正确性。在分库分表后，会将一张表拆分成 N 张子表，这 N 张子表可能又在不同的 DB 实例中，因此虽然逻辑上看起来还是一张表，但其实已经不在一个 DB 实例中了，这就造成了无法使用事务的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常见的就是在批量操作中，在分库分表前我们可以同时把对多个订单的操作放在一个事务中，但在分库分表后就不能这么干了，因为不同的订单可能属于不同用户，假设我们按用户来分库分表，那么不同用户的订单表位于不同的 DB 实例中，多个 DB 实例显然没办法使用一个事务来处理，这就需要借助一些其他的手段来解决这个问题。在分库分表后应该要尽量避免这种跨 DB 实例的操作，如果一定要这么使用，优先考虑使用补偿等方式保证数据最终一致性，如果一定要强一致性，常用的方案是通过分布式事务的方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;无法支持多维度查询&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表一般只能按 1-2 个纬度来分，这个维度就是所谓的&lt;code&gt;sharding key&lt;/code&gt;。常用的维度有用户、商户等维度，如果按用户的维度来分表，最简单的实现方式就是按用户 ID 来取模定位到在哪个分库哪个分表，这也就意味着之后所有的读写请求都必须带上用户 ID，但在实际业务中不可避免的会存在多个维度的查询，不一定所有的查询都会有用户 ID，这就需要我们对系统进行改造。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281523&quot; data-ratio=&quot;0.4780763790664781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GXILzicO8GXSic32fZiaphicftlAS8WEGoQ0kbD3HFbqcECfAWqQFKL5C1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能在分库分表后也支持多维度查询，常用的解决方案有两种，第一种是引入一张索引表，这张索引表是没有分库分表的，还是以按用户 ID 分库分表为例，索引表上记录各种维度与用户 ID 之间的映射关系，请求需要先通过其他维度查询索引表得到用户 ID，再通过用户 ID 查询分库分表后的表。这样，一来需要多一次 IO，二来索引表由于是没有分库分表的，很容易成为系统瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种方案是通过引入&lt;code&gt;NoSQL&lt;/code&gt;的方式，比较常见的组合是&lt;code&gt;ES+MySQL&lt;/code&gt;，或者&lt;code&gt;HBase+MySQL&lt;/code&gt;的组合等，这种方案本质上还是通过 NoSQL 来充当第一种方案中的索引表的角色，但是相对于直接使用索引表来说，&lt;code&gt;NoSQL&lt;/code&gt;具有更好的水平扩展性和伸缩性，只要设计得当，一般不容易成为系统的瓶颈。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据迁移&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表一般是需要进行数据迁移的，通过数据迁移将原有的单表数据迁移到分库分表后的库表中。数据迁移的方案常见的有两种，第一种是停机迁移，顾名思义，这种方式简单粗暴，好处是能一步到位，迁移周期短，且能保证数据一致性，坏处是对业务有损，某些关键业务可能无法接受几分钟或更久的停机迁移带来的业务损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一种方案是双写，这主要是针对新增的增量数据，存量数据可以直接进行数据同步，关于如何进行双写迁移网上已经有很多分享了，这里也就不赘述，核心思想是同时写老库和新库。双写的好处是对业务的影响小，但也更复杂，迁移周期更长，容易出现数据不一致问题，需要有完整的数据一致性保证方案支持。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离模式和分库分表模式推荐优先使用读写分离模式，只有在不满业务需求的情况才才考虑使用分库分表模式。原因是分库分表模式虽然能显著提升数据库的容量，但会增加系统复杂性，而且由于只能支持少数的几个维度读写，从某种意义上来说对业务系统也是一种限制，因此在设计分库分表方案的时候需要结合具体业务场景，更全面的考虑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发系统建设中，架构同样也是非常重要的，这里分享缓存、消息队列、资源隔离等等模式的一些经验。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统架构中缓存是最有效的利器，可以说没有之一。缓存的最大作用是可以提升系统性能，保护后端存储不被大流量打垮，增加系统的伸缩性。缓存的概念最早来源于 CPU 中，为了提高 CPU 的处理速度，引入了 L1、L2、L3 三级高速缓存来加速访问，现在系统中使用的缓存也是借鉴了 CPU 中缓存的做法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存是个非常大的话题，可以单独写一本书也毫不夸张，在这里总结一下我个人在运单系统设计和实现缓存的时候遇到的一些问题和解决方案。缓存主要分为本地缓存和分布式缓存，本地缓存如&lt;code&gt;Guava Cache&lt;/code&gt;、&lt;code&gt;EHCache&lt;/code&gt;等，分布式缓存如&lt;code&gt;Redis&lt;/code&gt;、&lt;code&gt;Memcached&lt;/code&gt;等，在运单系统中使用的主要以分布式缓存为主。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何保证缓存与数据库的数据一致性&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是如何保证缓存与数据库的数据一致性问题，基本在使用缓存的时候都会遇到这个问题，同时这也是个高频的面试题。在我负责的运单系统中使用缓存这个问题就更突出了，首先运单是会频繁更新的，并且运单系统对数据一致性的要求是非常高的，基本不太能接受数据不一致，所以不能简单的通过设置一个过期时间的方式来失效缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于缓存读写的模式推荐阅读耗子叔的文章：&lt;a href=&quot;https://coolshell.cn/articles/17416.html&quot; data-linktype=&quot;2&quot;&gt;缓存更新的套路&lt;/a&gt;，里面总结了几种常用的读写缓存的套路，我在运单系统中的缓存读写模式也是参考了文章中的&lt;code&gt;Write through&lt;/code&gt;模式，通过伪代码的方式大概是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;lock(运单ID) {&lt;br/&gt; //...&lt;br/&gt; &lt;br/&gt;    // 删除缓存&lt;br/&gt;   deleteCache();&lt;br/&gt;    // 更新DB&lt;br/&gt;   updateDB();&lt;br/&gt;    // 重建缓存&lt;br/&gt;   reloadCache()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是&lt;code&gt;Write through&lt;/code&gt;模式，那对缓存的更新就是在写请求中进行的。首先为了防止并发问题，写请求都需要加分布式锁，锁的粒度是以运单 ID 为 key，在执行完业务逻辑后，先删除缓存，再更新 DB，最后再重建缓存，这些操作都是同步进行的，在读请求中先查询缓存，如果缓存命中则直接返回，如果缓存不命中则查询 DB，然后直接返回，也就是说在读请求中不会操作缓存，这种方式把缓存操作都收敛在写请求中，且写请求是加锁的，有效防止了读写并发导致的写入脏缓存数据的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存数据结构的设计&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存要避免大 key 和热 key 的问题。举个例子，如果使用&lt;code&gt;redis&lt;/code&gt;中的&lt;code&gt;hash&lt;/code&gt;数据结构，那就比普通字符串类型的 key 更容易有大 key 和热 key 问题，所以如果不是非要使用&lt;code&gt;hash&lt;/code&gt;的某些特定操作，可以考虑把&lt;code&gt;hash&lt;/code&gt;拆散成一个一个单独的 key/value 对，使用普通的&lt;code&gt;string&lt;/code&gt;类型的 key 存储，这样可以防止&lt;code&gt;hash&lt;/code&gt;元素过多造成的大 key 问题，同时也可以避免单&lt;code&gt;hash key&lt;/code&gt;过热的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;读写性能&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于读写性能主要有两点需要考虑，首先是写性能，影响写性能的主要因素是 key/value 的数据大小，比较简单的场景可以使用&lt;code&gt;JSON&lt;/code&gt;的序列化方式存储，但是在高并发场景下使用 JSON 不能很好的满足性能要求，而且也比较占存储空间，比较常见的替代方案有&lt;code&gt;protobuf&lt;/code&gt;、&lt;code&gt;thrift&lt;/code&gt;等等，关于这些序列化/反序列化方案网上也有一些性能对比，参考&lt;a href=&quot;https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking&quot; data-linktype=&quot;2&quot;&gt;thrift-protobuf-compare - Benchmarking.wiki&lt;/a&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281522&quot; data-ratio=&quot;0.6240928882438317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GXe7a51sUnkazZCZFWBuytJ7EdiajFds9yIysF2Vibet4ZLZPPt9VXxUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;689&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读性能的主要影响因素是每次读取的数据包的大小。在实践中推荐使用&lt;code&gt;redis pipeline&lt;/code&gt;+批量操作的方式，比如说如果是字符串类型的 key，那就是&lt;code&gt;pipeline+mget&lt;/code&gt;的方式，假设一次&lt;code&gt;mget&lt;/code&gt;10 个 key，100 个&lt;code&gt;mget&lt;/code&gt;为一批 pipeline，那一次网络 IO 就可以查询 1000 个缓存 key，当然这里具体一批的数量要看缓存 key 的数据包大小，没有统一的值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;适当冗余&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适当冗余的意思是说我们在设计对外的业务查询接口的时候，可以适当的做一些冗余。这个经验是来自于当时我们在设计运单系统对外查询接口的时候，为了追求通用性，将接口的返回值设计成一个大对象，把运单上的所有字段都放在了这个大对象里面直接对外暴露了，这样的好处是不需要针对不同的查询方开发不同的接口了，反正字段就在接口里了，要什么就自己取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么做一开始是没问题的，但到我们需要对查询接口增加缓存的时候发现，由于所有业务方都通过这一个接口查询运单数据，我们没办法知道他们的业务场景，也就不知道他们对接口数据一致性的要求是怎么样的，比如能否接受短暂的数据一致性，而且我们也不知道他们具体使用了接口中的哪些字段，接口中有些字段是不会变的，有些字段是会频繁变更的，针对不同的更新频率其实可以采用不同的缓存设计方案，但很可惜，因为我们设计接口的时候过于追求通用性，在做缓存优化的时候就非常麻烦，只能按最坏的情况打算，也就是所有业务方都对数据一致性要求很高来设计方案，导致最后的方案在数据一致性这块花了大量的精力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们一开始设计对外查询接口的时候能做一些适当的冗余，区分不同的业务场景，虽然这样势必会造成有些接口的功能是类似的，但在加缓存的时候就能有的放矢，针对不同的业务场景设计不同的方案，比如关键的流程要注重数据一种的保证，而非关键场景则允许数据短暂的不一致来降低缓存实现的成本。同时在接口中最好也能将会更新的字段和不会更新的字段做一定的区分，这样在设计缓存方案的时候，针对不会更新的字段，可以设置一个较长的过期时间，而会更新的字段，则只能设置较短的过期时间，并且需要做好缓存更新的方案设计来保证数据一致性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发系统的架构中，消息队列（MQ）是必不可少的，当大流量来临时，我们通过消息队列的异步处理和削峰填谷的特性来增加系统的伸缩性，防止大流量打垮系统，此外，使用消息队列还能使系统间达到充分解耦的目的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281524&quot; data-ratio=&quot;0.18876755070202808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GRH2o1UFatv6MOyvM2OR99L7mrWUdOnGF35JG9ZOW5UR0uz9t6999uQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列的核心模型由生产者（Producer）、消费者（Consumer）和消息中间件（Broker）组成。目前业界常用的开源解决方案有&lt;code&gt;ActiveMQ&lt;/code&gt;、&lt;code&gt;RabbitMQ&lt;/code&gt;、&lt;code&gt;Kafka&lt;/code&gt;、&lt;code&gt;RocketMQ&lt;/code&gt;和近年比较火的&lt;code&gt;Pulsar&lt;/code&gt;，关于各种消息中间件的对比可以参考文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/401416746&quot; data-linktype=&quot;2&quot;&gt;消息队列背后的设计思想&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用消息队列后，可以将原本同步处理的请求，改为通过消费 MQ 消息异步消费，这样可以减少系统处理的压力，增加系统吞吐量，关于如何使用消息队列有许多的分享的文章，这里我的经验是在考虑使用消息队列时要结合具体的业务场景来决定是否引入消息队列，因为使用消息队列后其实是增加了系统的复杂性的，原来通过一个同步请求就能搞定的事情，需要引入额外的依赖，并且消费消息是异步的，异步天生要比同步更复杂，还需要额外考虑消息乱序、延迟、丢失等问题，如何解决这些问题又是一个很大话题，天下没有免费的午餐，做任何架构设计是一个取舍的过程，需要仔细考虑得失后再做决定。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务治理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务治理是个很大的话题，可以单独拿出来说，在这里我也把它归到架构中。服务治理的定义是&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般指独立于业务逻辑之外，给系统提供一些可靠运行的系统保障措施。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的保障措施包括服务的注册发现、可观测性（监控）、限流、超时、熔断等等，在微服务架构中一般通过服务治理框架来完成服务治理，开源的解决方案包括&lt;code&gt;Spring Cloud&lt;/code&gt;、&lt;code&gt;Dubbo&lt;/code&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统中，服务治理是非常重要的一块内容，相比于缓存、数据库这些大块的内容，服务治理更多的是细节，比如对接口的超时设置到底是 1 秒还是 3 秒，怎么样做监控等等，有句话叫细节决定成败，有时候就是因为一个接口的超时设置不合理而导致大面积故障的事情，我曾经也是见识过的，特别是在高并发的系统中，一定要注意这些细节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281528&quot; data-ratio=&quot;1.0740740740740742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GAjSWhLd7S1Q7kXVdzIiaDfjTtiaiaO5U86NNET4QDvycdbic9NhldFllVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;432&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于超时的原则是：&lt;strong&gt;一切皆有超时&lt;/strong&gt;。不管是 RPC 调用、Redis 操作、消费消息/发送消息、DB 操作等等，都要有超时。之前就遇到过依赖了外部组件，但是没有设置合理的超时，当外部依赖出现故障时，把服务所有的线程全部阻塞导致资源耗尽，无法响应外部请求，从而引发故障，这些都是“血”的教训。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了要设置超时，还要设置合理的超时也同样重要，像上面提到的故障即使设置了超时，但是超时太久的话依然会因为外部依赖故障而把服务拖垮。如何设置一个合理的超时是很有讲究的，可以从是否关键业务场景、是否强依赖等方面去考虑，没有什么通用的规则，需要结合具体的业务场景来看。比如在一些 C 端展示接口中，设置 1 秒的超时似乎没什么问题，但在一些对性能非常敏感的场景下 1 秒可能就太久了，总之，需要结合具体的业务场景去设置，但无论怎么样，原则还是那句话：一切皆有超时。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;监控&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监控就是系统的眼睛，没有监控的系统就像一个黑盒，从外部完全不知道里面的运行情况，我们就无法管理和运维这个系统。所以，监控系统是非常重要的。系统的可观测性主要包含三个部分——&lt;code&gt;logging&lt;/code&gt;、&lt;code&gt;tracing&lt;/code&gt;、&lt;code&gt;metrics&lt;/code&gt;。主要是使用的自研的监控系统，不得不说真的是非常的好用，具体的介绍可以参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&amp;amp;mid=2247494222&amp;amp;idx=1&amp;amp;sn=143a8ad9e4da4bdf9e7a6c4c738e3bf2&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;饿了么 EMonitor 演进史&lt;/a&gt;。在建设高并发系统时，我们一定要有完善的监控体系，包括系统层面的监控（CPU、内存、网络等）、应用层面的监控（JVM、性能等）、业务层面的监控（各种业务曲线等）等，除了监控还要有完善的报警，因为不可能有人 24 小时盯着监控，一旦有什么风险一定要报警出来，及时介入，防范风险于未然。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;熔断&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务框架中一般都会内置熔断的特性，熔断的目的是为了在下游服务出故障时保护自身服务。熔断的实现一般会有一个断路器（&lt;code&gt;Crit Breaker&lt;/code&gt;），断路器会根据接口成功率/次数等规则来判断是否触发熔断，断路器会控制熔断的状态在关闭-打开-半打开中流转。熔断的恢复会通过时间窗口的机制，先经历半打开状态，如果成功率达到阈值则关闭熔断状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281525&quot; data-ratio=&quot;0.5315682281059063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GYpEJA8eeICicFoveyBgicNAvhqFJ4v3OIFWW3ayWricJ4rIuRoqRpujZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;491&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有什么特殊需求的话在业务系统中一般是不需要针对熔断做什么的，框架会自动打开和关闭熔断开关。可能需要注意的点是要避免&lt;strong&gt;无效的熔断&lt;/strong&gt;，什么是无效的熔断呢？在以前碰到过一个故障，是服务的提供方在一些正常的业务校验中抛出了不合理的异常（比如系统异常），导致接口熔断影响正常业务。所以我们在接口中抛出异常或者返回异常码的时候一定要区分业务和系统异常，一般来说业务异常是不需要熔断的，如果是业务异常而抛出了系统异常，会导致被熔断，正常的业务流程就会受到影响。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;降级&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;降级不是一种具体的技术，更像是一种架构设计的方法论，是一种丢卒保帅的策略，核心思想就是在异常的情况下限制自身的一些能力，来保证核心功能的可用性。降级的实现方式有许多，比如通过配置、开关、限流等等方式。降级分为主动降级和被动降级。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281526&quot; data-ratio=&quot;0.30182599355531686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GsicHLficml1ohkvzqfuPPnX6BJ4oGj8zex5whz80XJFyucAxRXIV1VicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;931&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在电商系统大促的时候会把一些非核心的功能暂时关闭，来保证核心功能的稳定性，或者当下游服务出现故障且短时间内无法恢复时，为了保证自身服务的稳定性而把下游服务降级，这些都是主动降级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被动降级指的是，比如调用了下游一个接口，但是接口超时了，这个时候为了让业务流程能继续执行下去，一般会选择在代码中&lt;code&gt;catch&lt;/code&gt;异常，打印一条错误日志，然后继续执行业务逻辑，这种降级是被动的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统中做好降级是非常重要的。举个例子来说，当请求量很大的时候难免有超时，如果每次超时业务流程都中断了，那么会大大影响正常业务，合理的做法是我们应该仔细区分强弱依赖，对于弱依赖采用被动降级的降级方式，而对于强依赖是不能进行降级的。降级与熔断类似，也是对自身服务的保护，避免当外部依赖故障时拖垮自身服务，所以，我们要做好充分的降级预案。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限流&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于限流的文章和介绍网上也有许多，具体的技术实现可以参考网上文章。关于限流我个人的经验是在设置限流前一定要通过压测等方式充分做好系统容量的预估，不要拍脑袋，限流一般来说是有损用户体验的，应该作为一种兜底手段，而不是常规手段。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;资源隔离&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源隔离有各种类型，物理层面的服务器资源、中间件资源，代码层面的线程池、连接池，这些都可以做隔离。这里介绍的资源隔离主要是应用部署层面的，比如&lt;code&gt;Set化&lt;/code&gt;等等。上文提到的异地多活也算是 Set 化的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负责运单系统的期间也做过一些类似的资源隔离上的优化。背景是当时出遇到过一个线上故障，原因是某服务部署的服务器都在一个集群，没有按流量划分各自单独的集群，导致关键业务和非关键业务流量互相影响而导致的故障。因此，在这个故障后我也是决定对服务器做按集群隔离部署，隔离的维度主要是按业务场景区分，分为关键集群、次关键集群和非关键集群三类，这样能避免关键和非关键业务互相影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281527&quot; data-ratio=&quot;0.6150537634408603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8G384ia8MLb0EGqA8c1Rg0icYHG0EsnyatZJsPBEbFf7K1Zkv8tKaqic17A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;930&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在架构方面，我个人也不是专业的架构师，也是一直在学习相关技术和方法论，上面介绍的很多技术和架构设计模式都是在工作中边学习边实践。如果说非要总结一点经验心得的话，我觉得是注重细节。个人认为架构不止高大上的方法论，技术细节也是同样重要的，正所谓细节决定成败，有时候忘记设置一个小小的超时，可能导致整个系统的崩溃。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的系统中，在应用层面能做的优化也是非常多的，这部分主要分享关于补偿、幂等、异步化、预热等这几方面的优化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;补偿&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构下，会按各业务领域拆分不同的服务，服务与服务之前通过 RPC 请求或 MQ 消息的方式来交互，在分布式环境下必然会存在调用失败的情况，特别是在高并发的系统中，由于服务器负载更高，发生失败的概率会更大，因此补偿就更为重要。常用的补偿模式有两种：&lt;strong&gt;定时任务模式&lt;/strong&gt;或者&lt;strong&gt;消息队列模式&lt;/strong&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定时任务模式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时任务补偿的模式一般是需要配合数据库的，补偿时会起一个定时任务，定时任务执行的时候会扫描数据库中是否有需要补偿的数据，如果有则执行补偿逻辑，这种方案的好处是由于数据都持久化在数据库中了，相对来说比较稳定，不容易出问题，不足的地方是因为依赖了数据库，在数据量较大的时候，会对数据库造成一定的压力，而且定时任务是周期性执行的，因此一般补偿会有一定的延迟。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列模式&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列补偿的模式一般会使用消息队列中延迟消息的特性。如果处理失败，则发送一个延迟消息，延迟 N 分钟/秒/小时后再重试，这种方案的好处是比较轻量级，除了 MQ 外没有外部依赖，实现也比较简单，相对来说也更实时，不足的地方是由于没有持久化到数据库中，有丢失数据的风险，不够稳定。因此，我个人的经验是在关键链路的补偿中使用定时任务的模式，非关键链路中的补偿可以使用消息队列的模式。除此之外，在补偿的时候还有一个特别重要的点就是&lt;strong&gt;幂等性&lt;/strong&gt;设计。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;幂等&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等操作的特点是&lt;strong&gt;其任意多次执行所产生的影响均与一次执行的影响相同&lt;/strong&gt;，体现在业务上就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为发起多次而产生副作用。在分布式系统中发生系统错误是在所难免的，当发生错误时，会使用重试、补偿等手段来提高容错性，在高并发的系统中发生系统错误的概率就更高了，所以这时候接口幂等就非常重要了，可以防止多次请求而引起的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等的实现需要通过一个唯一的业务 ID 或者 Token 来实现，一般的流程是先在 DB 或者缓存中查询唯一的业务 ID 或者 token 是否存在，且状态是否为已处理，如果是则表示是重复请求，那么我们需要幂等处理，即不做任何操作，直接返回即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281530&quot; data-ratio=&quot;1.3897435897435897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GJgo1ASUttJBdm8PvTJicZnXQMIu6ySA3xunXdiciccdnMRKOr8m1NuamQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;390&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做幂等性设计的时候需要注意的是并不是所有的场景都要做幂等，比如用户重复转账、提现等等，因为幂等会让外部系统的感知是调用成功了，并没有阻塞后续流程，但其实我们系统内部是没有做任何操作的，类似上面提到的场景，会让用户误以为操作已成功。所以说要仔细区分需要幂等的业务场景和不能幂等的业务场景，对于不能幂等的业务场景还是需要抛出业务异常或者返回特定的异常码来阻塞后续流程，防止引发业务问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;异步化&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到的消息队列也是一种异步化，除了依赖外部中间件，在应用内我们也可以通过线程池、协程的方式做异步化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281531&quot; data-ratio=&quot;0.3767186067827681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GNWwHecYicpVCzuib24yFIlHm1gibzza2Br61a92BKqx1xDloYEUhObBeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1091&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于线程池的实现原理，拿 Java 中线程池的模型来举例，核心是通过任务队列和复用线程的方式相配合来实现的，网上关于这些分享的文章也很多。在使用线程池或者协程等类似技术的时候，我个人的经验是有以下两点是需要特别注意的：&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关键业务场景需要配合补偿&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，不管是线程池也好，协程也好，都是基于内存的，如果服务器意外宕机或者重启，内存中的数据是会丢失的，而且线程池在资源不足的时候也会拒绝任务，所以在一些关键的业务场景中如果使用了线程池等类似的技术，需要配合补偿一块使用，避免内存中数据丢失造成的业务影响。在我维护的运单系统中有一个关键的业务场景是入单，简单来说就是接收上游请求，在系统中生成运单，这是整个物流履约流量的入口，是特别关键的一个业务场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为生成运单的整个流程比较长，依赖外部接口有 10 几个，所以当时为了追求高性能和吞吐率，设计成了异步的模式，也就是在线程池中处理，同时为了防止数据丢失，也做了完善的补偿措施，这几年时间入单这块基本没有出过问题，并且由于采用了异步的设计，性能非常好，那我们具体是怎么做的呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281533&quot; data-ratio=&quot;0.46837763519706693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GibBVInyiaBswYhUo6Msm57yo9cPCpGUtFm9Fn3ywAuICkebUN1Q0ymDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1091&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的流程是在接收到上游的请求后，第一步是将所有的请求参数落库，这一步是非常关键的，如果这一步失败，那整个请求就失败了。在成功落库后，封装一个 Task 提交到线程池中，然后直接对上游返回成功。后续的所有处理都是在线程池中进行的，此外，还有一个定时任务会定时补偿，补偿的数据源就是在第一步中落库的数据，每一条落库的记录会有一个 flag 字段来表示处理状态，如果发现是未处理或者处理失败，则通过定时任务再触发补偿逻辑，补偿成功后再将 flag 字段更新为处理成功。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做好监控&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务中像 RPC 接口调用、MQ 消息消费，包括中间件、基础设施等的监控，这些基本都会针对性的做完善的监控，但是类似像线程池一般是没有现成监控的，需要使用方自行实现上报打点监控，这点很容易被遗漏。我们知道线程池的实现是会有内存队列的，而我们也一般会对内存队列设置一个最大值，如果超出了最大值可能会丢弃任务，这时候如果没有监控是发现不了类似的问题的，所以，使用线程池一定要做好监控。那么线程池有哪些可以监控的指标呢，按我的经验来说，一般会上报线程池的&lt;strong&gt;活跃线程数&lt;/strong&gt;以及&lt;strong&gt;工作队列的任务个数&lt;/strong&gt;，这两个指标我认为是最重要的，其他的指标就见仁见智了，可以结合具体业务场景来选择性上报。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;预热&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Warm Up。当系统长期处于低水位的情况下，流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考网上的定义，说白了，就是如果服务一直在低水位，这时候突然来一波高并发的流量，可能会一下子把系统打垮。系统的预热一般有 JVM 预热、缓存预热、DB 预热等，通过预热的方式让系统先“热”起来，为高并发流量的到来做好准备。预热实际应用的场景有很多，比如在电商的大促到来前，我们可以把一些热点的商品提前加载到缓存中，防止大流量冲击 DB，再比如 Java 服务由于 JVM 的动态类加载机制，可以在启动后对服务做一波压测，把类提前加载到内存中，同时还有可以提前触发 JIT 编译、Code cache 等等好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种预热的思路是利用业务的特性做一些&lt;strong&gt;预加载&lt;/strong&gt;，比如我们在维护运单系统的时候做过这样一个优化，在一个正常的外卖业务流程中是用户下单后到用户交易系统生成订单，然后经历支付-&amp;gt;商家接单-&amp;gt;请求配送这样一个流程，所以说从用户下单到请求配送这之间有秒级到分钟级的时间差，我们可以通过感知用户下单的动作，利用这时间差来提前加载一些数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281529&quot; data-ratio=&quot;0.4008559201141227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GQAmMkP7x9zuuem1j0meLE33TpwxPiaMK46RI5uqKSMRlS6so0T5l79Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;701&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在实际请求到来的时候只需要到缓存中获取即可，这对于一些比较耗时的操作提升是非常大的，之前我们利用这种方式能提升接口性能 50%以上。当然有个点需要注意的就是如果对于一些可能会变更的数据，可能就不适合预热，因为预热后数据存在缓存中，后面就不会再去请求接口了，这样会导致数据不一致，这是需要特别注意的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做高并发系统设计的时候我们总是会特别关注架构、基础设施等等，这些的确非常重要，但其实在应用层面能做的优化也是非常多的，而且成本会比架构、基础设施的架构优化低很多。很多时候在应用层面做的优化需要结合具体的业务场景，利用特定的业务场景去做出合理的设计，比如缓存、异步化，我们就需要思考哪些业务场景能缓存，能异步化，哪些就是需要同步或者查询 DB，一定要结合业务才能做出更好的设计和优化。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;规范&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是关于建设高并发系统经验分享的最后一个部分了，但我认为规范的重要性一点都不比基础设施、架构、数据库、应用低，可能还比这些都更重要。根据二八定律，在软件的整个生命周期中，我们花了 20%时间创造了系统，但要花 80%的时间来维护系统，这也让我想起来一句话，有人说代码主要是给人读的，顺便给机器运行，其实都是体现了可维护性的重要性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们使用了高大上的架构、做了各种优化之后，系统确实有了一个比较好的设计，但问题是怎么在后续的维护过程中防止架构腐化呢，这时候就需要规范了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规范包括代码规范、变更规范、设计规范等等，当然这里我不会介绍如何去设计这些规范，我更想说的是我们一定要重视规范，只有在有了规范之后，系统的可维护性才能有保证。根据破窗理论，通过各种规范我们尽量不让系统有第一扇破窗产生。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多关于设计、优化的方法，最后想再分享两点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一点就是有句著名的话——“&lt;strong&gt;过早优化是万恶之源&lt;/strong&gt;”，个人非常认同，我做的所有这些设计和优化，都是在系统遇到实际的问题或瓶颈的时候才做的，切忌不要脱离实际场景过早优化，不然很可能做无用功甚至得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二点是在设计的时候要遵循&lt;strong&gt;KISS 原则&lt;/strong&gt;，也就是 Keep it simple, stupid。简单意味着维护性更高，更不容易出问题，正所谓大道至简，或许就是这个道理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;502281532&quot; data-ratio=&quot;0.5663461538461538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauAibJLKtdnV4czk0ibibVqX8GlCLQhILGwhoOKIBpuodToef1jbGspTfHTkuGsOXBzibyIdqnOax1EUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1040&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些都是我在工作期间维护高并发系统的一些经验总结，鉴于篇幅和个人技术水平原因，可能有些部分没有介绍的特别详细和深入，算是抛砖引玉吧。如果有什么说的不对的地方也欢迎指出，同时也欢迎交流和探讨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;欢迎在视频号参与 1024程序员节 话题活动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281477&quot; data-galleryid=&quot;&quot; data-ratio=&quot;5.052&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvaudn5eaH1DhtibTzdpZk6eXKSfOGA4ibdcYJIeGE7dC59nMBV9XoqwNGO6hwibJ1iaVia0My6o3YDxmvjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>