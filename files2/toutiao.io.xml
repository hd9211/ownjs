<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>eb8e9206e54416ac1e29ba4d3f9c7a31</guid>
<title>面试写：如何优雅地给对象的所有方法添加异常处理</title>
<link>https://toutiao.io/k/r81a6pj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNDMyMTg4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wIDSOebZK4NvWoUN1gSpNiaxwF4VLvroSV4fibB1a5iaLEaR23sVIW9ickg4StvsXlxnPpslKAltA6mvJUhkT2PsaA/0?wx_fmt=png&quot; data-nickname=&quot;JavaScript 每日一练&quot; data-alias=&quot;&quot; data-signature=&quot;每天一道JavaScript 实战题，让大家平时多多积累实用的知识，提高开发效率，才有更多的时间摸鱼。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码不会全部按照我们的预期运行，可能会有意料之外的情况，为了保证程序的健壮性，要进行异常处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一个对象的所有方法，都应该做异常处理，但是，如果每个方法都加 try catch 又太麻烦：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;    aaa() {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// aaa&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt;(e) {&lt;br/&gt;            &lt;span&gt;// xxxx&lt;/span&gt;&lt;br/&gt;        } &lt;br/&gt;    },&lt;br/&gt;    bbb() {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// bbb&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt;(e) {&lt;br/&gt;            &lt;span&gt;// xxxx&lt;/span&gt;&lt;br/&gt;        } &lt;br/&gt;    },&lt;br/&gt;    ccc() {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// ccc&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt;(e) {&lt;br/&gt;            &lt;span&gt;// xxxx&lt;/span&gt;&lt;br/&gt;        } &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有一种方式既能对所有方法做异常处理，又不用重复写这么多次呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有，就是代理模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理模式是通过对目标对象做一层包装，提供和目标对象同名的方法，最终的功能实现还是调用目标对象的方法，但可以额外添加一些职责，比如日志、权限等，透明地对目标对象做一些扩充。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 React 里的高阶组件就是代理模式的实现，可以透明的扩展被包装的组件的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，这里的异常处理，也可以用代理的方式来做。但不用完全自己实现，ES6 提供了 Proxy，可以基于它来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义 createProxy 方法来实现代理，创建一个 Proxy 对象，对目标对象 target 做一层包装，定义 get、set 时的处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createProxy&lt;/span&gt;(&lt;span&gt;target&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; proxy = createExceptionProxy();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(target, {&lt;br/&gt;        &lt;span&gt;get&lt;/span&gt;: proxy,&lt;br/&gt;        &lt;span&gt;set&lt;/span&gt;: proxy&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createExceptionProxy&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;span&gt;target, prop&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!(prop &lt;span&gt;in&lt;/span&gt; target)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; target[prop] === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; createExceptionZone(target, prop);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; target[prop];&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 target 不包含 prop，就返回空，否则返回对应的属性值 target[prop]。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果属性值是函数，则做一层包装:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createExceptionZone&lt;/span&gt;(&lt;span&gt;target, prop&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;span&gt;...args&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; result;&lt;br/&gt;        ExceptionsZone.run(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          result = target[prop](...args);&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终的功能实现还是调用 target，传入参数，把调用结果作为代理方法的结果返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包装这一层的目的是为了做异常处理，也就是 ExceptionsZone.run 做的事情：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionsZone&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; exceptionHandler = &lt;span&gt;new&lt;/span&gt; ExceptionHandler();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; run(callback) {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        callback();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.exceptionHandler.handle(e);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用目标方法，并做 try catch，当出现异常的时候，用 ExceptionHandler 来处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的异常处理我们就简单打印下日志：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    handle(exception) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;记录错误：&#x27;&lt;/span&gt;,exception.message, exception.stack);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就实现了给目标对象的所有方法添加异常处理的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;guang&#x27;&lt;/span&gt;,&lt;br/&gt;    say() {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hi, I\&#x27;m &#x27;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.name);&lt;br/&gt;    },&lt;br/&gt;    coding() {&lt;br/&gt;        &lt;span&gt;//xxx&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;bug&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    coding2() {&lt;br/&gt;        &lt;span&gt;//xxx&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;bug2&#x27;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proxy = createProxy(obj);&lt;br/&gt;&lt;br/&gt;proxy.say();&lt;br/&gt;proxy.coding();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 coding、coding2 方法都会抛出异常，但并没有做异常处理，我们用代理给它加上：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0471869328493648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhOauW8OLCDUN2yyyeT0ykX9a2pcRibpDmF3HzcFicGlD8dt07Fr5LYztb7X2FKQcYEnCWIxnynKAiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们成功地通过代理模式给对象方法添加了异常处理！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是现在这样还是有问题的，比如我把 coding 方法改为 async 的就不行了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9936170212765958&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhOauW8OLCDUN2yyyeT0ykXsKJH1Bcc0mWTxA5nVfV89TODbyRvsQOrjNZlcofGeVobwv3Co1cBzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么办呢？能不能统一对异步和同步方法做代理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实没办法，因为没法区分方法是同步还是异步，而且这两种方法的调用方式也不同，但我们可以单独提供一个 runner 方法来运行这些异步逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionsZone&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; exceptionHandler = &lt;span&gt;new&lt;/span&gt; ExceptionHandler();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; asyncRun(callback) {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;await&lt;/span&gt; callback();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.exceptionHandler.handle(e);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后这样运行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; ExceptionsZone.asyncRun(proxy.coding2);&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能处理异步逻辑中的异常了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9741035856573705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhOauW8OLCDUN2yyyeT0ykXOosScx9G5iaVkQYmbDp6OMHXn3kvKnM1IsrgWrPzNzjegibYTU6XrIicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们通过代理的方式给对象的所有同步方法添加了异常处理，然后又提供了运行异步方法的 runner 函数，对异步的异常做了处理，结合这两种方式，优雅地给目标对象的所有方法加上了异常处理。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能你会说，代理就代理，你定义这么多 class 干啥？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这段逻辑是我从 Nest.js 源码里摘出来的，它源码里就是这样来给对象添加异常处理的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0945674044265594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhOauW8OLCDUN2yyyeT0ykXQE6bIOKyBs6YfAwZoDib7Yu2Ou9CrfparHZ4Zc3QGJo6aLPpc4RMSsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;994&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步逻辑也是单独提供了个方法来运行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3582089552238806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGhOauW8OLCDUN2yyyeT0ykXqNezpkKDO9IjV4JTRg68XJdMsm4qiaaQiazCKLCibHB9gTzTaqjbrHomQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得这个透明给对象添加异常处理的方式很优雅，就把它从 Nest.js 源码里抽了出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证健壮性，我们要对所有可能报错的代码添加异常处理，但是每个方法都添加 try catch 又太麻烦，所以我们利用 Proxy 实现了代理，透明的给对象的所有方法都添加上了异常处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，代理添加的只是同步的异常处理，并没有捕获异步逻辑的异常，我们可以单独一个一个函数来运行异步方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合代理 + 提供运行异步方法的 runner 这两种方式，就能给一个没有做任何异常处理的对象加上异常处理。是不是很优雅～&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;欢迎&lt;/span&gt;&lt;code&gt;长按图片加刷碗智为好友&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;我会第一时间和你分享前端行业趋势，学习途径，搞怪趣事，生活中的另一面幽默等等。&lt;span&gt;新的一年我们一起洗刷刷！！！！！！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;68&quot; data-cropselx2=&quot;361&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;385&quot; data-fileid=&quot;100021057&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8948194662480377&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy55d6jntYlvCrOVACPvqJkZuaOwJiaecIvQdzSq8lLVBibrGRZPxlWKvV7sGqC3CtOjZ1QxHu56tWZwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aede97631824d9cc439684347f4c5fb9</guid>
<title>MySQL-Seconds_behind_master的精度误差</title>
<link>https://toutiao.io/k/qgmx99e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h1&gt;MySQL-Seconds_behind_master的精度误差&lt;/h1&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;Seconds_behind_master是我们观察主从延迟的一个重要指标。但任何指标所能表示的精度都是有限的。例如用精度只能到秒的指标去衡量毫秒级的表现就会产生非常大的误差。如果再以此误差去分析问题，就会让思维走上弯路。例如用Seconds_behind_master去评估1s内的主从延迟就是一个典型的例子。&lt;/p&gt;&lt;h2&gt;问题现场&lt;/h2&gt;&lt;p&gt;在一些问题的排查中，我们注意到一个很奇怪的现象。那就是相同配置的从库表现出来的主从延迟差距有将近500ms。而这两个从库之间的差别就是所在的机房不一样(和主库都不在同一个机房)。如下图所示：&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43105756358768405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRS2CtQsRjRiaJLtH5B5Ewnkw7BJibk9tW4wdPSpiadPGpYa3CSycfic1hLTn2ThP9Bichxsvfh8gzk7wXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1494&quot;/&gt;&lt;/p&gt;&lt;h2&gt;网络问题&lt;/h2&gt;&lt;p&gt;难道是网络问题？那我们ping一下吧，最多也就相差1ms。那么还有499ms去哪里了呢，看来还得继续挖掘。&lt;/p&gt;&lt;h2&gt;Seconds_behind_master的取点数据&lt;/h2&gt;&lt;p&gt;直觉上来说网络问题不可能导致500ms这么大的误差，而机器配置和MySQL版本又是一样的。这就让笔者不得不怀疑这个兼容数据的准确性。所以就先看看这个500ms是怎么计算出来的。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5501955671447197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRS2CtQsRjRiaJLtH5B5EwnkwlqdPPrKZicbkXzuyicg9EBJeIXVs9cnOaQjCpkjo2VicaenW9kdZp8tPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;br/&gt;从监控取点数据来看从库C确实有主从延迟，不然为什么有那么多取点为0呢。&lt;/p&gt;&lt;h2&gt;Seconds_behind_master什么时候计算出来为1&lt;/h2&gt;&lt;p&gt;这时候笔者突然想到一个点，如果主从延迟一个是501ms一个是499ms，那么Seconds_behind_master计算的时候会不会采用四舍五入法。501ms(&amp;gt;=500ms)的就是1，499(&amp;lt;500ms)的就是0？为了了解这一问题，笔者就去翻了翻源码。&lt;/p&gt;&lt;h3&gt;Seconds_behind_master在MySQL中的计算源码&lt;/h3&gt;&lt;p&gt;计算这个指标的代码有很多微妙的分支，应对了各种corner case。在此笔者只列出和当前问题相关的源码。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;long time_diff= ((long)(time(0) - mi-&amp;gt;rli-&amp;gt;last_master_timestamp)&lt;br/&gt;                       - mi-&amp;gt;clock_diff_with_master);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前面time(0) - mi-&amp;gt;rli-&amp;gt;last_master_timestamp明显就是指时间差。但是，我们要考虑到一个很容易被忽略的常识，也就是不同机器的时间戳是不一样的！&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37978560490045943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRS2CtQsRjRiaJLtH5B5EwnkwV5bAibPqCEDVg5kibia6Ce5s7wyDacmYzLric9MgY8YgknRefib54lM7HfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot;/&gt;&lt;br/&gt;那么很明显的，如果主从实际延迟是0，但是计算的时候没有剔除掉机器时钟的差异。那么主从延迟就是6s。源码中的mi-&amp;gt;clock_diff_with_master就是去修正这个差距！而计算这个&lt;br/&gt;clock_diff_with_master就会引起不小的误差。&lt;/p&gt;&lt;h3&gt;什么时候计算clock_diff_with_master&lt;/h3&gt;&lt;p&gt;笔者在源码中翻阅时候注意到clock_diff_with_master不是每次都去计算的，而是在主从连接上或者重连(reconnect)的那一刻去计算一次。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;handle_slave_io&lt;br/&gt;    /* 建立主从连接 */&lt;br/&gt;    |-&amp;gt;safe_connect(thd, mysql, mi)) &lt;br/&gt;    /* connected: 主从连接成功后，计算一下主从clock_diff_with_master */&lt;br/&gt;    |-&amp;gt;get_master_version_and_clock&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就自然会导致下面的现象，假设一旦clock_diff_with_master计算有了误差。那么这个误差就会一直存在，直到下次重连为止！&lt;/p&gt;&lt;h3&gt;clock_diff_with_master跨秒误差&lt;/h3&gt;&lt;p&gt;接着笔者又注意到clock_diff_with_master精度只能到秒。那么自然就会出现下面这几种现象。为了简单起见，我们假设绝对时钟是从0开始，而且我们假设主从延迟是0。只看精度误差所能造成的影响。&lt;/p&gt;&lt;h3&gt;在实际主从延迟为0的情况下clock_diff_with_master计算出来是-1，Seconds_behind_master计算为1&lt;/h3&gt;&lt;p&gt;尽管有NTP，我们也不可能做到两台机器的时间戳在完全一致(除非两台机器有铯原子钟，那基本就没有毫秒级的误差了）。两台机器之间出现几百毫秒甚至数秒的延迟非常正常。例如假设我当前从库的clock是0.5s，主库的clock是1s。那么由于计算精度(只能到秒)的原因，实际实际只有0.5s的时间差会放大到1s。&lt;br/&gt;&lt;img data-ratio=&quot;0.49713631156930127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRS2CtQsRjRiaJLtH5B5EwnkwfQiamib0PvHcRQHUk1DaxY9y4Mj9Fe884aKjD0NbHHbOLnDbGuicb4fNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1746&quot;/&gt;&lt;br/&gt;那么我们现在可以计算出来在这种情况下Seconds_behind_master的平均值，在这里有一个预先假设就是我们取监控点的时间是随机的。&lt;br/&gt;&lt;img data-ratio=&quot;0.44468085106382976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRS2CtQsRjRiaJLtH5B5EwnkwgOEya6icNpbibr9OwT4bgVjtRdFUww34xzBqrnJaeVyQukgYyrHNxNxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1880&quot;/&gt;&lt;br/&gt;在上图中我们可以看到，在我们取从库时钟[0.5,1.5)这个1s的时间段范围内。在前0.5s，也就是[0.5,1)这个区间中我们计算出来的Seconds_behind_master是0，而在[1,1.5)区间计算的确是1&lt;br/&gt;。那我们的平均值就可以计算出来为(0.5*0+0.5*1)/(1.5-0.5)=0.5=500ms!&lt;br/&gt;也就是说，在没有任何实际主从延迟的情况下，仅仅跨秒这一个因素就能造成好几百毫秒的误差。&lt;/p&gt;&lt;h3&gt;实际主从延迟为0的情况下clock_diff_with_master计算为0，Seconds_behind_master计算为-1并被校正为0&lt;/h3&gt;&lt;p&gt;另外一个有意思的点是，既然误差能加1，自然也能减1。也就是Seconds_behind_master计算为-1。这就会给观察人员造成一个错觉，从库比主库快！当然了MySQL源码考虑到了这一点，强制校正为0。&lt;br/&gt;在这里，笔者将主从连接的那一刻稍微往前偏移0.1s，就可以构造出刚才说的现象，如下图所示：&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47314285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRS2CtQsRjRiaJLtH5B5Ewnkw3JpIJJPbITCqDKaqtpntHkbCBK7IMdiaBqbCicVXl9icx8mXd7mdDP4Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1750&quot;/&gt;&lt;br/&gt;MySQL中的源码注释和强行校正逻辑如下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;      long time_diff= ((long)(time(0) - mi-&amp;gt;rli-&amp;gt;last_master_timestamp)&lt;br/&gt;                       - mi-&amp;gt;clock_diff_with_master);&lt;br/&gt;      /*&lt;br/&gt;        Apparently on some systems time_diff can be &amp;lt;0. Here are possible&lt;br/&gt;        reasons related to MySQL:&lt;br/&gt;        - the master is itself a slave of another master whose time is ahead.&lt;br/&gt;        - somebody used an explicit SET TIMESTAMP on the master.&lt;br/&gt;        Possible reason related to granularity-to-second of time functions&lt;br/&gt;        (nothing to do with MySQL), which can explain a value of -1:&lt;br/&gt;        assume the master&#x27;s and slave&#x27;s time are perfectly synchronized, and&lt;br/&gt;        that at slave&#x27;s connection time, when the master&#x27;s timestamp is read,&lt;br/&gt;        it is at the very end of second 1, and (a very short time later) when&lt;br/&gt;        the slave&#x27;s timestamp is read it is at the very beginning of second&lt;br/&gt;        2. Then the recorded value for master is 1 and the recorded value for&lt;br/&gt;        slave is 2. At SHOW SLAVE STATUS time, assume that the difference&lt;br/&gt;        between timestamp of slave and rli-&amp;gt;last_master_timestamp is 0&lt;br/&gt;        (i.e. they are in the same second), then we get 0-(2-1)=-1 as a result.&lt;br/&gt;        This confuses users, so we don&#x27;t go below 0: hence the max().&lt;br/&gt;&lt;br/&gt;        last_master_timestamp == 0 (an &quot;impossible&quot; timestamp 1970) is a&lt;br/&gt;        special marker to say &quot;consider we have caught up&quot;.&lt;br/&gt;      */&lt;br/&gt;      protocol-&amp;gt;store((longlong)(mi-&amp;gt;rli-&amp;gt;last_master_timestamp ?&lt;br/&gt;                                   max(0L, time_diff) : 0));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;如何获得精确的毫秒级的主从延迟&lt;/h2&gt;&lt;p&gt;由于Seconds_behind_master精度的原因，完全无法衡量毫秒级的主从延迟，所以出现了pt-heartbeat这样的工具去精确的计算主从间毫秒级的延迟。在后续采用pt-heartbeat对两个库进行监控后，这两个看上去平均延迟相差500ms的从库实际主从延迟差距在10ms之内。&lt;/p&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;任何指标都有其表示的精度，而在其精度表示范围之外就会产生相当大的误差，以至于能够误导我们的判断。当对某一项的指标感到很反常识的时候，可以考虑是不是本身指标并不能描述当前我们想要观察的现象。例如本文中的阐述就表明Seconds_behind_master对1s的主从延迟的刻画没有太大的意义。&lt;/p&gt;&lt;h2&gt;公众号&lt;/h2&gt;&lt;p&gt;关注笔者公众号，获取更多干货文章:&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRS2CtQsRjRiaJLtH5B5Ewnkwcjic6vdQrxP2nJDSglYWZVKJV2a0LXDVEiapkJAtm6TsiaCKXXRhdzCrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c1bfa012dacb6fbb836ac050eec9727f</guid>
<title>30岁转行入IT晚吗</title>
<link>https://toutiao.io/k/o6nwkbk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人私信：非专业出身，30岁转行去做开发，业内有没有案例？下面是一些基本情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;计划拿出1年的时间，想通过自学入行做开发。理由：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1，薪资水平还可以； &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2，符合自己对未来的规划； &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3，周围一个文科的妹子，在别人手把手的调教下，外包到银行做测试，拿到了过万的薪资。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;心理接受度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不比技术，看看有没有可能性？一个实际的问题：能接受一个年轻人做自己的领导吗？周围的同事更多的也是20郎当岁，能相处的愉快吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比一路从20岁出头拱到30岁的人而言，要在30岁时去跟一些职场出道没多久的年轻人去拼，有优势也有弊端。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;优势：职场经验丰富，软实力加分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;弊端：项目经验不足，精力上拼不过年轻人，非科班欠缺一些底层逻辑&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自学的问题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自学的想法可以抛弃，在没有积累的情况下，线下培训是最有效的途径，可以面对面交流沟通，能解决实际疑问，少走很多弯路。另外，还能接触到商业项目的案例实战，更快速的接近职场，自学完全是没有这个氛围，也不足以支撑一个人可以坚持1年之久，更容易走弯路且不自知，一句话，没有别人的指导，快速入门没戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入门后可以自学，持续提升。终身学习，是从事IT行业最基本的职业要求，如果想找个工作后躺平，被优化毕业是迟早的事。不进则退，进得慢也会退。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;年龄的问题&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按现在的行业状况来看，确实是有些晚，30岁转管理危机，35岁转行危机，40岁生存危机等等，这不是行业定数，我相信各行各业都存在这个问题，所以，接受即可，做好自己的当下。确实想清楚一件事，做就是了，任何时候都不晚。种一棵树，最好的时机是十年前，其次就是现在。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;不排期，就遥遥无期，不提上日程，就没有日程。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这依旧是一个看年纪吃饭的年代，30岁是个坎，如果没有点出彩的成绩，路起来也很难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多事都有AB面，不要片面看待，更不要掩耳盗铃，IT也一样，不要只看到高薪、高福利、可以远程办公等等，对应的还有高压力、鼠标手、颈椎腰椎疼、掉发秃头，而且越来越多的人进入，竞争异常激烈，一边人手不足，一边人满为患，也是有原因的。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经验不足，更需要有经验的人指导，他们走过的路，吃过的亏，踩过的坑，更能对后来者形成一个启示，从他们那里来拓宽自己视野，让自己走得更稳健。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.4346153846153846&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/EwukgicNDWBssXhDQQZNFfvXuZmgY1rtXr3VE6eEjvf67FXPHgXvR8RqSlbBw6n4a94H3c21H5ichgOznGARziclg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>17b545027a9c06fb4bcf4f5c4538cda2</guid>
<title>百度某部门面试原题</title>
<link>https://toutiao.io/k/l0zugzm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文适合最近在考虑新机会的的小伙伴阅读&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;欢迎关注&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前端早茶&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，与广东靓仔携手共同进阶～&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3ODAyNDI0OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ic5A4V8PX4PmOXMQHa6L3OhPGOnf2BSZib7ibVcAj2j2FYkfFCWb2xmyfX63TYVlofunfD4QnB5vqELZqXfnQZMlA/0?wx_fmt=png&quot; data-nickname=&quot;前端早茶&quot; data-alias=&quot;ZeFeng_axios&quot; data-signature=&quot;专注前端，一起结伴同行，紧跟业界发展步伐~&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：广东靓仔&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;    这套题目是广东靓仔认识的一位前端妹子经过“一番努力”Get到的，感谢~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1717791411042944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ic5A4V8PX4PmKpHrxF4VjOd39aXmquRhBfEw9F8HGGQ48a8KjiaT2ZEdibX3q4dxiaZUMq6gibKLsKAeM6xEp4kXf0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;163&quot;/&gt;&lt;/p&gt;&lt;section&gt;这套题目，比较实用的，接下来广东靓仔跟小伙伴一起来看看这套百度某部门的技术一面原题。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、原题&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设置元素的backgroud 哪些区域颜色会改变&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;background&lt;/span&gt;填充区域默认为&lt;span&gt;content&lt;/span&gt;、&lt;span&gt;padding&lt;/span&gt;和&lt;span&gt;border&lt;/span&gt;区域。&lt;/p&gt;&lt;p&gt;然而该行为由&lt;span&gt;background-clip&lt;/span&gt;属性决定,默认为&lt;span&gt;border-box&lt;/span&gt;该属性对应的&lt;/p&gt;&lt;section&gt;&lt;span&gt;background&lt;/span&gt;填充对应区域如下:&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35659760087241005&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ic5A4V8PX4PmKpHrxF4VjOd39aXmquRhBjiaQVsiaN9lCmibjksqe7VG9yfCqG5FkwNUcwq95U91kPt0F3v9YuZcUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;FOUC 无样式闪烁（文档样式短暂失效）@import&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;原因大致为：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1：使用import方法导入样式表；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2：将样式表放在页面底部；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3：有几个样式表，放在html结构的不同位置；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其实原理很清楚：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; 当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;解决方法：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用LINK标签将样式表放在文档HEAD中。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重绘重排区别&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;重绘不一定需要重排（&lt;span&gt;&lt;span&gt;比如颜色的改变&lt;/span&gt;）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;重排必然导致重绘（&lt;span&gt;比如改变网页位置&lt;/span&gt;）&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;重排(Reflow)：&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;重绘(Repaint)：&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;减少重排次数和缩小重排影响范围解决方式：&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;1. &lt;/span&gt;将多次改变样式属性的操作，合成一次操作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 将需要多次重排的元素,嗯，position属性。设为absolute。或fixed。使其脱离文档流，这样，他的变化就不会影响到其他的元素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 在内存中多次操作节点。完成后再添加到文档中去。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 如果对一个元素进行复杂的操作，可以将display属性设为none嗯使其隐藏。操作完后再显示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5. 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你们项目中Token是怎么拿到的&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户登陆,发送手机号码和验证码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;后台接收参数,查找用户,用户存在就生成token,返回给前端&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;前端登陆成功,把token存到vuex(做持久化)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用axios拦截器,读取vuex中的token,并放入请求头&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求其他接口,就会带上token&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;后台在需要登陆的接口上,获取token,解密token获得userId,返回前端需要的数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;用户在下次使用app,如果token还在有效期内,不需要重新登陆&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有不同的或者更好的方案也可以回答，发散题，自由发挥&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;cookie是什么？&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;cookie 是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。&lt;/section&gt;&lt;section&gt;存储量很小4kb&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;拓展说明，&lt;/strong&gt;&lt;strong&gt;加分项：&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;    当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。&lt;span&gt; 这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。&lt;/span&gt;&lt;/section&gt;&lt;p data-pid=&quot;Rvd0FwJm&quot;&gt;&lt;span&gt;&lt;strong&gt;时效性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age选项代替，两者的作用都是限制cookie 的有效时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;expires的值是一个时间点（cookie失效时刻= expires ），而max-age 的值是一个以秒为单位时间段（cookie 失效时刻= 创建时刻+ max-age ）。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;httpOnly&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Js数据类型有哪些 &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;值类型(基本类型)：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;引用数据类型：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对象(Object)、数组(Array)、函数(Function)。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基本类型引用类型区别 &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基本类型&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基本类型的访问是按值访问的，就是说我们可以操作保存在变量中的实际的值。基本类型有以下几个特点：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基本类型的值是不可变得：   &lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;    2.基本类型的比较是值的比较：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    3.基本类型的变量是存放在栈区的（栈区指内存里的栈内存）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;引用类型&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;引用类型可以拥有属性和方法，属性又可以包含基本类型和引用类型。引用类型的有以下一些特性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.引用类型的值是可变的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.引用类型的值是同时保存在栈内存和堆内存中的对象&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.引用类型的比较是引用的比较&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;判断一个对象是不是数组&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;方法1：&lt;/p&gt;&lt;p&gt;根据对象的class属性来判断&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; obj = []&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;Object&lt;/span&gt;.prototype.toString.call(obj) === &lt;span&gt;&#x27;[object Array]&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;方法2：&lt;/p&gt;&lt;p&gt;&lt;span&gt;Array.isArray直接判断&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; obj = []&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;Array&lt;/span&gt;.isArray(obj))&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;js数组遍历都有哪些方法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这里列举12种，具体如下所示：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;1.for循环&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;,len=arr.length; i &amp;lt; len; i++) {   &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.foreach循环&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 没有返回值,对原数组无影响&lt;/span&gt;&lt;br/&gt;arr.forEach(&lt;span&gt;(&lt;span&gt;item,index,array&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//执行代码&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;// 参数：value数组中的当前项, index当前项的索引, array原始数组；&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3.map循环&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; ary = [&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;42&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;]; &lt;br/&gt;&lt;span&gt;var&lt;/span&gt; res = ary.map(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;item,index,ary &lt;/span&gt;) &lt;/span&gt;{ &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; item*&lt;span&gt;10&lt;/span&gt;; &lt;br/&gt;}) &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(res);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--&amp;gt;[120,230,240,420,10];  原数组拷贝了一份，并进行了修改&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(ary);&lt;span&gt;//--&amp;gt;[12,23,24,42,1]；  原数组并未发生变化&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.forof遍历&lt;/strong&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; value &lt;span&gt;of&lt;/span&gt; myArray) {&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(value);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5.filter遍历&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;不会改变原始数组,返回新数组&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; arr = [&lt;span&gt;73&lt;/span&gt;,&lt;span&gt;84&lt;/span&gt;,&lt;span&gt;56&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; newArr = arr.filter(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; item&amp;gt;&lt;span&gt;80&lt;/span&gt;)   &lt;span&gt;//得到新数组 [84, 100]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(newArr,arr)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;6.every遍历&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; arr = [ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt; ]; &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log( arr.every( &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt; item, index, array &lt;/span&gt;)&lt;/span&gt;{ &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; item &amp;gt; &lt;span&gt;3&lt;/span&gt;; &lt;br/&gt;    })); &lt;br/&gt;&lt;span&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;7.some遍历&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;some()是对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; arr = [ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt; ]; &lt;br/&gt;   &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log( arr.some( &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt; item, index, array &lt;/span&gt;)&lt;/span&gt;{ &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; item &amp;gt; &lt;span&gt;3&lt;/span&gt;; &lt;br/&gt;})); &lt;br/&gt;&lt;span&gt;// true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;8.reduce&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;      reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; total = [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;].reduce(&lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;)=&amp;gt;&lt;/span&gt;a + b); &lt;span&gt;//10&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;     reduce接受一个函数，函数有四个参数，分别是：上一次的值，当前值，当前值的索引，数组&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;].reduce(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;previousValue, currentValue, index, array&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; previousValue + currentValue;&lt;br/&gt;});&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;9.reduceRight&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;reduceRight()&lt;/span&gt;&lt;span&gt;方法的功能和&lt;/span&gt;&lt;span&gt;reduce()&lt;/span&gt;&lt;span&gt;功能是一样的，不同的是&lt;/span&gt;&lt;span&gt;reduceRight()&lt;/span&gt;&lt;span&gt;从数组的末尾向前将数组中的数组项做累加。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;reduceRight()&lt;/span&gt;&lt;span&gt;首次调用回调函数&lt;/span&gt;&lt;span&gt;callbackfn&lt;/span&gt;&lt;span&gt;时，&lt;/span&gt;&lt;span&gt;prevValue &lt;/span&gt;&lt;span&gt;和 &lt;/span&gt;&lt;span&gt;curValue &lt;/span&gt;&lt;span&gt;可以是两个值之一。如果调用 &lt;/span&gt;&lt;span&gt;reduceRight() &lt;/span&gt;&lt;span&gt;时提供了 &lt;/span&gt;&lt;span&gt;initialValue &lt;/span&gt;&lt;span&gt;参数，则 &lt;/span&gt;&lt;span&gt;prevValue &lt;/span&gt;&lt;span&gt;等于 &lt;/span&gt;&lt;span&gt;initialValue&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;curValue &lt;/span&gt;&lt;span&gt;等于数组中的最后一个值。如果没有提供 &lt;/span&gt;&lt;span&gt;initialValue &lt;/span&gt;&lt;span&gt;参数，则 &lt;/span&gt;&lt;span&gt;prevValue &lt;/span&gt;&lt;span&gt;等于数组最后一个值， &lt;/span&gt;&lt;span&gt;curValue &lt;/span&gt;&lt;span&gt;等于数组中倒数第二个值。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; arr = [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt; &lt;br/&gt;arr.reduceRight(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;preValue,curValue,index,array&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; preValue + curValue;&lt;br/&gt;}); &lt;span&gt;// 10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;10.find&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;find()&lt;/span&gt;方法返回数组中符合测试函数条件的第一个元素。否则返回undefined。&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; stu = [&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;张三&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;gender&lt;/span&gt;: &lt;span&gt;&#x27;男&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;王小毛&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;gender&lt;/span&gt;: &lt;span&gt;&#x27;男&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;李四&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;gender&lt;/span&gt;: &lt;span&gt;&#x27;男&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;]&lt;br/&gt;stu.find(&lt;span&gt;(&lt;span&gt;element&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (element.name == &lt;span&gt;&#x27;李四&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&lt;span&gt;//返回结果为&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//{name: &quot;李四&quot;, gender: &quot;男&quot;, age: 20}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;11.findIndex&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于数组中的每个元素，&lt;/span&gt;&lt;span&gt;findIndex &lt;/span&gt;&lt;span&gt;方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;。只要有一个元素返回 &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;findIndex &lt;/span&gt;&lt;span&gt;立即返回该返回 &lt;/span&gt;&lt;span&gt;true &lt;/span&gt;&lt;span&gt;的元素的索引值。如果数组中没有任何元素返回 &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，则 &lt;/span&gt;&lt;span&gt;findIndex&lt;/span&gt;&lt;span&gt; 返回 -1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;findIndex &lt;/span&gt;&lt;span&gt;不会改变数组对象。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;].findIndex(&lt;span&gt;&lt;span&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; x == &lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// Returns an index value of -1.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;12.keys，values，entries&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; &lt;span&gt;ES6 提供三个新的方法 —— entries()，keys()和values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; index &lt;span&gt;of&lt;/span&gt; [&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;].keys()) {&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(index);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; elem &lt;span&gt;of&lt;/span&gt; [&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;].values()) {&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(elem);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;// &#x27;a&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// &#x27;b&#x27;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; [index, elem] &lt;span&gt;of&lt;/span&gt; [&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;].entries()) {&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(index, elem);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 0 &quot;a&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1 &quot;b&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Js事件循环机制&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;Event Loop 包含两类：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1. 一类是基于 Browsing Context ，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 一种是基于 Worker &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二者是独立运行的。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;任务队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而异步任务，就是异步执行的任务，比如ajax网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列( Event Queue )的机制来进行协调。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更新 render&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;主线程重复执行上述步骤&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;深浅拷⻉贝区别&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;浅拷贝(Shallow Copy)：&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;仅拷贝对象的非对象属性(基本类型属性)、不可变对象属性，但是不拷贝对象的对象属性(不含不可变对象) ，即为浅拷贝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    以下这些函数得到的都是浅拷贝：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Object.assign&lt;/span&gt;、&lt;span&gt;Array.prototype.slice()&lt;/span&gt;、&lt;span&gt;Array.prototype.concat()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;深拷贝(Deep Copy)：&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单理解：&lt;span&gt;深拷贝会拷贝所有的属性。深拷贝前后两个对象互不影响。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;JSON.parse(JSON.stringify())&lt;/span&gt;、&lt;span&gt;手写递归函数&lt;/span&gt;、&lt;span&gt;函数库lodash&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;箭头函数特点&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;1. 省略function换成=&amp;gt; 一个参数的时候()可以省略 一个return的时候{}可以省略&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 不绑定this，其中的this指向函数定义位置的上下文this&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 内部不存在arguments和new.target，使用的都是外部的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 没有原型，占用内存空间小&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Js垃圾回收方法&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;Javascript具有自动垃圾回收机制(&lt;strong&gt;GC&lt;/strong&gt;:Garbage Collecation)。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;原理：&lt;/strong&gt;垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（1）标记清除法&lt;/span&gt;&lt;/p&gt;&lt;section&gt;    在函数声明一个变量的时候，就将这个变量标记为“进入环境”。&lt;/section&gt;&lt;section&gt;（2）引用计数法&lt;/section&gt;&lt;section&gt; 引用计数的含义是跟踪记录每个值被引用的次数。当这个值的引用次数变成0时，就可以将其占用的内存空间回收回来。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Vuex更新流程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;vuex的工作流程就是：&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）通过dispatch去提交一个actions，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）actions接收到这个事件之后，在actions中可以执行一些异步|同步操作，根据不同的情况去分发给不同的mutations，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）actions通过commit去触发mutations，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）mutations去更新state数据，state更新之后，就会通知vue进行渲染&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;拓展：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不能在mutations执行异步操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Vuex中所有的状态更新的唯一途径都是&lt;span&gt;mutation&lt;/span&gt;，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 &lt;span&gt;time-travel&lt;/span&gt; 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vue keep-alive组件有什么用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;用于保留组件状态或避免重新渲染（缓存的作用）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两个属性&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;exclude&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二者都可以用逗号分割字符串、正则表达式或者一个数组。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- 逗号分隔字符串 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;keep-alive&lt;/span&gt; &lt;span&gt;include&lt;/span&gt;=&lt;span&gt;&quot;a,b&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;component&lt;/span&gt; &lt;span&gt;:is&lt;/span&gt;=&lt;span&gt;&quot;view&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;component&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;keep-alive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 正则表达式 (使用 &lt;span&gt;`v-bind`&lt;/span&gt;) --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;keep-alive&lt;/span&gt; &lt;span&gt;:include&lt;/span&gt;=&lt;span&gt;&quot;/a|b/&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;component&lt;/span&gt; &lt;span&gt;:is&lt;/span&gt;=&lt;span&gt;&quot;view&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;component&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;keep-alive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 数组 (使用 &lt;span&gt;`v-bind`&lt;/span&gt;) --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;keep-alive&lt;/span&gt; &lt;span&gt;:include&lt;/span&gt;=&lt;span&gt;&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;component&lt;/span&gt; &lt;span&gt;:is&lt;/span&gt;=&lt;span&gt;&quot;view&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;component&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;keep-alive&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何监听一个变量的变化 长度 index&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;defineProperty&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; a = { &lt;span&gt;watchValue&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; lastTimeValue=a.watchValue;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(a, &lt;span&gt;&#x27;watchValue&#x27;&lt;/span&gt;, {&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;get：&#x27;&lt;/span&gt; + watchValue);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; watchValue;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;set&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;value&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    watchValue = value;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(lastTimeValue!=watchValue){&lt;br/&gt;        lastTimeValue=watchValue;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;value changed!! set: &#x27;&lt;/span&gt; + watchValue);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;proxy&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; observe1 = &lt;span&gt;(&lt;span&gt;object, onChange&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; handler = {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, property, receiver) {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(target[property], handler);&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, property, receiver);&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;      onChange(value);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.set(target, key, value, receiver);&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(object, handler);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; obj = {&lt;br/&gt;  &lt;span&gt;foo&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;a&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;x&lt;/span&gt;:{&lt;span&gt;y&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;},&lt;br/&gt;    &lt;span&gt;b&lt;/span&gt;:[{&lt;span&gt;c&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;}]&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; watchedObj = observe1(obj,(val)=&amp;gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`哈哈哈，监听到值变化为&lt;span&gt;${val}&lt;/span&gt;了`&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;watchedObj.foo = &lt;span&gt;true&lt;/span&gt;; &lt;br/&gt;watchedObj.a.x.y = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;// 监听到值变化为5了&lt;/span&gt;&lt;br/&gt;watchedObj.a.b[&lt;span&gt;0&lt;/span&gt;].c = &lt;span&gt;true&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;webpack lorder / plugin&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;webpack是一个模块打包器（module bundler），提供了一个核心，核心提供了很多开箱即用的功能，同时它可以用loader和plugin来扩展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;loader的使用方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1：在配置文件webpack.config.js中配置&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;rules&lt;/span&gt;: [&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.txt$/&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;use&lt;/span&gt;: &lt;span&gt;&#x27;raw-loader&#x27;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2：通过命令行参数方式&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;webpack --module-bind &lt;span&gt;&#x27;txt=raw-loader&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;3：通过内联使用&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import txt from &lt;span&gt;&#x27;raw-loader!./file.txt&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;webpack常用的loader&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;样式：style-loader、css-loader、less-loader、sass-loader等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文件：raw-loader、file-loader 、url-loader等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;编译：babel-loader、coffee-loader 、ts-loader等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;校验测试：mocha-loader、jshint-loader 、eslint-loader等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如下面配置，可以匹配.scss的文件，分别经过sass-loader、css-loader、style-loader的处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;sass-loader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;转化sass为css文件，并且包一层module.exports成为一个js module。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;style-loader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;将创建一个style标签将css文件嵌入到html中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;css-loader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;则处理其中的@import和url()。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;rules&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.scss$/&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;use&lt;/span&gt;:[&lt;br/&gt;              {&lt;span&gt;loader&lt;/span&gt;:&lt;span&gt;&#x27;style-loader&#x27;&lt;/span&gt;},&lt;br/&gt;              {&lt;span&gt;loader&lt;/span&gt;:&lt;span&gt;&#x27;css-loader&#x27;&lt;/span&gt;,&lt;span&gt;options&lt;/span&gt;:{&lt;span&gt;sourceMap&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;modules&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;}},&lt;br/&gt;              {&lt;span&gt;loader&lt;/span&gt;:&lt;span&gt;&#x27;sass-loader&#x27;&lt;/span&gt;,&lt;span&gt;options&lt;/span&gt;:{&lt;span&gt;sourceMap&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;}}&lt;br/&gt;          ],&lt;br/&gt;          &lt;span&gt;exclude&lt;/span&gt;:&lt;span&gt;/node_modules/&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;webpack常用的plugin&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;首先webpack内置&lt;/span&gt;&lt;span&gt;UglifyJsPlugin&lt;/span&gt;&lt;span&gt;，压缩和混淆代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;webpack内置&lt;/span&gt;&lt;span&gt;CommonsChunkPlugin&lt;/span&gt;&lt;span&gt;，提高打包效率，将第三方库和业务代码分开打包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ProvidePlugin&lt;/span&gt;&lt;span&gt;：自动加载模块，代替require和import&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;写一个webpack插件步骤如下：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1. 编写一个JavaScript命名函数。&lt;/p&gt;&lt;p&gt;2. 在它的原型上定义一个apply方法。&lt;/p&gt;&lt;p&gt;3. 指定挂载的webpack事件钩子。&lt;/p&gt;&lt;p&gt;4. 处理webpack内部实例的特定数据。&lt;/p&gt;&lt;p&gt;5. 功能完成后调用webpack提供的回调。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;编写插件之前要理解compiler和compilation两个对象，以及webpack生命周期的各个阶段和钩子，plugin比loader强大，通过plugin你可以访问compliler和compilation过程，通过钩子拦截webpack的执行。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;package.json package.lock.json 区别&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;package.json&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Node.js 项目遵循模块化的架构，当我们创建了一个 Node.js 项目，意味着创建了一个模块，这个模块的描述文件，被称为 package.json。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 属性说明&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;- 包名；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;version &lt;/span&gt;&lt;span&gt;- 包的版本号；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;description &lt;/span&gt;&lt;span&gt;- 包的描述；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;homepage &lt;/span&gt;&lt;span&gt;- 包的官网URL；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;author &lt;/span&gt;&lt;span&gt;- 包的作者，它的值是你在 https://npmjs.org 网站的有效账户名，遵循“账户名&amp;lt;邮件&amp;gt;”的规则，例如：zhangsan &amp;lt;zhangsan@163.com&amp;gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;contributors &lt;/span&gt;&lt;span&gt;- 包的其他贡献者；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;dependencies / devDependencies&lt;/span&gt;&lt;span&gt; - 生产/开发环境依赖包列表。它们将会被安装在 node_module 目录下；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;repository &lt;/span&gt;&lt;span&gt;- 包代码的 Repo 信息，包括 type 和 URL，type 可以是 git 或 svn，URL 则是包的 Repo 地址；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;main &lt;/span&gt;&lt;span&gt;- main 字段指定了程序的主入口文件，这个字段的默认值是模块根目录下面的 index.js；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;keywords &lt;/span&gt;&lt;span&gt;- 关键字&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;devDependencies、dependencies、peerDependencies的区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;package.lock.json&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当我们安装依赖时，package-lock.json 文件会自动生成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;package-lock.json 文件中记录了下载源地址，可以加快我们的 npm install 速度。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么转化less为css&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Less &lt;/span&gt;&lt;span&gt;是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;webpack的配置如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;rules&lt;/span&gt;: [{&lt;br/&gt;            &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.less$/&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;use&lt;/span&gt;: [&lt;span&gt;&quot;style-loader&quot;&lt;/span&gt;, &lt;span&gt;&quot;css-loader&quot;&lt;/span&gt;, &lt;span&gt;&quot;less-loader&quot;&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;//编译方向从右到左less-loader=&amp;gt;css-loader=&amp;gt;style-loader&lt;/span&gt;&lt;br/&gt;        }, {&lt;br/&gt;            &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.js$/&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;exclude&lt;/span&gt;: &lt;span&gt;/node_modules/&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;loader&lt;/span&gt;: &lt;span&gt;&#x27;babel-loader&#x27;&lt;/span&gt;,&lt;br/&gt;        }]&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;把样式文件less转为css并且单独提取出来（不放置在bundle.js中）&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; ExtractTextPlugin = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;extract-text-webpack-plugin&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt; &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; ExtractTextPlugin(&lt;span&gt;&#x27;style.css&#x27;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;   &lt;span&gt;//if you want to pass in options, you can do so:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//new ExtractTextPlugin({&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//  filename: &#x27;style.css&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//})&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    ]&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;地址栏输入一个url到页面渲染过程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、HTTP 请求准备阶段&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、HTTP 发送请求&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;浏览器向服务端发起http请求，把请求头和请求行一起发送个服务器，服务端解析请求头如发现cache-control和etag（if-none-match），if-modified（if-modified-since）字段就会判断缓存是否过期，如果没有返回304，否则返回200&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;3、HTTP 响应返回&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;content-type作用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Content-Type 实体头部用于指示资源的MIME类型 media type 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值；为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Content-Type 的值类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.1 application/json：&lt;/span&gt;消息主体是序列化后的 JSON 字符串 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.2 application/x-www-form-urlencoded：&lt;/span&gt;数据被编码为名称/值对。这是标准的编码格式 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.3 multipart/form-data：&lt;/span&gt; 需要在表单中进行文件上传时，就需要使用该格式。常见的媒体格式是上传文件之时使用的 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.4 text/plain：&lt;/span&gt;数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;介绍知道的状态码，状态码301、302区别&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;状态码分为5类：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1**&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;信息，服务器收到请求，需要请求者继续执行操作&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2**&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;成功，操作被成功接收并处理&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;3**&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;重定向，需要进一步的操作以完成请求&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;4**&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;5**&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;301：&lt;/strong&gt;（&lt;/span&gt;&lt;span&gt;永久移动&lt;/span&gt;&lt;span&gt;）请求的网页已被永久移动到新位置。服务器返回此响应（作为对GET或HEAD请求的响应）时，会自动将请求者转到新位置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;302：&lt;/strong&gt;（&lt;/span&gt;&lt;span&gt;临时移动&lt;/span&gt;&lt;span&gt;）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;HTTP状态码301与302的区别：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、它们之间关键区别在，资源是否存在有效性；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、301资源还在只是换了一个位置，返回的是新位置的内容；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、302资源暂时失效，返回的是一个临时的代替页上。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sessionstorage localstorage区别&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.生命周期&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sessionStorage的生命周期是仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.存储大小&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;localStorage和sessionStorage的存储数据大小一般都是：5MB&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3.存储位置&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.存储内容类型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5.获取方式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage：window.localStorage&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sessionStorage：window.sessionStorage&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;6.应用场景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;localStorage：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sessionStorage：敏感账号一次性登录&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浏览器为啥第二次访问就快了&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;主要原因是这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）、DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）、重点看下浏览器资源缓存，下面是缓存处理的过程：&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么减少页面加载时间&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;1、压缩css、js文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、合并js、css文件，减少http请求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、外部js、css文件放在最底下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、减少dom操作，尽可能用变量替代不必要的dom操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、优化图像（格式选择、懒加载等等）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、使用CDN&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7、使用缓存&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8、减少 http 请求（合并文件，合并图片）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9、标明高度和宽度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;10、网址后加斜杠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;11、优化TCP协议&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;遇到的棘手的问题,完成了什么工作&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;开放性题目，自由作答。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、最后&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;    这套题目，考到的知识点比较细，所以我们在平时学习的时候要多多去挖掘，&quot;蜻蜓点水 &quot;的背后是要深入。&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;关注我，一起携手进阶&lt;/strong&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3ODAyNDI0OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ic5A4V8PX4PmOXMQHa6L3OhPGOnf2BSZib7ibVcAj2j2FYkfFCWb2xmyfX63TYVlofunfD4QnB5vqELZqXfnQZMlA/0?wx_fmt=png&quot; data-nickname=&quot;前端早茶&quot; data-alias=&quot;ZeFeng_axios&quot; data-signature=&quot;专注前端，一起结伴同行，紧跟业界发展步伐~&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎关注&lt;span&gt;&lt;strong&gt;&lt;span&gt;前端早茶&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，与广东靓仔携手共同进阶～&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>54928802837dc074f1fe30ce61df0bac</guid>
<title>携程 SOA 的 Service Mesh 架构落地</title>
<link>https://toutiao.io/k/dmtcxk5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span/&gt;本文作者 Dozer、Bender、vio-lin 来自携程 SOA 团队。目前主要负责 SOA 系统的研发工作和 Service Mesh 架构的演进、落地工作，同时也关注服务治理、JVM、云原生等技术领域。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;携程的 SOA 系统经历了 ESB、微服务等架构的演变，正处于一个较平稳的阶段。但当前的微服务架构却遇到了各种业内经常遇到的问题，例如：&lt;/p&gt;&lt;p&gt;1）无法支撑多语言战略，团队没有精力维护除了 Java 以外其他语言的 SDK；&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）客户端 SDK 版本升级推进困难，特别是遇到 Bug 的时候，彻底下线一个版本可能会花上几个月的时间，给业务带来了隐患；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 Service Mesh 架构出现时，我们就注意到了它。一边探索一边实践，尝试着用 Service Mesh 来解决我们的痛点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、技术方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;携程主营业务在国内，并且在国际上也有着不小的业务量。基于这个特点，国内使用自建机房、国外使用公有云的模式是非常合适的。&lt;/p&gt;&lt;p&gt;正因为技术栈需要支持跨机房部署，所以将云原生架构作为演进的目标。&lt;/p&gt;&lt;p&gt;Istio 作为云原生架构中重要的一位成员，和云原生架构中的其他成员相辅相成。&lt;/p&gt;&lt;p&gt;除此以外，携程当前 SOA 以 HTTP 协议为主，Istio 对 HTTP、HTTPS、gRPC 这几个传输协议有着全面的支持。&lt;/p&gt;&lt;p&gt;自然地，基于 Istio 做二次开发成为了我们内部推行 Service Mesh 的技术实现方案。&lt;/p&gt;&lt;p&gt;虽然开源项目开箱即用，但在调研和方案设计的过程中，我们也遇到了很多问题，例如：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1）如何实现不改造业务代码即可接入 Service Mesh，做到无感知迁移&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2）Istio 无法覆盖所有携程需要的功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3）Istio 没有配置按需下发方案&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4）Istio 性能无法支撑携程规模&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5）Istio 对高可用方面的支持不够&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;接下来，本文会着重介绍 1-3 的解决思路，4-5 可以参考我们另外两篇文章：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;三、控制平面&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;控制平面想要实现无感知迁移，那么最重要的就是要实现两套系统的互通，其中主要包括：统一配置管理、服务注册与发现、功能对齐和 SDK 兼容。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.1 统一配置管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们现有的 SOA 系统已经有了一套包括管理后台、实时推送等功能模块的系统，并不需要再造一套。&lt;/p&gt;&lt;p&gt;但从云原生架构的角度看，这样的设计就不够云原生。云原生的架构下更推崇声明式 API 和 GitOps 工作流。我们现有的系统显得有点落伍，对将来上公有云也不太友好。&lt;/p&gt;&lt;p&gt;所以这里就出现了两个方案：&lt;/p&gt;&lt;p&gt;团队内部对这两个方案也争论了很久，两者各有利弊。&lt;/p&gt;&lt;p&gt;最终我们还是采取了先用当前配置为权威的方案，将来再慢慢将 Istio 配置作为权威并引入 GitOps 工作流。&lt;/p&gt;&lt;p&gt;这样选择最主要的原因就是，做现有系统配置和 Istio 配置的映射并不是一个确定的转换规则，随着我们对 Istio 的改造和理解更深入，转换逻辑会得到优化，最终的结果也会改变。另外想要实现方案二，不仅要实现一套老配置到新配置的适配，还要实现一套新配置到老的管理后台的适配，工作量非常大。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2 服务注册与发现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;想要让服务注册与发现互通，主要方案也会有两个：&lt;/p&gt;&lt;p&gt;由于历史原因，当前携程内部的应用有部署在 BM、VM、Kubernetes 等环境中，之前并未给不同集群做网络隔离，相互之间都是互通的。因此在实现 Service Mesh 的时候也采用了相同的方案，我们要做的就是一套实例双向同步系统。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.553125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ewz3qbqo4C1t6GzBJYKKh28icyXpk5A1YshmAZxzibQmapoCjNFEIbkBC4WUcRdvoCIRjIWyCswO2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于在 Service Mesh 环境中部署的应用，我们的 Operator 会读取系统中应用和服务之间的绑定关系，通过监听 Kubernetes API 感知到 Pods Ready 后帮助 Pods 注册到老的注册中心，应用的 SDK 无需做任何操作。也就是说在 Service Mesh 环境部署了一个其他语言编写的应用，只要它在系统中绑定了对应的服务并在标准端口暴露了服务，就可以被 Service Mesh 中的应用访问到，也可以被原 SOA 系统中的应用访问到。&lt;/p&gt;&lt;p&gt;对于在原 SOA 系统中部署的应用，它的 SDK 会先将自己上报到注册中心。Operator 会监听注册中心的实例变化并转换成 Istio 的配置。&lt;/p&gt;&lt;p&gt;在 Istio 的模型中，不仅可以将 Kubernetes 中的 Services 和 Pods 转换成 Envoy 的 Clusters 和 Instances，还可以定义 ServiceEntry 和 WorkloadEntry，将外部的地址转换成 Envoy 的 Clusters 和 Instances。我们正是利用了这个功能将原注册中心的服务和实例同步到了 Service Mesh 集群中。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.3 功能对齐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接入 Service Mesh 之后，原来 SOA SDK 支持的一些功能，我们也需要进行支持，比如预热、熔断、限流等。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;预热&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;基于 JVM 的应用在刚启动时，由于热点代码还没有进行 JIT 编译等原因，如果这时就接入和平时一样的请求流量，会导致这部分请求的响应时间增加。预热的基本思想就是让刚启动的机器逐步接入流量，目前 SOA SDK 中已经实现了一些预热算法，客户端会根据服务端的配置来控制流量以达到预热的效果，可配置的参数有：预热算法（例如控制流量直线型增长或指数型增长等）、预热时间等。&lt;/p&gt;&lt;p&gt;而 Envoy 在最新版中才提供了类似的功能：&lt;a target=&quot;_blank&quot; href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/slow_start&quot; textvalue=&quot;Slow start mode&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Slow start mode&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;那如何在现有的版本中实现这个功能？由于这里的核心目标就是让刚启动的服务实例逐步接入流量，最小连接数的负载均衡算法就可以达到这个目标，并且负载均衡方式通过 Istio 的 &lt;code&gt;DestinationRule&lt;/code&gt; 直接就可以进行配置，这个算法可以使客户端每次都去访问当前活跃请求数最小那个服务端。于是我们考虑在服务发布期间，将服务的负载均衡方式设置为最小连接数。&lt;/p&gt;&lt;p&gt;对于利用最小连接数的负载均衡的实际效果我们也做了相关的测试，可以看到引入后服务端在启动过程中，客户端的平均响应时间大幅度下降。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28448275862068967&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ewz3qbqo4C1t6GzBJYKKh2gh9vbo9lfmCtcg385VH6PLTp60qq2RG1ENlX2ba32PurGVMIS7PAUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;/p&gt;&lt;p&gt;在 SOA SDK 支持的预热中需要配置预热时长，而用户很难确定这个时长需要配置为多少。不同的机器配置、不同的 QPS、不同的业务逻辑等，都会影响服务从启动到预热完成所花的时间。如果配置的预热时长太短，实例没有真正的预热完成，就会导致部分请求响应时间增加了；而如果配置的太长，就会导致已经预热完成的实例没有充分的发挥作用。&lt;/p&gt;&lt;p&gt;而在服务接入 Service Mesh 后，在发布期间我们通过最小连接数的负载均衡算法，自适应地调整不同实例的负载。用户不需要关心需要配置什么预热算法，也不需要决定预热时长是多少，只要打开预热开关就可以了。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;熔断&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Istio 中可以通过设置&lt;code&gt;DestinationRule&lt;/code&gt;的&lt;code&gt;ConnectionPool&lt;/code&gt;和&lt;code&gt;OutlierDetection&lt;/code&gt;，来实现熔断策略。当服务由于某些故障开始响应变慢时，&lt;code&gt;ConnectionPool&lt;/code&gt;中关于 pending 请求数、最大并发请求数的设置，会限制客户端继续向变慢的服务发送更多请求，以此来给服务一些时间从响应变慢中恢复。当服务的部分实例出现故障时，&lt;code&gt;OutlierDetection&lt;/code&gt;的配置使客户端停止对这些故障实例的访问，来减轻偶发的部分服务实例故障对客户端的影响，也让故障的那部分实例有时间恢复。&lt;/p&gt;&lt;p&gt;我们的 SOA SDK 目前基于 Hystrix 来实现线程隔离，这部分功能基本对应到 Istio 中的&lt;code&gt;ConnectionPool&lt;/code&gt;配置，Istio 中不同的目标服务都有自己的一组连接池。两者实现方式不同，但基本可以达到同样的效果。&lt;/p&gt;&lt;p&gt;当服务的部分实例出现故障时，Hystrix 会将新的请求拒绝，这部分可以对应到 Istio 中的&lt;code&gt;OutlierDetection&lt;/code&gt;配置。不过这里有个区别，这种情况下 Istio 会将故障实例摘除，而不是直接报错。Istio 中这个功能的本质是一种客户端健康检测，但可以达到类似的效果，应该来说比直接报错更好。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;我们 SOA SDK 支持的限流为本地限流，具体包括对特定操作限流、对特定的请求方 AppID 限流等，我们需要在 Service Mesh 中也支持这些功能。由于目前 Istio 没有对限流抽象出模型定义，我们通过&lt;code&gt;EnvoyFilter&lt;/code&gt;打 patch 的方式，来对开启了限流的服务生成对应的 Envoy 限流配置。&lt;/p&gt;&lt;p&gt;为了将 SOA SDK 已有的丰富的限流配置都在 Service Mesh 中得到对应的支持，我们使用了 Envoy 限流的&lt;code&gt;descriptors&lt;/code&gt;特性。&lt;/p&gt;&lt;p&gt;参考文档：&lt;a target=&quot;_blank&quot; href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter&quot; textvalue=&quot;Local rate limit&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Local rate limit&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;比如我们可以通过&lt;code&gt;descriptor.entry&lt;/code&gt;，对来自不同客户端的请求、不同的请求 path 配置不同的限流值。如下的配置，对来自 client-a 的请求，设置的是每 60s 填充 10 个 token，对来自 client-b 且请求 path 是&lt;code&gt;/foo&lt;/code&gt;的请求，设置的是每 60s 填充 100 个 token。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;descriptors:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;entries:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;client_appid&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;client-a&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;token_bucket:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;max_tokens:&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;tokens_per_fill:&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;fill_interval:&lt;/span&gt; &lt;span&gt;60s&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;entries:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;client_appid&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;client-b&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;path&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;/foo&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;token_bucket:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;max_tokens:&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;tokens_per_fill:&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;fill_interval:&lt;/span&gt; &lt;span&gt;60s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的&lt;code&gt;client_appid&lt;/code&gt;和 path 的值，通过如下在 route 的 ratelimit 配置中添加 actions 来设置。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;route:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cluster:&lt;/span&gt; &lt;span&gt;service_protected_by_rate_limit&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;rate_limits:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;actions:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;request_headers:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;header_name:&lt;/span&gt; &lt;span&gt;x-envoy-client-appid&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;descriptor_key:&lt;/span&gt; &lt;span&gt;client_appid&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;request_headers:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;header_name:&lt;/span&gt; &lt;span&gt;&quot;:path&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;descriptor_key:&lt;/span&gt; &lt;span&gt;path&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上配置本质上就是通过从请求中提取一些特征，例如读取一些特定的 Header，然后再针对不同的请求分配不同的限流值。&lt;/p&gt;&lt;p&gt;对于更加复杂的场景，例如需要根据多个 Header 做逻辑判断时，我们通过 Envoy Filter 实现相关逻辑并设置到 metadata 中。然后在 ratelimit 的 actions 中从 metadata 中提取特征。例如，我们可以 patch 如下的配置到 envoy 中，生成限流使用的 metadata 数据。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;applyTo:&lt;/span&gt; &lt;span&gt;HTTP_FILTER&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;match:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;SIDECAR_INBOUND&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;listener:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;filterChain:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;filter:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;envoy.filters.network.http_connection_manager&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;subFilter:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;istio.metadata_exchange&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;patch:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;INSERT_FIRST&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;value:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;service.metadata.ratelimit&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;typed_config:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;@type&#x27;:&lt;/span&gt; &lt;span&gt;type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;inline_code:&lt;/span&gt; &lt;span&gt;|-&lt;br/&gt;          function envoy_on_request(request_handle)&lt;br/&gt;              custom_key_1 = build_custom_key_1()&lt;br/&gt;              custom_key_2 = build_custom_key_2()&lt;br/&gt;              request_handle:streamInfo():dynamicMetadata():set(&quot;metadata.custom.ratelimit&quot;, &quot;request.info&quot;, {&lt;br/&gt;                  customKey1 = custom_key_1,&lt;br/&gt;                  customKey2 = custom_key_2&lt;br/&gt;              })&lt;br/&gt;          end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后通过 &lt;code&gt;metadata_key&lt;/code&gt;的方式，拿到我们自己设置的限流相关的 metadata。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;route:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cluster:&lt;/span&gt; &lt;span&gt;inbound|8080|http|svc-a&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;rate_limits:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;actions:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;descriptor_key:&lt;/span&gt; &lt;span&gt;customKey1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;metadata_key:&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;metadata.custom.ratelimit&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;path:&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;request.info&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;customKey1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;descriptor_key:&lt;/span&gt; &lt;span&gt;customKey2&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;metadata_key:&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;metadata.custom.ratelimit&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;path:&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;request.info&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;customKey2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;其他功能&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;除了一些服务治理常见的功能，携程内部也有不少定制化的功能需要在 Service Mesh 中实现。&lt;/p&gt;&lt;p&gt;这部分需求部分是通过 Lua Filter 实现，部分是扩展 Envoy 编写了 C++ Filter 来实现的。&lt;/p&gt;&lt;p&gt;因为这 C++ Filter 这部分需求比较稳定，所以静态编译在 Sidecar 中也并不是个大问题。&lt;/p&gt;&lt;p&gt;如果可以通过 WebAssembly 实现当然是可以做得更灵活。但在我们项目启动的时候，Istio 的 WebAssembly 还未正式发布，后期我们会考虑引入 WebAssembly。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.4 SDK 兼容&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接入 Service Mesh 后的一大优势就是可以为 SOA SDK 做轻量化，仅保留基本的功能即可。&lt;/p&gt;&lt;p&gt;而 Service Mesh 的接入是一个长期的过程，应用是一批批接入的，同一个应用在不同的机房也有可能存在接入和不接入两种状态。让业务方写两个版本的代码肯定是不合适的。&lt;/p&gt;&lt;p&gt;因此我们在现有的 SOA SDK 中实现了无缝接入功能，原理也非常简单。&lt;/p&gt;&lt;p&gt;凡是接入 Service Mesh 的应用在发布时就会被注入一个环境变量，当 SOA SDK 探测到这个环境变量后，便会启动轻量化模式。&lt;/p&gt;&lt;p&gt;其中轻量化模式中被移出的功能包括：&lt;/p&gt;&lt;p&gt;这样不仅有利于业务方快速回滚，也可以方便业务方对两种 SOA 架构进行性能对比。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、数据平面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.1 HTTP 协议&lt;/span&gt;&lt;/p&gt;&lt;p&gt;携程当前主流的 SOA 传输协议还是 HTTP，这块的确慢了半拍，但这也更利于我们接入 Service Mesh。&lt;/p&gt;&lt;p&gt;Istio 本身对 HTTP 协议有着很好的支持，因此这部分并不需要我们做什么调整。&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2 Dubbo 协议&lt;/span&gt;&lt;/p&gt;&lt;p&gt;携程在 2018 年的时候引入了 dubbo 协议作为 HTTP 协议的补充，在两年时间的发展中也积累了较多的用户群体。&lt;/p&gt;&lt;p&gt;我们的 dubbo 的调用方式依赖 Dubbo 框架中的 dubbo 协议。&lt;/p&gt;&lt;p&gt;部分应用扩展使用了压缩率更高的 protobuf 来做序列化并进一步使用 gzip 压缩提升性能。&lt;/p&gt;&lt;p&gt;dubbo 协议本身是四层的私有协议，在 Istio 中的支持力度远不如 HTTP。另外 Dubbo 3.0 中也将 gRPC 协议作为了新的传输协议。&lt;/p&gt;&lt;p&gt;如何让 dubbo 协议升级到 gRPC 成为 Service Mesh 落地必须解决的问题。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;现状&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;当前携程内部通过 Dubbo 框架调开发服务端应用有近千个，对应的调用方就更多了。&lt;/p&gt;&lt;p&gt;并且考虑到携程内部使用 Node.js、Python 等语言的应用越来越多，新版升级必须满足如下的要求：&lt;/p&gt;&lt;p&gt;1）使用 gRPC 协议以支持 Service Mesh&lt;/p&gt;&lt;p&gt;2）使用 Dubbo 框架的业务方尽量不改或者少改代码&lt;/p&gt;&lt;p&gt;3）新协议注册的服务端符合 gRPC 的规范并使得其他语言客户端可以很方便地调用&lt;/p&gt;&lt;p&gt;4）不强制依赖 protobuf，能让用户保持 Code First 的编码习惯&lt;/p&gt;&lt;h4&gt;&lt;span&gt;技术选型&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;我们调研了当时主流的做法并通尝试得出三条可行的升级道路。&lt;/p&gt;&lt;p&gt;这里最大的难点是当前使用 dubbo 的旧服务不是基于 protobuf 编写契约的，所以不能直接通过依赖 protobuf 结构的 gRPC 发起调用。&lt;/p&gt;&lt;p&gt;【方案一】&lt;/p&gt;&lt;p&gt;依然用原来的序列化器将数据处理成二进制，在 gRPC 调用时 wrap 一个 protobuf 对象，用一个字段传递原来数据的二进制数据流，再用另外一些字段描述它的序列化方式。这也是 Dubbo 3.0 中透明升级 gRPC 协议时所使用的方案。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 优点：&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 缺点：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 这种方式对于标准的 gRPC 客户端不友好&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 两次序列化和反序列化影响性能&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;【方案二】&lt;/p&gt;&lt;p&gt;gRPC 标准中，没有规定 gRPC 强依赖 protobuf 做序列化器，gRPC 官方的 FAQ 中这样写道：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;gRPC is designed to be extensible to support multiple content types. The initial release contains support for Protobuf and with external support for other content types such as FlatBuffers and Thrift, at varying levels of maturity.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;那具体如何使用其他序列化器呢？&lt;/p&gt;&lt;p&gt;从协议角度，只需要改变&lt;code&gt;content-type&lt;/code&gt;即可。例如想表达用 json 作为序列化格式，那具体内容为：&lt;code&gt;application/grpc+json&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在 Golang 中只需要额外加一行配置一下即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;grpc.WithDefaultCallOptions(grpc.CallContentSubtype(codec.JSON{}.Name()))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• &lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 对业务开发友好，符合 gRPC 协议的标准&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 不会影响性能&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;• 缺点：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;【方案三】&lt;/p&gt;&lt;p&gt;通过代码规范来约束字段的前后顺序，然后使用类似 protostuff 这样的框架把其他契约转换成 protobuf。&lt;/p&gt;&lt;p&gt;【最终方案】&lt;/p&gt;&lt;p&gt;经过对比后，我们选择方案二，基于如下理由：&lt;/p&gt;&lt;p&gt;1）查看 gRPC 插件生成的 Java 类，其中存在可以定制序列化器的部分的代码，使用 json 改写序列化器是可能的。&lt;/p&gt;&lt;p&gt;2）对于 Golang 来说，天然支持这种使用方式。&lt;/p&gt;&lt;p&gt;3）对于 Node.js 和 Python 等动态语言，替换序列化器非常简单。&lt;/p&gt;&lt;p&gt;4）Dubbo 支持 POJO 并且基于 Java POJO 的服务定义方式在携程大多数应用的开发形式。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;技术实现细节&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;【去契约化】&lt;/p&gt;&lt;p&gt;原生的 gRPC 基于 proto 文件，依赖 gRPC 的插件完成代码生成。&lt;/p&gt;&lt;p&gt;Dubbo 中的 gRPC 依赖 proto 文件生成 gRPC 代码的同时，需要还要配合 Dubbo 扩展的 proto 插件生成&lt;code&gt;DubboGprcWrapper&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;Dubbo 本身为 gRPC 做了包装，可以让 gRPC 协议的入口复用 dubbo 本身的注册发现，服务注册与发现以及负载均衡等扩展。&lt;/p&gt;&lt;p&gt;proto 文件生成 gRPC 代码本质上有两部分，一部分是对服务的定义，另一部分是对 DTO 的定义和 DTO 的序列化反序列化代码。&lt;/p&gt;&lt;p&gt;如果只有代码而没有 proto，我们可以依靠反射服务接口类来实现获取服务和 DTO 的定义。&lt;/p&gt;&lt;p&gt;而 DTO 的序列化反序列化，如果替换成 json 或 hessian，那就不依赖 gRPC 生成的代码了，只要有 POJO 就可以处理。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;XXXMethodDefinition.setResponseMarshaller(io.grpc.protobuf.ProtoUtils.marshaller(InputType.getDefaultInstance()))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码是 gRPC 插件生成的，只需要将这部分替换成其他序列化器，就可以实现序列化器的替换。&lt;/p&gt;&lt;p&gt;【Java 字节码编译技术动态编译】&lt;/p&gt;&lt;p&gt;有了上述去契约化的实现，后续我们基于 Java 字节码编译技术，直接在内存中生成对应的 gRPC 协议依赖的对象。&lt;/p&gt;&lt;p&gt;使得用户可以在代码优先的情况下，依旧可以继续开启 gRPC 协议传输。&lt;/p&gt;&lt;p&gt;同时因为 gRPC 相关类是动态生成的，我们可以在动态编译的时候为接口定制序列化器。&lt;/p&gt;&lt;p&gt;只要将序列化格式换成其他等不依赖 protobuf 结构的类，旧的服务也可以直接升级为 gRPC。&lt;/p&gt;&lt;p&gt;而 Dubbo 依赖的&lt;code&gt;DubboGprcWrapper&lt;/code&gt;的类也改由动态编译生成，至此用户将脱离契约的限制。&lt;/p&gt;&lt;p&gt;这里我们使用了基于&lt;code&gt;JDKCompiler&lt;/code&gt;实现编译器，使用 JDK8 的版本编译生成代码。&lt;/p&gt;&lt;p&gt;我们在代码中用 mustache 模板定义了代码生成的主要框架，然后根据 Java 服务类反射获取元数据渲染 Java 类。&lt;/p&gt;&lt;p&gt;部分模板代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;{#methods}}&lt;br/&gt;    {{^isMultiParameter}}&lt;br/&gt;    {{#isManyInput}}&lt;br/&gt;        {{#isManyOutput}}&lt;br/&gt;        {{/isManyOutput}}&lt;br/&gt;        {{^isManyOutput}}&lt;br/&gt;    public io.grpc.stub.StreamObserver&amp;lt;{{inputType}}&amp;gt; {{methodName}}(&lt;br/&gt;        io.grpc.stub.StreamObserver&amp;lt;{{outputType}}&amp;gt; responseObserver) {&lt;br/&gt;        return asyncUnimplementedStreamingCall(getGetStreamMethod(), responseObserver);&lt;br/&gt;     }&lt;br/&gt;        {{/isManyOutput}}&lt;br/&gt;    {{/isManyInput}}&lt;br/&gt;     {{^isManyInput}}&lt;br/&gt;        {{#isManyOutput}}&lt;br/&gt;        {{/isManyOutput}}&lt;br/&gt;        {{^isManyOutput}}&lt;br/&gt;        {{/isManyOutput}}&lt;br/&gt;    {{/isManyInput}}&lt;br/&gt;{{/methods}}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【用户无缝升级】&lt;/p&gt;&lt;p&gt;解决代码热生成之后，支持旧服务无缝升级还需要解决一些问题。&lt;/p&gt;&lt;p&gt;首先业务原生的代码实现逻辑与 gRPC 接口存在差异。&lt;/p&gt;&lt;p&gt;比如 Dubbo 的 gRPC 要求实现类需要实现&lt;code&gt;XXXBase&lt;/code&gt;接口，而实际 Code First 的用户实现类是实现了对应的&lt;code&gt;XXXInterface&lt;/code&gt;服务接口。我们也无法让用户在编码阶段使用我们动态生成类。&lt;/p&gt;&lt;p&gt;我们在动态生成时代码内部额外生成一个 Wrapped 类，该类代理业务的实际逻辑并且实现 gRPC 服务需要实现的&lt;code&gt;XXXBase&lt;/code&gt;基类。&lt;/p&gt;&lt;p&gt;并且在业务实际代码和 gRPC 代码之间实现各种兼容的逻辑。而 gRPC 接口在默认方法中调用子类的对应方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@javax.annotation.Generated(&lt;br/&gt;value = &quot;generate by CDubbo&quot;,&lt;br/&gt;comments = &quot;Source: {{protoName}}&quot;)&lt;br/&gt;public class {{className}}Wrapper extends Dubbo{{serviceName}}Grpc.{{serviceName}}ImplBase {&lt;br/&gt;    private static final TransformUtils transformUtils = CDubboInjector.getInstance(TransformUtils.class);&lt;br/&gt;    private static final CDubboUtil cDubboUtil = CDubboInjector.getInstance(CDubboUtil.class);&lt;br/&gt;    //实际的业务实现类&lt;br/&gt;    private {{serviceName}} instance;&lt;br/&gt;&lt;br/&gt;    public {{className}}Wrapper({{serviceName}} instance) {&lt;br/&gt;      this.instance = instance;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;{{#unaryMethods}}&lt;br/&gt;  // 被代理的对象&lt;br/&gt;  @Override&lt;br/&gt;  public {{outputType}} {{methodName}}({{inputType}} request) {&lt;br/&gt;    try {&lt;br/&gt;        return instance.{{methodName}}(request);&lt;br/&gt;    }catch (Throwable e) {&lt;br/&gt;        throw cDubboUtil.toGrpcException(e);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;{{/unaryMethods}}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务接口类：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public interface I{{serviceName}} extends {{serviceName}}{&lt;br/&gt;  default public void {{methodName}}({{inputType}} request, io.grpc.stub.StreamObserver&amp;lt;{{outputType}}&amp;gt; responseObserver){&lt;br/&gt;        responseObserver.onNext(this.{{methodName}}(request));&lt;br/&gt;        responseObserver.onCompleted();&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们在 Spring 注入的时候更新&lt;code&gt;BeanDefinition&lt;/code&gt;来实现替换，将包装类设置为服务实现类的 Wrapper。&lt;/p&gt;&lt;p&gt;客户端这边也做类似的兼容逻辑。&lt;/p&gt;&lt;p&gt;上述过程完成后，用户只要在&lt;code&gt;ProtocolConfig&lt;/code&gt;配置中明确申明使用 gRPC，就会自动为服务和客户端开启 gRPC 协议。&lt;/p&gt;&lt;p&gt;【新老方法兼容之&lt;code&gt;CompletableFuture&lt;/code&gt;】&lt;/p&gt;&lt;p&gt;改动生成服务上下文的时候标注该方法是&lt;code&gt;CompletableFuture&lt;/code&gt;方法，在服务端的默认实现的位置获取到&lt;code&gt;Future&lt;/code&gt;之后更改对应的方法转换为&lt;code&gt;ResponseObserver&lt;/code&gt;。直接更新Dubbo部分代码生成的结果。&lt;/p&gt;&lt;p&gt;对应的更改的模板文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; {{methodName}}({{inputType}} request, io.grpc.stub.StreamObserver&amp;lt;{{outputType}}&amp;gt; responseObserver){&lt;br/&gt;            CompletableFuture&amp;lt;{{outputType}}&amp;gt; response = &lt;span&gt;this&lt;/span&gt;.{{methodName}}(request);&lt;br/&gt;           response.whenComplete((res,thr)-&amp;gt;{&lt;br/&gt;             &lt;span&gt;if&lt;/span&gt;(thr == &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;               responseObserver.onNext(res);&lt;br/&gt;               responseObserver.onCompleted();&lt;br/&gt;             }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;               responseObserver.onError(thr);&lt;br/&gt;             }&lt;br/&gt;           });&lt;br/&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端使用返回&lt;code&gt;ListenableFuture&lt;/code&gt;的方法返回&lt;code&gt;Future&lt;/code&gt;之后再使用 Guava 的工具转换成&lt;code&gt;CompletableFuture&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;{{#futureRequestMethods}}&lt;br/&gt;    public CompletableFuture&amp;lt;{{outputType}}&amp;gt; {{methodName}}({{inputType}} request) {&lt;br/&gt;          com.google.common.util.concurrent.ListenableFuture&amp;lt;{{outputType}}&amp;gt; responseFuture = futureStub&lt;br/&gt;                  .withDeadlineAfter(url.getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT), TimeUnit.MILLISECONDS)&lt;br/&gt;                  .{{methodName}}(request);&lt;br/&gt;          return FutureConverter.toCompletableFuture(responseFuture);&lt;br/&gt;        }&lt;br/&gt;{{/futureRequestMethods}}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【Stream 方法原地升级】&lt;/p&gt;&lt;p&gt;Dubbo 中并没有类似 gRPC Stream 的支持，所以我们基于 Dubbo Callback 进行了扩展。&lt;/p&gt;&lt;p&gt;CDubbo 中扩展后的接口所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;StreamContext&lt;/span&gt;&amp;lt;T&amp;gt; {&lt;br/&gt;    Result &lt;span&gt;write&lt;/span&gt;(T v);    &lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;();&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将 dubbo 协议升级到 gRPC 协议后如何对接到 gRPC Stream 呢？&lt;/p&gt;&lt;p&gt;我们在服务 Wrapper 里面 针对 gRPC 的&lt;code&gt;ResponseObserver&lt;/code&gt;转换成对应的&lt;code&gt;StreamContext&lt;/code&gt;传递给服务的实现类：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;StreamContext&amp;lt;{{outputType}}&amp;gt; streamContext = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StreamContext&lt;/span&gt;&amp;lt;{{outputType}}&amp;gt;() {&lt;br/&gt;          &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;public&lt;/span&gt; Result &lt;span&gt;write&lt;/span&gt;({{outputType}} v) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;              responseObserver.onNext(v);&lt;br/&gt;              &lt;span&gt;return&lt;/span&gt; Result.SUCCESSFUL;&lt;br/&gt;            }&lt;span&gt;catch&lt;/span&gt; ( Exception e){&lt;br/&gt;              &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;RuntimeException&lt;/span&gt;(e);&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt; &lt;br/&gt;          &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;() {&lt;br/&gt;            responseObserver.onCompleted();&lt;br/&gt;          }&lt;br/&gt;        };&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;// 现在都是一个请求然后拿stream的方式 暂时也只支持这样&lt;/span&gt;&lt;br/&gt;          instance.callStreamMethod(request,streamContext);&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt; (Throwable e){&lt;br/&gt;          responseObserver.onError(e);&lt;br/&gt;        }&lt;br/&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端需要在调用 Stream 的时候将 gRPC 的响应返回回调。Stream 有统一处理响应消息的位置，只要拿到请求的 StreamId 就能把 gRPC 的响应回调给具体的某次响应。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;StreamContextImpl&lt;/span&gt; &lt;span&gt;responseObserver1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; (StreamContextImpl) responseObserver;&lt;br/&gt;    &lt;span&gt;// stream 请求有个专门处理响应的地方 streamId 表示是第几个Stream 请求的响应&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;streamId&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; responseObserver1.getStreamId();&lt;br/&gt; &lt;br/&gt;    io.grpc.stub.StreamObserver&amp;lt;{{outputType}}&amp;gt; streamObserver = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.grpc.stub.StreamObserver&amp;lt;{{outputType}}&amp;gt;() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onNext&lt;/span&gt;({{outputType}} value) {&lt;br/&gt;        &lt;span&gt;// streamManager是统一处理所有服务端响应的位置&lt;/span&gt;&lt;br/&gt;        streamManager.dispatch(streamId,value);&lt;br/&gt;      }&lt;br/&gt; &lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onError&lt;/span&gt;(Throwable t) {&lt;br/&gt;        &lt;span&gt;// 服务端报错就直接抛异常&lt;/span&gt;&lt;br/&gt;        streamManager.killWithException(streamId);&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;RuntimeException&lt;/span&gt;(t);&lt;br/&gt;      }&lt;br/&gt; &lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onCompleted&lt;/span&gt;() {&lt;br/&gt;          &lt;span&gt;// 服务端结束 则客户端把对应的entry 结束掉&lt;/span&gt;&lt;br/&gt;        streamManager.kill(streamId);&lt;br/&gt;      }&lt;br/&gt;    };&lt;br/&gt;    stub.withDeadlineAfter(url.getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT), TimeUnit.MILLISECONDS)&lt;br/&gt;            .getStreamResponse(request, streamObserver);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【服务端自动选择序列化器】&lt;/p&gt;&lt;p&gt;Java 中既然可以替换默认的序列化器，那么也可以实现根据 Content Type 自动选择序列化器。&lt;/p&gt;&lt;p&gt;我们在代码生成的时候为 gRPC 注入一个用于桥接的序列化器&lt;code&gt;BridgeMarshaller&lt;/code&gt;，而不是一个特定的序列化器。&lt;/p&gt;&lt;p&gt;因为序列化器中没有办法拿到 Header，所以需要找一个扩展点从 Header 里面获取 Content Type，并通过上下文传递到序列化线程。&lt;/p&gt;&lt;p&gt;我们发现了&lt;code&gt;StreamTracer&lt;/code&gt;这个扩展，虽然它的原始目的是为了处理 Trace Context，但和我们要做的事情是一样的，都是提取 Header 里的数据放到上下文中。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Trace Context：实现分布式追踪时需要透传相关上下文，在 HTTP 调用中一般将它放在 Header 中。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;StreamTracer&lt;/code&gt;扩展：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;CDubboGrpcConfigurator&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;GrpcConfigurator&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;CDubboUtil&lt;/span&gt; &lt;span&gt;cDubboUtils&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; CDubboInjector.getInstance(CDubboUtil.class);&lt;br/&gt;  &lt;span&gt;// 获取header 传递上下文&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; NettyServerBuilder &lt;span&gt;configureServerBuilder&lt;/span&gt;(NettyServerBuilder builder, URL url) {&lt;br/&gt;    builder.addStreamTracerFactory(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ServerStreamTracer&lt;/span&gt;.Factory() {&lt;br/&gt;      &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;public&lt;/span&gt; ServerStreamTracer &lt;span&gt;newServerStreamTracer&lt;/span&gt;(String fullMethodName, Metadata headers) {&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; &lt;span&gt;contentType&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; cDubboUtils.extractContextType(headers);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ServerStreamTracer&lt;/span&gt;() {&lt;br/&gt;          &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;public&lt;/span&gt; Context &lt;span&gt;filterContext&lt;/span&gt;(Context context) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; context.withValue(GrpcConstants.Serialization.SERIALIZATION_KEY, contentType);&lt;br/&gt;          }&lt;br/&gt;        };&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; builder;&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;序列化选择：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;GenericMarshaller&lt;/span&gt;&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;MethodDescriptor&lt;/span&gt;.Marshaller&amp;lt;T&amp;gt; {&lt;br/&gt;  &lt;span&gt;//.....&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; T &lt;span&gt;parse&lt;/span&gt;(InputStream stream) {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;serialization&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; cDubboUtil.getSerialization(GrpcConstants.Serialization.SERIALIZATION_KEY.get());&lt;br/&gt;    &lt;span&gt;GrpcSerialization&lt;/span&gt; &lt;span&gt;grpcSerialization&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; SERIALIZATION_MAP.get(serialization);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(grpcSerialization == &lt;span&gt;null&lt;/span&gt;){&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;(&lt;span&gt;&quot;can not find any serialization [&quot;&lt;/span&gt; + serialization + &lt;span&gt;&quot;] by content-type in header.&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; grpcSerialization.getMarshaller(clazz).parse(stream);&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CDubbo 升级 gRPC 后默认使用&lt;code&gt;hessian2&lt;/code&gt;作为序列化器与 Dubbo 原生保持一致，尽量避免引入兼容性问题。&lt;/p&gt;&lt;p&gt;而其他语言例如 Golang 等就可以选择使用 json，而且并不需要 protobuf 定义契约，直接调用 gRPC 底层方法即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {&lt;br/&gt;    conn, err := grpc.Dial(&lt;span&gt;&quot;127.0.0.1:9080&quot;&lt;/span&gt;,&lt;br/&gt;        grpc.WithDefaultCallOptions(grpc.CallContentSubtype(codec.JSON{}.Name())), &lt;span&gt;// codec.JSON 只要实现 gRPC 的`encoding.Codec`接口即可&lt;/span&gt;&lt;br/&gt;        grpc.WithTransportCredentials(insecure.NewCredentials()),&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;%v\n&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    resp := &lt;span&gt;new&lt;/span&gt;(CheckHealthResponse) &lt;span&gt;// Response 可以用 Code First 自己构建&lt;/span&gt;&lt;br/&gt;    err = conn.Invoke(context.Background(),&lt;br/&gt;        &lt;span&gt;&quot;/com.test.TestService/CheckHealth&quot;&lt;/span&gt;, &lt;span&gt;// 这部分是 Java 中的服务接口完整名称 + 方法名&lt;/span&gt;&lt;br/&gt;        CheckHealthRequest{Message: &lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;}, &lt;span&gt;// Request 可以用 Code First 自己构建&lt;/span&gt;&lt;br/&gt;        resp, grpc.EmptyCallOption{})&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;%v\n&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;%+v\n&quot;&lt;/span&gt;, resp)&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外如果这个 Dubbo 服务本身就是用 protobuf 做契约的，那么 prodobuf 也是可以使用的。&lt;/p&gt;&lt;p&gt;【gRPC 中异常传递】&lt;/p&gt;&lt;p&gt;而在 gRPC 的原生 API 中响应是缺少这部分数据的。服务处理的异常不 catch 直接会在客户端转化为 &lt;code&gt;StatusRuntimeException: UNKNOWN&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &lt;/code&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;getLatest&lt;/span&gt;(User request, StreamObserver&amp;lt;CallHistory&amp;gt; responseObserver) {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; request.getName();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      Integer.parseInt(name);&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt; (Throwable e){&lt;br/&gt;       &lt;span&gt;// grpc 这边默认是可以带有异常 但是显示抛出&lt;/span&gt;&lt;br/&gt;      responseObserver.onError(INVALID_ARGUMENT.withCause(e).withDescription(&lt;span&gt;&quot;服务内部错误&quot;&lt;/span&gt;).asRuntimeException());&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们上述代码中已经对服务实现类做了一层 wrapper，实现了 gRPC API 之间的兼容。&lt;/p&gt;&lt;p&gt;由于我们是基于 Dubbo 开发的，Dubbo 遇到未知异常会转换成&lt;code&gt;RpcException&lt;/code&gt;。如果我们不处理，这个异常在 gRPC 中就是&lt;code&gt;UNKNOWN&lt;/code&gt;。因此需要在底层把&lt;code&gt;RpcException&lt;/code&gt;和&lt;code&gt;GrpcException&lt;/code&gt;的转换。将一般错误变为 gRPC 的异常抛出。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、配置按需下发&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在集群规模较小时，Service Mesh 中的每个服务默认可以访问任何其他的服务是没有问题的。但是当集群规模变大之后，就会出现以下问题：&lt;/p&gt;&lt;p&gt;在实际的服务调用关系中，一个服务并不会真的要访问所有其他的服务，相对于服务的总量而言，每个服务只会访问到很小一部分的服务。&lt;/p&gt;&lt;p&gt;我们需要找到一种方式来管理服务间的调用依赖关系，并且能让 Istio 根据这份调用关系，减少推送的频率和数据量。也就是说，当 A 服务发生变化时，只有依赖 A 服务的其他服务会收到推送。&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.1 解决方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 Istio 中，可以通过&lt;code&gt;Sidecar&lt;/code&gt;资源对 Sidecar 进行配置。例如如下的&lt;code&gt;Sidecar&lt;/code&gt;配置，svc-a 需要访问 svc-b 和 svc-c，当 svc-b 和 svc-c 的配置变化时，svc-a 的代理会收到推送，而其他 svc 的配置变更，并不需要推送给 svc-a 的代理：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;networking.istio.io/v1beta1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Sidecar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;svc-a&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;prod&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;egress:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;hosts:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;prod/svc-b.soa.mesh&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;prod/svc-c.soa.mesh&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;istio-system/*&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;workloadSelector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;svc-a&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样可以解决推送量大和推送频率高的问题。&lt;/p&gt;&lt;p&gt;但是随之而来的新问题是，怎么知道 svc-a 需要访问 svc-b 和 svc-c 呢？一种直接的方式是，接入 Service Mesh 之前分析好服务调用依赖，配置到 &lt;code&gt;Sidecar&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;携程目前并没有为所有服务之间梳理过调用关系，这种方式会给接入 Service Mesh 的用户带来负担，我们需要一种更加自动化的方式来透明地解决服务依赖关系的问题。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我们内部将所有的服务都映射到了&lt;code&gt;.soa.mesh&lt;/code&gt;这个域名上。例如一个用户服务的域名是：&lt;code&gt;user.soa.mesh&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们采取的方案是为每个&lt;code&gt;Sidecar&lt;/code&gt;加一条 host 为&lt;code&gt;*.soa.mesh&lt;/code&gt; 的路由，其中的路由目标设置为一个默认的 Gateway。当访问一个不在&lt;code&gt;Sidecar&lt;/code&gt;资源的&lt;code&gt;egress.hosts&lt;/code&gt;里列出的服务时，都会匹配到这条兜底路由，转发到 Gateway 进行处理。Gateway 收到这条转发过来的请求后，也就知道了服务间的调用依赖关系。转发这条请求的时候通过一定的机制去更新&lt;code&gt;Sidecar&lt;/code&gt;资源。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.878125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1ewz3qbqo4C1t6GzBJYKKh29vfFpkYiayxlIq6YFAqbz7FXsaCcjpe5icgc65iaxQ8oyukZungVERGEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图中的兜底路由通过 Host 做了分片，因为单个 Gateway 也无法承载所有的服务。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;最初我们考虑创建一个&lt;code&gt;hosts&lt;/code&gt;为&lt;code&gt;*.soa.mesh&lt;/code&gt;的&lt;code&gt;VirtualService&lt;/code&gt;来让 Istio 生成对应的路由，但是实际测试发现这种方式无法达到预期的效果，Istio 在处理包含&lt;code&gt;*&lt;/code&gt;前缀域名的时候有点问题。另外如果想把这条路由下发到 Sidecar，那我们也必须在&lt;code&gt;Sidecar&lt;/code&gt;资源里加上&lt;code&gt;*.soa.mesh&lt;/code&gt;。但如果这么一加，岂不是就把所有服务下发下去了？&lt;/p&gt;&lt;p&gt;最终我们通过&lt;code&gt;EnvoyFilter&lt;/code&gt;的方式，为每个 Sidecar 来 patch 这条兜底路由。因为 Istio 中的&lt;code&gt;EnvoyFilter&lt;/code&gt;作用在更底层，并不受&lt;code&gt;Sidecar&lt;/code&gt;资源的控制。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;EnvoyFilter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;soa-default-route&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;configPatches:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;applyTo:&lt;/span&gt; &lt;span&gt;VIRTUAL_HOST&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;match:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;SIDECAR_OUTBOUND&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;routeConfiguration:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;&quot;80&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;patch:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;operation:&lt;/span&gt; &lt;span&gt;ADD&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;value:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mesh-soa-gateway&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;domains:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;*.soa.mesh&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;*.soa.mesh:80&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;routes:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;match:&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;prefix:&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;route:&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;cluster:&lt;/span&gt; &lt;span&gt;outbound|80||mesh-soa-gateway&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;timeout:&lt;/span&gt; &lt;span&gt;0s&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;                &lt;span&gt;max_grpc_timeout:&lt;/span&gt; &lt;span&gt;0s&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;六、未来展望&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;6.1 WebAssembly&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;在 Service Mesh 中引入 WebAssembly 应该来说是一个大趋势，这也是 Service Mesh 的一大优势，不把这个优势利用好就太浪费了。&lt;/section&gt;&lt;section&gt;一方面，Istio 的内置功能不可能覆盖所有公司的业务需求。另一方面，各个事业部或部门也常常会有一些团队公共需求。&lt;/section&gt;&lt;section&gt;如果能将这些功能通过 WebAssembly 实现热加载、热更新，那 Service Mesh 的价值就被充分地发挥了。&lt;/section&gt;&lt;section&gt;抱着这个美好的愿景，我们在前期就调研了 Istio 中 WebAssembly 模块的功能、性能和易用性。&lt;/section&gt;&lt;section&gt;只可惜在一年多前这块还是有不少问题的，包括 Sidecar 占用内存大增、内存泄露、WebAssembly SDK 扩展性不够等。&lt;/section&gt;&lt;section&gt;目前我们内部的 Istio 版本经过了不少定制化，所以还停留在 1.10 版本，并不会紧跟官方最新版。&lt;/section&gt;&lt;section&gt;但后续随着官方对 WebAssembly 功能的完善，将静态编译的 Envoy C++ Filter 迁移到 WebAssembly 上必定是一个趋势。&lt;/section&gt;&lt;section&gt;&lt;span&gt;6.2 Sidecar 模式&lt;/span&gt;&lt;/section&gt;&lt;p&gt;Service Mesh 背后的模式一般被称为 Sidecar 模式。&lt;/p&gt;&lt;p&gt;这种模式是否可以扩展到其他领域？Service Mesh 只是解决了 SOA 这个领域的问题，能否把这种模式扩展到其它领域？充分发挥 Sidecar 模式的优势？&lt;/p&gt;&lt;p&gt;这是很多人会问的问题。&lt;/p&gt;&lt;p&gt;如果把所有模块都做成了 Sidecar 模式，我觉得要想清楚2个问题：&lt;/p&gt;&lt;p&gt;1）相关模块能接受额外 1ms 的响应延迟吗？Sidecar 带来的优势能否弥补这个问题？&lt;/p&gt;&lt;p&gt;2）Sidecar 模式和 Proxy 模式的本质区别是什么？&lt;/p&gt;&lt;p&gt;引入 Sidecar 势必会引入额外的性能损耗，不经特殊优化的情况下 Istio 最好响应延迟也要增加 1ms 以上，不能忽略了这部分的影响。&lt;/p&gt;&lt;p&gt;例如 Redis 中，额外引入 1ms 的响应延迟一般是无法接受的。&lt;/p&gt;&lt;p&gt;在关系型数据库中，通过 Proxy 来实现读写分离和分库分表是一种很常见的做法，Sidecar 模式本质上也是一种 Proxy。&lt;/p&gt;&lt;p&gt;那它和传统 Proxy 模式有什么区别呢？&lt;/p&gt;&lt;p&gt;它们最大的区别就在于这个代理部署在哪里。如果在客户端一侧，那就是 Sidecar 模式；如果在服务端一侧，那就是 Proxy 模式。&lt;/p&gt;&lt;p&gt;对于这两种模式如何取舍呢？&lt;/p&gt;&lt;p&gt;如果服务端并不是分布式的，或者目标服务器在同一个机房离得很近，那在服务器同一个机房部署一套 Proxy 集群维护起来会更加方便。&lt;/p&gt;&lt;p&gt;而 SOA 最大的特点是一个应用往往既是客户端也是服务端，调用关系是网状的。&lt;/p&gt;&lt;p&gt;对于 SOA 来说，在 Sidecar 和 Proxy 之间也就只有 Sidecar 可选了。&lt;/p&gt;&lt;p&gt;所以，想在其他模领域引入 Sidecar 模式前要把这两个问题想清楚了，而不是无脑地引入 Sidecar 模式。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、总结 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;携程的 Service Mesh 从启动到现在经历了将近2年的时间，正式上线也有 1 年多了。当前已经接入了大约 2000 个应用、4000 个服务和6000 个 Pods，并且一直保持着稳定运行，也经受住了各种故障演练的考验。&lt;/p&gt;&lt;p&gt;接入 Service Mesh 后，很多 Bug 仅需修改一下控制面代码或配置就可以轻松地实现热更新；原来的 SOA SDK 也进入了冻结维护状态不再开发新功能；公司内部大量非 Java 应用也可以轻松地接入 SOA 体系。这让 SOA 团队可以为公司产出更大的价值。&lt;/p&gt;&lt;p&gt;当然，还有许多挑战摆在我们的面前：WebAssembly 还未发挥应有的作用；dubbo 升级 gRPC 也还未在生产部署；控制面的性能指标依然不能达到我们的要求等。这些是我们接下来需要去解决的。&lt;/p&gt;&lt;p&gt;最后，希望本文中提到的各种问题和解决方案能给大家带来帮助和启发。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;【推荐阅读】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1ewz3qbqo4C1t6GzBJYKKh2WNcg8BhiaicUpWmnhzyia4AngsAgCMu6ISURVUwnyPgeObpVORmSR34LA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>