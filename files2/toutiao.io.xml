<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cf4cf5c4c47ca5111083c56833e051e8</guid>
<title>多功能猫咪爬架，点击链接立即购买！</title>
<link>https://toutiao.io/k/2qh6etz</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;


&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aab91ceb3985ec9e018001c3be0408bf</guid>
<title>[推荐] 阿里专家：如何画出优秀的架构图？</title>
<link>https://toutiao.io/k/92sk26n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0ce6332a80e1c8c88a3c6cb74cd1dc00</guid>
<title>[推荐] 如何撰写好的技术方案设计-真实案例干货分享</title>
<link>https://toutiao.io/k/0f5fv4t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;一、 前言&lt;br/&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个技术开发者，特别是高级、资深开发、架构师等，往往会遇到根据需求撰写技术方案。那么如何撰写一篇好的技术方案设计，我们今天就来聊一聊这个话题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、 技术方案是否有必要&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是肯定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我见过太多由于前期规划不到位（甚至是没有技术方案设计，开个技术讨论会口头沟通一下，就直接评工期开干的），这其中不乏很重要，工期很长的项目。而最后呢，到联调阶段各组串不起来，更可笑的是，产品和产品同学之间都没沟通清楚。导致最终很被动，到处挖坑补洞，而且花费了更多的时间和精力，甚至导致项目延期，后续扩张性不强等等问题。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我认为，技术方案是必不可少的一个环节。往往很多坑在这个阶段就可以避免的。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;古人云:&quot;磨刀不误砍柴工&quot;，技术方案就是磨刀的过程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.282339707536558&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67WicOEAfAcyiaosXCicREoJVkCPrLdvThA88KIdpqSibJ3aiatGQqWRxbwfJ6kicGjaxZk3kSUCB5yUnWLOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;方案设计&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、 如何写好技术方案&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要贴合需求，满足需求是大方向。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可实施。要考虑当前条件下是否可落地，如：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;团队人员接受能力:技术选型的时候，要考虑团队成员接受能力，盲目引入新技术，可能造成不可预知的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时间成本:  一般来说Java 或者 PHP 后端项目(c语言项目可能会做一年甚至更长时间)，3个月时间周期算是比较长的了，假如按照此方案，需要半年甚至更长时间，那可能也不切实际。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源成本: 例如，项目可能需要引入Redis，Mysql，ES， MongoDB 等基础资源，那公司是否能提供这些资源(服务器是要钱的)。如果不能，在写技术方案时候，可能就需要考虑是否有替代方案。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应急处理&amp;amp;可靠性保障
只要人能想到的问题，就一定会发生，不能有侥幸心理。所以要做好出现问题的应对策略，这里就必须做好如：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、技术方案模板&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是我总结的技术方案设计模板，希望对大家所有帮助。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、背景&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前的背景现状，简要说明以往业务所遇到的问题，给出本次项目迭代的原因，解决的技术痛点或业务痛点&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、目标&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过次方案要达到什么样的业务指标，例如，支撑多少QPS，性能相比现在提升多少倍，为后期水平扩展做铺垫&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、整体方案&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1)架构图
2)流程图
3)时序图
4)调用链路图&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、存储设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如Mysql表结构设计，缓存设计，ES存储设计等等，说明Schema、字段类型、默认值、描述信息等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、接口定义&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列举出接口的结构，参数，返回值等&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6、灰度方案&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按什么方式灰度，如何做灰度方案，用表格的形式列出分几个阶段灰度，每个阶段大概时间多长。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7、降级方案&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当出现问题如何降级操作，如何回滚。将风险降到最低程度。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8、关联系统(功能)影响&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点需要各组注意的地方，相关人员需要特别关注，一一确认到位&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9、资源分配情况&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;人力资源: 实现方案需要多少人力投入(开发人力，测试人力，运维人力)等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;硬件资源: 实现上述方案，列举需要哪些物理机器资源，运维人员需提前准备。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10、预估工期及时间节点&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列举出工期及关键时间节点，如，什么时候联调，什么时候提测，什么时候开始灰度上线，以及后续的迭代完善计划等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、温馨提示&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也给大家总结了我之前做系统重构写的技术方案设计文档（线上真实版本，已脱敏)，给大家总结了2套， 有需要的朋友可以公众号后台留言&quot;方案&quot;即可获取，也欢迎有兴趣的朋友一起交流学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67WicS8obXBjC9RqxibSJcgOsnicwSlKjFSxuEECwjZjYS8Y9zpmCdyv6z4yeSicSQSDNz2XUzRppBjuGXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a83ade3bd82e01dceec2c32d4fda8ca</guid>
<title>[推荐] Go 原生并发原语和最佳实践</title>
<link>https://toutiao.io/k/rdpao5x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 编程语言是用并发作为一等公民创建的。它是一种语言，通过抽象出语言中并发原语1背后的并行性细节，您可以轻松编写高度并行的程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数语言都将并行化作为标准库的一部分，或者期望开发者生态系统提供并行化库。通过在 Go 语言中包含并发原语，你可以编写并行性的程序，而无需了解编写并行代码的来龙去脉。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、并发（Concurrent）设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的设计者非常重视并发设计，将其作为一种方法论，这种方法论的基础是交流关键信息，而不是阻塞和共享这些信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对并发设计的强调允许应用程序代码正确地按顺序或并行执行，而无需设计和实现并行化，这是常态。并发设计的想法并不新鲜，事实上一个很好的例子是从瀑布式开发到敏捷开发，这实际上是向并发工程实践（早期迭代、可重复过程）的转变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发设计是关于编写“正确”程序与编写“并行”程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中构建并发程序时要问的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我是否堵塞在临界区？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否有更正确（如以 Go 为中心）的方式来编写此代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我可以通过通信来提高代码的功能性和可读性吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果其中任何一个是 Yes，那么你应该重新考虑你的设计，考虑用 Go 的最佳实践。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Communicating Sequential Processes (CSP)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言的一部分的基础来自 Hoare 的一篇论文，该论文讨论了语言需要将并发视为语言的一部分而不是事后的想法。该论文提出了一种线程安全队列，它允许应用程序中不同进程之间的数据通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通读这篇论文，你会发现Go 中的  &lt;code&gt;channel&lt;/code&gt; 原语与论文中对原语的描述非常相似，实际上这来自 Rob Pike 之前基于 CSP 构建语言的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pike 的一次演讲中，他将真正的问题确定为“需要一种方法来编写并发软件，以指导我们的设计和实现。”他接着说并发编程不是让程序并行化以更快地运行，而是“利用流程和通信的力量来设计优雅、响应迅速、可靠的系统。”&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通过通信实现并发&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从 Go 的创建者那里听到的最常见的短语之一是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Don’t communicate by sharing memory, share memory by communicating. - Rob Pike&lt;/p&gt;&lt;p&gt;即：不要通过共享内存来通信，而是通过通信来共享内存。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种观点反映了 Go 是基于 CSP 的事实，并且该语言具有用于在线程之间通信的本机原语（goroutine）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的代码是使用通信而不是使用 mutex 来管理对共享资源的访问的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Adapted from https://github.com/devnw/ttl&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// a TTL cache implementation for Go.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readwriteloop&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;   &lt;span&gt;// Create a channel to send data to.&lt;/span&gt;&lt;br/&gt;  outgoing = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    incoming &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    outgoing &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;interface&lt;/span&gt;{},&lt;br/&gt;    )&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(outgoing)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// `value` is the shared &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// resource or critical section.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// incoming is the channel where data is&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// sent to set the shared resource.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; v, ok := &amp;lt;-incoming:&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// Exit the go routine.&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Write the data to the shared resource.&lt;/span&gt;&lt;br/&gt;        value = v.v&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// outgoing is the channel that &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// the shared resource on request&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- value:&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(incoming, outgoing)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; outgoing&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们看一下代码，看看它做了什么。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;请注意，这没有使用 &lt;code&gt;sync&lt;/code&gt; 包或任何阻塞函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此代码仅使用 Go 并发原语 &lt;code&gt;go&lt;/code&gt;,&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;chan&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;共享资源的所有权由 goroutine 管理。（第 17 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使该方法包含一个 goroutine，对共享资源的访问也不会并行发生。（第 30 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该 &lt;code&gt;select&lt;/code&gt; 语句用于检查读取或写入请求。（第 24 和 34 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 incoming 会更新该值。（第 24 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 goroutine 外部读取的通道使用共享资源的当前值执行对 outgoing 写入。（第 34 行）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于单个 goroutine 本身没有并行性，因此可以通过返回的只读通道安全地访问共享资源 。事实上，&lt;code&gt;select&lt;/code&gt; 这里使用该语句提供了许多好处。选择原语部分对此进行了更详细的介绍。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;堵塞 vs 通信&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堵塞：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;暂停临界区读/写的进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解阻塞的&lt;strong&gt;必要性&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要了解如何避免竞争和死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素由多个进程/线程直接共享&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通信：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据要求共享临界区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当有事情要做时，进程开始工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存元素是通过通信共享，而不是直接共享的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、Go 原生并发原语&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Goroutine&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 Goroutine？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goroutine 是轻量级的线程。一旦 goroutine 从父 goroutine 中分离出来，它就会被移交给 Go 运行时执行。然而，与&amp;amp;in不同的是，bash这些进程被安排在 Go 运行时中执行，而不必并行执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2294455066921606&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowRmDVNKzB72JQwjiaFbUqiaz6lwnibYdtV5HkMD8hIKGgIaVR6NeIpWYGZAheTjDXlLVgWCGgOat49VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;Goroutine 拆分示例&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里“调度”的区别很重要，因为 Go 运行时多路复用 goroutine 的执行，以提高操作系统调度之上的性能。这意味着无法对 goroutine 何时执行做出任何假设。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 的泄露&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由 &lt;code&gt;go&lt;/code&gt; 原语创建的 goroutine 很轻量，但重要的是要知道它们&lt;strong&gt;不是&lt;/strong&gt;免费的。清理 goroutine 对于确保在 Go 运行时中正确收集资源非常重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该花时间在设计上考虑清理。确保长时间运行的 goroutine 在发生故障时正确退出。同样重要的是不要创建无数的 goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成一个 goroutine 很简单，因此很容易无节制的生成新的 goroutine，生成的每个 goroutine 的最小开销约为 2kb。如果你的代码创建了太多 goroutine，并且每个 goroutine 都有很大的开销，那么栈空间可能不够。这在生产环境中调试起来非常困难，因为很难判断堆栈在哪里溢出以及堆栈在哪里泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当发生堆栈溢出时，运行时将 panic，程序将退出，每个 goroutine 都会将堆栈信息打印到标准错误。这会在日志中产生大量噪音并且不是很有用。不仅堆栈信息没有用，而且还会输出大量数据（每个 goroutine 的日志，包括它的标识符和状态）。这也很难调试，因为通常操作系统上的日志缓冲区可能太小而无法容纳所有堆栈信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：公平地说，我只在应用程序使用&lt;strong&gt;超过 400,000 个&lt;/strong&gt;大型 goroutine 的生产环境中看到这种情况。这可能很少见，对于大多数应用程序来说都不是问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TL;DR：设计 goroutines 时要考虑到最终结果，以便它们在完成时正确停止。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Goroutine 中的 panic&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，Go 应用程序中的 panic 是违反最佳实践的，应该避免。代替 panic，你应该返回并处理函数中的错误。但是，如果有必要使用  &lt;code&gt;panic&lt;/code&gt;，必须知道，在 goroutine 如果没有 defer 的 recover，panic 会导致整个应用程序崩溃。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;最佳实践：&lt;/strong&gt;不要 Panic！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在生产环境中非常难以调试，因为它需要&lt;code&gt;stderr&lt;/code&gt;重定向到文件，因为你的应用程序很可能作为守护进程运行。如果你有一个日志聚合器并且它被设置为监控标准错误或文件日志，这会更容易。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果不确定，可以在 goroutine 增加 defer/recover&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; r := &lt;span&gt;recover&lt;/span&gt;(); r != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// Handle Panic HERE&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Channels&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go 中的 Channel 是什么？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源自 Hoare (1977) 的 Communicating Sequential Processes 论文通道是 Go 中的一种通信机制，它支持以线程安全的方式传输数据。它可用于安全有效地在并行 goroutine 之间进行通信，而无需 mutex。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道将构建并行代码的困难抽象到 Go 运行时，并提供了一种在 goroutine 之间进行通信的简单方法。从本质上讲，通道的最简单形式是数据队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 Rob Pike 的话来说：“Channels orchestrate; mutexes serialize.”&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通道在 Go 中是如何工作的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，通道是阻塞的。这意味着，如果你尝试从通道读取，它将阻止该 goroutine 的处理，直到有要读取的内容（即数据发送到通道）。同样，如果你尝试写入通道并且没有数据消费者（即从通道读取），它将阻止该 goroutine 的处理，直到有消费者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，围绕通道有一些非常重要的行为。Go 运行时被设计为非常高效，因此如果有一个 goroutine 在读取或写入通道上被阻塞，则运行时将在等待执行某些操作时使 goroutine 休眠。一旦通道有生产者或消费者，它将唤醒阻塞的 goroutine 并继续处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解这一点非常重要，因为它允许你通过使用通道显式地利用系统的 CPU 争用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 一个 nil 通道总是堵塞&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭 Channel&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;channel 完成后，最好关闭它。这通过 &lt;code&gt;close&lt;/code&gt; 实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时可能无法关闭通道，因为它会在应用程序的其他地方引起 panic（即往关闭的通道写入）。在这种情况下，当通道超出作用范围时，它将被垃圾收集。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果通道被限制在同一个作用域（即函数），你可以使用 &lt;code&gt;defer&lt;/code&gt;关键字来保证函数返回时通道是关闭的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(ch) &lt;span&gt;// Close the channel when func returns&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个通道关闭时，不允许再写入。注意关闭通道的方式非常重要，因为如果你尝试写入已关闭的通道，运行时将 panic。因此，过早关闭通道可能会产生意想不到的副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道关闭后，它将不再阻塞读取。这意味着所有阻塞在通道上的 goroutine 都将被唤醒并继续处理。读取时返回的零值将是通道类型的值，读取返回的第二个值将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Create the channel&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Do something with the channel&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Close the channel&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Read from closed channel&lt;/span&gt;&lt;br/&gt;  data, ok := &amp;lt;-ch&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;// Channel is closed&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在上面的示例中关闭了通道，则 &lt;code&gt;ok&lt;/code&gt;参数将是 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;  只读 channel 不能关闭&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 类型&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中有几种不同类型的通道。它们每个都有各自的优点和缺点。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;无缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Unbuffered channels are the simplest type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建无缓冲通道，请调用 make 函数，并提供通道类型。不要在第二个参数中提供大小值，如上例所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无缓冲通道默认是阻塞的，并且会阻塞 goroutine 直到有东西要读取或写入。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓冲 Channels&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Buffered channels are the other primary type of channel.&lt;/span&gt;&lt;br/&gt;  ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要创建缓冲通道，调用 make 函数，提供通道类型和缓冲区大小。上面的示例将创建一个缓冲区大小为 10 的通道。如果你尝试写入已满的通道，它将阻塞 goroutine，直到缓冲区中有空间。如果你试图从一个空的通道中读取，它将阻塞 goroutine，直到有东西要读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你想写入通道并且缓冲区有可用空间，则它不会阻塞 goroutine。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 通常，仅在真的需要时才使用缓冲通道。最佳实践是使用无缓冲通道。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;只读和只写 Channels&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通道的一个有趣用例是拥有一个仅用于读取或写入的通道。当你有一个需要从通道读取但你不希望该 goroutine 写入时，这很有用，反之亦然。这对于下面描述的所有者模式特别有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是创建只读或只写通道的语法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Define the variable with var&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; writeOnly &lt;span&gt;chan&lt;/span&gt;&amp;lt;- &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; readOnly &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  mychan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Assign the channel to the variable&lt;/span&gt;&lt;br/&gt;  readOnly = mychan&lt;br/&gt;  writeOnly = mychan&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;箭头指示通道的方向。&lt;code&gt;chan&lt;/code&gt;前面的箭头表示数据流进入通道，而 &lt;code&gt;chan&lt;/code&gt; 后面的箭头表示数据流流出通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读通道的一个示例是&lt;code&gt;time.Tick&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;// Tick is a convenience wrapper for NewTicker providing access to the ticking&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// channel only&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Tick&lt;/span&gt;&lt;span&gt;(d Duration)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;Time&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法返回一个只读通道，&lt;code&gt;time&lt;/code&gt;包以指定的时间间隔在内部写入该通道。这种模式确保了时钟滴答的实现逻辑与&lt;code&gt;time&lt;/code&gt;包隔离，因为用户不需要往通道写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要写入通道但你知道 goroutine 不需要从中读取时，只写通道非常有用。下面描述的所有者模式就是一个很好的例子 。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Channels 的设计注意事项&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计注意事项包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;哪个作用域拥有 channel？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非所有者有什么能力？&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;完全所有权&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只读&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只写&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;channel 将如何清理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个 goroutine 负责清理 channel？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;所有者模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Owner Pattern 是 Go 中的一种常见设计模式，用于确保通道的所有权由创建或拥有 goroutine 正确管理。这允许 goroutine 管理通道的整个生命周期并确保正确关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是 Go 中所有者模式的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewTime&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  tchan := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; time.Time)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(tchan &lt;span&gt;chan&lt;/span&gt;&amp;lt;- time.Time)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(tchan)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; tchan &amp;lt;- time.Now():&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }(tchan)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tchan&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;NewTime 控制通道实例化和清理（第 2 行和第 5 行）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过定义只读/只写边界避免乱用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制行为不一致的可能性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于此示例的重要说明。上下文 &lt;code&gt;ctx&lt;/code&gt; 传递给函数 &lt;code&gt;NewTime&lt;/code&gt;并用于指示 goroutine 停止。&lt;code&gt;tchan&lt;/code&gt; 通道是普通的无缓冲通道，但以只读方式返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当传递给内部 goroutine 时，&lt;code&gt;tchan&lt;/code&gt;通道作为只写通道传递。因为内部 goroutine 提供了一个只写通道，所以它有责任在完成时关闭通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;select&lt;/code&gt; 语句，&lt;code&gt;time.Now()&lt;/code&gt; 调用仅在从通道读取时执行。这确保&lt;code&gt;time.Now()&lt;/code&gt; 调用的执行与从通道读取同步。这种类型的模式有助于抢先减少 CPU 周期。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循环 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从通道读取的一种方法是使用&lt;code&gt;for&lt;/code&gt;循环。这在某些情况下可能很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; t := &lt;span&gt;range&lt;/span&gt; tchan {&lt;br/&gt;    fmt.Println(t)&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不推荐这种方法有几个原因。首先，不能保证通道会关闭（打破循环）。其次，循环不遵守上下文，这意味着如果取消上下文，循环将永远不会退出。&lt;strong&gt;第二点特别重要，因为没有优雅的方式来退出 goroutine。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我建议不要在通道上循环，而是使用以下模式，在该模式中使用带有&lt;code&gt;select&lt;/code&gt;语句的无限循环。这种模式确保检查上下文，如果它被取消，循环退出，同时还允许循环仍然从通道中读取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; tchan &amp;lt;-&lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done(): &lt;span&gt;// Graceful exit&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; t, ok := &amp;lt;-tchan: &lt;span&gt;// Read from the time ticker&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; !ok { &lt;span&gt;// Channel closed, exit&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;      fmt.Println(t)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文会详细讨论这个。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;转发 Channels&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在适当的情况下，将通道从一个转发到另一个也是一种有用的模式。这是使用&lt;code&gt;&amp;lt;- &amp;lt;-&lt;/code&gt;运算符完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是将一个通道转发到另一个通道的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;forward&lt;/span&gt;&lt;span&gt;(ctx context.Context, from &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  to := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; to &amp;lt;- &amp;lt;-from: &lt;span&gt;// Forward from into the to channel&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; to&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 使用此模式，你无法检测&lt;code&gt;from&lt;/code&gt;通道何时关闭。这意味着&lt;code&gt;from&lt;/code&gt;通道将不断地向 &lt;code&gt;to&lt;/code&gt; 通道发送数据，并且内部 goroutine 将永远不会退出，从而导致大量零值数据和 goroutine 泄漏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据你的使用场景，这可能是可取的，但是，重要的是要注意，当你需要检测关闭的通道时，这种模式不是一个好方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Select 语句&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select&lt;/code&gt; 语句允许在 Go 应用程序中管理多个通道，并可用于触发操作、管理数据或以其他方式创建逻辑并发流。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; data, ok := &amp;lt;- incoming: &lt;span&gt;// Data Read&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; outgoing &amp;lt;- data: &lt;span&gt;// Data Write&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;// Non-blocking default action&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;select&lt;/code&gt; 本质上是&lt;em&gt;随机&lt;/em&gt;的。这意味着如果有多个通道准备好同时读取或写入，该&lt;code&gt;select&lt;/code&gt;语句将随机选择一个 case 语句来执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 Select 语句&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select 语句的随机性会使测试 select 语句有点棘手，尤其是在测试以确保上下文取消正确退出例程时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个如何使用统计测试来测试 select 语句的示例，其中测试执行的次数确保测试失败的统计可能性很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此测试通过在并行例程中运行相同的已取消上下文 100 次来工作，其中两个上下文中只有一个已被取消。在这种情况下，总会有一个通道的消费者，因此每次循环运行时，都有 50% 的可能性会执行 context case。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过运行 100 次，有 50% 的机会选择触发上下文情况，测试将无法检测到所有 100 个测试的上下文取消的可能性非常非常低。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带上下文的 Work 取消&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在构建 Go 应用程序的早期，用户构建具有&lt;code&gt;done&lt;/code&gt;通道的应用程序，他们将在其中创建一个看起来像这样的通道：&lt;code&gt;done := make(chan struct{})&lt;/code&gt;，这是一种非常简单的方法，可以向 goroutine 发出它应该退出的信号，因为你所要做的就是关闭通道并将其用作退出信号。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Example of a simple done channel&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  done := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt;&lt;br/&gt;    &lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; doWork(done)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Exit anything using the done channel&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(done)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Do some more work&lt;/span&gt;&lt;br/&gt;  }()&lt;br/&gt;&lt;br/&gt;  &amp;lt;-done&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(done &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-done:&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;      &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式变得如此普遍，以至于 Go 团队创建了context 包 作为替代。该包提供了一个接口&lt;code&gt;context.Context&lt;/code&gt;，可用于向 goroutine 发出信号，告知它在&lt;code&gt;Done&lt;/code&gt; 方法返回的只读通道返回时退出 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doWork&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;: &lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，他们还提供了一些用于创建分层上下文、超时上下文和可以取消的上下文的方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;context.WithCancel&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;返回 &lt;code&gt;context.Context&lt;/code&gt;以及&lt;code&gt;context.CancelFunc&lt;/code&gt;，可用于取消上下文的函数字面值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithTimeout&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与&lt;code&gt;WithCancel&lt;/code&gt;返回一致，但具有超时，将在指定&lt;code&gt;time.Duration&lt;/code&gt;时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;context.WithDeadline&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;与 WithCancel 返回一致，但有一个截止日期，将在指定的时间过去后取消上下文。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：接受上下文的函数的第一个参数应该 &lt;strong&gt;始终&lt;/strong&gt; 是 context，并且应该命名为 &lt;code&gt;ctx&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://benjiv.com/go-native-concurrency-primitives/。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ce986df16b68a744efaf3963d722ff0</guid>
<title>[推荐] 百度和米哈游的Golang面试经验分享</title>
<link>https://toutiao.io/k/q0sox0k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;最近面了两家公司的&lt;code&gt;go&lt;/code&gt;技术岗位，一家百度，一家米哈游，面试的情况也不太乐观，现在分享一下面试中问的问题吧。&lt;/p&gt;&lt;p&gt;两家都是采用线上面试的，当时没有录音，&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZrO9jY7dRJ1zDsVdPMObBWYFItXnsBiavdibkQKJVkXvTBwsGtHlS1BUNU2xia3y3lnlXPNrRD4ZLgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;现在全靠自己的回忆来复盘一下了。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;百度一面&lt;/h2&gt;&lt;p&gt;百度的面试步骤分为计算机基础、&lt;code&gt;go&lt;/code&gt;相关、&lt;code&gt;mysql&lt;/code&gt;相关、&lt;code&gt;redis&lt;/code&gt;相关、&lt;code&gt;linux&lt;/code&gt;相关问题。还有一些发散性的问题。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;基础相关&lt;/h3&gt;&lt;p&gt;这一块的话，我回答的是稀碎，算法和数据结构我一个都没答上来，后面两个因为之前面试问到过，所以查过一些，回答的还算可以。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;go相关&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;GC&lt;/code&gt;，（面&lt;code&gt;GO&lt;/code&gt;必问题），&lt;code&gt;GC&lt;/code&gt;中&lt;code&gt;stw&lt;/code&gt;时机，各个阶段是如何解决的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;gpm&lt;/code&gt;，（面&lt;code&gt;GO&lt;/code&gt;必问题），这个必须要完全理解，抢占式调度是如何抢占的，怎么调度&lt;code&gt;goroutine&lt;/code&gt;的，&lt;code&gt;M&lt;/code&gt;和&lt;code&gt;P&lt;/code&gt;的数量问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何优雅的实现一个&lt;code&gt;goroutine&lt;/code&gt;池（这个回答的稀碎）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;谈谈内存逃逸&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;内存管理（这个也回答的稀碎）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span/&gt;mysql相关&lt;/h3&gt;&lt;h3&gt;&lt;span/&gt;redis&lt;/h3&gt;&lt;h3&gt;&lt;span/&gt;linux&lt;/h3&gt;&lt;h3&gt;&lt;span/&gt;总结&lt;/h3&gt;&lt;p&gt;我面试结束后，一般都会问面试官，根据这次面试，针对我的技术上面，有什么好的建议或者意见，这位面试官给我的回答是：计算机基础比较薄弱，但是业务能力很强。这也是我目前的现状，哈哈，所以最近一直在看哈工大老师的计算机理论和操作系统。希望能勤能补拙吧。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;米哈游一面&lt;/h2&gt;&lt;p&gt;米哈游面试总体分为四个部分，&lt;code&gt;go&lt;/code&gt;相关，&lt;code&gt;mysql&lt;/code&gt;相关，&lt;code&gt;redis&lt;/code&gt;相关，&lt;code&gt;linux&lt;/code&gt;相关。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;go相关&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;m &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    m&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; i&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; k&lt;span&gt;,&lt;/span&gt; v &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;k -&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; k&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;v -&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; v&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问会出现什么状况，为什么，怎么解决。就是不要闭包直接使用外部变量，通过传参就能解决了。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;内存泄露，什么情况下内存会泄露。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;channel的底层实现原理，（其实就是问buf是环形链表的数据结构）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;defer，这个一定要认真回答，defer在什么时机会修改返回值。多个defer的顺序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;make和new的区别&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;channel关闭了接着send数据会发生什么，关闭一个已经关闭的channel会发生什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;map是线程安全的吗，map的扩容规则。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数组和切片的区别。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GC&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GPM模型&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程、线程、协程区别。（这个很重要）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;还有其他的我忘记了。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZrO9jY7dRJ1zDsVdPMObBWYFItXnsBiavdibkQKJVkXvTBwsGtHlS1BUNU2xia3y3lnlXPNrRD4ZLgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;redis&lt;/h3&gt;&lt;p&gt;差不多就是百度那样。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;mysql&lt;/h3&gt;&lt;p&gt;也差不多和百度那样。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;linux&lt;/h3&gt;&lt;p&gt;大差不差，就问了一个怎么根据进程名查该进程的id.&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;总结&lt;/h3&gt;&lt;p&gt;根据面试反馈来看，米哈游给出的是go基础较差，但是业务能力较强。可能这就是之前干外包的特点吧。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZrO9jY7dRJ1zDsVdPMObBWYFItXnsBiavdibkQKJVkXvTBwsGtHlS1BUNU2xia3y3lnlXPNrRD4ZLgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;米哈游的二面&lt;/h3&gt;&lt;p&gt;米哈游二面主要问的是业务方面和算法方面的问题，主要有三部分。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;微服务相关，包括微服务的注册与发现，微服务的监控，微服务的限流相关等等，还有微服务怎么守护进程，我回答的是supervisor，也不知道对不对。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;具体业务的实现，兑换码的实现，如何批量生成几十万或者上百万的兑换码，（这个我回答的是用雪花算法实现），高并发下，一个兑换码如何保证只能被一个人兑换一次，以及一个兑换码如何可以被多个人兑换的实现。（这道题前前后后回答了有半个小时吧，因为之前做过相关的业务，所以心里有点底）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;三个算法问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;写一个方法，解决：输入4个数字，通过加减乘除，输出一个期望值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;广度优先算法：怎么输出各层的值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章原作者：ezreal_rao&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MTUwNDU1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZKcmczZwW2lOD3icB2iaicXKS3v7smeF8uwHtMI8YicppR3JyJQXl2L7HPnABTcgiaQcialTE11OlTpHnw/0?wx_fmt=png&quot; data-nickname=&quot;Go编程&quot; data-alias=&quot;&quot; data-signature=&quot;Golang语言编程，针对学习教程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>