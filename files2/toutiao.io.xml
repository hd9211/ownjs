<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>877b0dad1990c530fd20070a9f7689a9</guid>
<title>80 行 Python 代码搞定全国区划代码</title>
<link>https://toutiao.io/k/a8212hf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GitHub源码分享&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;微信搜索：码农StayUp&lt;/p&gt;&lt;p&gt;主页地址：https://gozhuyinglong.github.io&lt;/p&gt;&lt;p&gt;源码分享：https://github.com/gozhuyinglong/blog-demos&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网站建设中一般会用到全国行政区域划分，以便于做区域数据分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们用 Python 来爬取行政区域数据，数据来源为比较权威的国家统计局。爬取的页面为2020年统计用区划代码和城乡划分代码。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里有个疑问，为啥统计局只提供了网页版呢？提供文件版岂不是更方便大众。欢迎了解的小伙伴给我留言。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 网站分析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在爬取数据之前要做的便是网站分析，通过分析来判断使用何种方式来爬取。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 省份页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个静态页面，其二级页面使用的是相对地址，通过 class=provincetr 的&lt;code&gt;tr&lt;/code&gt;元素来定位&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41854838709677417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BVm2jk5Hyj7IibKLc8NURAqIwXVQxk9Bttmq0R5UgZ0z4Fp9icoltN5Eg4bxlqnLgABnnEkTjZBwfrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;省份页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 城市页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个静态页面，其二级页面使用的是相对地址，通过 class=citytr 的&lt;code&gt;tr&lt;/code&gt;元素来定位&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4411290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BVm2jk5Hyj7IibKLc8NURAqIxDeibgU9U2ZRF1CMJDd6pMZtVkBk1UfwKA6Y2NS497icCHc6fI8SJyUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;城市页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 区县页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个静态页面，其二级页面使用的是相对地址，通过 class=countytr 的&lt;code&gt;tr&lt;/code&gt;元素来定位&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4112903225806452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BVm2jk5Hyj7IibKLc8NURAqIWVve40W6u4wn9gdTpoUwTLUky5CicHNZlINKn394J2vfLoE6niaUD0Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;区县页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 城镇页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个静态页面，其二级页面使用的是相对地址，通过 class=towntr 的&lt;code&gt;tr&lt;/code&gt;元素来定位&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38064516129032255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BVm2jk5Hyj7IibKLc8NURAqI7ichjlFLtJhBRlmVmeZB3NJviaGHQdWhljLf9bHiclAVQj8PoiaE4F7RZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;城镇页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 村庄页面&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个静态页面，没有二级页面，通过 class=villagetr 的&lt;code&gt;tr&lt;/code&gt;元素来定位&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38306451612903225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BVm2jk5Hyj7IibKLc8NURAqI76icS2sz57LZticjC92uAFiaCkCruAewxTlHFcIXywlJLCMeFBFyHycOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;村庄页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 安装所需库&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的分析，使用爬取静态网页的方式即可。下面是一些必要的库，需要提前安装好：Requests、BeautifulSoup、lxml。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 Requests&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Requests 是一个 Python 的 HTTP 客户端库，用于访问 URL 网络资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装Requests库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pip install requests&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 BeautifulSoup&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Beautifu lSoup 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。它能够通过指定的转换器实现页面文档的导航、查找、修改等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装 BeautifulSoup 库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pip install beautifulsoup4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 lxml&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lxml 是一种使用 Python 编写的库，可以迅速、灵活地处理 XML 和 HTML。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它支持 XML Path Language (XPath) 和 Extensible Stylesheet Language Transformation (XSLT)，并且实现了常见的 ElementTree API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装lxml库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pip install lxml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 代码实现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;爬虫分以下几步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用Requests库来获取网页。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用BeautifulSoup和lxml库解析网页。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用Python的File来存储数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出文件为：当前py文件所在目录，文件名称：area-number-2020.txt&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果为：级别、区划代码、名称，中间使用制表符分隔，便于存到Exce和数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看详细代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# -*-coding:utf-8-*-&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; requests&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt; BeautifulSoup&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 根据地址获取页面内容，并返回BeautifulSoup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_html&lt;/span&gt;&lt;span&gt;(url)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 若页面打开失败，则无限重试，没有后退可言&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;# 超时时间为1秒&lt;/span&gt;&lt;br/&gt;            response = requests.get(url, timeout=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;            response.encoding = &lt;span&gt;&quot;GBK&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; response.status_code == &lt;span&gt;200&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; BeautifulSoup(response.text, &lt;span&gt;&quot;lxml&quot;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;except&lt;/span&gt; Exception:&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 获取地址前缀（用于相对地址）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_prefix&lt;/span&gt;&lt;span&gt;(url)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; url[&lt;span&gt;0&lt;/span&gt;:url.rindex(&lt;span&gt;&quot;/&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 递归抓取下一页面&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spider_next&lt;/span&gt;&lt;span&gt;(url, lev)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; lev == &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;        spider_class = &lt;span&gt;&quot;city&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;elif&lt;/span&gt; lev == &lt;span&gt;3&lt;/span&gt;:&lt;br/&gt;        spider_class = &lt;span&gt;&quot;county&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;elif&lt;/span&gt; lev == &lt;span&gt;4&lt;/span&gt;:&lt;br/&gt;        spider_class = &lt;span&gt;&quot;town&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        spider_class = &lt;span&gt;&quot;village&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; get_html(url).select(&lt;span&gt;&quot;tr.&quot;&lt;/span&gt; + spider_class + &lt;span&gt;&quot;tr&quot;&lt;/span&gt;):&lt;br/&gt;        item_td = item.select(&lt;span&gt;&quot;td&quot;&lt;/span&gt;)&lt;br/&gt;        item_td_code = item_td[&lt;span&gt;0&lt;/span&gt;].select_one(&lt;span&gt;&quot;a&quot;&lt;/span&gt;)&lt;br/&gt;        item_td_name = item_td[&lt;span&gt;1&lt;/span&gt;].select_one(&lt;span&gt;&quot;a&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; item_td_code &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;:&lt;br/&gt;            item_href = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;            item_code = item_td[&lt;span&gt;0&lt;/span&gt;].text&lt;br/&gt;            item_name = item_td[&lt;span&gt;1&lt;/span&gt;].text&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; lev == &lt;span&gt;5&lt;/span&gt;:&lt;br/&gt;                item_name = item_td[&lt;span&gt;2&lt;/span&gt;].text&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;            item_href = item_td_code.get(&lt;span&gt;&quot;href&quot;&lt;/span&gt;)&lt;br/&gt;            item_code = item_td_code.text&lt;br/&gt;            item_name = item_td_name.text&lt;br/&gt;        &lt;span&gt;# 输出：级别、区划代码、名称&lt;/span&gt;&lt;br/&gt;        content2 = str(lev) + &lt;span&gt;&quot;\t&quot;&lt;/span&gt; + item_code + &lt;span&gt;&quot;\t&quot;&lt;/span&gt; + item_name&lt;br/&gt;        print(content2)&lt;br/&gt;        f.write(content2 + &lt;span&gt;&quot;\n&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; item_href &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;:&lt;br/&gt;            spider_next(get_prefix(url) + item_href, lev + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 入口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 抓取省份页面&lt;/span&gt;&lt;br/&gt;    province_url = &lt;span&gt;&quot;http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2020/index.html&quot;&lt;/span&gt;&lt;br/&gt;    province_list = get_html(province_url).select(&lt;span&gt;&#x27;tr.provincetr a&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;# 数据写入到当前文件夹下 area-number-2020.txt 中&lt;/span&gt;&lt;br/&gt;    f = open(&lt;span&gt;&quot;area-number-2020.txt&quot;&lt;/span&gt;, &lt;span&gt;&quot;w&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; province &lt;span&gt;in&lt;/span&gt; province_list:&lt;br/&gt;            href = province.get(&lt;span&gt;&quot;href&quot;&lt;/span&gt;)&lt;br/&gt;            province_code = href[&lt;span&gt;0&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;] + &lt;span&gt;&quot;0000000000&quot;&lt;/span&gt;&lt;br/&gt;            province_name = province.text&lt;br/&gt;            &lt;span&gt;# 输出：级别、区划代码、名称&lt;/span&gt;&lt;br/&gt;            content = &lt;span&gt;&quot;1\t&quot;&lt;/span&gt; + province_code + &lt;span&gt;&quot;\t&quot;&lt;/span&gt; + province_name&lt;br/&gt;            print(content)&lt;br/&gt;            f.write(content + &lt;span&gt;&quot;\n&quot;&lt;/span&gt;)&lt;br/&gt;            spider_next(get_prefix(province_url) + href, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;finally&lt;/span&gt;:&lt;br/&gt;        f.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 资源下载&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你只是需要行政区域数据，那么已经为你准备好了，从下面连接中下载即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链接：https://pan.baidu.com/s/18MDdkczwJVuRZwsH0pFYwQ&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提取码：t2eg&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 爬虫遵循的规则&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引自：https://www.cnblogs.com/kongyijilafumi/p/13969361.html&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;遵守 Robots 协议，谨慎爬取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制你的爬虫行为，禁止近乎 DDOS 的请求频率，一旦造成服务器瘫痪，约等于网络攻击&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于明显反爬，或者正常情况不能到达的页面不能强行突破，否则是 Hacker 行为&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果爬取到别人的隐私，立即删除，降低进局子的概率。另外要控制自己的欲望&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4488888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BVm2jk5Hyj7IibKLc8NURAqIdPiaL8god0Y85ULLx2WGRMn1iabW0iczAjnQvrDIyzoh42m6KHwBcRapg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9fffb682fee7a6dd3ca9bab5191750fb</guid>
<title>你分库分表的姿势对么？：详谈水平分库分表</title>
<link>https://toutiao.io/k/oyacwl5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;22&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo平台产品开发团队-Han Lei&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;提起分库分表，对于大部分服务器开发来说，其实并不是一个新鲜的名词。随着业务的发展，我们表中的数据量会变的越来越大，字段也可能随着业务复杂度的升高而逐渐增多，我们为了解决单表的查询性能问题，一般会进行分表操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时我们业务的用户活跃度也会越来越高，并发量级不断加大，那么可能会达到单个数据库的处理能力上限。此时我们为了解决数据库的处理性能瓶颈，一般会进行分库操作。不管是分库操作还是分表操作，我们一般都有两种方式应对，一种是垂直拆分，一种是水平拆分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于两种拆分方式的区别和特点，互联网上参考资料众多，很多人都写过相关内容，这里就不再进行详细赘述，有兴趣的读者可以自行检索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此文主要详细聊一聊，我们最实用最常见的水平分库分表方式中的一些特殊细节，希望能帮助大家避免走弯路，找到最合适自身业务的分库分表设计。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;87&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;【注1】本文中的案例均基于Mysql数据库，下文中的分库分表统指水平分库分表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;【注2】后文中提到到M库N表，均指共M个数据库，每个数据库共N个分表，即总表个数其实为M*N。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、什么是一个好的分库分表方案？&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 方案可持续性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前期业务数据量级不大，流量较低的时候，我们无需分库分表，也不建议分库分表。但是一旦我们要对业务进行分库分表设计时，就一定要考虑到分库分表方案的可持续性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那何为可持续性？&lt;/strong&gt;其实就是：业务数据量级和业务流量未来进一步升高达到新的量级的时候，我们的分库分表方案可以持续使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个通俗的案例，假定当前我们分库分表的方案为10库100表，那么未来某个时间点，若10个库仍然无法应对用户的流量压力，或者10个库的磁盘使用即将达到物理上限时，我们的方案能够进行平滑扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在后文中我们将介绍下目前业界常用的翻倍扩容法和一致性Hash扩容法。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 数据偏斜问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个良好的分库分表方案，它的数据应该是需要比较均匀的分散在各个库表中的。如果我们进行一个拍脑袋式的分库分表设计，很容易会遇到以下类似问题：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;135&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;a、某个数据库实例中，部分表的数据很多，而其他表中的数据却寥寥无几，业务上的表现经常是延迟忽高忽低，飘忽不定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、数据库集群中，部分集群的磁盘使用增长特别块，而部分集群的磁盘增长却很缓慢。每个库的增长步调不一致，这种情况会给后续的扩容带来步调不一致，无法统一操作的问题。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这边我们定义分库分表最大数据偏斜率为 ：（数据量最大样本 - 数据量最小样本）/ 数据量最小样本。一般来说，如果我们的最大数据偏斜率在5%以内是可以接受的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008465&quot; data-ratio=&quot;0.5117773019271948&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZgAnfMNvQibZvq4LtEbZeoBN27oY1KicgZHAXDu0Fs8ax3HeUjQYh2pKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;467&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、常见的分库分表方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 Range分库分表&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;顾名思义，该方案根据数据范围划分数据的存放位置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个最简单例子，我们可以把订单表按照年份为单位，每年的数据存放在单独的库（或者表）中。如下图所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;rangeShardByYear&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String orderId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; year = Integer.parseInt(orderId.substring(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;t_order_&quot;&lt;/span&gt; + year;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过数据的范围进行分库分表，该方案是最朴实的一种分库方案，它也可以和其他分库分表方案灵活结合使用。时下非常流行的分布式数据库：TiDB数据库，针对TiKV中数据的打散，也是基于Range的方式进行，将不同范围内的[StartKey,EndKey)分配到不同的Region上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面我们看看该方案的缺点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;39&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;这点非常容易被遗忘，尤其是稳定跑了几年没有迭代任务，或者人员又交替频繁的模块。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里就需要注意了，因为是通过年份进行分库分表，那么元旦的那一天，你的定时任务很有可能会漏掉上一年的最后一天的数据扫描。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 Hash分库分表&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;虽然分库分表的方案众多，但是Hash分库分表是最大众最普遍的方案，也是本文花最大篇幅描述的部分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对Hash分库分表的细节部分，相关的资料并不多。大部分都是阐述一下概念举几个示例，而细节部分并没有特别多的深入，如果未结合自身业务贸然参考引用，后期非常容易出现各种问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在正式介绍这种分库分表方式之前，我们先看几个常见的错误案例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常见错误案例一：非互质关系导致的数据偏斜问题&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 对库数量取余结果为库序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % DB_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 对表数量取余结果为表序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上述方案是初次使用者特别容易进入的误区，用&lt;span&gt;Hash&lt;/span&gt;值分别对分库数和分表数取余，得到库序号和表序号。其实稍微思索一下，我们就会发现，以10库100表为例，如果一个&lt;span&gt;Hash&lt;/span&gt;值对100取余为0，那么它对10取余也必然为0。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这就意味着只有0库里面的0表才可能有数据，而其他库中的0表永远为空！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;类似的我们还能推导到，0库里面的共100张表，只有10张表中(个位数为0的表序号)才可能有数据。这就带来了非常严重的数据偏斜问题，因为某些表中永远不可能有数据，最大数据偏斜率达到了无穷大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么很明显，该方案是一个未达到预期效果的错误方案。数据的散落情况大致示意图如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;303&quot; data-backw=&quot;578&quot; data-fileid=&quot;100008466&quot; data-ratio=&quot;0.5237449118046132&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZpIKzw3xB1jE6WvhrjwNfpRA2W6cPuvco1Lqm6bxgsmWChU7IegDqaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;事实上，只要库数量和表数量非互质关系，都会出现某些表中无数据的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;证明如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008467&quot; data-ratio=&quot;0.4548440065681445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZJz6wCq1zwxLI062iahVEGn80PS0RcDfAdQ5hQWrB5kXPpwBcYyCrrKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;那么是不是只要库数量和表数量互质就可用用这种分库分表方案呢？比如我用11库100表的方案，是不是就合理了呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;答案是否定的，我们除了要考虑数据偏斜的问题，还需要考虑可持续性扩容的问题，一般这种&lt;span&gt;Hash&lt;/span&gt;分库分表的方案后期的扩容方式都是通过翻倍扩容法，那11库翻倍后，和100又不再互质。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，如果分库数和分表数不仅互质，而且分表数为奇数(例如10库101表)，则理论上可以使用该方案，但是我想大部分人可能都会觉得使用奇数的分表数比较奇怪吧。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常见错误案例二：扩容难以持续&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果避开了上述案例一的陷阱，那么我们又很容易一头扎进另一个陷阱，大概思路如下；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们把10库100表看成总共1000个逻辑表，将求得的Hash值对1000取余，得到一个介于[0，999)中的数，然后再将这个数二次均分到每个库和每个表中，大概逻辑代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ① 算Hash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ② 总分片数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; sumSlot = DB_CNT * TBL_CNT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ③ 分片序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; slot = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % sumSlot);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ④ 计算库序号和表序号的错误案例&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = slot % DB_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = slot / DB_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案确实很巧妙的解决了数据偏斜的问题，只要&lt;span&gt;Hash&lt;/span&gt;值足够均匀，那么理论上分配序号也会足够平均，于是每个库和表中的数据量也能保持较均衡的状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008468&quot; data-ratio=&quot;0.7772357723577236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZiaBvZ7pLrTdsmfFPRC4FlJvHbqGNRXYHQ6JyA7WJhC4lJC08466l5ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;615&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是该方案有个比较大的问题，那就是在计算表序号的时候，依赖了总库的数量，那么后续翻倍扩容法进行扩容时，会出现扩容前后数据不在同一个表中，从而无法实施。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图中，例如扩容前&lt;span&gt;Hash&lt;/span&gt;为1986的数据应该存放在6库98表，但是翻倍扩容成20库100表后，它分配到了6库99表，表序号发生了偏移。这样的话，我们在后续在扩容的时候，不仅要基于库迁移数据，还要基于表迁移数据，非常麻烦且易错。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看完了上面的几种典型的错误案例，那么我们有哪些比较正确的方案呢？下面将结合一些实际场景案例介绍几种Hash分库分表的方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常用姿势一：标准的二次分片法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述错误案例二中，整体思路完全正确，只是最后计算库序号和表序号的时候，使用了库数量作为影响表序号的因子，导致扩容时表序号偏移而无法进行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上，我们只需要换种写法，就能得出一个比较大众化的分库分表方案。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard2&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ① 算Hash&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ② 总分片数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; sumSlot = DB_CNT * TBL_CNT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ③ 分片序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; slot = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % sumSlot);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// ④ 重新修改二次求值方案&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = slot / TBL_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = slot % TBL_CNT ;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大家可以注意到，和错误案例二中的区别就是通过分配序号重新计算库序号和表序号的逻辑发生了变化。它的分配情况如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;426&quot; data-backw=&quot;568&quot; data-fileid=&quot;100008469&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZSdnFhxmkHZicZX7P3W6iceeraNwiaNibp2cexGiacNAmHNy1aMMEOVib60fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那为何使用这种方案就能够有很好的扩展持久性呢？我们进行一个简短的证明：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008470&quot; data-ratio=&quot;0.5790251107828656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZG1Wg0sVFvdcAhJfwjfTgLpw0gtwLYbiaBiarNibLsAPLThFMHLIMj3r9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过上面结论我们知道，通过翻倍扩容后，我们的表序号一定维持不变，库序号可能还是在原来库，也可能平移到了新库中(原库序号加上原分库数)，完全符合我们需要的扩容持久性方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008471&quot; data-ratio=&quot;0.8562992125984252&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZII2eI7xAY7V3wxpXEO6LoU41HA0pQo1WpicEbq0UibFpqshjdp83B1RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【方案缺点】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1、翻倍扩容法前期操作性高，但是后续如果分库数已经是大几十的时候，每次扩容都非常耗费资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2、连续的分片键&lt;span&gt;Hash&lt;/span&gt;值大概率会散落在相同的库中，某些业务可能容易存在库热点（例如新生成的用户&lt;span&gt;Hash&lt;/span&gt;相邻且递增，且新增用户又是高概率的活跃用户，那么一段时间内生成的新用户都会集中在相邻的几个库中）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势二：关系表冗余&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们可以将分片键对应库的关系通过关系表记录下来，我们把这张关系表称为&quot;路由关系表&quot;。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String userId&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.abs(userId.hashCode() % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从缓存获取&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Integer dbIdx = loadFromCache(userId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; == dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从路由表获取&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dbIdx = loadFromRouteTable(userId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; != dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;// 保存到缓存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                saveRouteCache(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; == dbIdx) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__comment&quot;&gt;// 此处可以自由实现计算库的逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dbIdx = selectRandomDbIdx();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            saveToRouteTable(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            saveRouteCache(userId, dbIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;该方案还是通过常规的&lt;span&gt;Hash&lt;/span&gt;算法计算表序号，而计算库序号时，则从路由表读取数据。因为在每次数据查询时，都需要读取路由表，故我们需要将分片键和库序号的对应关系记录同时维护在缓存中以提升性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上述实例中&lt;strong&gt;selectRandomDbIdx方法&lt;/strong&gt;作用为生成该分片键对应的存储库序号，这边可以非常灵活的动态配置。例如可以为每个库指定一个权重，权重大的被选中的概率更高，权重配置成0则可以将关闭某些库的分配。当发现数据存在偏斜时，也可以调整权重使得各个库的使用量调整趋向接近。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案还有个优点，就是理论上后续进行扩容的时候，仅需要挂载上新的数据库节点，将权重配置成较大值即可，无需进行任何的数据迁移即可完成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图所示：最开始我们为4个数据库分配了相同的权重，理论上落在每个库的数据概率均等。但是由于用户也有高频低频之分，可能某些库的数据增长会比较快。当挂载新的数据库节点后，我们灵活的调整了每个库的新权重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008472&quot; data-ratio=&quot;0.44283121597096187&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZ9icic99AgSdJ8CpmiboWqb2Js9gMZw5qqfKn6icBRakKVlr3T0FbChF5Tw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;551&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;该方案似乎解决了很多问题，那么它有没有什么不适合的场景呢？当然有，该方案在很多场景下其实并不太适合，以下举例说明。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a、每次读取数据需要访问路由表，虽然使用了缓存，但是还是有一定的性能损耗。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、路由关系表的存储方面，有些场景并不合适。例如上述案例中用户id的规模大概是在10亿以内，我们用单库百表存储该关系表即可。但如果例如要用文件MD5摘要值作为分片键，因为样本集过大，无法为每个md5值都去指定关系（当然我们也可以使用md5前N位来存储关系）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c、&lt;strong&gt;饥饿占位问题，如下详叙&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们知道，该方案的特点是后续无需扩容，可以随时修改权重调整每个库的存储增长速度。但是这个愿景是比较缥缈，并且很难实施的，我们选取一个简单的业务场景考虑以下几个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;【&lt;strong&gt;业务场景&lt;/strong&gt;】：以用户存放文件到云端的云盘业务为例，需要对用户的文件信息进行分库分表设计，有以下假定场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们使用路由表记录每个用户所在的库序号信息。那么该方案会有以下问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一：&lt;/strong&gt;我们总共有2亿个用户，只有3000W个产生过事务的用户。若程序不加处理，用户发起任何请求则创建路由表数据，会导致为大量实际没有事务数据的用户提前创建路由表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者最初存储云盘用户数据的时候便遇到了这个问题，客户端app会在首页查询用户空间使用情况，这样导致几乎一开始就为每个使用者分配好了路由。随着时间的推移，这部分没有数据的&quot;静默&quot;的用户，随时可能开始他的云盘使用之旅而“复苏”，从而导致它所在的库迅速增长并超过单个库的空间容量极限，从而被迫拆分扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决这个问题的方案，其实就是只针对事务操作(例如购买空间，上传数据，创建文件夹等等)才进行路由的分配，这样对代码层面便有了一些倾入。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二、&lt;/strong&gt;按照前面描述的业务场景，一个用户最终平均有2000条数据，假定每行大小为1K，为了保证B+数的层级在3层，我们限制每张表的数据量在2000W，分表数为100的话，可以得到理论上每个库的用户数不能超过100W个用户。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也就是如果是3000W个产生过事务的用户，我们需要为其分配30个库，这样会在业务前期，用户平均数据量相对较少的时候，存在非常大的数据库资源的浪费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决第二个问题，我们一般可以将很多数据库放在一个实例上，后续随着增长情况进行拆分。也可以后续针对将满的库，使用常规手段进行拆分和迁移。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势三：基因法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;还是由错误案例一启发，我们发现案例一不合理的主要原因，就是因为库序号和表序号的计算逻辑中，有公约数这个因子在影响库表的独立性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么我们是否可以换一种思路呢？我们使用相对独立的&lt;span&gt;Hash&lt;/span&gt;值来计算库序号和表序号。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.substring(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;).hashCode() % DB_CNT );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.hashCode() % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上所示，我们计算库序号的时候做了部分改动，我们使用分片键的前四位作为&lt;span&gt;Hash&lt;/span&gt;值来计算库序号。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这也是一种常用的方案，我们称为基因法，即使用原分片键中的某些基因（例如前四位）作为库的计算因子，而使用另外一些基因作为表的计算因子。该方案也是网上不少的实践方案或者是其变种，看起来非常巧妙的解决了问题，然而在实际生成过程中还是需要慎重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者曾在云盘的空间模块的分库分表实践中采用了该方案，使用16库100表拆分数据，上线初期数据正常。然而当数据量级增长起来后，发现每个库的用户数量严重不均等，故猜测该方案存在一定的数据偏斜。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了验证观点，进行如下测试，随机2亿个用户id（16位的随机字符串），针对不同的M库N表方案，重复若干次后求平均值得到结论如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;8库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=248305(dbIdx=2, tblIdx=64), max=251419(dbIdx=7, tblIdx=8), rate= 1.25%            √&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;16库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=95560(dbIdx=8, tblIdx=42), max=154476(dbIdx=0, tblIdx=87), rate= 61.65%           ×&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;20库100表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;min=98351(dbIdx=14, tblIdx=78), max=101228(dbIdx=6, tblIdx=71), rate= 2.93%&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们发现该方案中，分库数为16，分表数为100，数量最小行数仅为10W不到，但是最多的已经达到了15W+，最大数据偏斜率高达61%。按这个趋势发展下去，后期很可能出现一台数据库容量已经使用满，而另一台还剩下30%+的容量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案并不是一定不行，而是我们在采用的时候，要综合分片键的样本规则，选取的分片键前缀位数，库数量，表数量，四个变量对最终的偏斜率都有影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如上述例子中，如果不是16库100表，而是8库100表，或者20库100表，数据偏斜率都能降低到了5%以下的可接受范围。所以该方案的隐藏的&quot;坑&quot;较多，我们不仅要估算上线初期的偏斜率，还需要测算若干次翻倍扩容后的数据偏斜率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如你用着初期比较完美的8库100表的方案，后期扩容成16库100表的时候，麻烦就接踵而至。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势四：剔除公因数法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;还是基于错误案例一启发，在很多场景下我们还是希望相邻的&lt;span&gt;Hash&lt;/span&gt;能分到不同的库中。就像N库单表的时候，我们计算库序号一般直接用&lt;span&gt;Hash&lt;/span&gt;值对库数量取余。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么我们是不是可以有办法去除掉公因数的影响呢？下面为一个可以考虑的实现案例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(userId.hashCode() % DB_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 计算表序号时先剔除掉公约数的影响&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;((userId.hashCode() / TBL_CNT) % TBL_CNT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过测算，该方案的最大数据偏斜度也比较小，针对不少业务从N库1表升级到N库M表下，需要维护库序号不变的场景下可以考虑。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;常用姿势五：一致性Hash法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一致性Hash算法也是一种比较流行的集群数据分区算法，比如RedisCluster即是通过一致性Hash算法，使用16384个虚拟槽节点进行每个分片数据的管理。关于一致性Hash的具体原理这边不再重复描述，读者可以自行翻阅资料。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这边详细介绍如何使用一致性Hash进行分库分表的设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们通常会将每个实际节点的配置持久化在一个配置项或者是数据库中，应用启动时或者是进行切换操作的时候会去加载配置。配置一般包括一个[StartKey,Endkey)的左闭右开区间和一个数据库节点信息，例如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;503&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;195&quot; data-fileid=&quot;100008473&quot; data-ratio=&quot;0.38911290322580644&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7AWBMjESn4VYZibMW4Z0ScG0EwOmwf17qWyia5Y2OsNDia6qk0D8HZbY9vDVCsQwKD2Zvh88luLJJeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; TreeMap&amp;lt;Long, Integer&amp;gt; nodeTreeMap = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;afterPropertiesSet&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 启动时加载分区配置&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;HashCfg&amp;gt; cfgList = fetchCfgFromDb();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (HashCfg cfg : cfgList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        nodeTreeMap.put(cfg.endKey, cfg.nodeIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; ShardCfg &lt;span class=&quot;code-snippet__title&quot;&gt;shard&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String userId)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; hash = userId.hashCode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; dbIdx = nodeTreeMap.tailMap((&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt;) hash, &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;).firstEntry().getValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; tblIdx = Math.&lt;span class=&quot;code-snippet__built_in&quot;&gt;abs&lt;/span&gt;(hash % &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ShardCfg(dbIdx, tblIdx);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们可以看到，这种形式和上文描述的Range分表非常相似，Range分库分表方式针对分片键本身划分范围，而一致性Hash是针对分片键的&lt;span&gt;Hash&lt;/span&gt;值进行范围配置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;正规的一致性Hash算法会引入虚拟节点，每个虚拟节点会指向一个真实的物理节点。这样设计方案主要是能够在加入新节点后的时候，可以有方案保证每个节点迁移的数据量级和迁移后每个节点的压力保持几乎均等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是用在分库分表上，一般大部分都只用实际节点，引入虚拟节点的案例不多，主要有以下原因：&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;188&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;a、应用程序需要花费额外的耗时和内存来加载虚拟节点的配置信息。如果虚拟节点较多，内存的占用也会有些不太乐观。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b、由于mysql有非常完善的主从复制方案，与其通过从各个虚拟节点中筛选需要迁移的范围数据进行迁移，不如通过从库升级方式处理后再删除冗余数据简单可控。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c、虚拟节点主要解决的痛点是节点数据搬迁过程中各个节点的负载不均衡问题，通过虚拟节点打散到各个节点中均摊压力进行处理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而作为OLTP数据库，我们很少需要突然将某个数据库下线，新增节点后一般也不会从0开始从其他节点搬迁数据，而是前置准备好大部分数据的方式，故一般来说没有必要引入虚拟节点来增加复杂度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、常见扩容方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 翻倍扩容法&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;翻倍扩容法的主要思维是每次扩容，库的数量均翻倍处理，而翻倍的数据源通常是由原数据源通过主从复制方式得到的从库升级成主库提供服务的方式。故有些文档将其称作&quot;&lt;strong&gt;从库升级法&lt;/strong&gt;&quot;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;理论上，经过翻倍扩容法后，我们会多一倍的数据库用来存储数据和应对流量，原先数据库的磁盘使用量也将得到一半空间的释放。如下图所示:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008475&quot; data-ratio=&quot;0.5273775216138329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZwJlqfTzSZEDuiaibgRibNrqFj5CcibPicbBHlkvg3KO9tW4YDH1PnibrCPRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;具体的流程大致如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;①、时间点t1：为每个节点都新增从库，开启主从同步进行数据同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;②、时间点t2：主从同步完成后，对主库进行禁写。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;153&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;此处禁写主要是为了保证数据的正确性。若不进行禁写操作，在以下两个时间窗口期内将出现数据不一致的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a、断开主从后，若主库不禁写，主库若还有数据写入，这部分数据将无法同步到从库中。&lt;/p&gt;&lt;p&gt; b、应用集群识别到分库数翻倍的时间点无法严格一致，在某个时间点可能两台应用使用不同的分库数，运算到不同的库序号，导致错误写入。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③、时间点t3：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;④、时间点t4：从库升级为集群节点，业务应用识别到新的分库数后，将应用新的路由算法。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;161&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;一般情况下，我们将分库数的配置放到配置中心中，当上述三个步骤完成后，我们修改分库数进行翻倍，应用生效后，应用服务将使用新的配置。这里需要注意的是，业务应用接收到新的配置的时间点不一定一致，所以必定存在一个时间窗口期，该期间部分机器使用原分库数，部分节点使用新分库数。这也正是我们的禁写操作一定要在此步完成后才能放开的原因。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑤、时间点t5：确定所有的应用均接受到库总数的配置后，放开原主库的禁写操作，此时应用完全恢复服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑥、启动离线的定时任务，清除各库中的约一半冗余数据。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;65&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;为了节省磁盘的使用率，我们可以选择离线定时任务清除冗余的数据。也可以在业务初期表结构设计的时候，将索引键的Hash值存为一个字段。&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;257&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么以上述常用姿势四为例，我们离线的清除任务可以简单的通过sql即可实现（需要防止锁住全表，可以拆分成若干个id范围的子sql执行）：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;delete from db0.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 0; &lt;/p&gt;&lt;p&gt;delete from db1.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 1;&lt;/p&gt;&lt;p&gt;delete from db2.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 2;&lt;/p&gt;&lt;p&gt;delete from db3.tbl0 where hash_val mod 4 &amp;lt;&amp;gt; 3;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;具体的扩容步骤可参考下图：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008476&quot; data-ratio=&quot;1.0336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZfaZ1SZUkySuiccD7xiayc6kOPvIcWnVB3MnuvTQocGOCTmhvfbpl2hTw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：通过上述迁移方案可以看出，从时间点t2到t5时间窗口呢内，需要对数据库禁写，相当于是该时间范围内服务器是部分有损的，该阶段整体耗时差不多是在分钟级范围内。若业务可以接受，可以在业务低峰期进行该操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然也会有不少应用无法容忍分钟级写入不可用，例如写操作远远大于读操作的应用，此时可以结合canel开源框架进行窗口期内数据双写操作以保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该方案主要借助于mysql强大完善的主从同步机制，能在事前提前准备好新的节点中大部分需要的数据，节省大量的人为数据迁移操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是缺点也很明显，一是过程中整个服务可能需要以有损为代价，二是每次扩容均需要对库数量进行翻倍，会提前浪费不少的数据库资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 一致性Hash扩容&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们主要还是看下不带虚拟槽的一致性Hash扩容方法，假如当前数据库节点DB0负载或磁盘使用过大需要扩容，我们通过扩容可以达到例如下图的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图中，扩容前配置了三个&lt;span&gt;Hash&lt;/span&gt;分段，发现[-Inf，-10000）范围内的的数据量过大或者压力过高时，需要对其进行扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100008477&quot; data-ratio=&quot;0.548460661345496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7ibSqqgkw7u8SC7X6Jv4YzZVUcTNVh9jBUiaplWhveGiapBAxdNFVpicm6vyX77ylMziaqtryJv0Pia1vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;主要步骤如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;①、&lt;strong&gt;时间点t1&lt;/strong&gt;：针对需要扩容的数据库节点增加从节点，开启主从同步进行数据同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;②、&lt;strong&gt;时间点t2&lt;/strong&gt;：完成主从同步后，对原主库进行禁写。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;35&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt; 此处原因和翻倍扩容法类似，需要保证新的从库和原来主库中数据的一致性。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;③、&lt;strong&gt;时间点t3&lt;/strong&gt;：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;④、&lt;strong&gt;时间点t4&lt;/strong&gt;：修改一致性Hash范围的配置，并使应用服务重新读取并生效。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑤、&lt;strong&gt;时间点t5&lt;/strong&gt;：确定所有的应用均接受到新的一致性Hash范围配置后，放开原主库的禁写操作，此时应用完全恢复服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;⑥、&lt;strong&gt;启动离线的定时任务&lt;/strong&gt;，清除冗余数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到，该方案和翻倍扩容法的方案比较类似，但是它更加灵活，可以根据当前集群每个节点的压力情况选择性扩容，而无需整个集群同时翻倍进行扩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、小结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文主要描述了我们进行水平分库分表设计时的一些常见方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在进行分库分表设计时，可以选择例如范围分表，&lt;span&gt;Hash&lt;/span&gt;分表，路由表，或者一致性Hash分表等各种方案。进行选择时需要充分考虑到后续的扩容可持续性，最大数据偏斜率等因素。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文中也列举了一些常见的错误示例，例如库表计算逻辑中公约数的影响，使用前若干位计算库序号常见的数据倾斜因素等等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在实际进行选择时，一定要考虑自身的业务特点，充分验证分片键在各个参数因子下的数据偏斜程度，并提前规划考虑好后续扩容的方案。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:94.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eca28cd18229bd9354d0f9908e4b3499</guid>
<title>测试小姐姐问我 gRPC 怎么用，我直接把这篇文章甩给了她</title>
<link>https://toutiao.io/k/w2l7bil</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;上篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3MjY1ODI2Ng==&amp;amp;mid=2247484210&amp;amp;idx=1&amp;amp;sn=7d26f0d5ecf68704b75fcad76f42a68f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;gRPC，爆赞&lt;/a&gt; 直接爆了，内容主要包括：简单的 gRPC 服务，流处理模式，验证器，Token 认证和证书认证。&lt;/p&gt;&lt;p&gt;在多个平台的阅读量都创了新高，在 oschina 更是获得了首页推荐，阅读量到了 1w+，这已经是我单篇阅读的高峰了。&lt;/p&gt;&lt;p&gt;看来只要用心写还是有收获的。&lt;/p&gt;&lt;p&gt;这篇咱们还是从实战出发，主要介绍 gRPC 的发布订阅模式，REST 接口和超时控制。&lt;/p&gt;&lt;p&gt;相关代码我会都上传到 GitHub，感兴趣的小伙伴可以去查看或下载。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;发布和订阅模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;发布订阅是一个常见的设计模式，开源社区中已经存在很多该模式的实现。其中 docker 项目中提供了一个 pubsub 的极简实现，下面是基于 pubsub 包实现的本地发布订阅代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;github.com/moby/moby/pkg/pubsub&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    p := pubsub.NewPublisher(&lt;span&gt;100&lt;/span&gt;*time.Millisecond, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    golang := p.SubscribeTopic(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; key, ok := v.(&lt;span&gt;string&lt;/span&gt;); ok {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; strings.HasPrefix(key, &lt;span&gt;&quot;golang:&quot;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;    docker := p.SubscribeTopic(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; key, ok := v.(&lt;span&gt;string&lt;/span&gt;); ok {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; strings.HasPrefix(key, &lt;span&gt;&quot;docker:&quot;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; p.Publish(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; p.Publish(&lt;span&gt;&quot;golang: https://golang.org&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; p.Publish(&lt;span&gt;&quot;docker: https://www.docker.com/&quot;&lt;/span&gt;)&lt;br/&gt;    time.Sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;golang topic:&quot;&lt;/span&gt;, &amp;lt;-golang)&lt;br/&gt;    }()&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;docker topic:&quot;&lt;/span&gt;, &amp;lt;-docker)&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &amp;lt;-&lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码首先通过 &lt;code&gt;pubsub.NewPublisher&lt;/code&gt; 创建了一个对象，然后通过 &lt;code&gt;p.SubscribeTopic&lt;/code&gt; 实现订阅，&lt;code&gt;p.Publish&lt;/code&gt; 来发布消息。&lt;/p&gt;&lt;p&gt;执行效果如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;docker topic: docker: https:&lt;span&gt;//www.docker.com/&lt;/span&gt;&lt;br/&gt;golang topic: golang: https:&lt;span&gt;//golang.org&lt;/span&gt;&lt;br/&gt;fatal error: all goroutines are asleep - deadlock!&lt;br/&gt;&lt;br/&gt;goroutine &lt;span&gt;1&lt;/span&gt; [&lt;span&gt;chan&lt;/span&gt; receive]:&lt;br/&gt;main.main()&lt;br/&gt;    /Users/zhangyongxin/src/&lt;span&gt;go&lt;/span&gt;-example/grpc-example/pubsub/server/pubsub.&lt;span&gt;go&lt;/span&gt;:&lt;span&gt;43&lt;/span&gt; +&lt;span&gt;0x1e7&lt;/span&gt;&lt;br/&gt;exit status &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;订阅消息可以正常打印。&lt;/p&gt;&lt;p&gt;但有一个死锁报错，是因为这条语句 &lt;code&gt;&amp;lt;-make(chan bool)&lt;/code&gt; 引起的。但是如果没有这条语句就不能正常打印订阅消息。&lt;/p&gt;&lt;p&gt;这里就不是很懂了，有没有大佬知道，欢迎留言，求指导。&lt;/p&gt;&lt;p&gt;接下来就用 gRPC 和 pubsub 包实现发布订阅模式。&lt;/p&gt;&lt;p&gt;需要实现四个部分：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt; 文件；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;服务端：&lt;/strong&gt; 用于接收订阅请求，同时也接收发布请求，并将发布请求转发给订阅者；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;订阅客户端：&lt;/strong&gt; 用于从服务端订阅消息，处理消息；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;发布客户端：&lt;/strong&gt; 用于向服务端发送消息。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;proto 文件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;首先定义 proto 文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;syntax&lt;/span&gt; = &lt;span&gt;&quot;proto3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; proto;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;message&lt;/span&gt; String {&lt;br/&gt;    &lt;span&gt;string&lt;/span&gt; value = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;service&lt;/span&gt; PubsubService {&lt;br/&gt;    &lt;span&gt;rpc&lt;/span&gt; Publish (String) returns (String);&lt;br/&gt;    &lt;span&gt;rpc&lt;/span&gt; SubscribeTopic (String) returns (stream String);&lt;br/&gt;    &lt;span&gt;rpc&lt;/span&gt; Subscribe (String) returns (stream String);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义三个方法，分别是一个发布 &lt;code&gt;Publish&lt;/code&gt; 和两个订阅 &lt;code&gt;Subscribe&lt;/code&gt; 和 &lt;code&gt;SubscribeTopic&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Subscribe&lt;/code&gt; 方法接收全部消息，而 &lt;code&gt;SubscribeTopic&lt;/code&gt; 根据特定的 &lt;code&gt;Topic&lt;/code&gt; 接收消息。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;server/proto&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;github.com/moby/moby/pkg/pubsub&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc/reflection&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PubsubService &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    pub *pubsub.Publisher&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *PubsubService)&lt;/span&gt; &lt;span&gt;Publish&lt;/span&gt;&lt;span&gt;(ctx context.Context, arg *proto.String)&lt;/span&gt; &lt;span&gt;(*proto.String, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    p.pub.Publish(arg.GetValue())&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;proto.String{}, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *PubsubService)&lt;/span&gt; &lt;span&gt;SubscribeTopic&lt;/span&gt;&lt;span&gt;(arg *proto.String, stream proto.PubsubService_SubscribeTopicServer)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ch := p.pub.SubscribeTopic(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; key, ok := v.(&lt;span&gt;string&lt;/span&gt;); ok {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; strings.HasPrefix(key, arg.GetValue()) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; v := &lt;span&gt;range&lt;/span&gt; ch {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err := stream.Send(&amp;amp;proto.String{Value: v.(&lt;span&gt;string&lt;/span&gt;)}); &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *PubsubService)&lt;/span&gt; &lt;span&gt;Subscribe&lt;/span&gt;&lt;span&gt;(arg *proto.String, stream proto.PubsubService_SubscribeServer)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ch := p.pub.Subscribe()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; v := &lt;span&gt;range&lt;/span&gt; ch {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err := stream.Send(&amp;amp;proto.String{Value: v.(&lt;span&gt;string&lt;/span&gt;)}); &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewPubsubService&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;PubsubService&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;PubsubService{pub: pubsub.NewPublisher(&lt;span&gt;100&lt;/span&gt;*time.Millisecond, &lt;span&gt;10&lt;/span&gt;)}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    lis, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:50051&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;failed to listen: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 简单调用&lt;/span&gt;&lt;br/&gt;    server := grpc.NewServer()&lt;br/&gt;    &lt;span&gt;// 注册 grpcurl 所需的 reflection 服务&lt;/span&gt;&lt;br/&gt;    reflection.Register(server)&lt;br/&gt;    &lt;span&gt;// 注册业务服务&lt;/span&gt;&lt;br/&gt;    proto.RegisterPubsubServiceServer(server, NewPubsubService())&lt;br/&gt;&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;grpc server start ...&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err := server.Serve(lis); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;failed to serve: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对比之前的发布订阅程序，其实这里是将 &lt;code&gt;*pubsub.Publisher&lt;/code&gt; 作为了 gRPC 的结构体 &lt;code&gt;PubsubService&lt;/code&gt; 的一个成员。&lt;/p&gt;&lt;p&gt;然后还是按照 gRPC 的开发流程，实现结构体对应的三个方法。&lt;/p&gt;&lt;p&gt;最后，在注册服务时，将 &lt;code&gt;NewPubsubService()&lt;/code&gt; 服务注入，实现本地发布订阅功能。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;订阅客户端&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;client/proto&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    conn, err := grpc.Dial(&lt;span&gt;&quot;localhost:50051&quot;&lt;/span&gt;, grpc.WithInsecure())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; conn.Close()&lt;br/&gt;&lt;br/&gt;    client := proto.NewPubsubServiceClient(conn)&lt;br/&gt;    stream, err := client.Subscribe(&lt;br/&gt;        context.Background(), &amp;amp;proto.String{Value: &lt;span&gt;&quot;golang:&quot;&lt;/span&gt;},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;            reply, err := stream.Recv()&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; io.EOF == err {&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            fmt.Println(&lt;span&gt;&quot;sub1: &quot;&lt;/span&gt;, reply.GetValue())&lt;br/&gt;        }&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    streamTopic, err := client.SubscribeTopic(&lt;br/&gt;        context.Background(), &amp;amp;proto.String{Value: &lt;span&gt;&quot;golang:&quot;&lt;/span&gt;},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;            reply, err := streamTopic.Recv()&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; io.EOF == err {&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;                log.Fatal(err)&lt;br/&gt;            }&lt;br/&gt;            fmt.Println(&lt;span&gt;&quot;subTopic: &quot;&lt;/span&gt;, reply.GetValue())&lt;br/&gt;        }&lt;br/&gt;    }()&lt;br/&gt;&lt;br/&gt;    &amp;lt;-&lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一个 &lt;code&gt;NewPubsubServiceClient&lt;/code&gt; 对象，然后分别实现 &lt;code&gt;client.Subscribe&lt;/code&gt; 和 &lt;code&gt;client.SubscribeTopic&lt;/code&gt; 方法，再通过 goroutine 不停接收消息。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;发布客户端&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;client/proto&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    conn, err := grpc.Dial(&lt;span&gt;&quot;localhost:50051&quot;&lt;/span&gt;, grpc.WithInsecure())&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; conn.Close()&lt;br/&gt;    client := proto.NewPubsubServiceClient(conn)&lt;br/&gt;&lt;br/&gt;    _, err = client.Publish(&lt;br/&gt;        context.Background(), &amp;amp;proto.String{Value: &lt;span&gt;&quot;golang: hello Go&quot;&lt;/span&gt;},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    _, err = client.Publish(&lt;br/&gt;        context.Background(), &amp;amp;proto.String{Value: &lt;span&gt;&quot;docker: hello Docker&quot;&lt;/span&gt;},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; != err {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建一个 &lt;code&gt;NewPubsubServiceClient&lt;/code&gt; 对象，然后通过 &lt;code&gt;client.Publish&lt;/code&gt; 方法发布消息。&lt;/p&gt;&lt;p&gt;当代码全部写好之后，我们开三个终端来测试一下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;终端1&lt;/strong&gt; 上启动服务端：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run main.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;终端2&lt;/strong&gt; 上启动订阅客户端：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run sub_client.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;终端3&lt;/strong&gt; 上执行发布客户端：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run pub_client.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，在 &lt;strong&gt;终端2&lt;/strong&gt; 上就有对应的输出了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;subTopic:  golang: hello Go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sub1:  golang: hello Go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sub1:  docker: hello Docker&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以再多开几个订阅终端，那么每一个订阅终端上都会有相同的内容输出。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;源码地址：&lt;/strong&gt; https://github.com/yongxinz/go-example/tree/main/grpc-example/pubsub&lt;/p&gt;&lt;h3&gt;&lt;span&gt;REST 接口&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;gRPC 一般用于集群内部通信，如果需要对外提供服务，大部分都是通过 REST 接口的方式。开源项目 grpc-gateway 提供了将 gRPC 服务转换成 REST 服务的能力，通过这种方式，就可以直接访问 gRPC API 了。&lt;/p&gt;&lt;p&gt;但我觉得，实际上这么用的应该还是比较少的。如果提供 REST 接口的话，直接写一个 HTTP 服务会方便很多。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;proto 文件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;第一步还是创建一个 proto 文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;syntax = &lt;span&gt;&quot;proto3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;package proto;&lt;br/&gt;&lt;br/&gt;import &lt;span&gt;&quot;google/api/annotations.proto&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;message StringMessage {&lt;br/&gt;  &lt;span&gt;string&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;service RestService {&lt;br/&gt;    &lt;span&gt;rpc &lt;span&gt;Get&lt;/span&gt;(&lt;span&gt;StringMessage&lt;/span&gt;) &lt;span&gt;returns&lt;/span&gt; (&lt;span&gt;StringMessage&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        option (google.api.http) = {&lt;br/&gt;            &lt;span&gt;get&lt;/span&gt;: &lt;span&gt;&quot;/get/{value}&quot;&lt;/span&gt;&lt;br/&gt;        };&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;rpc &lt;span&gt;Post&lt;/span&gt;(&lt;span&gt;StringMessage&lt;/span&gt;) &lt;span&gt;returns&lt;/span&gt; (&lt;span&gt;StringMessage&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        option (google.api.http) = {&lt;br/&gt;            post: &lt;span&gt;&quot;/post&quot;&lt;/span&gt;&lt;br/&gt;            body: &lt;span&gt;&quot;*&quot;&lt;/span&gt;&lt;br/&gt;        };&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义一个 REST 服务 &lt;code&gt;RestService&lt;/code&gt;，分别实现 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;POST&lt;/code&gt; 方法。&lt;/p&gt;&lt;p&gt;安装插件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;go &lt;span&gt;get&lt;/span&gt; -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成对应代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;protoc -I/usr/&lt;span&gt;local&lt;/span&gt;/include -I. \&lt;br/&gt;    -I$GOPATH/pkg/&lt;span&gt;mod&lt;/span&gt; \&lt;br/&gt;    -I$GOPATH/pkg/&lt;span&gt;mod&lt;/span&gt;/github.com/grpc-ecosystem/grpc-gateway@v1&lt;span&gt;.16&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;/third_party/googleapis \&lt;br/&gt;    &lt;span&gt;--grpc-gateway_out=. --go_out=plugins=grpc:.\&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;--swagger_out=. \&lt;/span&gt;&lt;br/&gt;    helloworld.proto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;--grpc-gateway_out&lt;/code&gt; 参数可生成对应的 gw 文件，&lt;code&gt;--swagger_out&lt;/code&gt; 参数可生成对应的 API 文档。&lt;/p&gt;&lt;p&gt;在我这里生成的两个文件如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;helloworld&lt;/span&gt;&lt;span&gt;.pb&lt;/span&gt;&lt;span&gt;.gw&lt;/span&gt;&lt;span&gt;.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;helloworld&lt;/span&gt;&lt;span&gt;.swagger&lt;/span&gt;&lt;span&gt;.json&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;REST 服务&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;rest/proto&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ctx := context.Background()&lt;br/&gt;    ctx, cancel := context.WithCancel(ctx)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt;    mux := runtime.NewServeMux()&lt;br/&gt;&lt;br/&gt;    err := proto.RegisterRestServiceHandlerFromEndpoint(&lt;br/&gt;        ctx, mux, &lt;span&gt;&quot;localhost:50051&quot;&lt;/span&gt;,&lt;br/&gt;        []grpc.DialOption{grpc.WithInsecure()},&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatal(err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    http.ListenAndServe(&lt;span&gt;&quot;:8080&quot;&lt;/span&gt;, mux)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里主要是通过实现 gw 文件中的 &lt;code&gt;RegisterRestServiceHandlerFromEndpoint&lt;/code&gt; 方法来连接 gRPC 服务。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;gRPC 服务&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;rest/proto&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RestServiceImpl &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r *RestServiceImpl)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(ctx context.Context, message *proto.StringMessage)&lt;/span&gt; &lt;span&gt;(*proto.StringMessage, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;proto.StringMessage{Value: &lt;span&gt;&quot;Get hi:&quot;&lt;/span&gt; + message.Value + &lt;span&gt;&quot;#&quot;&lt;/span&gt;}, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(r *RestServiceImpl)&lt;/span&gt; &lt;span&gt;Post&lt;/span&gt;&lt;span&gt;(ctx context.Context, message *proto.StringMessage)&lt;/span&gt; &lt;span&gt;(*proto.StringMessage, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;proto.StringMessage{Value: &lt;span&gt;&quot;Post hi:&quot;&lt;/span&gt; + message.Value + &lt;span&gt;&quot;@&quot;&lt;/span&gt;}, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    grpcServer := grpc.NewServer()&lt;br/&gt;    proto.RegisterRestServiceServer(grpcServer, &lt;span&gt;new&lt;/span&gt;(RestServiceImpl))&lt;br/&gt;    lis, _ := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:50051&quot;&lt;/span&gt;)&lt;br/&gt;    grpcServer.Serve(lis)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;gRPC 服务的实现方式还是和以前一样。&lt;/p&gt;&lt;p&gt;以上就是全部代码，现在来测试一下：&lt;/p&gt;&lt;p&gt;启动三个终端：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;终端1&lt;/strong&gt; 启动 gRPC 服务：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run grpc_service.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;终端2&lt;/strong&gt; 启动 REST 服务：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run rest_service.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;终端3&lt;/strong&gt; 来请求 REST 服务：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ curl localhost:&lt;span&gt;8080&lt;/span&gt;/get/gopher&lt;br/&gt;{&lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;Get hi:gopher&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;$ curl localhost:&lt;span&gt;8080&lt;/span&gt;/post -X POST --data &lt;span&gt;&#x27;{&quot;value&quot;:&quot;grpc&quot;}&#x27;&lt;/span&gt;&lt;br/&gt;{&lt;span&gt;&quot;value&quot;&lt;/span&gt;:&lt;span&gt;&quot;Post hi:grpc&quot;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;源码地址：&lt;/strong&gt; https://github.com/yongxinz/go-example/tree/main/grpc-example/rest&lt;/p&gt;&lt;h3&gt;&lt;span&gt;超时控制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;最后一部分介绍一下超时控制，这部分内容是非常重要的。&lt;/p&gt;&lt;p&gt;一般的 WEB 服务 API，或者是 Nginx 都会设置一个超时时间，超过这个时间，如果还没有数据返回，服务端可能直接返回一个超时错误，或者客户端也可能结束这个连接。&lt;/p&gt;&lt;p&gt;如果没有这个超时时间，那是相当危险的。所有请求都阻塞在服务端，会消耗大量资源，比如内存。如果资源耗尽的话，甚至可能会导致整个服务崩溃。&lt;/p&gt;&lt;p&gt;那么，在 gRPC 中怎么设置超时时间呢？主要是通过上下文 &lt;code&gt;context.Context&lt;/code&gt; 参数，具体来说就是 &lt;code&gt;context.WithDeadline&lt;/code&gt; 函数。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;proto 文件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;创建最简单的 proto 文件，这个不多说。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;syntax = &lt;span&gt;&quot;proto3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;package proto;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// The greeting service definition.&lt;/span&gt;&lt;br/&gt;service Greeter {&lt;br/&gt;    &lt;span&gt;// Sends a greeting&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;rpc &lt;span&gt;SayHello&lt;/span&gt; &lt;span&gt;(HelloRequest)&lt;/span&gt; &lt;span&gt;returns&lt;/span&gt; &lt;span&gt;(HelloReply)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// The request message containing the user&#x27;s name.&lt;/span&gt;&lt;br/&gt;message HelloRequest {&lt;br/&gt;    &lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// The response message containing the greetings&lt;/span&gt;&lt;br/&gt;message HelloReply {&lt;br/&gt;    &lt;span&gt;string&lt;/span&gt; message = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;client/proto&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc/codes&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc/status&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 简单调用&lt;/span&gt;&lt;br/&gt;    conn, err := grpc.Dial(&lt;span&gt;&quot;localhost:50051&quot;&lt;/span&gt;, grpc.WithInsecure())&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; conn.Close()&lt;br/&gt;&lt;br/&gt;    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Duration(&lt;span&gt;3&lt;/span&gt;*time.Second)))&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt;    client := proto.NewGreeterClient(conn)&lt;br/&gt;    &lt;span&gt;// 简单调用&lt;/span&gt;&lt;br/&gt;    reply, err := client.SayHello(ctx, &amp;amp;proto.HelloRequest{Name: &lt;span&gt;&quot;zzz&quot;&lt;/span&gt;})&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        statusErr, ok := status.FromError(err)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ok {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; statusErr.Code() == codes.DeadlineExceeded {&lt;br/&gt;                log.Fatalln(&lt;span&gt;&quot;client.SayHello err: deadline&quot;&lt;/span&gt;)&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;client.SayHello err: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;    fmt.Println(reply.Message)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过下面的函数设置一个 3s 的超时时间：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Duration(&lt;span&gt;3&lt;/span&gt;*time.Second)))&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在响应错误中对超时错误进行检测。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;context&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;runtime&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;server/proto&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc/codes&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc/reflection&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;google.golang.org/grpc/status&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; greeter &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(*greeter)&lt;/span&gt; &lt;span&gt;SayHello&lt;/span&gt;&lt;span&gt;(ctx context.Context, req *proto.HelloRequest)&lt;/span&gt; &lt;span&gt;(*proto.HelloReply, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    data := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; *proto.HelloReply, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; handle(ctx, req, data)&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; res := &amp;lt;-data:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, status.Errorf(codes.Canceled, &lt;span&gt;&quot;Client cancelled, abandoning.&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(ctx context.Context, req *proto.HelloRequest, data &lt;span&gt;chan&lt;/span&gt;&amp;lt;- *proto.HelloReply)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;        log.Println(ctx.Err())&lt;br/&gt;        runtime.Goexit() &lt;span&gt;//超时后退出该Go协程&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;4&lt;/span&gt; * time.Second): &lt;span&gt;// 模拟耗时操作&lt;/span&gt;&lt;br/&gt;        res := proto.HelloReply{&lt;br/&gt;            Message: &lt;span&gt;&quot;hello &quot;&lt;/span&gt; + req.Name,&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// //修改数据库前进行超时判断&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// if ctx.Err() == context.Canceled{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//  ...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//  //如果已经超时，则退出&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;        data &amp;lt;- &amp;amp;res&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    lis, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:50051&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;failed to listen: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 简单调用&lt;/span&gt;&lt;br/&gt;    server := grpc.NewServer()&lt;br/&gt;    &lt;span&gt;// 注册 grpcurl 所需的 reflection 服务&lt;/span&gt;&lt;br/&gt;    reflection.Register(server)&lt;br/&gt;    &lt;span&gt;// 注册业务服务&lt;/span&gt;&lt;br/&gt;    proto.RegisterGreeterServer(server, &amp;amp;greeter{})&lt;br/&gt;&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;grpc server start ...&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err := server.Serve(lis); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatalf(&lt;span&gt;&quot;failed to serve: %v&quot;&lt;/span&gt;, err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务端增加一个 &lt;code&gt;handle&lt;/code&gt; 函数，其中 &lt;code&gt;case &amp;lt;-time.After(4 * time.Second)&lt;/code&gt; 表示 4s 之后才会执行其对应代码，用来模拟超时请求。&lt;/p&gt;&lt;p&gt;如果客户端超时时间超过 4s 的话，就会产生超时报错。&lt;/p&gt;&lt;p&gt;下面来模拟一下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务端：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ go run main.go&lt;br/&gt;grpc server &lt;span&gt;start&lt;/span&gt; ...&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt; &lt;span&gt;context&lt;/span&gt; deadline exceeded&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;客户端：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ go run main.go&lt;br/&gt;&lt;span&gt;2021&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;40&lt;/span&gt; client.SayHello err: deadline&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt; status &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;源码地址：&lt;/strong&gt; https://github.com/yongxinz/go-example/tree/main/grpc-example/deadline&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;本文主要介绍了 gRPC 的三部分实战内容，分别是：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发布订阅模式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;REST 接口&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;超时控制&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;个人感觉，超时控制还是最重要的，在平时的开发过程中需要多多注意。&lt;/p&gt;&lt;p&gt;结合上篇文章，gRPC 的实战内容就写完了，代码全部可以执行，也都上传到了 GitHub。&lt;/p&gt;&lt;p&gt;大家如果有任何疑问，欢迎给我留言，如果感觉不错的话，也欢迎关注和转发。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;题图：&lt;/strong&gt; 该图片由 Reytschl 在 Pixabay 上发布&lt;/p&gt;&lt;p&gt;&lt;strong&gt;源码地址：&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;关注公众号 &lt;strong&gt;AlwaysBeta&lt;/strong&gt;，回复「&lt;strong&gt;goebook&lt;/strong&gt;」领取 Go 编程经典书籍。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3MjY1ODI2Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YQLyg1D0dluejnibLk0SZTDAwxMeYugmNiakQIDLp6wqGCGxNkbIjHJYedmKLKaJeAmt2NMslI7COJwD44flibVmQ/0?wx_fmt=png&quot; data-nickname=&quot;AlwaysBeta&quot; data-alias=&quot;betasite&quot; data-signature=&quot;手艺人，写代码的&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;https://chai2010.cn/advanced-go-programming-book/ch4-rpc/readme.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://codeleading.com/article/94674952433/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://juejin.cn/post/6844904017017962504&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://www.cnblogs.com/FireworksEasyCool/p/12702959.html&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2bd347b372c777463d3369b89d8643b4</guid>
<title>设计模式系列：建造者模式</title>
<link>https://toutiao.io/k/n7vne01</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;建造者模式用于将复杂对象的创建和表示分离，有些对象由很多部分组成，每个部分又可以有多种不同选择，创建这种对象的时候往往需要考虑使用建造者模式。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;举个例子&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;一辆汽车由发动机，方向盘，车灯，车灯，车身颜色等组成，每辆车的颜色，车轮大小，车灯样式可能会不一样，但是车的组成部分不会少。&lt;/p&gt;&lt;p&gt;建造模式有两种实现方式，第一种方式是有导演的方式，第二种是无导演方式。根据我的经验日常使用无导演的方式可能会更多一些。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;有导演&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;所谓有导演就是通过一个导演类来指挥对象创建的过程，客户端使用导演类来获取对象，不用关心对象具体的创建过程。&lt;/p&gt;&lt;p&gt;先看一下&lt;code&gt;UML&lt;/code&gt;图，对建造模式有个大概的了解。&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100000566&quot; data-ratio=&quot;0.8931034482758621&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9QjGl15ibrdUldicgJCc7zg935YUDz6zuhl2UgqulbvrbcK1M8SqmAm5JaQH0UL1QqzFibb4BZvsSc3Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;看一下具体代码，我们以建造一辆汽车举例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String wheel;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String engine;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String seat;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String lamp;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String color;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//篇幅原因，此处省略get,set方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Car{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;wheel=&#x27;&quot;&lt;/span&gt; + wheel + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;, engine=&#x27;&quot;&lt;/span&gt; + engine + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;, seat=&#x27;&quot;&lt;/span&gt; + seat + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;, lamp=&#x27;&quot;&lt;/span&gt; + lamp + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;, color=&#x27;&quot;&lt;/span&gt; + color + &lt;span&gt;&#x27;\&#x27;&#x27;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;抽象&lt;code&gt;Builder&lt;/code&gt;类，指定建造复杂对象步骤&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Builder&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildWheel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildSeat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildLamp&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildColor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildEngine&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; Car &lt;span&gt;getCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体&lt;code&gt;Builder&lt;/code&gt;类，实现复杂对象具体建造过程和内容&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConcreteBuilder&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Builder&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Car car;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ConcreteBuilder&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car = &lt;span&gt;new&lt;/span&gt; Car();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildWheel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setWheel(&lt;span&gt;&quot;wheel&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildSeat&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setSeat(&lt;span&gt;&quot;seat&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildLamp&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setLamp(&lt;span&gt;&quot;lamp&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildColor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setColor(&lt;span&gt;&quot;color&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildEngine&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setEngine(&lt;span&gt;&quot;engine&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//返回构建好的汽车模型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Car &lt;span&gt;getCar&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; car;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Director&lt;/code&gt;类，决定了复杂对象的创建过程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarDirector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Car &lt;span&gt;createCar&lt;/span&gt;&lt;span&gt;(Builder builder)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        builder.buildWheel();&lt;br/&gt;        builder.buildSeat();&lt;br/&gt;        builder.buildLamp();&lt;br/&gt;        builder.buildColor();&lt;br/&gt;        builder.buildEngine();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; builder.getCar();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端这样使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BuilderClient&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        CarDirector carDirector = &lt;span&gt;new&lt;/span&gt; CarDirector();&lt;br/&gt;        &lt;span&gt;//通过Director创建具体对象，不关心对象的创建过程&lt;/span&gt;&lt;br/&gt;        Car car = carDirector.createCar(&lt;span&gt;new&lt;/span&gt; ConcreteBuilder());&lt;br/&gt;        System.out.println(car.toString());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;无导演&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;无导演模式感觉日常开发中用的比较多，但凡见到形似这样的代码，大概率就是建造者模式了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Car car = concreteBuilderA.buildEngine(&lt;span&gt;&quot;engine&quot;&lt;/span&gt;)&lt;br/&gt;                    .buildLamp(&lt;span&gt;&quot;lamp&quot;&lt;/span&gt;)&lt;br/&gt;                    .buildSeat(&lt;span&gt;&quot;seat&quot;&lt;/span&gt;)&lt;br/&gt;                    .buildColor(&lt;span&gt;&quot;color&quot;&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;//.buildWheel(&quot;wheel&quot;)&lt;/span&gt;&lt;br/&gt;                    .build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;老规矩先来看一下&lt;code&gt;UML&lt;/code&gt;图，来个整体的认识。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;100000565&quot; data-ratio=&quot;0.9467554076539102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9QjGl15ibrdUldicgJCc7zg935SCfHMZqj2uukgxHHtUtzr8c6Zks68VyzRvDQWsnWQKrsOPuC3R109w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p&gt;同样来看一下具体代码实现，还是以创建汽车为例，所以Car的代码不在重复给出。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Builder&lt;/code&gt;类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BuilderA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//返回builder自身&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; BuilderA &lt;span&gt;buildWheel&lt;/span&gt;&lt;span&gt;(String wheel)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; BuilderA &lt;span&gt;buildEngine&lt;/span&gt;&lt;span&gt;(String engine)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; BuilderA &lt;span&gt;buildLamp&lt;/span&gt;&lt;span&gt;(String lamp)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; BuilderA &lt;span&gt;buildSeat&lt;/span&gt;&lt;span&gt;(String seat)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; BuilderA &lt;span&gt;buildColor&lt;/span&gt;&lt;span&gt;(String color)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;abstract&lt;/span&gt; Car &lt;span&gt;build&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体&lt;code&gt;Builder&lt;/code&gt;，负责对象的具体创建工作。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConcreteBuilderA&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BuilderA&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Car car;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ConcreteBuilderA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car = &lt;span&gt;new&lt;/span&gt; Car();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;BuilderA &lt;span&gt;buildWheel&lt;/span&gt;&lt;span&gt;(String wheel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setWheel(wheel);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;BuilderA &lt;span&gt;buildEngine&lt;/span&gt;&lt;span&gt;(String engine)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setEngine(&lt;span&gt;&quot;engine&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;BuilderA &lt;span&gt;buildLamp&lt;/span&gt;&lt;span&gt;(String lamp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setLamp(&lt;span&gt;&quot;lamp&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;BuilderA &lt;span&gt;buildSeat&lt;/span&gt;&lt;span&gt;(String seat)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setSeat(&lt;span&gt;&quot;seat&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;BuilderA &lt;span&gt;buildColor&lt;/span&gt;&lt;span&gt;(String color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        car.setColor(&lt;span&gt;&quot;color&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Car &lt;span&gt;build&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; car;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端这样使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BuilderAClient&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        ConcreteBuilderA concreteBuilderA = &lt;span&gt;new&lt;/span&gt; ConcreteBuilderA();&lt;br/&gt;&lt;br/&gt;        Car car = concreteBuilderA.buildEngine(&lt;span&gt;&quot;engine&quot;&lt;/span&gt;)&lt;br/&gt;                    .buildLamp(&lt;span&gt;&quot;lamp&quot;&lt;/span&gt;)&lt;br/&gt;                    .buildSeat(&lt;span&gt;&quot;seat&quot;&lt;/span&gt;)&lt;br/&gt;                    .buildColor(&lt;span&gt;&quot;color&quot;&lt;/span&gt;)&lt;br/&gt;                    &lt;span&gt;//.buildWheel(&quot;wheel&quot;)&lt;/span&gt;&lt;br/&gt;                    .build();&lt;br/&gt;        System.out.println(car.toString());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;建造者模式是创建型模式之一，所谓的没有&lt;code&gt;Director&lt;/code&gt;的模式，只不过是把建造过程留给了客户端，让使用者自己决定怎样创建对象。无&lt;code&gt;Director&lt;/code&gt;模式的实现关键是&lt;code&gt;Builder&lt;/code&gt;类里面构建每个组件的方法都是返回&lt;code&gt;Builder&lt;/code&gt;自己。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04e1f6d6d663d85733c08e3e88f6942a</guid>
<title>抖音系企业应用设计系统 Semi Design 开源啦</title>
<link>https://toutiao.io/k/zav3dei</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-msg__text-area&quot;&gt;
                    &lt;p class=&quot;weui-msg__title warn&quot;&gt;
            The content has been deleted by the author.            &lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>