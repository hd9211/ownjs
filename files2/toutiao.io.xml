<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e38b5ea3240565f70ebe64ea60e3adcd</guid>
<title>尤娜系统的第一次飞行中换引擎的架构垂直拆分改造</title>
<link>https://toutiao.io/k/193vnpj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转眼离上次尤娜系统削峰填谷的改造已经过去4个月了。小B又来找尤娜，说她还有几个客户想对接B系统，尤娜系统对接的不错，所以希望这些客户都直接对接尤娜，小B会给利润分成。这是件双方都受益的好事，尤娜一口答应了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;未来需求预测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤娜请我喝咖啡，我们一起聊到尤娜系统未来可能的业务。尤娜说她还有几个朋友，也苦于和各个公司开展业务，对接成本高。尤娜出马一定可以说服他们用尤娜作为通道代理，各方受益。尤娜还说到虽然现在短期可以不考虑成本，长期希望作为代理公司可以盈利。另外，现在对接的不多，利润分成可以线下打款，以后业务做大了，估计还需要系统来完成整个业务闭环。让我好好考虑一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;我其实有点迷茫了：现在设计到哪一步是才是合理的呢？找到了&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486665&amp;amp;idx=1&amp;amp;sn=fa111f7d20c805488d51c2f6cafb2aef&amp;amp;chksm=fafde667cd8a6f71164e1da5b79dad16946bdad26f0ae642ba96c91c9a21707763092f234424&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《M*N个策略造成类爆炸怎样重构？》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《M*N个策略造成类爆炸怎样重构？》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章，里面提到：&lt;span&gt;架构和代码&lt;/span&gt;&lt;span&gt;不是设计出来的，是演进出来的。我觉得有道理，先把现在相对确定的需求设计完成：&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;1&amp;gt;B接新业务&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2&amp;gt;新公司接新业务&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3&amp;gt;考虑成本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4&amp;gt;做新业务的同时保证老业务的稳定性&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9335180055401662&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkw9sTclVY7vo8VtxBCLCRuwJG2bLumiaOEgROEiaeNK0VrvKoVI2c6Z1CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;361&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前尤娜系统是这样的，我们买了一个域名，绑定到一台nginx反向代理服务器。nginx是24核128G高配物理机。目前线上高峰时刻2000TPS，尤娜系统调用B系统平均耗时300ms，TP99是800ms(99%的请求在800ms内完成)。加上kafka全链路高峰时刻加上排队，TP99要2分钟。由于kafka削峰填谷，给B公司的请求并发量不超过500TPS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤娜系统使用了24台4核8G的机器来运行，目前容量满足需求，有一定的冗余，但具体多少还没有压测过。web容器我用的是jetty。网上说建议worker线程数设置为100或者200。我设置成了5000，似乎工作的挺好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是从成本的角度，新业务仍然使用像A系统这样同步调用的模式有很大的性能问题。性能问题全靠堆机器来支撑，所以目前的模式，公司是在做赔本的买卖。开展新业务可以从一开始就规定使用异步的模式，这样可以避免2分钟请求处理不完，一直占用线程，打满线程池的问题。所以单独从新业务的角度，架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9682539682539683&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwDNab1tHibVSMPTyUm2piaQwp9E1RkWZ9uKs66GznvGm6AGSrz9arN4dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但这是个理想化的模型，客户未必会认可。如果客户要同步调用我们也需要支持。那就需要对这个同步的模型做一个改造：也拆分成两个。老模型改造后的架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8522954091816367&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwg0rQOfq5N7BLKapAKYB4YKBPbXWUr5IYrIDfsJ5picg6yHIxZsfYbWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;501&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在就面临一个问题：老系统和新系统有复用的模块，也有不同的模式。是分开建设还是代码统一维护？是分开部署还是部署在一起？就这个问题我列了优缺点对比及相应的解决方案，请尤娜老板来做决议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkw0eicDDNvibsBiaLlm8vvQl98fibtria2VOTOzxLicfXpZYSgYcXrcaDa7ltA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;复用方案从稳定性上偏弱，我参考了&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485188&amp;amp;idx=1&amp;amp;sn=3618568ba3bf9c396195d8e2c4e6723d&amp;amp;chksm=fafdedaacd8a64bca74024452fb88a56ff99aa6bcd9ae841fca1b91cbff40d4dd78698b09dcc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《服务的容灾与容错》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《服务的容灾与容错》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;分析可以采用线程池隔离的方案，又通过&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485474&amp;amp;idx=1&amp;amp;sn=df22866d7a0b096e7169a5bef81a3058&amp;amp;chksm=fafde28ccd8a6b9a0157fb4e2600a71c8a5db6db7eea37dfdbd6f25e6d3b38b6ab92c4d1f9e3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《hystrix线程池隔离的原理与验证》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《hystrix线程池隔离的原理与验证》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;和&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485666&amp;amp;idx=1&amp;amp;sn=281374a2c8b286fe9c993e2f4698a261&amp;amp;chksm=fafde24ccd8a6b5ad998f2e893045bb387b3e26b9c7e20802b12b8a2fb2f32dca3db1c2fcf51&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Java线程池总结》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Java线程池总结》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;找到了具体的实施方法。最终尤娜采纳了复用方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最终的架构方案是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7907407407407407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkw5HY52K74iaQMfeM5LTvXCXb80a2HbtEibqKGdJicuydTe0xVH3x23XZsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统迁移方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤娜系统要垂直拆分：一拆二。从&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485181&amp;amp;idx=1&amp;amp;sn=df4568317a038fcff3b77cd66d0b7bb6&amp;amp;chksm=fafdec53cd8a654573d4210e755fac7c95b5145aa8a5c76cb3df64478a44da0446945ef04c19&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《服务治理的技术血脉》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《服务治理的技术血脉》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章我了解到垂直拆分是服务治理的开始，以后事情会越来越多。目前首要的事情是要平滑进行拆分后的迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我按照尤娜的建议，定义了标准的接入规范。对外暴露两种接入方式：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步调用&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步调用&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步调用接口/asyn/b&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;异步回调接口，由接入方提供&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时规定这些接口必须透传一个18位的请求编号，这个请求编号是做全链路跟踪用的。因为在和A对接时没有这个号，所以我做了兼容，如果没有传，我就自己生成一个。生成方法我参考的是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486291&amp;amp;idx=1&amp;amp;sn=c6a52233e35571c6531bbef005139981&amp;amp;chksm=fafde1fdcd8a68ebf2e6c1f3edc53cff7c8a622dd8520d2e98cf9b99976e29096a3bd9d79604&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《惊艳面试官-Java中关于随机数生成8种方式的思考》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;惊艳面试官-Java中关于随机数生成8种方式的思考》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;里的随机数生成，18位基本上可以保证每天千亿级别请求量的情况下不重复。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异步部分是新逻辑，该在哪个工程代码下开发就在哪里开发。老逻辑，从消费端可以将逻辑迁移到新系统，外部不感知。因为消费端是真正的逻辑处理部分，所以我将这部分叫做“尤娜系统逻辑处理”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在完全迁移之前，老系统保持不动。尤娜系统逻辑处理订阅kafka消息，需要灰度来承接流量。为此，我选择在凌晨1点到5点的低峰期上线，这个时间段，1分钟只有几笔请求。但这是一次大升级，还是需要和小A的公司、小B的公司打声招呼。最好他们也能一起升级把跟踪号加上。并请小A的公司出人一起确认业务状态。尤娜出面轻松的帮我搞定了小A公司的事项。小B的公司不同意做任何变更，这个也不是必需的，所以这个作罢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;凌晨1点，我准时启动了一台新的逻辑处理服务。过了十几分钟，终于有个请求被这台机器消费了。我通过跟踪日志、数据库数据确认处理和老逻辑完全一致。请小A公司的人确认请求结果符合预期。打算第二天再部署一台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的打算是因为逻辑处理服务耗时TP99是800ms，最高请求并发量是500TPS。按单台并发量是200来算，3台4C8G足够。留有一定冗余容灾，部署6台。灰度发布，3天部署完。之后老尤娜系统，也就是新的尤娜系统api网关，会每天停止一台的消费，只做生产者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是尤娜系统的第一次飞行中换引擎的垂直拆分改造过程。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复盘&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个过程给我印象最深的是沟通问题。阿里黑话叫：拉通、对齐。&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486632&amp;amp;idx=1&amp;amp;sn=7b443147ff6b4d10ab0c09ee6e1e1d73&amp;amp;chksm=fafde606cd8a6f109870d9ad2c47cc42497de5a0f18d84bcdb174d3bf13e49efe8b6bf1a27d2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;领域驱动设计DDD&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;领域驱动设计DDD&lt;/a&gt;里叫通用语言。这些都在说沟通的问题。现在很多事情，技术不是难题，关键是沟通。和领导的沟通，和外部的沟通。沟通要放在第一位。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么网上说建议worker线程数设置为100或者200。我设置成了5000，似乎工作的挺好？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先上使用spring boot设置方法的代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public class &lt;/span&gt;JettyConfig {&lt;br/&gt;    &lt;span&gt;@Bean&lt;br/&gt;    &lt;/span&gt;&lt;span&gt;public &lt;/span&gt;ConfigurableServletWebServerFactory webServerFactory()&lt;br/&gt;    {&lt;br/&gt;        JettyServletWebServerFactory factory = &lt;span&gt;new &lt;/span&gt;JettyServletWebServerFactory();&lt;br/&gt;        factory.setPort(&lt;span&gt;9000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Tweak the connection config used by Jetty to handle incoming HTTP&lt;br/&gt;        // connections&lt;br/&gt;        &lt;/span&gt;&lt;span&gt;final &lt;/span&gt;QueuedThreadPool threadPool = &lt;span&gt;new &lt;/span&gt;QueuedThreadPool();&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默&lt;/span&gt;&lt;span&gt;认&lt;/span&gt;&lt;span&gt;最大&lt;/span&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;程&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数&lt;/span&gt;&lt;span&gt;200&lt;br/&gt;        &lt;/span&gt;threadPool.setMaxThreads(&lt;span&gt;5000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默&lt;/span&gt;&lt;span&gt;认&lt;/span&gt;&lt;span&gt;最小&lt;/span&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;程&lt;/span&gt;&lt;span&gt;连&lt;/span&gt;&lt;span&gt;接数&lt;/span&gt;&lt;span&gt;8&lt;br/&gt;        &lt;/span&gt;threadPool.setMinThreads(&lt;span&gt;20&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默&lt;/span&gt;&lt;span&gt;认线&lt;/span&gt;&lt;span&gt;程最大空&lt;/span&gt;&lt;span&gt;闲时间&lt;/span&gt;&lt;span&gt;60000ms&lt;br/&gt;        &lt;/span&gt;threadPool.setIdleTimeout(&lt;span&gt;60000&lt;/span&gt;);&lt;br/&gt;        factory.setThreadPool(threadPool);&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;factory;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置maxThreads主要是两点考虑和限制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1&amp;gt;JVM设置时有Xss参数代表每个线程分配的内存资源大小。我设置为128K。这样，最大5000*128K占不到1G内存。堆内存设置为3G。内存共8G，还有足够的内存可以使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2&amp;gt;线程数多会影响上下文切换，如果CPU密集型处理可能会影响响应速度。但是目前线程主要是在等待IO，也没有很强的时效性要求，所以设置成5000问题不大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编者按&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我打算写这样一个系统故事是因为也是咱们用户群里提到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486857&amp;amp;idx=1&amp;amp;sn=c95685a190e6e7d3fa6b8b9c7b5b5df9&amp;amp;chksm=fafde727cd8a6e31c2e6b2f00ca606135789545ebc46d029419cb3444f98c157749388e95d2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《弹力设计三大纪律，怎样让稳定性KPI高大上？》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《弹力设计三大纪律，怎样让稳定性KPI高大上？》&lt;/a&gt;这样的文章对实操帮助不大，实际中还是不知道怎么做，希望我可以出一些实战性的文章。大家希望我写什么样的文章也可以加我微信 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;brmayi &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，注明：入群。一起进群讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;关于设计和架构，我是这么理解：做架构是一个在不同阶段做不同权衡的过程，任何一个决策都有其背景。首先我想把实际工作的内容做输出需要授权，也和咱们不同人遇到的问题不一定契合。而如果我能通过一个系列，这个系列的系统是慢慢孵化的，其实可以覆盖系统演进过程中的很多场景。大家可以代入性思考，这个问题自己会怎么去解决，而别人是怎么解决的，都有哪些考虑点。这样经过几次思考，慢慢强化架构意识，还可以感受到架构在其中的作用。也建议大家在读文章的时候注意里面的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，帮好朋友做招聘。铁哥们，人超好~~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;3.3817567567567566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwEspESaUaZiauwZicLL6C5q59qvrMAv5dmG2PvLibZUmtdAROQjEw97MCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p&gt;给朋友的联系方式来张大图，&lt;br/&gt;也可以直接发送简历到朋友邮箱：&lt;br/&gt;&lt;strong&gt;&lt;span&gt;houjinxuan@meituan.com&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;636&quot; data-backw=&quot;358&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7781531531531531&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlib9yJ6ORVmdtlUH8PNRESkwJMGsthUO1cJjSEn78ohzib8TOychicDfO5O7g71ibIgea8icsUF8zcickZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ea34e50f48a9abbb95c092446b90d10</guid>
<title>浏览器缓存库设计总结（localStorage/indexedDB）</title>
<link>https://toutiao.io/k/v4pmufa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5539906103286385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlZkx88icktcNibiaaKBHa3SLWHlj2icm0ticUXficmSdbj1vQeP600iaEOmnlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;浏览器缓存设计一直是web性能优化中非常重要的一个环节,也是SPA应用盛行的今天不得不考虑的问题.作为一名优秀的前端工程师,为了让我们的应用更流畅,用户体验更好,我们有必要做好浏览器缓存策略.&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;每个Web应用体验都必须快速，对于渐进式 Web 应用更是如此。快速是指在屏幕上获取有意义内容所需的时间，要在不到 5 秒的时间内提供交互式体验。并且，它必须真的很快。很难形容可靠的高性能有多重要。可以这样想: 本机应用的首次加载令人沮丧。已安装的渐进式 Web 应用必须能让用户获得可靠的性能。&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;本文会介绍一些笔者曾经做过的Web性能优化方案以及浏览器缓存的基本流程,并会着重介绍如&lt;span&gt;何利用浏览器缓存API封装适合自己团队的前端缓存库&lt;/span&gt;来极大地提高应用性能,并&lt;span&gt;为公司省钱&lt;/span&gt;.&lt;/p&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;你将收获&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;熟悉浏览器缓存的基本过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web性能优化基本方案以及缓存策略为公司带来的价值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于localStorage的缓存方案设计以及库的封装(vuex/redux数据持久化解决方案)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于indexedDB的缓存方案设计以及库的封装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合http请求库(axios/umi-request)进行更细粒度的缓存代理层设计&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;正文&lt;/h2&gt;&lt;h3 data-id=&quot;heading-3&quot;&gt;&lt;strong&gt;1.浏览器缓存的基本过程&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先要想设计一个优秀的缓存策略,一定要了解浏览器缓存的流程,接下来是笔者总结的一个基本的流程图:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1280&quot; data-ratio=&quot;1.0322916666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlkmWCzBR7JP1FyMKw1pWoA3wYPoLT2gfwDesqoc9OzbQoO1CibvtTBRw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;960&quot; data-width=&quot;1240&quot;/&gt;&lt;/section&gt;&lt;p&gt;上图展示了一个基本的从浏览器请求到展示资源的过程,我们的缓存策略一部分可以从以上流程出发来做优化.我们都知道页面的缓存状态是由header决定的,下面具体介绍几个概念:&lt;/p&gt;&lt;h4 data-id=&quot;heading-4&quot;&gt;&lt;strong&gt;1. ETag&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;由服务端根据资源内容生成一段 hash 字符串，标识资源的状态,用户第一次请求时服务器会将ETag随着资源一起返回给浏览器, 再次请求时浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改直接使用缓存.具体流程可以是如下情景:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;624&quot; data-ratio=&quot;0.4875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlj59T40N93PsFia4ZViaW6MZN56O1ByPic7ic0924aeghOetaAW3rWKnCvQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;基于内容的hash往往会比Last-modified更准确.&lt;/section&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;&lt;strong&gt;2. Last-modified&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;服务器端资源最后的修改时间，必须和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回 304，使用缓存；如果修改过，则再次去服务器请求资源，返回200，重新请求资源。&lt;/p&gt;&lt;h4 data-id=&quot;heading-6&quot;&gt;&lt;strong&gt;3. Expires&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用. Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。&lt;/p&gt;&lt;h4 data-id=&quot;heading-7&quot;&gt;&lt;strong&gt;4. Cache-Control的max-age&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;单位为秒,指定设置缓存最大的有效时间。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。以上就是浏览器缓存几个基本的概念,更多知识可以在wiki中学习,这里就不一一介绍了.接下来我们具体看看如何优化web应用以及缓存策略给公司带来的价值.&lt;/p&gt;&lt;h3 data-id=&quot;heading-8&quot;&gt;&lt;strong&gt;2.Web性能优化基本方案以及缓存策略为公司带来的价值&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Web性能优化又是老生常谈的问题了,几年前就一直在探讨这个问题,笔者大致盘点一下性能优化的几个常用的方向:&lt;/p&gt;&lt;h4 data-id=&quot;heading-9&quot;&gt;&lt;strong&gt;1.资源的合并与压缩.&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;比如我们常用的gulp或者webpack这些打包工具, 可以帮我们压缩js,css,html代码,并且将不同页面模块的js,css打包合并到一个文件中,好处就是减少了http请求,降低了资源的体积,使得响应更快.但是仍然存在一个缺陷,就是合并代码会导致一次请求的资源体积会比之前分包的要大,所以会一定程度的影响页面渲染时间,所以这里需要做一个权衡,或者部分采用按需加载的方式.&lt;/p&gt;&lt;h4 data-id=&quot;heading-10&quot;&gt;&lt;strong&gt;2.图片压缩&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;一个网站往往更占资源的是媒体文件,比如图片,视频,音频等,对于图片在发布到线上时最好是需求提前压缩一下, 为了减少图片请求几年前常用的做法是雪碧图,也就是几张图片合成一张大图,通过背景定位来显示不同的图片,不过目前貌似用的不多了,现在更多的采用字体图标,svg,或者webp,所以我们需要根据不同的场景使用不同的策略,当然目前主流的云平台支持对象存储,对媒体资源有不错的优化,有条件的可以采用这种方案,比如七牛云,阿里的对象存储oss.&lt;/p&gt;&lt;h4 data-id=&quot;heading-11&quot;&gt;&lt;strong&gt;3. 合理规划html代码结构&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这个优化主要是为了提高页面渲染时间,我们都知道css和js的加载一般都是阻塞的, css不会阻塞js和外部脚本的加载,但是会阻塞js的执行, 如果我们把css放到body最底部,那么我们在网络不好的情况下可能会看到先展示html文本然后才渲染页面样式的窘境,如果我们把js脚本放到head内,那么将会阻塞后面内容的渲染,并且造成一些应dom还未生成的导致的错误, 虽然我们可以采用async、defer让script变成异步的,但是如果不同js文件有依赖关系,那么很可能导致意外的错误,所以我们的最佳实践往往是如下这种结构的:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;title&amp;gt;&lt;/span&gt;趣谈前端&lt;span&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;meta &lt;span&gt;charset&lt;/span&gt;=&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;meta &lt;span&gt;http-equiv&lt;/span&gt;=&lt;span&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;IE=edge&quot;&lt;/span&gt;&amp;gt;&amp;lt;meta &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span&gt;content&lt;/span&gt;=&lt;span&gt;&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;link &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;icon&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/ico.png&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;image/x-icon&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;link &lt;span&gt;rel&lt;/span&gt;=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;href&lt;/span&gt;=&lt;span&gt;&quot;/umi.348436c0.css&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;div&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;  // html内容&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;script &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;/umi.520.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-id=&quot;heading-12&quot;&gt;&lt;strong&gt;4.资源的懒加载和预加载&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;资源的懒加载可以极大的降低页面首屏时间, 我们不仅仅可以对图片采用懒加载, 即只给用户展示可视区域内的图片(虽然图片的懒加载意义更加重大),我们还可以对内容进行懒加载,本质上是一种特殊的分页技巧, jquery时代的lazyload是一个很好的例子,当然现在自己实现一个懒加载方案也非常简单,我们只需要使用getBoundingClientRect这个API配合具体业务使用即可,内容型平台用的比较多,比如我们手机滑到某一区域才加载更多内容,笔者之前做的某头条的广告埋点上报机制就是一个很好的例子.大致思路如下:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;848&quot; data-ratio=&quot;0.6625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlnRPldmOuMOzefJfUyoE2L6VmOgtSIzn7oN1EdyXibeU4ldcOx2Ouia9w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;p&gt;预加载就是提前加载图片，当用户需要查看时可直接从本地缓存中渲染.这种机制和懒加载往往相反,预加载为了带来更加流畅的用户体验,比如漫画网站,我们如果不使用预加载,那么用户频繁切换图片时体验是相当差的,所以我们需要提前将图片加载好,牺牲的代价就是用户可能会等待一定的时间来开启&quot;漫画之旅&quot;.&lt;/p&gt;&lt;h4 data-id=&quot;heading-13&quot;&gt;&lt;strong&gt;5.静态资源使用cdn&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;cdn的好处就是可以突破浏览器同域名下一次最大请求并发数量,从而不用&quot;排队&quot;来提高加载速度.我们都是到同一域名下浏览器最多并发请求6条(不同浏览器之间有差异),超过6条的则会等待前面的请求完成才会继续发起,如果使用cdn,一方面它采用离用户最近的资源来响应,另一方面cdn往往和应用处于不同的域下,所以可以不用等待其他域下的并发数限制,从而加速网站响应.&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247492755&amp;amp;idx=1&amp;amp;sn=d9845f6fc6719247970c9d8edfb2e999&amp;amp;chksm=fc50fd68cb27747e379c74dae587957992f10c236462e169752ecccd7e434695722a1690db2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5342592592592592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibNVrke3zbdetTT6KMnfuVic6KUQEk7OibN6KPMme1CTChQYASyuqFgdv5coalmW9BpADns9tIHw8KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-14&quot;&gt;&lt;strong&gt;6.浏览器缓存&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这一块就是本文上一节中探讨的内容,这里不做过多介绍了,我们还可以采用localStorage, indexedDB来进一步优化缓存,我们下面会详细介绍这一块的内容.&lt;/p&gt;&lt;h4 data-id=&quot;heading-15&quot;&gt;&lt;strong&gt;7.代码层面的优化&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;代码层面往往就是工程师自己对代码掌控的能力,一个优秀的工程师往往会写出代码量更少,性能更好的代码, 比如采用函数式编程来优化代码结构,使用算法来提高js代码执行效率(比如排序,搜索算法),如果想了解更多这方面的知识,可以参考笔者之前写的两篇文章:&lt;/p&gt;&lt;section&gt;所以说在写代码时,请无时无都都提醒自己, 今天的代码跑性能测试了吗?&lt;/section&gt;&lt;h4 data-id=&quot;heading-16&quot;&gt;&lt;strong&gt;8.使用web worker技术并行执行js代码,减少阻塞&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Web Worker的作用就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。&lt;/p&gt;&lt;p&gt;Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是Worker比较耗费资源，一旦使用完毕，就应该关闭。&lt;/p&gt;&lt;p&gt;知道了这些web性能优化知识,我们还要充分理解为什么要做这些优化.有过内容平台开发经验的朋友可能会知道,内容平台比较耗资源的就是媒体资源,比如图片,视频等,我们为了有更好的用户体验往往会将这些资源放到第三方服务平台存储,这样会有更好的请求性能还不用担心服务器压力,但是唯一缺点就是烧钱.每一个请求都是钱,虽然不多, 但是也抗不了百万千万的ip请求量,所以这些做的好的内容平台每年至少在这块花个几百万很正常,尤其是按请求付费.所以优化好了网站, 一方面可以带来更多的用户,更好的用户体验,也可以帮公司省流量, 进而帮老板省钱!(跪求求一个年终奖o(╥﹏╥)o).&lt;/p&gt;&lt;p&gt;接下里的内容,就教大家如何省钱.&lt;/p&gt;&lt;h3 data-id=&quot;heading-17&quot;&gt;&lt;strong&gt;3.基于localStorage的缓存方案设计以及库的封装(vuex/redux数据持久化解决方案)&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;&lt;section&gt;localStorage属性允许你访问一个Document 源（origin）的对象 Storage；存储的数据将保存在浏览器会话中。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;关于localStorage的文章也写了很多,使用方法也很简单, 这里就不做过多介绍了,但是有没有考虑自己封装一个localStorage呢? 大多数人可能会觉得很多余,因为localStorage提供的api已经够简单了,没必要封装,但是你有没有考虑过,localStorage是持久化缓存,不支持过期时间,所以有些业务场景下原生localStorage是满足不了的,所以这种情况下饿哦们需要自己实现具有过期时间的localStorage库, 关于如何实现该功能,笔者之前也写过一篇文章,有详细的介绍,并且可以让localStorage使用起来更强大,感兴趣的可以学习研究一下:&lt;/p&gt;&lt;section&gt;笔者已经将库发布到npm上了,可以通过如下方式安装使用:&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; dao &lt;span&gt;from&lt;/span&gt; @alex_xu/dao&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;或者在html标签中直接使用umd文件,github地址: &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247483764&amp;amp;idx=1&amp;amp;sn=736e1e642056fa08b70d31c15e9315a9&amp;amp;chksm=fc53188fcb249199c2a6ece5cf4483c5293d5df119d332dd76d0abf402a4e4e6110c24c6f720&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于localStorage封装的可以设置过期时间的库&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于localStorage封装的可以设置过期时间的库&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我们常用的vue里的状态管理库vuex,因为状态都是存在内存中的,那么如果要做web离线应用,或者web游戏,我们往往需要考虑持久化缓存, 那么我们也可以借助localStorage来实现状态的持久化功能,但是请记住,localStorage的存储空间在5-10M,如果有更大的需求,可以采用接下来介绍的indexedDB来实现.&lt;/p&gt;&lt;h3 data-id=&quot;heading-18&quot;&gt;&lt;strong&gt;4.基于indexedDB的缓存方案设计以及库的封装&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;IndexedDB主要用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB是一个事务型数据库系统，类似于基于SQL的RDBMS。然而，不像RDBMS使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。它允许我们存储和检索用键索引的对象；可以存储结构化克隆算法支持的任何对象。我们只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务。&lt;/p&gt;&lt;p&gt;我们刚刚接触indexedDB时往往觉得它很难懂, 我们首先需要使用open方法打开数据库,因为indexedDB大部分方法都是异步的,所以我们很难管理, 包括创建事务,创建表(一组数据的对象存储区), 添加对象存储等,这里笔者不会介绍如何使用indexedDB的具体使用方法,而是叫大家如何简化操作indexedDB的使用流程,封装成一个简单好用的缓存库.以下的封装都是基于promise,这样使用起来更优雅.以下是封装的思路:&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;610&quot; data-ratio=&quot;0.5820610687022901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlFhglNCIaZhdwHLW8gCEW0FsPrO4OSv5wEpTJFYp7ht70nT31fCoWVQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1048&quot; data-width=&quot;1048&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们工作中处理的indexedDB无非如上几个操作,所以我们需要将其从indexedDB底层API中抽离出来这几个api.具体实现如下:&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;declare global {&lt;br/&gt;  interface Window { xdb: any; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xdb = (() =&amp;gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; instance:any = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; dbName = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; DB = &lt;span&gt;function&lt;/span&gt;(args:any) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; cfg = {&lt;br/&gt;      name: args.name || &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;      version: args.version || &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;      onSuccess(e:Event) {&lt;br/&gt;        args.onSuccess &amp;amp;&amp;amp; args.onSuccess(e)&lt;br/&gt;      },&lt;br/&gt;      onUpdate(e:Event) {&lt;br/&gt;        args.onUpdate &amp;amp;&amp;amp; args.onUpdate(e)&lt;br/&gt;      },&lt;br/&gt;      onError(e:Event) {&lt;br/&gt;        args.onError &amp;amp;&amp;amp; args.onError(e)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.dbName = args.name&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.request = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.db = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 打开/创建数据库&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init = &lt;span&gt;function&lt;/span&gt;() {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;window&lt;/span&gt;.indexedDB) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;你的浏览器不支持该版本&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request = &lt;span&gt;window&lt;/span&gt;.indexedDB.open(&lt;span&gt;this&lt;/span&gt;.dbName, cfg.version)&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;        cfg.onError(event)&lt;br/&gt;      }&lt;br/&gt;      &lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;        _this.db = _this.request.result&lt;br/&gt;        cfg.onSuccess(event)&lt;br/&gt;      }&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.request.onupgradeneeded = &lt;span&gt;function&lt;/span&gt; (event:any) {&lt;br/&gt;        _this.db = event.target.result&lt;br/&gt;        cfg.onUpdate(event)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.init()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 添加表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.createTable = &lt;span&gt;function&lt;/span&gt;(name:string, opts:any = {}) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; objectStore:any&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.db.objectStoreNames.contains(name)) {&lt;br/&gt;        opts = {&lt;br/&gt;          keyPath: opts.keyPath,&lt;br/&gt;          indexs: &lt;span&gt;Array&lt;/span&gt;.isArray(opts.indexs) ? opts.indexs : []&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// indexs = [{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   indexName: &#x27;name&#x27;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   key: &#x27;name&#x27;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   unique: true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// }]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        objectStore = &lt;span&gt;this&lt;/span&gt;.db.createObjectStore(name, { keyPath: opts.keyPath })&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(opts.length) {&lt;br/&gt;          opts.indexs.forEach((item:any) =&amp;gt; {&lt;br/&gt;            objectStore.createIndex(item.indexName, item.key, { unique: item.unique })&lt;br/&gt;          })&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; objectStore&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 访问表中数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.get = &lt;span&gt;function&lt;/span&gt;(tableName:string, keyPathVal:any) {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; transaction = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName])&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; objectStore = transaction.objectStore(tableName)&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = objectStore.get(keyPathVal)&lt;br/&gt;  &lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt;(event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;事务失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;  &lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt;(event:Event) {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (request.result) {&lt;br/&gt;            &lt;span&gt;// 判断缓存是否过期&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(request.result.ex &amp;lt; &lt;span&gt;Date&lt;/span&gt;.now()) {&lt;br/&gt;              resolve({status: &lt;span&gt;200&lt;/span&gt;, data: &lt;span&gt;null&lt;/span&gt;})&lt;br/&gt;              _this.del(tableName, keyPathVal)&lt;br/&gt;            }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;              resolve({status: &lt;span&gt;200&lt;/span&gt;, data: request.result})&lt;br/&gt;            }&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            resolve({status: &lt;span&gt;200&lt;/span&gt;, data: &lt;span&gt;null&lt;/span&gt;})&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 遍历访问表中所有数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.getAll = &lt;span&gt;function&lt;/span&gt;(tableName:string) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; objectStore = &lt;span&gt;this&lt;/span&gt;.db.transaction(tableName).objectStore(tableName)&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; result:any = []&lt;br/&gt;        objectStore.openCursor().onsuccess = &lt;span&gt;function&lt;/span&gt; (event:any) {&lt;br/&gt;          &lt;span&gt;let&lt;/span&gt; cursor = event.target.result&lt;br/&gt;  &lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (cursor) {&lt;br/&gt;            result.push(cursor.value)&lt;br/&gt;            cursor.continue()&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            reslove({status: &lt;span&gt;200&lt;/span&gt;, data: result})&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        objectStore.openCursor().onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;事务失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从表中添加一条数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.add = &lt;span&gt;function&lt;/span&gt;(tableName:string, row:any, ex:number) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .add(&lt;span&gt;Object&lt;/span&gt;.assign(row, ex ? { ex: &lt;span&gt;Date&lt;/span&gt;.now() + ex } : {}))&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reslove({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据写入成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据写入失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;      &lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 更新表中的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.update = &lt;span&gt;function&lt;/span&gt;(tableName:string, row:any) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((reslove, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .put(row)&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reslove({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据更新成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据更新失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 删除某条数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.del = &lt;span&gt;function&lt;/span&gt;(tableName:string, keyPathVal:any) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .delete(keyPathVal)&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          resolve({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据删除成功&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据删除失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 清空表数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.clear = &lt;span&gt;function&lt;/span&gt;(tableName:string) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; request = &lt;span&gt;this&lt;/span&gt;.db.transaction([tableName], &lt;span&gt;&#x27;readwrite&#x27;&lt;/span&gt;)&lt;br/&gt;          .objectStore(tableName)&lt;br/&gt;          .clear()&lt;br/&gt;&lt;br/&gt;        request.onsuccess = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          resolve({status: &lt;span&gt;200&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据表已清空&#x27;&lt;/span&gt;})&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        request.onerror = &lt;span&gt;function&lt;/span&gt; (event:Event) {&lt;br/&gt;          reject({status: &lt;span&gt;500&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据表清空失败&#x27;&lt;/span&gt;, err: event})&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    loadDB(args:any) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(instance === &lt;span&gt;undefined&lt;/span&gt; || dbName !== args.name) {&lt;br/&gt;        instance = &lt;span&gt;new&lt;/span&gt; (DB &lt;span&gt;as&lt;/span&gt; any)(args)&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; instance&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;})()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;window&lt;/span&gt;.xdb = xdb&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; xdb&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;这样就实现了一个基于promise的且支持过期时间的indexedDB库,实现过期时间也非常简单,就是在创建表的行时在底层添加一个过期时间字段,用户需要设置改行过期时间时, 只需要添加过期时间即可,当我们再次获取表格数据时只需要检测改行是否过期,如果过期就清除重新设置即可.&lt;/p&gt;&lt;h3 data-id=&quot;heading-19&quot;&gt;&lt;strong&gt;5.结合http请求库(axios/umi-request)进行更细粒度的缓存代理层设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;为了更大程度的发挥indexedDB存储空间的优势,并且进一步优化缓存策略,我们来可以做缓存拦截.我们都知道,一个应用的有些请求不需要频繁获取,比如省市级联数据, 区位地图数据,或者一些不需要经常更新的数据, 如果我们可以做到只请求一次, 下次请求直接使用内存数据,并设置一个过期时间, 到过期时间之后会重新请求数据, 那么是不是对请求又可以做一次优化?我们第一印象可能会写出这样的代码:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(!store.get(&lt;span&gt;&#x27;xx&#x27;&lt;/span&gt;)){&lt;br/&gt;   http.get(&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;).then(res =&amp;gt; {&lt;br/&gt;    res &amp;amp;&amp;amp; store.set(&lt;span&gt;&#x27;xx&#x27;&lt;/span&gt;, res, &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;  })&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;这样虽然可以实现功能,但是每一个业务都要写类似的代码, 往往很难受, 所以作为一个有追求的程序员,我们可以在请求上下功夫.我们都有过axios或者fetch库的使用经验,我们也接触过请求/响应拦截器的使用, 那么我们能不能考虑对请求本身也做一层拦截呢?我想实现的效果是我们在业务里还是正常的像之前一样使用请求,比如:&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;req.get(&lt;span&gt;&#x27;/getName?type=xxx&#x27;&lt;/span&gt;).then(res)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;然而内部已经帮我们做好请求缓存了,我们的req实际上不是axios或者fetch的实例,而是一层代理.&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1280&quot; data-ratio=&quot;1.16875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/dFTfMt0114ibOKteqIF9YgCvq0sOFJdYlib9a6lsCpfjhjEkaqMuSvneqH0lBe9JWMFxbGas3oTA6MURKodnB4sw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;960&quot; data-width=&quot;1094&quot;/&gt;&lt;/section&gt;&lt;p&gt;通过这种方式我们对原来的请求方式可以不做任何改变, 完全采用代理机制在请求拦截器中和响应拦截器中布局我们的代理即可,关键点就是存到数据库中的内容要和服务器响应的内容结构一致.&lt;/p&gt;&lt;p&gt;以上方式我们可以对所有的get请求做缓存,如果我们只想对部分请求做缓存,其实利用以上机制实现也很简单,我们只需要设置缓存白名单, 在请求拦截器中判断如果在白名单内才走缓存逻辑即可.&lt;/p&gt;&lt;p&gt;这样,我们再次进行某项数据的搜索时,可以不走任何http请求,直接从indexedDB中获取,这样可以为公司节省大量的流量.&lt;/p&gt;&lt;p&gt;关于indexedDB的库的封装,我也发布到npm和github上了,大家可以直接使用或者进行二次开发.&lt;/p&gt;&lt;h2 data-id=&quot;heading-20&quot;&gt;最后&lt;/h2&gt;&lt;section&gt;如果想学习更多&lt;span&gt;H5游戏&lt;/span&gt;, &lt;span&gt;webpack&lt;/span&gt;，&lt;span&gt;node&lt;/span&gt;，&lt;span&gt;gulp&lt;/span&gt;，&lt;span&gt;css3&lt;/span&gt;，&lt;span&gt;javascript&lt;/span&gt;，&lt;span&gt;nodeJS&lt;/span&gt;，&lt;span&gt;canvas数据可视化&lt;/span&gt;等前端知识和实战，欢迎在公号《趣谈前端》加入我们的技术群一起学习讨论，共同探索前端的边界.&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金签约作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bece664f344551f749ad9e82ac2562e5</guid>
<title>开源｜用Rust编写的，闪电般快速且功能强大的代码编辑器</title>
<link>https://toutiao.io/k/3jfuqw9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;用Rust编写的，闪电般快速且功能强大的代码编辑器。它的UI使用Druid，使用Xi编辑器的Rope Science技术进行文本编辑，并使用Wgpu进行渲染。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1407&quot; data-ratio=&quot;2.026666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicfPd8Edwf3ZGdEfC3lV26bhaeGxutrTmdGpfZEbA5WU9o1yibBRhAFn7fFb8VwlSGdiatxp8CoMOGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a1a0d059ea4017e65c1ae1c34c7b451</guid>
<title>京东到家购物车日志优化实践</title>
<link>https://toutiao.io/k/bpv0bbr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;一. 降低资源使用&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    1.1 降低磁盘使用率&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    1.2 异步日志&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    1.3 降低cpu使用率&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二. 日志链路追踪&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2.1 ThreadLocal技术选型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2.2 TTL线程池改造&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2.3 Log4j2 MDC + TTL线程池实现 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2.4 链路日志使用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三. 测试指标及建议&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.1 建议&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.2 测试指标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.3 Log4j2各项参数测试结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着京东到家的业务发展，作为黄金链路之一的购物车系统访问量也越来越大，打印日志的场景也越来越多，系统方面面临以下急需解决的问题：&lt;/p&gt;&lt;p&gt;1.日志输出过多，磁盘压力大，排查问题要过滤大量日志&lt;/p&gt;&lt;p&gt;2.日志导致cpu负载过高，甚至会打满，影响服务的性能和吞吐量&lt;/p&gt;&lt;p&gt;3.无法快速精准的定位出某个请求链路的所有日志，定位问题比较困难&lt;/p&gt;&lt;p&gt;经过购物车线上真实流量和系统压测验证，我们在减少磁盘使用率，降低cpu负载等方面进行了优化,在接口性能和吞吐量等方面得到了很大程度的提升。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;一. 降低资源使用&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1.1 降低磁盘使用率&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;下图是购物车网关INFO级别的磁盘使用率（服务器配置4c8g磁盘50G）, 以每小时20G的写入速度记录程序的运行过程&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;160&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2773279352226721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJXTqgU3GmUFiaz6qKaTK7uGhY8y1Dv1QevmXTiahMlWmdAdWpLTZSvsIY2gJMDXjKWYLXZSXdJtdYSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;通过日志分级输出，控制日志打印级别，现在磁盘全天的使用率保持在10G左右&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2773279352226721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJXTqgU3GmUFiaz6qKaTK7uGhIkvGkN8Ku5meUINE3KsUwms4QOofkkWvyDE514ZazbdbDNEeMpOMpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1.1 Log4j2日志分级&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;日志打印需要可读性强且易于解析 ,写作的三要素是时间+地点+人物，打印日志的三要素则是时间+位置+事件。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;时间:业务执行的时间；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;位置:某个方法，某项业务;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;事件:入参、出参、异常堆栈等；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;301&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHiaQRfdSM32AdoJfnNpnIibyCcZcaicKBbtq7YpdJbsZOlzzzndCAX1YuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;以下是购物车在不同场景使用的日志级别：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;开发和联调阶段使用INFO级别，用来打印接口入参、出参、耗时和程序的运行过程，方便定位和排查问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;线上使用WARN级别，用来感知服务降级、业务异常、参数异常、限流等场景&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在压测或大促期间我们会使用ERROR级别记录运行时异常情况&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;日志分级的目的是尽量减少日志打印对服务性能和磁盘压力的影响。&lt;/p&gt;&lt;p&gt;   在一些极端场景下，线上需要详细日志的输出来定位问题，我们通过动态的调整日志级别来实现，调整日志级别代码如下:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;182&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31533477321814257&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJXTqgU3GmUFiaz6qKaTK7uGh0A0nb9MHZueCp9O8xNthwRC345AXTIXw2bEkBxZZf3icrLCen0JF9AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1.2 异步日志&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;购物车网关通过改造日志配置,将同步输出日志，改成AsyncLogger异步输出，我们看一下同步日志和异步日志的性能对比&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;200&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJH2oJzYUYlEUf1ibCSRuX6OJgw7nhGREYUI6yib3JwQJUZdf4nuxB7Nj0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;166&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHUjlEGmtiamJ2Zgc73vuAZEt7g2gWHpGaQozWtL7o5kasza5qgRriblzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过分析上面两张图，我们可以得出如下结论:&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;1.2.1 异步日志-AsyncLogger简介&lt;/strong&gt;&lt;strong/&gt;&lt;/h3&gt;&lt;p&gt;  AsyncLogger是Log4j2 官方推荐的异步方式。有全局异步和混合异步两种模式:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;AsyncLogger底层采用Disruptor，通过环形无阻塞队列作为缓冲，多生产者多线程的竞争是通过CAS（compare and swap）无锁化实现，可以极大的提高日志输出效率。&lt;/p&gt;&lt;p&gt;  在加载log4j2.xml启动阶段，如果检测到配置了AsyncRoot或AsyncLogger，将启动一个disruptor实例。即使log4j2.xml中配置了多AsyncLogger，也仅有一个EventProcessor线程进行日志的异步处理。&lt;/p&gt;&lt;p&gt;1) Disruptor有一个基于数组的循环数据结构(环状缓冲区)。这种结构拥有多个可用元素引用的数组。预先分配了对象内存空间。生产者与消费者通过循环数据结构进行读写操作，不会有锁或资源竞争。&lt;/p&gt;&lt;p&gt;2) 在Disruptor中，采用消费者-生产者模型进行读写的分离，所有事件(events)以组播的方式被发布给所有消费者，以便下游队列通过并行的方式进行消费。因为消费者是并行消费，所以需要协调消费者间的依赖关系。&lt;/p&gt;&lt;p&gt; 3) 生产者和消费者中有个序列计数器，指示缓冲区中当前正在被它所处理的元素。所有生产者或消费者只可以修改自己的序列计数器，但可以读取其他的序列计数器，通过内存屏障加序列号的方式实现了无锁的并发机制。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;169&quot; data-backw=&quot;468&quot; data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJH04wjc7OpAMy84Ie03AdNVEsxgUFfg4RcIpgiaamupnr51jssiaicJiaUAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;468&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;1.2.2 &lt;/strong&gt;&lt;span&gt;购物车AsyncLogger混合异步配置&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;342&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.59140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHC3t0HJZjhluZsCza26eAprj5eG77wkufBA7PEsWk9To7pxblSd1XCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;详细配置参考:https://blog.csdn.net/jek123456/article/details/100123570&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;1.2.3 &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;异步日志注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;h3&gt;&lt;span&gt;不要开启全局异步的情况下，使用AsyncAppender和AsyncLogger，虽然不会报错，但是对于性能提升没有任何好处。&lt;/span&gt;&lt;/h3&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;&lt;span&gt;不管是同步异步，都设置immediateFlush为false(为true时立即输出，不会缓冲)，这会对性能提升有很大帮助，设置为false会提升5倍吞吐量左右，可以根据BufferSize值调整缓冲池大小，默认8Kb，如果程序意外退出，缓冲区内的日志不会输出 ，这种情况可以使用JVM关闭的回调功能，捕获关闭事件，然后调用LogManager.shutdown()输出缓冲区中的日志。&lt;/span&gt;&lt;/h3&gt;&lt;h3/&gt;&lt;/li&gt;&lt;li&gt;&lt;h3&gt;&lt;span&gt;同步模式下不获取位置信息要比获取位置信息性能提升1-5倍，异步模式则会提升30-100倍&lt;/span&gt;&lt;/h3&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3/&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;1.2.4 &lt;span&gt;日志的输出过程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;201&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.34765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHkmNN2VCtfR0Kibxic2ibsJicVRvheSlmULgN4lWej35mibrkAGOu249ibzaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;①.首先使用全局Filter对日志事件进行过滤。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Log4j2中的日志Level分为8个级别，按照从低到高为：ALL &amp;lt; TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL &amp;lt; OFF。&lt;/p&gt;&lt;p&gt;全局Filter的Level为ALL，表示允许输出所有级别的日志。logger.info()请求输出INFO级别的日志，通过。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;53&quot; data-backw=&quot;473&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11205073995771671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJH1nqjtNWsicicccax75u64N42xJeFjjWT1HNcse2gjGXeMcUGhib9ut4Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;②.使用Logger的Level对日志事件进行过滤。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Logger的Level为TRACE，表示允许输出TRACE级别及以上级别的日志。logger.info()请求输出INFO级别的日志，通过。&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;70&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.12169312169312169&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHdvzZUglNNnBz4AmicpldPTxvvUUIRnd5AHABtStTbqaEibgQrBUHJTQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;③.生成日志输出内容Message。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  使用占位符的方式输出日志，输出语句为logger.info()(&quot;increase {} from {} to {}&quot;, arg1, arg2,arg3)的形式，最终输出时{}占位符处的内容将用arg1,arg2,arg3的字符串填充。为后续日志格式化输出做准备。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;④.生成LogEvent。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  LogEvent中含有loggerName(日志的输出者)，level(日志级别)，timeMillis(日志输出时间)，message(日志输出内容)，threadName(线程名称)等信息。&lt;/p&gt;&lt;p&gt;  在上述程序中，生成的LogEvent的属性值为loggerName=com.jddj.Main，Level=INFO，timeMillis=1505659461759，message为步骤3中创建的Message，threadNama=main。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑤.使用Logger配置的Filter对日志事件进行过滤。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  Logger配置的Filter的Level为DEBUG，表示允许输出DEBUG及以上级别的日志。logger.info()请求输出INFO级别的日志，通过。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;85&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.14655172413793102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHqvF2JziaTq9gRrPQkWESIot8M51gYwJZZz65eTfJibsFHqUJYibV7GfOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑥.使用Logger对应的Appender配置的Filter对日志事件进行过滤。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  Appender的Filter配置的Level为INFO级别日志onMatch=ACCEPT，表示允许输出INFO级别的日志。logger.info()请求输出INFO级别的日志，通过。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2517799352750809&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJH5fEovA6d4nzsOSP6u0LZvl2JX3vRiapkHZwolvbRfJc2jEU8crWFEFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1545&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑦.判断是否需要触发rollover。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   &lt;span&gt;此步骤不是日志输出的必须步骤，如配置的Appender无需进行rollover，则无此步骤。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  因为使用RollingFileAppender，并且配置了基于文件大小的rollover触发策略，在此阶段会判断是否需要触发rollover。判断当前的文件大小是否达到了指定size，如果达到了，触发rollover操作(如果日志打印过多，则会频繁触发文件滚动机制，从而影响输出性能)。可参考Log4j2中RollingFile的文件滚动更新机制:https://www.cnblogs.com/yeyang/p/7944899.html&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2531900604432505&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHbByiaicmG2PMqADOxQk11yQHRQsqqZzVW24SoPQibr68SkZDNQtmnQWkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1489&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑧.PatternLayout对LogEvent进行格式化，生成可输出的字符串。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;PatternLayout将根据Pattern的模式，利用各种Converter对LogEvent的相关信息进行转换，最终拼接成可输出的日志字符串。如:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DatePatternConverter对LogEvent的日志输出时间进行格式化转换；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LevelPatternConverter对LogEvent的日志级别信息进行格式化转换；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LoggerPatternConverter对LogEvent的Logger的名字进行格式化转换；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MessagePatternConverter对LogEvent的日志输出内容进行格式化转换等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;经各种Converter转换后，LogEvent的信息被格式化为指定格式的&lt;/span&gt;字符串。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑨.使用OutputStream，将日志输出到文件。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  将日志字符串序列化为字节数组，使用字节流OutoutStream将日志输出到文件中。如果配置了immediateFlush为true，打开app.log就可观察到输出的日志了。&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;1.3 降低CPU使用率 &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;下图购物车网关单机3k/min的请求量下，打印行号和不打印行号cpu使用率对比&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9173333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHic1c2m2CTdhicI26TchrQblgF9DKLzicvEJ27NEic5jDRtZDN7cKsibPkFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;通过对比我们发现如果日志打印量少的情况下，cpu使用率差距不大，但是当达到每小时写入20G的时候，打印位置信息比不打印位置信息使用率差3倍左右，购物车系统通过以下两点解决cpu升高问题 ：&lt;/p&gt;&lt;p&gt;①.日志分级，降低日志的输出量&lt;/p&gt;&lt;p&gt;②.优化PatternLayout配置(不打印位置信息)&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.07527801539777587&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHZpr376usEA5R3vJft66BvSUHic1LAemx8CVudzmc6QCyWzVw3XjAvNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1169&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;打印位置信息会导致的cpu使用率升高，下面是Log4j2官方针对打印位置信息性能的压测数据:&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6877192982456141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHVvQXckONzm8gEgM4OTmOtcpaS2MyOX0AY2EAydr7YP38O4FiaNVAyzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;  以下参数配置会使性能急剧下降 : %C or $class, %F or %file, %l or %location, %L or %line, %M or %method, 大概下降30-100倍左右（includeLocation 参数配置决定了是否抛出异常，以上参数配置决定了是否遍历堆栈）  &lt;/p&gt;&lt;p&gt;   这是因为Log4j需要在运行时获取堆栈的快照（snapshot）,并遍历堆栈跟踪以查找位置信息,无论是在Java 9之前通过Thorwable.getStackTrace()，还是通过 Java 9 之后的 StackWalker，获取当前代码堆栈，都是一个非常消耗 CPU 性能的操作。在大量输出日志的时候，会成为严重的性能瓶颈，其原因是：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;获取堆栈属于从 Java 代码运行，切换到 JVM 代码运行，是 JNI （Java Native Interface）调用。这个切换是有性能损耗的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Java 9 之前通过新建异常获取堆栈，Java 9 之后通过 Stackwalker 获取。这两种方式，截止目前 Java 17 版本，都在高并发情况下，有严重的性能问题，会吃掉大量 CPU。（底层 JVM 符号与常量池优化的问题）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;从源码看，获取位置信息需要遍历异常+反射+字符串截取+悲观锁，这些都是非常消耗性能的&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Log4j PatternLayout 符号定义 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;275&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4749582637729549&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHNe1zwICC3LMyBphJaoJ6I8cysCrrhEU5WcofHqDhs8XcProlX4ajpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1198&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;红色标注的参数不建议配置，这些参数配置后非常影响性能&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二. 日志链路追踪&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt; 生产环境排查问题往往都是通过日志，但对于巨大的日志量，如何实现针对某一个操作进行整个日志链路的追踪就显得尤为重要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;  Log4j2提供的日志追踪方案是NDC和MDC，但仅限于当前线程内的数据传递（其底层原理是维护一个ThreadLocalMap）,如果是父子线程之间的调用，就无法完成完整的链路追踪工作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;  购物车使用 TTL(TransmittableThreadLocal) + 线程池 + Log4j2 来解决这个问题&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.1 ThreadLocal技术选型&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;     优点:解决了当前线程的值传递               &lt;/p&gt;&lt;p&gt;     缺点:不支持子线程&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;InheritableThreadLocals：其设计的初衷是为了增强ThreadLocal类型，使其具备变量可以被子线程继承的特性，具体表现为当前线程创建子线程的时候，会把ThreadLocal快照拷贝一份到子线程的ThreadLocal中，但是对于使用复用线程的执行组件时,ITL的值传递已经不起作用。&lt;/p&gt;&lt;p&gt;优点:支持新建子线程的值传递                &lt;/p&gt;&lt;p&gt;缺点:不支持线程池&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TransmittableThreadLocal: 为了进一步增强InheritableThreadLocals，使其能够在提交任务到线程池的时候拷贝“任务提交者（通常为主线程）”的线程变量，因此会在当前线程创建任务的时候初始化，即构造Runnable接口的对象时初始化。（因继承ITL,会有ITL特性,当线程池新建线程执行任务时，即使不改造线程池仍然会有主线程快照，但是会存在脏数据）&lt;/p&gt;&lt;p&gt;优点:支持子线程、线程池的值传递       &lt;/p&gt;&lt;p&gt;缺点:需要改造线程池代码&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.2 TTL线程池改造&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;480&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8310502283105022&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHU9vGicnCVmQs5ukqccJQ9icr0xMrxHDvp6ibXfgBNqRuGbOJrXib9rKWicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1095&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.3 Log4j2 MDC + TTL线程池实现&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;  MDC和NDC是Log4j用于存储应用程序的上下文信息,其底层原理是维护一个ThreadLocalMap (ThreadLocal),当使用线程池时，无法获取主线程的值，所以我们利用TTL思想在线程池执行任务之前，copy一份主线程上下文信息快照，并且在执行完线程之后，恢复执行线程备份的变量，解决Log4j2在线程池值传递的问题&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;356&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6161971830985915&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHcnyM0Z41mYmjPwjQ0S8O0bND89rBUTmANMIOUzFAJjqrUotvc8L1QA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;ParallelCallableTask重写Callable任务，所以需要线程池执行Callable任务，改为执行ParallelCallableTask任务&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3475314617618587&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHDzfHXhCla3y6jDZRWOeaIROPw7kTmQoorYa8miawGS1YTDib6kPg4usA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1033&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.4 链路日志使用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;针对用户每次请求的traceId分析产生问题的具体原因，通过链路日志的改造，traceId贯穿整个业务流程&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5778186274509803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHbzWrLO4naurxnsuWsWnLwN35ZjZZx5iaLM3EfhjrjgThBI6MK0Nz7mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;三. 测试指标及建议&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.1 建议&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;1. 合理的记录程序运行时的各项参数，可以快速帮我们定位问题原因&lt;/p&gt;&lt;p&gt;2.日志分级输出，合理调整日志的输出级别，可以减少cpu和磁盘压力&lt;/p&gt;&lt;p&gt;3.调整日志格式，正确清晰的输出日志，可以减少线上风险，规避性能隐患&lt;/p&gt;&lt;p&gt;4.Log4j+监控组合使用可以让开发更容易发现问题，解决问题   &lt;/p&gt;&lt;p&gt;5.如果对日志性能要求高，可以使用异步日志，如果打印过多，要考虑日志分级&lt;/p&gt;&lt;p&gt;6.改造线程池可以减少系统链路关键字的维护，不需要无限制的透传下去&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.2 测试指标 &lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;购物车网关cpu使用率压测结果(服务器配置cpu:4c 内存8g 磁盘50G)&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;331&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5721247563352827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHOcG9rNuLzGVtiaWcO579A29XzHIG7ShmLSb0ibiboyZIaPxRKfcgibHQKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.3 &lt;span&gt;Log4j2各项参数测试结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;（服务器配置 4c8g磁盘50G 12并发tp99）&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;276&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4777227722772277&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJV3cqJnxMy0rYcDC50ibsjJHnU3394sJ47VzAHbecmM9XYNa8kIe8TuFo8h1WwhPFYEZbHfB7deOLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;580&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0040322580645162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJXTqgU3GmUFiaz6qKaTK7uGhyibia8TbF8wCBMuibz4Myuf1vo3zOBHTaIxEPx6caFA9XfD9jqC34iboCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;744&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e88df1a2e9c9fbf3667d1d93acb22ac4</guid>
<title>简单软件架构的一些好处</title>
<link>https://toutiao.io/k/8t641lz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfOv5b5DHk7KxkuBIyL2lIJ0ibbTG39Ayd4IUJKQUSgqINcf4EnibBHjoMBHsHfpicAKLic1DvyKIWqgBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/section&gt;&lt;section&gt;作者 | Dan Luu&lt;/section&gt;&lt;section&gt;
译者 | Sambodhi&lt;/section&gt;&lt;section&gt;
策划 | Tina&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;本文最初发表于 Wave 官网，经原作者 Dan Luu 授权，InfoQ 中文站翻译并分享。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Wave 是一家价值 17 亿美元的公司，拥有 70 名工程师，该公司的产品是一款加减数字的 CRUD 应用程序。为了与此保持一致，我们的架构是一种标准的 CRUD 应用架构，基于 Postgres 的 Python 单体架构。先从一个简单的架构入手，然后尽量用最简单的方式来解决问题，这使得我们的业务范围能够扩大到这种规模，而工程师们大多专注于为用户提供价值的工作。&lt;/p&gt;&lt;p&gt;Stackoverflow 扩大了单体的规模，取得了良好的效果（2013 年的架构 /2016 年的架构），最后以 18 亿美元的价格被收购。如果我们关注的是流量而非市场市值，那么 Stackoverflow 就是互联网上流量最高的前 100 个网站之一（关于其他许多建立在单体之上的有价值的公司的案例，请参考这条 Twitter 主题的回复。我们没有很多网络流量，因为我们是一个移动应用，但 Alexa 还是将我们的网站列在了前 75000 名，尽管我们的网站基本上只是人们查找 APP 的一种途径，而大部分人并没有从我们的网站中获得这些 APP）。&lt;/p&gt;&lt;p&gt;有些应用的要求，使得在一个枯燥的数据库中构建出一个简单的单体应用是不可能的，但对大部分应用来说，即便是在前 100 个网站的流量水平上，计算机的运行速度也足以满足使用简单的架构来提供服务，通常创建简单的架构比复杂的架构更便宜、更容易。&lt;/p&gt;&lt;p&gt;尽管简单的架构具有不合理的有效性，但是大部分的新闻报道都是围绕着复杂的架构展开的。举例来说，在最新的通用技术会议上，就有六场演讲讨论了怎样构建或处理基于微服务的复杂结构的负面影响，却没有一场演讲讨论如何构建简单的单体。甚至关于量子计算的演讲也有一场。更大规模的会议也一样；最近旧金山的一次以企业为导向的会议上，关于处理复杂架构的演讲，场次就高达两位数；却没有一场关于如何构建简单的单体的演讲。我上次去的那次会议给我留下了很深的印象，就是许多公司的员工，他们的应用程序规模很小，本来可以用简单的架构就能完成，但是他们使用的都是会议圈子和网络上流行的最新、最复杂的技术。&lt;/p&gt;&lt;p&gt;我们的架构是如此简单，以至于我都懒得去做一个架构图。我会讨论我们所做的使一切乏味的事。&lt;/p&gt;&lt;p&gt;我们目前使用的是乏味的、同步的 Python，这意味着，当我们的服务器进程在等待 I/O 时被阻塞，比如网络请求。我们之前尝试过 Eventlet，这是一种理论上能使我们从 Python 中获得更高效率的异步框架，但是我们碰到了大量的 Bug，我们觉得，等待事件的 CPU 和延迟成本，都不值得我们为处理 Eventlent 问题而承担操作上的痛苦。其他知名的 Python 框架也有类似的情况，但是大规模使用它们的用户往往也会报告大规模使用这些框架带来的严重后果。使用同步的 Python 代价很高，因为我们需要支付 CPU 的费用，而在网络请求期间，CPU 除了等待之外什么都不做，但是，现在，我们每个月只能处理几十亿个请求，因此，即便是使用 Python 这种缓慢的语言，也要支付公共云的零售费用，这样的成本也很低。我们工程团队的成本完全决定了我们所运营的系统的成本。&lt;/p&gt;&lt;p&gt;我们将长时间运行的任务（我们不想让响应阻塞）分配到一个队列中，而不是承担使我们的单体异步的复杂性。&lt;/p&gt;&lt;p&gt;我们不能像我们想的那样无聊的地方，就是我们的内部数据中心。当我们只在塞内加尔和科特迪瓦运营时，我们完全是在云端中运营，但是，随着我们的业务范围扩大到乌干达（以及未来更多的国家 / 地区），我们不得不拆分后端，部署到当地的内部数据中心，以遵守当地的数据存储法律和法规。这并非一项简单的操作，但正如那些在面向服务的复杂架构中做过相同工作的人所知道的那样，这种操作要比使用复杂的服务导向的架构要简单得多。&lt;/p&gt;&lt;p&gt;另外一个方面是我们必须研发的软件，而非购买。刚起步时，我们强烈地倾向于购买软件，而非研发软件，因为一个由少数工程师组成的团队无法承担研发软件的时间成本。虽然“购买”这一选项，通常会给你提供一些无效的工具，但这在那个时候是正确的选择。如果我们不能说服供应商修复 Showstopper 错误，而这个错误对我们至关重要，那么在这种情况下，构建更多的自己的工具，并且在更多的方面保留内部的专业知识，这的确是很有意义的，但这与公司应只选择“构建”其核心能力的标准建议相悖。这种复杂性的大部分都是我们不愿意承担的，但是对于某些类别的产品，即便是进行了相当广泛的研究，我们仍然找不到供应商能够提供适合我们的产品。公平地说，我们的供应商需要解决的问题比我们需要解决的问题复杂得多，因为我们的供应商承担着为每个客户解决问题的复杂性，而我们只需要为一个客户解决问题，那就是我们自己。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;61&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;译注：Showtopper 错误是导致执行停止并基本上变得无用的硬件或软件错误。必须修复此严重错误，以使开发过程进一步进行。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;我们在运营的头几个月里，就犯了一个错误，就是没有仔细地界定数据库事务的边界，这在今天已经付出了一定的代价。在 Wave 的代码库中，SQLAlchemy 数据库会话是一个请求全局变量；在任何时候访问 DB 对象的属性时，它都隐含地开始一个新的数据库事务，并且 Wave 代码库中的任何函数都可以在会话上调用 commit，使其提交所有挂起、的更新。这使得我们很难控制数据库更新发生的时间，从而增加了出现微妙的数据完整性错误的概率，并且很难依靠数据库来构建类似于幂等键（idempotency key）或事务性暂存的作业流失。这样做还会增加我们意外地持有打开的长时间运行的数据库事务的风险，这可能使模式迁移操作变得困难。&lt;/p&gt;&lt;p&gt;一些我们不确定的选择（因为我们在考虑更改，或建议其他从零起步的团队考虑另一种方式）有：使用 RabbitMQ（就我们的目的而言，Redis 可能同样适用于任务队列，只需要 Redis 就可以减轻操作负担）；使用 Celery（这对于我们的用例来说过于复杂，并且已经出现了好几次故障，比如在版本升级过程中出现了向后兼容性问题）；使用 SQLAlchemy（它使开发人员难以理解自己的代码将会产生怎样的数据库查询，从而导致各种难以调试的情况，同时也带来了不必要的操作痛苦，尤其是与上面提到的数据库事务边界的观点有关）；以及使用 Python（由于我们的创始 CTO 的技术背景，这是最初的正确选择，但其并发支持、性能和广泛的动态性使我们质疑它是否是大规模后端代码库的正确选择）。以上所有这些都不是主要的错误，而且对于一些（例如 Python) 来说，缺陷已经很少了，因此，与投资到理论上更好的迁移相比，我们将花费更少的费用去进行更多的维护，但如果我们现在就从头编写一套类似的代码库，那么我们就会认真考虑，它们是否正确的选择。&lt;/p&gt;&lt;p&gt;在某些方面，我们很满意能做出这样的选择，虽然这些听上去并不像是最简单可行的解决方案，比如我们的 API，我们使用 GraphQL；我们的传输协议，我们有一段时间使用自定义协议；还有我们的主机管理，我们使用 Kubernetes。对于我们的传输协议，我们曾经使用了一种基于 UDP 的自定义协议，并带有 SMS 和 USSD 后备功能，这也是这场讲座所提到的性能理由。在 HTTP/3 发布后，我们已经能够用 HTTP/3 来替代我们的自定义协议，通常我们只需要 USSD 就可以解决像最近在马里发生的互联网关闭这样的事件）。&lt;/p&gt;&lt;p&gt;对于 GraphQL 的使用，我们相信其优点多于缺点：&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;精确返回类型的自文档化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;精确返回类型的代码生成使得客户端更加安全；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GraphiQL 交互式探索器是生产力的一个胜利；我们的各种应用（用户应用、支持应用、Wave agent 应用等）大多可以共享一个 API，从而减少复杂性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可组合的查询语言允许客户端在一次数据包往返中准确获取它们需要的数据，而无需建立大量的特殊用途的端点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免了对什么算作 RESTful API 的无意义争论。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当我们采用 GraphQL 时，GraphQL 库并不是很好（基本的 Python 库是从 JavaScript 库中移植过来的，因此不是 Python 化的，Graphene 需要大量的模板，Apollo-Android 生成的优化代码非常烂）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认的 GQL 编码是冗余的，而且由于很多客户端的带宽较低，所以我们非常关心限制大小。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于 Kubernetes，我们之所以选择 Kubernetes，是因为我们清楚，如果业务成功（确实如此），而且我们不断扩张，我们最终会扩张到那些要求我们在该国内运营服务的国家。各国之间的具体规定各不相同，但是我们在非洲的主要市场上拓展了业务，这就要求我们在该国运营我们的 “主要数据中心”，还有其他一些规定，例如，要求我们能够将故障转移到该国的数据中心。&lt;/p&gt;&lt;p&gt;电信集成是我们无法回避的复杂性的一个方面。从理论上讲，我们将使用 SaaS SMS 提供商来完成这一切，但是，非洲各大 SaaS SMS 提供商的业务并没有遍及整个非洲，因此在那里使用这些服务的费用都让人望而却步。如果我们利用 SaaS SMS 提供商来解决我们所有的短信需求，那么以前的那些说工程师的薪酬成本如何主导我们系统成本的说法是站不住脚的；提供电信集成服务的团队为此付出了数倍的代价。&lt;/p&gt;&lt;p&gt;通过将应用架构尽量简化，我们就可以将复杂性（以及人力）预算用于有利于业务发展的领域。如果没有足够的理由去提高复杂性，那么我们就可以基于尽可能简单地做事的这一想法，用少量的工程师，创建一个规模不小的业务，虽然我们所经营的非洲金融业务通常被视为难以涉足的业务，我们会在以后的文章中谈到（我们的早期和最有帮助的咨询顾问之一，他给我们提出的建议，对于 Wave 的成功非常关键，起初提出 Wave 是一个糟糕的商业点子，而创始人应该选择另一个，因为他预见到了许多潜在的困难）。&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.wave.com/en/blog/simple-architecture/index.html&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
今日文章推荐：&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247521178&amp;amp;idx=1&amp;amp;sn=fb2a3b7f8e4e6bfdfe999c97ee58138d&amp;amp;chksm=e8d46c58dfa3e54ebb62ed628eb3d95c1f04c0e6149c448df8e4470b091d54108949e107afce&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;四个最佳后端框架推荐&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;四个最佳后端框架推荐&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247521117&amp;amp;idx=1&amp;amp;sn=ddc02b95eacd1eb2e46d09e49ec88c16&amp;amp;chksm=e8d46c9fdfa3e589692c59d849de7c87e6361b2170389be68922b14ba0219421c8d72bff9d03&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;OVHcloud 毁灭级火灾报告：消防隐患能否为百万网站数据“买单”？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;OVHcloud 毁灭级火灾报告：消防隐患能否为百万网站数据“买单”？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247521085&amp;amp;idx=1&amp;amp;sn=380932d88b7ba09c939f3c8823f5753f&amp;amp;chksm=e8d46cffdfa3e5e9cca94d8232e645701a350e86c68d048aec6155550ca41a4d81d9623dfda0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;架构师韩超：没有技术团队，如何进行数字化转型&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;架构师韩超：没有技术团队，如何进行数字化转型&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247521066&amp;amp;idx=1&amp;amp;sn=5632a7f6744aaaa24bc88f1f443451fa&amp;amp;chksm=e8d46ce8dfa3e5fe5df530d5427dd50a6bd1d9fe471adbc30fcabe61c6ddce3f2c739762a937&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;复制粘贴代码，很可能会带来灾难性的后果&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;复制粘贴代码，很可能会带来灾难性的后果&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247521005&amp;amp;idx=1&amp;amp;sn=caf870d2fca9f1e11e777bd25b6bff5a&amp;amp;chksm=e8d46d2fdfa3e43911c18942d2684e8f37774d69168830f4587eae5d382ad53d7de635cf88c4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;F5“拉黑”俄罗斯，禁止其为 Nginx 开源项目作贡献&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;F5“拉黑”俄罗斯，禁止其为 Nginx 开源项目作贡献&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>