<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9f63894fa6503a1867f5a0702807f90c</guid>
<title>为什么你需要关注软件架构？</title>
<link>https://toutiao.io/k/g9j0b7r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt; | &lt;span&gt;Pierre Pureur, Kurt Bittner&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;
译者 | 明知山&lt;/section&gt;&lt;section&gt;策划 | 丁晓昀&lt;/section&gt;&lt;section&gt;
软件开发团队一直反对“前期大设计”，而倾向于自组织团队中出现的架构设计，这可能导致低估软件架构重要性的心态。更多地意识到架构当中存在的隐式决策，并迫使这些决策变成显式的，有助于开发团队做出更好、更明智的决策。&lt;/section&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 关键要点&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件开发人员通常不信任架构实践，倾向于避开有意识的架构活动，并选择在自组织团队中出现的架构设计；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为解决紧急架构的局限性和满足最初的质量属性需求，进行有意识的架构设计是有必要的；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;软件架构是由质量属性需求 (Quality Attribute Requirements，QAR) 驱动的，如果在最初的迭代中没有考虑到它们，通常会在软件系统被部署到初始试验阶段之后（只有少量的用户）出现问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更多地意识到架构当中存在的隐式决策，并迫使这些决策变成显式的，这有助于开发团队利用他们从 Sprint 和迭代中获得的经验数据做出更好、更明智的决策；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重构和过度的组件化会导致解决方案的碎片化，以至于没有人能完全理解发生了什么；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;现代架构实践，如持续架构和演进架构，提供了可以帮助做出显式架构决策的工具，让开发人员能够交付更可持续的软件产品。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;许多软件开发人员不信任架构实践，他们将这些实践与严格和专横的过程以及重要的前期规划和设计联系在一起。&lt;/p&gt;&lt;p&gt;因此，他们相信，如果他们遵循这些实践，可能需要很长时间才能交付一些甚至可能不是客户想要的东西。&lt;/p&gt;&lt;p&gt;他们更愿意专注于理解客户的需求，并通过小而快速的敏捷迭代过程来交付产品。&lt;/p&gt;&lt;p&gt;他们当中有一些人相信，只要遵循了这些过程，架构自然会“出现”，而不需要有意识地进行计划或架构设计。因为存在这些信念，他们可能不认为软件架构是重要的，甚至可能不关心它。&lt;/p&gt;&lt;p&gt;这种架构方法通常可以交付满足客户所需的产品，这是一个好的开始。&lt;/p&gt;&lt;p&gt;但是，如果不显式考虑产品的可持续性，它就有可能衰退，导致产品在自然退役前无法维护。&lt;/p&gt;&lt;p&gt;通过关注关键的质量属性，如性能、可伸缩性、安全性和弹性，有意识的软件架构方法有助于延长产品的生命周期，使其在更长的时期内可持续。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36771300448430494&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfOpzgIGIgOmrscThZCCVwLUe850MECweQXZkvic7vj5xEbzCib4lGpDv4cwx5BPmB6mhYPLK1fkzsPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;预先架构和紧急架构对比&lt;/section&gt;&lt;p&gt;如果我们正在做的事情是我们非常了解的，并且已经做过很多次了，那么预先设计方法就很有效。例如，建造摩天大楼、挖运河、生产产品或建造桥梁。我们可以应用“最佳实践”，并依赖过去已经在这些事情上验证过的有效方法。&lt;/p&gt;&lt;p&gt;如果我们正在处理一些东西是全新的，并且我们不太了解，或者变化太快以至于还没有“最佳实践”，那么预先设计就不起作用了。在这种情况下，作为科学革命基础的可控性实验可以帮助我们更深入地理解问题和可能的解决方案。最终的解决方案“出现”了，只是它沿着有意识的实验的路径向我们招手。&lt;/p&gt;&lt;p&gt;这两种方法都是有价值的，但适用的场景非常不同，一种可用于处理大部分已知的事情，而另一种可用于在变化的世界中探索新的机会和可能性。&lt;/p&gt;&lt;p&gt;第二种方法的问题在于，可控性实验可能无法在合理的时间内产生可持续的解决方案，并且可能需要进行可接受的返工。软件架构实践可以通过更早地提出更好的问题来指导实验，以减少交付可持续产品的时间和成本，并仍然可以保留敏捷方法的优势。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 架构是如何出现的&lt;/section&gt;&lt;p&gt;正如我们在前一篇文章中所讨论的，架构的本质由一组定义和约束产品技术面的决策组成。无论团队采用哪种方法，无论他们是有意识地还是心照不宣地做出决定，这些决定都是存在的。这些决策专注于产品如何处理质量属性需求（QAR）。&lt;/p&gt;&lt;p&gt;QAR 也可以是显式或隐式的，尽管显式的更容易处理并可以确保产品契合它们。例如，用户通常希望在使用产品时能够得到及时响应，而不管有多少人也在使用该产品。显式地声明“响应性”需求以及产品可以支持多少并发用户而不会变成“无法应式”的，将有助于开发团队对他们的技术方法做出更好的决策，比如“系统的速度必须够快”或“系统必须是可伸缩的”这样的声明并不能帮助团队做出更好的技术决策。&lt;/p&gt;&lt;p&gt;评估质量属性需求和设计一个架构来实现这些需求涉及到一些前期规划，这些也是软件系统取得成功的关键驱动因素，原因如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件架构是由质量属性需求驱动的，如果在最初的迭代中没有考虑到它们，通常会在软件系统被部署到初始试验阶段之后（只有少量的用户）出现问题。因此，当必须满足关键的质量属性需求 (如性能、安全性或可伸缩性) 时，可能需要进行重要的架构、设计和代码重构，这可能会出现具有高度易变性的软件架构。此外，如果架构设计没有强有力地实现组件的抽象和隔离，重构的成本可能会飙升。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为解决紧急架构的局限性和满足最初的质量属性需求，进行有意识的架构设计是有必要的。例如，除了提供关于系统实际使用情况的有用信息以及关于架构设计的反馈回路之外，在初始架构设计中加入一个简单的监控框架，这对于确保软件系统的弹性和正确性来说是至关重要的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重构和过度的组件化会导致解决方案的碎片化，以至于没有人能完全理解发生了什么。有可能不知道正在使用的组件是什么版本，也可能没有记录每个组件的服务水平协议 (Service Level agreement，SLA)。微服务架构为每个服务使用了单独的数据存储，这可能会导致数据一致性问题。单体系统的可持续性较差，但具有高度的内部一致性。这两种架构各有优缺点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; 你的软件系统是可持续的吗?&lt;/section&gt;&lt;p&gt;广义地说，实现“可持续性”是软件产品架构工作的重点。如果软件产品能够满足当前需求 (包括 QAR)，而不损害满足未来需求的能力，则可以认为该软件产品是可持续的。正如我们在前一节中所述，质量属性需求驱动了架构，满足关键 QAR 对于创建可持续的架构设计来说是至关重要的。不幸的是，随着功能增强的实现和新设计决策的制定，软件系统会随着时间的推移而“磨损”，这可能会延展甚至破坏最初的架构设计。常见的“磨损”原因包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;由于维护系统的开发人员对系统缺乏理解，最初的设计决策也就过时了。与系统设计相关的决策和假设很少会被准确地记录下来。当人们不再针对系统提出问题或回答问题时，软件系统就开始衰退了。提出问题是评估软件系统健康状况的一种重要技术，如果有知识资源可以回答这些问题的话。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术债务的累积会导致系统维护不再可行或不再具有成本效益，并且无法实现新的功能。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开发人员试图重用不同组件的代码块，他们认为可以通过对复用代码进行微小的改动来实现新功能。遗憾的是，他们可能无法完全理解原始代码所依赖的架构上下文，也意识不到在不同的组件中重用代码可能会在以后产生不必要的副作用，例如性能、可伸缩性或可用性问题。这些软件变更增加了技术债务，并降低了系统的整体质量，除非技术债务能够迅速得到解决。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术的发展导致一些软件系统运行在不是为它们设计的技术平台上。一些较老的软件系统经历了“灾难性的成功”，因为它们持续存在的时间比最初计划的要长得多，而且它们的技术债务已经变得非常沉重、难以解决且代价巨大，“偿还”起来非常困难。偿还技术债务的成本可能与完全替换该软件系统的成本类似，甚至有过之而无不及。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;失败的假设。逻辑的主体，包括软件系统，最终会因为假设的失败而崩溃，软件开发人员可能没有意识到他们所做的假设。隐藏的假设可以被认为是对系统的约束。关键在于要清楚地阐明所有的假设，并保持信息的更新。质量属性需求本身也是一种需要进行验证的假设，它们的实现需要经过经验的测试和确认，如果可能的话，可以使用自动化。性能、可伸缩性、弹性 (例如，使用类似于 Netflix 猴子军团的框架) 和安全性都是很好的例子。质量属性自动化测试的目标是持续对假设 (例如，实现 QAR 仍然是现实的吗？) 进行测试，并用以指导软件系统的演化。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果对最初的架构没有很好的理解，即使增加了新特性 (我们可以称之为“架构熵定律”)，使用紧急架构创建的软件系统最终也会失去架构完整性。因此，它们可能不再是可持续的。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 评估软件架构的适用性&lt;/section&gt;&lt;p&gt;如何知道你的软件系统什么时候磨损了，就像知道你的汽车轮胎什么时候磨损了并需要更换一样？就像医生可能使用许多不同种类的工具来评估个体的健康状况 (心电图、MRI、CT、血液测试、体格检查) 一样，不同的工具可以帮助团队评估软件架构的适用性。旧的系统可能难以理解，因为正如我们前面提到的，它们的设计决策和假设通常没有文档记录，而即使存在文档，也很可能是过时的。理解和评估系统的架构设计通常需要“软件考古”工具和技能。总的来说，有很多工具可以用来评估软件架构的适用性，包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;架构评审 (特别是对等评审) 是评估软件系统架构设计适用性的有效工具，特别是如果他们关注的权衡 (例如，来自 CMU/SEI 的架构权衡评估方法 (pdf))。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动化的软件质量评估工具 (例如 CAST)，但是人们需要接受它们生成的结果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码评审 (特别是自动化代码评审) 对于确保代码质量来说非常重要。结对编程是实现这一目标的另一种方法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;适用性功能实现，例如自动化性能测试。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;增强框架实现，包括 Web 服务监控工具，为软件架构提供反馈循环。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;技术债务的识别和评估，包括标明会导致技术债务增加的决定。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动化测试工具 (特别是负载 / 伸缩性 / 弹性测试)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缺陷趋势分析 (这是技术债务的代理)，需要使用一致的方式捕获数据，目标是识别不稳定性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生产事故趋势分析——与缺陷趋势分析具有相同的要求和目标。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;安全测试工具。使用这些工具的目的是找出风险暴露点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;5&lt;/span&gt; 结论&lt;/section&gt;&lt;p&gt;在“前期大设计”和敏捷实践之间长达 20 年的争议中，软件开发人员努力在这两种方法之间找到一个有意义的平衡点，并从有意识的架构活动转向自组织团队的架构设计。因此，他们常常认为软件架构并不是那么重要。更多地意识到架构当中存在的隐式决策，并迫使这些决策变成显式的，这有助于开发团队利用他们从 Sprint 和迭代中获得的经验数据做出更好、更明智的决策。现代架构实践，如持续架构和演进架构，提供了可以帮助做出显式架构决策的工具，让开发人员能够交付更可持续的软件产品。&lt;/p&gt;&lt;p&gt;欲了解更多信息，请参考 Murat Erder、Pierre Pureur 和 Eoin Woods 合著的“Continuous Architecture in Practice”，以及 Murat Erder 和 Pierre Pureur 合著的“Continuous Architecture: Sustainable Architecture in an Agile and Cloud-Centric World”。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pierre Pureur 是一位经验丰富的软件架构师，拥有广泛的创新和应用开发背景，丰富的金融服务行业经验，广泛的咨询经验和全面的技术基础设施知识。他曾担任一家大型金融服务公司的首席企业架构师，领导大型架构团队，管理大型并发应用程序开发项目，指导创新活动，以及制定战略和业务计划。他是“Continuous Architecture in Practice: Scalable Software Architecture in the Age of Agility and DevOps”(2021 年出版) 和“Continuous Architecture: Sustainable Architecture in an Agile and Cloud-Centric World”(2015 年出版) 的合著者，并发表了许多文章，还在多个软件架构会议上做演讲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kurt Bittner 拥有超过 30 年在短反馈驱动周期内开发软件的经验。他帮助许多组织采用敏捷软件交付实践，包括大型银行、保险、制造和零售组织，以及大型政府机构。他曾为包括 Oracle、HP、IBM 和微软在内的大型软件交付组织工作，曾是 Forrester Research 的技术行业分析师。他的工作重心是帮助企业建立强大的、自组织的、高性能的团队，为客户提供他们喜爱的解决方案。他写了四本关于软件开发的书，包括“The Nexus Framework for Scaling Scrum”。他现居科罗拉多州博尔德市，担任 Scrum.org 的企业解决方案副总裁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看英文原文：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.infoq.com/articles/care-about-architecture/?&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
活动推荐&lt;/section&gt;&lt;p&gt;今年 7 月，ArchSummit 全球架构师峰会将落地深圳。目前已经邀请到了顺丰集团 CTO 耿艳坤、美的集团 IoT 副总裁兼 CTO 向江旭、度小满金融数据智能部总经理 / 技术委员会执行主席杨青、Shopee 技术委员会主席叶绍志博士等多位专家来大会现场分享，更多大咖正在陆续邀请中...&lt;/p&gt;&lt;p&gt;ArchSummit 深圳站的主题是数字化转型下的架构升级，根据这一主题，以及广东地区金融业、制造业发达的特色，我们设置了金融领域数字化转型、数字化转型时代的数据治理、AICon 全球人工智能与机器学习大会、 可观测性技术落地探索、单云架构到多云架构转型、 IoT 系统架构设计、微服务架构落地实践、云原生前沿技术应用、架构师能力模型、出海业务架构、开源和自研选型思考、架构稳定性保障等专题，点击阅读原文了解详情。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/h3qlj72</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7be169030c1810d58a198201c0aa6c09</guid>
<title>优质网站同好者周刊（第 069 期） | 倾城博客</title>
<link>https://toutiao.io/k/irkvigs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Mac&quot;&gt;&lt;code&gt;Mac&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：Kap, capture, record, screen, aspect, ratio, HD, FPS, 60FPS&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;An open-source screen recorder built with web technology&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/getkap.co.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Kap - Capture your screen&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://getkap.co/&quot;&gt;Kap&lt;/a&gt; 是一款&lt;strong&gt;免费&lt;/strong&gt;且&lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/wulkano/kap&quot;&gt;开源&lt;/a&gt;的 Mac 录屏软件（使用 Web 技术构建的开源屏幕录像机，支持 M1 芯片电脑）。它支持多种录制方式，你可以选择全屏录制，或窗口录制，也可以自定义框选录制特定区域，还支持设定特定比例和尺寸，在录制完成后，你还可以使用它自带的编辑工具设置视频的格式，比如设置开始和结束时间、尺寸大小、帧率、导出格式等，无需再导入到剪辑软件中进行处理。它具备以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;质量更高噪音更低&quot;&gt;&lt;a href=&quot;#%E8%B4%A8%E9%87%8F%E6%9B%B4%E9%AB%98%E5%99%AA%E9%9F%B3%E6%9B%B4%E4%BD%8E&quot; aria-label=&quot;质量更高噪音更低 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;质量更高，噪音更低&lt;/h3&gt;&lt;p&gt;导出为带有可选音频的 GIF、MP4、WebM 或 APNG，突出显示点击和修剪。&lt;/p&gt;&lt;h3 id=&quot;开源的力量&quot;&gt;&lt;a href=&quot;#%E5%BC%80%E6%BA%90%E7%9A%84%E5%8A%9B%E9%87%8F&quot; aria-label=&quot;开源的力量 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;开源的力量&lt;/h3&gt;&lt;p&gt;您一直在寻找的易用性和速度——您不知道自己需要的功能和可扩展性。&lt;/p&gt;&lt;p&gt;除了简单的录制屏幕外，该软件还有非常多特色，值得称赞：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它支持&lt;strong&gt;插件系统&lt;/strong&gt;；你可以通过安装额外的插件，来&lt;strong&gt;增强录屏&lt;/strong&gt;；比如增加摄像头录制、录制完成后自动上传分享、隐藏桌面图标等；&lt;/li&gt;&lt;li&gt;录制完毕，支持剪辑、重新设置尺寸；此外，还能选择格式转换，比如 GIF，这就非常棒；无需再借助其他工具来处理；&lt;/li&gt;&lt;li&gt;在丰富的模式外，Kap 支持&lt;strong&gt;显示鼠标点击位置&lt;/strong&gt;。在录制演示视频或动图时，能显示鼠标点了何处，会让演示变得更清晰、易懂。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不管你是喜欢简洁的录制工具，还是喜欢增强插件，Kap 都是一个很好的工具。有了 Kap，录制屏幕内容的工作流，变得简单，让我有了录制的热情；在所用为数不多几款录屏软件中，我愿称 Kap 最强。如果您也有录屏的需求，Kap 是不应该错过的选择。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62a1e267bcba9006a79e869c&quot;&gt;倾城之链 - Kap - Capture your screen&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A0%81&quot;&gt;&lt;code&gt;编码&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9C%A8%E7%BA%BF&quot;&gt;&lt;code&gt;在线&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：免费, 在线, 学习, 代码, 重构, 设计模式, 工厂模式, 迭代器, 单例, 观察者&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;重构是一种能够在不新增功能的情况下改善代码的可控过程。设计模式是软件设计中常见问题的典型解决方案。立即开始学习！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/refactoringguru.cn.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 免费在线学习代码重构和设计模式&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://refactoringguru.cn/&quot;&gt;Refactoring.Guru&lt;/a&gt;，免费、&lt;strong&gt;在线&lt;/strong&gt;学习代码重构和设计模式的网站。在这里，  您可以免费在线学习代码重构、  设计模式、 SOLID 原则  （单一职责、  开闭原则、  里氏替换、  接口隔离以及依赖反转）  以及其他和智能编程主题相关的一切内容。该网站有写道：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我们将帮助你先从整体了解各种代码重构技巧和设计模式，  学习它们之间如何交叉、  合作和关联。  这些概念并不是我发明的，  而是过去 20 年间由无数大师级程序员提出。  但是，  我认为代码重构、  设计模式和一般编程原则之间的联系对于大部分程序开发者来说仍是非常神秘的。  这也是我为什么创建这个网站的原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;值得一提的是，目前网站中，已有许多关于重构和设计模式的信息， 但作者仍会不时地对该项目进行更新。 你还可以通过「电子邮件」关注项目进展。对于 IT 从业者（程序员）， &lt;strong&gt;设计模式&lt;/strong&gt;（是软件设计中常见问题的典型解决方案。  它们就像能够根据需求进行调整的预制蓝图，  可用于解决代码中的特定设计问题），与&lt;strong&gt;重构&lt;/strong&gt;（是一种能够在不新增功能的情况下优化代码的系统过程，  它可将一团乱麻变成清晰的代码和简洁的设计），是非常值得掌握的技能；该网站，以非常合理的方式，介绍了「什么是设计模式」，每种模式的&lt;strong&gt;意图&lt;/strong&gt;、&lt;strong&gt;所解决的问题&lt;/strong&gt;、&lt;strong&gt;伪代码&lt;/strong&gt;，&lt;strong&gt;适合应用场景&lt;/strong&gt;、&lt;strong&gt;实现方式&lt;/strong&gt;、&lt;strong&gt;优缺点&lt;/strong&gt;、&lt;strong&gt;与其他模式的关系&lt;/strong&gt;、&lt;strong&gt;代码示例&lt;/strong&gt;等等，可谓全面，超乎想象，如果您有从事编程行业，强烈推荐收藏 &amp;amp; 阅读。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62a1da63bcba9006a79e869a&quot;&gt;倾城之链 - 免费在线学习代码重构和设计模式&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;&lt;code&gt;网站生成器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Vue&quot;&gt;&lt;code&gt;Vue&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot;&gt;&lt;code&gt;Markdown&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Vite &amp;amp; Vue powered static site generator.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/vitepress.vuejs.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - VitePress | Vite &amp;amp; Vue Powered Static Site Generator&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://vitepress.vuejs.org/&quot;&gt;VitePress&lt;/a&gt; ，基于 &lt;a href=&quot;https://nicelinks.site/post/5b1a221c0526c920d6dfaada&quot;&gt;Vue&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://nicelinks.site/post/6010e1b10c71de1fb957b64e&quot;&gt;Vite&lt;/a&gt; 的&lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;静态站点生成器&lt;/a&gt;（开源、简单、强大且高性能）。截止目前（2022/06/07），它正处于 &lt;code&gt;alpha&lt;/code&gt; 阶段。它已经适合&lt;code&gt;开箱即用&lt;/code&gt;的文档使用，但配置和主题 API 可能仍会在次要版本之间发生变化。VitePress 具有以下功能特性：&lt;/p&gt;&lt;h3 id=&quot;vite-无可匹敌的-dx&quot;&gt;&lt;a href=&quot;#vite-%E6%97%A0%E5%8F%AF%E5%8C%B9%E6%95%8C%E7%9A%84-dx&quot; aria-label=&quot;vite 无可匹敌的 dx permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Vite 无可匹敌的 DX&lt;/h3&gt;&lt;p&gt;感受 Vite 的速度。即时的服务器启动和闪电般的 HMR，无论应用程序的大小都能保持快速。&lt;/p&gt;&lt;h3 id=&quot;简洁至上的设计&quot;&gt;&lt;a href=&quot;#%E7%AE%80%E6%B4%81%E8%87%B3%E4%B8%8A%E7%9A%84%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;简洁至上的设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;简洁至上的设计&lt;/h3&gt;&lt;p&gt;以 Markdown 为中心的内容，它的建立是为了帮助你专注于写作，并以最小的配置进行部署。&lt;/p&gt;&lt;h3 id=&quot;vue-的力量与-markdown-的结合&quot;&gt;&lt;a href=&quot;#vue-%E7%9A%84%E5%8A%9B%E9%87%8F%E4%B8%8E-markdown-%E7%9A%84%E7%BB%93%E5%90%88&quot; aria-label=&quot;vue 的力量与 markdown 的结合 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Vue 的力量与 Markdown 的结合&lt;/h3&gt;&lt;p&gt;用 Markdown 中 Vue 的所有功能增强你的内容，同时能够用 Vue 定制你的网站。&lt;/p&gt;&lt;h3 id=&quot;完全静态但仍然动态&quot;&gt;&lt;a href=&quot;#%E5%AE%8C%E5%85%A8%E9%9D%99%E6%80%81%E4%BD%86%E4%BB%8D%E7%84%B6%E5%8A%A8%E6%80%81&quot; aria-label=&quot;完全静态但仍然动态 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;完全静态但仍然动态&lt;/h3&gt;&lt;p&gt;使用真正的 SSG+SPA 架构，尽情发挥。在页面加载时是静态的，但从那里开始以 100% 的互动性吸引用户。&lt;/p&gt;&lt;p&gt;倒是用过非常多&lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;静态站点生成器&lt;/a&gt;工具，来搭建博客或承载文档，诸如：&lt;a href=&quot;https://nicelinks.site/post/5b2298f5d1c6ca419a9f7e00&quot;&gt;VuePress&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/61c928af5be6454b4e3d5146&quot;&gt;Next.js&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/61a334f7465c2155e2d15886&quot;&gt;Wiki.js&lt;/a&gt; 等等。在&lt;a href=&quot;https://quickapp.lovejade.cn/vuepress-hexo-jekyll-ghost-gitbook-hugo-solo_compare-personal-website-generator/&quot;&gt;如何选定搭建个人独立博客工具&lt;/a&gt; 一文中，有做详细叙述。Vue3 和 Vite，有体验过，于前端开发而言，非常值得使用。之于 VitePress 相信也有其可取处，感兴趣的朋友不妨玩儿一下。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/629f40babcba9006a79e8694&quot;&gt;倾城之链 - VitePress | Vite &amp;amp; Vue Powered Static Site Generator&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/JSON&quot;&gt;&lt;code&gt;JSON&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%B7%A5%E5%85%B7&quot;&gt;&lt;code&gt;工具&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;JSON Hero makes reading and understand JSON files easy by giving you a clean and beautiful UI packed with extra features.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/jsonhero.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - JSON Viewer - JSON Hero&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://jsonhero.io/&quot;&gt;JSON Hero&lt;/a&gt;，是一个开源的、漂亮的网络 JSON 浏览器，可让您快速浏览、搜索和导航您的 JSON 文件。🚀 它通过为您提供包含额外功能的、干净美观的 UI，使阅读和理解 JSON 文件变得容易。JSON Hero 具有以下功能特征：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;以您喜欢的任何方式查看 JSON：列视图、树视图、编辑器视图等；&lt;/li&gt;&lt;li&gt;自动推断字符串的内容并提供有用的预览；&lt;/li&gt;&lt;li&gt;创建可用于验证 JSON 的推断 JSON 模式；&lt;/li&gt;&lt;li&gt;快速扫描相关值以检查边缘情况；&lt;/li&gt;&lt;li&gt;搜索您的 JSON 文件（键和值）；&lt;/li&gt;&lt;li&gt;可使用键盘快捷键；&lt;/li&gt;&lt;li&gt;支持&lt;strong&gt;黑暗模式&lt;/strong&gt;、代码视图、VS 代码插件等；&lt;/li&gt;&lt;li&gt;具有路径支持的可轻松共享的 URL；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;JSON 本身非常不利于阅读，但 JSON Hero 正在让它变得更好：停止盯着编辑器中的千行 JSON 文件；此外，JSON Hero 使用非常的简单，只需打开网站，输入 JSON URL，或者粘贴 JSON 内容即可。另外值得一提的是，JSON Hero 免费可用，并在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/jsonhero-io/jsonhero-web&quot;&gt;Github 完全开源&lt;/a&gt;，感兴趣的朋友，可以了解下。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/629f36b4f7de4036d27ffe88&quot;&gt;倾城之链 - JSON Viewer - JSON Hero&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/GraphQL&quot;&gt;&lt;code&gt;GraphQL&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%95%99%E7%A8%8B&quot;&gt;&lt;code&gt;教程&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;GraphQL Start is a pragmatic guide that explains how to build a GraphQL API (server) from start to finish on top of Node.js stack using JavaScript and GraphQL.js library.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/graphqlstart.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - What is GraphQL Start - GraphQL Start&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://graphqlstart.com/&quot;&gt;GraphQL Start&lt;/a&gt; 是一本实用指南（该网站基于 &lt;a href=&quot;https://nicelinks.site/post/5c7d27dace377707f7f675f3&quot;&gt;Gitbook&lt;/a&gt; 所搭建），它解释了如何使用 JavaScript 和 &lt;a href=&quot;https://nicelinks.site/post/61c9a2d25be6454b4e3d5148&quot;&gt;GraphQL.js&lt;/a&gt; 库在 Node.js 堆栈之上从头到尾构建 GraphQL API（服务器）。在本&lt;strong&gt;教程&lt;/strong&gt;中，您将学习以下内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如何组织你的 GraphQL API 项目&lt;/li&gt;&lt;li&gt;如何实现查询、突变和订阅；&lt;/li&gt;&lt;li&gt;如何使用批处理和缓存优化 API 性能；&lt;/li&gt;&lt;li&gt;如何处理认证和授权；&lt;/li&gt;&lt;li&gt;如何验证用户的权限并限制对内容的访问；&lt;/li&gt;&lt;li&gt;如何使用无服务器基础架构将 API 部署到云中；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;需要补充说明的是，在阅读这份教程，您至少需要熟悉 &lt;strong&gt;Node.js&lt;/strong&gt; 和 &lt;strong&gt;JavaScript&lt;/strong&gt; 的基本概念。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/629df3cbf7de4036d27ffe86&quot;&gt;倾城之链 - What is GraphQL Start - GraphQL Start&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/React&quot;&gt;&lt;code&gt;React&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/GraphQL&quot;&gt;&lt;code&gt;GraphQL&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Relay is a JavaScript framework for building data-driven React applications.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/relay.dev.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Relay | A JavaScript Framework for building data-driven React Applications&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://relay.dev/&quot;&gt;Relay&lt;/a&gt; 是一个 JavaScript 框架，用于构建数据驱动的 React 应用程序。它专为任何规模的高性能而设计。无论您的应用程序有数十、数百或数千个组件，Relay 都可以轻松管理数据获取。并且由于 Relay 的增量编译器，即使您的应用程序增长，它也可以保持您的迭代速度；您可以从以下功能特征，进一步了解 Relay：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;声明式&lt;/strong&gt;：不再使用命令式 API 与您的数据存储进行通信。只需使用 GraphQL 声明您的数据需求，然后让 Relay 确定如何以及何时获取您的数据。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;托管&lt;/strong&gt;：查询位于依赖它们的视图旁边，因此您可以轻松地推断您的应用程序。Relay 将查询聚合为高效的网络请求，以仅获取您需要的内容。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;突变&lt;/strong&gt;：Relay 允许您使用 GraphQL 突变对客户端和服务器上的数据进行突变，并提供自动数据一致性、乐观更新和错误处理。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;保持快速迭代&lt;/strong&gt;：Relay 是数据获取变成&lt;strong&gt;声明性&lt;/strong&gt;的。组件声明它们的数据依赖关系，而不用担心如何获取它们。Relay 保证每个组件需要的数据都被获取并且可用。这使组件保持解耦并促进重用。使用 Relay，可以快速修改组件及其数据依赖关系，而无需修改系统的其他部分。这意味着您在重构或更改应用程序时不会意外破坏其他组件。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;自动优化&lt;/strong&gt;：Relay 的编译器聚合和优化整个应用程序的数据需求，以便可以在单个 GraphQL 请求中有效地获取它们。Relay 处理繁重的工作，以确保以最有效的方式获取组件声明的数据。例如，通过对相同字段进行重复数据删除，以及在运行时预计算使用的信息，以及其他优化。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;数据一致性&lt;/strong&gt;：当影响它们的数据发生变化时，Relay 会自动使所有组件保持最新，并且仅在绝对必要时才有效地更新它们。这意味着没有不必要的重新渲染。Relay 还支持执行 GraphQL Mutations，可选择乐观更新和本地数据更新，同时确保屏幕上的可见数据始终保持最新。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Relay 用于在 React 应用程序中获取和管理 GraphQL 数据，它强调可维护性、类型安全和运行时性能。通过结合声明性数据获取和静态构建步骤来实现这一点。通过声明性数据获取，组件声明它们需要什么数据，而 Relay 会弄清楚如何有效地获取数据。在静态构建步骤中，Relay 验证和优化查询，并预先计算工件以实现更快的运行时性能。如果您从事 Web 前端开发相关工作，并对 Relay 感兴趣，可阅读 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://relay.dev/docs/&quot;&gt;Relay 文档&lt;/a&gt; 以便进一步了解和使用它。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/629deedff7de4036d27ffe84&quot;&gt;倾城之链 - Relay | A JavaScript Framework for building data-driven React Applications&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;目标，不一定总是要达到，&lt;strong&gt;目标往往只是用来帮助你瞄准方向&lt;/strong&gt;。如果你给每件事情都设了限，无论是有形的还是无形的，它都会融进你的工作和生活。没有极限，只有停滞不前，而你千万别停滞不前，你必须超越和突破。── 当代 · 国际著名华裔武术家、截拳道创始人、动作片演员、动作导演、武术指导、功夫片的开创者、好莱坞首位华人主角李小龙&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b86ba366f4f4c3e877516e736dc525e</guid>
<title>是时候为Spring Boot 3.0做准备了</title>
<link>https://toutiao.io/k/v3i8wzb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41101152368758004&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5KYkqUOzHEMPIFkQzAFEGktt0lwYGbSSL2krVpdKt8ydaHltcVfZfdBohyN6Nh2D8eo9wqrIpDK9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1562&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年2月28日Spring Boot进入2.0时代，距今已经超过4年了。2022 年11月Spring Boot 3.0将正式发布，它将基于Spring Framework 6.0，并且需要 Java 17 或更高版本，同时它也将是Jakarta EE 9的第一个Spring Boot版本。还有六个月的时间留给开发者来过渡到Spring Boot 3.0，今天胖哥将告诉你一些方法，以便于将来快速迁移到3.0。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Java 17&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 17将是继Java 8以来最重要的LTS版本，是Java社区八年努力的成果。包含了很多重要的改进，Java 17也是目前性能最强的LTS版本。目前所有的Spring Boot 2.x 版本都能很好地适配Java 17，你可以无需等待，先着手JDK的升级调试，并尝试一些新的特性和API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;尽快升级到Spring Boot 2.7&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几日胖哥已经讲了Spring Boot 2.7基本已经是Spring Boot 2.x最后一个大版本了，Spring Boot 2.5已经停止OSS支持，不再进行维护，Spring Boot 2.6也将在Spring Boot 3.0发布后停止维护，迭代的速度越来越快了。尽早升级到2.7才能更好迁移到3.0，这里胖哥建议不要跳版本升级，比如不要直接从2.4跳到2.7，尽量按照2.4、2.5、2.6、2.7这样的步骤升级，跨度太大反而不利于平滑升级。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;移除过时代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Spring Boot版本都会或多或少有一些被标记为&lt;code&gt;@Deprecated&lt;/code&gt;的代码，Spring Boot 3.0 将完全移除在 2.x 过时的代码，当然2.x早期的过时代码也可能在最新的2.x被移除。尽量不要使用过时代码，一般过时代码上都注释有过时的原因或者替代的API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;配置文件机制的更改&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spring Boot 2.4中，配置文件 &lt;code&gt;application.properties&lt;/code&gt; 和 &lt;code&gt;application.yaml&lt;/code&gt; 的加载机制被改变，目的是为了简化外部配置的加载方式，使之更加合理，带来的是不向下兼容。为了平滑升级，Spring 提供了一个配置项来兼容旧机制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;use-legacy-processing:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个机制将在3.0时移除，我们必须使用符合新机制的配置方式，如果你存在这几种方式就需要注意了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多文档Yaml&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在&lt;code&gt;yaml&lt;/code&gt;配置文件中使用了间隔符&lt;code&gt;---&lt;/code&gt;来声明多文档的话，你得知道现在按文档声明的顺序来注册声明的配置属性；而在 Spring Boot 2.3 及更早版本中，基于配置文件激活顺序。举个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;active:&lt;/span&gt; &lt;span&gt;dev&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;application:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;dev-app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8081&lt;/span&gt;      &lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;active:&lt;/span&gt; &lt;span&gt;prod&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;application:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;prod-app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;     &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个配置文件在Spring Boot 2.3以及更早的版本中会根据&lt;code&gt;spring.profiles.active&lt;/code&gt;来决定加载的环境。但是从2.4开始后面的属性会覆盖前面的属性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;外部配置总是覆盖jar内的配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的配置文件在jar之外，并且该配置文件适用于特定的环境，例如&lt;code&gt;application-dev.yaml&lt;/code&gt;。2.4以下的版本中，在jar外面的&lt;code&gt;application.yaml&lt;/code&gt;不会覆盖jar中的&lt;code&gt;application-&amp;lt;profile名称&amp;gt;.yaml&lt;/code&gt;文件，从2.4开始外部文件将总是覆盖jar内的配置文件。你需要检查你是否存在这种情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;激活配置文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您使用&lt;code&gt;spring.profiles&lt;/code&gt;属性来激活环境配置，那么现在就应该迁移到&lt;code&gt;spring.config.activate.on-profile&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旧玩法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt; &lt;span&gt;&quot;prod&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;secret:&lt;/span&gt; &lt;span&gt;&quot;production-password&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新玩法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;activate:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;on-profile:&lt;/span&gt; &lt;span&gt;&quot;prod&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;secret:&lt;/span&gt; &lt;span&gt;&quot;production-password&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这真是折腾人啊。&lt;code&gt;spring.profiles.active&lt;/code&gt;仍然可以用来激活特定的环境，例如命令行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ java -jar myapp.jar --spring.profiles.active=prod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以在 &lt;code&gt;application.properties&lt;/code&gt; 或 &lt;code&gt;application.yaml&lt;/code&gt; 中使用&lt;code&gt;spring.profiles.active&lt;/code&gt;，从2.4开始&lt;code&gt;spring.profiles.active&lt;/code&gt;不能在特定环境中使用，也就是说&lt;code&gt;application-&amp;lt;profile&amp;gt;.yaml&lt;/code&gt;中不能使用，&lt;code&gt;---&lt;/code&gt;间隔的多文档中也不能使用它。一句话，你不能再通过&lt;code&gt;spring.profiles.active&lt;/code&gt;来合并一个包含了&lt;code&gt;spring.config.activate.on-profile&lt;/code&gt;属性的配置文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的机制， &lt;code&gt;spring.profiles.include&lt;/code&gt;属性只能在非特定配置文件中使用，下面的配置是无效的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 无效配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;config:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;activate:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;on-profile:&lt;/span&gt; &lt;span&gt;&quot;prod&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;profiles:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;include:&lt;/span&gt; &lt;span&gt;&quot;metrics&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多的要点请参考官方配置文件&lt;span&gt;Spring boot配置迁移指南&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;性能更高的路径解析方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Spring Boot 2.6 开始，路径解析默认使用&lt;code&gt;PathPatternParser&lt;/code&gt;，取代了之前的Ant风格匹配&lt;code&gt;AntPathMatcher&lt;/code&gt;，升级时很多人的&lt;strong&gt;Swagger&lt;/strong&gt;出问题了，通过&lt;code&gt;spring.mvc.pathmatch.matching-strategy&lt;/code&gt;解决了这个问题。虽然在Spring Boot 3.0中&lt;code&gt;AntPathMatcher&lt;/code&gt;会继续生效，但是&lt;code&gt;PathPatternParser&lt;/code&gt;成为官方推荐，因为它的性能更高，稍后我也将出一篇专题来分析&lt;code&gt;PathPatternParser&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;兼容问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是Jakarta EE 9的兼容问题，确保你的第三方依赖库和你的代码都兼容Jakarta EE 9。另外也要检查Spring框架正在使用的第三方依赖jar是否有计划兼容Spring 6。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;尝试去学习Spring 6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 6以及Spring Boot 3已经发布了多个里程碑，在闲暇时间可以抽出一些时间去尝试一下，体验新的特性和变化，评估你应用升级的难度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;Spring boot配置迁移指南: https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Config-Data-Migration-Guide&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651514853&amp;amp;idx=1&amp;amp;sn=cc4c1ab9812868835e414a9ca610d1ab&amp;amp;chksm=bd258b9a8a52028cea6d9ac013784ac4e29085cdcbc5ac2e07beadd7c13a684dca151dfcec04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring Boot 2.7.0 发布，2.5 停止维护，节奏太快了吧&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring Boot 2.7.0 发布，2.5 停止维护，节奏太快了吧&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651514488&amp;amp;idx=1&amp;amp;sn=5b9509cdd0903bbfed9669f0451dc6fd&amp;amp;chksm=bd258a078a520311dda464be496b4a53c1031af4ba72da99dafd58da5dd0d787733535435ae7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringCloud 优雅下线+灰度发布&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;SpringCloud 优雅下线+灰度发布&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44ccc4e203bff48085cb5b2078a0f1cc</guid>
<title>C++异步从理论到实践总览篇</title>
<link>https://toutiao.io/k/3zwk82u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;fangshen，腾讯 IEG 客户端开发工程师&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;C++20带来了coroutine特性, 同时新的execution也在提案过程中, 这两者都给我们在C++中解决异步问题带来了新的思路. 但对比其他语言的实现, C++的协程和后续的execution都存在一定的理解和封装成本, 本系列的分享我们将围绕基本的原理, 相应的封装, 以及剥析优秀的第三方实现, 最终结合笔者framework落地的情况来展开.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 纠结的开篇&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前设计我们游戏用的c++框架的时候, 刚好c++20的coroutine已经发布, 又因为是专门 给game server用的c++ framework, 对多线程的诉求相对有限, 或者本着少并发少奇怪的错误的原则, 除网络和IO和日志等少量模块外, 大部分模块主要还是工作在主线程上的, 所以当时设计的重点也就放在了c++20 coroutine的包装和使用上, 更多的使用coroutine来完善异步的支持. 但如果考虑到framework作为前后端公用框架的话, 原来主要针对主线程使用的包装的coroutine调度器就显得有些不够用, 以此作为基础, 我们开始了尝试结合比较新的c++异步思路, 来重新思考应该如何实现一个尽量利用c++新特性, 业务层简单易用的异步框架了.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列的主要内容也是围绕这条主线来铺开, 过程中我们 主要以:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自有的framework异步实现&lt;/strong&gt; - 主要落地尝试利用c++20的coroutine实现一个业务级的调度器.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;asio&lt;/strong&gt; - 这个应该不用多说了, 近年来一直高频迭代, 业界广泛使用的开源第三方库, 中间的异步任务调度, 网络部分的代码实现都非常优质.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;libunifex&lt;/strong&gt; - 最接近当前sender/receiver版 execution提案的可实操版本, c++17/20兼容, 但不推荐使用c++17的版本进行任何尝试, 原因后续文件会展开.&lt;br/&gt;这几个库作为基础, 逐步展开我们对c++异步的探索, 然后再回到落地实践这条主线上, 探讨一个业务侧使用简单, 内部高效的异步库应该如何来实现并落地.  当然, 我们的侧重点主要还是c++异步的调度和处理上, 网络相关的有部分内容可能会简单提到, 但不会进行深入的展开.
  其实整个尝试的过程只能说非常不顺利了, 当然, 随着对相关实现的深入理解和细节的深挖, 收益也是颇多的. 闲话不多说了, 我们直接切入主题, 以对异步的思考来展开这篇总览的内容.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 前尘往事 - rstudio framework实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rstudio framework的异步框架由两块比较独立的部分组成:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一部分是源自asio几年前版本的post和strand部分实现, 另外附加了一些业务侧较常用的像Fence等对象;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外一部分是主线程的协程调度器实现, 这部分最早是基于c++17实现的一版stackless 协程; 另外一版则是gcc11.1正式发布后, 直接用c++20重构了整个实现, 直接使用c++20的coroutine的一个版本.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 asio 部分&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;  这一部分的内容因为后续有asio scheduler实现具体的分析篇章, 这个地方主要以业务侧使用进行展开了.&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 executor概述&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;来源于1.6X boost同期的asio standalone版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;去除了各平台网络处理相关的代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仅保留了post和相关的功能(新版本有executor实现)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;早期c++11兼容, 无coroutine支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除网络库外, asio非常有使用价值的一部分代码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2  一个简单的使用示例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  GJobSystem-&amp;gt;Post([]() {&lt;br/&gt;        &lt;span&gt;//some calculate task here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;        GJobSystem-&amp;gt;Post(&lt;br/&gt;            []() {&lt;br/&gt;                &lt;span&gt;//task notify code here&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;            },&lt;br/&gt;            rstudio::JobSystemType::kLogicJob);&lt;br/&gt;      }, rstudio::JobSystemType::kWorkJob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关的时序图:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2801678908709339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4l6jiaWwnw868fiaEK3qYELYicEGic4ENDOSjDItwAOgHatRBSkwsutkSJKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1906&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.3  当前框架使用的线程结构&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6405693950177936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lnQWicBuPxTCHqCWPOGnWGZlpWGcSZHWsHVO66yKzk2u5OZj9xYhjqdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1686&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预定义的枚举值:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JobSystemType&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; {&lt;br/&gt;  kLogicJob = &lt;span&gt;0&lt;/span&gt;,       &lt;span&gt;// logic thread(main thread)&lt;/span&gt;&lt;br/&gt;  kWorkJob,            &lt;span&gt;// work thread&lt;/span&gt;&lt;br/&gt;  kSlowJob,            &lt;span&gt;// slow work thread(run io or other slow job)&lt;/span&gt;&lt;br/&gt;  kNetworkJob,         &lt;span&gt;// add a separate thread for network&lt;/span&gt;&lt;br/&gt;  kNetworkConnectJob,  &lt;span&gt;// extra connect thread for network&lt;/span&gt;&lt;br/&gt;  kLogJob,             &lt;span&gt;// log thread&lt;/span&gt;&lt;br/&gt;  kNotifyExternalJob,  &lt;span&gt;// use external process to report something, 1 thread only~~&lt;/span&gt;&lt;br/&gt;  kTotalJobTypes,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不同Job说明:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kLogicJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kWorkJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Work Thread线程池执行任务(多个), 一般是计算量可控的小任务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kSlowJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNetworkJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNetworkConnectJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kLogJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;日志专用线程, 目前日志模块是自己起的线程, 可以归并到此处管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;kNotifyExternalJob&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;专用的通知线程, 如lua error的上报, 使用该类型&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.4  Timer任务相关&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关接口:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//NoIgnore version&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddAlwaysRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType,&lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; periodTimeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddTimesRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType, &lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; periodTimeMs, &lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runCount)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;&lt;span&gt;&lt;span&gt;uint64_t&lt;/span&gt; &lt;span&gt;JobSystemModule::AddDelayRunJob&lt;/span&gt;&lt;span&gt;(JobSystemType jobType,  &lt;br/&gt;      threads::ThreadJobFunction&amp;amp;&amp;amp; periodJob,&lt;br/&gt;      &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; delayTimeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;JobSystemModule::KillTimerJob&lt;/span&gt;&lt;span&gt;(&lt;span&gt;uint64_t&lt;/span&gt; tid)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本部分并未直接使用asio原始的basic_waitable_timer实现, 而是自己实现的定时任务.&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.5 在线程池上关联执行任务 - Strand&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;特定的情况下, 被派发到Work线程池的任务存在依赖关系&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;需要串联执行的时候, 这个时候我们需要额外的设施 JobStrand&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来保证任务是按先后依赖关系来串行执行的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如下图中part1, part2, part3, part4串行执行的情况所示&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lCGIGIQqZmiback9qKNkaTib2rPpXrCTNCoWqW8lRM5AMV5h22ZEbaXrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例代码:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;auto&lt;/span&gt; strand = GJobSystem-&amp;gt;RequestStrand(rstudio::JobSystemType::kWorkJob);&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part1~&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part2~&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part3~ &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    &lt;span&gt;//part4~ &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;starnd.Post([](){ &lt;br/&gt;    GJobSystem-&amp;gt;Post([](){&lt;br/&gt;        &lt;span&gt;//return code here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    }, rstudio::JobSystemType::kLogicJob); &lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.6 其他辅助设施&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobFence&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobFencePtr &lt;span&gt;JobSystemModule::RequestFence&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;字面义, 栅栏, 起到拦截执行的作用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一般多用于模块的初始化和结束&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如tbuspp在kNetworkJob上的初始化和结束.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3619246861924686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lqTs7fklVPtWiczxGu3OvFuia3Rs4OjglNM3sCicicIGopJQZwBQQL6Xa8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1912&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例代码(TcpService的初始化)&lt;/strong&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;job_system_module_-&amp;gt;Post(&lt;br/&gt;    [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        InitInNetworkThread();&lt;br/&gt;    },&lt;br/&gt;    JobSystemType::kNetworkJob);&lt;br/&gt;&lt;br/&gt;period_task_ptr = job_system_module_-&amp;gt;AddAlwaysRunJob(&lt;br/&gt;    JobSystemType::kNetworkJob,&lt;br/&gt;    [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        LoopInNetworkThread();&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fence_-&amp;gt;FenceTo((&lt;span&gt;int&lt;/span&gt;)JobSystemType::kNetworkJob);&lt;br/&gt;fence_-&amp;gt;Wait();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobNotify &amp;amp;&amp;amp; JobWaiter&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobWaiterPtr &lt;span&gt;JobSystemModule::RequestWaiter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;jobs::JobNotifyPtr &lt;span&gt;JobSystemModule::RequestNotify&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;批量任务管理使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等待的方式的区别&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JobNotify&lt;/strong&gt;: 执行完成调用额外指定的回调.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;JobWaiter&lt;/strong&gt;: 以Wait的方式在特定线程等待所有Job执行完成.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JobTicket&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;jobs::JobTicketPtr &lt;span&gt;JobSystemModule::RequestTicket&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;令牌对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一般用来处理跨线程的生命周期控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回调之前先通过IsExpired()来判断对应对象是否已经释放&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GJobSystem-&amp;gt;Post(&lt;br/&gt;  [&lt;span&gt;this&lt;/span&gt;, workTicket]() {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!workTicket || workTicket-&amp;gt;IsExpired()) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; InitInNetworkThread();&lt;br/&gt;  },&lt;br/&gt;  JobSystemType::kNetworkJob);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 asio 与其他实现的对比&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;  正好今年的GDC上有一个&amp;lt;&amp;lt;One Frame In Halo Infinite&amp;gt;&amp;gt;的分享, 里面主要讲述的是对Halo Infinite的引擎升级, 提供新的JobSystem和新的动态帧的机制来支撑项目的, 我们直接以它为例子来对比一下framework和Halo的实现, 并且也借用Halo Infinite的例子, 来更好的了解这种lambda post模式的缺陷, 以及可以改进的点.
  Halo引入新的JobSystem主要是为了将老的Tetris结构的并发模式:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5618055555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lzJm0V4Ww8UxzPVO2j0ib0Te7n2W1oL3NMKjAABpdZSiblLucQ92P8ibcw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向新的基于Dependency的图状结构迁移:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lHC1a2xnia1VHGmpMictbJTMp3sqtyAxCq0kWqOFXapLmnpGfMsK4ibSicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1440&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他使用的JobSystem的业务Api其实很简单, 我们直接来看一下相关的代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;JobSystem&amp;amp; jobSsytem = JobSystem::Get();&lt;br/&gt;JobGraphHandle graphHandle = jobSystem.CreateJobGraph();&lt;br/&gt;&lt;br/&gt;JobHandle jobA = jobSystem.AddJob( &lt;br/&gt; graphHandle, &lt;br/&gt; &lt;span&gt;&quot;JobA&quot;&lt;/span&gt;,&lt;br/&gt; [](){...} );&lt;br/&gt;&lt;br/&gt;JobHandle jobB = jobSystem.AddJob(&lt;br/&gt; graphHandle,&lt;br/&gt; &lt;span&gt;&quot;JobB&quot;&lt;/span&gt;,&lt;br/&gt; [](){...} );&lt;br/&gt;&lt;br/&gt;jobSystem.AddJobToJobDependency(jobA, jobB);&lt;br/&gt;&lt;br/&gt;jobSystem.SubmitJobGraph(graphHandle);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这样的机制, 就很容易形成如:&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lv1iamtUVNDHCWunZBJibDREpNrcIcy5hMrK9AnicTHq9Dibic2TlDg05Bfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;913&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还有一个用于同步的SyncPoint:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;JobSystem&amp;amp; jobSystem = JobSystem::Get();&lt;br/&gt;JobGraphHandle graphHandle = jobSystem.CreateJobGraph();&lt;br/&gt;&lt;br/&gt;SyncPointHandle syncPointX = jobSystem.CreateSyncPoint(graphHandle, &lt;span&gt;&quot;SyncPointX&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;JobHandle jobA = jobSystem.AddJob(graphHandle, &lt;span&gt;&quot;JobA&quot;&lt;/span&gt;, [](){...});&lt;br/&gt;JobHandle jobB = jobSystem.AddJob(graphHandle, &lt;span&gt;&quot;JobB&quot;&lt;/span&gt;, [](){...});&lt;br/&gt;&lt;br/&gt;jobSystem.AddJobToSyncPointDependency(jobA, syncPointX);&lt;br/&gt;jobSystem.AddSyncPointToJobDependency(syncPointX, jobB);&lt;br/&gt;&lt;br/&gt;jobSystem.SubmitJobGraph(graphHandle);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的作用如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5675487465181058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4lTo3UDOjLg9SN8kVUAzPsAc44fUTcZe2mYqzF2F6MuMd9d9m5JljYrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在workload主动触发SyncPoint后, 整体执行才会继续往下推进, 这样就能方便的加入一些主动的同步点对整个Graph的执行做相关的控制了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到asio, 我们前面也介绍了, 使用strand和post(), 我们也能很方便的构造出Graph形的执行情况 , 而SyncPoint其实类型framework中提供的Event, 表达上会略有差异, 但很容易看出两套实现其实是相当类同的. 这样的话, Halo 的JobSystem有的所有优缺点, framework基本也同样存在了, 这里简单搬运一下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5634588563458857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavoY2qYsT93zCZmcM8HTl4libdSFcjs02k1Oic6LkU4FEdfqMAJFgoZ0BpRPAf87cXhYH5ziamYstfTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1434&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂并发业务的表达以lambda内嵌为主, 虽然这种方式尽可能保证所有代码上下文是比较集中的, 对比纯粹使用callback的模式有所进步, 但这种自由度过高的方式本身也会存在一些问题, 纯粹靠编码者来维系并发上下文的正确性,  这种情况下状态值在lambda之间的传递也需要特别的小心,  容易出错, 并且难以调试。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 coroutine实现部分&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;coroutine部分之前的帖子里已经写得比较详细了, 这里仅给出链接以及简单的代码示例:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/411834453&quot; data-linktype=&quot;2&quot;&gt;如何在C++17中实现stackless coroutine以及相关的任务调度器&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/414506528&quot; data-linktype=&quot;2&quot;&gt;C++20 Coroutine实例教学&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外还有一个purecpp大会的演讲视频,  主要内容与上述的两篇文章相关度比较高, 这里也给出相关的链接, 感兴趣的同学可以自行观看:&lt;a href=&quot;https://www.bilibili.com/video/BV1fZ4y197AL?spm_id_from=333.999.0.0&quot; data-linktype=&quot;2&quot;&gt;C++20 coroutine原理与应用&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//C++ 20 coroutine&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; clientProxy = mRpcClient-&amp;gt;CreateServiceProxy(&lt;span&gt;&quot;mmo.HeartBeat&quot;&lt;/span&gt;);&lt;br/&gt;mScheduler.CreateTask20([clientProxy]() &lt;br/&gt;                        -&amp;gt; rstudio::logic::CoResumingTaskCpp20 {&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt;* task = rco_self_task();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step1: task is %llu\n&quot;&lt;/span&gt;, task-&amp;gt;GetId());&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::NextFrame{};&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step2 after yield!\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (c &amp;lt; &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;in while loop c=%d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        c++;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; &lt;span&gt;5&lt;/span&gt;; c++) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;in for loop c=%d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::NextFrame{};&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step3 %d\n&quot;&lt;/span&gt;, c);&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; newTaskId = &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::CreateTask(&lt;span&gt;false&lt;/span&gt;, &lt;br/&gt;                                    []()-&amp;gt; logic::CoResumingTaskCpp20 {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;from child coroutine!\n&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;2000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;after child coroutine sleep\n&quot;&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;new task create in coroutine: %llu\n&quot;&lt;/span&gt;, newTaskId);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Begin wait for task!\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::WaitTaskFinish{ newTaskId, &lt;span&gt;10000&lt;/span&gt; };&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;After wait for task!\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    rstudio::logic::cotasks::RpcRequest &lt;br/&gt;        rpcReq{clientProxy, &lt;span&gt;&quot;DoHeartBeat&quot;&lt;/span&gt;, rstudio::reflection::Args{ &lt;span&gt;3&lt;/span&gt; }, &lt;span&gt;5000&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt;* rpcret = &lt;span&gt;co_await&lt;/span&gt; rpcReq;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (rpcret-&amp;gt;rpcResultType == rstudio::network::RpcResponseResultType::RequestSuc) {&lt;br/&gt;        assert(rpcret-&amp;gt;totalRet == &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; retval = rpcret-&amp;gt;retValue.to&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;();&lt;br/&gt;        assert(retval == &lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;rpc coroutine run suc, val = %d!\n&quot;&lt;/span&gt;, retval);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;rpc coroutine run failed! result = %d \n&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)rpcret-&amp;gt;rpcResultType);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; rstudio::logic::cotasks::Sleep(&lt;span&gt;5000&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;step4, after 5s sleep\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;co_return&lt;/span&gt; rstudio::logic::CoNil;&lt;br/&gt;} );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行结果:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;step1: task is 1&lt;br/&gt;step2 after yield!&lt;br/&gt;in while loop c=0&lt;br/&gt;in while loop c=1&lt;br/&gt;in while loop c=2&lt;br/&gt;in while loop c=3&lt;br/&gt;in while loop c=4&lt;br/&gt;in for loop c=0&lt;br/&gt;in for loop c=1&lt;br/&gt;in for loop c=2&lt;br/&gt;in for loop c=3&lt;br/&gt;in for loop c=4&lt;br/&gt;step3 5&lt;br/&gt;new task create in coroutine: 2&lt;br/&gt;Begin wait for task!&lt;br/&gt;from child coroutine!&lt;br/&gt;after child coroutine sleep&lt;br/&gt;After wait for task!&lt;br/&gt;service yield call finish!&lt;br/&gt;rpc coroutine run suc, val = 4!&lt;br/&gt;step4, after 5s sleep&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体来看, 协程的使用还是给异步编程带来了很多便利, 但框架本身的实现其实还是有比较多迭代优化的空间的:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;asio的调度部分与coroutine部分的实现是分离的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;coroutine暂时只支持主线程&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面也结合halo的实例说到了一些限制, 那么这些问题有没有好的解决办法了, 答案是肯定的, 虽然execution并未完全通过提案, 但整体而言, execution新的sender/reciever模型, 对于解决上面提到的一些缺陷, 应该是提供了非常好的思路, 我们下一章节中继续展开.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. so easy - execution就是解?&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最开始的想法其实比较简单, 结合原来的framework, 适当引入提案中的execution一些比较可取的思路, 让framework的异步编程能更多的吸取c++新特性和execution比较高级的框架抽象能力, 提升整个异步库的实现质量. 所以最开始定的主线思路其实是更多的向execution倾斜, 怎么了解掌握execution, 怎么与现在的framework结合成了主线思路.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们选择的基础参考库是来自冲元宇宙这波改名的Meta公司的libunifex, 客观来说, Meta公司的folly库, 以及libunifex库的实现质量, 肯定都是业界前沿的, 对c++新特性的使用和探索, 也是相当给力的. 这些我们后续在分析libunifex具体实现的篇章中也能实际感受到.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但深入了解libunifex后, 我们会发现, 它的优点有不少:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;尝试为c++提供表达异步的框架性结构.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;泛型用得出神入化, ponder在它前面基本是小弟级别的, 一系列泛用性特别强的template 编程示例, 比如隐含在sender/receiver思路内的lazy evaluate表达, 如何在大量使用泛型的情况下提供业务定制点等等.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结构化的表达并发和异步, 相关代码的编写从自由发挥自主把控走向框架化, 约束化, 能够更有序更可靠的表达复杂异步逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个执行pipeline的组织, 所有信息是compile time和runtime完备的, dependencies不会丢失.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点之间的值类型是强制检查的, 有问题的情况 , 大多时候compiler time就会报错.
有不少优点的同时, 也有很多缺点:&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个库的实现严重依赖了c++20 ranges采用的一种定制手段 cpo, 并且也使用了类似ranges的pipe表达方法, 理解相关代码存在一定的门坎.(后续会有具体的篇章展开相关的内容)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库同时向下兼容了c++17, 但由于c++17本身特性的限制, 引入了大量的宏, 以及X Macros展开的方式, 导致相关的代码阅读难度进一步提升. 但实际上c++17版本并不具备可维护的价值, 依赖SIFINAE的实现, 如果中间任何一环报错, 必然需要在N屏的报错中寻找有效信息.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libunifex对coroutine的支持存疑, 虽然让coroutine可以作为一种reciever存在, 但本质上来说, coroutine其实更适合拿来做流程控制的胶水, 而不是作为异步中的某个节点存在.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认的scheduler实现质量离工业级还存在一定的距离, 这一点后续的代码分析中也会具体提到.
诸多问题的存在, 可能也是execution提案没有短时间内获得通过的原因吧, 但整体来说, execution本身的理念还是很有参考价值的, 但以它的现状来说, 离最终的解肯定还是有比较大的距离的.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 尝试重新思考 - 要什么, 用什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情到这个点就有点尴尬了, 原有的asio, 架构层面来说, 跟新的execution是存在落差的. 而项目实践上来说, asio相当稳扎稳打, 而以libunifex当前的状态来说, 离工业化使用其实是有一定距离的. 但asio作者在21年时候的两篇演讲(更像coding show):&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=icgnqFM-aY4&amp;amp;t=868s&quot; data-linktype=&quot;2&quot;&gt;Talking Async Ep1: Why C++20 is the Awesomest Language for Network Programming&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=hHk5OXlKVFg&quot; data-linktype=&quot;2&quot;&gt;Talking Async Ep2: Cancellation in depth&lt;/a&gt;第一篇基本整个演示了asio从最开始的callback, 到融入c++20 coroutine后的优雅异步表达, 我们可以通过下面的代码片断感受一下:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;asio相关示例代码1&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;awaitable&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt; &lt;span&gt;listen&lt;/span&gt;&lt;span&gt;(tcp::acceptor&amp;amp; acceptor, tcp::endpoint target)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (;;)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; [e, client] = &lt;span&gt;co_await&lt;/span&gt; acceptor.async_accept(use_nothrow_awaitable);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e)&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; ex = client.get_executor();&lt;br/&gt;    co_spawn(ex, proxy(&lt;span&gt;std&lt;/span&gt;::move(client), target), detached);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;asio相关示例代码2&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;auto&lt;/span&gt; [e] = &lt;span&gt;co_await&lt;/span&gt; server.async_connect(target, use_nothrow_awaitable);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!e)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;co_await&lt;/span&gt; (&lt;br/&gt;        (&lt;br/&gt;          transfer(client, server, client_to_server_deadline) ||&lt;br/&gt;          watchdog(client_to_server_deadline)&lt;br/&gt;        )&lt;br/&gt;        &amp;amp;&amp;amp;&lt;br/&gt;        (&lt;br/&gt;          transfer(server, client, server_to_client_deadline) ||&lt;br/&gt;          watchdog(server_to_client_deadline)&lt;br/&gt;        )&lt;br/&gt;      );&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比原来每个async_xxx()函数后接callback的模式, 整个实现可以说是相当的优雅了, 代码的可读性也得到了极大的提高, 这两段代码都来自于上面的演讲中, 想深入了解的可以直接打开相关的链接观看视频, 很推荐大家去看一下.
  能够把复杂的事情用更简洁易懂的方法表达, 这肯定是让人振奋的, 当然, 深入了解相关实现后, 也会发现存在一些问题, 但我们的本意是参考学习, 得出最终想要的可以比较好的支撑并发和异步业务的基础框架, 有这些, 其实已经可以理出一条比较清晰的思路了:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;execution部分主要使用它的sender/receiver概念, 和它提供的一些通用的算法. 移除掉所有因为fallback c++17引入的大量代码噪声. 抛弃它并不完备的各种scheduler实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协程借鉴部分asio的思路, 首先让协程可以基于context上下文, 在跨线程的情况下使用, 另外更多还是使用原有框架有明确的scheduler的方式对所有协程进行管理和定制的模式.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用asio的scheduler部分作为execution的底层scheduler实现, 同时也使用asio的timer表达, 去除原始libunifex依赖不同scheduler提供schedule_at()方法来执行定时器相关逻辑的实现.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据业务需要, 定制一些必要的sender adapter等简化业务的使用.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尝试用execution框架对接ISPC等特殊的并发库, 能够以一个清晰的方式来表达这种混合环境上执行的逻辑.&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列涉及的基础知识和相关内容比较多, 先给出一个临时的大纲, 后续可能会有调整. 目前的思路是先介绍大家相对熟悉度不那么高的execution基础知识和libunifex, 后面再介绍asio相关的scheduler以及coroutine实现, 最后再回归笔者正在迭代的framework, 这样一个顺序来展开.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=IUiNUky-ibM&quot; data-linktype=&quot;2&quot;&gt;One Frame in Halo Infinite&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://think-async.com/Asio/&quot; data-linktype=&quot;2&quot;&gt;asio官网&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://github.com/facebookexperimental/libunifex&quot; data-linktype=&quot;2&quot;&gt;libunifex源码库&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;近期好文：&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649770979&amp;amp;idx=1&amp;amp;sn=040e8980fa1acdde8658d1d64477a531&amp;amp;chksm=beccd89889bb518e24d339637539fee251d9502c2117a6315cbc3efc64be670714439cdf8683&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;月活 12.8 亿的微信是如何防止崩溃的？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;月活 12.8 亿的微信是如何防止崩溃的？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;将在06月08日 19:30 直播&quot; data-intro=&quot;对谈从业22年+技术人：健康码不崩，你就不会想起我&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder-1652418032974586-1817145992&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAjQk0RgWbuwAAAAstQy6ubaLX4KHWvLEZgBPE1aIUFQxWRKKDzNPgMItVt7MBPyPn10ZZD8cXgtf9&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaK0DoUicWmFlI1tRiatibpSGJYcVet7ibjjvECRUqK9JZc39otOsZWpHbTicMJFuVgtiamwqVXeqqzWda9XibWtIs1eiagg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdV9E7ibhl8AQMvrhdGTafob5OnHztc0kEuESsUia6GwebT6o8KIG7wdhcI1YhrhibQRkQ&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;上班打工，下班打碟，work-life balance.&amp;#10;&amp;#10;#产品经理 @内森の日常 &amp;#10;&quot; data-nonceid=&quot;1762807789237249818&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>