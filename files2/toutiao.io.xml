<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>df9fdf5bcf317d82a57ddf0f1d860f7d</guid>
<title>盘点 3 月份 yyds 的开源项目</title>
<link>https://toutiao.io/k/79431xa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

          

          
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>45671d459e18bd6853454cdd828c36af</guid>
<title>服务治理篇-应用架构的演变</title>
<link>https://toutiao.io/k/d3agyd2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;h1&gt;&lt;span&gt;应用架构的演变讲的文章很多了，但是我看这些文章，包括我自己之前写的两篇文章《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484193&amp;amp;idx=1&amp;amp;sn=3b799207a163c7bfe2905669d6956191&amp;amp;chksm=fafde98fcd8a609969265c00796ba2374059679a67d0c14443f9fad5c3e751a9ccf6657a71d7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团分布式服务通信框架及服务治理系统OCTO&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;美团分布式服务通信框架及服务治理系统OCTO&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》和《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485181&amp;amp;idx=1&amp;amp;sn=df4568317a038fcff3b77cd66d0b7bb6&amp;amp;chksm=fafdec53cd8a654573d4210e755fac7c95b5145aa8a5c76cb3df64478a44da0446945ef04c19&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;服务治理的技术血脉&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;服务治理的技术血脉&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》，其实没有把概念讲得特别清楚。感觉乍一看是这么回事，仔细一想满脸问号。&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6093023255813953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicuxFiapRtj510kLcdRajggGpRIfXS0EUiaVeKmzU0moO9seUzzwULGvwrqdthSKGlbMpmRKPXysmfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486103&amp;amp;idx=1&amp;amp;sn=943c5b7f3558df78164321806f273c8f&amp;amp;chksm=fafde039cd8a692f86f0ac97b0e1e05ece075de3e4f33e6a5ec90b269c51aed1963ff3107e0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Dubbo&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;Dubbo&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;官网上有一个架构演进的介绍。并附有下面这张图。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34475374732334046&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicuxFiapRtj510kLcdRajggGibSxmcCiaPHRtlgahhjY7rLTd5nyuxYDJCAG3DcEtjWo6BOibA7k06Mpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内容参考地址：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://dubbo.apache.org/zh/docs/v2.7/user/preface/background/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这段介绍代表了整个业界应用演进的大致方向，但不够全面，侧重于服务治理要解决的问题。本文整体采用&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484931&amp;amp;idx=1&amp;amp;sn=756db99b2fa4ce9c5e9f168d8799d692&amp;amp;chksm=fafdecadcd8a65bb81a0e153e453c2d090c48c73fc7457ccf2b7255f497c441170b651e060e5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;要素型逻辑结构&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;要素型逻辑结构&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;，从不同方面深入对应用架构演变的认知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单一应用架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据库访问框架(ORM)是关键。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1379310344827587&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl94hZoxRU2dIicCkGN7DVicVAArPuRJLsZl0ZR9heQYQLYmGkLIj4qpyCs3gGQ2MBGjJA3xuOSsfZ9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;174&quot;/&gt;&lt;/p&gt;&lt;p&gt;我在07年毕业的时候，基本上项目还是采用这种架构。08年我在日本给著名化妆品公司“资生堂”做项目。这个项目成本估算为300人月。光开发人员就几十个。代码全都写到一个应用中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中我记忆最深的功能是开店和闭店。每天上班要执行开店，就是要启动应用，启动耗时1小时。每天下班要执行闭店，就是关闭应用，关闭耗时1小时还多。这个应用在资生堂所有门店应用之后，门店的工作人员因这个应用要早上班1小时，晚下班1小时。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当时我们是和东芝合作的，也算是日本鼎鼎有名的企业了。这堪比蜗牛的运行速度&lt;span&gt;放在现在简直不可想象。主要就是因为应用做的事情太多了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;那时候还没有代码静态检查、安全扫描、执行全量单元测试检查覆盖率这些常规保障措施。要是有，开发小哥哥更哭了。这些检查执行速度和代码量有很大关系。想想看，资生堂那个项目的话，提交代码到检查完成，按照现在一般的检查执行速度，七八个小时吧。可以想象，DevOps毫无用武之地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前后端分离架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl94hZoxRU2dIicCkGN7DVicVA8SrZicC3vM4iaNdz3ThIhpfJTlukyIh8aoNK5HjRggk81XfVXQHRxOsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;为了解决上面图中四点问题，前后端分离架构应运而生。这种架构前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署。前端只需要关注页面的样式与动态数据的解析&amp;amp;渲染，而后端专注于具体业务逻辑。&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这种架构对应对项目复杂性没有质的改善，最大的作用是开发人员不再需要是全栈工程师，人员分工有了初步的分工。在&lt;span&gt;扩展和协同上的问题依然严峻。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;垂直应用架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当访问量主键增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1272727272727272&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl94hZoxRU2dIicCkGN7DVicVAGM7bz82LX1sPnG8EDDibx71LWTGoB6BNAcTWdMMrsdXQZCdVgF0UcHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;165&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里咱们来思考一个问题：什么是垂直领域？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;09年时我入职人人网。那时人人网刚刚从校内网改名，被炒的很热，招的开发人员背景也都相当的好。那段时间，人人网的技术是经常和百度做比较的。结果却是昙花一现，那么多牛人没能把人人网做得更好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后来很多人出来自己创业，创业时对人人网的失败做自省。很多人就提到要做垂直领域社交，这种普适性的社交缺少个性化优势。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所谓垂直领域就是专业领域。它是社会分工精细化的产物。前后端分离也是一种垂直拆分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是Dubbo官网上介绍应用架构的演变时提到的垂直应用架构并不完全是这个意思。它的垂直拆分更纯粹些，应用之间是完全独立的，很少有交互，就像上面图中的样子。比如微信和QQ。不然也不会说用于加速前端页面开发的Web框架(MVC)是关键。但是在业界说垂直领域、垂直应用都是按专业领域划分没有任何问题。以&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486924&amp;amp;idx=1&amp;amp;sn=99516d226d297fe1a19d9ee252d7672d&amp;amp;chksm=fafde762cd8a6e74f295ce70bed5d4cc4712688d9826bb1e70c251fff1a5757a0633e8244846&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;AKF扩展立方体&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;AKF扩展立方体&lt;/strong&gt;&lt;/a&gt;里对Y轴的描述为准。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式服务架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速地响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.186335403726708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl94hZoxRU2dIicCkGN7DVicVAqicoN8TRhdkas0JH7LG6JjBE1BeodCOyKM8bup4Q18LAWjvnc2VibJVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;161&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;咱们来思考一个问题：什么是分布式？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实分布式是分布式计算的简称。分布式系统就是采用分布式计算的系统。分布式计算是计算机科学中一个研究方向，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给多个计算机进行处理，最后把这些计算结果综合起来得到最终的结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;白话来说：一个程序或系统，只要运行在不同的机器上，都可以叫做分布式。它是以缩短单个任务的执行时间来提升效率的。因为最终需要将结果综合起来，所以关键点在于通信。在这种架构趋势下，以RPC为核心的服务治理应运而生，Dubbo是其中的典型代表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流动计算架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1476190476190475&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicuxFiapRtj510kLcdRajggGEp9r6yE5F4a2VxAibm8gCPxrEL55USKoaicWwwtWft6MkicgdvhdKlV0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;210&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这段来自Dubbo官网的描述，我最初看到的表情是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicuxFiapRtj510kLcdRajggG85iaHuEdkC9oJP5Tic9xsXIVO65ul6xzxrHDsuibuX9vj1dKlTFRmro1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;192&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源调度和治理中心&lt;/span&gt;≈SOA吗？当然不是，SOA是面向服务的意思，Dubbo官网所说的服务专指服务治理平台。服务治理平台负责资源调度和治理中心。它和分布式服务架构的区别是分布式服务架构是应用服务之间彼此通信。而SOA是以服务治理平台为总线，进行统一管理。说白了是SOA的一个应用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里的流动计算架构按照刚才的分析就是面向服务治理的架构。两者是否能划等号呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;流动计算架构按照英文Elastic Computing直译可叫做弹性计算架构，有动态的意思。简单的分布式计算，两两之间通过RPC调用，从一个节点的角度仅能看到其上下游，有点管中窥豹的意味。如果有一个中心节点，它可以站在更大的视角，就可以对整体的请求做动态分发路由了。这就包含将请求发往处理能力更强的节点，如果监控到整体处理能力不足，可以有动态添加节点或者限流熔断等一系列的能力。就是说面向服务治理的架构实现了流动计算。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;云计算架构&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按照Dubbo官网的描述方式，我斗胆给出流动计算架构下一代架构的描述：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当服务数量攀升、复杂性越来越高，由于通信引发的网络调用、限流、熔断和监控等问题需要让开发者不感知，无侵入性的实现。此时，用于服务间通信的基础设施层&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484324&amp;amp;idx=1&amp;amp;sn=78986320566babe59cc2c0da81c7f5b6&amp;amp;chksm=fafde90acd8a601ceff0bb501a0c1f6cd10b5408d3e4fed43d9e6c8605f800297abead8abdf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;服务网格&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;服务网格&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;是关键。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8490566037735849&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicuxFiapRtj510kLcdRajggG4ul4Wy1UHibMfibDNHH1abTOWEzOic08xlHGkv9m5nvoicCm4lOIgibEHHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;像上面一样，咱们来探讨一下云计算架构和服务网格的关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云重点突然一个多字，是服务数量激增量变引起的质变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;服务网格是云计算架构的解决方案。它是将服务治理平台这种PaaS层下沉到IaaS层成为对用户更加透明的基础设施。经常听说某某大厂在做自下而上的服务网格，本质上是将现在公司使用的服务治理不断下沉，让用户体验更加友好的过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本篇文章用阅读理解的方式叙述了应用架构的演变。本质上除了文章中的论点，如之前的很多文章一样，暗线在讲&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485748&amp;amp;idx=1&amp;amp;sn=0ad1457703464924754a49c139c005e0&amp;amp;chksm=fafde39acd8a6a8cbf2073f40f48484fc02d20de48bf917631235c9f3da64a8d82667f47c5d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术学习方法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;技术学习方法&lt;/strong&gt;&lt;/a&gt;：&lt;span&gt;以提出问题为驱动，以解决问题为整合、用输出倒逼输入&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486113&amp;amp;idx=1&amp;amp;sn=f3623b2cf257aa37ea83768fd4325762&amp;amp;chksm=fafde00fcd8a691928c66f7e484ab2b7f6fa7797dc32833a7f777bb4ebde58c010750f13c118&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PDCA方法论&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;PDCA方法论&lt;/strong&gt;&lt;/a&gt;，检查自己是否错过更新：每周三晚上8点左右，我都会更新文章，如果你没有收到，记得点开【编程一生】公众号找一下(*^▽^*)&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b25ec57cb46d07f11e268d89ab279c5f</guid>
<title>边玩游戏，边学编程？试试这款开源游戏</title>
<link>https://toutiao.io/k/yysoke8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;扫描下方二维码，即刻加入！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个免费、开源的多人在线RPG游戏，通过这个游戏，你可以学到现实世界里的编程技能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.9413333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7NkdEX3fXuX73OZ9hWbqCDJFvricbISPEB2mjJ7IeUPk0ibLkQTEepDsZ5z6synq1UPu2RBbPHpzaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a002fdaf7a156ba9dd258f0080f62478</guid>
<title>从实现原理看低代码</title>
<link>https://toutiao.io/k/ekwcd0t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-ql0744&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-pid=&quot;qaYWt5Qb&quot;&gt;我们在低代码领域探索了很多年，从2015 开始研发低代码前端渲染（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baidu.gitee.io/amis&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;amis&lt;/a&gt;），从 2018 年开研发后端低代码数据模型，发布了&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baidu.gitee.io/aisuda-docs/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;爱速搭&lt;/a&gt;低代码平台，这些年调研过了几乎所有市面上的相关技术和产品，发现虽然每家产品细节都不太一样，但在底层技术上却只有少数几种方案，因此我们认为不同产品间的最大区别是实现原理，了解这些实现原理就能知道各个低代码平台的优缺点，所以本文将会介绍目前已知的各种低代码实现方案，从实现原理角度看低代码。&lt;/p&gt;&lt;h2 id=&quot;h_451340998_0&quot; data-into-catalog-status=&quot;&quot;&gt;本文里的「低代码」指的是什么？&lt;/h2&gt;&lt;p data-pid=&quot;uh_eR78U&quot;&gt;在讨论各个低代码方案前，首先要明确「低代码」究竟是什么？&lt;/p&gt;&lt;p data-pid=&quot;ZQmMJRMw&quot;&gt;这个问题不好直接回答，因为低代码是非常宽泛的概念，有很多产品都声称自己的低代码，但我们很容易反过来回答另一个问题：「什么是低代码产品&lt;b&gt;唯一不可缺少&lt;/b&gt;的功能？」&lt;/p&gt;&lt;p data-pid=&quot;aBcjcWAe&quot;&gt;我认为这个功能是&lt;b&gt;可视化编辑&lt;/b&gt;，因为非可视化编辑就是代码编辑，而只有代码编辑的产品不会被认为是低代码，因此可视化编辑是低代码的必要条件，低代码其实还有另一个更清晰的叫法是&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.outsystems.com/blog/posts/what-is-visual-programming/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;可视化编程&lt;/a&gt;。&lt;/p&gt;&lt;p data-pid=&quot;my0GPF1s&quot;&gt;既然可视化编辑是低代码的必要条件，那从实现角度看，实现可视化编辑有什么必要条件？&lt;/p&gt;&lt;p data-pid=&quot;a5w9zd6F&quot;&gt;我认为可视化编辑的必要条件是&lt;b&gt;「声明式」&lt;/b&gt;代码，因为可视化编辑器只支持「声明式」代码。&lt;/p&gt;&lt;p data-pid=&quot;lGyApKj-&quot;&gt;解释一下什么是「声明式」，除了声明式之外还有另一种代码模式是「命令式」，我们分别举两个例子，如果想绘制一个红色区块，用「声明式」来实现，可以使用 HTML+CSS，类似下面的方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;background:red; height:50px&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;TW4V5Ksd&quot;&gt;而换成用「命令式」来实现，可以使用 Canvas API，类似下面的方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;canvas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;2d&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillStyle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;red&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rectangle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Path2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rectangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;hOktm5fR&quot;&gt;虽然最终展现效果是一样的，但这两种代码在实现思路上有本质区别：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;eqdQIdXy&quot;&gt;「声明式」直接描述&lt;b&gt;最终效果&lt;/b&gt;，不关心如何实现。&lt;/li&gt;&lt;li data-pid=&quot;1KWNR-z0&quot;&gt;「命令式」关注如何实现，明确怎么一步步达到这个效果。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;T_W4Zwe4&quot;&gt;从可视化编辑器的角度看，它们的最大区别是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;D-lZYyjZ&quot;&gt;「声明式」可以直接从展现结果反向推导回源码&lt;/li&gt;&lt;li data-pid=&quot;nio8-2GF&quot;&gt;「命令式」无法做到反向推导&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;l1HVqJhw&quot;&gt;反向推导是编辑器必备功能，比如编辑器里的常见操作是点选这个红色区块，然后修改它的颜色，在这两种代码中如何实现？&lt;/p&gt;&lt;p data-pid=&quot;zKk-QWrY&quot;&gt;如果是「声明式」的 HTML+CSS，可以直接改 &lt;code&gt;style&lt;/code&gt; 的 &lt;code&gt;background&lt;/code&gt; 值，而基于 Canvas 的命令式代码则无法实现这个功能，因为无法从展现找到实现它的代码，命令式代码实现同样效果的可能路径是无数的，除了前面的示例，下面这段代码也可以实现一样的效果：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;canvas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;2d&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;beginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;moveTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;strokeStyle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;#ff0000&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lineWidth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stroke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;dCC7GVw4&quot;&gt;甚至有可能这个颜色是多个字符串加随机数拼接而成，即便通过静态分析也找不到来源，从而无法实现可视化修改。&lt;/p&gt;&lt;p data-pid=&quot;B5GcMMFf&quot;&gt;「命令式」代码无法实现可视化编辑，而可视化编辑是低代码唯一不可少的功能，所以我们可以得到结论：&lt;b&gt;所有&lt;/b&gt;低代码平台必然只能采用「声明式」代码，这也是为什么所有低代码平台都会有内置的「DSL」。&lt;/p&gt;&lt;p data-pid=&quot;yOslXCPS&quot;&gt;既然低代码都是声明式，那我们可以通过分析其它「声明式」语言来了解低代码的优缺点，其实在专业研发里，声明式语言在部分领域已经是主流了：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;5Pqv6fJy&quot;&gt;HTML+CSS 是一种页面展现的 DSL&lt;/li&gt;&lt;li data-pid=&quot;bi6qACrq&quot;&gt;SQL 是一种数据查询及处理的 DSL&lt;/li&gt;&lt;li data-pid=&quot;jvYcJHCd&quot;&gt;K8S 的 yaml 是一种服务部署的 DSL&lt;/li&gt;&lt;li data-pid=&quot;2bDxo290&quot;&gt;NGINX conf 是一种反向代理的 DSL&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;O9QUhThz&quot;&gt;上面这些方案目前都是主流，但它们早期并不被看好，比如十几年前还曾经争论过到底是用 B/S 还是 C/S 架构，CSS 2 的功能主要是面向图文排版，并不适合用来构建应用界面。&lt;/p&gt;&lt;p data-pid=&quot;OWoVYd68&quot;&gt;SQL 最开始也不被看好，下面引用《硅谷简史》这本书里的部分文字：&lt;/p&gt;&lt;blockquote data-pid=&quot;NgVoRnmB&quot;&gt;1970年，IBM研究员特德·科德（Ted Codd）发表了一篇里程碑式的论文，《大型数据库的系统模型》，介绍了关系数据库理论。&lt;br/&gt;&lt;br/&gt;当时大多数人认为关系数据库没有商业价值，因其速度太慢，不能满足大规模数据处理或者大量用户存取数据，虽然关系数据库理论上很漂亮而且易于使用，但它的速度太慢。&lt;/blockquote&gt;&lt;p data-pid=&quot;-YCb78N0&quot;&gt;上门两段其实说的是 Oracle 的发家故事，可以看到当时关系型数据库并不被看好，因为大家都觉得慢，这点很好理解，数据库在查询前还得先解析 SQL语法、估算各种查询的代价、生成执行计划，存储也只能使用通用的数据结构，没法根据不同业务进行定制。&lt;/p&gt;&lt;p data-pid=&quot;cB_ribR7&quot;&gt;综合来看这些「声明式」语言有以下优点：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;BYwgiCK_&quot;&gt;&lt;b&gt;容易上手&lt;/b&gt;，因为描述的是结果，语法可以做得简单，非研发也能快速上手 HTML 及 SQL。&lt;/li&gt;&lt;li data-pid=&quot;MOfSNIz3&quot;&gt;&lt;b&gt;支持可视化编辑&lt;/b&gt;，微软的 HTML 可视化编辑 FrontPage 在 1995 年就有了，现在各种 BI 软件可以认为是 SQL 的可视化编辑。&lt;/li&gt;&lt;li data-pid=&quot;HuupG_pw&quot;&gt;&lt;b&gt;容易优化性能&lt;/b&gt;，无论是浏览器还是数据库都在不断优化，比如可以自动改成并行执行，这是命令式语言无法自动实现的。&lt;/li&gt;&lt;li data-pid=&quot;qYoRjOx0&quot;&gt;&lt;b&gt;容易移植&lt;/b&gt;，容易向下兼容，现在的浏览器能轻松渲染 30 年前的 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//info.cern.ch/hypertext/WWW/MarkUp/Tags.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;HTML&lt;/a&gt;，而现在的编译器没法编译 30 年前的浏览器引擎代码。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;w4Q6GQ3v&quot;&gt;而这些语言的缺点是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;DuUk6thI&quot;&gt;&lt;b&gt;只适合特定领域&lt;/b&gt;，命令式的语言比如 JavaScript 可以用在各种领域，但 HTML+CSS 只适合渲染文档及界面，SQL 只适合做查询，所有这些语言都。&lt;/li&gt;&lt;li data-pid=&quot;UBcv1Lqn&quot;&gt;&lt;b&gt;灵活性差&lt;/b&gt;，比如 SQL 虽然内置了很多函数，但想只靠它实现业务是远远不够的，有些数据库还提供了用户自定义函数功能（UDF），通过代码来扩展。&lt;/li&gt;&lt;li data-pid=&quot;nPLax5ya&quot;&gt;&lt;b&gt;调试困难&lt;/b&gt;，遇到问题时如缺乏工具会难以排查，如果你在Firefox出现前开发过页面就会知道，由于IE6没有开发工具，编写复杂页面体验很差，遇到问题要看很久代码才发现是某个标签没闭合或者 CSS 类名写错了。&lt;/li&gt;&lt;li data-pid=&quot;r_w7vdkD&quot;&gt;&lt;b&gt;强依赖运行环境&lt;/b&gt;，因为声明式只描述结果而不关注实现，因此强依赖运行环境，但这也带来了以下问题：&lt;/li&gt;&lt;ul&gt;&lt;li data-pid=&quot;4svJ4kot&quot;&gt;&lt;b&gt;功能取决于运行环境&lt;/b&gt;，比如浏览器对 CSS 的支持程度决定某个属性是否有人用，虽然出现了CSS Houdini 提案，但 Firefox 和 Safari 都不支持，而且上手成本太高，预计以后也不会流行。&lt;/li&gt;&lt;li data-pid=&quot;GV8b333W&quot;&gt;&lt;b&gt;性能取决于运行环境&lt;/b&gt;，比如同一个 SQL 在不同数据库下性能有很大区别。&lt;/li&gt;&lt;li data-pid=&quot;21cTykOn&quot;&gt;&lt;b&gt;对使用者是黑盒&lt;/b&gt;，使用者难以知道最终实现，就像很少人知道数据库及浏览器的实现细节，完全当成黑盒来使用，一旦遇到性能问题就不知所措。&lt;/li&gt;&lt;li data-pid=&quot;FlrkF-a3&quot;&gt;&lt;b&gt;技术锁定&lt;/b&gt;，因为即便是最开放的 HTML 也无法解决，很多年前许多网站只支持 IE，现在又变成了只支持 Chrome，微软和 Opera 在挣扎了很多年后也干脆直接转向用 Chromium。同样的即便有 SQL 标准，现在用的 Oracle/SQL Server 应用也没法轻松迁移到 Postgres/MySQL 上。低代码行业未来也一样，即便出了标准也解决不了锁定问题，更有可能是像&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/w3c/miniapp&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;小程序标准&lt;/a&gt;那样发展缓慢，功能远落后于微信。 &lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-pid=&quot;MwWqr92h&quot;&gt;因为低代码就是一种声明式编程，所以这些「声明式」优缺点，其实就是低代码的优缺点，了解声明式的历史及现状就能更好理解低代码，因为：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;VNW8agaa&quot;&gt;低代码的各种优点是「声明式」所带来的。&lt;/li&gt;&lt;li data-pid=&quot;W5tThpmk&quot;&gt;低代码被质疑的各种缺点也是「声明式」所导致的。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;h_451340998_1&quot; data-into-catalog-status=&quot;&quot;&gt;低代码的实现方案&lt;/h2&gt;&lt;p data-pid=&quot;1qUNYLWO&quot;&gt;说完了声明式，我们就对低代码有了全面认识，接下来进入正题，开始介绍已知的各种低代码实现原理，将会分为前端和后端两部分。&lt;/p&gt;&lt;h2 id=&quot;h_451340998_2&quot; data-into-catalog-status=&quot;&quot;&gt;生成代码的方案算不算低代码？&lt;/h2&gt;&lt;p data-pid=&quot;VYtRlmjz&quot;&gt;在讨论各种方案前，有一种方案比较特别，它虽然也有配置规范或 DSL，甚至有可视化编辑，但最终应用运行是通过生成代码的方式实现的，不依赖依赖运行环境。&lt;/p&gt;&lt;p data-pid=&quot;vboPaM7H&quot;&gt;这个方案最大的优点是可以和专业开发整合，因此灵活性强、可以使用原有的开发流程，本质上和专业开发一样。&lt;/p&gt;&lt;p data-pid=&quot;YSrQ-SUc&quot;&gt;但也有如下缺点：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;0ZI5RJqL&quot;&gt;&lt;b&gt;强依赖研发&lt;/b&gt;，无法做到给非研发使用，因为后续代码需要编译上线。&lt;/li&gt;&lt;li data-pid=&quot;iXMTBRvM&quot;&gt;&lt;b&gt;无法持续可视化编辑&lt;/b&gt;，因为代码无法可视化编辑，生成代码后只要有修改就没法再反向还原成低代码的形式，后续只能代码编辑。&lt;/li&gt;&lt;li data-pid=&quot;Xkurxxrd&quot;&gt;&lt;b&gt;难以实现完全用低代码开发应用&lt;/b&gt;，因为不能生成太复杂的代码，使得这种方案一般不包括交互行为，通常是只有前端界面支持可视化编辑。&lt;/li&gt;&lt;li data-pid=&quot;1nRoddHM&quot;&gt;&lt;b&gt;无法做到向下兼容&lt;/b&gt;，因为生成的那一瞬间代码依赖的框架版本就固定了，目前还没见过哪款前后前端框架做过到完全向下兼容。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Gy5Z2CkJ&quot;&gt;因此我认为生成代码的方案&lt;b&gt;不算&lt;/b&gt;真正的低代码，本质上它还是一种开发辅助方式，一种高级点的脚手架工具，和大部分IDE的生成样板代码能力一样，使用这种方案无法做到持续可视化开发，我还没见过有人将 HTML+CSS 编译成 C++ 代码后二次开发。&lt;/p&gt;&lt;h2 id=&quot;h_451340998_3&quot; data-into-catalog-status=&quot;&quot;&gt;前端代码实现原理 - 界面渲染&lt;/h2&gt;&lt;p data-pid=&quot;KkbRSosU&quot;&gt;前面提到前端 HTML+CSS 可以看成一种描述界面的低代码 DSL，因此前端界面实现低代码会比较容易，只需要对 HTML+CSS 进行更进一步封装，这里以我们的开源项目 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baidu.gitee.io/amis/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;amis&lt;/a&gt; 为例进行介绍。&lt;/p&gt;&lt;p data-pid=&quot;v6siUhwg&quot;&gt;amis 核心原理是将 JSON 转成自研的 React 组件库，然后使用 React 进行渲染。&lt;/p&gt;&lt;p data-pid=&quot;14OuUXz9&quot;&gt;比如下面这段 JSON：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;page&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;页面标题&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;subTitle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;副标题&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;form&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;用户登录&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;input-text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;用户名&quot;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;KpLe2_Mg&quot;&gt;可以理解 amis 原理就是转成了下面这样的 React 组件树，最终由各个 React 组件库渲染 HTML：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Page&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;title=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;页面标题&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;subTitle=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;副标题&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;Form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;title=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;用户登录&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;InputText&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;用户名&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/Form&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Page&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;9-1A9ltY&quot;&gt;虽然也有低代码平台直接使用 HTML+CSS 来实现更灵活的界面控制，但这样做会导致用起来复杂度高，因为通常需要多层嵌套 HTML 才能实现一个组件，使用者还必须熟悉 HTML 及 CSS，上手门槛过高，因此大部分低代码平台都是类似 amis 那样使用 JSON 进行简化。&lt;/p&gt;&lt;p data-pid=&quot;-BpNzbIu&quot;&gt;这里有个小问题，为什么大家几乎全都使用 JSON？我觉得有两方面原因：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;oIbWsaUU&quot;&gt;低代码平台编辑器几乎都是基于 Web 实现，JavaScript 可以方便操作 JSON。&lt;/li&gt;&lt;li data-pid=&quot;I-dK6GFf&quot;&gt;JSON 可以支持双向编辑，它的读取和写入是一一对应的。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;3sZZKGS4&quot;&gt;第二点怎么理解？可以对比一下 YAML，它有引用功能，导致了不好实现双向编辑，比如下面 YAML 示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;root_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&amp;amp;root&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;     &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;l&quot;&gt;/path/to/root/&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;patha&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&amp;amp;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;root_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;*root&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Oz6IhBto&quot;&gt;转成了对应的 JSON 数据后，就变成了&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&quot;paths&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;root_path&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&quot;val&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/path/to/root/&quot;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;patha&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&quot;root_path&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&quot;val&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/path/to/root/&quot;&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Y0FYswdx&quot;&gt;可以看到之前的引用关系没了，而是复制出了一部分，如果直接基于这个数据进行可视化编辑，编辑器在修改的时候就只会改一处，也没法再还原成之前的 YAML 了，要想实现 YAML 可视化编辑就不能先转成 JSON，而是要对 YAML 解析后的树形结构进行操作，前端界面实现成本很高，因此目前还没见过 YAML 的可视化编辑器。&lt;/p&gt;&lt;p data-pid=&quot;mPPOjryI&quot;&gt;但 JSON 的优点就是它的缺点，因为它的用途是数据交换而不是人工编写，导致基于 JSON 构建 DSL 不方便编辑，会有以下 3 个问题：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;O5RTQI91&quot;&gt;不支持注释&lt;/li&gt;&lt;li data-pid=&quot;gL4wbneF&quot;&gt;不支持多行字符串&lt;/li&gt;&lt;li data-pid=&quot;73380pPH&quot;&gt;语法过于严格，比如不支持单引号，不能在最后多写一个逗号&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;QC1MG7pS&quot;&gt;其中我们对这个注释问题进行了特殊支持，开发了带注释的 JSON 解析，存储的时候将注释内嵌到一个特殊的字段中，在代码显示的时候将它提取出来变成注释。&lt;/p&gt;&lt;p data-pid=&quot;ELwcGKIJ&quot;&gt;另外许多低代码平台会将这个 JSON 配置隐藏，只提供界面编辑，但在 amis 可视化编辑器里提供了直接修改 JSON 的功能，因为对于熟悉的开发者，直接编写 JSON 要比在属性面板里找半天效率高，还可以直接将 amis 文档中的示例粘贴进来快速创建。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b7913ed553bad9096e9003170c782c1f_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3830&quot; data-rawheight=&quot;752&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b7913ed553bad9096e9003170c782c1f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3830&quot; data-rawheight=&quot;752&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b7913ed553bad9096e9003170c782c1f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b7913ed553bad9096e9003170c782c1f_b.jpg&quot;/&gt;&lt;figcaption&gt;amis 开始编辑器里 JSON 编辑模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;UsfyKhP1&quot;&gt;前面提到声明式容易向下兼容，amis 自己就是最好的例子，在 amis 诞生的 2015 年前端框架和现在有大量区别：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;nWb4d5mq&quot;&gt;Vue 还是 1，现在已经到 3 了，不向下兼容。&lt;/li&gt;&lt;li data-pid=&quot;3t3gUagK&quot;&gt;Angular 还是 1，现在已经 13 了，不向下兼容。&lt;/li&gt;&lt;li data-pid=&quot;p2Pk52W5&quot;&gt;React 虽然整体用法没变，但有大量细节&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/facebook/react/blob/main/CHANGELOG.md%23breaking-changes&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;不向下兼容&lt;/a&gt;，加上 hooks 推出后，许多第三方库改成了 hooks 版本，导致旧的类组件形式没法直接使用。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;uTO36Dd1&quot;&gt;而 amis 早期的界面配置现在还能继续使用，不受框架升级影响。&lt;/p&gt;&lt;h2 id=&quot;h_451340998_4&quot; data-into-catalog-status=&quot;&quot;&gt;交互逻辑的实现&lt;/h2&gt;&lt;p data-pid=&quot;W56XeObP&quot;&gt;前面说到前端界面低代码是比较容易，但交互及逻辑处理却很难低代码话，目前常见有三种方案：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;B2DMTuXN&quot;&gt;使用图形化编程&lt;/li&gt;&lt;li data-pid=&quot;WUYpAqjs&quot;&gt;固化交互行为&lt;/li&gt;&lt;li data-pid=&quot;CiZR0QWX&quot;&gt;使用 JavaScript&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;z_NPd7sk&quot;&gt;先说第一种图形化编程，这是非常自然的想法，既然低代码的关键是可视化，那直接使用图形化的方式编程不就行了？&lt;/p&gt;&lt;p data-pid=&quot;wbwEn56c&quot;&gt;但我们发现这么做局限性很大，本质的原因是「代码无法可视化」，这点在 35 年前&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//worrydream.com/refs/Brooks-NoSilverBullet.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;没有银弹&lt;/a&gt;的论文里就提到了。&lt;/p&gt;&lt;p data-pid=&quot;SrtQubXv&quot;&gt;为什么代码无法可视化？首先想一想，可视化的前提条件是什么？&lt;/p&gt;&lt;p data-pid=&quot;RSD3oLKH&quot;&gt;答案是需要具备空间形体特征，可视化只能用来展现二维及三维的物体，因为一维没什么意义，四维及以上大部人无法理解，所以如果一个事物没有形体特征，它就没法被可视化。&lt;/p&gt;&lt;p data-pid=&quot;Qn-Mu5Jb&quot;&gt;举个例子，下面是一段 amis中 代码，作用是遍历 JSON 并调用外部函数进行处理：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSONTraverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPlainObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;JSONTraverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;mapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ZBJg0sNq&quot;&gt;虽然只有 10 行代码，却包含了循环、调用函数、类型检测、分支判断、或操作符、递归调用、参数是函数这些抽象概念，这些概念在现实中都找不到形体的，你可以尝试一下用图形来表示这段代码，然后给周围人看看，我相信任何图形化的尝试都会比原本这段代码更难懂，因为你需要先通过不同图形来区分上面的各种概念，其他人得先熟悉这些图形符号才能看懂，理解成本反而更高了。&lt;/p&gt;&lt;p data-pid=&quot;GDwaeyt7&quot;&gt;代码的这些抽象思维&lt;b&gt;难以像积木一样进行拼接&lt;/b&gt;，积木拼接这种方式只适合用来实现简单的逻辑，比如 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//scratch.mit.edu/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;scratch&lt;/a&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-45997472a940d3011b4d9e06648821eb_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2772&quot; data-rawheight=&quot;1464&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-45997472a940d3011b4d9e06648821eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2772&quot; data-rawheight=&quot;1464&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-45997472a940d3011b4d9e06648821eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-45997472a940d3011b4d9e06648821eb_b.jpg&quot;/&gt;&lt;figcaption&gt;Scratch&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;_E5eLDEX&quot;&gt;而前面图形化是低代码唯一不可少的功能，这就使得低代码不适合做复杂的抽象逻辑处理，这是图形化缺陷决定的，因此在复杂逻辑处理方面低代码永远无法彻底取代专业代码开发。&lt;/p&gt;&lt;p data-pid=&quot;8y9mCJXP&quot;&gt;但如果是面向特定领域，低代码平台可以先将这个领域难以图形化的算法预置好，让使用者只需做简单的处理，比如在 Blender 中将 PBR 算法封装了，使用的时候只需要调整参数就行&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5dcfa256ecb603d28106d59591a1540e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2574&quot; data-rawheight=&quot;1286&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-5dcfa256ecb603d28106d59591a1540e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2574&quot; data-rawheight=&quot;1286&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-5dcfa256ecb603d28106d59591a1540e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-5dcfa256ecb603d28106d59591a1540e_b.jpg&quot;/&gt;&lt;figcaption&gt;Blender 中的材质节点编辑&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;6asR7uHu&quot;&gt;如果真要用节点实现这个算法会非常复杂，大概长这样&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c383ec8f36c26ad54fa5e3b94a0c6763_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2732&quot; data-rawheight=&quot;1286&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-c383ec8f36c26ad54fa5e3b94a0c6763_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2732&quot; data-rawheight=&quot;1286&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-c383ec8f36c26ad54fa5e3b94a0c6763_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c383ec8f36c26ad54fa5e3b94a0c6763_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;CWt0PI1x&quot;&gt;在复杂逻辑下，图形中的连线反而变成了视觉干扰，比如下面的例子&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c939299f28b797ead52334bc270a47ec_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1832&quot; data-rawheight=&quot;694&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c939299f28b797ead52334bc270a47ec_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1832&quot; data-rawheight=&quot;694&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c939299f28b797ead52334bc270a47ec_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c939299f28b797ead52334bc270a47ec_b.jpg&quot;/&gt;&lt;figcaption&gt;来自 UE4 Blueprints From Hell 里的一张图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;XHXZ7LA-&quot;&gt;想象一下假设客户做出了上面这个图的复杂逻辑，然后找你排查问题，而客户的程序是部署在内网的，没法导出，只能通过微信拍屏幕给你看。。。&lt;/p&gt;&lt;p data-pid=&quot;zdWiPtYX&quot;&gt;因此我认为图形化不适合用来实现业务逻辑，只适合用来做更高层次流程控制，比如审批流，审批流是现实真实存在的，没有复杂的抽象逻辑，因此适合图形化。&lt;/p&gt;&lt;p data-pid=&quot;S29wyzCe&quot;&gt;在爱速搭中，我们除了实现流程功能，还实现了树形结构的 api 编排功能，它本质上是模仿代码结构，将会在后面进行介绍。&lt;/p&gt;&lt;p data-pid=&quot;n07lrJ1a&quot;&gt;说完了图形化编程，接下来谈第二种方案：固化交互行为，这是不少低代码平台的做法，我们还是以 amis 为例进行介绍。&lt;/p&gt;&lt;p data-pid=&quot;cVKXN8EV&quot;&gt;amis 将常用的交互行为固化并做成了&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baidu.gitee.io/amis/zh-CN/components/action&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;配置&lt;/a&gt;，比如弹框是下面的配置：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;弹框&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;actionType&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dialog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;dialog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;弹框&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;这是个简单的弹框。&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;xxIAE7ou&quot;&gt;除了弹框之外还有发起请求、打开链接、刷新其它组件等，使用固化交互行为有下面两个优点：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;hR4vMSYP&quot;&gt;可以可视化编辑&lt;/li&gt;&lt;li data-pid=&quot;fOldyN5O&quot;&gt;整合度高，比如弹框里可以继续使用 amis 配置，通过嵌套实现复杂的交互逻辑&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Qz8Ip5qO&quot;&gt;但这个方案最大的缺点是灵活性受限，只能使用 amis 内置的行为。&lt;/p&gt;&lt;p data-pid=&quot;m-Jg_e2p&quot;&gt;要实现更灵活的控制，还是得支持第三个方案：JavaScript，目前有的低代码平台只在界面编辑提供可视化编辑，一旦涉及到交互就得写 JavaScript，这和 30 年前的 C++ Builder 本质上是一样的：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9e0b2cca21d0c79e6566f7d2ac588b88_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2814&quot; data-rawheight=&quot;1572&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9e0b2cca21d0c79e6566f7d2ac588b88_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2814&quot; data-rawheight=&quot;1572&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9e0b2cca21d0c79e6566f7d2ac588b88_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9e0b2cca21d0c79e6566f7d2ac588b88_b.jpg&quot;/&gt;&lt;figcaption&gt;RDA Studio 11 的界面编辑&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;cVPua8uE&quot;&gt;但第三个方案的最大缺点就是无法可视化编辑，因此不算是低代码。&lt;/p&gt;&lt;h2 id=&quot;h_451340998_5&quot; data-into-catalog-status=&quot;&quot;&gt;后端低代码的方案&lt;/h2&gt;&lt;p data-pid=&quot;ZCz9bfMA&quot;&gt;前端讨论完了，接下来是后端部分，后端低代码需要解决以下三个问题：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;oJwzINaM&quot;&gt;如何实现自定义数据存储？&lt;/li&gt;&lt;li data-pid=&quot;SaY8dvp4&quot;&gt;如何实现业务逻辑？&lt;/li&gt;&lt;li data-pid=&quot;akFl_leg&quot;&gt;如何实现流程流转？&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;h_451340998_6&quot; data-into-catalog-status=&quot;&quot;&gt;如何自定义数据存储？&lt;/h3&gt;&lt;p data-pid=&quot;Gq7Pp_z1&quot;&gt;低代码平台需要支持用户存储自定义数据，因为每个应用所需的字段是不一样的。&lt;/p&gt;&lt;p data-pid=&quot;Ytja0yrR&quot;&gt;自定义数据存储是后端低代码最重要的功能，使用什么方案将直接影响这个产品的适用范围，目前我们已知有 5 种方案，每种都有自己的优缺点。&lt;/p&gt;&lt;h3 id=&quot;h_451340998_7&quot; data-into-catalog-status=&quot;&quot;&gt;存储的实现方案 1：直接使用关系型数据库&lt;/h3&gt;&lt;p data-pid=&quot;RduTesLT&quot;&gt;这个方案的原理是将数据模型的可视化操作转成数据库 DDL，比如添加了一个字段，系统会自动生成表结构变更语句：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;blog&#x27;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;title&#x27;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;pyWNdshR&quot;&gt;这个方案的优点是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;MXozFbqh&quot;&gt;所有方案里唯一支持直连外部数据库，可以对接已有系统。&lt;/li&gt;&lt;li data-pid=&quot;Y9lg4jj6&quot;&gt;性能高和灵活性强，因为可以使用高级 SQL。&lt;/li&gt;&lt;li data-pid=&quot;DaE9w20Z&quot;&gt;开发人员容易理解，因为和专业开发是一样的。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;9JcRSZb3&quot;&gt;但它的缺点是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;sLL5_FoN&quot;&gt;需要账号有创建用户及 DDL权限，如果有安全漏洞会造成严重后果，有些公司内部线上帐号没有这个权限，导致无法实现自动化变更。&lt;/li&gt;&lt;li data-pid=&quot;BJP11hta&quot;&gt;DDL 有很多问题无解，比如在有数据的情况下，就不能再添加一个没有默认值的非 NULL 字段。&lt;/li&gt;&lt;li data-pid=&quot;bjpY5Knb&quot;&gt;DDL 执行时会影响线上性能，比如 MySQL 5.6 之前的版本在一个大数据量的表中添加索引字段会&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//download.nust.na/pub6/mysql/doc/refman/5.5/en/create-index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;锁整个表的写入&lt;/a&gt;（但也有数据库不受影响，比如 TiDB、OceanBase 支持&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pingcap.com/zh/blog/tidb-source-code-reading-17&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在&lt;/a&gt;线表结构变更，不会阻塞读写）。&lt;/li&gt;&lt;li data-pid=&quot;HU7VVFm9&quot;&gt;部分数据库不支持 DDL 事务，比如 MySQL 8 之前的版本，导致一旦在执行过程中出错将无法恢复。&lt;/li&gt;&lt;li data-pid=&quot;upAPl9sK&quot;&gt;实现成本较高，需要实现「动态实体」功能，如果要支持不同数据库还得支持各种方言。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;4mVy7ZrR&quot;&gt;尽管这个方案有很多缺点，但它的优点也很突出，因此爱速搭里实现了这个方案，因为我们觉得能连已有数据库是非常重要的，其它方案都只适合用来做新项目，这个方案使得可以逐步将已有项目低代码化，不需要做数据迁移。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-743d93ccb2444838742bbaa709ff7175_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3798&quot; data-rawheight=&quot;1680&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-743d93ccb2444838742bbaa709ff7175_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3798&quot; data-rawheight=&quot;1680&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-743d93ccb2444838742bbaa709ff7175_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-743d93ccb2444838742bbaa709ff7175_b.jpg&quot;/&gt;&lt;figcaption&gt;爱速搭里的数据库模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xKK1ZtbZ&quot;&gt;实现这个方案的关键是「动态实体」，在专业开发中实体（Entity）定义都是静态的，以 Java 为例，它从 2006 年开始就有专门的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//jakarta.ee/specifications/persistence/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JPA&lt;/a&gt; 规范，但这个规范是定义基于 Java 代码注解，使得需要经过编译才能使用，毕竟它的定位是面向专业开发，只有写在代码里才能支持代码提示，提升开发体验，而低代码平台中需要将这个实体定义抽象成配置，在运行时动态生成实体，如果使用 JPA 就需要生成 Java 代码后进行编译，这很容易出错，不太适合低代码平台，所以使用这个方案需要实现「动态实体」功能，是整个方案最大难点。&lt;/p&gt;&lt;h3 id=&quot;h_451340998_8&quot; data-into-catalog-status=&quot;&quot;&gt;存储的实现方案 2：使用文档型数据库&lt;/h3&gt;&lt;p data-pid=&quot;mdVSA2Bu&quot;&gt;文档型数据库不需要预先定义表结构，因此它很适合用来存储用户自定义数据，这个方案实现起来比较简单，以 MongoDB 为例，可以这样做：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;wV1hbWHs&quot;&gt;用户创建一个自定义表的时候，系统就自动创建一个 collection，所有这个表的数据都存在这个 collection 里。&lt;/li&gt;&lt;li data-pid=&quot;HiuOMWx0&quot;&gt;用户新增字段的时候，就随机分配一个  fileId，后续对这个字段的操作都自动映射到这个 fileId 上，用 fileId 的好处是用户重命名字段后还能查找之前的数据，因为所有数据查询底层都基于这个 fileId。&lt;/li&gt;&lt;li data-pid=&quot;hfELBe96&quot;&gt;查询的时候先找到对应的 collection，再通过 meta 信息查询字段对应的 fileId，使用这个 fileId 来获取数据。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;HPGXoJdz&quot;&gt;这个方案的优点是实现简单，用户体验可以做得更好，是目前大部分零代码平台的选择，使用这个方案的产品也很好识别，只要看一下它的私有部署文档，如果有要求装 MongoDB 就肯定是。&lt;/p&gt;&lt;p data-pid=&quot;tS8oWHQJ&quot;&gt;但这个方案也有显著缺点：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;E2g9pfGN&quot;&gt;无法支持外部数据库，数据是孤岛，外部数据接入只能通过导入的方式。&lt;/li&gt;&lt;li data-pid=&quot;rG8IpajQ&quot;&gt;MongoDB 在国内发展缓慢，接受度依然很低，目前还没听说有哪家大公司里最重要的数据存在 MongoDB 里，一方面有历史原因，另一方面不少数据库都开始支持 JSON 字段，已经能取代大部分必须用 MongoDB 的场景了。&lt;/li&gt;&lt;li data-pid=&quot;em6bdo9F&quot;&gt;不支持高级 SQL 查询。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;rx6fn8cf&quot;&gt;你可能会问，现在 MySQL、Postgres 等数据库都支持 JSON  字段类型了，是否可以用这个字段来实现低代码？答案是不太行，只适合数据量不大的场景，虽然 JSON 字段可以用来存用户自定义数据，但无法创建字段索引，比如在 MySQL 要想给 JSON 创建索引，还是得创建一个特殊的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;字段&lt;/a&gt;，这又需要 DDL 权限了，没有索引会导致这个方案无法支持大量数据查询。&lt;/p&gt;&lt;p data-pid=&quot;8t1oo-uQ&quot;&gt;在爱速搭中我们也实现这个方案，目前是基于 MySQL JSON 字段，后续可能也会支持存储使用 MongoDB，目前它的使用场景是流程执行过程中的数据存储，因此数据量不会很大，我们希望流程功能用起来可以更简单些。&lt;/p&gt;&lt;p data-pid=&quot;JoOWsuVj&quot;&gt;它的最大特点是界面编辑和数据存储是统一的，当你拖入文本框到页面后就会自动创建对应的字段，不需要先创建数据模型再创建界面，因此用起来更简单。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2a5b1717317e2f50657d14bd91ea9633_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2578&quot; data-rawheight=&quot;1648&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-2a5b1717317e2f50657d14bd91ea9633_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2578&quot; data-rawheight=&quot;1648&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-2a5b1717317e2f50657d14bd91ea9633_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2a5b1717317e2f50657d14bd91ea9633_b.jpg&quot;/&gt;&lt;figcaption&gt;爱速搭里的表单模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;h_451340998_9&quot; data-into-catalog-status=&quot;&quot;&gt;存储的实现方案  3：使用行代替列&lt;/h3&gt;&lt;p data-pid=&quot;87BBotGU&quot;&gt;这是很多可扩展平台里使用的技术，比较典型的是 WordPress，它的扩展性很强，装个扩展就能变成电商网站。而整个 WordPress 只有 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//codex.wordpress.org/Database_Description&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;12&lt;/a&gt; 个表，它是怎么做到的？方法是靠各种 meta 表，比如用于扩展文章的 &lt;code&gt;wp_postmeta&lt;/code&gt; 表结构如下&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wp_postmeta&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;meta_id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bigint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auto_increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;post_id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bigint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;0&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;meta_key&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;meta_value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;longtext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meta_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post_id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meta_key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meta_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COLLATE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utf8_general_ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;xvr9FRLM&quot;&gt;其中的关键就是 &lt;code&gt;meta_key&lt;/code&gt; 和 &lt;code&gt;meta_value&lt;/code&gt; 这两个字段，相当于将数据库当 KV 存储用了，因此可以任意扩展字段名及值。&lt;/p&gt;&lt;p data-pid=&quot;x3MLsG2V&quot;&gt;这个方案的优点是实现简单，但缺点也很明显：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;x8fU7HNo&quot;&gt;查询性能低，如果有 10 个字段就要查 10 行。&lt;/li&gt;&lt;li data-pid=&quot;ma4s5Zo2&quot;&gt;无法支持 SQL 高级查询，因为数据是按行存的。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;rhvSkhfV&quot;&gt;这个方案主要用于成熟项目的扩展，比如在 CRM 产品中允许用户扩展字段，但因为性能较低，并不适合通用低代码平台。&lt;/p&gt;&lt;h3 id=&quot;h_451340998_10&quot; data-into-catalog-status=&quot;&quot;&gt;存储的实现方案 4：元信息+宽表&lt;/h3&gt;&lt;p data-pid=&quot;s160uLhh&quot;&gt;早期数据库不支持 JSON 字段的时候，有些开发者会预留几个列来给用户扩展自定义属性，比如在表里加上 ext1、ext2、ext3 字段，让用户可以存 3 个定制数据，基于这个原理我们可以进一步扩展，通过预留大量列来实现应用自定义存储。&lt;/p&gt;&lt;p data-pid=&quot;cAa5Xh52&quot;&gt;这个方案最早出现在 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//force.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;force.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;，具体细节可以阅读它&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.salesforce.com/wiki/multi_tenant_architecture&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;架构说明文档&lt;/a&gt;。&lt;/p&gt;&lt;p data-pid=&quot;w_H-pUUI&quot;&gt;实现它有两个关键点：元数据、预留列，这里简单说明一下原理，首先系统预先创建一个 500 列的表，比如就叫 data：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;tenant_id&lt;/th&gt;&lt;th&gt;table_id&lt;/th&gt;&lt;th&gt;uuid&lt;/th&gt;&lt;th&gt;value0&lt;/th&gt;&lt;th&gt;value1&lt;/th&gt;&lt;th&gt;...&lt;/th&gt;&lt;th&gt;value 4000&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;&lt;td/&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-pid=&quot;ts4GmrF-&quot;&gt;也可以创建更多，但注意有的数据库对列的数量有限制，比如 MySQL 最多是 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/refman/8.0/en/column-count-limit.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;4096&lt;/a&gt; 列。&lt;/p&gt;&lt;p data-pid=&quot;2YTdbFxZ&quot;&gt;上面的 data 表里主要有 4 类字段：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;hu9GRkA7&quot;&gt;tenant_id 是租户 id，用于隔离不同租户&lt;/li&gt;&lt;li data-pid=&quot;F9TcFDqZ&quot;&gt;table_id 是自定义表的 id&lt;/li&gt;&lt;li data-pid=&quot;SIULlk0J&quot;&gt;uuid 是具体这一行数据的 id&lt;/li&gt;&lt;li data-pid=&quot;IQlgxskZ&quot;&gt;后面的 value0 到 value500 都是预留的列，用于存储实际数据，一般使用变长字符串类型&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Rx10rapa&quot;&gt;当用户给这个表新增一个字段的时候，怎么知道这个字段放哪？这就需要另一个用于描述字段信息的元数据表，比如增加一个「标题」字段时，使用另一个 table_fields 表来描述这个字段的信息，示例如下：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;tenant_id&lt;/th&gt;&lt;th&gt;table_id&lt;/th&gt;&lt;th&gt;field_id&lt;/th&gt;&lt;th&gt;value_index&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;type&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;标题&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-pid=&quot;Jou87cz3&quot;&gt;在这个 table_fields 表里：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;VfkP1SX3&quot;&gt;tenant_id 和 table_id 和前面一样。&lt;/li&gt;&lt;li data-pid=&quot;bikk1Xg_&quot;&gt;field_id 对应的是给这个「标题」字段分配的 id。&lt;/li&gt;&lt;li data-pid=&quot;vcIXhttL&quot;&gt;value_index 对应前面那个 data 表里预览列的位置，比如这个值是 0，就意味着 value0 列被分配给了这个「标题」字段。&lt;/li&gt;&lt;li data-pid=&quot;jkNv3Rc2&quot;&gt;name 用来存名称，type 用来标识类型，这样查询和写入数据的时候，首先从这里查询 value_index 是什么，然后再去前面那个预留列的表中查询对应列的值。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;viTBSj2t&quot;&gt;最终在实际查询的时候需要根据元数据表做一下转换，比如 &lt;code&gt;select 标题 from blog&lt;/code&gt; 要转成 &lt;code&gt;select value0 from data where tenal_id = 1 and table_id = 1&lt;/code&gt;。 &lt;/p&gt;&lt;p data-pid=&quot;v-GD3hni&quot;&gt;要完全实现这个方案还有很多细节问题得解决，由于篇幅原因这里不详细介绍，感兴趣可以阅读前面提到的 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//force.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;force.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 技术白皮书，这里列举其中几个问题：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;Jyja3Lk9&quot;&gt;因为存储只能是字符串，所以对于日期、数字等其他类型，因此读取的时候需要根据类型使用数据库里的函数进行转换，比如 &lt;code&gt;STR_TO_DATE&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;jilrzM8Z&quot;&gt;需要单独处理唯一性功能，因为这个数据表是所有租户共用的，没法设置表级别的唯一性索引，这时就需要新建一个表来单独做，坏处是数据多份容易产生不一致，需要在所有更新操作都加事务。&lt;/li&gt;&lt;li data-pid=&quot;iJTJvAGI&quot;&gt;需要单独处理索引功能，同样是因为字段是字符串，因此没法直接在 &lt;code&gt;data&lt;/code&gt; 表里加索引，如果数据存储的是数字，排序就是错的，为了解决这个问题需要另外创建一个一个包含常见字段的索引表，数据更新的时候。&lt;/li&gt;&lt;li data-pid=&quot;NK85gOI3&quot;&gt;自增字段需要自己实现。&lt;/li&gt;&lt;li data-pid=&quot;98BLn0a8&quot;&gt;元数据信息需要缓存，不然每次查询前都需要先查询元数据信息，然后再去查询真正的数据。 &lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;5E_h1CSL&quot;&gt;这个方案比前面几个方案的优点是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;E5FxXxhX&quot;&gt;比起第一种原生数据库表方案，它不需要 DDL 操作，不容易出问题，跟适合 SaaS 产品。&lt;/li&gt;&lt;li data-pid=&quot;6MZ-xMDW&quot;&gt;比起第二种文档型数据库方案，它的存储使用更为成熟的关系型数据库，相关的运维工具多。&lt;/li&gt;&lt;li data-pid=&quot;MZ7nLC9Y&quot;&gt;比起第三种行代替列方案，它的查询性能好，因为是读取一行数据。 &lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;oXZpdQZn&quot;&gt;但它也有许多缺点：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;6LDBxXlo&quot;&gt;&lt;b&gt;无法支持 SQL 所有功能&lt;/b&gt;，比如 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//force.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;force.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 的 SOQL 无法 &lt;code&gt;select *&lt;/code&gt;、没有视图、不支持写入和更新数据，通过这个特点就能识别出使用这个方案的产品，这类产品虽然看起来很像在用传统数据库，也支持使用 SQL，但这个 SQL 一定是受限的。&lt;/li&gt;&lt;li data-pid=&quot;-_-GXpMD&quot;&gt;&lt;b&gt;数据泄露风险高&lt;/b&gt;，因为所有租户的数据都存在一张表里，而数据库都不支持行级别权限的账号，所以意味着所有租户其实共享一个数据库账号，只要有某个功能的查询漏了加租户过滤就能查到所有租户数据。相比之下前面提到的原生表及文档型数据库方案都能直接使用数据库自带的账号进行有效隔离。&lt;/li&gt;&lt;li data-pid=&quot;-PeAfSwO&quot;&gt;&lt;b&gt;一些数据库高级字段难以支持&lt;/b&gt;，比如坐标数据、二进制类型等，只能用单独的表存，导致了查询开销。&lt;/li&gt;&lt;li data-pid=&quot;6TuEa7S-&quot;&gt;&lt;b&gt;整体实现成本高&lt;/b&gt;，其中很多细节需要处理好，比如保证数据一致性，因为为了实现唯一性、索引等功能需要拷贝数据，更新的时候要同时更新。 &lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;jx3USE5q&quot;&gt;爱速搭中没有实现这个方案，我们曾经考虑过但后来放弃了，我认为这个方案虽然很适合 SaaS 类的低代码产品，但它的用户定位比较尴尬，一方面是有一定复杂度导致不能做到零代码平台那样的易用性，另一方面是有不少限制导致专业研发不喜欢，所以最终是两边都不讨好，这种产品想做成需要依赖广泛使用的平台，因此 Salesforce 才能做成，而国内类似情况我能想到的唯一成功案例是微信小程序，尽管有很多限制，但因为微信广泛使用，所以才成功了，如果是一个独立的小程序平台肯定没人用。 &lt;/p&gt;&lt;p data-pid=&quot;hB0rgAe8&quot;&gt;这里说一段小历史，在十几年前，当时云计算领域最先推出的是谷歌 2008 年发布的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Google_App_Engine&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;App Engine&lt;/a&gt;，这是谷歌的第一个云产品，而当时类似 AWS EC2 那样的虚机产品国内都还没有，毕竟 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Kernel-based_Virtual_Machine&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;KVM&lt;/a&gt; 也才刚发布。如果你当时问云计算的专家，云计算的未来是 App Engine 还是虚拟机，我听到不少专家的回答是 App Engine，因为这看起来更有前景，你只需要写代码，不用操心运维，平台会自动水平扩展，这才是云该有的样子，当时国内不少公司都推出了类似产品。&lt;/p&gt;&lt;p data-pid=&quot;7mLzJOLN&quot;&gt;但 13 年后的今天，国内 App Engine 平台几乎都关闭了，而虚机不但是主流，还更进一步出现了物理机产品。这个元信息方案给我的感觉和当年 App Engine 很像，看上去能完成增删改查的简单应用，但如果深入就发现缺少很多功高级功能，导致两边不讨好：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;UTJRjYaU&quot;&gt;技术薄弱的开发者不会用，比如因为 App Engine 是分布式部署，导致上传文件不能放本地，必须改成对象存储，所以没法直接用 WordPress 没法用，对于小站长来说还不如用虚拟主机。&lt;/li&gt;&lt;li data-pid=&quot;TXv7DLu6&quot;&gt;对于有技术实力的开发者，又会觉得平台能力受限，不利于自己后续发展，比如谷歌的 App Engine 直到 2019 年才支持 WebSocket。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Yuxfxy3F&quot;&gt;整体而言我不看好这个方案在国内的发展。&lt;/p&gt;&lt;h3 id=&quot;h_451340998_11&quot; data-into-catalog-status=&quot;&quot;&gt;存储的实现方案 5：使用单文件&lt;/h3&gt;&lt;p data-pid=&quot;RYvV8TBK&quot;&gt;这个方案目前只在「仿 Excel」的零代码平台中见过，它和 Excel 类似，数据全都放一个文件里，查询过滤完全靠前端，优点是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;I5N0Fq1F&quot;&gt;实现简单，部署成本低，因为表的存储就是单文件。 &lt;/li&gt;&lt;li data-pid=&quot;ek5QfhE_&quot;&gt;容错性强，数据类型都是靠前端处理的，不会出现存数据库导致。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;EFVwVBYP&quot;&gt;缺点是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;GfFM_b4G&quot;&gt;如果要支持行列级别权限校验，还得在后端实现一遍过滤，而每次都加载一个巨大的 JSON 文件对服务器内存有较高要求。&lt;/li&gt;&lt;li data-pid=&quot;En8VFY3p&quot;&gt;难以支持事务操作，尤其是支持行级别的操作。&lt;/li&gt;&lt;li data-pid=&quot;lyth7y6f&quot;&gt;目前看十万级别数据处理可以只靠前端，但再大量的数据就不合适了，一次性加载太多对带宽和浏览器内存要求比较高。&lt;/li&gt;&lt;li data-pid=&quot;4ZaTk2zU&quot;&gt;只能当成 Excel 的替代品，数据是孤岛，不能直连外部数据库。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;CPuBuH6Q&quot;&gt;这个方案比较特殊，主要工作量在前端，有大量细节体验优化，在爱速搭中没实现，后续可能会考虑。&lt;/p&gt;&lt;h3 id=&quot;h_451340998_12&quot; data-into-catalog-status=&quot;&quot;&gt;后端业务逻辑的实现&lt;/h3&gt;&lt;p data-pid=&quot;2aq7xObk&quot;&gt;说完了存储，接下来是第二个问题：如何实现后端业务逻辑？&lt;/p&gt;&lt;p data-pid=&quot;KnYfS7Am&quot;&gt;前面提到过代码难以图形化，这在后端也是一样的，因此大概有这几种方案：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;v-cGbuGM&quot;&gt;逻辑图形化，这个目前看各个产品效果都不太理想，看上去还不如代码易读。&lt;/li&gt;&lt;li data-pid=&quot;H8cypP1x&quot;&gt;固定行为，主要是对数据存储提供增删改查操作。&lt;/li&gt;&lt;li data-pid=&quot;aZ2JBFsC&quot;&gt;支持 JavaScript 自定义。&lt;/li&gt;&lt;li data-pid=&quot;pecniUcY&quot;&gt;简化 DSL 语言，类似 Excel 中的公式。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;vuQRNBef&quot;&gt;前面两种方案之前介绍过了，这里只讨论后面两种。&lt;/p&gt;&lt;p data-pid=&quot;lIZ85zh0&quot;&gt;后端支持使用 JavaScript 是种常见做法，主要原因是 JavaScript 引擎容易被嵌入，而且启动速度快，了解的人多，比如市值超过 1200 亿美元的 ServiceNow 后端自定义业务逻辑就是基于 Rhino 引擎实现的。&lt;/p&gt;&lt;p data-pid=&quot;m0pt9T1V&quot;&gt;简化 DSL 语言的主要是使用场景是做表达式计算，比如在流程中的分支流转规则判断，需要用户能自定义表达式，比如金额大于多少换成总监审批，这时用公式会比 JavaScript 会更简单，因为系统可以自动转换数据类型，并自动处理异步函数的调用，目前爱速搭的流程里有实现，同时在 amis 里也&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baidu.gitee.io/amis/zh-CN/docs/concepts/expression%23%25E6%2596%25B0%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E8%25AF%25AD%25E6%25B3%2595&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;提供了&lt;/a&gt;。&lt;/p&gt;&lt;p data-pid=&quot;57kdh6Na&quot;&gt;另外除了上面提到这四种，我们在爱速搭中还设计了另一个方案：执行树，它长这个样子：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a84a188166e9e7d6bdeb273155191b2e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2124&quot; data-rawheight=&quot;1178&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-a84a188166e9e7d6bdeb273155191b2e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2124&quot; data-rawheight=&quot;1178&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-a84a188166e9e7d6bdeb273155191b2e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a84a188166e9e7d6bdeb273155191b2e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Q8qj77Gg&quot;&gt;左侧是树形结构，右侧是点中某个节点时的参数配置，左侧的树形结构其实是直接参考代码的树形结构：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;QrnCZiWT&quot;&gt;默认从上往下执行，但有个特殊的「并行执行」节点可以并行执行。&lt;/li&gt;&lt;li data-pid=&quot;AMZJ91A3&quot;&gt;对于循环和分支会创建子节点，并且子节点可以无限嵌套，相当于代码里的花括号。&lt;/li&gt;&lt;li data-pid=&quot;pEuJ0qnU&quot;&gt;节点可以折叠，这样就能先将复杂的逻辑折叠起来方便看主流程，这是使用图模式难以实现的，在图里收起后无法修改其它节点的位置，导致空出一块。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;NtSbaEKl&quot;&gt;为了方便实现简单逻辑处理，我们还增加了 JavaScript 节点和 SQL 节点。&lt;/p&gt;&lt;p data-pid=&quot;DHp_e39L&quot;&gt;但执行树这个方案目前的定位是聚合多接口，将多个后端接口数据合并后给前端，类似于 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//samnewman.io/patterns/architectural/bff/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;BFF&lt;/a&gt; 的作用，我们推荐复杂的后端逻辑还是用 Spring Boot 吧，成熟稳定且好招人。&lt;/p&gt;&lt;h3 id=&quot;h_451340998_13&quot; data-into-catalog-status=&quot;&quot;&gt;流程的实现&lt;/h3&gt;&lt;p data-pid=&quot;CuMBTU6A&quot;&gt;接下来是第三个问题：如何实现流程？这是大部分低代码平台标配的功能，流程的逻辑不像普通代码那么抽象，因此适合用可视化编辑。&lt;/p&gt;&lt;p data-pid=&quot;1zz8IC2c&quot;&gt;流程可视化存在很久了，著名的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Business_Process_Model_and_Notation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;BPMN&lt;/a&gt; 规范最早版本在 2004 就发布了，因此大部分产品都会支持 BPMN 2.0 规范。&lt;/p&gt;&lt;p data-pid=&quot;2swbJNJ4&quot;&gt;但 BPMN 本质上是一种图形规范，它的最大作用是给事件、动作及分支条件这些抽象概念分配了不同的形体，使得熟悉这个规范的用户有了共同语言。&lt;/p&gt;&lt;p data-pid=&quot;v2-tAvoz&quot;&gt;BPMN 不能解决平台锁定问题，在一个平台开发的流程无法直接迁移到另一个平台。&lt;/p&gt;&lt;p data-pid=&quot;O805g4id&quot;&gt;流程的核心是实现流程流转引擎，以爱速搭为例，流程可视化布局后最终存储的格式是有向图，比如下面这个最简单流程：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d10d6e0243e0f6d9a4f7bc430c3d8588_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;614&quot; data-rawheight=&quot;150&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d10d6e0243e0f6d9a4f7bc430c3d8588_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;614&quot; data-rawheight=&quot;150&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d10d6e0243e0f6d9a4f7bc430c3d8588_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d10d6e0243e0f6d9a4f7bc430c3d8588_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;J0zZS9MH&quot;&gt;简化后的存储数据格式是两条连线和三个节点：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;lines&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;d4ffdd0f6829&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;to&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;4a055392d2e1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;from&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;e19408ecf7e3&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;79ccff84860d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;to&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;724cd2475bfe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;from&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;4a055392d2e1&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&quot;nodes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;e19408ecf7e3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;开始&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;4a055392d2e1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;examine-and-approve-task&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;审批节点&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;724cd2475bfe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;end&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;结束&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;9_Hur8tV&quot;&gt;流程流转算法的核心就是根据当前状态和这个有向图，判断出下个节点是什么，然后执行那个节点的操作。&lt;/p&gt;&lt;p data-pid=&quot;PBrkOm7N&quot;&gt;同时因为主要面向的是审批流，所以还需要处理审批场景特有的逻辑，比如有的审批是全部通过才算通过，有的审批是只需要一个人通过就算通过，还有回退、加签等功能，并处理各种边界条件，比如找不到审批人的时候怎么办。&lt;/p&gt;&lt;p data-pid=&quot;jw3s_UbY&quot;&gt;虽然目前业界有开源的流程引擎，但这些引擎大多是面向代码开发，不太好改造成平台模式，因此在爱速搭里自己实现了流程引擎，这样才能更好定制功能。&lt;/p&gt;&lt;h2 id=&quot;h_451340998_14&quot; data-into-catalog-status=&quot;&quot;&gt;低代码平台未来会怎样？&lt;/h2&gt;&lt;p data-pid=&quot;CyUXMn6o&quot;&gt;前面提到了各种低代码的实现方案细节，这里抛开具体细节，来整体讨论一下未来低代码平台会怎样。&lt;/p&gt;&lt;p data-pid=&quot;QVWttenF&quot;&gt;最开始提到过低代码唯一不可缺少的功能是可视化编辑，这是低代码的最大优势，但是低代码的最大缺陷，因为可视化难以表达复杂的抽象逻辑，因此长远看低代码并不会在所有领域取代专业开发，更多是和专业开发配合来提升效率。&lt;/p&gt;&lt;p data-pid=&quot;j_eBZstY&quot;&gt;从技术方案上看低代码平台主要有两个方向：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;leHL1sz1&quot;&gt;偏向零代码的方案，它的特点是&lt;/li&gt;&lt;ul&gt;&lt;li data-pid=&quot;jTBypS3k&quot;&gt;易用性强&lt;/li&gt;&lt;li data-pid=&quot;dh82aPO2&quot;&gt;灵活性差&lt;/li&gt;&lt;li data-pid=&quot;iRGZVT2c&quot;&gt;适合小公司，客单价低，但客户数多&lt;/li&gt;&lt;li data-pid=&quot;mynJg3WI&quot;&gt;标准化程度高，导致功能都很类似，将面临同质化竞争&lt;/li&gt;&lt;li data-pid=&quot;MPm9rzN4&quot;&gt;产品使用简单，客户支持成本低 &lt;/li&gt;&lt;/ul&gt;&lt;li data-pid=&quot;Ohy2t5pp&quot;&gt;偏向专业开发的方案，它的特点是&lt;/li&gt;&lt;ul&gt;&lt;li data-pid=&quot;Q3QpJ6du&quot;&gt;易用性弱&lt;/li&gt;&lt;li data-pid=&quot;Gj79kwog&quot;&gt;灵活性强&lt;/li&gt;&lt;li data-pid=&quot;T6QiCyiv&quot;&gt;适合中大型公司，客户数少，但客单价高&lt;/li&gt;&lt;li data-pid=&quot;MK8PlCQI&quot;&gt;标准化程度低，每家都有各自的特点&lt;/li&gt;&lt;li data-pid=&quot;dDFI7_ir&quot;&gt;产品使用复杂，客户支持成本高&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-pid=&quot;HiQbuwNP&quot;&gt;未来会怎样呢？我的想法是：&lt;/p&gt;&lt;p data-pid=&quot;kRtL1pkY&quot;&gt;偏向零代码方案，因为功能类似支持成本低，可以同时支持很多用户，容易出现赢者通吃的情况，但由于 toB 领域发展速度慢，所以还是有不少机会，可以类比 BI 数据可视化产品，BI 这个领域的软件出现至少 20 年了，比如 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Qlik&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qlik&lt;/a&gt; 1994 就发布了，现在市面上的 BI 软件在基本功能上都大体相同，但没有哪个产品占据绝大部分市场份额，我们的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//cloud.baidu.com/product/sugar.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Sugar&lt;/a&gt; 产品虽然两年前才推出，但依然得到了不少优质客户，所以只要产品优秀就有机会。&lt;/p&gt;&lt;p data-pid=&quot;mEp8uFod&quot;&gt;零代码产品有好几种形态，和去年一样，我更看好「在线 Excel」，因为既然是面向非开发者，类 Excel 是上手成本最低的方案，而且这一年来许多「在线 Excel」的产品都加上了低代码功能，比如 Airtable 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.airtable.com/interfacebuilder/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Interface&lt;/a&gt;，在功能上和表单驱动的零代码越来越接近了。&lt;/p&gt;&lt;p data-pid=&quot;2U5Faafv&quot;&gt;而偏向专业开发的方案，因为支持成本高导致没法同时支持很多客户，因此更难出现一家独大的情况，而偏向研发会导致细节方案有很多区别，没太多可比性。&lt;/p&gt;&lt;p data-pid=&quot;GNIaavNq&quot;&gt;以我们的爱速搭为例，目前产品选择的方案是偏向专业开发，现有客户都是知名企业，但也导致了支持成本很高，因为客户问的问题都很专业，大多只有核心研发才能解答，在功能方面我们的特点是前端使用了我们开源的 amis 框架，这个其它家是不会提供的。&lt;/p&gt;&lt;h2 id=&quot;h_451340998_15&quot; data-into-catalog-status=&quot;&quot;&gt;TL;DR&lt;/h2&gt;&lt;p data-pid=&quot;JtqIKbG1&quot;&gt;前面字太多了，总结一下主要观点：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;ZHepOb8z&quot;&gt;低代码都是一种「声明式」编程，因为只有声明式才能可视化编辑，而可视化编辑是低代码唯一不可少的功能。&lt;/li&gt;&lt;li data-pid=&quot;f_lQwWSq&quot;&gt;低代码的优缺点其实来自于「声明式」本身。&lt;/li&gt;&lt;li data-pid=&quot;k8VBCY9t&quot;&gt;编写代码是一种抽象思维，因此并不适合可视化，导致低代码只能面向特定领域，复杂应用需要和专业开发配合。&lt;/li&gt;&lt;li data-pid=&quot;0JmBPs4g&quot;&gt;前端界面的 HTML+CSS 可以认为是一种低代码 DSL，因此界面的低代码比较容易实现，只需要在 HTML+CSS 基础上抽象一层。&lt;/li&gt;&lt;li data-pid=&quot;nBtgmthB&quot;&gt;后端存储的低代码有几种方案，但没有哪个方案是完美的，它们都有各自的优缺点，这将决定一个低代码平台的适用范围，建议在选型时重点关注。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;h_451340998_16&quot; data-into-catalog-status=&quot;&quot;&gt;在了解原理之后&lt;/h2&gt;&lt;p data-pid=&quot;aigDVu-r&quot;&gt;前面介绍了各种低代码实现原理，看起来都不难，但真正要实现还需要大量细节工作，以我们的 amis 为例，从 2015 年启动至今一直在持续更新，下面是 amis 开源这两年半来的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/baidu/amis/graphs/contributors&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;提交历史&lt;/a&gt;，基本除了春节和国庆之外都在提交：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f6a11131c83a21633eb4c084b13f7092_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1824&quot; data-rawheight=&quot;698&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-f6a11131c83a21633eb4c084b13f7092_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1824&quot; data-rawheight=&quot;698&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-f6a11131c83a21633eb4c084b13f7092_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f6a11131c83a21633eb4c084b13f7092_b.jpg&quot;/&gt;&lt;figcaption&gt;amis 的 contributors 页面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;qTEEhdjb&quot;&gt;但今天 amis 现在仍然有大量功能要做，比如本周将发布的 1.6.0 版本终于开始初步增强移动端 UI，下面是新版移动端日期选择：&lt;/p&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed18f4e4d8a81fde2b8d4c78ea1d33b3_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1125&quot; data-rawheight=&quot;2436&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed18f4e4d8a81fde2b8d4c78ea1d33b3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1125&quot; data-rawheight=&quot;2436&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed18f4e4d8a81fde2b8d4c78ea1d33b3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ed18f4e4d8a81fde2b8d4c78ea1d33b3_b.jpg&quot;/&gt;&lt;figcaption&gt;amis 1.6.0 里的日期选择&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;qciFpGTZ&quot;&gt;除了无尽的功能要加，还有许多基础工作要做，比如组件单元测试覆盖率只有 40%，此刻还有 360+ issues 要处理，感谢阅读到这，有什么问题欢迎留言交流，我要去处理 issue 了……&lt;/p&gt;&lt;blockquote data-pid=&quot;EzKLySBs&quot;&gt;本文最初是为了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//a2m.msup.com.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;A2M&lt;/a&gt; 的分享准备的补充材料，但会议因为疫情的原因推迟到了 4 月，考虑到上篇文章已经一年多了，明年将会有新的想法，因此提前发出来了。&lt;br/&gt;本文使用 CC BY-SA 4.0 协议，欢迎转载。&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1071085eae3c7cf465fdd2d6fde7fccd</guid>
<title>vivo 短视频推荐去重服务的设计实践</title>
<link>https://toutiao.io/k/sdzsrai</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;26&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Zhang Wei&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、概述&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 业务背景&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo短视频在视频推荐时需要对用户已经看过的视频进行过滤去重，避免给用户重复推荐同一个视频影响体验。在一次推荐请求处理流程中，会基于用户兴趣进行视频召回，大约召回2000~10000条不等的视频，然后进行视频去重，过滤用户已经看过的视频，仅保留用户未观看过的视频进行排序，选取得分高的视频下发给用户。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 当前现状&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当前推荐去重基于Redis Zset实现，服务端将播放埋点上报的视频和下发给客户端的视频分别以不同的Key写入Redis ZSet，推荐算法在视频召回后直接读取Redis里对应用户的播放和下发记录（整个ZSet），基于内存中的Set结构实现去重，即判断当前召回视频是否已存在下发或播放视频Set中，大致的流程如图1所示。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;364&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6296296296296297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPNGs7z5ev17IdbQbK1d4k5NibkNO0aZ64MYqGDMsFV4SeHc0oO7PLRkDA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图1：短视频去重当前现状）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;视频去重本身是基于用户实际观看过的视频进行过滤，但考虑到实际观看的视频是通过客户端埋点上报，存在一定的时延，因此服务端会保存用户最近100条下发记录用于去重，这样就保证了即使客户端埋点还未上报上来，也不会给用户推荐了已经看过的视频（即重复推荐）。而下发给用户的视频并不一定会被曝光，因此仅保存100条，使得未被用户观看的视频在100条下发记录之后仍然可以继续推荐。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当前方案主要问题是占用Redis内存非常大，因为视频ID是以原始字符串形式存在Redis Zset中，为了控制内存占用并且保证读写性能，我们对每个用户的播放记录最大长度进行了限制，当前限制单用户最大存储长度为10000，但这会影响重度用户产品体验。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、方案调研&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 主流方案&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;第一，存储形式&lt;/strong&gt;。视频去重场景是典型的只需要判断是否存在即可，因此并不需要把原始的视频ID存储下来，目前比较常用的方案是使用布隆过滤器存储视频的多个Hash值，可降低存储空间数倍甚至十几倍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二，存储介质&lt;/strong&gt;。如果要支持存储90天（三个月）播放记录，而不是当前粗暴地限制最大存储10000条，那么需要的Redis存储容量非常大。比如，按照5000万用户，平均单用户90天播放10000条视频，每个视频ID占内存25B，共计需要12.5TB。视频去重最终会读取到内存中完成，可以考虑牺牲一些读取性能换取更大的存储空间。而且，当前使用的Redis未进行持久化，如果出现Redis故障会造成数据丢失，且很难恢复（因数据量大，恢复时间会很长）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前业界比较常用的方案是使用磁盘KV（一般底层基于RocksDB实现持久化存储，硬盘使用SSD），读写性能相比Redis稍逊色，但是相比内存而言，磁盘在容量上的优势非常明显。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 技术选型&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;第一，播放记录&lt;/strong&gt;。因需要支持至少三个月的播放历史记录，因此选用布隆过滤器存储用户观看过的视频记录，这样相比存储原始视频ID，空间占用上会极大压缩。我们按照5000万用户来设计，如果使用Redis来存储布隆过滤器形式的播放记录，也将是TB级别以上的数据，考虑到我们最终在主机本地内存中执行过滤操作，因此可以接受稍微低一点的读取性能，选用磁盘KV持久化存储布隆过滤器形式的播放记录。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二，下发记录&lt;/strong&gt;。因只需存储100条下发视频记录，整体的数据量不大，而且考虑到要对100条之前的数据淘汰，仍然使用Redis存储最近100条的下发记录。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、方案设计&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于如上的技术选型，我们计划新增统一去重服务来支持写入下发和播放记录、根据下发和播放记录实现视频去重等功能。其中，重点要考虑的就是接收到播放埋点以后将其存入布隆过滤器。在收到播放埋点以后，以布隆过滤器形式写入磁盘KV需要经过三步，如图2所示：第一，读取并反序列化布隆过滤器，如布隆过滤器不存在则需创建布隆过滤器；第二，将播放视频ID更新到布隆过滤器中；第三，将更新后的布隆过滤器序列化并回写到磁盘KV中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;334&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5781041388518025&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPN1lcTujL8u1dxtDdQX0JD5TFXw03XCfcIkIfQicAUJ6niaICjicwTA0afg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;749&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图2：统一去重服务主要步骤）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;整个过程很清晰，但是考虑到需要支持千万级用户量，假设按照5000万用户目标设计，我们还需要考虑四个问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;第一&lt;/strong&gt;，视频按刷次下发（一刷5~10条视频），而播放埋点按照视频粒度上报，那么就视频推荐消重而言，数据的写入QPS比读取更高，然而，相比Redis磁盘KV的性能要逊色，磁盘KV本身的写性能比读性能低，要支持5000万用户量级，那么如何实现布隆过滤器写入磁盘KV是一个要考虑的重要问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;第二&lt;/strong&gt;，由于布隆过滤器不支持删除，超过一定时间的数据需要过期淘汰，否则不再使用的数据将会一直占用存储资源，那么如何实现布隆过滤器过期淘汰也是一个要考虑的重要问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;第三&lt;/strong&gt;，服务端和算法当前直接通过Redis交互，我们希望构建统一去重服务，算法调用该服务来实现过滤已看视频，而服务端基于Java技术栈，算法基于C++技术栈，那么需要在Java技术栈中提供服务给C++技术栈调用。我们最终采用gRPC提供接口给算法调用，注册中心采用了Consul，该部分非重点，就不详细展开阐述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;第四&lt;/strong&gt;，切换到新方案后我们希望将之前存储在Redis ZSet中的播放记录迁移到布隆过滤器，做到平滑升级以保证用户体验，那么设计迁移方案也是要考虑的重要问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 整体流程&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;统一去重服务的整体流程及其与上下游之间的交互如图3所示。服务端在下发视频的时候，将当次下发记录通过统一去重服务的Dubbo接口保存到Redis下发记录对应的Key下，使用Dubbo接口可以确保立即将下发记录写入。同时，监听视频播放埋点并将其以布隆过滤器形式存放到磁盘KV中，考虑到性能我们采用了批量写入方案，具体下文详述。统一去重服务提供RPC接口供推荐算法调用，实现对召回视频过滤掉用户已观看的视频。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;346&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5979142526071842&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPN7w69sMvibXmCvnGLricpVDVh9KggY3nuQG1wMibLOJ0Ctg9nhCfk1k0YQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;863&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图3：统一去重服务整体流程）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;磁盘KV写性能相比读性能差很多，尤其是在Value比较大的情况下写QPS会更差，考虑日活千万级情况下磁盘KV写性能没法满足直接写入要求，因此需要设计写流量汇聚方案，即将一段时间以内同一个用户的播放记录汇聚起来一次写入，这样就大大降低写入频率，降低对磁盘KV的写压力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 流量汇聚&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了实现写流量汇聚，我们需要将播放视频先暂存在Redis汇聚起来，然后隔一段时间将暂存的视频生成布隆过滤器写入磁盘KV中保存，具体而言我们考虑过N分钟仅写入一次和定时任务批量写入两种方式。接下来详细阐述我们在流量汇聚和布隆过滤器写入方面的设计和考虑。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 近实时写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;监听到客户端上报的播放埋点后，原本应该直接将其更新到布隆过滤器并保存到磁盘KV，但是考虑到降低写频率，我们只能将播放的视频ID先保存到Redis中，N分钟内仅统一写一次磁盘KV，这种方案姑且称之为近实时写入方案吧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最朴素的想法是每次写的时候，在Redis中保存一个Value，N分钟以后失效，每次监听到播放埋点以后判断这个Value是否存在，如果存在则表示N分钟内已经写过一次磁盘KV本次不写，否则执行写磁盘KV操作。这样的考虑主要是在数据产生时，先不要立即写入，等N分钟汇聚一小批流量之后再写入。这个Value就像一把“锁”，保护磁盘KV每隔N分钟仅被写入一次，如图4所示，如果当前为已加锁状态，再进行加锁会失败，可保护在加锁期间磁盘KV不被写入。从埋点数据流来看，原本连续不断的数据流，经过这把“锁”就变成了每隔N分钟一批的微批量数据，从而实现流量汇聚，并降低磁盘KV的写压力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;192&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.33184855233853006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPNazZUmibxckfY9mMN87YVY8e0gIOL6f6ia8cPCyFichSTVkF4z064TSrzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图4：近实时写入方案）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;近实时写入的出发点很单纯，优势也很明显，可以近实时地将播放埋点中的视频ID写入到布隆过滤器中，而且时间比较短（N分钟），可以避免Redis Zset中暂存的数据过长。但是，仔细分析还需要考虑很多特殊的场景，主要如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;193&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;strong&gt;第一&lt;/strong&gt;，Redis中保存一个Value其实相当于一个分布式锁，实际上很难保证这把“锁”是绝对安全的，因此可能会存在两次收到播放埋点均认为可以进行磁盘KV写操作，但这两次读到的暂存数据不一定一样，由于磁盘KV不支持布隆过滤器结构，写入操作需要先从磁盘KV中读出当前的布隆过滤器，然后将需要写入的视频ID更新到该布隆过滤器，最后再写回到磁盘KV，这样的话，写入磁盘KV后就有可能存在数据丢失。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;135&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;strong&gt;第二&lt;/strong&gt;，最后一个N分钟的数据需要等到用户下次再使用的时候才能通过播放埋点触发写入磁盘KV，如果有大量不活跃的用户，那么就会存在大量暂存数据遗留在Redis中占用空间。此时，如果再采用定时任务来将这部分数据写入到磁盘KV，那么也会很容易出现第一种场景中的并发写数据丢失问题。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如此看来，近实时写入方案虽然出发点很直接，但是仔细想来，越来越复杂，只能另寻其他方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 批量写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;既然近实时写入方案复杂，那不妨考虑简单的方案，通过定时任务批量将暂存的数据写入到磁盘KV中。我们将待写的数据标记出来，假设我们每小时写入一次，那么我们就可以把暂存数据以小时值标记。但是，考虑到定时任务难免可能会执行失败，我们需要有补偿措施，常见的方案是每次执行任务的时候，都在往前多1~2个小时的数据上执行任务，以作补偿。但是，明显这样的方案并不够优雅，我们从时间轮得到启发，并基于此设计了布隆过滤器批量写入的方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们将小时值首尾相连，从而得到一个环，并且将对应的数据存在该小时值标识的地方，那么同一小时值（比如每天11点）的数据是存在一起的，如果今天的数据因任务未执行或执行失败未同步到磁盘KV，那么在第二天将会得到一次补偿。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;顺着这个思路，我们可以将小时值对某个值取模以进一步缩短两次补偿的时间间隔，比如图5所示对8取模，可见1:00~2:00和9:00~10:00的数据都会落在图中时间环上的点1标识的待写入数据，过8个小时将会得到一次补偿的机会，也就是说这个取模的值就是补偿的时间间隔。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;387&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6688102893890675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPNA9YcPAjl26ux7dDPldwuAia27c6R9Nm3v8aMIUnt6toKLQR0jh4vnUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图5：批量写入方案）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么，我们应该将补偿时间间隔设置为多少呢？这是一个值得思考的问题，这个值的选取会影响到待写入数据在环上的分布。我们的业务一般都会有忙时、闲时，忙时的数据量会更大，根据短视频忙闲时特点，最终我们将补偿间隔设置为6，这样业务忙时比较均匀地落在环上的各个点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;确定了补偿时间间隔以后，我们觉得6个小时补偿还是太长了，因为用户在6个小时内有可能会看过大量的视频，如果不及时将数据同步到磁盘KV，会占用大量Redis内存，而且我们使用Redis ZSet暂存用户播放记录，过长的话会严重影响性能。于是，我们设计每个小时增加一次定时任务，第二次任务对第一次任务补偿，如果第二次任务仍然没有补偿成功，那么经过一圈以后，还可以得到再次补偿（兜底）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;细心一点应该会发现在图5中的“待写入数据”和定时任务并不是分布在环上的同一个点的，我们这样设计的考虑是希望方案更简单，定时任务只会去操作已经不再变化的数据，这样就能避免并发操作问题。就像Java虚拟机中垃圾回收一样，我们不能一边回收垃圾，一边却还在同一间屋子里扔着垃圾。所以，设计成环上节点对应定时任务只去处理前一个节点上的数据，以确保不会产生并发冲突，使方案保持简单。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;批量写入方案简单且不存在并发问题，但是在Redis Zset需要保存一个小时的数据，可能会超过最大长度，但是考虑到现实中一般用户一小时内不会播放非常大量的视频，这一点是可以接受的。最终，我们选择了批量写入方案，其简单、优雅、高效，在此基础上，我们需要继续设计暂存大量用户的播放视频ID方案。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 数据分片&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了支持5000万日活量级，我们需要为定时批量写入方案设计对应的数据存储分片方式。首先，我们依然需要将播放视频列表存放在Redis Zset，因为在没写入布隆过滤器之前，我们需要用这份数据过滤用户已观看过的视频。正如前文提到过，我们会暂存一个小时的数据，正常一个用户一个小时内不会播放超过一万条数据的，所以一般来说是没有问题的。除了视频ID本身以外，我们还需要保存这个小时到底有哪些用户产生过播放数据，否则定时任务不知道要将哪些用户的播放记录写入布隆过滤器，存储5000万用户的话就需要进行数据分片。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结合批量同步部分介绍的时间环，我们设计了如图6所示的数据分片方案，将5000万的用户Hash到5000个Set中，这样每个Set最多保存1万个用户ID，不至于影响Set的性能。同时，时间环上的每个节点都按照这个的分片方式保存数据，将其展开就如同图6下半部分所示，以played:user:${时间节点编号}:${用户Hash值}为Key保存某个时间节点某个分片下所有产生了播放数据的用户ID。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;643&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.1130298273155417&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPNOT1KcHKqahc30Jtftib9kb6pWkcT5pibAkuiaiaiblOCZibBSicribzd7nMXdw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图6：数据分片方案）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对应地，我们的定时任务也要进行分片，每个任务分片负责处理一定数目的数据分片。否则，如果两者一一对应的话，将分布式定时任务分成5000个分片，虽然对于失败重试是更好的，但是对于任务调度来说会存在压力，实际上公司的定时任务也不支持5000分分片。我们将定时任务分为了50个分片，任务分片0负责处理数据分片0~100，任务分片1负责处理数据分片100~199，以此类推。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4 数据淘汰&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于短视频推荐去重业务场景，我们一般保证让用户在看过某条视频后三个月内不会再向该用户推荐这条视频，因此就涉及到过期数据淘汰问题。布隆过滤器不支持删除操作，因此我们将用户的播放历史记录添加到布隆过滤器以后，按月存储并设置相应的过期时间，如图7所示，目前过期时间设置为6个月。在数据读取的时候，根据当前时间选择读取最近4个月数据用于去重。之所以需要读取4个月的数据，是因为当月数据未满一个月，为了保证三个月内不会再向用户重复推荐，需要读取三个完整月和当月数据。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;326&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5632022471910112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPN1t76H4Nf6L2AEOnYgy0OZkzUibdsN2GvgE2dO4PbXloTWkL9iamx5KHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图7：数据淘汰方案）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于数据过期时间的设置我们也进行了精心考虑，数据按月存储，因此新数据产生时间一般在月初，如果仅将过期时间设置为6个月以后，那么会造成月初不仅产生大量新数据，也需要淘汰大量老数据，对数据库系统造成压力。所以，我们将过期时间进行了打散，首先随机到6个月后的那个月任意一天，其次我们将过期时间设置在业务闲时，比如：00:00~05:00，以此来降低数据库清理时对系统的压力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 方案小结&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过综合上述流量汇聚、数据分片和数据淘汰三部分设计方案，整体的设计方案如图8所示，从左至右播放埋点数据依次从数据源Kafka流向Redis暂存，最终流向磁盘KV持久化。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;309&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.534375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPN2w4D5ZILoZfBFs7ia9cmXOZ2Z2vyEMdEQDjLtHO5XUY47KibdiaTLYdQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图8：整体方案流程）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;首先，从Kafka播放埋点监听到数据以后，我们根据用户ID将该条视频追加到用户对应的播放历史中暂存，同时根据当前时间和用户ID的Hash值确定对应时间环，并将用户ID保存到该时间环对应的用户列表中。然后，每个分布式定时任务分片去获取上一个时间环的播放用户数据分片，再获取用户的播放记录更新到读出的布隆过滤器，最后将布隆顾虑其序列化后写入磁盘KV中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、数据迁移&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了实现从当前基于Redis ZSet去重平滑迁移到基于布隆过滤器去重，我们需要将统一去重服务上线前用户产生的播放记录迁移过来，以保证用户体验不受影响，我们设计和尝试了两种方案，经过对比和改进形成了最终方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们已经实现了批量将播放记录原始数据生成布隆过滤器存储到磁盘KV中，因此，迁移方案只需要考虑将存储在原来Redis中的历史数据（去重服务上线前产生）迁移到新的Redis中即可，接下来就交由定时任务完成即可，方案如图9所示。用户在统一去重服务上线后新产生的增量数据通过监听播放埋点写入，新老数据双写，以便需要时可以降级。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;454&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7848557692307693&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPNccecDyqmK7AQGLtiaHVOsDJA6JIE37ibNicD2icjaXWQVaL0fMcM0aL4vg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图9：迁移方案一）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但是，我们忽略了两个问题：第一，新的Redis仅用作暂存，因此比老的Redis容量小很多，没法一次性将数据迁移过去，需要分多批迁移；第二，迁移到新的Redis后的存储格式和老的Redis不一样，除了播放视频列表，还需要播放用户列表，咨询DBA得知这样迁移比较难实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既然迁移数据比较麻烦，我们就考虑能不能不迁移数据呢，在去重的时候判断该用户是否已迁移，如未迁移则同时读取一份老数据一起用于去重过滤，并触发将该用户的老数据迁移到新Redis（含写入播放用户列表），三个月以后，老数据已可过期淘汰，此时就完成了数据迁移，如图10所示。这个迁移方案解决了新老Redis数据格式不一致迁移难的问题，而且是用户请求时触发迁移，也避免了一次性迁移数据对新Redis容量要求，同时还可以做到精确迁移，仅迁移了三个月内需要迁移数据的用户。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;251&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4335971855760774&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPNOmhVpnf2qSyNArcQibwic2EZSOhjQeBR1BrF7ONgYlls3KkDCzTI7OwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1137&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图10：迁移方案二）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;于是，我们按照方案二进行了数据迁移，在上线测试的时候，发现由于用户首次请求的时候需要去迁移老的数据，造成去重接口耗时不稳定，而视频去重作为视频推荐重要环节，对于耗时比较敏感，所以就不得不继续思考新的迁移方案。我们注意到，在定时批量生成布隆过滤器的时候，读取到时间环对应的播放用户列表后，根据用户ID获取播放视频列表，然后生成布隆过滤器保存到磁盘KV，此时，我们只需要增加一个从老Redis读取用户的历史播放记录即可把历史数据迁移过来。为了触发将某个用户的播放记录生成布隆过滤器的过程，我们需要将用户ID保存到时间环上对应的播放用户列表，最终方案如图11所示。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;297&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5138516532618409&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6vf7FLw6icEx8sPp1HibgjPNCGydnyicCewKea80Lu5UIBMe6MnmGHMlV9x941eR8odfpHfoxyF9hDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1119&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（图11：最终迁移方案）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;首先，DBA帮助我们把老Redis中播放记录的Key（含有用户ID）都扫描出来，通过文件导出；然后，我们通过大数据平台将导出的文件导入到Kafka，启用消费者监听并消费文件中的数据，解析后将其写入到当前时间环对应的播放用户列表。接下来，分布式批量任务在读取到播放用户列表中的某个用户后，如果该用户未迁移数据，则从老Redis读取历史播放记录，并和新的播放记录一起更新到布隆过滤器并存入磁盘KV。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、小结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文主要介绍短视频基于布隆过滤器构建推荐去重服务的设计与思考，从问题出发逐步设计和优化方案，力求简单、完美、优雅，希望能对读者有参考和借鉴价值。由于文章篇幅有限，有些方面未涉及，也有很多技术细节未详细阐述，如有疑问欢迎继续交流。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:108.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>