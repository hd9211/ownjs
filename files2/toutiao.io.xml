<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>38d17aac62be69b1a61bc5d97d1f1168</guid>
<title>Go 设计模式（十五）：策略模式</title>
<link>https://toutiao.io/k/0nevhvz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content mx-auto&quot; id=&quot;post&quot;&gt;&lt;article class=&quot;markdown-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;序&lt;/h2&gt;&lt;h2 id=&quot;笔记&quot;&gt;笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://lailin.xyz/images/1601397314638-badeafba-9995-48db-92a3-204c146b50fc.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;&lt;p&gt;来个 🌰，我们在保存文件的时候，由于政策或者其他的原因可能需要选择不同的存储方式，敏感数据我们需要加密存储，不敏感的数据我们可以直接明文保存。&lt;/p&gt;&lt;h3 id=&quot;Code&quot;&gt;Code&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; strategy

&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; (
&lt;span class=&quot;hljs-string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;hljs-string&quot;&gt;&quot;io/ioutil&quot;&lt;/span&gt;
&lt;span class=&quot;hljs-string&quot;&gt;&quot;os&quot;&lt;/span&gt;
)


&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; StorageStrategy &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; {
Save(name &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, data []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;) error
}

&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; strategys = &lt;span class=&quot;hljs-keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;]StorageStrategy{
&lt;span class=&quot;hljs-string&quot;&gt;&quot;file&quot;&lt;/span&gt;:         &amp;amp;fileStorage{},
&lt;span class=&quot;hljs-string&quot;&gt;&quot;encrypt_file&quot;&lt;/span&gt;: &amp;amp;encryptFileStorage{},
}


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewStorageStrategy&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(StorageStrategy, error)&lt;/span&gt;&lt;/span&gt; {
s, ok := strategys[t]
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; !ok {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, fmt.Errorf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;not found StorageStrategy: %s&quot;&lt;/span&gt;, t)
}

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; s, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}


&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; fileStorage &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt;{}


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(s *fileStorage)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(name &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, data []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ioutil.WriteFile(name, data, os.ModeAppend)
}


&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; encryptFileStorage &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt;{}


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(s *encryptFileStorage)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(name &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, data []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {

data, err := encrypt(data)
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err
}

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ioutil.WriteFile(name, data, os.ModeAppend)
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;encrypt&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(data []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {

&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; data, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;单元测试&quot;&gt;单元测试&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; strategy

&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; (
&lt;span class=&quot;hljs-string&quot;&gt;&quot;testing&quot;&lt;/span&gt;

&lt;span class=&quot;hljs-string&quot;&gt;&quot;github.com/stretchr/testify/assert&quot;&lt;/span&gt;
)

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test_demo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {

data, sensitive := getData()
strategyType := &lt;span class=&quot;hljs-string&quot;&gt;&quot;file&quot;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; sensitive {
strategyType = &lt;span class=&quot;hljs-string&quot;&gt;&quot;encrypt_file&quot;&lt;/span&gt;
}

storage, err := NewStorageStrategy(strategyType)
assert.NoError(t, err)
assert.NoError(t, storage.Save(&lt;span class=&quot;hljs-string&quot;&gt;&quot;./test.txt&quot;&lt;/span&gt;, data))
}



&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test data&quot;&lt;/span&gt;), &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/article&gt;&lt;hr/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>460caedc02cec9729359f11044e38602</guid>
<title>CPU 飙高，系统性能问题如何排查？</title>
<link>https://toutiao.io/k/h1mu8e9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLqLGSRLxM4Z2QKpUVWyztuKkVz6qy2UISPOun8iau5GjXBzLmzJJ9RdPvbI4jWU08IpfibRLQ9deAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;p&gt;&lt;span&gt;阿里妹导读：&lt;/span&gt;&lt;span&gt;压测时或多或少都收到过CPU或者Load高的告警，如果是单机偶发性的，经常会认为是“宿主机抢占导致的”，那事实是否真是如此呢？是什么引起了这些指标的飙高？网络、磁盘还是高并发？有什么工具可以定位？TOP、PS还是vmstat？CPU高&amp;amp;Load高和CPU低&amp;amp;Load高，不同的表征又代表着什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末福利：&lt;span&gt;免费下载&lt;/span&gt;《ECS运维指南之Linux系统诊断&lt;span&gt;》电子书&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6076146076146076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13Xt6rh8gdsx0AnzhRjVq2OkzxjxVtXvBLQvzozfYA4WSykPJ51QVuFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1287&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一  背景知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LINUX进程状态&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LINUX 2.6以后的内核中，进程一般存在7种基础状态：D-不可中断睡眠、R-可执行、S-可中断睡眠、T-暂停态、t-跟踪态、X-死亡态、Z-僵尸态，这几种状态在PS命令中有对应解释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1806853582554517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13UqwyJDBg37hT8swox1Cln6BYWH2LWfA3P9VPEq6E3dbcBxys1cZmWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1284&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Load Average &amp;amp; CPU使用率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;谈到系统性能，Load和CPU使用率是最直观的两个指标，那么这两个指标是怎么被计算出来的呢？是否能互相等价呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Load Average&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不少人都认为，Load代表正在CPU上运行&amp;amp;等待运行的进程数，即&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.09817671809256662&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13OldyMmZCBicJAfEnL1NHOzqOs1iaiaeCoHLpkjk6FemialiaGDxWwAHDYww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但Linux系统中，这种描述并不完全准确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下为Linux内核源码中Load Average计算方法，可以看出来，因此除了可执行态进程，不可中断睡眠态进程也会被一起纳入计算，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.05236907730673317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13p6Hniaw9aBVgDiaTCtqgu7Rr6pKicfR3SOniaaDA9FVSic1vAgAYOaC98jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1203&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;602staticunsignedlongcount_active_tasks(void)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;603&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;604structtask_struct*p;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;605unsignedlongnr&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;0;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;606607read_lock(&amp;amp;tasklist_lock);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;608for_each_task(p)&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;609if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;((p-&amp;gt;state==TASK_RUNNING610 (p-&amp;gt;state&amp;amp;TASK_UNINTERRUPTIBLE)))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;611nr+&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;FIXED_1;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;612&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;613read_unlock(&amp;amp;tasklist_lock);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;614returnnr;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;615&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;......&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;625staticinlinevoidcalc_load(unsignedlongticks)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;626&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;627unsignedlongactive_tasks;&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/* fixed-point */628staticintcount=LOAD_FREQ;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;629630count-&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;ticks;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;631if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;(count&amp;lt;0) {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;632count+&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;LOAD_FREQ;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;633active_tasks&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;count_active_tasks();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;634CALC_LOAD(avenrun[0],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_1, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;635CALC_LOAD(avenrun[1],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_5, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;636CALC_LOAD(avenrun[2],&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;EXP_15, active_tasks);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;637&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;638&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在前文 Linux进程状态 中有提到过，不可中断睡眠态的进程(TASK_UNINTERRUTED)一般都在进行I/O等待，比如磁盘、网络或者其他外设等待。由此我们可以看出，Load Average在Linux中体现的是整体系统负载，即CPU负载 + Disk负载 + 网络负载 + 其余外设负载，并不能完全等同于CPU使用率(这种情况只出现在Linux中，其余系统比如Unix，Load还是只代表CPU负载)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU使用率&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPU的时间分片一般可分为4大类：用户进程运行时间 - User Time, 系统内核运行时间 - System Time, 空闲时间 - Idle Time, 被抢占时间 - Steal Time。除了Idle Time外，其余时间CPU都处于工作运行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8610526315789474&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13NkGgIGfVJdeM86ibhXy8wklbRAS9oPoEw3JzXw3EkOIInWichAEXQGQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常而言，我们泛指的整体CPU使用率为User Time 和 Systime占比之和(例如tsar中CPU util)，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.13093525179856116&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13xsnAXZlZNwDNzxd39WtKr02SOqoaC7xwBfsgPR2km18or5lemBDH9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了便于定位问题，大多数性能统计工具都将这4类时间片进一步细化成了8类，如下为TOP对CPU时间片的分类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.14093428345209819&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs134JwQO9X9fvRnbtiaksKXdQCfljEGYyt77fm3HWvtZ7iaCZeWhicwQtn3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1263&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这8类分片中，除wa和id外，其余分片CPU都处于工作态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二  资源&amp;amp;瓶颈分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上文我们了解到，Load Average和CPU使用率可被细分为不同的子域指标，指向不同的资源瓶颈。总体来说，指标与资源瓶颈的对应关系基本如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6057319907048799&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13ka70PfcOPtzMkwt17mbEicabmxnT8b91nvIPXPUot4CENjO2RGRibHuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1291&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Load高 &amp;amp; CPU高&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是我们最常遇到的一类情况，即load上涨是CPU负载上升导致。根据CPU具体资源分配表现，可分为以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU sys高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况CPU主要开销在于系统内核，可进一步查看上下文切换情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU si高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况CPU大量消耗在软中断，可进一步查看软中断类型。一般而言，网络I/O或者线程调度引起软中断最为常见：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU us高&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况说明资源主要消耗在应用进程，可能引发的原因有以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Load高 &amp;amp; CPU低&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况出现的根本原因在于不可中断睡眠态(TASK_UNINTERRUPTIBLE)进程数较多，即CPU负载不高，但I/O负载较高。可进一步定位是磁盘I/O还是网络I/O导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三  排查策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用现有常用的工具，我们常用的排查策略基本如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6327467482785004&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13jMZeGFd94Twb8icTwibADmSehCDqGrCymSR5myUEic5WN09ribH90nJnCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1307&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从问题发现到最终定位，基本可分为四个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源瓶颈定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一阶段通过全局性能检测工具，初步定位资源消耗异常位点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;热点进程定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定位到资源瓶颈后，可进一步分析具体进程资源消耗情况，找到热点进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上下文切换：pidstat -w&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU&lt;span&gt;：&lt;/span&gt;pidstat -u&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;I/O&lt;span&gt;：&lt;/span&gt;iotop、pidstat -d&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;僵尸进程&lt;span&gt;：&lt;/span&gt;ps&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程&amp;amp;进程内部资源定位&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找到具体进程后，可细化分析进程内部资源开销情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;热点事件&amp;amp;方法分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;获取到热点线程后，我们可用trace或者dump工具，将线程反向关联，将问题范围定位到具体方法&amp;amp;堆栈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常用的工具有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]Linux Load Averages: Solving the Mystery&lt;br/&gt;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]What exactly is a load average?&lt;br/&gt;http://linuxtechsupport.blogspot.com/2008/10/what-exactly-is-load-average.html&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;电子书免费下载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《ECS运维指南 之 Linux系统诊断》&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.4143490528012899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJ1NrXIAf1byA6uXa3fMs13mFxuOHQUtPOc74R27jQmckLEMKEcsuBxoGo7qAVxDuD1IMNbKAiayzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2481&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书以浅显易懂的案例带领您进入Linux的世界，由浅入深，由表及里，层层推进，从运维工作的实际需求出发，全面讲解相关的技术、经典案例，以及常见问题的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;点击“阅读原文”&lt;/span&gt;，立即下载吧！  &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-s=&quot;300,640&quot; data-copyright=&quot;0&quot; data-cropsely2=&quot;182&quot; data-cropsely1=&quot;0&quot; data-cropselx2=&quot;180&quot; data-cropselx1=&quot;0&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKjYl1NicXGw20r286y3CF1Jc5iafxBBXzN9GyerB7AMQAPeGCGZA57Ha7w75vickdc4aFAsBNicyVfgg/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;关注&lt;/span&gt;&lt;span&gt;「阿里技术」&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;把握前沿技术脉搏&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naLWBBEcl44aIic1Mthe1nZiaramW5s4e8WwyCYYbTzu6uPBpgI6sxNXNymEnOYKpJpcrItUia7lS64mA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳我，下载电子书。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f8b15e910f0f55f81e34466fb13b8bfe</guid>
<title>Rust 学习笔记：异步代码的几种写法</title>
<link>https://toutiao.io/k/vco1y0p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;335:751&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93396&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;314:356&quot;&gt;mio&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;最原始的方式是使用 &lt;code&gt;&lt;span&gt;mio&lt;/span&gt;&lt;/code&gt;进行开发。&lt;code&gt;&lt;span&gt;mio&lt;/span&gt;&lt;/code&gt;是一个底层异步 &lt;code&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;/code&gt;库，提供非阻塞方式的 &lt;code&gt;&lt;span&gt;API&lt;/span&gt;&lt;/code&gt;，具有很高的性能。实际上 &lt;code&gt;&lt;span&gt;mio&lt;/span&gt;&lt;/code&gt;是对于操作系统 &lt;code&gt;&lt;span&gt;epoll&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;kqueue&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;IOCP&lt;/span&gt;&lt;/code&gt;的&lt;span&gt;封装。在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中我们使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;libevent&lt;/span&gt;&lt;/code&gt;&lt;span&gt;之类的库， &lt;/span&gt;&lt;code&gt;&lt;span&gt;mio&lt;/span&gt;&lt;/code&gt;&lt;span&gt;可以理解为对应的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/code&gt;&lt;span&gt;版本。基于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mio&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的代码大致如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt; loop &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;// Poll Mio for events, blocking until we get an event.&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;     poll&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(&amp;amp;&lt;/span&gt;&lt;span&gt;mut events&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)?;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;// Process each event.&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; event in events&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; event&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_writable&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;             &lt;/span&gt;&lt;span&gt;// socket可写，开始发送数据&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; event&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_readable&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;             &lt;/span&gt;&lt;span&gt;// socket可读，开始接收数据&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;// socket 关闭，退出循环&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Ok&lt;/span&gt;&lt;span&gt;(());&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;     &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;总的来说，这是完全基于异步事件通知的写法，和 &lt;code&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;/code&gt;区别不是很大，异步代码对于程序员是一个挑战，当代码逻辑越来越复杂，添加新功能或是解决已有问题的难度也越来越大。&lt;/p&gt;&lt;p&gt;另外， &lt;code&gt;&lt;span&gt;mio&lt;/span&gt;&lt;/code&gt;实现的是一个单线程事件循环，虽然可以处理成千上万路的 &lt;code&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;/code&gt;操作，但没有多线程的能力，需要自己扩充。&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93396&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;322:360&quot;&gt;Future Poll&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了更好地规范异步的逻辑， &lt;/span&gt;&lt;code&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/code&gt;&lt;span&gt;抽象出 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt;表示尚未发生的事物。这些 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt;可以用很多方式組合成一个更复杂的复合 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来代表一系列的事件。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt;需要程序主动去 &lt;/span&gt;&lt;code&gt;&lt;span&gt;poll&lt;/span&gt;&lt;/code&gt;&lt;span&gt;(轮询)才能获取到最终的结果，每一次轮询的结果可能是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;/code&gt;&lt;span&gt;或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Pending&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;运行库提供 &lt;code&gt;&lt;span&gt;Executor&lt;/span&gt;&lt;/code&gt;和 &lt;code&gt;&lt;span&gt;Reactor&lt;/span&gt;&lt;/code&gt;来执行 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;，也就是调用 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;的 &lt;code&gt;&lt;span&gt;poll&lt;/span&gt;&lt;/code&gt;方法循环执行一系列就绪的 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;，当 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;返回 &lt;code&gt;&lt;span&gt;Pending&lt;/span&gt;&lt;/code&gt;的时候，会将 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;转移到 &lt;code&gt;&lt;span&gt;Reactor&lt;/span&gt;&lt;/code&gt;上等待唤醒。&lt;code&gt;&lt;span&gt;Reactor&lt;/span&gt;&lt;/code&gt;被用来负责唤醒之前无法完成的 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;。事实上， &lt;code&gt;&lt;span&gt;tokio&lt;/span&gt;&lt;/code&gt;的 &lt;code&gt;&lt;span&gt;Reactor&lt;/span&gt;&lt;/code&gt;是基于 &lt;code&gt;&lt;span&gt;mio&lt;/span&gt;&lt;/code&gt;实现的，而 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;std&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;smol&lt;/span&gt;&lt;/code&gt;则是封装了 &lt;code&gt;&lt;span&gt;epoll&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;kqueue&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;IOCP&lt;/span&gt;&lt;/code&gt;，提供类似的功能。&lt;/p&gt;&lt;p&gt;手动实现 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;是一件相对繁琐的工作，主要的问题在于异步模式本身的特性。例如，接收网络数据，无法臆测每次轮询会收到多少字节的数据，往往需要开辟一段接收缓冲区容纳数据，协议解码也需要一个状态机拼包向上层提交；发送网络数据存在相似问题，发送数据时底层未就绪，则缓冲发送数据，待下次轮询时，需要首先检查并处理发送缓冲区。另外还有一些值得注意的地方，如果手动实现的 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;返回 &lt;code&gt;&lt;span&gt;Pending&lt;/span&gt;&lt;/code&gt;，则必须自己实现唤醒机制，也就是需要将 &lt;code&gt;&lt;span&gt;cx&lt;/span&gt;&lt;/code&gt;克隆一份记下来，然后在适当的时侯调用 &lt;code&gt;&lt;span&gt;cx&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;wake&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/code&gt;。因为网络相关的功能往往是分层的，因此手动的 &lt;code&gt;&lt;span&gt;Poll&lt;/span&gt;&lt;/code&gt;循环也会是层层堆叠的，这时候，返回值 &lt;code&gt;&lt;span&gt;Poll&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;就有学问了。泛型T可能包裹各种不同的数据， &lt;code&gt;&lt;span&gt;Option&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;， &lt;code&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;，或者两者的组合。因为最外层还有一个 &lt;code&gt;&lt;span&gt;Poll&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;，所有这时候的 &lt;code&gt;&lt;span&gt;match&lt;/span&gt;&lt;/code&gt;语句写起来会非常臃肿，粘贴复制写很多代码，完成的功能却非常有限，而且由于这些代码很相似，大大增加了出错的可能性。&lt;/p&gt;&lt;p&gt;标准库中仅仅定义了 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;，更多的相关功能需要引用 &lt;code&gt;&lt;span&gt;futures&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;rs&lt;/span&gt;&lt;/code&gt;类库，里面定义了一系列有关异步的操作，包括 &lt;code&gt;&lt;span&gt;Stream&lt;/span&gt;&lt;/code&gt;、 &lt;code&gt;&lt;span&gt;Sink&lt;/span&gt;&lt;/code&gt;、 &lt;code&gt;&lt;span&gt;AsyncRead&lt;/span&gt;&lt;/code&gt;、 &lt;code&gt;&lt;span&gt;AsyncWrite&lt;/span&gt;&lt;/code&gt;等基础 &lt;code&gt;&lt;span&gt;Trait&lt;/span&gt;&lt;/code&gt;，以及对应实现了大量方便操作的组合子的 &lt;code&gt;&lt;span&gt;Ext&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Trait&lt;/span&gt;&lt;/code&gt;，特别用途的 &lt;code&gt;&lt;span&gt;fused&lt;/span&gt;&lt;/code&gt;、 &lt;code&gt;&lt;span&gt;Box&lt;/span&gt;&lt;/code&gt;， &lt;code&gt;&lt;span&gt;Try&lt;/span&gt;&lt;/code&gt;系列的扩展，诸如 &lt;code&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;/code&gt;、 &lt;code&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;/code&gt;、 &lt;code&gt;&lt;span&gt;pin_mut&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;/code&gt;等一系列的宏。理论上，不使用这些扩展也能写出代码，只不过那样的代码很可能篇幅会长的可怕。值得一提的是，除了一些可以简化代码的过程宏之外，扩展 &lt;code&gt;&lt;span&gt;Trait&lt;/span&gt;&lt;/code&gt;提供的组合子也会让代码精简不少。比如 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;and_then&lt;/span&gt;&lt;/code&gt;可以让代码写成链式调用的方式；&lt;code&gt;&lt;span&gt;Sink&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;send&lt;/span&gt;&lt;/code&gt;包装了 &lt;code&gt;&lt;span&gt;Sink&lt;/span&gt;&lt;/code&gt;发送三步骤 &lt;code&gt;&lt;span&gt;poll_ready&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;start_send&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;poll_flush&lt;/span&gt;&lt;/code&gt;，使用 &lt;code&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;一行代码直接就可以完成发送。因此，很多 &lt;code&gt;&lt;span&gt;poll&lt;/span&gt;&lt;/code&gt;方式的代码实际上是准确地说是混合式的，其中也使用了不少 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;/code&gt;代码块。&lt;/p&gt;&lt;p&gt;总之，搞清楚 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;相关的这些内容是需要花费不少时间，更不用说用它们来写代码了。不过，即便是使用 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;这种更高级原语，也是有必要了解底层的工作原理和实现机制，所谓知其然知其所以然。&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93396&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;345:364&quot;&gt;async/await&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;使用 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;可以将异步的代码写得类似同步的过程，更加符合人体工程学。因为 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;/code&gt;被翻译为一个 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;状态机，原先在 &lt;code&gt;&lt;span&gt;poll&lt;/span&gt;&lt;/code&gt;方式中需要处理的与 &lt;code&gt;&lt;span&gt;Pending&lt;/span&gt;&lt;/code&gt;相关的状态现在都由 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;/code&gt;生成的状态机自动完成，因此大大减轻了程序员的心智负担。&lt;/p&gt;&lt;p&gt;如前所述，底层的 &lt;code&gt;&lt;span&gt;Futures&lt;/span&gt;&lt;/code&gt;提供了很多方便的组合子扩展 &lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;，使用起来很简洁，可以极大地简化代码。例如，上文提到过的 &lt;code&gt;&lt;span&gt;Sink&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;send&lt;/span&gt;&lt;/code&gt;包装了发送缓冲区的实现和异步发送的三个步骤；&lt;code&gt;&lt;span&gt;AsyncRead&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;read_exact&lt;/span&gt;&lt;/code&gt;实现了读取指定字节数的功能，在处理网络协议解析时可以避免手写一个拼包状态机；&lt;code&gt;&lt;span&gt;AsyncWrite&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;write_all&lt;/span&gt;&lt;/code&gt;实现了发送全部数据以及发送缓冲，等等。正是在这些底层功能的支持下， &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;成为了更高级的书写异步代码的方式。也许会有少许担心，这样所谓“高级”会不会在性能上有很大损失？笔者个人不这么认为。自动实现的状态机也许未必比程序员手动完成的性能更差。状态机编程对于任何人，即便是一个有经验的程序员都是不小挑战。蹩脚的状态机实现不仅可能有性能问题，更大的风险来自于实现上的漏洞，以及维护上的困难。代码写出来更多是给别人看的，完成同样的功能，简洁的代码更有可能是更高质量的代码。&lt;/p&gt;&lt;p&gt;以下例子是固定长度分割的报文接收过程，使用 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;是很简单的。如果实现为一个 &lt;code&gt;&lt;span&gt;Stream&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;poll_next&lt;/span&gt;&lt;/code&gt;，代码会复杂很多。&lt;/p&gt;&lt;pre&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;/// convenient method for reading a whole frame&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    pub async fn recv_frame&lt;/span&gt;&lt;span&gt;(&amp;amp;&lt;/span&gt;&lt;span&gt;mut self&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt; io&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Vec&lt;/span&gt;&lt;span&gt;&amp;lt;u8&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        let mut len &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        let _ &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; self&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read_exact&lt;/span&gt;&lt;span&gt;(&amp;amp;&lt;/span&gt;&lt;span&gt;mut len&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;?;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;// inner socket, 支持 AsyncRead&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        let n &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; u32&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;from_be_bytes&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; as usize&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; n &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; self&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;max_frame_len &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;            let msg &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; format&lt;/span&gt;&lt;span&gt;!(&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;&quot;data length {} exceeds allowed maximum {}&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                n&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; self&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;max_frame_len&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Err&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;ErrorKind&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;PermissionDenied&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; msg&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        let mut frame &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; vec&lt;/span&gt;&lt;span&gt;![&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; n&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        self&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read_exact&lt;/span&gt;&lt;span&gt;(&amp;amp;&lt;/span&gt;&lt;span&gt;mut frame&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;?;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;Ok&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;frame&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;最后，完全使用 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;写代码目前还有几个问题：&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95679&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;205:628&quot;&gt;async trait&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Trait&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 不支持 &lt;/span&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，无法直接用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Trait&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来抽象异步方法。暂时解决办法是使用三方库 &lt;/span&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;use async_trait&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;async_trait&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;#[async_trait]&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;trait &lt;/span&gt;&lt;span&gt;Advertisement&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    async fn run&lt;/span&gt;&lt;span&gt;(&amp;amp;&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;宏 &lt;code&gt;&lt;span&gt;async_trait&lt;/span&gt;&lt;/code&gt;将代码转换为一个返回 &lt;code&gt;&lt;span&gt;Pin&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Box&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dyn&lt;/span&gt;&lt;span&gt;Future&lt;/span&gt;&lt;span/&gt;&lt;span&gt;+&lt;/span&gt;&lt;span/&gt;&lt;span&gt;Send&lt;/span&gt;&lt;span/&gt;&lt;span&gt;+&lt;/span&gt;&lt;span/&gt;&lt;span&gt;&#x27;async&amp;gt;&amp;gt;&lt;/span&gt;&lt;/code&gt; 的同步方法。因为装箱和动态派发的原因，性能上会有少许损失。&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;95679&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;214:629&quot;&gt;异步析构&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;当前 &lt;code&gt;&lt;span&gt;drop&lt;/span&gt;&lt;/code&gt;方法必须是同步调用，不能使用 &lt;code&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;语法。当一个 &lt;code&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;/code&gt;对象越过生命周期被析构，往往在关闭底层句柄之前，还需要完成某些 &lt;code&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;/code&gt;操作。比如，通知网络对端连接已经关闭。在同步代码中，我们只需要在 &lt;code&gt;&lt;span&gt;drop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/code&gt;中置入这些操作，但是在异步代码中，无法在 &lt;code&gt;&lt;span&gt;drop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/code&gt;中做类似的事情。&lt;/p&gt;&lt;p&gt;解决办法，总是在异步 &lt;code&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;/code&gt;对象越过生命周期之前显式地执行关闭动作，或是，实现一个类似 &lt;code&gt;&lt;span&gt;GC&lt;/span&gt;&lt;/code&gt;的功能，专门负责清理工作。&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93396&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;311:371&quot;&gt;展望&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;笔者在学习 &lt;code&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/code&gt;过程中，主要关注网络相关的并发编程。因为之前有在 &lt;code&gt;&lt;span&gt;Go&lt;/span&gt;&lt;/code&gt;版本的 &lt;code&gt;&lt;span&gt;ipfs&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/code&gt;上的开发经验，故而学习研究了 &lt;code&gt;&lt;span&gt;rust&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/code&gt;以及 &lt;code&gt;&lt;span&gt;nervos tentacle&lt;/span&gt;&lt;/code&gt;。&lt;code&gt;&lt;span&gt;rust&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/code&gt;是 &lt;code&gt;&lt;span&gt;Parity&lt;/span&gt;&lt;/code&gt;实现的准官方版本，但是这个项目的代码及其难懂，过于强调使用泛型参数的抽象，导致代码可读性非常差。请教了代码作者，他承认代码可能有些复杂，但也强调都是有原因的... &lt;code&gt;&lt;span&gt;nervos tentacle&lt;/span&gt;&lt;/code&gt;的实现在协议上不够完整，特别是与标准 &lt;code&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/code&gt;并不兼容。两个项目共有的特点是主要用 &lt;code&gt;&lt;span&gt;poll&lt;/span&gt;&lt;/code&gt;的方式写代码，逻辑上都是状态机的嵌套。&lt;/p&gt;&lt;p&gt;因此，笔者试图完全使用 &lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;方式重构 &lt;code&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/code&gt;，参考 &lt;code&gt;&lt;span&gt;rust&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/code&gt;的实现，代码协程化，向上层提供纯粹的异步接口，争取在 &lt;code&gt;&lt;span&gt;API&lt;/span&gt;&lt;/code&gt;层面的体验接近 &lt;code&gt;&lt;span&gt;go&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;libp2p&lt;/span&gt;&lt;/code&gt;，这是推广 &lt;code&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/code&gt;协程机制的一个尝试，同时也是个人的一个学习的过程。目前刚刚起步，仅完成了 &lt;code&gt;&lt;span&gt;secio&lt;/span&gt;&lt;/code&gt;与 &lt;code&gt;&lt;span&gt;yamux&lt;/span&gt;&lt;/code&gt;部分，待合适时机开源，期望更多 &lt;code&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/code&gt;爱好者共同来开发完善。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;参考：Asynchronous Destructors&lt;/p&gt;&lt;p&gt;链接：https://boats.gitlab.io/blog/post/poll-drop/&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eff1dc5700578f9809aeb6c4667e9dcd</guid>
<title>可视化测试策略</title>
<link>https://toutiao.io/k/e5rjr8o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content custom&quot;&gt;&lt;h1 id=&quot;可视化测试策略&quot;&gt;&lt;a href=&quot;#可视化测试策略&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 可视化测试策略&lt;/h1&gt; &lt;p&gt;有很多的模型/框架列出了你可以做的测试活动——但是在什么情况下做什么似乎没有什么帮助。我有两个可视化的想法——让我们探索如何可视化测试策略。是的，没有大小适合所有人的方法——上下文很重要。&lt;/p&gt; &lt;p&gt;这一切都始于我的一个同事问:“我们是否有任何测试框架/策略文档来描述目的以及哪种类型的客户需要哪种测试:单元测试、功能测试、数据处理测试、完整性测试”……+16个其他测试活动。&lt;/p&gt; &lt;p&gt;我很清楚，ISTQB列出并描述了上述测试活动，而启发式测试策略模型列出了启发式——对于这些活动什么时候更有价值，什么时候更有价值，以及在什么情况下它们最适用，几乎没有指导。显然，我们不应该对世界上的每一个测试项目都面面俱到。任何实践的价值都取决于它所处的环境——甚至试探法。&lt;/p&gt; &lt;p&gt;我们正在寻找的是一种讨论和可视化整个测试方法的方法。虽然这可以放在测试策略文档中(我经常这样做)——测试策略只是所选测试策略的书面叙述。测试覆盖策略和测试自动化策略是测试策略的一部分——但是我们首先要看到这些部分之间的关系。
一种解决方法是可视化管道：&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://jlottosen.files.wordpress.com/2020/08/image.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; &lt;p&gt;可视化管道！&lt;/p&gt; &lt;p&gt;如@lisacrispin和@aahunsberger所述，可视化管道可以帮助您找到从构想到部署的所有地方，可以对故事进行测试。 我认为该模型甚至也适用于非DevOps交付-测试可以在任何地方增加价值，而测试除了关门之外，还有更多
尽管如果您不清楚何时在SDLC /管道中采用不同的测试方法，则需要就手头的价值和可见性以及其他测试活动的相关性进行讨论。 该讨论还可以帮助详细说明上述可视化的方框。&lt;/p&gt; &lt;p&gt;另一种解决方法可能是制作沃德利地图&lt;/p&gt; &lt;p&gt;沃德利（Wardley）地图是具有风景地图特征的插图，可用于IT环境中的定向。 沃德利地图有两个维度：可见性和演化。&lt;/p&gt; &lt;p&gt;利益相关者的可见性可以是业务需求或感知价值，如“无法规无测试”中所使用。 进化主要涉及从未知/未知到嵌入式/工业化的相对位置。 例如，查看IT系统，重要的是要测试的系统如何发展：
&lt;img src=&quot;https://jlottosen.files.wordpress.com/2019/04/sut1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; &lt;p&gt;显然，SUT越新颖，相关的探索性测试就越多，同样，堆栈越标准化，连续测试的价值就越大。 …。 相对有价值，可能是更好的措辞。 元素的相对位置是Wardley地图的关键输出。 （以及稍后有关ET和CT之间的相对关系的更多信息）&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://jlottosen.files.wordpress.com/2020/08/image-3.png&quot; alt=&quot;&quot;/&gt;
向未知系统添加更多探索性测试&lt;/p&gt; &lt;p&gt;因此，首先我们可以根据底层IT结构的特征来定位测试活动。 其次，随着特性的变化，我们可以绘制每个测试活动的可见性和演变。 连续测试本身可以或多或少地变得可见，或多或少地被嵌入和工业化。
&lt;img src=&quot;https://jlottosen.files.wordpress.com/2020/08/image-2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; &lt;p&gt;正如ET和CT所提到的，我们现在可以使用该地图来讨论为什么针对特定项目同时需要CT和ET。 持续测试在价值链中与持续交付相关联，而探索性测试则更多地与最终用户构建正确事物的目标联系在一起，尤其是在隐性和隐性知识的情况下。&lt;/p&gt; &lt;p&gt;总结一下我的同事的问题–计划测试策略，我们需要了解管道，测试活动的相对价值以及测试活动的相对发展。&lt;/p&gt; &lt;h3 id=&quot;author&quot;&gt;&lt;a href=&quot;#author&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; author&lt;/h3&gt; &lt;p&gt;石头 磊哥 seven 随便叫&lt;/p&gt; &lt;h3 id=&quot;company&quot;&gt;&lt;a href=&quot;#company&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; company&lt;/h3&gt; &lt;p&gt;thoughtworks&lt;/p&gt; &lt;p&gt;大家好，本人不才，目前依旧混迹于thoughtworks，做着一名看起来像全栈的QA，兴趣爱好前端，目前是thoughtworks 西安QA社区的leader，如果有兴趣分享话题，或者想加入tw，可以找我&lt;/p&gt; &lt;h3 id=&quot;roles&quot;&gt;&lt;a href=&quot;#roles&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; roles&lt;/h3&gt; &lt;p&gt;QA（营生） dev（front-end dev 兴趣爱好）&lt;/p&gt; &lt;h3 id=&quot;联系方式&quot;&gt;&lt;a href=&quot;#联系方式&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; 联系方式&lt;/h3&gt; &lt;p&gt;如果想转载或者高薪挖我 请直接联系我 哈哈&lt;/p&gt; &lt;h4 id=&quot;wechat&quot;&gt;&lt;a href=&quot;#wechat&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; wechat:&lt;/h4&gt; &lt;p&gt;qileiwangnan&lt;/p&gt; &lt;h4 id=&quot;email&quot;&gt;&lt;a href=&quot;#email&quot; aria-hidden=&quot;true&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt; email:&lt;/h4&gt; &lt;p&gt;qileilove@gmail.com&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>