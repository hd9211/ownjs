<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8a38282634e25c3894dc500979da6058</guid>
<title>树莓派家用指北</title>
<link>https://toutiao.io/k/h2njn7z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;前两天刚刚入职，最近几天忙着租房搬家，忙活了几天总算是住进了自己小屋里，作为一个软件工程师，怎么可以没有一台家用服务器呢？方案有很多种，上至几千元的 NAS，下至淘汰的老电脑，但是旧电脑响声大功耗高，NAS 动辄三四千的价格对我这个刚毕业的大学生来说着实有些困难，于是我将目光放到了另一个小玩意上——树莓派。&lt;/p&gt;&lt;p&gt;我选择树莓派的原因也很简单，第一便宜，第二可查阅的资料非常多，基本上你之后使用过程中的问题网络上都有解决方案了，因此本文不会介绍怎么使用树莓派，怎么烧录系统，这些东西有太多人写过了，我重复写也没什么意思，因此这块内容我就一笔带过了，本文是我自己的家用服务器方案，更多的是提供一个方向性的指导，如果你觉得我的文章对你有所帮助，欢迎点个关注支持一下哦～&lt;/p&gt;&lt;h2&gt;什么是树莓派？&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTx7ehOiaRuJMA9FtXlibB7ibljibpn3sUAWiasLccmXIRaVfH9UxDmu6lZGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;打开任何一个搜索引擎在里面输入&lt;strong&gt;「树莓派」&lt;/strong&gt;三个字都会出现很多内容，其实树莓派本质上就是一台小电脑，虽然外形只有信用卡大小，却具有电脑的所有基本功能。和我们平常用的电脑不一样的是，树莓派自身是没有屏幕、键盘、鼠标这些东西的，但是它提供了网口、USB 口以及视频输出口（其实意思就是让你自己配）。&lt;/p&gt;&lt;p&gt;当然了，树莓派和主流电脑一个很大的区别就是他的芯片，和主流的 x86 桌面级电脑不同的是，树莓派用的是低功耗的 ARM 芯片，因此在性能上和常规电脑还是有些差距的，不过随着近年来 ARM 芯片的不断发展，其性能已经和传统 x86 处理器不相伯仲，甚至在某些方面遥遥领先，例如苹果的 M1 芯片。这里推荐阅读我之前写的两篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484658&amp;amp;idx=1&amp;amp;sn=58a2c7cde1ed027b26f1e2e41deb8bdb&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——x86 与 ARM 的爱恨情仇》&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484681&amp;amp;idx=1&amp;amp;sn=aa4ec453f111157205111ec3d6022c5c&amp;amp;chksm=ceb3d1bbf9c458ad33758e466664d1b0bcdc3e5a348f8ad47a6ac068c8102414cdfee6a1140d&amp;amp;scene=21&amp;amp;cur_album_id=1418449495750311936#wechat_redirect&quot; title=&quot;《M1 暴打 Intel？——这次的芯片有何不同》&quot; data-linktype=&quot;2&quot;&gt;《M1 暴打 Intel？——这次的芯片有何不同》&lt;/a&gt;&lt;/p&gt;&lt;p&gt;好在在学校的这些年，有一些闲置的键盘、鼠标和移动硬盘没来得及出手，于是我便果断的选择了树莓派作为我的家用服务器。&lt;/p&gt;&lt;h2&gt;树莓派的选择&lt;/h2&gt;&lt;p&gt;打开淘宝搜索树莓派，眼花缭乱的，那应该如何选择呢？&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7046979865771812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTvJgOL4qMmulyZyrHhXsry9rHS0GZbQsiaGSP0cdECshnpDQEl1nGfFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;其实很简单，虽然树莓派的型号众多，但是细分下来也只有三类：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;Model B 系列：旗舰版，接口全，性能强&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;Model A 系列：青春版，外形小，性能一般，配置和接口略有阉割&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;Zero 系列：迷你版，拥有超小身材，性能较弱&lt;/span&gt;&lt;/p&gt;&lt;p&gt;目前，树莓派已经发展到了第四代了，如果资金不是非常紧张的，推荐购买树莓派 4B 版，官网对他的介绍如下：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4879194630872483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicThVHIcc2Kkkn9X0E0otjPahP5F2ojRwh4PHlNxH8V7gsJ13CFtUMGzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;相较于前代，处理器性能大幅增强，并且最高支持 8G 内存，支持 4K 视频输出，同时使用 USB- C 供电，完全可以作为一个桌面级电脑使用了，用作家用服务器绰绰有余了。&lt;/p&gt;&lt;h2&gt;操作系统选择&lt;/h2&gt;&lt;p&gt;说完了树莓派的硬件，怎么可以离开软件呢？树莓派相较于传统电脑另一个好处就是可以自由选择烧录的操作系统，官方推荐的是 Raspberry Pi OS，系统的烧录网上的教程太多了，这里我推荐直接使用官方提供的烧录软件&lt;strong&gt;「Raspberry Pi Imager」&lt;/strong&gt;，从下面的图中也可以看出来是一个非常容易上手的软件了。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6588235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTKcrB20hDj7GAVX2ZiaYp2gsEp8MC3B63lXxM63dJN1ibfhxFunUZy92g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;SD 卡选择 16G 的即可，如果容量大一些也是可以的，读写速度自然也是越快越好了，这里我烧录的系统是官方推荐的 Raspberry Pi OS，针对树莓派进行了性能优化，由于是基于 Debian 开发的操作系统，经常使用 Ubuntu 的同学上手难度会稍微低一些。&lt;/p&gt;&lt;p&gt;当然了，你也可以选择烧录其他的操作系统，例如 Ubuntu、Manjaro、Android 等操作系统，甚至有人成功烧录了最近新出的 Windows11，链接在这里，有兴趣的小伙伴自行阅读 👉&lt;span&gt;How to Install Windows 11 on a Raspberry Pi 4&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0615640599001663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT1jkQy4JIjMvAfGCWC2NzB3YsTQcfOcBviaup2p6gia2JRZdKTrHBgfjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;家用树莓派方案指北&lt;/h2&gt;&lt;p&gt;说了树莓派软硬件的选择后，终于可以进入本文的正题了。&lt;/p&gt;&lt;p&gt;树莓派的玩法有很多，网上有很多控制机器人、外接灯泡控制开关等，说实话，这些玩法教育意义大于实用意义，毕竟家用也不会把灯泡接到树莓派上，直接买个小米的智能灯泡控制体验不比这个好吗？&lt;/p&gt;&lt;p&gt;之所以一开始就舍弃使用旧电脑作为家用服务器这一方案的一个原因就是功耗，网上有人对树莓派的功耗进行过测试，4B 的功耗：空闲时 2.7 W，负载时到 6.4 W。按照家里电费 0.7 元一度电的价格计算，一年 365 天每天 24 小时高负荷运行的电费也才&lt;strong&gt;6.4×24×365÷1000×0.7=39.2448 元&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4318181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT7EIlMpGUIsHYLiaB12VcHTYb14mUFibcIcdSWLnMFDh9gongpAE2w3Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;因此树莓派适用于一些适合 24 小时在线的服务，我的服务有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;离线下载（Aria2、qbittorrent）&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;米家、HomeKit 等智能家居中转控制（HomeAssistant）&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;局域网文件共享（Samba）&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;Linux Server（Docker）&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;家庭 Dashboard 中控面板（Flutter Web）&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;接下来我将会按照顺序逐一介绍。&lt;/p&gt;&lt;h3&gt;连接树莓派——连通性测试&lt;/h3&gt;&lt;p&gt;想要使用树莓派第一步肯定是连接上树莓派，连接树莓派的方式有很多种，直接接键盘、鼠标、显示器，或者通过 SSH/VNC/FTP，无论用何种方式只要能连接上网络即可。方便起见，建议先连接显示器，然后开启 SSH 和 VNC 服务。网络上的教程很多很详细，这里不再赘述。&lt;/p&gt;&lt;p&gt;本节主要来介绍一个很关键但是很多文章都忽略的内容，即树莓派与个人电脑间的&lt;strong&gt;网络连通性测试&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;如果要实现诸如上述局域网共享文件、离线下载等功能，一个很重要的特点是工作电脑与树莓派之间的&lt;strong&gt;传输速度要快&lt;/strong&gt;，不然我离线下载完文件后传到自己电脑上还要好久，那岂不是多此一举吗？&lt;/p&gt;&lt;p&gt;由于大多数教程中工作电脑与树莓派的连接都是通过 WI-FI 而非网线的方式，因此在一开始就有必要针对二者的网络传输速度做一个测试，这里我推荐使用&lt;strong&gt;「iPerf3」&lt;/strong&gt;，安装和使用都很简单。&lt;/p&gt;&lt;p&gt;我们需要在树莓派上使用 apt 安装 iPerf3，然后启动 iPerf3 的服务。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 安装 iPerf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo apt install iperf3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 启动 iPerf3 服务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -p 3005 -s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-p&lt;/code&gt;设置监听的端口号，客户端需要使用该端口与服务端进行通信。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;code&gt;-s&lt;/code&gt;设置为服务模式运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;然后在工作电脑上也安装上 iPerf3 即可，mac 电脑直接执行 &lt;code&gt;brew install iperf3&lt;/code&gt; 即可安装，然后我们只需执行下面的命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 测试 Mac 与树莓派之间的网速（我的树莓派内网 ip 为192.168.31.189）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;iperf3 -c 192.168.31.189 -p 3005&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;我的测试结果如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6466165413533834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTibITmOLGJkricBnYcc9YS7yKH1ib0eb7u1mPuqv9WaawysuQx2GxGngjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;换算一下，上传下载大约能有 7MB/s 的速度，虽然速度不是很快，但是基本可以用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;PS：如果有小伙伴测试结束后发现连通速度有些慢，不妨检查下你的树莓派是否连接到 5GHz 的 Wi-Fi 上。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;确认连接速度可以正常使用后，我们便可以来安装使用一个非常重要的工具了——Docker。&lt;/p&gt;&lt;h3&gt;使用 Docker 为树莓派赋能&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7486263736263736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT2Fr6cZjH9WACvSLh0dYO9fFZIEibCMOMWZotfhwkYK1Zu46gDuorF4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Docker 的存在使得开发者可以快速搭建自己所需要的开发环境，只需指定好镜像后即可快速生成所需要的容器环境。并且由于树莓派使用的是 ARM 架构的芯片，很多常用软件如果想要正常安装使用需要自行编译，这对于性能不够强悍的树莓派来说无疑是一种负担，为了让我们的精力聚焦在在实际的开发中，而不是纠缠着应用运行环境的问题上，这次我们使用 Docker 搭建所需要的开发环境，为树莓派赋能。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对 Docker 还不了解的小伙伴可以移步 👉https://yeasy.gitbook.io/docker_practice/&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在树莓派上安装 Docker、配置镜像加速在上面的链接中都已给出，值得一提的是，Docker 的定位在于将容器内的环境搭建起来，但如果我们想将多个容器的运行方式和配置固定下来，应用于容器编排，则需要使用 Docker Compose。&lt;/p&gt;&lt;p&gt;举个例子，我们有一个应用容器，需要 mysql 存储数据， nginx 作转发，消息队列作数据转化，那在每次启动前，需要将每个前置容器先启动，再把应用容器跑起来，这本身就是一个重复的动作。而且在启动时，还需要针对每个容器进行不同的配置，所以为了&lt;strong&gt;实现对多个容器的组合管理&lt;/strong&gt;，例如规定容器启动顺序，规定好配置内容等行为，Docker Compose 便应运而生了。&lt;/p&gt;&lt;p&gt;Docker Compose 的安装方式有很多种，但由于 ARM 架构的限制，树莓派上的 Docker Compose 建议使用 pip 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo pip3 install -U docker-compose&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;！！！一定是 Python3 版本的 pip，所以建议直接使用 pip3&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;监管你的 Docker——Portainer&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5233333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTD9wIsaZOzkA31AuYvX5IzGcuW6mrjLLZeuHQomW5Gr1iajwpvXKoD5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Portainer 是 Docker 的轻量级，跨平台和开源管理 UI。你可以通过 WebUI 管理你的 docker 容器，镜像，网络和卷。他的安装也很简单，直接执行以下命令即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;安装完成后如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.41005291005291006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTpD94aK3Lky6cAdpGibBtEpkTwytqAcsLJguV7ib3liaVXsnXRSKxpBcoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;监控面板——Pi Dashboard&lt;/h3&gt;&lt;p&gt;有了 Docker 之后，我们便可以方便快速的进行各种软件的安装了。为了方便监控我们的树莓派情况，首当其冲的便是 Pi Dashboard。&lt;/p&gt;&lt;p&gt;安装很简单，只需执行下面一行命令 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker run -d --name docker-pi-dashboard -e &#x27;LISTEN=1024&#x27; --net=host ecat/docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;启动完毕后可以通过&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo docker ps | grep docker-pi-dashboard&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;来确认我们的容器是否启动成功，如果启动成功，在浏览器中输入&lt;code&gt;&amp;lt;你的IP地址&amp;gt;:1024&lt;/code&gt;即可访问到 pi dashboard 了。如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6252676659528907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTOCVPxErLfCYfmw2fO5kJAwX9bibyoqmmUOicfxPCLUXWl1F1NPXOBVvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;智能家居——HomeAssistant&lt;/h3&gt;&lt;p&gt;智能家居是眼下最火的领域之一，小米、苹果、华为等都在布局该领域，旗下的米家、HomeKit 等都已经提供了非常完善的服务，那么我们为什么要在树莓派上搭建一套智能家居系统呢？&lt;/p&gt;&lt;p&gt;其实原因很简单，虽然目前智能家居产品众多，但是尚未有一种智能家居解决方案同时满足设备种类多、交互体验好、成本低廉的特性，为此很多情况我们都会选择某一家的某一些产品，这就有可能会造成整个家里出现小米的台灯、华为的传感器、苹果的音箱等多种混乱的局面，然后你还要安装多个 App，这种体验无疑是非常差的。&lt;/p&gt;&lt;p&gt;在计算机领域有一句名言——&lt;strong&gt;所有兼容问题都可以通过加一层抽象解决，所有性能问题都可以通过去掉一层抽象解决。&lt;/strong&gt;既然这样，何不在这些智能家居平台基础上再抽出一层，提供一个统一的控制入口？&lt;/p&gt;&lt;p&gt;答案自然是可以的，并且已经有人将方案开源出来了，这就是本节要介绍的 HomeAssistant。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.45717344753747324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXkKkHVKzL0Yncs1I7KQIjaZJMwQfMKbelBzQ2bv24KY8ODf4aJsD1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;无论是米家还是 HomeKit 都只能在各自的生态中使用，米家只有移动端 App，HomeKit 虽然覆盖了平板、手机、电脑、手表等，但也仅限苹果生态。（互联网发展了这么多年，却忘记了他最开始的形态，真不知道这是一种进步还是一种悲哀）&lt;/p&gt;&lt;p&gt;扯了这么远，回到正题，HomeAssistant 的安装使用非常简单，官网已经写的非常详细了 👉https://www.home-assistant.io/installation/raspberrypi#docker-compose&lt;/p&gt;&lt;p&gt;推荐使用 Docker Compose 安装。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;version: &quot;3&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;services:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  homeassistant:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    container_name: homeassistant&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    image: &quot;ghcr.io/home-assistant/raspberrypi4-homeassistant:stable&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    volumes:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /PATH_TO_YOUR_CONFIG:/config&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      - /etc/localtime:/etc/localtime:ro&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    restart: unless-stopped&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    privileged: true&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    network_mode: host&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;指定好 volumes 的路径后执行&lt;code&gt;docker-compose up -d&lt;/code&gt;指令即可。&lt;/p&gt;&lt;h3&gt;米家的接入&lt;/h3&gt;&lt;p&gt;安装好之后你的家庭应该是空的，如果想要绑定米家设备，可以接入米家的 MIoT 插件，文档 👉https://github.com/al-one/hass-xiaomi-miot/blob/master/README_zh.md&lt;/p&gt;&lt;p&gt;填写好自己的小米账号和密码后，即可利用网页在 HomeAssistant 中查看使用自己的米家设备，以此达到跨平台的目的。下图是我自己配置的控制页面 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3484848484848485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTsR1YcHs9vBAibtibTwU5zdHvibbxlCCuLyZS8LdUhJMQ6YBxIZ1vn26lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1914&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;开放能力——REST API&lt;/h3&gt;&lt;p&gt;如果只是提供了一个网页用于控制，那么本质上也就是在交互体验上进行了优化，并不值得单独开一小节。HomeAssistant 作为一个开源产品，最大的优势在于提供了开放的能力，使每个用户按照自己的想法去进行更改设置，我们完全可以根据 HA 提供的 REST API 针对自己的需求定制化。（例如制作一个属于你自己的家庭枢纽，后面会提到）&lt;/p&gt;&lt;p&gt;HomeAssistant 默认是不会开放 REST API 功能，你需要在&lt;code&gt;configuration.yaml&lt;/code&gt;文件中配置一下&lt;code&gt;api&lt;/code&gt;选项，如下图所示 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.39290586630286495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTHfG7yg2o5nCMjVsWoXXYpwx2IElEsrm71gUeibH9EicPOWsQicecp8QQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于 HomeAssistant 可配置的选项还有很多，具体的可以参考文档 👉https://developers.home-assistant.io/&lt;/p&gt;&lt;h3&gt;离线下载——Aria2&lt;/h3&gt;&lt;p&gt;有些资源下载时间较长，不适合电脑长期挂机下载的，这时就可以将我们的树莓派变成一个离线下载的服务器。提到下载，不可不提的一个神器便是 Aria2。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2391713747645951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTUXus5gHY0Q8YibCGOhBU1epNMlme8PEVP8ibE4htSbckTJw0wreZ3xkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Aria2 是一款自由、跨平台&lt;strong&gt;命令行界面&lt;/strong&gt;的下载管理器，和 wget 这类下载器不同的是，Aria2 不仅支持 BitTorrent，还能够从各种来源多路检索所请求的文件。包括 HTTP，HTTPS，FTP 和 BitTorrent 协议。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对种子下载原理感兴趣的同学可以阅读我的这篇文章 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484780&amp;amp;idx=1&amp;amp;sn=f4c12708e159821f700811b1dc1be35c&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&quot; data-linktype=&quot;2&quot;&gt;《人人都是 LSP？—— 种子与文件下载的相爱相杀》&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;而且 Raspbain 系统默认已经安装了 Aria2，运行 apt-cache show aria2 即可查看安装信息，因此我们要做的就是为 Aria2 找一个图形化界面即可，使用 Docker 的一大好处就是可以直接去找别人已经打包好的镜像文件，让安装使用变得十分易用。&lt;/p&gt;&lt;p&gt;只需执行下述命令即可启动一个 Aira2 的图形化界面了 👇&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker run -d --name aria2-ui-pi -p 8888:80 -p 6800:6800 -v /data:/data --restart=always huangzulin/aria2-ui-pi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;默认下载路径是在容器内的 /data 文件夹，为了方便使用最好指定一个 volume 映射&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;局域网文件共享——Samba&lt;/h3&gt;&lt;p&gt;现在，手机是 Android/iOS，电脑是 Win/Mac，除去苹果生态，设备与设备之间的文件传输直至今日仍然是一个大问题。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.42875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTXa1WnX0lGtFUcY4WpuByyFDrQ89H8M8L5F7Ytu1CVR8MTScyZaIr8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;Samba 是在 Linux 和 UNIX 系统上实现 SMB 协议的一个免费软件，SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。通过该协议，你可以快速方便的在 Win 与 Linux/Unix 之间分享文件，而不是通过 QQ 在线传文件。&lt;/p&gt;&lt;p&gt;安装过程也十分简单，你可以选择 apt 安装也可以选择 docker 直接安装，网上的教程非常多，详情可参考 👉&lt;span&gt;在树莓派上配置 Samba 服务教程&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;打造属于你自己的家庭枢纽&lt;/h3&gt;&lt;p&gt;无论是 HomeAssistant 还是 Aria2，这些都是别人写好的东西，如果你想让树莓派更加定制化，你可以按照自己的想法去边写一些小程序（这也就是为什么之前要提一下开放 HomeAssistant 的 REST API）。&lt;/p&gt;&lt;p&gt;如果想要让自己的程序运行在树莓派上，大致有以下几条路可以走 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5580568720379147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicT6ZX8icIuZPtCNtvIHdJ6Ply072d2icJjr1icTgPPAs3mZefHpw4RC4wAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了打造一个属于自己的家庭枢纽，我的想法是在一块&lt;strong&gt;可以触摸的屏幕&lt;/strong&gt;上控制自己家的智能家居设备（借助 HomeAssistant），直观地查看天气（和风天气），追踪快递行程（爬虫）、时钟、纪念日/倒数日/照片墙等，因此这是一个完整的网页，我选择的技术栈是 SpringBoot + Flutter Web + Nginx，然后使用 Docker 打包成一个镜像启动整个服务。&lt;/p&gt;&lt;p&gt;部分页面如下 👇&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4071573261309926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTQODBvtibq3uNmOM6nHcfU9ckyDenX7jMALXWp1ygakePmAicDDN1WW8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1481&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我在做的就是 Java 相关的工作，后端选择 SpringBoot 无可厚非，之所以选择 Flutter Web 而不是传统的 Vue 或者 React，一方面是因为 Flutter 的声明式 UI 写起来确实比传统 Web 页面编写更舒服，效率更高，另一方面是因为用 Flutter 写的网页可以无缝转换成在 Android/iOS/PC/Linux/macOS 这些平台上的原生 App，有助于后期针对多个平台的覆盖（当然更多还是因为我已经把 Vue 和 React 忘的差不多了)。&lt;/p&gt;&lt;p&gt;目前这个网页比较简陋，还有很多我想做的功能没来得及做上去，但后续我准备持续更新这个代码，后续如果在家里运行效果还不错的话，甚至有想开源出去的想法，不过这就是后话了。&lt;/p&gt;&lt;h3&gt;随时随地访问——内网穿透&lt;/h3&gt;&lt;p&gt;玩了这么多东西，有没有发现一个最大的问题？&lt;/p&gt;&lt;p&gt;没错，就是这些所有的东西必须要求你的电脑和树莓派处在同一个网络里，即局域网环境里。虽然我一开始的使用场景就是在家里使用，但如果我在公司突然想看一部美剧了，但是用公司电脑下载视频显然是不现实的，如果这时候我可以在外网直接访问家里树莓派的离线下载服务，那么下班回家后岂不就可以看到自己想看的电影了吗？&lt;/p&gt;&lt;p&gt;所以，最好的方式就是联系你的宽带运营商，并申请一个公网 IP，这样你就可以通过这个公网 IP 访问到你的树莓派了。&lt;/p&gt;&lt;p&gt;据我所知，目前只有电信的部分地区会给公网 IP，大多数运营商是不会提供公网 IP 的，而且申请流程很麻烦，所以为了可以随时随地的从外网访问家里服务器的文件或其他服务，我们可以为树莓派做一个&lt;strong&gt;「内网穿透」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.32531824611032534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLLziazMtXZicKqhIu94GufrehGj2OZPvDRlqxI7FNybPLx5HBZfjRxuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;「计算机领域的大多数问题都可以通过增加一层来解决」，所谓内网穿透，无非是在内部网络和互联网之间增加一个中转服务器，这个中转服务器负责接收你的请求并转发到内部服务器，也即&lt;strong&gt;「代理」&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当然了，内网穿透的原理肯定不会这么简单，这里只是通俗的解释一下，如果之后有机会来详细说下。所以为了实现内网穿透，我们需要有一台可以公网访问的服务器作为中转桥梁，这时我突然想到我毕业前买的学生机还没到期呢，现在刚好在吃灰，拿它来做中转岂不是最好的？&lt;/p&gt;&lt;p&gt;内网穿透服务器的选择有很多，FRP 是用的最多的，但我这里选择的是 👉&lt;span&gt;nps&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;，原因也很简单，页面好看，交互简单，性能够用。&lt;/p&gt;&lt;p&gt;nps 是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持 tcp、udp 流量转发，可支持&lt;strong&gt;任何 tcp、udp 上层协议&lt;/strong&gt;（访问内网网站、本地支付接口调试、ssh 访问、远程桌面，内网 dns 解析等等……），此外还支持内网 http 代理、内网 socks5 代理、p2p 等，并带有功能强大的 web 管理端。&lt;/p&gt;&lt;p&gt;我们只需要在云主机上安装好服务端，并按照后台提示在树莓派上安装好客户端，简单设置自己要转发的端口即可实现内网穿透。&lt;/p&gt;&lt;p&gt;官方文档在 👉https://ehang-io.github.io/nps/#/?id=nps&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2GybwibD5l6qawfY2P9bbCyBqicTLzqYLx5Eus5D03LDor9OCorJn6Licv6QtLg3NibpdpicEia3Zf4eZhPAeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;拥有一台树莓派最大的好处就是可以充分发挥你的灵感与创意，如果你有想法、有能力、有时间，不妨让树莓派成为你实现想法的载体。&lt;/p&gt;&lt;p&gt;最后扯一点文章之外的，工作之后的时间果然少了很多，这篇文章从开始写到现在完成差不多花了一个星期，阿里的工作强度的确很大，每天下班到家多半也是 10 点之后的事情了，能留出来码字的时间实在有限，难得周末有空，把近期搬家捣鼓自己家的想法写下来，也算是自己新阶段的开始。这段时间阅读了很多内部的优秀文档，也希望自己未来的文章可以像内网的大神们一样更专业，新的征程加油！&lt;/p&gt;&lt;p&gt;以上就是本文的全部内容了，如果觉得还不错的话，不妨给我一个点赞关注支持一下哦 👍&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; How to Install Windows 11 on a Raspberry Pi 4: &lt;em&gt;https://www.tomshardware.com/how-to/install-windows-11-raspberry-pi#xenforo-comments-3710927&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 在树莓派上配置 Samba 服务教程: &lt;em&gt;https://ee-fans.com/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E9%85%8D%E7%BD%AEsamba%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; nps: &lt;em&gt;https://github.com/ehang-io/nps&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d6d66b247b16b0941ea36723ed241ae</guid>
<title>Abp 太重了？轻量化 Abp 框架</title>
<link>https://toutiao.io/k/jwxxjl6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;本文首发于个人博客（https://blog.zhangchi.fun/）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在进行框架的选型时，经常会听到“***框架太重了”之类的声音，比如“Abp太重了，不适合我们...”。事实上，Abp框架真的很重吗？&lt;/p&gt;&lt;p&gt;框架的“轻”和“重”，我没有在网上找到明确的定义，通过阅读一些技术博客，大致可以把框架的“轻”和“重”通过以下几个方面进行区分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;所依赖程序集的数量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所实现的功能的多少&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上手难度及易用性&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;“轻量级”的框架，大概指的是一个程序集依赖少且程序集文件小、功能虽少但足够满足需求、上手容易使用简单的框架；“重量级”的框架，大概指的是一个程序集依赖多且程序集文件大、功能丰富但大多数用不到、上手困难且使用困难的框架。&lt;/p&gt;&lt;p&gt;这篇文章将从上述几个方面来探索Abp是一个“轻量级”还是“重量级”的框架。&lt;/p&gt;&lt;h2&gt;最小依赖&lt;/h2&gt;&lt;p&gt;Abp开发了一些启动模板来为我们生成项目。启动模板采用了领域驱动设计的分层方案来建立项目层级，包括了&lt;strong&gt;展示层&lt;/strong&gt;、&lt;strong&gt;应用层&lt;/strong&gt;、&lt;strong&gt;领域层&lt;/strong&gt;与&lt;strong&gt;基础设施层&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6JK0Hq5Psqon1LXadBDibBNEcREztb0AHZS5GfCWnYI6SLDEJCMRb61MUaLPKuRhe1lhq4dt7gkFEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1979434447300772&quot; data-w=&quot;389&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们通常都会通过Abp CLI或Abp.io来创建类似上图架构的项目。Abp为我们生成的项目，减少了我们初始化项目的工作量，开箱即用，因此将我们可能会使用的Nuget包预先引入到我们的项目中，也就给我们一种依赖项太多的感觉。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6JK0Hq5Psqon1LXadBDibBNEhcSWWDYib7lVwXqr8w0wZ9mdHwNv7GibI0JuTibqib5S3yjxNz8wJ1lg4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1533980582524272&quot; data-w=&quot;515&quot;/&gt;&lt;/p&gt;&lt;p&gt;从架构设计上来讲，&lt;strong&gt;模块化&lt;/strong&gt;是Abp的核心；而从技术角度来看，&lt;strong&gt;依赖注入&lt;/strong&gt;则是Abp实现众多功能的一个主要手段。只要了解Abp的&lt;strong&gt;模块化&lt;/strong&gt;和&lt;strong&gt;依赖注入&lt;/strong&gt;，我们就能够基于Abp框架来进行项目开发。&lt;/p&gt;&lt;p&gt;接下来将创建一个原生的&lt;code&gt;ASP.NET Core Web API&lt;/code&gt;项目，围绕&lt;strong&gt;模块化&lt;/strong&gt;和&lt;strong&gt;依赖注入&lt;/strong&gt;两个核心概念，来展示如何以最小依赖的方式使用Abp。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;通过VS或者dotNet cli新建一个原生的&lt;code&gt;ASP.NET Core Web API&lt;/code&gt;项目，命名为&lt;code&gt;LightweightAbp&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;安装Nuget包&lt;code&gt;Volo.Abp.Autofac&lt;/code&gt;和&lt;code&gt;Volo.Abp.AspNetCore.Mvc&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将项目进行&lt;strong&gt;模块化&lt;/strong&gt;：在项目根目录新建一个Abp&lt;strong&gt;模块&lt;/strong&gt;代码文件&lt;code&gt;LightweightAbpModule.cs&lt;/code&gt;，并复制以下代码：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;[DependsOn(&lt;br/&gt;    typeof(AbpAutofacModule),&lt;br/&gt;    typeof(AbpAspNetCoreMvcModule))]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpModule&lt;/span&gt; : AbpModule&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(ServiceConfigurationContext context)&lt;br/&gt;    {&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnApplicationInitialization&lt;/span&gt;(ApplicationInitializationContext context)&lt;br/&gt;    {&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[DependsOn(&lt;br/&gt;    typeof(AbpAutofacModule),&lt;br/&gt;    typeof(AbpAspNetCoreMvcModule))]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpModule&lt;/span&gt; : AbpModule&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(ServiceConfigurationContext context)&lt;br/&gt;    {&lt;br/&gt;        context.Services.AddControllers();&lt;br/&gt;        context.Services.AddSwaggerGen(c =&amp;gt;&lt;br/&gt;        {&lt;br/&gt;            c.SwaggerDoc(&lt;span&gt;&quot;v1&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; OpenApiInfo { Title = &lt;span&gt;&quot;LightweightAbp&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;v1&quot;&lt;/span&gt; });&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnApplicationInitialization&lt;/span&gt;(ApplicationInitializationContext context)&lt;br/&gt;    {&lt;br/&gt;        var app = context.GetApplicationBuilder();&lt;br/&gt;        var env = context.GetEnvironment();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (env.IsDevelopment())&lt;br/&gt;        {&lt;br/&gt;            app.UseDeveloperExceptionPage();&lt;br/&gt;            app.UseSwagger();&lt;br/&gt;            app.UseSwaggerUI(c =&amp;gt; c.SwaggerEndpoint(&lt;span&gt;&quot;/swagger/v1/swagger.json&quot;&lt;/span&gt;, &lt;span&gt;&quot;LightweightAbp v1&quot;&lt;/span&gt;));&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        app.UseRouting();&lt;br/&gt;&lt;br/&gt;        app.UseAuthorization();&lt;br/&gt;&lt;br/&gt;        app.UseEndpoints(endpoints =&amp;gt;&lt;br/&gt;        {&lt;br/&gt;            endpoints.MapControllers();&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Startup&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(IServiceCollection services)&lt;br/&gt;    {&lt;br/&gt;        services.AddApplication&amp;lt;LightweightAbpModule&amp;gt;();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Configure&lt;/span&gt;(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)&lt;br/&gt;    {&lt;br/&gt;        app.InitializeApplication();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder &lt;span&gt;CreateHostBuilder&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;br/&gt;            Host.CreateDefaultBuilder(args)&lt;br/&gt;                .ConfigureWebHostDefaults(webBuilder =&amp;gt;&lt;br/&gt;                {&lt;br/&gt;                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();&lt;br/&gt;                })&lt;br/&gt;                .UseAutofac();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此项目的创建完成了。可以看到，仅仅依赖了&lt;code&gt;Volo.Abp.Autofac&lt;/code&gt;和&lt;code&gt;Volo.Abp.AspNetCore.Mvc&lt;/code&gt;两个Nuget包，即可利用Abp进行开发。若从所依赖Nuget包数量来评估框架的“轻”和“重”，那么Abp不可谓不轻。&lt;/p&gt;&lt;h2&gt;功能按需使用&lt;/h2&gt;&lt;p&gt;得益于&lt;strong&gt;模块化&lt;/strong&gt;设计，Abp将其所能提供的功能，划分并封装到了不同的&lt;strong&gt;模块&lt;/strong&gt;中。要想使用Abp提供的某一功能，只需引入相关的Nuget包并依赖（&lt;code&gt;DependsOn&lt;/code&gt;）模块即可。&lt;/p&gt;&lt;h3&gt;数据访问&lt;/h3&gt;&lt;p&gt;要想实现数据访问功能，首先我们需要定义&lt;code&gt;Entity&lt;/code&gt;、&lt;code&gt;DbContext&lt;/code&gt;并配置数据库支持。在Abp的层次架构中，&lt;code&gt;Entity&lt;/code&gt;、&lt;code&gt;Repository&lt;/code&gt;属于领域层，&lt;code&gt;Service&lt;/code&gt;属于应用层，&lt;code&gt;DbContext&lt;/code&gt;则属于&lt;code&gt;EntityFramework Core&lt;/code&gt;模块，因此我们按需引入所需模块即可。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;安装Nuget包&lt;code&gt;Volo.Abp.Ddd.Application&lt;/code&gt;、&lt;code&gt;Volo.Abp.Ddd.Domain&lt;/code&gt;和&lt;code&gt;Volo.Abp.EntityFrameworkCore.Sqlite&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在&lt;code&gt;LightweightAbpModule&lt;/code&gt;类中配置&lt;code&gt;DependsOn&lt;/code&gt;特性，将&lt;code&gt;AbpDddApplicationModule&lt;/code&gt;、&lt;code&gt;AbpDddDomainModule&lt;/code&gt;和&lt;code&gt;AbpEntityFrameworkCoreSqliteModule&lt;/code&gt;模块依赖到我们的项目模块中。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;    [DependsOn(&lt;br/&gt;        typeof(AbpAutofacModule),&lt;br/&gt;        typeof(AbpAspNetCoreMvcModule),&lt;br/&gt;        typeof(AbpDddApplicationModule),&lt;br/&gt;        typeof(AbpDddDomainModule),&lt;br/&gt;        typeof(AbpEntityFrameworkCoreSqliteModule))]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpModule&lt;/span&gt; : AbpModule&lt;br/&gt;    { ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;using&lt;/span&gt; System;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; Volo.Abp.Domain.Entities;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;namespace&lt;/span&gt; LightweightAbp&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Book&lt;/span&gt; : Entity&amp;lt;Guid&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { get; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[ConnectionStringName(&lt;span&gt;&quot;Default&quot;&lt;/span&gt;)]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LightweightAbpDbContext&lt;/span&gt; : AbpDbContext&amp;lt;LightweightAbpDbContext&amp;gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;LightweightAbpDbContext&lt;/span&gt;(DbContextOptions&amp;lt;LightweightAbpDbContext&amp;gt; options)&lt;br/&gt;        : &lt;span&gt;base&lt;/span&gt;(options)&lt;br/&gt;    { }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Book&amp;gt; Books { get; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnModelCreating&lt;/span&gt;(ModelBuilder builder)&lt;br/&gt;    {&lt;br/&gt;        base.OnModelCreating(builder);&lt;br/&gt;&lt;br/&gt;        builder.Entity&amp;lt;Book&amp;gt;(b =&amp;gt;&lt;br/&gt;        {&lt;br/&gt;            b.ToTable(nameof(Books));&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ConfigureServices&lt;/span&gt;(ServiceConfigurationContext context)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    context.Services.AddAbpDbContext&amp;lt;LightweightAbpDbContext&amp;gt;(options =&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        options.AddDefaultRepositories(includeAllEntities: &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    Configure&amp;lt;AbpDbContextOptions&amp;gt;(options =&amp;gt;&lt;br/&gt;    {&lt;br/&gt;        options.UseSqlite();&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;&quot;ConnectionStrings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;Default&quot;&lt;/span&gt;: &lt;span&gt;&quot;Data Source=LightweightAbp.db&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;dotnet ef migrations add InitialCreate&lt;br/&gt;dotnet ef database update&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; interface IBookAppService&lt;br/&gt;{&lt;br/&gt;    Task &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookAppService&lt;/span&gt; : ApplicationService, IBookAppService&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; IRepository&amp;lt;Book, Guid&amp;gt; Repository =&amp;gt; LazyServiceProvider.LazyGetRequiredService&amp;lt;IRepository&amp;lt;Book, Guid&amp;gt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name)&lt;br/&gt;    {&lt;br/&gt;        var book = await Repository.InsertAsync(&lt;span&gt;new&lt;/span&gt; Book()&lt;br/&gt;        {&lt;br/&gt;            Name = name&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; book.Name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[ApiController]&lt;br/&gt;[Route(&lt;span&gt;&quot;[controller]&quot;&lt;/span&gt;)]&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookController&lt;/span&gt; : AbpController&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; readonly IBookAppService _service;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;BookController&lt;/span&gt;(IBookAppService service)&lt;br/&gt;    {&lt;br/&gt;        _service = service;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    [HttpGet]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; _service.CreateAsync(name);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6JK0Hq5Psqon1LXadBDibBNEBbtmfgFew2qicbX1ibDCCg532icN21ibt64HB0rx8gmBH3tXOzbBmI1lBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0629629629629629&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里我们实现了简单的数据插入。可以看到，项目中并没有使用复杂架构和复杂的领域驱动设计，仅引用并配置Abp模块，即可使用常规的 &lt;code&gt;ASP.NET Core Web API&lt;/code&gt;方式进行开发。&lt;/p&gt;&lt;h3&gt;缓存&lt;/h3&gt;&lt;p&gt;接下来我们将继续实现缓存功能。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; interface IBookAppService&lt;br/&gt;{&lt;br/&gt;    Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name);&lt;br/&gt;&lt;br/&gt;    Task&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; &lt;span&gt;GetAllAsync&lt;/span&gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookAppService&lt;/span&gt; : ApplicationService, IBookAppService&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; readonly IRepository&amp;lt;Book, Guid&amp;gt; _repository;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; readonly IDistributedCache&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; _cache;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;BookAppService&lt;/span&gt;(&lt;br/&gt;        IRepository&amp;lt;Book, Guid&amp;gt; repository,&lt;br/&gt;        IDistributedCache&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; cache)&lt;br/&gt;    {&lt;br/&gt;        _repository = repository;&lt;br/&gt;        _cache = cache;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; &lt;span&gt;CreateAsync&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; name)&lt;br/&gt;    { ... }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; &lt;span&gt;GetAllAsync&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; await _cache.GetOrAddAsync(&lt;br/&gt;            &lt;span&gt;&quot;AllBooksName&quot;&lt;/span&gt;,&lt;br/&gt;            async () =&amp;gt; await _repository.Select(b =&amp;gt; b.Name).ToArrayAsync(),&lt;br/&gt;            () =&amp;gt; &lt;span&gt;new&lt;/span&gt; DistributedCacheEntryOptions&lt;br/&gt;            {&lt;br/&gt;                AbsoluteExpiration = DateTimeOffset.Now.AddHours(1)&lt;br/&gt;            }&lt;br/&gt;        );&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BookController&lt;/span&gt; : AbpController&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;&lt;br/&gt;    [HttpGet(&lt;span&gt;&quot;all&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;[]&amp;gt; &lt;span&gt;GetAllAsync&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; _service.GetAllAsync();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们实现了缓存功能。显而易见，按需使用缓存功能所在的Nuget包及模块即可，并没有很多繁杂的操作。&lt;/p&gt;&lt;p&gt;众所周知，Abp实现了相当多的功能，其中有些功能也许整个项目生命周期中都不会用到。得益于&lt;strong&gt;模块化&lt;/strong&gt;的方式，我们可以只依赖我所需要的Nuget包和Abp模块。如果根据功能多少来评判框架的“轻”和“重”，我们按需依赖不同模块时Abp框架不可谓不轻。由此可见，一个框架的“轻”和“重”，有时还会取决于使用方式。&lt;/p&gt;&lt;h2&gt;上手难度及易用性&lt;/h2&gt;&lt;p&gt;学习一门新技术最好的起点便是官方文档，Abp也是如此，Abp的官方文档非常详尽介绍了各个功能。Abp还为我们提供了启动模板，模板遵循了领域驱动设计的最佳实践来进行项目分层，并且为我们继承了很多项目中常用的功能模块。&lt;/p&gt;&lt;p&gt;对于初学者而言，面对一个复杂的分层架构及丰富的功能特性支持，一瞬间需要接受非常多的知识，因此会产生无从下手的感觉，进而得出一种上手难度高，框架很“重”的结论。&lt;/p&gt;&lt;p&gt;如果从另外一种角度来学习Abp的话，也许情况会有所不同。在本文之初，我便提出了Abp的核心是&lt;strong&gt;模块化&lt;/strong&gt;及&lt;strong&gt;依赖注入&lt;/strong&gt;的观点，当我们将入门的重点放在&lt;strong&gt;模块化&lt;/strong&gt;和&lt;strong&gt;依赖注入&lt;/strong&gt;上，那么会发现Abp是一个极易上手并且学习曲线很平缓的框架。正如上文我所进行的代码演示，如果感觉这个演示项目简单易学，那么就证明了我这一观点。&lt;/p&gt;&lt;p&gt;至于易用性，首先Abp实现的功能很全面，我们可以按需使用；其次，随着对Abp框架的逐步深入，会发现&lt;strong&gt;模块化&lt;/strong&gt;的设计让我们的项目集成多种功能变得简单，并且随着项目的演进，Abp的&lt;strong&gt;模块化&lt;/strong&gt;给我们提供了轻易切换到微服务方案的能力；&lt;strong&gt;依赖注入&lt;/strong&gt;系统让我们能够轻易的定制并替换Abp默认实现的功能。因此，我认为Abp是一个易于使用的框架。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;在这里我们从一个不同的角度来认识了Abp框架，显而易见，对于Abp来讲，是否太“重”，和我们对他的认知及使用方式有很大的关联。&lt;/p&gt;&lt;p&gt;项目示例代码将托管在Github中。&lt;/p&gt;&lt;h2&gt;致谢&lt;/h2&gt;&lt;p&gt;感谢Abp群（QQ群：48039003）的群友们提供的热心帮助。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>feaf847ba77fe99478968dc0dc9d6f8b</guid>
<title>[推荐] Spring Boot 如何统一后端返回格式？老鸟们都是这样玩的</title>
<link>https://toutiao.io/k/290ect3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gOa4vJmA3Iz2aqv8C4e699G3oBEfic7adODd5HlOzXVxLgDu1sgreZv5vrd1SaRITNCaT17SVcT1w/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900.0000000000001&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;469.0140845070423&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5211111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4gOa4vJmA3Iz2aqv8C4e699qibG4OFemkoiaP7pAkgs87ibAeWW4KIwXA5Acia5xbOicQbkyHV38n5yicvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是飘渺。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来聊一聊在基于SpringBoot前后端分离开发模式下，如何&lt;span&gt;友好的&lt;/span&gt;返回统一的标准格式以及如何优雅的处理全局异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看看为什么要返回统一的标准格式？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要对SpringBoot返回统一的标准格式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，SpringBoot的返回格式常见的有三种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一种：返回 String&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getStr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello,javadaily&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时调用接口获取到的返回值是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hello,javadaily&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二种：返回自定义对象&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/aniaml&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Aniaml &lt;span&gt;getAniaml&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  Aniaml aniaml = &lt;span&gt;new&lt;/span&gt; Aniaml(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;pig&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; aniaml;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时调用接口获取到的返回值是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;pig&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三种：接口异常&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@GetMapping(&lt;span&gt;&quot;/error&quot;&lt;/span&gt;)&lt;br/&gt;public int &lt;span&gt;&lt;span&gt;error&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;    int i = 9/0;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时调用接口获取到的返回值是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span&gt;&quot;2021-07-08T08:05:15.423+00:00&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;500&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;error&quot;&lt;/span&gt;: &lt;span&gt;&quot;Internal Server Error&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;/wrong&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上种种情况，如果你和前端开发人员联调接口她们就会很懵逼，由于我们没有给他一个统一的格式，前端人员不知道如何处理返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有甚者，有的同学比如小张喜欢对结果进行封装，他使用了Result对象，小王也喜欢对结果进行包装，但是他却使用的是Response对象，当出现这种情况时我相信前端人员一定会抓狂的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们项目中是需要定义一个统一的标准返回格式的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定义返回标准格式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个标准的返回格式至少包含3部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;status 状态值：由后端统一定义各种返回结果的状态码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message 描述：本次接口调用的结果描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;data 数据：本次返回的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;:&lt;span&gt;&quot;100&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;操作成功&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;:&lt;span&gt;&quot;hello,javadaily&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也可以按需加入其他扩展值，比如我们就在返回对象中添加了接口调用时间&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;timestamp: 接口调用时间&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定义返回对象&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResultData&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;/** 结果状态 ,具体状态码参见ResultData.java*/&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; status;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; T data;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; timestamp ;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ResultData&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.timestamp = System.currentTimeMillis();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;ResultData&amp;lt;T&amp;gt; &lt;span&gt;success&lt;/span&gt;&lt;span&gt;(T data)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ResultData&amp;lt;T&amp;gt; resultData = &lt;span&gt;new&lt;/span&gt; ResultData&amp;lt;&amp;gt;();&lt;br/&gt;    resultData.setStatus(ReturnCode.RC100.getCode());&lt;br/&gt;    resultData.setMessage(ReturnCode.RC100.getMessage());&lt;br/&gt;    resultData.setData(data);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultData;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;ResultData&amp;lt;T&amp;gt; &lt;span&gt;fail&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code, String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ResultData&amp;lt;T&amp;gt; resultData = &lt;span&gt;new&lt;/span&gt; ResultData&amp;lt;&amp;gt;();&lt;br/&gt;    resultData.setStatus(code);&lt;br/&gt;    resultData.setMessage(message);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultData;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定义状态码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public enum ReturnCode {&lt;br/&gt;    /**操作成功**/&lt;br/&gt;    RC100(100,&lt;span&gt;&quot;操作成功&quot;&lt;/span&gt;),&lt;br/&gt;    /**操作失败**/&lt;br/&gt;    RC999(999,&lt;span&gt;&quot;操作失败&quot;&lt;/span&gt;),&lt;br/&gt;    /**服务限流**/&lt;br/&gt;    RC200(200,&lt;span&gt;&quot;服务开启限流保护,请稍后再试!&quot;&lt;/span&gt;),&lt;br/&gt;    /**服务降级**/&lt;br/&gt;    RC201(201,&lt;span&gt;&quot;服务开启降级保护,请稍后再试!&quot;&lt;/span&gt;),&lt;br/&gt;    /**热点参数限流**/&lt;br/&gt;    RC202(202,&lt;span&gt;&quot;热点参数限流,请稍后再试!&quot;&lt;/span&gt;),&lt;br/&gt;    /**系统规则不满足**/&lt;br/&gt;    RC203(203,&lt;span&gt;&quot;系统规则不满足要求,请稍后再试!&quot;&lt;/span&gt;),&lt;br/&gt;    /**授权规则不通过**/&lt;br/&gt;    RC204(204,&lt;span&gt;&quot;授权规则不通过,请稍后再试!&quot;&lt;/span&gt;),&lt;br/&gt;    /**access_denied**/&lt;br/&gt;    RC403(403,&lt;span&gt;&quot;无访问权限,请联系管理员授予权限&quot;&lt;/span&gt;),&lt;br/&gt;    /**access_denied**/&lt;br/&gt;    RC401(401,&lt;span&gt;&quot;匿名用户访问无权限资源时的异常&quot;&lt;/span&gt;),&lt;br/&gt;    /**服务异常**/&lt;br/&gt;    RC500(500,&lt;span&gt;&quot;系统异常，请稍后重试&quot;&lt;/span&gt;),&lt;br/&gt;&lt;br/&gt;    INVALID_TOKEN(2001,&lt;span&gt;&quot;访问令牌不合法&quot;&lt;/span&gt;),&lt;br/&gt;    ACCESS_DENIED(2003,&lt;span&gt;&quot;没有权限访问该资源&quot;&lt;/span&gt;),&lt;br/&gt;    CLIENT_AUTHENTICATION_FAILED(1001,&lt;span&gt;&quot;客户端认证失败&quot;&lt;/span&gt;),&lt;br/&gt;    USERNAME_OR_PASSWORD_ERROR(1002,&lt;span&gt;&quot;用户名或密码错误&quot;&lt;/span&gt;),&lt;br/&gt;    UNSUPPORTED_GRANT_TYPE(1003, &lt;span&gt;&quot;不支持的认证模式&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    /**自定义状态码**/&lt;br/&gt;    private final int code;&lt;br/&gt;    /**自定义描述**/&lt;br/&gt;    private final String message;&lt;br/&gt;&lt;br/&gt;    ReturnCode(int code, String message){&lt;br/&gt;        this.code = code;&lt;br/&gt;        this.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getCode&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; code;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getMessage&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;统一返回格式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ResultData&amp;lt;String&amp;gt; &lt;span&gt;getStr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ResultData.success(&lt;span&gt;&quot;hello,javadaily&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时调用接口获取到的返回值是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;hello,javadaily&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span&gt;1625736481648&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;httpStatus&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样确实已经实现了我们想要的结果，我在很多项目中看到的都是这种写法，在Controller层通过&lt;code&gt;ResultData.success()&lt;/code&gt;对返回结果进行包装后返回给前端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里我们不妨停下来想想，这样做有什么弊端呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最大的弊端就是我们后面每写一个接口都需要调用&lt;code&gt;ResultData.success()&lt;/code&gt;这行代码对结果进行包装，重复劳动，浪费体力；&lt;br/&gt;&lt;br/&gt;而且还很容易被其他老鸟给嘲笑。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gOa4vJmA3Iz2aqv8C4e699DGNhndOUYozjUs4rrYMKxpOEEkTiaW15gk9lPPwNPQo3hibG4fElxHPw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以呢我们需要对代码进行优化，目标就是不要每个接口都手工制定&lt;code&gt;ResultData&lt;/code&gt;返回值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高级实现方式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要优化这段代码很简单，我们只需要借助SpringBoot提供的&lt;code&gt;ResponseBodyAdvice&lt;/code&gt;即可。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;ResponseBodyAdvice的作用：拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等等。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看下&lt;code&gt;ResponseBodyAdvice&lt;/code&gt;的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ResponseBodyAdvice&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;/**&lt;br/&gt;  * 是否支持advice功能&lt;br/&gt;  * true 支持，false 不支持&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;supports&lt;/span&gt;&lt;span&gt;(MethodParameter var1, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; var2)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;/**&lt;br/&gt;  * 对返回的数据进行处理&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Nullable&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;T &lt;span&gt;beforeBodyWrite&lt;/span&gt;&lt;span&gt;(@Nullable T var1, MethodParameter var2, MediaType var3, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; var4, ServerHttpRequest var5, ServerHttpResponse var6)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只需要编写一个具体实现类即可&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; jam&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2021/7/8 10:10 上午&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResponseAdvice&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ResponseBodyAdvice&lt;/span&gt;&amp;lt;&lt;span&gt;Object&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ObjectMapper objectMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;supports&lt;/span&gt;&lt;span&gt;(MethodParameter methodParameter, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; aClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;beforeBodyWrite&lt;/span&gt;&lt;span&gt;(Object o, MethodParameter methodParameter, MediaType mediaType, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt; String){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; objectMapper.writeValueAsString(ResultData.success(o));&lt;br/&gt;        }        &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ResultData.success(o);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意两个地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@RestControllerAdvice&lt;/code&gt;注解&lt;/p&gt;&lt;p&gt;&lt;code&gt;@RestControllerAdvice&lt;/code&gt;是&lt;code&gt;@RestController&lt;/code&gt;注解的增强，可以实现三个方面的功能：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;全局异常处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全局数据绑定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全局数据预处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;String类型判断&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt; String){&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; objectMapper.writeValueAsString(ResultData.success(o));&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码一定要加，如果Controller直接返回String的话，SpringBoot是直接返回，故我们需要手动转换成json。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的处理我们就再也不需要通过&lt;code&gt;ResultData.success()&lt;/code&gt;来进行转换了，直接返回原始数据格式，SpringBoot自动帮我们实现包装类的封装。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getStr&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello,javadaily&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们调用接口返回的数据结果为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@GetMapping(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;public String getStr(){&lt;br/&gt;  return &lt;span&gt;&quot;hello,javadaily&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是感觉很完美，别急，还有个问题在等着你呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gOa4vJmA3Iz2aqv8C4e699kLQhjyGc5xic06EVg7GH1ibETk09icl6qvkqDUObSz9U2Fpqnn5dBXz0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;br/&gt;接口异常问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时有个问题，由于我们没对Controller的异常进行处理，当我们调用的方法一旦出现异常，就会出现问题，比如下面这个接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/wrong&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;9&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回的结果为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gOa4vJmA3Iz2aqv8C4e699F4vXppP4LAnKTsuvSGEfsU3NulReBHdmsX4Vic8n1EeopTPL8OLwwJw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;这显然不是我们想要的结果，接口都报错了还返回操作成功的响应码，前端看了会打人的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别急，接下来我们进入第二个议题，如何优雅的处理全局异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SpringBoot为什么需要全局异常处理器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不用手写try...catch，由全局异常处理器统一捕获&lt;/p&gt;&lt;p&gt;使用全局异常处理器最大的便利就是程序员在写代码时不再需要手写&lt;code&gt;try...catch&lt;/code&gt;了，前面我们讲过，默认情况下SpringBoot出现异常时返回的结果是这样：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span&gt;&quot;2021-07-08T08:05:15.423+00:00&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;500&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;error&quot;&lt;/span&gt;: &lt;span&gt;&quot;Internal Server Error&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;path&quot;&lt;/span&gt;: &lt;span&gt;&quot;/wrong&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种数据格式返回给前端，前端是看不懂的，所以这时候我们一般通过&lt;code&gt;try...catch&lt;/code&gt;来处理异常&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/wrong&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;        i = &lt;span&gt;9&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;        log.error(&lt;span&gt;&quot;error:{}&quot;&lt;/span&gt;,e);&lt;br/&gt;        i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们追求的目标肯定是不需要再手动写&lt;code&gt;try...catch&lt;/code&gt;了，而是希望由全局异常处理器处理。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于自定义异常，只能通过全局异常处理器来处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;error1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;empty&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;自定义异常&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们引入Validator参数校验器的时候，参数校验不通过会抛出异常，此时是无法用&lt;code&gt;try...catch&lt;/code&gt;捕获的，只能使用全局异常处理器。&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;SpringBoot集成参数校验请参考这篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMTk4NjM1MA==&amp;amp;mid=2247490888&amp;amp;idx=1&amp;amp;sn=dd7c3a4feb185abdca42362000b336d3&amp;amp;chksm=9ad00709ada78e1f04f0d878e03625083abccb5f72b6ae473c6816e2039edf245fe4ac6f50a6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot开发秘籍 - 集成参数校验及高阶技巧&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;SpringBoot开发秘籍 - 集成参数校验及高阶技巧&lt;/a&gt;&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何实现全局异常处理器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RestExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 默认全局异常处理。&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; e the e&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; ResultData&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    @&lt;span&gt;ResponseStatus&lt;/span&gt;(&lt;span&gt;HttpStatus&lt;/span&gt;.&lt;span&gt;INTERNAL_SERVER_ERROR&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ResultData&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;span&gt;exception&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;全局异常信息 ex={}&quot;&lt;/span&gt;, e.getMessage(), e);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ResultData.fail(ReturnCode.RC500.getCode(),e.getMessage());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有三个细节需要说明一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@RestControllerAdvice&lt;/code&gt;，RestController的增强类，可用于实现全局异常处理器&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@ExceptionHandler&lt;/code&gt;,统一处理某一类异常，从而减少代码重复率和复杂度，比如要获取自定义异常可以&lt;code&gt;@ExceptionHandler(BusinessException.class)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@ResponseStatus&lt;/code&gt;指定客户端收到的http状态码&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;体验效果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们调用如下接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;error1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;empty&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;自定义异常&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回的结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;500&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;自定义异常&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span&gt;1625795902556&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本满足我们的需求了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当我们同时启用统一标准格式封装功能&lt;code&gt;ResponseAdvice&lt;/code&gt;和&lt;code&gt;RestExceptionHandler&lt;/code&gt;全局异常处理器时又出现了新的问题：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;100&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;操作成功&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;500&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;自定义异常&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;data&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span&gt;1625796167986&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span&gt;1625796168008&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时返回的结果是这样，统一格式增强功能会给返回的异常结果再次封装，所以接下来我们需要解决这个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;全局异常接入返回的标准格式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要让全局异常接入标准格式很简单，因为全局异常处理器已经帮我们封装好了标准格式，我们只需要直接返回给客户端即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;beforeBodyWrite&lt;/span&gt;&lt;span&gt;(Object o, MethodParameter methodParameter, MediaType mediaType, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt; String){&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; objectMapper.writeValueAsString(ResultData.success(o));&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt; ResultData){&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; o;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ResultData.success(o);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt; ResultData){&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; o;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果返回的结果是ResultData对象，直接返回即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们再调用上面的错误方法，返回的结果就符合我们的要求了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;status&quot;&lt;/span&gt;: &lt;span&gt;500&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;自定义异常&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span&gt;1625796580778&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的文章就到这里了，希望通过这篇文章你能掌握如何在你项目中友好实现统一标准格式到返回并且可以优雅的处理全局异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;github地址：https://github.com/jianzh5/cloud-blog/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我是飘渺Jam，一名写代码的架构师，做架构的程序员，期待你的关注。咱们下期见！&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5581a99aea7d4b298afda3a191ff077</guid>
<title>[推荐] 如何写好一份 30K Offer 的简历？</title>
<link>https://toutiao.io/k/jghtnwm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;279&quot; data-ratio=&quot;0.5953846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mALMxRtWV1fIXmVo5kqFkByTF5M1QqzQefhS9EYKY6BzY1Dmib2jiabopE4CdId9eYgX7TEHHeVt9lsFDn0RS7Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈喽，大家好，我是瓜哥，致力于分享互联网各领域干货。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近很多大学生都在进行期末考试，马上就放假了，是时候轻松一下了，但是作为即将进入大四的童鞋们，面临的就是&lt;code&gt;秋季招聘&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为过来人，给大家的建议就是利用好 &lt;code&gt;7、8&lt;/code&gt; 月的黄金时间，准备好一份简历，并针对性进行巩固技术知识，在秋招中斩获 &lt;code&gt;N&lt;/code&gt; 个 &lt;code&gt;Offer&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这篇文章就和大家简单聊聊，如何写好一份简历？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俗话说的好，&lt;code&gt;学历是块敲门砖，正所谓师傅领进门，修行靠个人&lt;/code&gt;。简历也一样是找工作的敲门砖，简历不是简单的记一份流水账，而是让面试官了解你的重要途径。校招更是如此，因为初出茅庐的应届毕业生并没有实际的工作经验，所以简历的第一印象很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写好一份技术简历，首先需要知道简历中一般包括什么内容。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简历基本要素&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基本信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;求职意向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;专业技能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工作经历、项目经验（重点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;教育及培训背景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自我评价&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基本信息又包含哪些内容呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;姓名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;年龄/出生年月&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;民族&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;政治面貌&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;学历&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;专业（考虑是否对应聘职位有帮助）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工作年限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;联系方式（手机、电子邮箱）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;婚否&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于基本信息这里面需要注意的地方是，如果是中专毕业，建议别写，如果是大专，建议写本科，最好自己提前完成自考成人本科。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工作经验方面，如果是应届生，建议写半年实习，一般情况下，学校也会安排实习，如果已经有相关编程经验，按照实际写即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于联系方式，建议留当地的号码，邮箱建议注册姓名拼音的邮箱。案例如下：zhangsan@163.com/zs@163.com）&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;求职意向&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多应届生，反馈求职意向和招聘不符，这块需要注意的地方是建议上面的求职意向需要根据招聘情况，及时调整，&lt;code&gt;招聘需求中都会有写&lt;/code&gt;。比如，Web 前端工程师、小程序工程师、C++ 开发工程师、嵌入式软件工程师等等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简历书写建议&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不要将自己的爱好兴趣写进去；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;简历页数不超过 2 页；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不写与招聘要求无关的技术；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不给自己挖坑，斟酌了解、熟悉、精通用词；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;简历中不要出现错误的单词拼写，注意技术名词的大小写；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;作为理工科的程序员，也要将简历中的语言表达通顺；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;切记不要写与招聘岗位无关的工作经验；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;简历不要造假，随时可能被 Pass；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;项目经历中是否担任过一些重要的职位，如小组长、负责人；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;突出个人亮点、做过什么大型项目、修改过公司什么难度的 Bug 、给公司带来多大的效益；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;英语四六级、软件工程师的证书写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在校连续几年拿过国家奖学金或国家励志奖学金写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实习经历或导师带领做过的技术项目写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重点院校毕业要放在简历耀眼的位置；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如 GitHub 2k Star 或博客内容丰富写进简历；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;建议使用 PDF 版简历，偏于携带和传播；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;确保简历中的技术内容都能说出什么，证书与项目经历要真实。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;专业技能如何写？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于专业技能方向，这里提供一个通用的模板写法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;综合自己掌握的知识点与大量企业的网络招聘需求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解、掌握、精通根据自身能力来写&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要全写精通，你不是神&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;专业名词大小写不要写错、不懂的提前网上查询&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对不同企业对技术的要求进行简历微调&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;自我评价&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后聊聊自我评价，看到很多应届生的简历，自我评价过多且过分夸张，十分不建议，自我评价需要做到的是前后一致，个人特长需要与工作岗位相关的内容，并不是打篮球、画画之类的，很多应届生都这么干过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;瓜哥给大家一个示例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;具有良好的编码风格 工作细致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具有较强的抗压和适应能力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;喜欢参加公司 OR 线下技术交流会&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，瓜哥最近也在整理，前端、后端的相关简历模板，需要&lt;code&gt;简历模板&lt;/code&gt;或者&lt;code&gt;简历指导&lt;/code&gt;的小伙伴们记得&lt;code&gt;一键三连&lt;/code&gt;支持瓜哥，&lt;code&gt;在看&lt;/code&gt;越多，瓜哥整理的进度也会越快。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;码字不易，在线求个三连支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，关注瓜哥不迷路，带你编程上高速，下一个技术大佬就是你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击下方卡片，回复 &lt;code&gt;书籍&lt;/code&gt; 免费获取 2 本保姆级电子书&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNDM2ODIxOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mALMxRtWV1fxCl58rlJ2wanda3pGIZZ5ZZsaDDicsfibicL5Kzj1rBcTFibGta06QdFbzUh4JyAfd2RDa8QEV6Iamw/0?wx_fmt=png&quot; data-nickname=&quot;代码情缘&quot; data-alias=&quot;&quot; data-signature=&quot;林中有两条路，我选择了人迹更少的那条，一切来自于此。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c79eb16f0fb3dfe99024d2f1e72b103d</guid>
<title>[推荐] 慢 SQL 排查思路？就这</title>
<link>https://toutiao.io/k/xitokgg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天和大家聊一个常见的问题：慢SQL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过本文你将了解到以下内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;慢SQL的危害&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SQL语句的执行过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储引擎和索引的那些事儿&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;慢SQL解决之道&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续均以MySQL默认存储引擎InnoDB为例进行展开，话不多说，开搞！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.慢SQL的危害&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢SQL，就是跑得很慢的SQL语句，你可能会问慢SQL会有啥问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一个场景：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大白和小黑端午出去玩，机票太贵于是买了高铁，火车站的人真是乌央乌央的。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;马上检票了，大白和小黑准备去厕所清理下库存，坑位不多，排队的人还真不少。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;小黑发现其中有3个坑的乘客贼慢，其他2个坑位换了好几波人，这3位坑主就是不出来。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;等在外面的大伙，心里很是不爽，长期占用公共资源，后面的人没法用。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;小黑苦笑道：这不就是厕所版的慢SQL嘛！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是实际生活中的例子，换到MySQL服务器也是一样的，毕竟科技源自生活嘛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL服务器的资源(CPU、IO、内存等)是有限的，尤其在高并发场景下需要快速处理掉请求，否则一旦出现慢SQL就会阻塞掉很多正常的请求，造成大面积的失败/超时等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7542262678803641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawKIx7Ap2Bfx9G5kxrH9wMxUOAGoJEthtictIjPvwyAUmk9vCQEJVicyxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.SQL语句执行过程&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3701188455008489&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawvAsmfEicYvbEJicic3Zw3Ud8icpIqm5e8xVH5vAEkPUkzEkUbeQ0CUEpZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端和MySQL服务端的交互过程简介：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端发送一条SQL语句给服务端，服务端的连接器先进行账号/密码、权限等环节验证，有异常直接拒绝请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端查询缓存，如果SQL语句命中了缓存，则返回缓存中的结果，否则继续处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端对SQL语句进行词法解析、语法解析、预处理来检查SQL语句的合法性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端通过优化器对之前生成的解析树进行优化处理，生成最优的物理执行计划。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将生成的物理执行计划调用存储引擎的相关接口，进行数据查询和处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理完成后将结果返回客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端和MySQL服务端的交互过程简图：&lt;img data-ratio=&quot;1.138095238095238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawCB9kKgFQd2GrOsuGfXszyoH4VZBEzSEOODJcyc0WUQ6a2kgR7k3Jkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俗话说&quot;条条大路通罗马&quot;，优化器的作用就是找到这么多路中最优的那一条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储引擎更是决定SQL执行的核心组件，适当了解其中原理十分有益。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 存储引擎和索引的那些事儿&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 存储引擎&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB存储引擎(Storage Engine)是MySQL默认之选，所以非常典型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储引擎的主要作用是进行数据的存取和检索，也是真正执行SQL语句的组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB的整体架构分为两个部分：内存架构和磁盘架构，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.76875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawfb1drqp3TbIRyP2cCf6mGMDkVq98oaVOXibG7mtT1u02K0NJrupBQAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;存储引擎的内容非常多，并不是一篇文章能说清楚的，本文不过多展开，我们在此只需要了解内存架构和磁盘架构的大致组成即可。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB 引擎是面向行存储的，数据都是存储在磁盘的数据页中，数据页里面按照固定的行格式存储着每一行数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;行格式主要分为四种类型Compact、Redundant、Dynamic和Compressed，默认为Compact格式。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3352941176470588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawHM0bYBZibKpjUnIBh96avgob6ImMts8IUrUp4meU3kSvZgvQXKIS18A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;磁盘预读机制和局部性原理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当计算机访问一个数据时，不仅会加载当前数据所在的数据页，还会将当前数据页相邻的数据页一同加载到内存，磁盘预读的长度一般为页的整倍数，&lt;span&gt;从而有效降低磁盘IO的次数。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5628834355828221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawzADXHbHgXLrRvzTo6riacibYCuc6j9iaJVD8UAanYz8SzqUcqD0IS93cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;磁盘和内存的交互&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL中磁盘的数据需要被交换到内存，才能完成一次SQL交互，大致如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5955414012738853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawuuDwcNhjLLYYNrica4icc1Hs92j2gLSUsdVFIn4Pia6XkGq2lPop6wHmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;扇区是硬盘的读写的基本单位，通常情况下每个扇区的大小是 512B&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;磁盘块文件系统读写数据的最小单位，相邻的扇区组合在一起形成一个块，一般是4KB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页是内存的最小存储单位，页的大小通常为磁盘块大小的 2^n 倍&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB页面的默认大小是16KB，是数倍个操作系统的页&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5098039215686274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawQcR5UBxgWJluY8rDsG1UbnabFia04265Pns6AicQticic2WIXJahNE0t0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;随机磁盘IO&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL的数据是一行行存储在磁盘上的，并且这些数据并非物理连续地存储，这样的话要查找数据就无法避免随机在磁盘上读取和写入数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于MySQL来说，当出现大量磁盘随机IO时，大部分时间都被浪费到寻道上，磁盘呼噜呼噜转，就是传输不了多少数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一次磁盘访问由三个动作组成：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;寻道：磁头移动定位到指定磁道&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;旋转：等待指定扇区从磁头下旋转经过&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据传输：数据在磁盘与内存之间的实际传输&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于存储引擎来说，如何有效降低随机IO是个非常重要的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 索引&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以实现增删改查的数据结构非常多，包括：哈希表、二叉搜索树、AVL、红黑树、B树、B+树等，这些都是可以作为索引的候选数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合MySQL的实际情况：磁盘和内存交互、随机磁盘IO、排序和范围查找、增删改的复杂度等等，综合考量之下B+树脱颖而出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B+树作为多叉平衡树，对于范围查找和排序都可以很好地支持，并且更加矮胖，访问数据时的平均磁盘IO次数取决于树的高度，因此B+树可以让磁盘的查找次数更少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在InnoDB中B+树的高度一般都在2~4层，并且根节点常驻内存中，也就是说查找某值的行记录时最多只需要1~3次磁盘I/O操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyISAM是将数据和索引分开存储的，InnoDB存储引擎的数据和索引没有分开存储，这也就是为什么有人说Innodb索引即数据，数据即索引，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4496951219512195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawXEfGDDbZyicTohgDN9B9QEOOW2VcHRltqJyshFNkPFxgC1via6ksic6JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1312&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到InnoDB的数据和索引的存储，就提到一个名词：&lt;strong&gt;聚集索引&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;聚集索引&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚集索引将索引和数据完美地融合在一起，是每个Innodb表都会有的一个特殊索引，一般来说是借助于表的主键来构建的B+树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有student表，将id作为主键索引，那么聚集索引的B+树结构，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5038051750380518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawTxntAYMkhaT4mp2Xb7oPJXxMC9lUd7qfqbBcX3PqXiaz2NbsngubJJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;非叶子节点不存数据，只有主键和相关指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;叶子节点包含主键、行数据、指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;叶子节点之间由双向指针串联形成有序双向链表，叶子节点内部也是有序的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聚集索引按照如下规则创建：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有主键时InnoDB利用主键来生成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有主键，InnoDB会选择一个非空的唯一索引来创建&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无主键且非NULL唯一索引时，InnoDB会隐式创建一个自增的列来创建&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们要查找id=10的数据，大致过程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;索引的根结点在内存中，10&amp;gt;9 因此找到P3指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;P3指向的数据并没有在内存中，因此产生1次磁盘IO读取磁盘块3到内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内存中对磁盘块3进行二分查找，找到ID=9的全部值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非聚集索引&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非聚集索引的叶子节点中存放的是二级索引值和主键键值，非叶子节点和叶子节点都没有存储整行数据值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有student表，将name作为二级索引，那么非聚集索引的B+树结构，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4888558692421991&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawcfyMslw9iayvVYUmA00ia3xQgP1NRefw2oIWBRhSbqomtK8icuibOC7eiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于非聚集索引的叶子节点没有存储行数据，如果通过非聚集索引来查找非二级索引值，需要分为两步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一：通过非聚集索引的叶子节点来确定数据行对应的主键&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二：通过相应的主键值在聚集索引中查询到对应的行记录&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把通过非聚集索引找到主键值，再根据主键值从聚集索引找对于行数据的过程称为：&lt;strong&gt;回表查询&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说：select * from student where name = &#x27;Bob&#x27; 将产生回表查询，因为在name索引的叶子节点没有其他值，只能从聚集索引获得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果查找的字段在非聚集索引就可以完成，就可以避免一次回表过程，这种称为：覆盖索引，所以select * 并不是好习惯，需要什么拿什么就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们要查找name=Tom的记录的所有值，大致过程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从非聚集索引开始，根节点在内存中，按照name的字典序找到P3指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;P3指针所指向的磁盘块不在内存中，产生1次磁盘IO加载到内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内存中对磁盘块3的数据进行搜索，获得name=tom的记录的主键值为4&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据主键值4从聚集索引的根节点中获得P2指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;P2指针所指向的磁盘块不在内存中，产生第2次磁盘IO加载到内存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将上一步获得的数据，在内存中进行二分查找获得全部行数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述查询就包含了一次回表过程，因此性能比主键查询慢了一倍，因此尽量使用主键查询，一次完事。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 慢SQL解决思路&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现慢SQL的原因很多，我们抛开单表数亿记录和无索引的特殊情况，来讨论一些更有普遍意义的慢SQL原因和解决之道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从两个方面来进行阐述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33779761904761907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaMZss2ia9Bx0yJNIfuKRhiawibEssFkqTicicyicMbibAPy4NoZk2dKJvHUZLSnVldt6PtQzkAo4c5cd6VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1344&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 索引设置原则&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序员的角度和存储引擎的角度是不一样的，索引写的好，SQL跑得快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如表中有1000w记录，其中有status字段表示状态，可能90%的数据status=1，可以不将status作为索引，因为其对数据记录区分度很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个索引都需要占用磁盘空间，修改表数据时会对索引进行更新，索引越多，更新越复杂。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为每添加一个索引，.ibd文件中就需要多维护一个B+Tree索引树，如果某一个table中存在10个索引，那么就需要维护10棵B+Tree，写入效率会降低，并且会浪费磁盘空间。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度，属于热门字段，为其建立索引非常必要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于需要经常使用ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段建立索引，可以有效借助B+树的特性来加速执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主键可以用来创建聚集索引，外键也是唯一的且常用于表关联的字段，也需要建索引来提高性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 SQL的优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果数据库表的索引设置比较合理，SQL语句书写不当会造成索引失效，甚至造成全表扫描，迅速拉低性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;索引失效&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写SQL的时候在某些情况下会出现索引失效的情况：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;select id from std upper(name) = &#x27;JIM&#x27;;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;select id from std where id+1=10;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;对索引使用&amp;lt;&amp;gt; 、not in 、not exist、!=&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;select id from std where name != &#x27;jim&#x27;;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;select id from std name like &#x27;%jim&#x27;;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如：字符串类型索引字段不加引号，select id from std name = 100;保持变量类型与字段类型一致&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;并不是所有的or都会使索引失效，如果or连接的所有字段都设置了索引，是会走索引的，一旦有一个字段没有索引，就会走全表扫描。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;联合索引包含key1，key2，key3三列，但SQL语句没有key1，根据联合索引的最左匹配原则，不会走联合索引。&lt;br/&gt;select name from table where key2=1 and key3=2;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;好的建议&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于数据库来说，在绝大部分情况下，连接会比子查询更快，使用连接的方式，MySQL优化器一般可以生成更佳的执行计划，更高效地处理查询&lt;br/&gt;而子查询往往需要运行重复的查询，子查询生成的临时表上也没有索引， 因此效率会更低。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;禁止分页查询偏移量过大，如limit 100000,10&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;使用覆盖索引&lt;/strong&gt;&lt;br/&gt;减少select * 借助覆盖索引，减少回表查询次数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多表关联查询时，小表在前，大表在后&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在MySQL中，执行from后的表关联查询是从左往右执行的，第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MySQL采用从左往右的顺序解析where子句，可以将过滤数据多的条件放在前面，最快速度缩小结果集。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;使用小范围事务，而非大范围事务&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;遵循最左匹配原则&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;使用联合索引，而非建立多个单独索引&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 慢SQL的分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分析慢SQL之前需要通过MySQL进行相关设置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;开启：SET GLOBAL slow_query_log = 1;&lt;br/&gt;开启状态：SHOW VARIABLES LIKE &lt;span&gt;&#x27;%slow_query_log%&#x27;&lt;/span&gt;;&lt;br/&gt;设置阈值：SET GLOBAL long_query_time=3;&lt;br/&gt;查看阈值：SHOW GLOBAL VARIABLES LIKE &lt;span&gt;&#x27;long_query_time%&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;explain分析SQL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;explain命令只需要加在select之前即可，例如:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;explain select * from std where id &amp;lt; 100;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该命令会展示sql语句的详细执行过程，帮助我们定位问题，网上关于explain的用法和讲解很多，本文不再展开。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从慢SQL的危害、Innodb存储引擎、聚集索引、非聚集索引、索引失效、SQL优化、慢SQL分析等角度进行了阐述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL的很多知识点都非常复杂，并非一两篇文章能讲清楚的，因此本文在很多地方显得很单薄，好在网上资料非常多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果本文能在某些方面对读者有所启发，足矣。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;已经在写 MySQL 锁的文章了，关注我追更哟~&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3NjQ3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEf5LN3Y4UErfNUkiaMseJPkdXA4xPD6Uicl8EqAJAEKVIKalU19xS41TO3aPmHK5bqbzGTwu3z92Kg/0?wx_fmt=png&quot; data-nickname=&quot;yes的练级攻略&quot; data-alias=&quot;yes_java&quot; data-signature=&quot;用接地气的话来分享一些后端技术或写一些想写的。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>