<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0299745d12d7fed8f5f3ad9c48692bdc</guid>
<title>面试官问：如何保证 MQ 消息是有序的？</title>
<link>https://toutiao.io/k/cemwgzn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是Tom哥~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了系统间解耦，我们通常会引入&lt;/span&gt;&lt;code&gt;&lt;span&gt;MQ&lt;/span&gt;&lt;/code&gt;&lt;span&gt;框架，大家各司其职共同完成上下游的业务流程。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYwSdHxu9LiadrVdUVT3Lic3HVToiavEGbdEr0qEZfwfiab1qmFiaGd4xR8tA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;大致过程：&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生产端，创建一条消息，通过网络发送到MQ Server&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MQ将 消息存储在topic 的&lt;strong&gt;一个分区&lt;/strong&gt;里&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消费端，从分区中拉取消息，消费处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;但现实往往不一样！MQ 架构设计要满足高并发、高性能、高可用等指标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYMBwt2sBKy4a5aoXvHAJ5B0ZiaiaGOtxZIkhAib7WB8NoNclGjX56eic9fg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单分区，达不到我们的吞吐量要求，我们考虑采用&lt;/span&gt;&lt;code&gt;&lt;span&gt;多分区&lt;/span&gt;&lt;/code&gt;&lt;span&gt;架构设计，正所谓 ”三个臭皮匠赛过一个诸葛亮“，多分区可以有效分摊全局压力，提升整体系统性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYOBHyObVr0FZ3zcZqZVbusiblH1azsU0SIt5IIkep8nHq4CVkaicaSFCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两台 MQ机器，组成一个集群，原先一个分区存储&lt;/span&gt;&lt;code&gt;&lt;span&gt;6条消息&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，现在分摊到两个分区，每个分区各存储&lt;/span&gt;&lt;code&gt;&lt;span&gt;3条消息&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，性能比上面那个提升一倍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;貌似可以满足我们的需求，但任何事情都有两面性！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;我们看看下面业务场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个用户在电商网站上下订单到交易完成，中间会经历一系列动作，订单的状态也会随之变化，一个订单会产生多条MQ消息，&lt;/span&gt;&lt;code&gt;&lt;span&gt;下单&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;付款&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;发货&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;买家确认收货&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，消费端需要严格按照业务状态机的顺序处理，否则，就会出现业务问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们发现，消息带上了状态，不再是一个个独立的个体，有了上下文依赖关系！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于这个问题，突然想到&lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP协议&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其本身也是无状态的，也就是说前后两次请求没有关联，但有些业务功能有登录要求，那怎么解决？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;引入Cookie机制，每次请求客户端额外传输一些数据，来达到上下文关联。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;回到MQ的消息顺序问题，我们要如何解决？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYQZ2OGJWDBPX9OOictn1wveZv7d9vxGK4dKMFc1DKQ60ePhS3q8buyWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：各退一步，保证局部有序。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如上面的电商例子，只要保证一个订单的多条状态消息在同一个分区，便可以满足业务需求，这个方案可以覆盖大部分的业务场景。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里面只需要有一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;路由策略&lt;/span&gt;&lt;/code&gt;&lt;span&gt;组件，由它决定消息该放到哪个分区中！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到市面MQ开源框架很多，常见的如：Kafka、Pulsar、RabbitMQ、RocketMQ 等，API方法略有区别，但设计思路是相通的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为例：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;生产端提供了一个接口 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;MessageQueueSelector&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public interface MessageQueueSelector {&lt;br/&gt;   MessageQueue select(final List&amp;lt;MessageQueue&amp;gt; mqs, final Message msg, final Object arg);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口内定义一个select方法，具体参数含义：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;mqs：该Topic下所有的队列分片&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;msg：待发送的消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;arg：发送消息时传递的参数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueueSelector&lt;/span&gt;&lt;/code&gt;&lt;span&gt;接口，RocketMQ 框架提供了三个默认实现类：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1、SelectMessageQueueByHash：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;arg参数的hashcode的绝对值，然后对mqs.size()取余，得到目标队列在mqs的下标&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2、SelectMessageQueueByRandom：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对mqs.size()值取随机数作为目标队列在mqs的下标&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;3、SelectMessageQueueByMachineRoom&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;返回null&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;特别注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然保证了单个分片的消息有序，但每个分片的消费者只能是单线程处理，因为多线程无法控制消费顺序。这个可能会损失一些性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;这里又引出另一个问题，如何保证一个队列只能有一个消费端呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.72578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYl2pt0ywfYicNtMhvibW69wZttFKtGPWr8WwIKRMU34sefEibh2iapxlLCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;遍历一个topic下所有的&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isOrder &amp;amp;&amp;amp; !this.lock(mq)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 尝试对它加锁，确保一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;只能被一个消费者处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、将&lt;/span&gt;&lt;code&gt;&lt;span&gt;PullRequest&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对象放入&lt;/span&gt;&lt;code&gt;&lt;span&gt;PullMessageService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的&lt;/span&gt;&lt;code&gt;&lt;span&gt;pullRequestQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;队列中&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public void dispatchPullRequest(List&amp;lt;PullRequest&amp;gt; pullRequestList) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (PullRequest pullRequest : pullRequestList) {&lt;br/&gt;        this.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);&lt;br/&gt;        log.info(&lt;span&gt;&quot;doRebalance, {}, add a new pull request {}&quot;&lt;/span&gt;, consumerGroup, pullRequest);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、org.apache.rocketmq.client.impl.consumer.PullMessageService#run&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5194585448392555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYNtXfYvjXiaA3pklFgicmE4opBJLcHpXFX2icosQRmaJaibIUZCJXX54OMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1182&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;PullMessageService&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/code&gt;&lt;span&gt;线程任务&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无限循环，从队列中拉取、处理消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;另一个问题，如何保证一个队列，只有一个线程在处理消息呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、&lt;span&gt; DefaultMQPushConsumerImpl#pullMessage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYU9ZoJd7icmutNLRvKn4hpjrmQappjyVuJw6Wp7uuME61Ex5RkdQvCXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;ConsumeMessageService&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中有两个实现类，因为我们有消费顺序要求，会选择&lt;/span&gt;&lt;code&gt;&lt;span&gt;ConsumeMessageOrderlyService&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来处理业务&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、 ConsumeMessageOrderlyService.ConsumeRequest&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshweLJVZ3yKhblYxiaXUBL3CMYibywA90B6mrYy7tQMhou6Pz1ZUiaQOyzf2PerklFzU8oyxy09HYvRX1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从&lt;/span&gt;&lt;code&gt;&lt;span&gt;ConcurrentMap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;中获取&lt;/span&gt;&lt;code&gt;&lt;span&gt;messageQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对应的锁对象&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 关键字，线程来抢占锁，互斥关系，从而保证了一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;只能有一个线程并发处理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;继续往下看，如果扩容了怎么办？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原来有6个分区，&lt;/span&gt;&lt;code&gt;&lt;span&gt;order_id_1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的消息在&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue6&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，此时扩容一倍，现在12个分区，&lt;/span&gt;&lt;code&gt;&lt;span&gt;order_id_1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;订单后面产生的消息可能路由到了&lt;/span&gt;&lt;code&gt;&lt;span&gt;MessageQueue8&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，同一个订单的消息分布在两个分区中，无法保证顺序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们能做的是，先将存量消息处理完，再扩容。如果是在线业务，可以搞个临时topic，先将消息暂时堆积，待扩容后，按新的路由规则重新发送。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;顺序消息，如果某条失败了怎么办？会不会一直阻塞？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、如果失败，不会提交消费位移，系统会自动重试（有重试上限），此时会阻塞后面的消息消费，直到这条消息处理完&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、如果这个消息达到重试上限，依然失败，会进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;死信队列&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，可以继续处理后面的消息&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于我：前阿里P7技术专家，出过专利，竞赛拿过奖，CSDN博客专家，负责过电商交易、社区生鲜、互联网金融等业务，多年团队管理经验。&lt;/span&gt;&lt;/section&gt;&lt;h1 accuse=&quot;qTitle&quot;&gt;&lt;span&gt;&lt;span&gt;关注「微观技术」，后台回复 “算法”、“书单” 关键字，免费领取资料&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.069090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwcdJhGaQRdAk0VWLIAIU548z3Izf6mwqwwUX9X86hvNHZq158VYMEaxegjfRg8ic02O0HeWD4xIsiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485551&amp;amp;idx=1&amp;amp;sn=533259fc15567b9f44e169943be4a305&amp;amp;chksm=ceb9f4c4f9ce7dd2debac27430c17c39fdb6ffadbd35c5494c68d39615a513336b7432b2ec1a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊 Kafka 那点破事！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247485467&amp;amp;idx=1&amp;amp;sn=de5105db459f8ffd60f34850784c8e48&amp;amp;chksm=ceb9f4b0f9ce7da6f3c25b039148d2193e3623a8fc7290debbf908e050613eb402c7fe80567c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;什么是布隆过滤器？如何解决高并发缓存穿透问题？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484980&amp;amp;idx=1&amp;amp;sn=25a530689f0657750d579263800369a6&amp;amp;chksm=ceb9fa9ff9ce7389974d2f33bea9d861920cb75cca559f1f2810c89f729011bb3c2839ac46da&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;学会这10个设计原则，离架构师又进了一步！！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484929&amp;amp;idx=1&amp;amp;sn=d8cb3306dea9f1b92fd30d59da3f536a&amp;amp;chksm=ceb9faaaf9ce73bca59b46021a450fdc84aa0f85d6b49ff0e5578cc3abaa1433447f7dffc5e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;人人都是架构师？？？谈何容易！！&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1127a48939f9a0152cc9708575c65b6d</guid>
<title>初探自动化部署 Jenkins 安装及配置</title>
<link>https://toutiao.io/k/7n84pl9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;感谢赞赏，一起进步&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>02f2fadc5890e82662bfccba854a85f5</guid>
<title>开发 App 新选择：使用 Vue Native 构建移动应用</title>
<link>https://toutiao.io/k/v90tm3b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6671232876712329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APibmqndDJ2QhiavH71OHtVU28npvku6usdacJjT8vic24qOR9KQtFYibU2EwnSKjzUQ5v1mXqnVatBsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Native 是一个 JavaScript 框架，旨在使用 JavaScript 构建可以在 Android 和 iOS 上运行的跨平台移动应用程序。通过封装 React Native，开发人员可以使用 Vue Native 使用 Vue.js 构建移动应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正因为如此，所有可以在 React Native 中完成的事情都可以在 Vue Native 中完成，并且代码被编译为 React Native。通过这种方式，开发人员可以从 Vue 和 React Native 生态系统提供的内容中受益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这篇文章中，我们将讨论 Vue Native 的特性以及如何使用 Vue Native 创建移动应用程序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Vue Native 的特性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在决定使用 Vue.js 构建移动应用程序时，Vue Native 有许多有用的特性需要考虑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;声明式渲染&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Native使用声明式编程范式。这意味着我们只需声明我们希望我们的组件和状态如何渲染以获得我们想要的结果。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;双向绑定&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的Vue Native应用中，我们可以在我们的组件类和其模板之间共享数据。如果我们改变了状态中的数据，它就会自动反映在用户界面中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们仍然必须访问 &lt;code&gt;v-model&lt;/code&gt; 进行双向数据绑定。这意味着我们可以使用 &lt;code&gt;v-model&lt;/code&gt; 将一个 &lt;code&gt;input&lt;/code&gt; 元素的值绑定到我们组件的数据属性中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Vue.js 生态系统的丰富性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 生态系统是 JavaScript 领域最大、发展最快的生态系统之一。使用 Vue Native 构建应用程序提供了更大的 Vue 生态系统的好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着我们可以使用诸如 &lt;code&gt;v-if&lt;/code&gt; 用于条件渲染，&lt;code&gt;v-model&lt;/code&gt; 用于双向数据绑定，&lt;code&gt;v-for&lt;/code&gt; 用于列表渲染，以及Vuex用于状态管理等功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;编译为 React Native&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Vue Native 依赖于 React Native，所以熟悉 React Native 生态系统的开发者更容易上手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以在 Vue Native 中渲染 React Native 组件，而无需编写一行额外的配置，以便轻松集成并提高生产力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1628781762362&quot; data-category_id_list=&quot;48|26|1|55|5|37|54|53|42|43|36&quot; data-id=&quot;1628781762362&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置开发环境&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始使用 Vue Native 的最快和最简单的方法是使用 &lt;span&gt;Vue Native CLI&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 引导移动应用程序。此 CLI 使用 &lt;span&gt;Expo CLI&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 或 &lt;span&gt;React Native CLI&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 生成一个简单的单页应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着我们必须安装任一CLI，根据我们应用程序的需要，来使用Vue Native CLI。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要开始，我们必须安装一些依赖项。首先，运行下面的命令来全局安装Vue Native CLI。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; npm install --g vue-native-cli&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，全局安装 Expo CLI，尽管这可以与 React Native CLI 互换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;  npm install --g expo-cli&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建一个Vue Native项目&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在 Vue Native 和 Expo CLI 都已全局安装，让我们使用以下命令创建一个 Vue Native 项目：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vue-native init &amp;lt;yourProjectName&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过在项目的根目录下导航并运行这个命令，启动一个开发服务器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; &lt;span&gt;cd&lt;/span&gt; &amp;lt;yourProjectName&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; npm start&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Metro Bundler 在 React Native 中编译 JavaScript 代码，从 http://localhost:19002/ 运行。通过在 Web 浏览器中访问 http://localhost:8080/，将出现以下页面：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5207517619420516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APibmqndDJ2QhiavH71OHtVU2uQXrSqWOeeVs9NJOW3TibsLqyBRwMoptSHtQZZNZWC2iaLPTRic53TicAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若要在物理设备上查看Vue Native应用，请扫描浏览器中的二维码，并在Android或iOS的Expo Go中打开链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过点击浏览器中显示的链接，在安卓模拟器或iOS模拟器上打开应用程序，但并不是所有在Expo Go中可用的API都可以在模拟器上使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为选择，我们可以克隆Vue Native核心团队准备的Kitchen Sink演示应用程序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Vue Native UI组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Native提供了一些开箱即用的UI组件来构建应用界面，让我们来看看其中最重要的一些组件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;视图组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;view&lt;/code&gt; 组件就像我们普通HTML中的 &lt;code&gt;div&lt;/code&gt; 标签一样工作。这个组件是在Vue Native中创建用户界面的基本构建模块，就像在React Native中一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在一个 &lt;code&gt;view&lt;/code&gt; 组件中拥有多个子组件，比如下面的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;My Awesome Vue Native App&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Text组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要在我们的移动应用程序中输出文本，我们不能使用常规的HTML标签，如 &lt;code&gt;h1&lt;/code&gt; 或 &lt;code&gt;p&lt;/code&gt;。相反，我们必须使用 &lt;code&gt;&amp;lt;text&amp;gt;...&amp;lt;text&amp;gt;&lt;/code&gt; 组件。使用这个组件是非常直接的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;Hello World&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Image组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Image&lt;/code&gt; 组件渲染静态图像、网络图像和来自用户设备的图像。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与普通的 &lt;code&gt;img&lt;/code&gt; 标签中使用 &lt;code&gt;src&lt;/code&gt; 属性不同，这里我们在 &lt;code&gt;image&lt;/code&gt; 组件中绑定了 &lt;code&gt;source&lt;/code&gt; 属性来动态加载我们的图片。这使得webpack在构建过程中可以捆绑我们的图片资产。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过添加以下内容，我们可以将图像加载到Vue Native应用中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;!-- Network image --&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;image&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;{ width: 300, height: 150 }&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;:source&lt;/span&gt;=&lt;span&gt;&quot;{&lt;br/&gt;         uri:&#x27;https://images.unsplash.com/photo-1621570074981-ee6a0145c8b5?ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;amp;ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=750&amp;amp;q=80&#x27;,&lt;br/&gt;      }&quot;&lt;/span&gt;&lt;br/&gt;   /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!-- Static image --&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;image&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;{ width: 300, height: 150 }&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;:source&lt;/span&gt;=&lt;span&gt;&quot;require(&#x27;./assets/photo.jpg&#x27;)&quot;&lt;/span&gt;&lt;br/&gt;  /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;!-- Local disk image --&amp;gt;&lt;/span&gt; &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;image&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;{width: 66, height: 58}&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;:source&lt;/span&gt;=&lt;span&gt;&quot;{uri: &#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==&#x27;}&quot;&lt;/span&gt;&lt;br/&gt;   /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;TextInput组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TextInput&lt;/code&gt; 组件通过用户的键盘将文本输入到应用程序中。我们可以使用 &lt;code&gt;v-model&lt;/code&gt; 将我们状态中的数据绑定到 &lt;code&gt;TextInput&lt;/code&gt; 组件。这允许我们无缝获取和设置 &lt;code&gt;TextInput&lt;/code&gt; 的值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text-input&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;{&lt;br/&gt;        height: 30,&lt;br/&gt;        width: 250,&lt;br/&gt;        borderColor: &#x27;#511281&#x27;,&lt;br/&gt;        borderWidth: 1,&lt;br/&gt;      }&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;v-model&lt;/span&gt;=&lt;span&gt;&quot;text&quot;&lt;/span&gt;&lt;br/&gt;    /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  data() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;text&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;    };&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，上面的代码在Vue Native应用中输出如下屏幕：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.073015873015873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0APibmqndDJ2QhiavH71OHtVU2v02wfoEqx5QBRa0EdwkVl5WbPn6mKzfncfBDJNardWqspwNj2vt9Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;NativeBase UI 组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要建立一个可以投入生产的移动应用，仅仅使用内置的Vue Native组件可能是不够的。幸运的是，Vue Native带来了React Native和Vue.js两个生态系统的优点，所以我们可以使用NativeBase UI组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NativeBase是由GeekyAnts创建的，他们是Vue Native背后的同一个团队。这个UI组件给了我们一个真正原生的外观和感觉，在我们的移动应用中，通过相同的JavaScript代码库，为Android和iOS提供了特定平台的设计。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;双向数据绑定&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;v-model&lt;/code&gt; 在我们的 Vue 组件模板和 Vue Native 中的 Vue 状态之间共享数据是轻而易举的。我们可以使用 &lt;code&gt;v-model&lt;/code&gt; 指令探索双向数据绑定，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text-input&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;{&lt;br/&gt;        height: 30,&lt;br/&gt;        width: 250,&lt;br/&gt;        borderColor: &#x27;#511281&#x27;,&lt;br/&gt;        borderWidth: 1,&lt;br/&gt;      }&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;v-model&lt;/span&gt;=&lt;span&gt;&quot;text&quot;&lt;/span&gt;&lt;br/&gt;    /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  data() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;text&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;    };&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过将一个带有数据绑定的输入字段从我们的状态输出到输入字段和一个文本组件，我们可以看到以下内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.9281609195402298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0APibmqndDJ2QhiavH71OHtVU2U0FmbSTd2o0PVz4GpNiaOVUHr27cswicJAceH7uwb4zXIbiauX9LXiasYg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;导航和路由&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Native应用中的导航和路由是通过&lt;span&gt;Vue Native Router&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;库来处理的。在底层，这个库使用了流行的&lt;span&gt;React Navigation&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;包。Vue Native Router和React Navigation都有类似的api，因此安装也类似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该库没有预装，所以为了在我们的应用程序中开始使用导航，我们必须用以下方式安装它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm i vue-native-router&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，我们需要安装以下软件包才能使 Vue Native Router 正常工作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;react-native-reanimated&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;react-native-gesture-handler&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;react-native-paper&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目根目录下运行以下命令来安装这些包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm i react-native-reanimated react-native-gesture-handler react-native-paper&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue Native Router 提供了 &lt;code&gt;StackNavigator&lt;/code&gt; 和 &lt;code&gt;DrawerNavigator&lt;/code&gt; 来注册用于导航的屏幕：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {&lt;br/&gt;  createAppContainer,&lt;br/&gt;  createStackNavigator,&lt;br/&gt;} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vue-native-router&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; SettingsScreen &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./screens/SettingsScreen.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; HomeScreen &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./screens/HomeScreen.vue&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; StackNavigator = createStackNavigator(&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;Settings&lt;/span&gt;: SettingsScreen,&lt;br/&gt;    &lt;span&gt;Home&lt;/span&gt;: HomeScreen,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;initialRouteName&lt;/span&gt;: &lt;span&gt;&#x27;Home&#x27;&lt;/span&gt;,&lt;br/&gt;  }&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; AppNavigator = createAppContainer(StackNavigator);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;components&lt;/span&gt;: { AppNavigator },&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要在屏幕之间导航，请调用 &lt;code&gt;navigation&lt;/code&gt; 对象上的 &lt;code&gt;navigate&lt;/code&gt; 方法，该方法作为props传递如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// navigation is declared as a prop&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;props&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;navigation&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;Object&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;methods&lt;/span&gt;: {&lt;br/&gt;    navigateToScreen() {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.navigation.navigate(&lt;span&gt;&quot;Profile&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;状态管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于Vue Native应用程序中的集中状态管理模式，我们可以使用Vue的官方状态管理库Vuex。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集成Vuex非常简单。首先，使用以下命令之一安装Vuex：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm i vuex&lt;br/&gt;//or&lt;br/&gt;yarn add vuex&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个中央存储文件，并根据应用程序的需要添加 &lt;code&gt;state&lt;/code&gt;、&lt;code&gt;getter&lt;/code&gt;、&lt;code&gt;mutations&lt;/code&gt; 或 &lt;code&gt;actions&lt;/code&gt;。为了简单起见，在这里使用 &lt;code&gt;state&lt;/code&gt; 对象:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// store/index.js&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vue-native-core&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Vuex &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;vuex&#x27;&lt;/span&gt;;&lt;br/&gt;Vue.use(Vuex);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; store = &lt;span&gt;new&lt;/span&gt; Vuex.Store({&lt;br/&gt;  &lt;span&gt;state&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;Ejiro Asiuwhu&#x27;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; store;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的store中使用数据和方法与传统的Vue应用程序有很大不同，这里是如何导入和使用我们store中的数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; store &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./store&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;computed&lt;/span&gt;: {&lt;br/&gt;    name() {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; store.state.name;&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，我们没有像通常在 Vue 和 Vuex 应用程序设置中那样使用 &lt;code&gt;this.$store&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;访问设备 API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于React Native丰富的生态系统，在我们的Vue Native应用中访问本地设备的API是可能的。例如，要在我们的应用程序中访问用户的设备地理定位API，我们可以像这样使用&lt;span&gt;expo-location&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;view&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;:on-press&lt;/span&gt;=&lt;span&gt;&quot;getLocation&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;title&lt;/span&gt;=&lt;span&gt;&quot;Get Location&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;color&lt;/span&gt;=&lt;span&gt;&quot;#184d47&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;accessibility-label&lt;/span&gt;=&lt;span&gt;&quot;Get access to users&#x27; location&quot;&lt;/span&gt;&lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;Location Details:&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;{{ location }}&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;Latitude: {{ latitude }}&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;Longitude: {{ longitude }}&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;text&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;text-error&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;{{ errorMessage }}&lt;span&gt;&amp;lt;/&lt;span&gt;text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; * &lt;span&gt;as&lt;/span&gt; Location &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;expo-location&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt;  data() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;location&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;latitude&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;longitude&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;errorMessage&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;text&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;user&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;country&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;      },&lt;br/&gt;    };&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;methods&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;async&lt;/span&gt; getLocation() {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; { status } = &lt;span&gt;await&lt;/span&gt; Location.requestForegroundPermissionsAsync();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (status !== &lt;span&gt;&quot;granted&quot;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.errorMessage = &lt;span&gt;&quot;Permission to access location was denied&quot;&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; location = &lt;span&gt;await&lt;/span&gt; Location.getCurrentPositionAsync({});&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.location = location;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.latitude = location.coords.latitude;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.longitude = location.coords.longitude;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.errorMessage = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (error) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.errorMessage = error;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用 Expo 包，不需要额外的配置或设置，这使得使用 Vue Native 构建移动应用程序变得轻而易举。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Vue Native 构建移动应用程序为使用 JavaScript 构建跨平台移动应用程序开辟了许多可能性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过访问 Vue 和 React Native 生态系统的丰富性和优势，开发人员可以编写 &lt;code&gt;.vue&lt;/code&gt; 组件并将 Expo 和 React Native 包集成到应用程序中，几乎不需要额外的配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本教程中使用的完整代码可在GitHub上找到。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本教程源码：https://github.com/ejirocodes/Vue-Native-Demo&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;&lt;span&gt;原文：https://blog.logrocket.com/building-mobile-apps-with-vue-native/&lt;br/&gt;&lt;span&gt;作者：Ejiro Asiuwhu&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近文章&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Vue Native CLI: &lt;em&gt;https://github.com/GeekyAnts/vue-native-cli&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Expo CLI: &lt;em&gt;https://docs.expo.io/workflow/expo-cli/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;React Native CLI: &lt;em&gt;https://github.com/react-native-community/cli&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Vue Native Router: &lt;em&gt;https://github.com/GeekyAnts/vue-native-router&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;React Navigation: &lt;em&gt;https://reactnavigation.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;react-native-reanimated: &lt;em&gt;https://github.com/kmagiera/react-native-reanimated&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;react-native-gesture-handler: &lt;em&gt;https://github.com/kmagiera/react-native-gesture-handler&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;react-native-paper: &lt;em&gt;https://github.com/callstack/react-native-paper&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;expo-location: &lt;em&gt;https://docs.expo.io/versions/latest/sdk/location/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a3b521edd93674fcdcf84f322b51b56</guid>
<title>Android 端权限隐私的合规化处理实践</title>
<link>https://toutiao.io/k/7eoe7fm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;是什么&lt;/span&gt;&lt;/section&gt;&lt;section&gt;对客户端而言，权限隐私可分为权限和隐私两个大的方面。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;权限为用户通过app内弹窗设置或者手机设置内对应app的权限设置方式给予对应app相应的权限，如电话权限，定位权限，相机权限等，本文主要集中介绍隐私相关的权限部分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐私为app使用过程中与用户个人相关的个人信息，如所在位置，Mac地址，设备id等。就Android端而言，多数隐私信息需要对应授权后才能获取，但目前仍存在部分隐私信息无需授权就可以拿到的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;为什么&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;大众隐私意识觉醒，权限隐私安全性差会直接导致用户不愿使用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日趋严格的权限治理和隐私安全治理，工信部和市场的严格管控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端作为与用户最直接的交互信息收集入口，有义务合规化的收集和使用用户信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;具体实践&lt;/h3&gt;&lt;h4&gt;一.Android各版本对权限的适配处理&lt;/h4&gt;&lt;h5&gt;1.1 早期的注册权限&lt;/h5&gt;&lt;section&gt;Android6.0(SDK版本为23)之前的版本，安装App页面会列出当前app所注册的所有权限，无同意与否按钮，只有安装和取消，开发App时只需要在清单文件中注册所需的对应权限即可：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&amp;gt;&lt;br/&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt;&lt;br/&gt;&amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&amp;gt;&lt;br/&gt;&amp;lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;1.2 动态权限授予&lt;/h5&gt;&lt;section&gt;Android自6.0(SDK版本为23)开始，将权限分为普通权限，危险权限，特殊权限。而其中的&lt;strong&gt;危险权限&lt;/strong&gt;需要在调用某些系统方法之前需要用户手动授予对应权限，包括PHONE,LOCATION,STORAGE等多个权限组。如果在没授权的情况下直接调用相关方法，就会抛出，应用也随之崩溃。报错信息类似下方这种：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;java.lang.SecurityException: getDeviceId: has android.permission.READ_PHONE_STATE.&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;而要解决以上的报错问题，可以自行封装权限处理类工具，也可使用一些开源的权限工具进行处理。核心代码都逃不过：&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;code&gt;//判断某个权限是否已经被同意&lt;br/&gt;ContextCompat.checkSelfPermission(context, perm) ==  PackageManager.PERMISSION_GRANTED)&lt;br/&gt;//请求某个权限，调用后会弹出权限系统弹窗&lt;br/&gt;ActivityCompat.requestPermissions((Activity) object, perms, requestCode);&lt;br/&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;注：如果用户拒绝权限且不让再次显示系统权限授权弹窗的话，最好是提供端内可点击进入手机系统的权限设置页面以让用户可以选择开启对应权限。&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;1.3 READ_PHONE_STATE权限的变化&lt;/h5&gt;&lt;h6&gt;1.3.1 演变&lt;/h6&gt;&lt;h6&gt;&lt;br/&gt;&lt;/h6&gt;&lt;h6&gt;1.3.2 适配处理&lt;/h6&gt;&lt;h5&gt;1.4 存储分区的处理&lt;/h5&gt;&lt;section&gt;自Android10.0之后，Google开始采用存储分区，主要目的是改变现有App胡乱使用手机存储导致垃圾和其他安全问题。适配 Android11 后强制使用存储分区。具体分区如下，扩展的外部存储是无权限进行读取的。而其他私有存储会在App卸载后清理掉：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49663526244952894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtk1iadicGZOnHmjo6G9u1LBe6ysr1HanurCZRafmCC7dG7mH8W0PatfTyQkq39AMB6eNyO5iceNx3RAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;743&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体部分代码改动如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;1.拍照存储路径：&lt;br/&gt;&lt;code&gt;Environment.getExternalStorageDirectory().getAbsolutePath()&lt;/code&gt;修改为&lt;code&gt;getExternalFilesDir(Environment.DIRECTORY_DCIM)&lt;/code&gt;；&lt;/section&gt;&lt;section&gt;2.原本的存储路径 /storage/emulated/0 改为 /storage/emulated/0/Android/data&lt;br/&gt;具体调用的修改为:&lt;br/&gt;&lt;code&gt;Environment.getExternalStorageDirectory()&lt;/code&gt;改为&lt;code&gt;context.getExternalFilesDir()&lt;/code&gt;;&lt;/section&gt;&lt;section&gt;3.如果App在sdcard中有重要存储，可以在适配android10.0的过渡阶段将之前的数据复制出来到新的存储分区中。&lt;/section&gt;&lt;h4&gt;二.隐私信息合规化处理&lt;/h4&gt;&lt;section&gt;上半部分较为粗略的过了一下权限相关的部分改动和对应修改，接下来说一说隐私信息的合规化处理。当然，权限作为隐私处理的前提，如果权限都没有合理的修改完毕，那隐私处理合规化更谈不上了，毕竟很多隐私是依赖于权限的。&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;2.1 隐私信息获取告知的直接化和透明化&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在首次打开App时，需要在进行初始化之前就向用户展示用户协议与隐私保护弹窗或页面，只有用户在同意之后才能进入App进行使用。而对于&lt;strong&gt;手机号、MAC地址、IMEI、所在位置信息、手机存储权限、相册访问权限&lt;/strong&gt;，&lt;strong&gt;手机流量使用&lt;/strong&gt;等敏感信息需要让用户在第一屏就能够看到。并且提供用户协议和隐私政策链接，能让用户点击后查看具体详细的条款。设计完成后要让法务进行确认，是否符合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在处理1.2中的动态权限时，需要在系统弹窗中或者之前说明需要用户授予该权限的原因。如：获取定位权限之前需要告知用户该权限是为了获取定位信息，然后精准推送相关内容。获取相机权限是为了要使用摄像头进行拍照。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在进入App操作三步以内能看到法律条款和隐私政策入口，正常处理方式会在App的&lt;strong&gt;设置页&lt;/strong&gt;内加上对应入口。同时在注册登录页面，需要明显展示出法律条款和隐私条款入口，且需要默认不勾选，需要用户主动同意后才能进行账号注册和登录。如下图：&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15965583173996176&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtk1iadicGZOnHmjo6G9u1LBe6OfrL54NNPjtwA7WvSzbKFqPkYHibib7YZtIhpYL9s5SS4icviaV7hnNBmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分发广告的App需要注意处理广告下载逻辑，在用户点击后需要展示所下载App的信息，所需的权限和隐私条款，让用户清楚的知道下载的App是否是自己想要的，且不允许自动下载。这样能很好的解决用户无意识的在手机上下载了很多无用App，这对很多老年人使用手机很有帮助。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;2.2 隐私信息获取和传输的安全化&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免频繁的调用系统方法获取隐私信息，可以在单次启动App调用该获取数据后使用全局变量进行缓存，之后每次使用时直接调用全局变量使用就行，不必每次都调用系统方法。包括&lt;code&gt;getDeviceId&lt;/code&gt;,&lt;code&gt;getMacAddress&lt;/code&gt;等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;诸如imei，mac，定位的经纬度等敏感信息，需要避免多次在网络中传输，可以处理为单独接口收集相关信息一次后保存在服务端即可，无需每次传输；另外需要避免以明文的方式在数据接口中传输。像imei可以通过MD5加密算法进行加密处理，并不会影响用户的区分；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于READ_PHONE_STATE权限升级为了系统权限&lt;strong&gt;READ_PRIVILEGED_PHONE_STATE&lt;/strong&gt;，部分通过native方式(C代码)直接调用imei等信息时也会报错或者为空。建议这部分尽量使用java方式调用，如果有变动可以明显的感知到错误并修改，不至于需要重新修改C代码，然后又进行jni编译。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;2.3 部分隐私Api调用的严格化&lt;/h5&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在未授权的情况下，需要保证App中与该权限无关联的功能可以正常使用。所以就不能简单的处理为1.3.1中提到的不给权限就不让使用App的方案了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Android端目前尚存在部分无需动态授权就可以获取的隐私，如用户手机上的应用安装列表。此信息可用于分析用户喜好，如小说类产品还是视频类产品；也可以用于分析用户某些App还未安装，便于推送广告的拉新。但目前国内市场已经开始治理，如果存在获取手机内应用列表的情况，会进行下架处理或者不予上架。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目前工信部和各应用市场对App上架要求严格，使用第三方检测工具可以很细致的检测出App中存在哪些不合理的系统方法调用，比如：在未同意协议与隐私之前就进行了网络请求；在未同意协议与隐私之前获取了Mac地址；在未获取定位权限的情况下就获取了手机的基站信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;三.遇到的一些问题和坑&lt;/h4&gt;&lt;section&gt;这里总结部分在开发过程中遇到的一些隐蔽小点，希望能帮助到大家。&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;早期的腾讯X5内核会在隐私协议展示时就会获取mac地址，如下图。可尝试更新到新的版本继续查看。由于我方对X5内核需求不高，所以直接进行了删除清理。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtk1iadicGZOnHmjo6G9u1LBe65qTsZDeghEqRIDbNnXwQ4XtibSibf3nicDHG2cgfQbUTDBebLgzy748aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集成开源库或者第三方sdk的初始化均需要处理为同意隐私之后再进行，大多数sdk在初始化时都会调用相关无需授权的api方法。如语音相关的讯飞sdk会在初始化的时候调用MAC地址信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分统计库如umeng，talkingdata sdk需要升级到新版本的接入方式。老版本的talkingdata sdk在尚未授定位权限时进行初始化仍会调用手机基站信息api(属于定位)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自有代码逻辑中相关隐私信息的获取和赋值，也都要放到隐私同意之后去进行，故在用户协议和隐私同意之前尽量少的进行代码逻辑处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;总结&lt;/h3&gt;&lt;p&gt;&lt;span&gt;权限隐私的发展趋势只会越来越严格和规范。在日常的客户端开发当中，我们就需要时刻持有隐私安全的意识，让自己站在用户的角度上合理的保证隐私安全。并紧跟隐私安全的发展，提前布局。这样才能不至于临时出问题后手忙脚乱的去处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本文仅粗略的记录了一些权限隐私相关的一些情况和做法，如有不当，欢迎指正&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>15a29d3a5bd730b6d1e09794be791cc7</guid>
<title>Kubernetes 多集群架构探索</title>
<link>https://toutiao.io/k/6xcvtu3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;7月17日，在Cloud Native Days China云原生多云多集群专场，有赞技术专家王兵发表了《Kubernetes多集群架构探索》主题演讲，介绍了有赞多集群的落地实践，以及如何使用Karmada进行多集群管理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6755162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPiafQRcswXUC4dmtMibwr03tnKVQcXBXKiawSNk0yC78lR2uVvAcciaxncQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;演讲主要包含三部分的内容：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为什么要使用多集群&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有赞多集群使用情况及存在的问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多集群方案探索与选择&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;为什么要使用多集群？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;关于多集群的使用我们主要有三方面的考虑：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1、单集群限制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;现在K8s是开发到1.22版本了，但是单集群限制目前来看还是没有改变。比如单个node还是110，一个集群也就是5000个节点左右。根据我们的使用经验，在单集群时，1个集群内部有2000个service时，其实我们的集群已经出现了一些瓶颈。我们都知道 Service会自己产生一些service的环境变量，当我们去创建对应的 development，然后去创建对应的service时，发现每个pod会产生大量的service，当然这里边有个前提，我们的service都在同一个namespace下面，比如在生产环境，一个namespace下的service可能有几千个，当我们去执行某些命令时会非常卡，另外环境变量比较多的话，会影响应用的启动。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、多云架构：&lt;/strong&gt;有赞最开始是一个多云多机房架构，就是说我们天然最少在一个云上应该有一个机器人。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、容灾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在我们最开始容器化的时候一朵云上只有一个集群 , 流量是两边都存在的。在17年~18年时出现了一个故障：我们内部有一个自研的ingress controller出现bug之后，入口的一个核心应用发布的时候 endpoint更新了，结果我们自研的ingress controller并没有把endpoint更新到它的off stream里面，因为所有的流量基本都会经过核心应用，导致机房无法使用。因此我们就开始拆集群，最起码要保证一朵云上有两个集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;有赞多集群使用情况及存在的问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们现在使用 K8s多级群主要分为4个部分：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;整体的部署架构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6943649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPz5D2vdLFTUkrYoGGJPvoQyicrckrLNn12a4pGnLjVpNkOVNy3mvrGVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1047&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图我们内部目前是这样使用的：在不同云上的不同的机房，最上面的组件yz7是统一接入层，上文提到的提到的ingress controller就是和它交互的。在每一朵云上有的云我们可能直接用它的公有云，有的云可能是有托管的机房，也可能会用它的公有云。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每朵云最少有两个K8s集群，这里不一样的地方是因为有托管还有云上的，下面是一个VK的节点，我们最开始这个地方的云是自建的，会有伸缩性受限的问题存在，在使用了开源社区的某个组件后，增加了一个虚拟节点，这个虚拟的节点其实往上套了一下，对应的它机房里边的一个公有云的一个k8s的集群。因此从整体来说，在集群的层面都是可以任意扩展的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;应用部署&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;有了集群之后，如何将应用和程序部署到k8s？有赞内部最开始有4个环境：daily、 QA、预发和生产4个环境，最开始的daily是给研发提供环境去验证代码；QA用于测试，其环境相对是比较稳定的，但是它连的数据库与线上环境基本是一致的，所以可以在最终发到真正的线上时，还能在预发环境进行验证。后面我们把 daily环境去掉了，做了一个持续交付的环境来替代 Daily的需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;应用部署方面，还有其他相关联的一些系统，比如我们内部的ingress controller这样的系统，其实它也是需要和K8s交互的，目前来说我们内部90%以上的无状态的业务应用都已全部容器化，都是通过我们的发布系统发布到对应的K8s集群。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5014451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPoRFZBXVw4PHTRlf9bQ7NT0j8lR00ojV9lgY6aCHwF9ianicpCKjGye3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;服务发现和暴露&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;服务发现和暴露，主要分两块，最外面接入层的流量HTTP和内部的RPC流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5515289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaP4qTX8xsm2GCerYdO7E9Z8KiaNIzlrjiaTicq7icykyEichrkiatYIfgzibxHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;883&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HTTP流程：我们内部有一个统一的接入软件yz7，yz7有个组件yz7-k8s-sync，这个组件和开源ingress controller做的工作类似，然后将对应的endpoint写到yz7的配置里，在内存里日更新。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;RPC&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6784141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaP7aic4icFkexYwROELxsibBnZmicb4GibChpEaib4ROVmvNGz9d5uwAVHjb2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;RPC服务发现最开始其实是一个大的单体应用，后面逐渐进行了拆分，微服务化，然后使用了国内用的比较多的Dubbo。我们最开始做容器化时，它的服务发现都还是依托Dubbo框架，因此刚提到的使用macvlan有一个优势，在切容器化时，虚机和容器其实是无所谓的，都注册到Dubbo里，它的注册中心都能注册到，它的调用方也都可以调到，因为网络是可达的，这是我们微服务化后使用Dubbo的第一步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二步是我们基于Istio 1.1版本拉出来的分支做的服务发现，相当于依托K8s的原数据做的服务发现，也是一个逐渐渐进的过程，所以中间也是会存在它的服务发现同时依托于K8s的原数据和Dubbo的etc原数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;下图其实是最终我们想要呈现的架构图：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6726519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaP0Ipu1Mrx7wDncQbppDcNKzWAEMz04T2MQFibyH6qHicdCHelS3tZLdow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这里边相当于所有的服务注册或服务发现的数据都依托于K8s里的原数据。里边的 Pilot组件就是我们基于Istio社区1.1拉出来一个分支进行迭代的。Tether组件时我们自研的，最终是要接管在容器里面进出的所有流量。它现在也提供了一些能力，比如能够通过它的接口去自己实现服务的注册。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;弹性伸缩&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;弹性伸缩我们现在主要分两块：一个是应用程序的弹性伸缩，还有一个是集群的弹性伸缩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;应用的弹性伸缩，首先有个前提集群的规模是可以弹性的，集群的弹性伸缩，我们现在主要做了两件事：第一个是在托管的或者叫自建的机房里，我们使用了Virtual Kubelet，让其作为一个虚拟节点存在于自建的机房里，和对应机房公有云上的k8s去联通；另外我们自研了一套集群节点伸缩系统，可以在上面配置节点相对应的弹性规则。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;使用多集群存在的问题&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;运维困难：我们是在多环境多云多机房，然后有N个开发者的集群，对于开发者的管理员来说是非常痛苦的。比如我们新建了一个集群，如果这份原数据需要在很多系统里都进行配置，对于运维同学来说是相当痛苦的，因为相关的系统跑不起来或者程序发不起来。第二个问题多集群在新建集群时，目前来说它这份配置需要一个check list，所有的系统都要去完成变更将这份配置给加上，这个周期是比较长的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;多集群间元数据的同步：主要是workload方面，目前我们的workload是通过发布系统，逐步的向每个集群发布，如此可能会导致如果一个集群挂了，就没有办法进行发布。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;多集群方案探索与选择&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们是在今年年初开始对业界的一些多集群管理系统进行调研：&lt;/p&gt;&lt;p&gt;1）kubefed v2：对于我们来说，API需要重新试配，其他的一些周边或配套系统也要跟着更改，改动成本比较大。&lt;/p&gt;&lt;p&gt;2）karmada：调研过程中Karmada正好开源，非常符合我们的需求。&lt;/p&gt;&lt;p&gt;3）OpenClusterManagement：组件比较多，后期运维起来会比较麻烦，而且感觉它是openshift里边一个组件，后期是否会和openshift耦合性太强，这也是我们担心的点。&lt;/p&gt;&lt;p&gt;4）kcp：项目比较早期&lt;/p&gt;&lt;p&gt;因此，&lt;strong&gt;最终我们选择了Karmada&lt;/strong&gt;。其主要的优势有以下几个方面：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;灵活的分发策略&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持多集群间的灵活调度&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可使用原生 Kubernetes API&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持自定义调度&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前来说Karmada已经满足我们的需求了，后期我们会选择Karmada作为多集群管理的方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图为我们期望的最终应用部署架构图：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9493464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPOWmib5V3jicsSJL8WuveKkS3d66vzI5rUd92CqP3nlhmV6zqq01D2r7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Control Plane为最上面的控制面，它是纯粹的控制面的集群，不会部署真正的workload，包含Karmada和Pandora，Pandora是放置我们内部写的operator；下面为Runtime集群，也就是我们现在的K8s架构，这里有个很大的变化：之前我们做发布或其他周边系统需要和K8s进行交互时，可能直接通到最下面，但改成这样的话，就不需要和下边的runtime集群去交互，如何需要交互，是和Control Plane里边的对象进行交互。这样的好处是下边的集群无论怎么变化，它在这里是可以感知和控制的，可以解决我们上文提到的一些问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;下图为我们做的pass平台，其主要解决应用交付的问题：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8882083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ia1Z7HH4plnBxmiaDGF9iaGE3QwjUH8ukaPSK8ATDRY41H0GBiafuyWN2dMxkxZcgUDBr0uKBBPwTpOo94LLiaficFOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们期望的效果是发布系统将程序或应用分发到集群里，和K8s 里的API Server直接交互。上面是面向用户也就是研发人员进行应用发布动作；中间层是我们pass平台对外暴露的APIServer，我们希望做的 pass平台能将无状态应用和有状态应用都能收拢到一起。整块的话，这里有Control Plane cluster的，Sync我们会同步一些原数据，主要是给UI这一层使用，然后会同步到RDS；控制面的Control Plane集群，它里边有很多operator，其中就包括了Karmada的countrol manager，去往下面分发，这里边workload是没有的，最下面是runtime的环境。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;总的来说，其优点主要有：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;统一控制面，所有元数据都在控制面系统中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;底层集群不可用无影响&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;控制系统无需感知底层集群变化&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.74&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ZPtdzESiawhdMHyNfDvj0a36SiaN499NjK0BKean9ibV1T8rYe2gLG8OTSjeCB1NesY09JLKujB7DqpO8DGu4HFxw/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493941&amp;amp;idx=1&amp;amp;sn=d6f22061d25c8f3917a39e3e92c4b934&amp;amp;chksm=e8c497b4dfb31ea297c290054ac9e2c723d03b778cd144e5be973a1e7cc6d479a66256694786&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;科普 | 除了容器的发家史，你还想了解啥？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493935&amp;amp;idx=1&amp;amp;sn=41bf964db631b998f63e612e837263bc&amp;amp;chksm=e8c497aedfb31eb830408d10b0699dd45c7fa98f23d20a1a44342ca78bb263c2a0a29d1e49db&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;云原生动态周报 | Istio 1.11正式发布&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247493814&amp;amp;idx=1&amp;amp;sn=45eb1d83218aa8ce41eb05920df4561e&amp;amp;chksm=e8c49637dfb31f2191289af1ccef43e375f0451c6529bf877fbd14a60afd15595b42e05c4c47&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;科普 | 从零开始入门容器，看这篇就够了！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;111&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;111&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ia1Z7HH4plnCqgkia6XMVK2WHqxZTTxdjOrOVKE3oBVsIRbB7hbhQTt3ll0pJo5icuicoKjAxAnoN07lu1ohK82w4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;扫描二维码 ｜ 加入Karmada技术交流群&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/6aVaON9Kibf5ibKRPQgZ9XgbVNsIeQUnfKSiaErmr8dtdicicS3A8m6TiavR6ZB0Eah3pD0kjQg8ACyNb1x5ibdqRg2jA/640?wx_fmt=gif&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;戳原文，&lt;span&gt;观看完整演讲视频&lt;/span&gt;！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>