<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>439d191b0f2b207cf79e985d5458f4ce</guid>
<title>什么是真正的程序员？| 码农周刊第 323 期</title>
<link>https://toutiao.io/k/v08ikpz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;什么是真正的程序员？| 码农周刊第 323 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第323期（2020-10-28）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3230&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=323&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;适合入门&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;该框架由阿里云机器学习 PAI 团队研发，让自然语言处理场景的模型预训练和迁移学习开发与部署更加简单和高效。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;硬核&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;论文笔记&lt;/p&gt;
        
        &lt;p&gt;系列文章&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;因子分解机算法&lt;/p&gt;
        
        &lt;p&gt;深入讲解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;Yahoo 开源的 Kafka 集群管理平台&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;更多可能&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;源码分析&lt;/p&gt;
        
        &lt;p&gt;一个 Android Jetpack 扩展库&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;倾向于使用 Less 或 Stylus&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;这里有最接地气的架构师一线实战经验、核心技能的分享。运营和产品的总结。以及一些个人的深度思考。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 268968 即可&lt;/p&gt;
        
        &lt;p&gt;GO PHP JS 一网打尽&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 146415 即可&lt;/p&gt;
        
        &lt;p&gt;分享技术，专注程序员成长&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 137785 即可&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;Coding虽易，debug不易....&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 98777 即可&lt;/p&gt;
        
        &lt;p&gt;专注分享Java实战技术、Java基础原理、微服务实战技术、分布式系统架构&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 22887 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书为对基本概率论感兴趣的读者以及之前未接触过此方向的人提供了一个坚实的基础。通过对话的方式和详细的数学推导，在迷人的风格和信息丰富的讨论上取得了平衡。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;真实&lt;/p&gt;
        
        &lt;p&gt;值得思考&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5ca5f35f6888ea57f7d041efbc59b4a9</guid>
<title>工具 | 字节跳动开源的，超高速、多特性的高性能序列推理引擎</title>
<link>https://toutiao.io/k/s6o3btm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d073a2764d4084b6a06c7240b0a44f59</guid>
<title>[推荐] 《我想进大厂》之 JVM 夺命连环 10 问</title>
<link>https://toutiao.io/k/swi8lo6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者： 科技缪缪（本文来自作者投稿）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 说说 JVM 的内存布局？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlaX1kzmfeFkqNiaDiar0WVkM9WqfBbh6BW3EmEgTCVCW4XbhYQGBzhSXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 虚拟机主要包含几个区域：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;堆&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：堆是 Java 虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为 Young&lt;/span&gt;&lt;span&gt; 区年轻代和 Old 区老年代，其中年轻代又分为 Eden、S0、S1 3个部分，他们默认的比例是 8:1:1 的大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，它的参数会被传递至从0开始的连续的局部变量表中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态连接用于将符号引用表示的方法转换为实际方法的直接引用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;元数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在 Java1.7 之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;class 文件就是类和接口的定义信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时常量池就是类和接口的常量池运行时的表现形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;本地方法栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要用于执行本地 native 方法的区域。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;程序计数器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 知道 new 一个对象的过程吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.40390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlOvda0KYHkCicWv9Libm8FpZgRKScK30oQxYPNIOsfMgjEvMmq8Isb6Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当虚拟机遇见 &lt;strong&gt;new &lt;/strong&gt;关键字时候，实现判断当前类是否已经加载。如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先&lt;strong&gt;校验当前类是否被加载&lt;/strong&gt;，如果没有加载，执行类加载机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加载&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：就是从字节码加载成二进制流的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;验证&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当然加载完成之后，当然需要校验 class 文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为静态变量、常量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：执行 static 代码块 (cinit) 进行初始化，如果存在父类，先对父类进行初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：静态代码块是绝对线程安全的，只能隐式被 Java 虚拟机在类加载过程中初始化调用！(此处该有问题：&lt;strong&gt;static 代码块线程安全吗？&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先为对象分配合适大小的内存空间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着为实例变量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置对象的头信息，对象 hashcode、GC 分代年龄、元数据信息等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行构造函数 (init) 初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 知道双亲委派模型吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类加载器自顶向下分为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bootstrap ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（启动类加载器）：默认会去加载 JAVA_HOME/lib 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Extention ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（扩展类加载器）：默认去加载 JAVA_HOME/lib/ext 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Application ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（应用程序类加载器）：比如我们的 Web 应用，会加载 Web 程序中 ClassPath 下的类；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;User ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（用户自定义类加载器）：由用户自己定义。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们在加载类的时候，首先都会向上询问自己的父加载器是否已经加载。如果没有则依次向上询问；如果没有加载，则从上到下依次尝试是否能加载当前类，直到加载成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlZKccYiccqpOGYdIUwltUNPmmyib6Gz2W6IWH6FCIIxojeQpyjXpw6T5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 说说有哪些垃圾回收算法？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-清除&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统一标记出需要回收的对象，标记完成之后统一回收所有被标记的对象。而由于标记的过程需要遍历所有的 GC ROOT，清除的过程也要遍历堆中所有的对象，所以标记-清除算法的效率低下，同时也带来了内存碎片的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;复制算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决性能的问题，复制算法应运而生。它将内存分为大小相等的两块区域，每次使用其中的一块。当一块内存使用完之后，将还存活的对象拷贝到另外一块内存区域中，然后把当前内存清空。这样性能和内存碎片的问题得以解决。但是同时带来了另外一个问题，可使用的内存空间缩小了一半！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，诞生了我们现在的常见的&lt;strong&gt;年轻代+老年代&lt;/strong&gt;的内存结构：Eden+S0+S1 组成。因为根据 IBM 的研究显示，98%的对象都是朝生夕死，所以实际上存活的对象并不是很多，完全不需要用到一半内存浪费，所以默认的比例是 8:1:1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，在使用的时候只使用 Eden 区和 S0、S1 中的一个，每次都把存活的对象拷贝另外一个未使用的 Survivor 区，同时清空 Eden 和使用的 Survivor，这样下来内存的浪费就只有10%了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果最后未使用的 Survivor 放不下存活的对象，这些对象就进入 Old 老年代了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所以有一些初级点的问题会问你，为什么要分为 Eden 区和2个 Survior 区？有什么作用？就是为了节省内存和解决内存碎片的问题。这些算法都是为了解决问题而产生的，如果理解原因你就不需要死记硬背了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-整理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对老年代再用复制算法显然不合适，因为进入老年代的对象都存活率比较高了，这时候再频繁的复制对性能影响就比较大，而且也不会再有另外的空间进行兜底。所以针对老年代的特点，通过&lt;strong&gt;标记-整理&lt;/strong&gt;算法，标记出所有的存活对象，让所有存活的对象都向一端移动，然后清理掉边界以外的内存空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 什么是 GC ROOT？有哪些 GC ROOT？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面提到的标记的算法，怎么标记一个对象是否存活？简单的通过引用计数法，给对象设置一个引用计数器，每当有一个地方引用他，就给计数器+1，反之则计数器-1，但是这个简单的算法&lt;strong&gt;无法解决循环引用的问题&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 通过可达性分析算法来达到标记存活对象的目的，定义一系列的 GC ROOT 为起点。从起点开始向下开始搜索，搜索走过的路径称为引用链。当一个对象到 GC ROOT没有任何引用链相连的话，则对象可以判定是可以被回收的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而可以作为 GC ROOT 的对象包括：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态变量、常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本地方法栈 native 方法引用的对象。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 垃圾回收器了解吗？年轻代和老年代都有哪些垃圾回收器？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlS2swjribk4EibNmDPwGf1o5gqeRbkSdEKic67pibPqMEDGPf857pP2G1YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;年轻代的垃圾收集器包含有 Serial、ParNew、Parallell。老年代则包括 Serial Old 老年代版本、CMS、Parallel Old 老年代版本和 JDK11 中全新的 G1 收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单线程版本收集器，进行垃圾回收的时候会 STW（Stop The World），也就是进行垃圾回收的时候其他的工作线程都必须暂停。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;ParNew&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的多线程版本，用于和 CMS 配合使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Scavenge&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以并行收集的多线程垃圾收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的老年代版本，也是单线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Parallel Scavenge 的老年代版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;CMS（Concurrent Mark Sweep）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：CMS 收集器是以获取最短停顿时间为目标的收集器。相对于其他的收集器 STW 的时间更短暂，可以并行收集是它的特点，同时它基于&lt;strong&gt;标记-清除&lt;/strong&gt;算法。整个 GC 过程分为4步：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，不需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;重新标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发清除&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：清理删除掉标记阶段判断的已经死亡的对象，不需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程。而初始标记和重新标记的耗时较短，但是需要停止用户线程。总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;G1（Garbage First）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：G1 收集器是 JDK9 的默认垃圾收集器，不再区分年轻代和老年代进行回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. G1的原理了解吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlclwUSgRl1TKmdLvuBoicahRpa48GWyMADXRrVQhAiaryF7LPkLCC1TeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 作为 JDK9 之后的服务端默认收集器，不再区分年轻代和老年代进行垃圾回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把内存划分为多个 Region，每个 Region 的大小可以通过 &lt;strong&gt;-XX：G1HeapRegionSize&lt;/strong&gt; 设置，大小为1~32M。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于大对象的存储则衍生出 &lt;strong&gt;Humongous &lt;/strong&gt;的概念。超过 Region 大小一半的对象会被认为是大对象，而超过整个 Region 大小的对象被认为是超级大对象，将会被存储在连续的 N 个 Humongous Region 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 在进行回收的时候会在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先回收收益最大的 Region。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 的回收过程分为以下四个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最终标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：短暂暂停用户线程，再处理一次，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;筛选回收&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：更新 Region 的统计数据，对每个 Region 的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的 Region 中存活对象复制到空的 Region，同时清理旧的 Region。需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说除了并发标记之外，其他几个过程也还是需要短暂的 STW。G1 的目标是在停顿和延迟可控的情况下尽可能提高吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 什么时候会触发 YGC 和 FGC？对象什么时候会进入老年代？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个新的对象来申请内存空间的时候，如果 Eden 区无法满足内存分配需求，则触发 YGC。使用中的 Survivor 区和 Eden 区存活对象送到未使用的 Survivor 区。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 YGC 之后还是没有足够空间，则直接进入老年代分配。如果老年代也无法分配空间，触发 FGC，FGC 之后还是放不下则报出 OOM 异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.03125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlDlicFGn9Z2ic9ABVnrxWE9qzl4p4QOrbWyeZ1nEYqxGibianVicET1BqnLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;YGC 之后，存活的对象将会被复制到未使用的 Survivor 区。如果 S 区放不下，则直接晋升至老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而对于那些一直在 Survivor 区来回复制的对象，通过 &lt;strong&gt;-XX：MaxTenuringThreshold&lt;/strong&gt; 配置交换阈值，默认15次。如果超过次数同样进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，还有一种动态年龄的判断机制，不需要等到 MaxTenuringThreshold 就能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. 频繁 FullGC 怎么排查？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种问题最好的办法就是结合有具体的例子举例分析，如果没有就说一般的分析步骤。发生 FGC 有可能是内存分配不合理，比如 Eden 区太小，导致对象频繁进入老年代，这时候通过启动参数配置就能看出来，另外有可能就是存在内存泄露，可以通过以下的步骤进行排查：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. &lt;strong&gt;jstat -gcutil&lt;/strong&gt; 或者查看 gc.log 日志，查看内存回收情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlNzhFQZlnLpOEIWkoPIgE4pPQYFcZ8OVdAu4ibOBtawqVJOaLficd7icXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;S0、S1 分别代表两个 Survivor 区占比；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;E 代表 Eden 区占比，图中可以看到使用了78%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;O 代表老年代，M 代表元空间，YGC 发生54次，YGCT 代表 YGC 累计耗时，GCT 代表 GC 累计耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.196875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSllkLHHPvwzafVdDDsvk6lPxdJPUQ5M2uV0Cch5HD8LfnjWrjBGPJj0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[GC&lt;/span&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;span&gt;[FGC&lt;/span&gt;&lt;span&gt; 开头代表垃圾回收的类型；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PSYoungGen: 6130K-&amp;gt;6130K(9216K)] 12274K-&amp;gt;14330K(19456K), 0.0034895 secs&lt;/span&gt;&lt;span&gt; 代表 YGC 前后内存使用情况；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Times: user=0.02 sys=0.00, real=0.00 secs&lt;/span&gt;&lt;span&gt;：user 表示用户态消耗的 CPU 时间，sys 表示内核态消耗的 CPU 时间，real 表示各种墙时钟的等待时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这两张图只是举例并没有关联关系。比如你从图里面看能到是否进行 FGC、FGC 的时间花费多长；GC 后老年代，年轻代内存是否有减少；得到一些初步的情况来做出判断。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. dump 出内存文件在具体分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如通过 jmap 命令 &lt;strong&gt;jmap -dump:format=b,file=dumpfile pid&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;导出之后再&lt;/span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;span&gt;Eclipse Memory Analyze&lt;/span&gt;&lt;span&gt;r &lt;/span&gt;&lt;span&gt;等工具进行分析，定位到代码、&lt;/span&gt;&lt;span&gt;修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里还会可能存在一个提问的点，比如 &lt;strong&gt;CPU 飙高，同时 FGC 怎么办&lt;/strong&gt;？办法比较类似：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到当前进程的 pid，&lt;strong&gt;top -p pid -H&lt;/strong&gt; 查看资源占用，找到问题线程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;printf “%x\n” pid&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，把线程 pid 转为16进制，比如 0x32d；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;jstack pid|grep -A 10 0x32d &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;查看线程的堆栈日志，还找不到问题继续下一步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dump 出内存文件用 MAT 等工具进行分析，定位到代码、修复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. JVM调优有什么经验吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要明白一点，所有的调优的目的都是为了用更小的硬件成本达到更高的吞吐，JVM 的调优也是一样。通过对垃圾收集器和内存分配的调优达到性能的最佳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;简单的参数含义&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，需要知道几个主要的参数含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlLWMnkcBxCTMcdsOu97iaiaSbOv87f3heq6PbIWTnZOtQIaEy96HZxj8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-Xms&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置初始堆的大小，&lt;strong&gt;-Xmx &lt;/strong&gt;设置最大堆的大小；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewSize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代大小，&lt;strong&gt;-XX:MaxNewSize&lt;/strong&gt; 年轻代最大值，&lt;strong&gt;-Xmn&lt;/strong&gt; 则是相当于同时配置 -XX:NewSize 和 -XX:MaxNewSize 为一样的值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置年轻代和年老代的比值。如果为3，表示年轻代与老年代比值为 1:3，默认值为2；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:SurvivorRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代和两个 Survivor 的比值。默认值为8，代表比值为 8:1:1；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:PretenureSizeThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当创建的对象超过指定大小时，直接把对象分配在老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设定对象在 Survivor 复制的最大年龄阈值，超过阈值转移到老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxDirectMemorySize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当 Direct ByteBuffer 分配的堆外内存到达指定大小后，即触发 Full GC。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;调优&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了打印日志方便排查问题最好开启GC日志。开启GC日志对性能影响微乎其微，但是能帮助我们快速排查定位问题。&lt;strong&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一般设置 &lt;strong&gt;-Xms=-Xmx&lt;/strong&gt;。这样可以获得固定大小的堆内存，减少 GC 次数和耗时，可以使得堆相对稳定；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 让 JVM 在发生内存溢出的时候自动生成内存快照，方便排查问题；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;-Xmn&lt;/strong&gt; 设置新生代的大小。太小会增加 YGC，太大会减小老年代大小，一般设置为&lt;strong&gt;整个堆的1/4到1/3&lt;/strong&gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置 &lt;strong&gt;-XX:+DisableExplicitGC &lt;/strong&gt;禁止系统 System.gc()。防止手动误触发 FGC 造成问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651482823&amp;amp;idx=1&amp;amp;sn=cd623fbfa900f1217b34d34f980b2e82&amp;amp;chksm=bd2506b88a528faea643840bb2613ae67252085c24faaba2359006cc37335dc4fe042f1ca66d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;关于 JVM 内存的 N 个问题&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651488039&amp;amp;idx=1&amp;amp;sn=b812f2bd8b3e0e7edfdb2bb6c050894e&amp;amp;chksm=bd2513588a529a4e02c41f59fa78adc2c064b48b112a5120d53687b8ee84aff87524acecb479&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JVM 史上最最最完整深入解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486318&amp;amp;idx=1&amp;amp;sn=a0bf7b6896cc30cff1581243193200fc&amp;amp;chksm=bd2514118a529d0769979c50eaac2c8b5fef25cb8fdf550d9e24534d211700d0bd6befae2b64&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Boot项目优化和JVM调优&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好文章，我&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d57371e4e1fb4835ce1dec4639db21b1</guid>
<title>[推荐] 面试官：如何写出让 CPU 跑得更快的代码？</title>
<link>https://toutiao.io/k/l6chi61</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6356877323420075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DU5g3I7vpskPKGc2AVN5icSasGiaxoa1NIJWILJqTibPeibIZv2jkj6ianZSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;代码都是由 CPU 跑起来的，我们代码写的好与坏就决定了 CPU 的执行效率，特别是在编写计算密集型的程序，更要注重 CPU 的执行效率，否则将会大大影响系统性能。&lt;/p&gt;&lt;p&gt;CPU 内部嵌入了 CPU Cache（高速缓存），它的存储容量很小，但是离 CPU 核心很近，所以缓存的读写速度是极快的，那么如果 CPU 运算时，直接从 CPU Cache 读取数据，而不是从内存的话，运算速度就会很快。&lt;/p&gt;&lt;p&gt;但是，大多数人不知道 CPU Cache 的运行机制，以至于不知道如何才能够写出能够配合 CPU Cache 工作机制的代码，一旦你掌握了它，你写代码的时候，就有新的优化思路了。&lt;/p&gt;&lt;p&gt;那么，接下来我们就来看看，CPU Cache 到底是什么样的，是如何工作的呢，又该写出让 CPU 执行更快的代码呢？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.34772462077012833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUqltTazYGAUDNlrTfuPx6rgBxLw3ynWVJIQSGAVlM7bc73W4znSPoZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;CPU Cache 有多快？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;你可能会好奇为什么有了内存，还需要 CPU Cache？根据摩尔定律，CPU 的访问速度每 18 个月就会翻倍，相当于每年增长 60% 左右，内存的速度当然也会不断增长，但是增长的速度远小于 CPU，平均每年只增长 7% 左右。于是，CPU 与内存的访问性能的差距不断拉大。&lt;/p&gt;&lt;p&gt;到现在，一次内存访问所需时间是 &lt;code&gt;200~300&lt;/code&gt; 多个时钟周期，这意味着 CPU 和内存的访问速度已经相差 &lt;code&gt;200~300&lt;/code&gt; 多倍了。&lt;/p&gt;&lt;p&gt;为了弥补 CPU 与内存两者之间的性能差异，就在 CPU 内部引入了  CPU Cache，也称高速缓存。&lt;/p&gt;&lt;p&gt;CPU Cache 通常分为大小不等的三级缓存，分别是 &lt;strong&gt;L1 Cache、L2 Cache 和 L3 Cache&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;由于 CPU Cache 所使用的材料是 SRAM，价格比内存使用的 DRAM 高出很多，在当今每生产 1 MB 大小的 CPU Cache 需要 7 美金的成本，而内存只需要 0.015 美金的成本，成本方面相差了 466 倍，所以 CPU Cache 不像内存那样动辄以 GB 计算，它的大小是以 KB 或 MB 来计算的。&lt;/p&gt;&lt;p&gt;在 Linux 系统中，我们可以使用下图的方式来查看各级 CPU Cache 的大小，比如我这手上这台服务器，离 CPU 核心最近的 L1 Cache 是 32KB，其次是 L2 Cache 是 256KB，最大的 L3 Cache 则是 3MB。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7211740041928721&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUiaYtfLibicW11HOurkPCxZ6WcY0JHr1oGpcRvyNKsozexRSR3iaUzpulVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其中，&lt;strong&gt;L1 Cache 通常会分为「数据缓存」和「指令缓存」&lt;/strong&gt;，这意味着数据和指令在 L1 Cache 这一层是分开缓存的，上图中的 &lt;code&gt;index0&lt;/code&gt; 也就是数据缓存，而 &lt;code&gt;index1&lt;/code&gt; 则是指令缓存，它两的大小通常是一样的。&lt;/p&gt;&lt;p&gt;另外，你也会注意到，L3 Cache 比 L1 Cache 和 L2 Cache 大很多，这是因为 &lt;strong&gt;L1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU 核心共享的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;程序执行时，会先将内存中的数据加载到共享的 L3 Cache 中，再加载到每个核心独有的 L2 Cache，最后进入到最快的 L1 Cache，之后才会被 CPU 读取。它们之间的层级关系，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6649056603773585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUZic96QWC2PPxCPP9HeOPgzcmfSj9I80u1W15JpyIUib3LbibMpjFTh0Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1325&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;越靠近 CPU 核心的缓存其访问速度越快，CPU 访问 L1 Cache 只需要 &lt;code&gt;2~4&lt;/code&gt; 个时钟周期，访问 L2 Cache 大约 &lt;code&gt;10~20&lt;/code&gt; 个时钟周期，访问 L3 Cache 大约 &lt;code&gt;20~60&lt;/code&gt; 个时钟周期，而访问内存速度大概在 &lt;code&gt;200~300&lt;/code&gt; 个 时钟周期之间。如下表格：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5965189873417721&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUwhcPrwJ0d1niaQBKwCcsIvXC5Bm5MibIsgRum9riaEg7z2WibopJGaQQug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;所以，CPU 从 L1 Cache 读取数据的速度，相比从内存读取的速度，会快 &lt;code&gt;100&lt;/code&gt; 多倍。&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;CPU Cache 的数据结构和读取过程是什么样的？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为 &lt;strong&gt;Cache Line（缓存块）&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;你可以在你的 Linux 系统，用下面这种方式来查看 CPU 的 Cache Line，你可以看我服务器的 L1 Cache Line 大小是 64 字节，也就意味着 &lt;strong&gt;L1 Cache 一次载入数据的大小是 64 字节&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.20949263502454993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUpgXIYYgic3eJ5SHJNKFVRnLPwCd2qNnEGEichslHoZLWt8GsyEu49Nqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1222&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;比如，有一个 &lt;code&gt;int array[100]&lt;/code&gt; 的数组，当载入 &lt;code&gt;array[0]&lt;/code&gt; 时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会&lt;strong&gt;顺序加载&lt;/strong&gt;数组元素到 &lt;code&gt;array[15]&lt;/code&gt;，意味着 &lt;code&gt;array[0]~array[15]&lt;/code&gt; 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。&lt;/p&gt;&lt;p&gt;事实上，CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5844875346260388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUfV2liaq9Sm18DGvnOFhxAHpGX1U3GqBwNlyj3W2biaRLeWTsv6NBrdvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样的访问机制，跟我们使用「内存作为硬盘的缓存」的逻辑是一样的，如果内存有缓存的数据，则直接返回，否则要访问龟速一般的硬盘。&lt;/p&gt;&lt;p&gt;那 CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？我们从最简单、基础的&lt;strong&gt;直接映射 Cache（&lt;em&gt;Direct Mapped Cache&lt;/em&gt;）&lt;/strong&gt; 说起，来看看整个 CPU Cache 的数据结构和访问逻辑。&lt;/p&gt;&lt;p&gt;前面，我们提到 CPU 访问内存数据时，是一小块一小块数据读取的，具体这一小块数据的大小，取决于 &lt;code&gt;coherency_line_size&lt;/code&gt; 的值，一般 64 字节。在内存中，这一块的数据我们称为&lt;strong&gt;内存块（&lt;em&gt;Bock&lt;/em&gt;）&lt;/strong&gt;，读取的时候我们要拿到数据所在内存块的地址。&lt;/p&gt;&lt;p&gt;对于直接映射 Cache 采用的策略，就是把内存块的地址始终「映射」在一个 CPU Line（缓存块） 的地址，至于映射关系实现方式，则是使用「取模运算」，取模运算的结果就是内存块地址对应的 CPU Line（缓存块） 的地址。&lt;/p&gt;&lt;p&gt;举个例子，内存共被划分为 32 个内存块，CPU Cache 共有 8 个 CPU Line，假设 CPU 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 CPU Line 中的话，则是一定映射在 7 号 CPU Line 中，因为 &lt;code&gt;15 % 8&lt;/code&gt; 的值是 7。&lt;/p&gt;&lt;p&gt;机智的你肯定发现了，使用取模方式映射的话，就会出现多个内存块对应同一个 CPU Line，比如上面的例子，除了 15 号内存块是映射在 7 号 CPU Line 中，还有 7 号、23 号、31 号内存块都是映射到 7 号 CPU Line 中。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.0351390922401171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUwLEOS9ugA1Km1PvBQf6zJ9ffp8HzIFBo5AdqI87aUqO25SUUExafHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;因此，为了区别不同的内存块，在对应的 CPU Line 中我们还会存储一个&lt;strong&gt;组标记（Tag）&lt;/strong&gt;。这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。&lt;/p&gt;&lt;p&gt;除了组标记信息外，CPU Line 还有两个信息：&lt;/p&gt;&lt;p&gt;CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个&lt;strong&gt;字（&lt;em&gt;Word&lt;/em&gt;）&lt;/strong&gt;。那怎么在对应的 CPU Line 中数据块中找到所需的字呢？答案是，需要一个&lt;strong&gt;偏移量（Offset）&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;因此，一个内存的访问地址，包括&lt;strong&gt;组标记、CPU Line 索引、偏移量&lt;/strong&gt;这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由&lt;strong&gt;索引 + 有效位 + 组标记 + 数据块&lt;/strong&gt;组成。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6840363937138131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUGmFpHBHryZfZCrS1CcXAAXwZq4la5afWIFtIfATQJpGGGBQkicIMcHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1209&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对比内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;到这里，相信你对直接映射 Cache 有了一定认识，但其实除了直接映射 Cache 之外，还有其他通过内存地址找到 CPU Cache 中的数据的策略，比如全相连 Cache （&lt;em&gt;Fully Associative Cache&lt;/em&gt;）、组相连 Cache （&lt;em&gt;Set Associative Cache&lt;/em&gt;）等，这几种策策略的数据结构都比较相似，我们理解流直接映射 Cache 的工作方式，其他的策略如果你有兴趣去看，相信很快就能理解的了。&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;如何写出让 CPU 跑得更快的代码？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们知道 CPU 访问内存的速度，比访问 CPU Cache 的速度慢了 100 多倍，所以如果 CPU 所要操作的数据在 CPU Cache 中的话，这样将会带来很大的性能提升。访问的数据在 CPU Cache 中的话，意味着&lt;strong&gt;缓存命中&lt;/strong&gt;，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。&lt;/p&gt;&lt;p&gt;于是，「如何写出让 CPU 跑得更快的代码？」这个问题，可以改成「如何写出 CPU 缓存命中率高的代码？」。&lt;/p&gt;&lt;p&gt;在前面我也提到， L1 Cache 通常分为「数据缓存」和「指令缓存」，这是因为 CPU 会别处理数据和指令，比如 &lt;code&gt;1+1=2&lt;/code&gt; 这个运算，&lt;code&gt;+&lt;/code&gt; 就是指令，会被放在「指令缓存」中，而输入数字 &lt;code&gt;1&lt;/code&gt; 则会被放在「数据缓存」里。&lt;/p&gt;&lt;p&gt;因此，&lt;strong&gt;我们要分开来看「数据缓存」和「指令缓存」的缓存命中率&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;如何提升数据缓存的命中率？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;假设要遍历二维数组，有以下两种形式，虽然代码执行结果是一样，但你觉得哪种形式效率最高呢？为什么高呢？&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.3868613138686132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUaWq5KdzLgGiaTeUj6icIrEgVHbzteS2cMUQlbkEfiawYibpunTLQO08DBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;经过测试，形式一 &lt;code&gt;array[i][j]&lt;/code&gt;  执行时间比形式二 &lt;code&gt;array[j][i]&lt;/code&gt; 快好几倍。&lt;/p&gt;&lt;p&gt;之所以有这么大的差距，是因为二维数组 &lt;code&gt;array&lt;/code&gt; 所占用的内存是连续的，比如长度 &lt;code&gt;N&lt;/code&gt; 的指是 &lt;code&gt;2&lt;/code&gt; 的话，那么内存中的数组元素的布局顺序是这样的：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2391304347826087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DU1V6Raia4HWY3ZAUReO3jbvGHRib59hCUbpRZ612thav03UbGoujvSuSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;形式一用 &lt;code&gt;array[i][j]&lt;/code&gt;  访问数组元素的顺序，正是和内存中数组元素存放的顺序一致。当 CPU 访问 &lt;code&gt;array[0][0]&lt;/code&gt; 时，由于该数据不在 Cache 中，于是会「顺序」把跟随其后的 3 个元素从内存中加载到 CPU Cache，这样当 CPU 访问后面的 3 个数组元素时，就能在 CPU Cache 中成功地找到数据，这意味着缓存命中率很高，缓存命中的数据不需要访问内存，这便大大提高了代码的性能。&lt;/p&gt;&lt;p&gt;而如果用形式二的 &lt;code&gt;array[j][i]&lt;/code&gt; 来访问，则访问的顺序就是：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2391304347826087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DULaIspIibUC6T3XxxOlc0YRmlI6Wa8nHf1qviaDzxBLoAEdk61tmW4jNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;你可以看到，访问的方式跳跃式的，而不是顺序的，那么如果 N 的数值很大，那么操作 &lt;code&gt;array[j][i]&lt;/code&gt; 时，是没办法把 &lt;code&gt;array[j+1][i]&lt;/code&gt; 也读入到 CPU Cache 中的，既然 &lt;code&gt;array[j+1][i]&lt;/code&gt; 没有读取到 CPU Cache，那么就需要从内存读取该数据元素了。很明显，这种不连续性、跳跃式访问数据元素的方式，可能不能充分利用到了 CPU Cache 的特性，从而代码的性能不高。&lt;/p&gt;&lt;p&gt;那访问 &lt;code&gt;array[0][0]&lt;/code&gt; 元素时，CPU 具体会一次从内存中加载多少元素到 CPU Cache 呢？这个问题，在前面我们也提到过，这跟 CPU Cache Line 有关，它表示 &lt;strong&gt;CPU Cache 一次性能加载数据的大小&lt;/strong&gt;，可以在 Linux 里通过 &lt;code&gt;coherency_line_size&lt;/code&gt; 配置查看 它的大小，通常是 64 个字节。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.20949263502454993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUpgXIYYgic3eJ5SHJNKFVRnLPwCd2qNnEGEichslHoZLWt8GsyEu49Nqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1222&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;也就是说，当 CPU 访问内存数据时，如果数据不在 CPU Cache 中，则会一次性会连续加载 64 字节大小的数据到 CPU Cache，那么当访问 &lt;code&gt;array[0][0]&lt;/code&gt; 时，由于该元素不足 64 字节，于是就会往后&lt;strong&gt;顺序&lt;/strong&gt;读取 &lt;code&gt;array[0][0]~array[0][15]&lt;/code&gt; 到 CPU Cache 中。顺序访问的 &lt;code&gt;array[i][j]&lt;/code&gt; 因为利用了这一特点，所以就会比跳跃式访问的 &lt;code&gt;array[j][i]&lt;/code&gt; 要快。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;因此，遇到这种遍历数组的情况时，按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升，&lt;/strong&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;如何提升指令缓存的命中率？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;提升数据的缓存命中率的方式，是按照内存布局顺序访问，那针对指令的缓存该如何提升呢？&lt;/p&gt;&lt;p&gt;我们以一个例子来看看，有一个元素为 0 到 100 之间随机数字组成的一维数组：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5985401459854015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DU9LLoj74jOfcObSSxeWI3Rc3mgkbJ51n7jAKiajAjxTfSPJB4XrAJ5rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来，对这个数组做两个操作：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.927007299270073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DULmPvhCfBh9RvNIa8TRCZasTczRGWsTVk75zwo76mAWeGwkaEndYn2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;那么问题来了，你觉得先遍历再排序速度快，还是先排序再遍历速度快呢？&lt;/p&gt;&lt;p&gt;在回答这个问题之前，我们先了解 CPU 的&lt;strong&gt;分支预测器&lt;/strong&gt;。对于 if 条件语句，意味着此时至少可以选择跳转到两段不同的指令执行，也就是 if 还是 else 中的指令。那么，&lt;strong&gt;如果分支预测可以预测到接下来要执行 if 里的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;当数组中的元素是随机的，分支预测就无法有效工作，而当数组元素都是顺序的，分支预测器会动态地根据历史命中数据对未来进行预测，这样命中率就会很高。&lt;/p&gt;&lt;p&gt;因此，先排序再遍历速度会更快，这是因为排序之后，数字是从小到大的，那么前几次循环命中 &lt;code&gt;if &amp;lt; 50&lt;/code&gt; 的次数会比较多，于是分支预测就会缓存 &lt;code&gt;if&lt;/code&gt; 里的 &lt;code&gt;array[i] = 0&lt;/code&gt; 指令到 Cache 中，后续 CPU 执行该指令就只需要从 Cache 读取就好了。&lt;/p&gt;&lt;p&gt;如果你肯定代码中的 &lt;code&gt;if&lt;/code&gt; 中的表达式判断为 &lt;code&gt;true&lt;/code&gt; 的概率比较高，我们可以使用显示分支预测工具，比如在 C/C++ 语言中编译器提供了 &lt;code&gt;likely&lt;/code&gt; 和 &lt;code&gt;unlikely&lt;/code&gt; 这两种宏，如果 &lt;code&gt;if&lt;/code&gt; 条件为 &lt;code&gt;ture&lt;/code&gt; 的概率大，则可以用 &lt;code&gt;likely&lt;/code&gt; 宏把 &lt;code&gt;if&lt;/code&gt; 里的表达式包裹起来，反之用 &lt;code&gt;unlikely&lt;/code&gt; 宏。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5539906103286385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUzOCKyzJmM68G89T8hSbibBuEch9QQQF0IY59uUtfibN3Fn2rTt5whcJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;实际上，CPU 自身的动态分支预测已经是比较准的了，所以只有当非常确信 CPU 预测的不准，且能够知道实际的概率情况时，才建议使用这两种宏。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;如果提升多核 CPU 的缓存命中率？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在单核 CPU，虽然只能执行一个进程，但是操作系统给每个进程分配了一个时间片，时间片用完了，就调度下一个进程，于是各个进程就按时间片交替地占用 CPU，从宏观上看起来各个进程同时在执行。&lt;/p&gt;&lt;p&gt;而现代 CPU 都是多核心的，进程可能在不同 CPU 核心来回切换执行，这对 CPU Cache 不是有利的，虽然 L3 Cache 是多核心之间共享的，但是 L1 和 L2 Cache 都是每个核心独有的，&lt;strong&gt;如果一个进程在不同核心来回切换，各个核心的缓存命中率就会受到影响&lt;/strong&gt;，相反如果进程都在同一个核心上执行，那么其数据的 L1 和 L2 Cache 的缓存命中率可以得到有效提高，缓存命中率高就意味着 CPU 可以减少访问 内存的频率。&lt;/p&gt;&lt;p&gt;当有多个同时执行「计算密集型」的线程，为了防止因为切换到不同的核心，而导致缓存命中率下降的问题，我们可以把&lt;strong&gt;线程绑定在某一个 CPU 核心上&lt;/strong&gt;，这样性能可以得到非常可观的提升。&lt;/p&gt;&lt;p&gt;在 Linux 上提供了 &lt;code&gt;sched_setaffinity&lt;/code&gt; 方法，来实现将线程绑定到某个 CPU 核心这一功能。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.23548387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUvZ5zh4RImou6azJ9KMevyTDPcTHLffjYgxyckdaggftIY6hJgiarkYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;由于随着计算机技术的发展，CPU 与 内存的访问速度相差越来越多，如今差距已经高达好几百倍了，所以 CPU 内部嵌入了 CPU Cache 组件，作为内存与 CPU 之间的缓存层，CPU Cache 由于离 CPU 核心很近，所以访问速度也是非常快的，但由于所需材料成本比较高，它不像内存动辄几个 GB 大小，而是仅有几十 KB 到 MB 大小。&lt;/p&gt;&lt;p&gt;当 CPU 访问数据的时候，先是访问 CPU Cache，如果缓存命中的话，则直接返回数据，就不用每次都从内存读取速度了。因此，缓存命中率越高，代码的性能越好。&lt;/p&gt;&lt;p&gt;但需要注意的是，当 CPU 访问数据时，如果 CPU Cache 没有缓存该数据，则会从内存读取数据，但是并不是只读一个数据，而是一次性读取一块一块的数据存放到 CPU Cache 中，之后才会被 CPU 读取。&lt;/p&gt;&lt;p&gt;内存地址映射到 CPU Cache 地址里的策略有很多种，其中比较简单是直接映射 Cache，它巧妙的把内存地址拆分成「索引 + 组标记 + 偏移量」的方式，使得我们可以将很大的内存地址，映射到很小的 CPU Cache 地址里。&lt;/p&gt;&lt;p&gt;要想写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率：&lt;/p&gt;&lt;p&gt;另外，对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高进程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。&lt;/p&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;絮叨&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;分享个喜事，小林平日里忙着输出文章，今天收到一份特别的快递，是 CSDN 寄来的奖状。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6587360594795539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZcKapyUj66hkhTng5Zof8DUZ0IFb8hhbujk32TmfGFhf050tBp0Y99Z45Ee6v0PwhnjVq73FsDEVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1345&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;骄傲的说，你们关注的是 CSDN 首届技术原创第一名的博主，以后简历又可以吹牛逼了&lt;/p&gt;&lt;p&gt;没有啦，其实主要还是&lt;strong&gt;谢谢你们不离不弃的支持&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5902612826603325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcKapyUj66hkhTng5Zof8DUVwlCFh1n6JlGk9YqHE2t6sNc4UfFw0Za60dcwsambuF9A16w06086A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;em&gt;哈喽，我是小林，就爱图解计算机基础，如果觉得文章对你有帮助，欢迎分享给你的朋友，也给小林点个「在看」，这对小林非常重要，谢谢你们，给各位小姐姐小哥哥们抱拳了，我们下次见！&lt;/em&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h5&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;这个星期不知不觉输出了 3 篇文章了，前面的 2 篇还没看过的同学，赶紧去看看呀！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247485960&amp;amp;idx=1&amp;amp;sn=476d40b3e272149ba6c7370340e9768f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;天啦噜！知道硬盘很慢，但没想到比 CPU Cache 慢 10000000 倍&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247485918&amp;amp;idx=1&amp;amp;sn=f7fa3aa2a7cc362eeebad09d4d6fa03a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;CPU 执行程序的秘密，藏在了这 15 张图里&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1d02de76a2e7a5045cff32e6675b6cc3</guid>
<title>[推荐] Redis 集群搭建采坑总结</title>
<link>https://toutiao.io/k/b60qswo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    先澄清一下，整个过程问题都不是我解决的，我在里面就是起了个打酱油的角色。因为实际上我负责这个项目，整个过程也比较清楚。之前也跟具体负责的同事说过，等过段时间带他做做项目复盘。结果一直忙，之前做的事情都快忘了也没带他做复盘。所以趁着还记得，总结一下这个问题，也算一起做个复盘总结了。&lt;/p&gt;&lt;p&gt;    本周一的时候，我们测试环境遇到一个问题：启动一个服务就会导致后端调用耗时增加。当时咨询了对这个问题之前有了解的同事得到的答复是因为一笔请求发到两套测试环境(一个请求需要在两套环境下运行结果做对比)，因为这两套环境共用同一套redis集群。收到第二个相同请求的时候，会将这笔请求标记为重复请求。下游接收到这笔请求是重复的，需要重新查询数据库验证请求是否重复，不是的话做一个纠正。所以这时候会造成请求延迟升高。&lt;/p&gt;&lt;p&gt;    负责解决这个问题的同事小A就问我：那是不是再搭建一套将两套Redis集群分开就解决了。我说不一定，还有解释不通的地方：一个环境服务不启动不写redis，另一个环境服务启动写redis的时候也会遇到这个问题。&lt;/p&gt;&lt;p&gt;    于是小A找了这个服务相关负责的同事了解业务。因为测试环境的总责任人是我，所以了解业务的时候，小A也把我拉了一起了解。通过同事的讲述了解到一个环境中服务要写两个机房。如果两个机房的Redis是同一套也会被标记成重复请求。&lt;/p&gt;&lt;p&gt;    至此，解决环境问题的方法有了答案：每套环境要搭建两套Redis集群，两个环境4套Redis集群来解决问题。&lt;/p&gt;&lt;p&gt;    往往，一个答案只是一系列问题的开始。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间线&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    我们的搭建方案是直接在使用Redis的服务上搭建连接它的两套Redis集群，只改下端口，多跑两个进程。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题1：服务器退出登录Redis服务会停止&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;     小A告诉我遇到问题的现象：按照网上经典的安装启动教程，启动成功了。但是当干会儿别的，ssh自动退出登录之后再看Redis服务就停止了。&lt;/p&gt;&lt;p&gt;     我听到这里首先想到的是这个现象基本可以断定是以非daemon进程在运行，于是我上网上找了以deamon方式运行的命令发给小A：&lt;/p&gt;&lt;p&gt;redis-server ./redis.conf --daemonize yes&lt;/p&gt;&lt;p&gt;     小A看了解决方法补充到那一定也可以在配置文件里直接配置daemon方式运行。我表示赞同，他也是这么做的。我当时没有点破，相信刚毕业的他不久也自己会发现配置文件和显示命令实际上是一回事。只是一个是永久生效，一个是每次运行时生效。而直接用这条命令只是为了说明本质问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题2：服务连接Redis报错Not Auth&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     小A又向我反馈报了一个错，说他在网上查的是Redis版本问题，估计需要重新搭建Redis。我过去看了一下：Redis集群是3.X的版本，jedis客户端用的是2.9的版本。没有听说过Redis3.X的版本有不向下兼容的问题，同时因为这个Redis是从负责Redis的团队要过来的安装包，应该和现在跑着的是一个版本。如果怀疑Redis的团队发的安装包与之前不一样的话，我也确信之前肯定版本不会低于3.0，因为Redis是从3.0之后才支持集群的。所以我判定不是Redis版本问题。让他再查查。实际上我的意思是让他换关键词来查。比如可以按照报错的提示原因来查，也可以按照异常来查，不同的关键词搜索可以获得不同的信息。&lt;/p&gt;&lt;p&gt;    然后我看了报的错：其他的没细看，只见赫然写着：Not Auth。我就问：Redis服务有没有设置密码。他说没有，还演示了一下，我在旁边确认了没有。就查看客户端配置有没有配置密码。果然客户端里有密码配置。这就与服务端不匹配了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题3：报错cluster support disabled&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    小A将客户端密码去掉重新打包部署之后，Not Auth的错不报了，但是其实报了两个错，还有一个错没解决：就是提示cluster support disabled。&lt;/p&gt;&lt;p&gt;    我说集群方式启动应该就是一个配置，应该有个cluster-enabled什么的从no改成yes。我还出了个馊主意(注意这里用到的馊主意，想想《红楼梦》里每句话都是剧透，这里也不例外)：我说理论上一台集群也可以算一个集群。应该可以直接改个配置就以集群方式启动了。&lt;/p&gt;&lt;p&gt;    小A按照我说的思路用直接改配置为集群的方法，客户端再启动果然没有报错了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题4：请求延迟没有好转，Redis服务端没有写入成功数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    客户端没有报错之后，小A重试原问题现场，请求延迟没有好转。另外，还发现Redis服务端没有写入成功的数据。&lt;/p&gt;&lt;p&gt;    这次我和小A首先一起排查配置有没有配置对。发现配置没有问题，我就跟小A说：让他多打日志。客户端连接的地方打一些，读写数据的地方打一些。&lt;/p&gt;&lt;p&gt;    通过这个方法，小A定位到客户端连接的连接池为空。最终自己排查到是一台机器的集群的哈希槽在一台机器情况下哈希槽分配有问题，数据写入失败。最后每个集群多起了2个Redis进程做成3个节点的集群解决了问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;可优化的排查思路分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    在问题4排查的时候，我和小A一起检查了配置是否正确来确认Redis请求是请求到了正确的服务端。其实，有个更为直接和说明问题的方法：抓包。可以tcpdump端口查请求流量是不是正确从客户端发出来了，被转发到了哪里。&lt;/p&gt;&lt;p&gt;    在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485553&amp;amp;idx=1&amp;amp;sn=945e46d81bef62f35ac447895d99cdd2&amp;amp;chksm=fafde2dfcd8a6bc905cd0e9e50a9e51247a6d53f614a948b89209341a55877893a3fcba295dd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《技术方案设计的方法》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《技术方案设计的方法》&lt;/a&gt;里我也提到，很多时候搜索不到自己想要的信息很可能是关键词的问题。排查问题的时候也可以试着换换关键词来搜索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;根本原因分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    这里面有个问题没有彻底搞清楚：为什么一台机器的Redis集群会有问题。&lt;/p&gt;&lt;p&gt;    问了小A，当时异常时getSlots方法时返回了空。就是说问题实际上可能是slot没有被分配。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;    我就问他单台机器的时候有没有在redis-cli客户端上运行cluster info命令。他给我发了下面的运行情况截图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6090750436300174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl89y3phMeqKp0zqjUPXAouo4xPAUDrcwSPreZt9xV0gMHgeZVXh3dwkcVXbOcbJXOUsbuShHoXXCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;573&quot;/&gt;&lt;/p&gt;&lt;p&gt;    这张截图验证了我的猜想，slot没有被分配，集群状态为失败，所以连接不上。&lt;/p&gt;&lt;p&gt;    那需要连接上的条件并非是集群里有几个节点，而是slots分配，集群状态成功。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2623688155922039&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl89y3phMeqKp0zqjUPXAouoK0n5ZK12F4Ge6qV0G5f0trZBftHpC3x5ekDMoApRstA6ejgyxE0xKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1334&quot;/&gt;&lt;/p&gt;&lt;p&gt;    为了验证这个猜想，我搭建了一个一个节点的集群，手动cluster addslots了0到16383个slot。集群判断16384个slot都分配完毕，自动状态改成OK。&lt;/p&gt;&lt;p&gt;    &lt;/p&gt;&lt;p&gt;    这整个过程说明了：网上都是说Redis集群必须是3个节点以上的最好是单数个节点来启动。单数个节点是为了投票的时候可以三局两胜得出结论：一半以上的节点挂掉整个集群不可用。而对于Redis根本上判断集群是否可用是根据slot有没有完整的16384个slot在提供服务决定的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    我觉得在整个过程中小A的表现我觉得很OK的。有4点：&lt;/p&gt;&lt;p&gt;1&amp;gt;主观能动性&lt;/p&gt;&lt;p&gt;    在过程中，他自己通过网上搜素找资源，自己解决了很多问题。整个问题处理过程中其实没花费我多少时间，花时间的事情他都自己解决了。&lt;/p&gt;&lt;p&gt;2&amp;gt;合理的利用了各种资源&lt;/p&gt;&lt;p&gt;    对于业务不理解，他找了理解业务的同事。技术问题搞不定他找了我。因为我对项目负责，所以找我是很合情合理的。同时，我是很希望他遇到这种事情来找我的。因为他找我证明他是信任我的，相信我能一定程度帮到他。第二，他找我是把我当成一种资源。作为资源我被需要，是有价值的。被需要让人觉得很踏实。&lt;/p&gt;&lt;p&gt;    我在有搞不定的事情的时候也向上寻求帮助。比如之前需要其他组协作的时候人家有排期遇到困难，领导出面帮忙搞定了。还有申请资源由于暂时性资源紧张，申请不到，也是更上级出面帮忙搞定了。一个称职的上级一定可以成为一种资源，也愿意让自己成为资源。但是成为资源的形式不同，有的可能提供的是战略，有的提供的是精神支持等。&lt;/p&gt;&lt;p&gt;3&amp;gt;事后总结&lt;/p&gt;&lt;p&gt;    问题解决后，小A有自己写wiki总结事情经过，避免后人采坑，同时自身也有总结收获。&lt;/p&gt;&lt;p&gt;4&amp;gt;及时沟通&lt;/p&gt;&lt;p&gt;    中间过程中，他每个关键步骤都有及时跟我沟通。因为解决完后他反馈给我：他自己觉得对于redis原理还没有理解，所以不清楚为什么3个节点就OK的原因。我因为了解他的想法，所以才自己又实验给出一个根本原因分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;    关于Redis，就一句话：那些很多人说只有面试的时候才能用到的东西，我总是发现实际工作中很有用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;相关阅读&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>