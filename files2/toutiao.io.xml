<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d94851ca017f26ea687c9708250e6a05</guid>
<title>京东不再需要CTO；架构师成长路线；Go1.18泛型编程体验｜码农周刊VIP会员专属邮件周报 Vol.085</title>
<link>https://toutiao.io/k/spdubm8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以下内容节选自「码农周刊VIP会员专属邮件周报 Vol.085」，查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本期，首先分享的是&lt;strong&gt;有效沟通的四个误区&lt;/strong&gt;，供参考。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）我是对的，&lt;strong&gt;错的是你&lt;/strong&gt;；&lt;br/&gt;2）我了解事情的全貌，&lt;strong&gt;你不了解&lt;/strong&gt;；&lt;br/&gt;3）我动机单纯，&lt;strong&gt;你可不一定&lt;/strong&gt;；&lt;br/&gt;4）我不是问题的始作俑者。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicExaAOpFGs2HwoLibfVcbghYjBFH0wjibEvDYjKib0ptt4jic9AtPboeZZNcGehAj7tiaYYtNI6Pa31iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;黑匣子这么重要，为什么数据不能云同步？&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;https://mp.weixin.qq.com/s/VvAGVX_MsXQ8gKIcodSnRw&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;黑匣子最主要的任务是保存数据，其他方面的性能很差，无法搭载实现数据同步所需的操作环境。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;京东不再需要 CTO&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/WT1CB6ORxhHsl4bbIXADpA&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;李大学退休、王亚卿失势、张晨淡出，刘强东找不到心中的理想CTO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;架构师成长路线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/EQZRy63YW58J8dDGqfHM4w&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从各个角度来解读架构师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;货拉拉全链路监控演进史&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/nrsy3uf&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一年实现降本60%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java开发中那些非常好用的工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/4clfoez&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;太顺手了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;Go1.18泛型编程体验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/fq5drnb&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go 1.18版本发布了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;低代码是什么？有什么优势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://toutiao.io/k/mh3ya24&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;编写信息安全规划的几点经验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://mp.weixin.qq.com/s/EjFZ2wr5ynzhiqttVAm8ng&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实操内容&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查看完整链接版请微信扫描下方二维码，加入「码农周刊VIP会员」。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b38fa017c9a1af130515b2a42adb2b6c</guid>
<title>[推荐] 如果你是一个Golang面试官，你会问哪些问题？</title>
<link>https://toutiao.io/k/yvw61mc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小土这两天本来想在公司发个面经，于是偶然搜到了这篇 &lt;span&gt;如果你是一个Golang面试官，你会问哪些问题？&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;,文章下面也有很多大佬的优秀回答，感兴趣的同学可以查看原文了解更多内容。下面小土主要收集了两个回答。另外小土在语雀也搜集了不少Gopher面经，&lt;span&gt;面试题库收集&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;回答 1:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者：混血王子
链接：https://www.zhihu.com/question/67846139/answer/2105444792&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有假如，我就是一个Golang面试官，来自百度。同时我到百度之前也面过头条，腾讯，小米，高德的golang，基本都过了。我回答应该还是比较有说服力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，golang的问题只占我面试问题的20%左右。问东西的顺序不一定是下面的顺序，有的时候我会根据简历选择二分法难度来问，直接问一个难度适中的问题。说上来就继续二分法筛。下面是我问过的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，make和new差别，引用类型的意义&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，逃逸分析&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，channel的实现&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，gmp与gc，重点问题（网络io等待队列，读写屏障）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，map的实现，重点问题（sync.map的实现，map实现随机的方法）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期间会根据实际情况，从这几个题发散问一些细节，但是难度不会太难了。因为我面的是p6级别的，问源码有点欺负人了。另外会问一个开发性问题，你写go遇到的坑点。从这里也可以发散问一些，但是不会问太多了。这几个问题在10分钟之内肯定要问完的。我的面试范围和我之前遇到过的面试基本都在&lt;span&gt;https://draveness.me/golang/&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 内，这个教程还是非常不错的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题不一定都要答上来，我是综合考察的，我写这几个题目也不是让大家去背这几个题的，只是想告诉大家面试的难度一般如何，顺便说几个经典题目。另外我主要关注的问题其实主要是mysql，redis，mq，算法，分布式。有人看的话，我就补充一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.7 补充mysql&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先声明一下，我说的面试题都是个人向的，其实大家要面哪家公司的时候，搜那家公司的面试题用处其实不大，因为面试官并没有说题库，或者统一标准的说法。如果我去了其他家公司当面试官我一样也会这么问（注意是提问方式和难度，题目我会换的）。而你碰到百度其他面试官，也很可能不会按我这么问。另外，因为我面的校招到10年的都有，所以具体问法也会灵活调整。说到校招，这次大校招我也被安排当面试官了，校招的朋友也可以关注一下，如果能答出来，那就惊喜级别&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;补充一下我对mysql的考察方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1，八股，为什么用b+树不用b树&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以第一题为分界线，答出来了问下面的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2，说说对mvcc的理解&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3，幻读是怎么解决的&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4，redo，undo的作用和实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5，事务的实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答不出第一题就问，下面就是纯八股了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2，索引怎么建&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3，联合索引最左前缀&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4，聚簇索引与回表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得前半部分回答得不行，就会转问后半部分的简单题。和上面一样，我问的问题和我遇见过的问题，基本都在《&lt;em&gt;MySQL技术内幕&lt;/em&gt;:InnoDB存储引擎》姜承尧老师的书里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.8 补充redis&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis的东西虽然不多，但是也是必问的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，底层数据结构实现，重点问题如：压缩列表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，aof与rdb，重点问题如：aof重写机制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，为什么用跳表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，分布式锁与redlock&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，三种分布式的结构&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，大KEY&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上说明白一半就行了，和上面一样，我问的问题和我遇见过的问题，大部分都在《Redis设计与实现》里面。因为redis的问题都不算难，如果全答上来了，我可能会问一个：在扩容rehash的时候scan扫集合，会不会扫到重复的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9.9 补充mq+es+分布式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就补一下剩下的常问问题吧，mq主要是kafka。下面基本上工作3年之内不怎么问，3年以上的说上1/3到1/2就通过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，kafka的零拷贝和顺序io 零拷贝最好说说细节，其实就是用户空间和内核空间mmap&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，kafka的分片，分片的读一致性（水位和活跃组？忘了叫什么了）和写一致性怎么保证&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，es的倒排索引，和分片的查询召回&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，分布式锁，redis redlock etcd&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，分布式事务 2pc 3pc tcc&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，分布式共识协议 raft和paxos&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7，分布式数据库 CAP BASE的概念 etcd tidb的了解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额外的问题，只有简历写了我才会问&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1，k8s的应用和架构（k8s其实我也没深入研究，随便）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2，监控prometheus，比如里面时序数据库TSDB&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3，微服务架构的内容，比如服务发现和链路追踪的工具&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4，校招的话问问tcp&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5，其他我感兴趣的东西&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6，算法题必问，一般先选一个中等偏难的，难度参见周赛第三题。要是很顺畅就加一个第四题难度（困难），做不出来就换一个第二题难度（中等偏简单）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7，架构设计，因为我只是一面，这种问题一般留给二面问。不过我给的建议是，mysql分表，redis缓存，kafka削峰这三板斧&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写在最后，其实我的标准只有一个，我的所有提问也是围绕这一标准来的，就是让我感受到你对技术的热情，对技术路线有清晰规划，并且正在进行系统性地有条理的学习持续一年以上，比如看书，事实上我也是这么要求自己的。我相信满足了这个条件，你面其他公司也很容易。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;回答2:&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者：HelloKaton
链接：https://www.zhihu.com/question/67846139/answer/257359743&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章翻译自一位外国友人的关于面试后端程序员的文章，我比较喜爱这篇文章。一是因为它极大的拓宽了我的视角，另一方面是其中的一些问题非常具有启发性。不仅对于面试者，对于面试官来说也是个不错的参考。于是迫不及待的翻译了一下，给各位看官做个参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原文参见 &lt;span&gt;@arialdomartini&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;的: &lt;span&gt;Back-End Developer Interview Questions&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是原文翻译。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开放式问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计模式相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码设计相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语言相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非关系型数据库相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码版本管理相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式系统相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件生命周期和团队管理相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑和算法相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件架构相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向服务架构(SOA)和微服务(Microservice)相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全相关问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比尔盖茨式问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码示例问题&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通用问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语言设计中空引用(&lt;span&gt;null reference&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么函数式编程重要？什么时候适用函数式语言？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计(design)、架构(architecture)、功能(functionality)和美学(aesthetic)之间有什么区别？讨论一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微软、谷歌、欧朋(opera)和火狐这类公司是如何从他们的浏览器中获利的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么打开TCP套接字有很大的开销？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;封装的重要性体现在哪儿？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是实时系统？它与普通系统有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时语言(real-time language)和堆内存分配(heap memory allocation)之间的关系是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不变性(Immutability)是指: (变量的)值只能在创建的时候被设置一次，之后就不能被改变。为什么不变性对写更加安全的代码有帮助？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可变值(mutable values)和不可变值(immutable values)有哪些优缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是O/R阻抗失衡(Object-Relational impedence mismatch)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你需要使用缓存，你使用哪些原则来确定缓存的大小？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCP和HTTP有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在客户端渲染(client-side rendering)和服务端渲染(server-side rendering)之间，你是如何权衡的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何在一个不可靠的协议之上构建一个可靠的通信协议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开放式问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么人们会抵制变化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何向你的祖母解释什么是线程？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为一个软件工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是好的代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释什么是流(Streaming)和如何实现一个流？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你的公司给你一周的时间，用来改善你和同事的生活: 你将如何使用这一周？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本周你学了什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所有的设计中都会有美学元素(aesthetic element)的存在。问题是，你认为美学元素是你的朋友还是敌人？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;列出最近你读过的5本书。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设目前有个大型公司（非常有钱），他们的开发流程是瀑布式流程（Waterfall），如果需要你在他们公司引入持续交付（&lt;span&gt;Continue Devivery&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;），你会怎么做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们来谈谈&quot;&lt;em&gt;重复造轮子&lt;/em&gt;&quot;,&quot;&lt;em&gt;非我发明症&lt;/em&gt;&quot;, &quot;&lt;em&gt;吃自己做出来的狗粮&lt;/em&gt;&quot;的这些做法吧。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(注: 重复造轮子: Reinventing the wheel; 非我发明症:Not Invented Here Syndrome; 吃自己做出来的狗粮: Eating Your Own Dog Food)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在你当前的工作流中，什么事情是你计划下一步需要自动化的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么写软件是困难的？是什么使软件的维护变得困难？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你更喜欢在全新项目（Green Field Project）上工作还是在已有项目(Brown Field Project)基础上工作？为什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当你在浏览器地址栏输入google.com回车之后都发生了什么?&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当操作系统CPU处于空闲的时候，它可能在处理哪些事情？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何向一个5岁的孩子解释什么是Unicode/数据库事务？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何维护单体架构(monolithic architecture)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个&quot;专业的开发者&quot;意味着什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软件开发是艺术、是技艺还是工程？你的观点是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;喜欢这个的人也喜欢...&quot;，如何在一个电子商务商店里实现这种功能？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么在创新上，企业会比创业公司慢些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么说，你不应该尝试应用自己发明或者设计的密码学？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计模式相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;请用一个例子表明，全局对象是邪恶的存在。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你工作的系统不支持事务性，你会如何从头开始实现它？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是好莱坞原则（Hollywood Principles）？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于迪米特法则(最少知识原则): 写一段代码违反它, 然后修复它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（注: 迪米特法则：the Law of Demeter, 最少知识原则：the Principle of Least Knowledge）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Active-Record模式有什么限制和缺陷？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Data-Mapper模式和Active-Record模式有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空对象模式(Null Object Pattern)的目的是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么组合(Composition)比继承(Inheritance)更好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是反腐败层(Anti-corruption Layer)?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你可以写一个线程安全的单例(Singleton)类吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据抽象(Data Abstraction)能力是指能改变实现而不影响客户端的这种能力。请构造一个一个例子，违反这个特性，并且尝试修复它。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何处理依赖关系地狱(Dependency Hell)的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么说goto语句是恶魔般的存在？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;健壮性是进行软件设计时的一个通用原则，它建议 &lt;em&gt;“发送时要保守，接收时要开放”&lt;/em&gt;。这也经常被写成，“做一个有耐心的读者，做一个谨慎的作者”。你能解释一些这背后的逻辑吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;译者注：&quot;发送时要保守，接收时要开发&quot;的原文是：&quot;Be conservative in what you send, be liberal in what you accept&quot;，有点类似于“严于律己，宽于待人”的意味。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码设计相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你在进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内聚和耦合的区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构在哪些场景下有用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码中的注释有用吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计和架构有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么在测试驱动开发(TDD)中是先写测试，再写代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C++支持多继承，Java允许类实现多个接口。这些特性对正交性有什么影响？使用多继承和使用多接口有区别吗？[这个问题来自Andrew .Hunt 和 David Thomas写的《程序员修炼之道》]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在存储过程（Stored Procedures）中写业务逻辑有什么优缺点？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语言相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;告诉我你的首选语言的三个最坏的缺陷。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么现在函数式编程这么越来越受关注？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;闭包是什么？它有什么用途？闭包和类有什么共同点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;泛型有什么用途？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是高阶函数？有什么用途？用你的首选语言写个例子出来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;讨论一下，如何写一个循环，然后把它转换成递归函数，要避免易变性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些语言将函数视为第一公民，这是什么意思？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用一个例子说明匿名函数是有用的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是动态方法调度(Dynamic Method Dispatch)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;名字空间(Namespace)有什么用？有什么可以替代它的吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;谈谈Java和C#之间的互操作性(Interoperability) (任选其他两门语言都行)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么很多软件工程师不喜欢Java？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你认为好的语言好在哪里？差的语言差在哪里？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写两个函数，一个是&quot;引用透明的(Referentially Transparent)&quot;，另一个是&quot;引用不透明的(Referentially Opaque)&quot;。讨论之。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是栈？什么是堆？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么一个语言中，&quot;函数是第一公民&quot;是很重要的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模式匹配(Pattern Matching)和Switch语句(Switch clauses)的区别在哪儿？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么有些语言设计上没有异常机制？这有什么优缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;Cat&lt;/code&gt;是一个&lt;code&gt;Animal&lt;/code&gt;, 那么&lt;code&gt;TaskCare&amp;lt;Cat&amp;gt;&lt;/code&gt;是一个&lt;code&gt;TakeCare&amp;lt;Animal&amp;gt;&lt;/code&gt;吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;web相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么&quot;第一方cookie(first-party cookie)&quot;和&quot;第三方cookie(third-party cookie)&quot;被如此不同的对待？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果要你将一个项目从MySQL迁移至PostgreSQL中，你会如何迁移？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么&lt;code&gt;SELECT * FROM table WHERE field = null&lt;/code&gt;不能匹配空的字段？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是ACID(原子性，一致性，隔离性，持久性)原则？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何进行数据库模式(Database schema)迁移的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟加载(lazy loading)是如何实现的？什么场景下有用？他有什么缺陷？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是N+1问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何找出应用中开销最大的查询？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非关系型数据库相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是最终一致性(Eventual Consistency)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于CAP理论，举一些CP、AP、CA系统的例子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NoSQL是如何解决可伸缩性的挑战的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么情况下你会使用类似于MongoDB的文档数据库而不是关系型数据库（如Mysql或者PostgreSQL）？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码版本管理相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么在Mercurial或者git中(管理)分支比SVN容易？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分散式版本控制系统（比如git），相比集中式版本控制系统（如svn）有哪些优势和劣势？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(注:集中式版本控制系统: Centralized Version Control Systems；分散式版本控制系统: Distributed Version Control Systems)&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;能描述一下什么是GitHubFlow和GitFlow工作流吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是rebase？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么合并操作(merge)在Mercurial和git中比在SVN和CVS中容易？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;并发问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为什么我们需要并发呢？解释一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么测试多线程/并发代码这么困难？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是竞争条件（Race Condition）？用任何一个语言写一个例子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是死锁？用代码解释一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是饿死？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是Wait-Free算法？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式系统相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;怎么测试一个分布式系统？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么场景下你会在两个系统中采用异步通信机制？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远程过程调用的通用缺点是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你为了可扩展性和鲁棒性而构建一个分布式的系统，分别在封闭安全的网络环境情况下，和地理上的位置不同但是网络环境不是封闭和安全的情况下，你会考虑什么不同的事情？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在Web应用中如何管理容错性？在桌面端呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在分布式系统中，如何处理故障？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;让我们来谈谈网络分裂(network partitions)后有的几种恢复的手段吧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你认为分布式计算中有哪些谬论？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你在什么时候会使用Request/Response模式，什么时候使用Publish/Subscribe模式？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件生命周期和团队管理相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是敏捷（Agility）？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是如何处理遗留代码（Legacy Code）的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设我是你们公司的CEO，请向我解释什么是看板，并且说服我在它上面投资。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;敏捷（Agility）和瀑布（Waterfall）之间的最大区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为团队管理者，你对会议太多这个问题是如何处理的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你会如何处理延期很长时间了的项目？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;&lt;em&gt;个体与交互重于过程和工具&lt;/em&gt;&quot;和&quot;&lt;em&gt;客户协作重于合同谈判&lt;/em&gt;&quot;占了敏捷宣言（Agile Manifesto）的一半，谈论一下这两个观念。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你是你们公司的CTO，你会采取什么样的决策？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你觉得项目经理有用吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果要你组织一个弹性工作制的开发团队（即没有强制工作时间的要求），并且假期制度是&quot;按需休假&quot;，你会如何做？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你会如何管理一个人员流动非常高的团队？如何在不加薪的条件下说服团队成员不要离开？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除了代码之外，你最关注你的同事的哪3项素质？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于代码，你最希望非技术人员能知道的的三件事是什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑和算法相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;只用LIFO栈如何构造一个FIFO队列？只用FIFO队列如何构造一个LIFO栈？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一段有栈溢出的代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个尾递归版本的阶乘函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用任何一个语言，写一个REPL，功能是echo你输入的字符串。然后将它演化成一个逆波兰表达式的计算器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果需要你设计一个文件系统磁盘碎片整理程序，你会如何设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个生成随机迷宫的程序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一段有内存泄漏的示例代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随机生成一个的数字序列，里面每个数字都不同。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个简单的垃圾回收系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用任何一门语言，写一个基本的消息代理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写一个基础的web服务器，然后画一张线路图，展示你将来还想要实现的功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何对一个10GB的文件进行排序？如果是10TB的数据，你会采用什么方法？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请实现&lt;code&gt;rnd()&lt;/code&gt;函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;软件架构相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么情况下缓存是没用的，甚至是危险的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么事件驱动的架构能提高可扩展性(scalability)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么样的代码是可读性强的代码？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;紧急设计(Emergent Design)和演化架构(Evolutionary Architecture)之间的区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;横向扩展(scale out) vs 纵向扩展(scale up): 有什么区别？分别在什么场景下使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式系统中如何处理&quot;故障切换(failover)&quot;和&quot;用户会话(user session)&quot;？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是CQRS(Command Query Responsibility Segregation)?他和最早的Command-Query Separation原则有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是三层架构？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何设计一个可扩展性高的系统？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理C10k问题的策略有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果让你来设计一个去中心化的P2P系统，你会如何设计？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么CGI的扩展性不好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在设计系统时，你如何防止供应商依赖(&lt;span&gt;Vendor Lock-in&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在可扩展性上，发布/订阅(Publish-Subscribe)模式有什么缺点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;80年代以后，CPU有哪些变化？这些变化，对编程产生了什么影响？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能生命周期(performace lifecycle)中，你认为哪个部分是需要考虑进去的？如何管理？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;除了恶意攻击造成的拒绝服务现象以外，哪些设计或者架构上的问题会导致拒绝服务？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;性能和可扩展性之间有什么关系？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么时候紧耦合是OK的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个系统要有什么特征才能适配云计算环境(Cloud Ready)？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Does unity of design imply an aristocracy of architects?&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;面向服务架构(SOA)和微服务(Microservice)相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在SOA中，为什么长期存活的事务(Long-lived transation)不被看好，而Saga却被看好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SOA和MicroService之间有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们来谈谈Web服务的版本管理、版本兼容性、重大变更管理这些事情吧.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在saga中事务和补偿操作(compensation operation)之间的区别是什么？在SOA中呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务不能做得太&quot;微&quot;，你认为什么时候微服务太&quot;微&quot;了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MicroService架构的优劣是什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安全相关问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是双因素认证(Two Factor Authentication)？在一个已有的Web应用中，你如何实现这种机制？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;比尔盖茨式问题:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果你把一面镜子放在扫描仪上，会发生什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设有一个和你完全一样的克隆人，而他是你的上司，你愿意和他工作吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;现在请你面试一下我。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么Quora上的回答会比Yahoo Answer上的回答好？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对手是现代语言，你的任务是要为Cobol辩护，你会如何进行？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;10年后的你是什么样子？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设你是我老板，我被解雇了。你会如何通知我？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我想要重构一个系统，而你想要从头重写。我们来争论一下该怎么弄吧。然后我们反转角色，再争论一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老板要你对公司撒谎，你的反应是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你可以穿越到以前，你会给年轻时候的你什么建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码示例问题:&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;function &lt;span&gt;hookupevents&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; i++) {&lt;br/&gt;    document.getElementById(&lt;span&gt;&quot;button&quot;&lt;/span&gt; + i)&lt;br/&gt;      .addEventListener(&lt;span&gt;&quot;click&quot;&lt;/span&gt;, function() { &lt;br/&gt;        alert(i); &lt;br/&gt;      });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;关于类型擦除(Type Erasure)，这段Java代码的输出是什么？为什么？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ArrayList&amp;lt;Integer&amp;gt; li = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;ArrayList&amp;lt;Float&amp;gt; lf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Float&amp;gt;();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (li.getClass() == lf.getClass()) &lt;span&gt;// evaluates to true&lt;/span&gt;&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;Equal&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stack&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Object[] elements;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Stack&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        elements = &lt;span&gt;new&lt;/span&gt; Object[DEFAULT_INITIAL_CAPACITY];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;push&lt;/span&gt;&lt;span&gt;(Object e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ensureCapacity();&lt;br/&gt;        elements[size++] = e;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (size == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EmptyStackException();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; elements[--size];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Ensure space for at least one more element, roughly&lt;br/&gt;     * doubling the capacity each time the array needs to grow.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (elements.length == size)&lt;br/&gt;            elements = Arrays.copyOf(elements, &lt;span&gt;2&lt;/span&gt; * size + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;if&lt;/code&gt;语句，或者更加通用点，条件表达式通常是过程式编程/命令式编程的形式。你能去掉这段代码中的&lt;code&gt;switch&lt;/code&gt;语句，用面向对象的方式来修改这段代码吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Formatter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Service service;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Formatter&lt;/span&gt;&lt;span&gt;(Service service)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.service = service;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;doTheJob&lt;/span&gt;&lt;span&gt;(String theInput)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String response = service.askForPermission();&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (response) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;FAIL&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;error&quot;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;OK&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; String.format(&lt;span&gt;&quot;%s%s&quot;&lt;/span&gt;, theInput, theInput);&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TheService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FileHandler fileHandler;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FooRepository fooRepository;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;TheService&lt;/span&gt;&lt;span&gt;(FileHandler fileHandler, FooRepository fooRepository)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.fileHandler = fileHandler;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.fooRepository = fooRepository;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;Execute&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String file)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; String rewrittenUrl = fileHandler.getXmlFileFromFileName(file);&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; String executionId = fileHandler.getExecutionIdFromFileName(file);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((executionId == &lt;span&gt;&quot;&quot;&lt;/span&gt;) || (rewrittenUrl == &lt;span&gt;&quot;&quot;&lt;/span&gt;)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Foo knownFoo = fooRepository.getFooByXmlFileName(rewrittenUrl);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (knownFoo == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; knownFoo.DoThat(file);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    HRESULT error = S_OK;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation1()))&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation2()))&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation3()))&lt;br/&gt;            {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(SUCCEEDED(Operation4()))&lt;br/&gt;                {&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                {&lt;br/&gt;                    error = OPERATION4FAILED;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            {&lt;br/&gt;                error = OPERATION3FAILED;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            error = OPERATION2FAILED;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        error = OPERATION1FAILED;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; error;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是一个Golang面试官，你会问哪些问题？欢迎留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;如果你是一个Golang面试官，你会问哪些问题？: &lt;span&gt;https://www.zhihu.com/question/67846139&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;面试题库收集: &lt;span&gt;https://www.yuque.com/go-interview/set/interview-index&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;https://draveness.me/golang/: &lt;span&gt;https://link.zhihu.com/?target=https%3A//draveness.me/golang/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;@arialdomartini: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/arialdomartini&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Back-End Developer Interview Questions: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/arialdomartini/Back-End-Developer-Interview-Questions&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;null reference: &lt;span&gt;https://link.zhihu.com/?target=http%3A//programmers.stackexchange.com/questions/12777/are-null-references-really-a-bad-thing&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Continue Devivery: &lt;span&gt;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Continuous_delivery&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;当你在浏览器地址栏输入google.com回车之后都发生了什么?: &lt;span&gt;https://link.zhihu.com/?target=https%3A//github.com/alex/what-happens-when&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Vendor Lock-in: &lt;span&gt;https://link.zhihu.com/?target=https%3A//sourcemaking.com/antipatterns/vendor-lock-in&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef837d0286ce7a1866ce8c839df10d49</guid>
<title>[推荐] 你管这破玩意儿叫高可用</title>
<link>https://toutiao.io/k/qudsbeg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;今天我们来聊一下互联网三高（高并发、高性能、高可用）中的高可用，看完本文相信能解开你关于高可用设计的大部分困惑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用（High availability，即 HA）的主要目的是为了保障「业务的连续性」，即在用户眼里，业务永远是正常（或者说基本正常）对外提供服务的。高可用主要是针对架构而言，那么要做好高可用，就要首先设计好架构，第一步我们一般会采用分层的思想将一个庞大的 IT 系统拆分成为应用层，中间件，数据存储层等独立的层，每一层再拆分成为更细粒度的组件，第二步就是让每个组件对外提供服务，毕竟每个组件都不是孤立存在的，都需要互相协作，对外提供服务才有意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要保证架构的高可用，就要保证架构中所有组件以及其对外暴露服务都要做高可用设计，任何一个组件或其服务没做高可用，都意味着系统存在风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这么多组件该怎么做高可用设计呢，其实任何组件要做高可用，都离不开「冗余」和「自动故障转移」，众所周知单点是高可用的大敌，所以组件一般是以集群（至少两台机器）的形式存在的，这样只要某台机器出现问题，集群中的其他机器就可以随时顶替，这就是「冗余」。简单计算一下，假设一台机器的可用性为 90%，则两台机器组成的集群可用性为 1-0.1*0.1 = 99%，所以显然冗余的机器越多，可用性越高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但光有冗余还不够，如果机器出现问题，需要人工切换的话也是费时费力，而且容易出错，所以我们还需要借助第三方工具（即仲裁者）的力量来实现「自动」的故障转移，以达到实现&lt;/span&gt;&lt;span&gt;近实时&lt;/span&gt;&lt;span&gt;的故障转移的目的，&lt;/span&gt;&lt;span&gt;近实时的故障转移才是高可用的主要意义&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎样的系统可以称之为高可用呢，业界一般用几个“九”来衡量系统的可用性，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6686103012633625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxECjvy7L8AZicH8XP4AbRqRxpFgsx4rKKOTOmCL4lL9I6QzGdh2yvZgeN7kX6qd3px0MLvjibfGauA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般实现两个 9 很简单，毕竟每天宕机 14 分钟已经严重影响业务了，这样的公司迟早歇菜，大厂一般要求 4 个 9，其他要求严苛的业务要达到五个九以上，比如如果因为一个电脑的故障导致所有列车停驶，那么就会有数以万计的人正常生活受到阻碍，这种情况就要求五个九以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们就来一起看看架构中的各个组件如何借助「冗余」和「自动故障转移」来实现高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 互联网架构剖析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前多数互联网都会采用微服务架构，常见架构如下:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9707792207792207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFF2y5qicTib6bSVPvebnjeAzMMqAWTWB2r5Bx5Vwz2THY50RIic1nBMmgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;924&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到架构主要分以下几层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;接入层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要由 F5 硬件或 LVS 软件来承载所有的流量入口；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;反向代理层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Nginx，主要负责根据 URL 来分发流量，限流等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;网关&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要负责流控、风控、协议转换等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;站点层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要负责调用会员，促销等基本服务来装配 JSON 等数据并返回给客户端；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基础 service&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：其实与站点层都属于微服务，是平级关系，只不过基础 service 属于基础设施，能被上层的各个业务层 server 调用而已；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;存储层&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也就是 DB，如 MySQL、Oracle 等，一般由基础 service 调用返回给站点层；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;中间件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：ZK、ES、Redis、MQ 等，主要起到加速访问数据等功能，在下文中我们会简单介绍下各个组件的作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如前所述，要实现整体架构的高可用，必须要实现每一层组件的高可用，接下来我们就来分别看一下每一层的组件都是如何实现高可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 接入层 &amp;amp; 反向代理层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两层的高可用都和 keepalived 有关，所以我们结合起来一起看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0052447552447552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFVgylNIdGrhDkSF8FibpNr6eoUGjEibuCFm4bmcz5ibszdZ6XefKTwG9LA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对外，两个 LVS 以主备的形式对外提供服务，注意只有 master 在工作（即此时的 VIP 在 master 上生效），另外一个 backup 在 master 宕机之后会接管 master 的工作，那么 backup 怎么知道 master 是否正常呢？答案是通过 keepalived，在主备机器上都装上 keepalived 软件，启动后就会通过心跳检测彼此的健康状况，一旦  master 宕机，keepalived 会检测到，从而 backup 自动转成 master 对外提供服务，此时 VIP 地址（即图中的 115.204.94.139）即在 backup 上生效，也就是我们常说的「IP漂移」，通过这样的方式即解决了 LVS 的高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;keepalived 的心跳检测主要通过发送 ICMP 报文，或者利用 TCP 的端口连接和扫描检测来检测的，同样的，它也可以用来检测 Nginx 暴露的端口，这样的话如果某些 Nginx 不正常 Keepalived 也能检测到并将其从 LVS 能转发的服务列表中剔出。Nginx也能通过端口检测服务健康状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借用 keepalived 这个第三方工具，同时实现了 LVS 和 Nginx 的高可用，同时在出现故障时也可以将宕机情况发送到对应开发人员的邮箱以让他们及时收到通知处理，确实很方便，Keepalived 应用广泛，下文我们会看到它也可以用在 MySQL 上来实现 MySQL 的高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 微服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看一下「网关」、「站点层」、「基础服务层」，这三者一般就是我们所说的微服务架构组件。当然这些微服务组件还需要通过一些 RPC 框架如 Dubbo 来支撑才能通信，所以微服务要实现高可用，就意味着 Dubbo 这些 RPC 框架也要提供支撑微服务高可用的能力，我们就以 Dubbo 为例来看下它是如何实现高可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来简单地看下 Dubbo 的基本架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7773584905660378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFvmiaryD4ebUrFo6Be22J24afz1w72oyUlyOemjYH7ZBccsV5RpcyCMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;思路也很简单，首先是 Provider（服务提供者）向 Registry（注册中心，如 ZK 或 Nacos 等）注册服务，然后 Consumer（服务消费者）向注册中心订阅和拉取 Provider 服务列表，获取服务列表后，Consumer 就可以根据其负载均衡策略选择其中一个  Provider 来向其发出请求，当其中某个 Provider 不可用（下线或者因为 GC 阻塞等）时，会被注册中心及时监听（通过心跳机制）到，也会及时推送给 Consumer，这样 Consumer 就能将其从可用的 Provider 列表中剔除，也就实现了故障的自动转移，不难看出，注册中心就起到了类似 keepalived 的作用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 中间件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们再来看下这些中间件如 ZK、Redis 等是如何实现高可用的呢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1 ZooKeeper（ZK）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4/&gt;&lt;h4/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上一节微服务中我们提到了注册中心，那我们就以 ZK 为例来看看它的高可用是如何实现的，先来看下它的整体架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF48MtucWD8DPMCz0mfjqytSlSvljubib3ia1xIR6La51orJIssR1ISmZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Zookeeper 中的主要角色如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即领导者，在集群中只有一个 Leader，主要承担了以下的功能：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事务请求的唯一调度和处理者，保证集群事务处理的顺序性，所有 Follower 的写请求都会转给 Leader 执行，用来保证事务的一致性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集群内部各服务器的调度者：处理好事务请求后，会将数据广播同步到各个 Follower，统计 Follower 写入成功的数量，超过半数 Follower 写入成功，Leader 就会认为写请求提交成功，通知所有的 Follower commit 这个写操作，保证事后哪怕是集群崩溃恢复或者重启，这个写操作也不会丢失。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;处理客户端非事务请求、转发事务请求给 leader 服务器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参与事物请求 Proposal 的投票（需要半数以上服务器通过才能通知 leader commit 数据; Leader 发起的提案，要求 Follower 投票）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参与 Leader 选举的投票。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;画外音：Zookeeper 3.0 之后新增了一种 Observer 的角色，不过与此处讨论的 ZK 高可用关系不是很大，为了简化问题，所以省略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到由于只有一个 Leader，很显然，此 Leader 存在单点隐患，那么 ZK 是怎么解决此问题的呢，首先 Follower 与 Leader 会用心跳机制保持连接，如果 Leader 出现问题了（宕机或者因为 FullGC 等原因无法响应），Follower 就无法感知到 Leader 的心跳，就会认为 Leader 出问题了，于是它们就会发起投票选举，最终在多个 Follower 中选出一个 Leader 来（这里主要用到了 Zookeeper Atomic Broadcast，即 ZAB 协议，它是为 ZK 专门设计的一种支持崩溃恢复的一致性协议），选举的细节不是本文重点，就不在此详述了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了 ZAB 协议，业界上常用的还有 Paxos，Raft 等协议算法，也可以用在 Leader 选举上，也就是是在分布式架构中，这些协议算法承担了“第三者”也就是仲裁者的作用，以承担故障的自动转移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 Redis&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 的高可用需要根据它的部署模式来看看，主要分为「主从模式」和「Cluster 分片模式」两种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;主从模式&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来看一下主从模式，架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0134529147982063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFFWlG0mOU7CGJ7PocwSNywKzyqLicoR0dPFSGYSZxeyqpyz4vBib9j39g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;446&quot; title=&quot;主从模式&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;主从模式&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;主从模式即一主多从（一个或者多个从节点），其中主节点主要负责读和写，然后会将数据同步到多个从节点上，Client 也可以对多个从节点发起读请求，这样可以减轻主节点的压力，但和 ZK 一样，由于只有一个主节点，存在单点隐患，所以必须引入第三方仲裁者的机制来判定主节点是否宕机以及在判定主节点宕机后快速选出某个从节点来充当主节点的角色，这个第三方仲裁者在 Redis 中我们一般称其为「哨兵」（sentinel），当然哨兵进程本身也有可能挂掉，所以为了安全起见，需要部署多个哨兵（即哨兵集群）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4821428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFjCMq4hjcVibRr7ODrhBwMJG1wfAJOaO3F5VGpJ9GyEAgTWhM1yPyEAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;504&quot; title=&quot;哨兵集群&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;哨兵集群&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些哨兵通过 Gossip（流言） 协议来接收关于主服务器是否下线的信息，并在判定主节点宕机后使用 Raft 协议来选举出新的主节点。&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;Cluster 分片集群&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从模式看似完美，但存在以下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主节点写的压力难以降低：因为只有一个主节点能接收写请求，如果在高并发的情况下，写请求如果很高的话可能会把主节点的网卡打满，造成主节点对外无法服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主节点的存储能力受到单机存储容量的限制：因为不管是主节点还是从节点，存储的都是全量缓存数据，那么随着业务量的增长，缓存数据很可能直线上升，直到达到存储瓶颈；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步风暴：因为数据都是从 master 同步到 slave 的，如果有多个从节点的话，master 节点的压力会很大。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决主从模式的以上问题，分片集群应运而生，所谓分片集群即将数据分片，每一个分片数据由相应的主节点负责读写，这样的话就有多个主节点来分担写的压力，并且每个节点只存储部分数据，也就解决了单机存储瓶颈的问题，但需要注意的是每个主节点都存在单点问题，所以需要针对每个主节点做高可用，整体架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.731457800511509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF14icPLDKtw0iagY9sFicsZrFDibZESUInZXgbAq2J6iaaAtF7z6EEWiaoIOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原理也很简单，在 Proxy 收到 client 执行的 redis 的读写命令后，首先会对 key 进行计算得出一个值，如果这个值落在相应 master 负责的数值范围（一般将每个数字称为槽，Redis 一共有 16384 个槽）之内，那就把这条 redis 命令发给对应的 master 去执行，可以看到每个 master 节点只负责处理一部分的 redis 数据，同时为了避免每个 master 的单点问题，也为其配备了多个从节点以组成集群，当主节点宕机时，集群会通过 Raft 算法来从从节点中选举出一个主节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3 Elasticsearch（ES）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来看一下 ES 是如何实现高可用的，在 ES 中，数据是以分片（Shard）的形式存在的。如下图所示，一个节点中索引数据共分为三个分片存储：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4613259668508287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFicqfXTgHCVicUOE5iaLX0J1ogI140QfpkaQGCRAW6U52VNXeq3gj4DPtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;362&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但只有一个节点的话，显然存在和 Redis 的主从架构一样的单点问题，这个节点挂了，ES 也就挂了，所以显然需要创建多个节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46344086021505376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFYLmibg8rMgib2wCwcTicmiaoElKcI3ZnR5UrkHTxaOAFAjg4OAmfQ7h20g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;930&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦创建了多个节点，分片（图中 P 为主分片，R 为副本分片）的优势就体现出来了，可以将分片数据分布式存储到其它节点上，极大提升了数据的水平扩展能力，同时每个节点都能承担读写请求，采用负载均衡的形式避免了单点的读写压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ES 的写机制与 Redis 和 MySQL 的主从架构有些差别（后两者的写都是直接向 master 节点发起写请求，而 ES 则不是），所以这里稍微解释一下 ES 的工作原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先说下节点的工作机制，节点（Node）分为主节点（Master Node）和从结点（Slave Node），主节点的主要职责是负责集群层面的相关操作，管理集群变更，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点，主节点也只有一个，一般通过类 Bully 算法来选举出来，如果主节点不可用了，则其他从节点也可以通过此算法来选举以实现集群的高可用，任何节点都可以接收读写请求以达到负载均衡的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再说一下分片的工作原理，分片分为主分片（Primary Shard，即图中 P0，P1，P2）和副本分片（Replica Shard，即图中 R0，R1，R2），主分片负责数据的写操作，所以虽然任何节点可以接收读写请求，但如果此节点接收的是写请求并且没有写数据所在的主分片话，此节点会将写请求调度到主分片所在的节点上，写入主分片后，主分片再把数据复制到其他节点的副本分片上，以有两个副本的集群为例，写操作如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3515704154002026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF693SL8F4eVU8zOQjwcndJIKL38DBIp1ThXwpnDZjSicvibq8N8N0zEcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;987&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.4 Message Queue（MQ）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ES 利用数据分片来提升高可用和水平扩展能力的思想也应用在其他组件的架构设计上，我们以 MQ 中的 Kafka 为例再来看下数据分片的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6520833333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF5QticRNDibRbvK5yY68X5bXiaUKboEibtbFBfVHhPBoUXg5K3B17WXkGyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; title=&quot;Kafka 高可用设计，图片来自《武哥漫谈IT》&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;Kafka 高可用设计，图片来自《武哥漫谈IT》&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如上是 Kafka 集群，可以看到每个 Topic 的 Partition 都分布式存储在其它消息服务器上，这样一旦某个 Partition 不可用，可以从 follower 中选举出 leader 继续服务，不过与 ES 中的数据分片不同的是，follower Partition 属于冷备，也就是说在正常情况下不会对外服务，只有在 leader 挂掉之后从 follower 中选举出 leader 后它才能对外提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 存储层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看一下最后一层，存储层（DB），这里我们以 MySQL 为例来简单地讨论一下其高可用设计，其实大家如果看完了以上的高可用设计，会发现 MySQL 的高可用也不过如此，思想都是类似的，与 Redis 类似，它也分主从和分片（即我们常说的分库分表）两种架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从的话与 LVS 类似，一般使用 keepalived 的形式来实现高可用，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.647766323024055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFgHR6pzBAx1fEzzgiaaax5JBlcWFXOz4uiaNBBBGlX2YYzGngfYOCpKBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;582&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 master 宕机了，Keepalived 也会及时发现，于是从库会升级主库，并且 VIP 也会“漂移”到原从库上生效，所以说大家在工程配置的 MySQL 地址一般是 VIP 以保证高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据量大了之后就要分库分表了，于是就有了多主，就像 Redis 的分片集群一样，需要针对每个主配备多个从，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5478170478170478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFmmhvFuzrI226JU1zyEKGwOdvecu8iaLXLVw2Cko1p5ppByw4Hd8k8tw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前有读者问分库分表之后为啥还要做主从，现在我想大家应该都明白了，不是为了解决读写性能问题，主要是为了实现高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完了架构层面的高可用设计，相信大家对高可用的核心思想「冗余」和「自动故障转移」会有更深刻的体会，观察以上架构中的组件你会发现冗余的主要原因是因为只有一主，为什么不能有多主呢，也不是不可以，但这样在分布式系统下要保证数据的一致性是非常困难的，尤其是节点多了的话，数据之间的同步更是一大难题，所以多数组件采用一主的形式，然后再在主和多从之间同步，多数组件之所以选择一主本质上是技术上的 tradeoff。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么做好每个组件的高可用之后是否整个架构就真的可用了呢，非也，这只能说迈出了第一步，在生产上还有很多突发情况会让我们的系统面临挑战，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;瞬时流量问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如我们可能会面临秒杀带来的瞬时流量激增导致系统的承载能力被压垮，这种情况可能影响日常交易等核心链路，所以需要做到系统之间的隔离，如单独为秒杀部署一套独立的集群；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;安全问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如 DDOS 攻击，爬虫频繁请求甚至删库跑路等导致系统拒绝服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如代码 bug 引起内存泄露导致 FullGC 导致系统无法响应等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;部署问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在发布过程中如果贸然中止当前正在运行的服务也是不行的，需要做到优雅停机，平滑发布；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三方问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：比如我们之前的服务依赖第三方系统，第三方可能出问题导致影响我们的核心业务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;不可抗力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如机房断电，所以需要做好容灾，异地多活，之前我司业务就由于机房故障导致服务四小时不可用，损失惨重。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以除了做好架构的高可用之外，我们还需要在做好系统隔离，限流，熔断，风控，降级，对关键操作限制操作人权限等措施以保证系统的可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里特别提一下降级，这是为了保证系统可用性采取的常用的措施，简单举几个例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们之前对接过一个第三方资金方由于自身原因借款功能出了问题导致无法借款。这种情况为了避免引起用户恐慌，于是我们在用户申请第三方借款的时候返回了一个类似「为了提升你的额度，资金方正在系统升级」这样的文案，避免了客诉；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在流媒体领域，当用户观看直播出现严重卡顿时，很多企业的第一选择不是查 log 排查问题，而是为用户自动降码率。因为比起画质降低，卡得看不了显然会让用户更痛苦；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双十一零点高峰期，我们把用户的注册登录等非核心功能给停掉了，以保证下单等核心流程的顺利。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外我们最好能做到事前防御，在系统出问题前把它扼杀在摇篮里，所以我们需要做单元测试，做全链路压测等来发现问题，还需要针对 CPU，线程数等做好&lt;strong&gt;监控&lt;/strong&gt;，当其达到我们设定的域值时就触发告警以让我们及时发现修复问题（我司之前就碰到过一个类似的&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486188&amp;amp;idx=1&amp;amp;sn=46cc45885e42c0d5028359ba85193eca&amp;amp;chksm=bd251b938a529285c1ade09ffeac58fc88e997b02c028cd911514861e278b243efdc4e26b9e1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍生产事故复盘‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;生产事故复盘&lt;/span&gt;&lt;/a&gt;&lt;span&gt;大家可以看一下），此外在做好单元测试的前提下，依然有可能因为代码的潜在 bug 引起线上问题，所以我们需要在关键时间（比如双十一期间）封网（也就是不让发布代码）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外我们还需要在出事后能快速定位问题，快速回滚，这就需要记录每一次的发布时间，发布人等，这里的发布不仅包括工程的发布，还包括配置中心等的发布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2505733944954128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGFDZduepG2dgaBNDNkI7HVfXQ2l4WMzgHtc2Wiasgm0SHiaLdPZKWbZ4ew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3488&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;画外音：上图是我司的发布记录，可以看到有代码变更，回滚等，这样如果发现有问题的话可以一键回滚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后我们以一张图来总结一下高可用的常见手段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7684887459807074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWiadZz9DR96fy1xdNgWkIGF6n4vJibqCjicK5G405dyccnUoPVfU14fp7TtyfiaYbW89nEumuWJkAW7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651506905&amp;amp;idx=2&amp;amp;sn=be4dc72831a156ff656ca5c40e643944&amp;amp;chksm=bd25a4a68a522db0b135b5fb87ffc5b76c27aeeaf9407a3ca7beadda7b47b61e06a963556516&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站高可用架构实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;B站高可用架构实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651496233&amp;amp;idx=2&amp;amp;sn=213ecb44769419caa0121e90e12d57e7&amp;amp;chksm=bd25f3568a527a40763d094b84609e27bea2b05e42819bb0898f97907a4ebb67c5a33fc7f9ff&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka宕机后不再高可用？探究Kafka高可用实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka宕机后不再高可用？探究Kafka高可用实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651498116&amp;amp;idx=2&amp;amp;sn=dcc1fb4707cbc355679d4f1c9af91c72&amp;amp;chksm=bd25cafb8a5243ed6ffcfb07c004c1a4518d98a6c503fd457cfff099c3fa46fee3d48a870ebd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Elastic Job从单点到高可用、同城主备、同城双活&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Elastic Job从单点到高可用、同城主备、同城双活&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>003ff2ee4c82de98be46b80ee29ed3bc</guid>
<title>[推荐] 时间轮原理及其在框架中的应用</title>
<link>https://toutiao.io/k/1dwwpfd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;28&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;作者：vivo互联网服务器团队-Li Wanghong&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、时间轮简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 为什么要使用时间轮&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在平时开发中，经常会与定时任务打交道。下面举几个定时任务处理的例子。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）心跳检测&lt;/strong&gt;。在Dubbo中，需要有心跳机制来维持Consumer与Provider的长连接，默认的心跳间隔是60s。当Provider在3次心跳时间内没有收到心跳响应，会关闭连接通道。当Consumer在3次心跳时间内没有收到心跳响应，会进行重连。Provider侧和Consumer侧的心跳检测机制都是通过定时任务实现的，而且是本篇文章要分析的时间轮HashedWheelTimer处理的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）超时处理&lt;/strong&gt;。在Dubbo中发起RPC调用时，通常会配置超时时间，当消费者调用服务提供者出现超时进行一定的逻辑处理。那么怎么检测任务调用超时了呢？我们可以利用定时任务，每次创建一个Future，记录这个Future的创建时间与超时时间，后台有一个定时任务进行检测，当Future到达超时时间并且没有被处理时，就需要对这个Future执行超时逻辑处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）Redisson分布式锁续期&lt;/strong&gt;。在分布式锁处理中，通常会指定分布式锁的超时时间，同样会在finally块里释放分布式锁。但是有一个问题时，通常分布式锁的超时时间不好判断，如果设置短了业务却没执行完成就把锁释放掉了，或者超时时间设置很长，同样也会存在一些问题。Redisson提供了一种看门狗机制，通过时间轮定时给分布式锁续期，也就是延长分布式锁的超时时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到，上述几个例子都与定时任务有关，那么传统的定时任务有什么缺点呢？为什么要使用时间轮来实现？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如使用普通的定时任务处理机制来处理&lt;strong&gt;例2）&lt;/strong&gt;中的超时情况：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）简单地，可以针对每一次请求创建一个线程，然后Sleep到超时时间，之后若判断超时则进行超时逻辑处理。存在的问题是如果面临是高并发请求，针对每个请求都要去创建线程，这样太耗费资源了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2）针对方案1的不足，可以改成一个线程来处理所有的定时任务，比如这个线程可以每隔50ms扫描所有需要处理的超时任务，如果发现有超时任务，则进行处理。但是，这样也存在一个问题，可能一段时间内都没有任务达到超时时间，那么就让CPU多了很多无用的轮询遍历操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对上述方案的不足，可以采用时间轮来进行处理。下面先来简单介绍下时间轮的概念。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1.2 单层时间轮&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们先以单层时间轮为例，假设时间轮的周期是1秒，时间轮中有10个槽位，则每个槽位代表100ms。假设我们现在有3个任务，分别是任务A（220ms后执行）、B（410ms之后运行）、C（1930ms之后运行）。则这三个任务在时间轮所处的槽位如下图，可以看到任务A被放到了槽位2，任务B被放到了槽位4，任务C被放到了槽位9。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当时间轮转动到对应的槽时，就会从槽中取出任务判断是否需要执行。同时可以发现有一个剩余周期的概念，这是因为任务C的执行时间为1930ms，超过了时间轮的周期1秒，所以可以标记它的剩余周期为1，当时间轮第一次转动到它的位置时，发现它的剩余周期为1，表示还没有到要处理的时间，将剩余周期减1，时间轮继续转动，当下一次转动到C任务位置时，发现剩余周期为0，表示时间到了需要处理该定时任务了。Dubbo中采用的就是这种单层时间轮机制。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8234165067178503&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvoL7qrRAPH5Sjd5mXWGZYTdE1Dff4YUjYG60iagKEoTMl54fq1jGfc1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;521&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 多层时间轮&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;既然有单层时间轮，那么自然而然可以想到利用多层时间轮来解决上述任务执行时间超出时间轮周期的情况。下面以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;301&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5205949656750573&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvArjABxkglzibdia54ficuEN81VNEvLAu5R2EBwxFNro15bVQsBpaIicocw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、时间轮原理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面先来看一下Dubbo中的时间轮的结构，可以看到，它和时钟很像，它被划分成了一个个Bucket，每个Bucket有一个头指针和尾指针，分别指向双向链表的头节点和尾节点，双向链表中存储的就是要处理的任务。时间轮不停转动，当指向Bucket0所负责维护的双向链表时，就将它所存储的任务遍历取出来处理。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;405&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7009063444108762&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvMgiba9hibt6JoX2NGjmuAeml6DdMHzNCunDaI6QXQRg5NEJj0IYLzcrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面我们先来介绍下Dubbo中时间轮HashedWheelTimer所涉及到的一些核心概念，在讲解完这些核心概念之后，再来对时间轮的源码进行分析。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 TimerTask&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在Dubbo中，TimerTask封装了要执行的任务，它就是上图双向链表中节点所封装的任务。所有的定时任务都需要继承TimerTask接口。如下图，可以看到Dubbo中的心跳任务HeartBeatTask、注册失败重试任务FailRegisteredTask等都实现了TimerTask接口。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TimerTask&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Timeout timeout)&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;153&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.264&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvlBwPu6NhLhYN3ttTY9HJd2FRPEfrzzvsHujH2Qew9zfQlZyjPmf7JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 Timeout&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;TimerTask中run方法的入参是Timeout，Timeout与TimerTask一一对应，Timeout的唯一实现类HashedWheelTimeout中就封装了TimerTask属性，可以理解为HashedWheelTimeout就是上述双向链表的一个节点，因此它也包含两个HashedWheelTimeout类型的指针，分别指向当前节点的上一个节点和下一个节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Timeout&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;Timer &lt;span class=&quot;code-snippet__title&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;TimerTask &lt;span class=&quot;code-snippet__title&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isExpired&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;isCancelled&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout是Timeout的唯一实现，它的作用有两个：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面来看一下Timeout的实现类HashedWheelTimeout的核心字段与实现。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_INIT = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;、&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_CANCELLED = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;、&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ST_EXPIRED = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   HashedWheelTimeout里定义了三种状态，分别表示任务的初始化状态、被取消状态、已过期状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) STATE_UPDATER&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   用于更新定时任务的状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) HashedWheelTimer timer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指向时间轮对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) TimerTask task&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   实际要执行的任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指定时任务执行的时间，这个时间是在创建 HashedWheelTimeout 时指定的&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   计算公式是: currentTime(创建 HashedWheelTimeout 的时间) + delay(任务延迟时间)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             - startTime(HashedWheelTimer 的启动时间)，时间单位为纳秒&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; state = ST_INIT&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   任务初始状态&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; remainingRounds&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指当前任务剩余的时钟周期数. 时间轮所能表示的时间长度是有限的， 在任务到期时间与当前时刻&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   的时间差超过时间轮单圈能表示的时长，就出现了套圈的情况，需要该字段值表示剩余的时钟周期&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;) HashedWheelTimeout next、HashedWheelTimeout prev&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   分别对应当前定时任务在链表中的前驱节点和后继节点，这也验证了时间轮中每个槽所对应的任务链表是&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   一个双链表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;9&lt;/span&gt;) HashedWheelBucket bucket&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮中的一个槽，对应时间轮圆圈的一个个小格子，每个槽维护一个双向链表，当时间轮指针转到当前&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   槽时，就会从槽所负责的双向链表中取出任务进行处理&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了remove操作，可以从双向链表中移除当前自身节点，并将当前时间轮所维护的定时任务数量减一。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelBucket bucket = &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.bucket;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bucket != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timer.pendingTimeouts.decrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了cancel操作，可以取消时间轮中的定时任务。当定时任务被取消时，它会首先被暂存到canceledTimeouts队列中。在时间轮转动到槽进行任务处理之前和时间轮退出运行时都会调用cancel，而cancel会调用remove，从而清理该队列中被取消的定时任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; boolean cancel() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!compareAndSetState(ST_INIT, ST_CANCELLED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timer.cancelledTimeouts.add(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelTimeout提供了expire操作，当时间轮指针转动到某个槽时，会遍历该槽所维护的双向链表，判断节点的状态，如果发现任务已到期，会通过remove方法移除，然后调用expire方法执行该定时任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;expire&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!compareAndSetState(ST_INIT, ST_EXPIRED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        task.run(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 HashedWheelBucket&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前面也介绍过了，它是时间轮中的槽，它内部维护了双向链表的首尾指针。下面我们来看一下它内部的核心资源和实现。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) HashedWheelTimeout head、HashedWheelTimeout tail&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   指向该槽所维护的双向链表的首节点和尾节点&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了addTimeout方法，用于添加任务到双向链表的尾节点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;addTimeout&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(HashedWheelTimeout timeout)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;assert&lt;/span&gt; timeout.bucket == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timeout.bucket = &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (head == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        head = tail = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tail.next = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.prev = tail;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tail = timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了remove方法，用于从双向链表中删除指定节点。核心逻辑如下图所示，根据要删除的节点找到其前置节点和后置节点，然后分别调整前置节点的next指针和后置节点的prev指针。删除过程中需要考虑一些边界情况。删除之后将pendingTimeouts，也就是当前时间轮的待处理任务数减一。remove代码逻辑较简单，这边就不贴代码了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;259&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.44880546075085326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvjNKodCNcQugf5JQlFp2yQoibg2aw3SnCcsw8IkbeS9vEf7QcicFWX7Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket提供了expireTimeouts方法，当时间轮指针转动到某个槽时，通过该方法处理该槽上双向链表的定时任务，分为3种情况：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;定时任务已到期，则会通过remove方法取出，并调用其expire方法执行任务逻辑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定时任务已被取消，则通过remove方法取出直接丢弃。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;定时任务还未到期，则会将remainingRounds（剩余时钟周期）减一。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;expireTimeouts&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelTimeout timeout = head;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (timeout != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout next = timeout.next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.remainingRounds &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next = &lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.deadline &amp;lt;= deadline) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                timeout.expire();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.isCancelled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next = &lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            timeout.remainingRounds--;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout = next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HashedWheelBucket也提供了clearTimeouts方法，该方法会在时间轮停止的时候被使用，它会遍历并移除所有双向链表中的节点，并返回所有未超时和未被取消的任务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.4 Worker&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Worker实现了Runnable接口，时间轮内部通过Worker线程来处理放入时间轮中的定时任务。下面先来看一下它的核心字段和run方法逻辑。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1) &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;Timeout&lt;/span&gt;&amp;gt; unprocessedTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   当时间轮停止时，用于存放时间轮中未过期的和未被取消的任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tick&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮指针，指向时间轮中某个槽，当时间轮转动时该tick会自增&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;729&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.26171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvpuyqYmHbpeG02qJOSrNo4pp7FPsn8nw4jgpqoem0O62GIDkI5rXDPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    startTime = System.nanoTime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    startTimeInitialized.countDown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;do&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = waitForNextTick();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (deadline &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; idx = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) (tick &amp;amp; mask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            processCancelledTasks();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            HashedWheelBucket bucket = wheel[idx];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            transferTimeoutsToBuckets();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            bucket.expireTimeouts(deadline);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            tick++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (WORKER_STATE_UPDATER.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(HashedWheelTimer.&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                    == WORKER_STATE_STARTED);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (HashedWheelBucket bucket : wheel) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.clearTimeouts(unprocessedTimeouts);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (; ; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = timeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!timeout.isCancelled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            unprocessedTimeouts.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    processCancelledTasks();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面对run方法中涉及到的一些方法进行介绍：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）waitForNextTick&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;逻辑比较简单，它会判断有没有到达处理下一个槽任务的时间了，如果还没有到达则sleep一会。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）processCancelledTasks&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;遍历cancelledTimeouts，获取被取消的任务并从双向链表中移除。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processCancelledTasks&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (; ; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = cancelledTimeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.&lt;span class=&quot;code-snippet__keyword&quot;&gt;remove&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3）transferTimeoutsToBuckets&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当调用newTimeout方法时，会先将要处理的任务缓存到timeouts队列中，等时间轮指针转动时统一调用transferTimeoutsToBuckets方法处理，将任务转移到指定的槽对应的双向链表中，每次转移10万个，以免阻塞时间轮线程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;transferTimeoutsToBuckets&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;100000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelTimeout timeout = timeouts.poll();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; calculated = timeout.deadline / tickDuration;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        timeout.remainingRounds = (calculated - tick) / wheel.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; ticks = Math.max(calculated, tick);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; stopIndex = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;) (ticks &amp;amp; mask);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HashedWheelBucket bucket = wheel[stopIndex];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.addTimeout(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.5 HashedWheelTimer&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后，我们来分析时间轮HashedWheelTimer，它实现了Timer接口，提供了newTimeout方法可以向时间轮中添加定时任务，该任务会先被暂存到timeouts队列中，等时间轮转动到某个槽时，会将该timeouts队列中的任务转移到某个槽所负责的双向链表中。它还提供了stop方法用于终止时间轮，该方法会返回时间轮中未处理的任务。它也提供了isStop方法用于判断时间轮是否终止了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先来看一下HashedWheelTimer的核心字段。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) HashedWheelBucket[] wheel&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   该数组就是时间轮的环形队列，数组每个元素都是一个槽，一个槽负责维护一个双向链表，用于存储定时&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   任务。它会被在构造函数中初始化，当指定为n时，它实际上会取最靠近n的且为&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;的幂次方值。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) Queue&amp;lt;HashedWheelTimeout&amp;gt; timeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   timeouts用于缓存外部向时间轮提交的定时任务&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) Queue&amp;lt;HashedWheelTimeout&amp;gt; cancelledTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   cancelledTimeouts用于暂存被取消的定时任务，时间轮会在处理槽负责的双向链表之前，先处理这两&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   个队列中的数据。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) Worker worker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮处理定时任务的逻辑&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;) Thread workerThread&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮处理定时任务的线程&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;) AtomicLong pendingTimeouts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮剩余的待处理的定时任务数量&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tickDuration&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮每个槽所代表的时间长度&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; workerState&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   时间轮状态，可选值有init、started、shut down&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面来看一下时间轮的构造函数，用于初始化一个时间轮。首先它会对传入参数ticksPerWheel进行转换处理，返回大于该值的2的幂次方，它表示时间轮上有多少个槽，默认是512个。然后创建大小为该值的HashedWheelBucket[]数组。接着通过传入的tickDuration对时间轮的tickDuration赋值，默认是100ms。节通过threadFactory创建workerThread工作线程，该线程就是负责处理时间轮中的定时任务的线程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;HashedWheelTimer&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ThreadFactory threadFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; tickDuration, TimeUnit unit,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ticksPerWheel,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; maxPendingTimeouts&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    wheel = createWheel(ticksPerWheel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mask = wheel.length - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.tickDuration = unit.toNanos(tickDuration);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    workerThread = threadFactory.newThread(worker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.maxPendingTimeouts = maxPendingTimeouts;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; HashedWheelBucket[] &lt;span class=&quot;code-snippet__title&quot;&gt;createWheel&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ticksPerWheel&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelBucket[] wheel = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelBucket[ticksPerWheel];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; wheel.length; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        wheel[i] = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelBucket();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; wheel;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;初始化时间轮之后，就可以向其中提交定时任务了，可以通过时间轮提供的newTimeout方法来完成。首先将待处理的任务数量加1，然后启动时间轮线程，这时worker的run方法就会被系统调度运行。然后将该定时任务封装成HashedWheelTimeout加入到timeouts队列中。start之后，时间轮就开始运行起来了，直到外界调用stop方法终止退出。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Timeout &lt;span class=&quot;code-snippet__title&quot;&gt;newTimeout&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;TimerTask task, &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; delay, TimeUnit unit&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; pendingTimeoutsCount = pendingTimeouts.incrementAndGet();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; deadline = System.nanoTime() + unit.toNanos(delay) - startTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    HashedWheelTimeout timeout = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelTimeout(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, task, deadline);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timeouts.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(timeout);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; timeout;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt; (WORKER_STATE_UPDATER.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_INIT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (WORKER_STATE_UPDATER.compareAndSet(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                     WORKER_STATE_INIT, WORKER_STATE_STARTED)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                workerThread.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_STARTED:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; WORKER_STATE_SHUTDOWN:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Invalid WorkerState&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (startTime == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            startTimeInitialized.&lt;span class=&quot;code-snippet__keyword&quot;&gt;await&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException ignore) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、时间轮应用&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;到这里，Dubbo中的时间轮原理就分析完了。接下来呼应本文开头的三个例子，结合它们来分析下时间轮在Dubbo或Redisson中是如何使用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）HeartbeatTimerTask&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在Dubbo的HeaderExchangeClient类中会向时间轮中提交该心跳任务。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;startHeartBeatTask&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;URL url&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!client.canHandleIdle()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        AbstractTimerTask.ChannelProvider cp =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          () -&amp;gt; Collections.singletonList(HeaderExchangeClient.&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; heartbeat = getHeartbeat(url);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; heartbeatTick = calculateLeastDuration(heartbeat);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.heartBeatTimerTask =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HeartbeatTimerTask(cp, heartbeatTick, heartbeat);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; HashedWheelTimer IDLE_CHECK_TIMER =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                              &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; HashedWheelTimer(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; NamedThreadFactory(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dubbo-client-idleCheck&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;), &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS, TICKS_PER_WHEEL);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doTask&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long lastRead = lastRead(channel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long lastWrite = lastWrite(channel);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((lastRead != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; now() - lastRead &amp;gt; heartbeat)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            || (lastWrite != &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; now() - lastWrite &amp;gt; heartbeat)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Request req = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Request();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setVersion(Version.getProtocolVersion());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setTwoWay(&lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            req.setEvent(HEARTBEAT_EVENT);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            channel.send(req);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2）Redisson锁续期机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当获取锁成功后，Redisson会封装一个锁续期任务放入时间轮中，默认10s检查一下，用于对获取到的锁进行续期，延长持有锁的时间。如果业务机器宕机了，那么该续期的定时任务也就没法跑了，就没法续期了，那等加锁时间到了锁就自动释放了。逻辑封装在RedissonLock中的renewExpiration()方法中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;194&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3363886342804766&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt590uN0EGmkqXQFichIpeWUvd2SgvYgR98dCAEVAYibSSxpib3gIOaoMjJNpJzw1HtuB0G5Hbt2ZcGKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; void renewExpiration() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(getEntryName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ee == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void run(Timeout timeout) throws Exception {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(getEntryName());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (ent == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;Long&lt;/span&gt; threadId = ent.getFirstThreadId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (threadId == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            RFuture&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt;&amp;gt; future = renewExpirationAsync(threadId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            future.onComplete((res, e) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Can&#x27;t update lock &quot;&lt;/span&gt; + getName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; expiration&quot;&lt;/span&gt;, e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (res) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    renewExpiration();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }, internalLockLeaseTime / &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ee.setTimeout(task);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;renewExpirationAsync&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; threadId&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return 1; &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;end; &quot;&lt;/span&gt; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return 0;&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          Collections.singletonList(getName()),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                          internalLockLeaseTime, getLockName(threadId));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3）超时重试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用方式和HeartbeatTimerTask方式类似，读者可以自己动手去分析下它是在哪里被引入的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在本篇文章中，先是举了3个例子来论述为什么需要使用时间轮，使用时间轮的优点，在文末处也分别对这3个例子在Dubbo或Redisson中的使用做了介绍。接着通过画图讲解了单层时间轮与多层时间轮机制，让读者对时间轮算法有了一个简单的认识。在第二部分，依次讲解了Dubbo时间轮中涉及到的TimerTask、Timeout、HashedWheelBucket、Worker、HashedWheelTimer，分析了它们的原理与源码实现。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:117.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>602dd2835c93d4a13e54f86265982787</guid>
<title>[推荐] 2万字 + 50 张图，细说 JVM 内存分布、内存对齐、压缩指针！</title>
<link>https://toutiao.io/k/02whm5c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZdwkxf9KpduegYClib9mbvJlw6YSlyXwar1e8wLuxcWPUmRpNOU9tZwdaLPx85rf14z0uXBLsaeASw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天为大家带来一篇 2 万字的硬核技术文章。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3618421052631579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeaKYVicAZVk1VAnhiamA41gT2ojtuPGEJjia3kBwibBnsR9zTsFUWjwGWQvhAYSI5MhM59te7XE8Kadg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们将从计算机组成原理的角度详细阐述对象在JVM内存中是如何布局的，以及什么是内存对齐，如果我们头比较铁，就是不进行内存对齐会造成什么样的后果，最后引出压缩指针的原理和应用。同时我们还介绍了在高并发场景下，False Sharing产生的原因以及带来的性能影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家看完本文后，一定会收获很多，话不多说，下面我们正式开始本文的内容~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2274193548387098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ricXgeszzmZ697l6f7qkJF65XDsfCVIyhTiagCtzNVc0qj75ULcmE8GWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;本文概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的日常工作中，有时候我们为了防止线上应用发生&lt;code&gt;OOM&lt;/code&gt;，所以我们需要在开发的过程中计算一些核心对象在内存中的占用大小，目的是为了更好的了解我们的应用程序内存占用的一个大概情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进而根据我们服务器的内存资源限制以及预估的对象创建数量级计算出应用程序占用内存的高低水位线，如果内存占用量超过&lt;code&gt;高水位线&lt;/code&gt;，那么就有可能有发生&lt;code&gt;OOM&lt;/code&gt;的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在程序中根据估算出的&lt;code&gt;高低水位线&lt;/code&gt;，做一些防止&lt;code&gt;OOM&lt;/code&gt;的处理逻辑或者发出告警。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么核心问题是如何计算一个Java对象在内存中的占用大小呢？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在为大家解答这个问题之前，笔者先来介绍下Java对象在内存中的布局，也就是本文的主题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Java对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5758064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r3I5lLLo8slEicxFgVfFAdGqDVOBdRPgVkduFxd2BEe6LplnF30pr72A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Java对象的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，Java对象在JVM中是用&lt;code&gt;instanceOopDesc &lt;/code&gt;结构表示而Java对象在JVM堆中的内存布局可以分为三部分：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 对象头（Header）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Java对象都包含一个对象头，对象头中包含了两类信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;MarkWord&lt;/code&gt;：在JVM中用&lt;code&gt;markOopDesc &lt;/code&gt;结构表示用于存储对象自身运行时的数据。比如：hashcode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程Id，偏向时间戳等。在32位操作系统和64位操作系统中&lt;code&gt;MarkWord&lt;/code&gt;分别占用4B和8B大小的内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;类型指针&lt;/code&gt;：JVM中的类型指针封装在&lt;code&gt;klassOopDesc &lt;/code&gt;结构中，类型指针指向了&lt;code&gt;InstanceKclass对象&lt;/code&gt;，Java类在JVM中是用InstanceKclass对象封装的，里边包含了Java类的元信息，比如：继承结构，方法，静态变量，构造函数等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在不开启指针压缩的情况下(-XX:-UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和8B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在开启指针压缩的情况下(-XX:+UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和4B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果Java对象是一个数组类型的话，那么在数组对象的对象头中还会包含一个4B大小的用于记录数组长度的属性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于在对象头中用于记录数组长度大小的属性只占4B的内存，所以Java数组可以申请的最大长度为：&lt;code&gt;2^32&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 实例数据（Instance Data)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象在内存中的实例数据区用来存储Java类中定义的实例字段，包括所有父类中的实例字段。也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象中的字段类型分为两大类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基础类型：Java类中实例字段定义的基础类型在实例数据区的内存占用如下：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;long | double占用8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int | float占用4个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;short | char占用2个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte | boolean占用1个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引用类型：Java类中实例字段的引用类型在实例数据区内存占用分为两种情况：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不开启指针压缩(-XX:-UseCompressedOops)：在32位操作系统中引用类型的内存占用为4个字节。在64位操作系统中引用类型的内存占用为8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启指针压缩(-XX:+UseCompressedOops)：在64为操作系统下，引用类型内存占用则变为为4个字节，32位操作系统中引用类型的内存占用继续为4个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么32位操作系统的引用类型占4个字节，而64位操作系统引用类型占8字节？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，引用类型所保存的是被引用对象的内存地址。在32位操作系统中内存地址是由32个bit表示，因此需要4个字节来记录内存地址，能够记录的虚拟地址空间是2^32大小，也就是只能够表示4G大小的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在64位操作系统中内存地址是由64个bit表示，因此需要8个字节来记录内存地址，&lt;strong&gt;但在 64 位系统里只使用了低 48 位，所以它的虚拟地址空间是 2^48大小，能够表示256T大小的内存&lt;/strong&gt;，其中低 128T 的空间划分为用户空间，高 128T 划分为内核空间，可以说是非常大了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们从整体上介绍完Java对象在JVM中的内存布局之后，下面我们来看下Java对象中定义的这些实例字段在实例数据区是如何排列布局的：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 字段重排列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们在编写Java源代码文件的时候定义的那些实例字段的顺序会被JVM重新分配排列，这样做的目的其实是为了内存对齐，那么什么是内存对齐，为什么要进行内存对齐，笔者会随着文章深入的解读为大家逐层揭晓答案~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节中，笔者先来为大家介绍一下JVM字段重排列的规则:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM重新分配字段的排列顺序受&lt;code&gt;-XX:FieldsAllocationStyle&lt;/code&gt;参数的影响，默认值为&lt;code&gt;1&lt;/code&gt;，实例字段的重新分配策略遵循以下规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量&lt;code&gt;OFFSET&lt;/code&gt;需要对齐至&lt;code&gt;NX&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;偏移量是指字段的内存地址与Java对象的起始内存地址之间的差值。比如long类型的字段，它内存占用8个字节，那么它的OFFSET应该是8的倍数8N。不足8N的需要填充字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至4N，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM默认分配字段的顺序为：long / double，int / float，short / char，byte / boolean，oops(Ordianry Object Point 引用类型指针)，&lt;strong&gt;并且父类中定义的实例变量会出现在子类实例变量之前&lt;/strong&gt;。当设置JVM参数&lt;code&gt;-XX +CompactFields &lt;/code&gt;时（默认），占用内存小于long / double 的字段会允许被插入到对象中第一个 long / double字段之前的间隙中，以避免不必要的内存填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CompactFields选项参数在JDK14中以被标记为过期了，并在将来的版本中很可能被删除。详细细节可查看issue：https://bugs.openjdk.java.net/browse/JDK-8228750&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的三条字段重排列规则非常非常重要，但是读起来比较绕脑，很抽象不容易理解，笔者把它们先列出来的目的是为了让大家先有一个朦朦胧胧的感性认识，下面笔者举一个具体的例子来为大家详细说明下，在阅读这个例子的过程中也方便大家深刻的理解这三条重要的字段重排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在我们有这样一个类定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;根据上面介绍的&lt;code&gt;规则3&lt;/code&gt;我们知道父类中的变量是出现在子类变量之前的，并且字段分配顺序应该是long型字段l，应该在int型字段i之前。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果JVM开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;时，int型字段是可以插入对象中的第一个long型字段（也就是Parent.l字段）之前的空隙中的。如果JVM设置了&lt;code&gt;-XX -CompactFields&lt;/code&gt;则int型字段的这种插入行为是不被允许的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1&lt;/code&gt;我们知道long型字段在实例数据区的OFFSET需要对齐至8N，而int型字段的OFFSET需要对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2&lt;/code&gt;我们知道如果开启压缩指针&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至4N，关闭压缩指针时&lt;code&gt;-XX:-UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于JVM参数&lt;code&gt;UseCompressedOops &lt;/code&gt;和&lt;code&gt;CompactFields &lt;/code&gt;的存在，导致Child对象在实例数据区字段的排列顺序分为四种情况，下面我们结合前边提炼出的这三点规则来看下字段排列顺序在这四种情况下的表现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 -XX:+UseCompressedOops  -XX -CompactFields 开启压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;偏移量OFFSET = 8的位置存放的是类型指针，由于开启了压缩指针所以占用4个字节。对象头总共占用12个字节：MarkWord(8字节) + 类型指针(4字节)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则3：&lt;/code&gt;父类Parent中的字段是要出现在子类Child的字段之前的并且long型字段在int型字段之前。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则2：&lt;/code&gt;在开启压缩指针的情况下，Child对象中的第一个字段需要对齐至4N。这里Parent.l字段的OFFSET可以是12也可以是16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则1：&lt;/code&gt;long型字段在实例数据区的OFFSET需要对齐至8N，所以这里Parent.l字段的OFFSET只能是16，因此OFFSET = 12的位置就需要被填充。Child.l字段只能在OFFSET = 32处存储，不能够使用OFFSET = 28位置，因为28的位置不是8的倍数无法对齐8N，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;规则1也规定了int型字段的OFFSET需要对齐至4N，所以Parent.i与Child.i分别存储以OFFSET = 24和OFFSET = 40的位置。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为JVM中的内存对齐除了存在于字段与字段之间还存在于对象与对象之间，Java对象之间的内存地址需要对齐至8N&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以Child对象的末尾处被填充了4个字节，对象大小由开始的44字节被填充到48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2  -XX:+UseCompressedOops  -XX +CompactFields 开启压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rDUgEBKWWc9ahzQR8rqV39GoH6b2dbub8ViaiaCt5WE5n3pIOsaxFSFbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第一种情况的分析基础上，我们开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;压缩字段，所以导致int型的Parent.i字段可以插入到OFFSET = 12的位置处，以避免不必要的字节填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2：&lt;/code&gt;Child对象的第一个字段需要对齐至4N，这里我们看到&lt;code&gt;int型&lt;/code&gt;的Parent.i字段是符合这个规则的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;Child对象的所有long型字段都对齐至8N，所有的int型字段都对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终得到Child对象大小为36字节，由于Java对象与对象之间的内存地址需要对齐至8N，所以最后Child对象的末尾又被填充了4个字节最终变为40字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们可以看到在开启字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;的情况下，Child对象的大小由48字节变成了40字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 -XX:-UseCompressedOops  -XX -CompactFields 关闭压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23306451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUIwxgUGicbCZ6bkcIT0gnpMSRAm1Ky5MmEkcCticjCaialUgZBqUuxRcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先在关闭压缩指针&lt;code&gt;-UseCompressedOops&lt;/code&gt;的情况下，对象头中的类型指针占用字节变成了8字节。导致对象头的大小在这种情况下变为了16字节。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;long型的变量OFFSET需要对齐至8N。根据&lt;code&gt;规则2：&lt;/code&gt;在关闭压缩指针的情况下，Child对象的第一个字段Parent.l需要对齐至8N。所以这里的Parent.l字段的OFFSET  = 16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于long型的变量OFFSET需要对齐至8N，所以Child.l字段的OFFSET
需要是32，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样计算出来的Child对象大小为44字节，但是考虑到Java对象与对象的内存地址需要对齐至8N，于是又在对象末尾处填充了4个字节，最终Child对象的内存占用为48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4  -XX:-UseCompressedOops  -XX +CompactFields 关闭压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第三种情况的分析基础上，我们来看下第四种情况的字段排列情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2153225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rkd3BpQQERqordT5gAdsgiaicyvIqEr9rFyFZmw1MqJjU29eaesHScn8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于在关闭指针压缩的情况下类型指针的大小变为了8个字节，所以导致Child对象中第一个字段Parent.l前边并没有空隙，刚好对齐8N，并不需要int型变量的插入。所以即使开启了字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;，字段的总体排列顺序还是不变的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认情况下指针压缩&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;以及字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;都是开启的&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 对齐填充（Padding)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前一小节关于实例数据区字段重排列的介绍中为了内存对齐而导致的字节填充不仅会出现在字段与字段之间，还会出现在对象与对象之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了字段重排列需要遵循的三个重要规则，其中规则1，规则2定义了字段与字段之间的内存对齐规则。规则3定义的是对象字段之间的排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了内存对齐的需要，对象头与字段之间，以及字段与字段之间需要填充一些不必要的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如前边提到的字段重排列的第一种情况&lt;code&gt;-XX:+UseCompressedOops -XX -CompactFields&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而以上提到的四种情况都会在对象实例数据区的后边在填充4字节大小的空间，原因是除了需要满足字段与字段之间的内存对齐之外，还需要满足对象与对象之间的内存对齐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机堆中对象之间的内存地址需要对齐至8N（8的倍数），如果一个对象占用内存不到8N个字节，那么就必须在对象后填充一些不必要的字节对齐至8N个字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;虚拟机中内存对齐的选项为&lt;code&gt;-XX:ObjectAlignmentInBytes&lt;/code&gt;，默认为8。也就是说对象与对象之间的内存地址需要对齐至多少倍，是由这个JVM参数控制的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以上边第一种情况为例说明：图中对象实际占用是44个字节，但是不是8的倍数，那么就需要再填充4个字节，内存对齐至48个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些为了内存对齐的目的而在字段与字段之间，对象与对象之间填充的不必要字节，我们就称之为&lt;code&gt;对齐填充（Padding）&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 对齐填充的应用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们知道了对齐填充的概念之后，大家可能好奇了，为啥我们要进行对齐填充，是要解决什么问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就让我们带着这个问题，来接着听笔者往下聊~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 解决伪共享问题带来的对齐填充&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了以上介绍的两种对齐填充的场景（字段与字段之间，对象与对象之间），在JAVA中还有一种对齐填充的场景，那就是通过对齐填充的方式来解决&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍False Sharing（伪共享）之前，笔者先来介绍下CPU读取内存中数据的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.1 CPU缓存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据摩尔定律：芯片中的晶体管数量每隔&lt;code&gt;18&lt;/code&gt;个月就会翻一番。导致CPU的性能和处理速度变得越来越快，而提升CPU的运行速度比提升内存的运行速度要容易和便宜的多，所以就导致了CPU与内存之间的速度差距越来越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了弥补CPU与内存之间巨大的速度差异，提高CPU的处理效率和吞吐，于是人们引入了&lt;code&gt;L1,L2,L3&lt;/code&gt;高速缓存集成到CPU中。当然还有&lt;code&gt;L0&lt;/code&gt;也就是寄存器，寄存器离CPU最近，访问速度也最快，基本没有时延。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ruGeiaJSUicRiboqYgiaAWqhLFI8lDanK1q52jytoe5w9xibl51u246UUmWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU缓存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个CPU里面包含多个核心，我们在购买电脑的时候经常会看到这样的处理器配置，比如&lt;code&gt;4核8线程&lt;/code&gt;。意思是这个CPU包含4个物理核心8个逻辑核心。4个物理核心表示在同一时间可以允许4个线程并行执行，8个逻辑核心表示处理器利用&lt;code&gt;超线程的技术&lt;/code&gt;将一个物理核心模拟出了两个逻辑核心，一个物理核心在同一时间只会执行一个线程，而&lt;code&gt;超线程芯片&lt;/code&gt;可以做到线程之间快速切换，当一个线程在访问内存的空隙，超线程芯片可以马上切换去执行另外一个线程。因为切换速度非常快，所以在效果上看到是8个线程在同时执行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;图中的CPU核心指的是物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache是离CPU核心最近的高速缓存，紧接着就是L2Cache，L3Cache，内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离CPU核心越近的缓存访问速度也越快，造价也就越高，当然容量也就越小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中L1Cache和L2Cache是CPU物理核心私有的（&lt;strong&gt;注意：这里是物理核心不是逻辑核心&lt;/strong&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而L3Cache是整个CPU所有物理核心共享的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU逻辑核心共享其所属物理核心的L1Cache和L2Cache&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L1Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L1Cache离CPU是最近的，它的访问速度最快，容量也最小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们看到L1Cache分为两个部分，分别是：Data Cache和Instruction Cache。它们一个是存储数据的，一个是存储代码指令的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过&lt;code&gt;cd /sys/devices/system/cpu/&lt;/code&gt;来查看linux机器上的CPU信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rQDoCpOjBGDjIRQFgYz5PpQvR7WjNkM34wibLLreU7cjhnicMyicyynTow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录里，我们可以看到CPU的核心数，&lt;strong&gt;当然这里指的是逻辑核心&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者机器上的处理器并没有使用超线程技术所以这里其实是4个物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们进入其中一颗CPU核心（cpu0）中去看下L1Cache的情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU缓存的情况在&lt;code&gt;/sys/devices/system/cpu/cpu0/cache&lt;/code&gt;目录下查看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07231920199501247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rdBic5LNCpCTfiacvTic6bE1vnpvQS8QtdA3okiaNE4BibjicFv6RTgw8IxdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index0&lt;/code&gt;描述的是L1Cache中DataCache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r5Ztzic9ubE7Yao8kwqDNrE4Th9yFMGbjp02EgsDmWdP5D5NRTDRnz6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level&lt;/code&gt;：表示该cache信息属于哪一级，1表示L1Cache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：表示属于L1Cache的DataCache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;size&lt;/code&gt;：表示DataCache的大小为32K。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shared_cpu_list&lt;/code&gt;：之前我们提到L1Cache和L2Cache是CPU物理核所私有的，而由物理核模拟出来的逻辑核是&lt;strong&gt;共享L1Cache和L2Cache的&lt;/strong&gt;，&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录下描述的信息是逻辑核。shared_cpu_list描述的正是哪些逻辑核共享这个物理核。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index1&lt;/code&gt;描述的是L1Cache中Instruction Cache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14965986394557823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3raUkia8dMPfuZycmq6V3yxPEgsOibdPkXdOcf8jiacjsKibIoZCA0pTYwUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到L1Cache中的Instruction Cache大小也是32K。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L2Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的信息存储在&lt;code&gt;index2&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15172413793103448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBPG6d6wMicBXC6XNicM4Q4xmwAPvCUVoqicqtegyV1mibEr8gMCOlPjo9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的大小为256K，比L1Cache要大些。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L3Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L3Cache的信息存储在&lt;code&gt;index3&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15411558669001751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r8EhWk8gMQibcobiaSg6jBXwDYesjukUia4SRXU6d9h9Bf4rm4ZTRMAib4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们可以看到L1Cache中的DataCache和InstructionCache大小一样都是32K而L2Cache的大小为256K，L3Cache的大小为6M。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这些数值在不同的CPU配置上会是不同的，但是总体上来说L1Cache的量级是几十KB，L2Cache的量级是几百KB，L3Cache的量级是几MB。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.2 CPU缓存行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了CPU的高速缓存结构，引入高速缓存的目的在于消除CPU与内存之间的速度差距，根据&lt;code&gt;程序的局部性原理&lt;/code&gt;我们知道，CPU的高速缓存肯定是用来存放热点数据的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在高速缓存中存取数据的基本单位又是什么呢？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上热点数据在CPU高速缓存中的存取并不是我们想象中的以单独的变量或者单独的指针为单位存取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU高速缓存中存取数据的基本单位叫做缓存行&lt;code&gt;cache line&lt;/code&gt;。缓存行存取字节的大小为2的倍数，在不同的机器上，缓存行的大小范围在32字节到128字节之间。目前所有主流的处理器中缓存行的大小均为&lt;code&gt;64字节&lt;/code&gt;（&lt;strong&gt;注意：这里的单位是字节&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rFp5pibic2ibgK0RhpiaNSzG8LY5TVRjoLibakY8jIicsxTu4EoYgUzGXq7tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache,L2Cache,L3Cache中缓存行的大小都是&lt;code&gt;64字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着每次CPU从内存中获取数据或者写入数据的大小为64个字节，即使你只读一个bit，CPU也会从内存中加载64字节数据进来。同样的道理，CPU从高速缓存中同步数据到内存也是按照64字节的单位来进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你访问一个long型数组，当CPU去加载数组中第一个元素时也会同时将后边的7个元素一起加载进缓存中。&lt;strong&gt;这样一来就加快了遍历数组的效率。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;long类型在Java中占用8个字节，一个缓存行可以存放8个long型变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构，如果你的数据结构中的项在内存中不是彼此相邻的（比如：链表），这样就无法利用CPU缓存的优势。由于数据在内存中不是连续存放的，所以在这些数据结构中的每一个项都可能会出现缓存行未命中（&lt;code&gt;程序局部性原理&lt;/code&gt;）的情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《Reactor在Netty中的实现(创建篇)》&lt;/a&gt;中介绍Selector的创建时提到，Netty利用数组实现的自定义SelectedSelectionKeySet类型替换掉了JDK利用HashSet类型实现的&lt;code&gt;sun.nio.ch.SelectorImpl#selectedKeys&lt;/code&gt;。&lt;strong&gt;目的就是利用CPU缓存的优势来提高IO活跃的SelectionKeys集合的遍历性能&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 False Sharing（伪共享）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个这样的例子，笔者定义了一个示例类FalseSharding，类中有两个long型的volatile字段a，b。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段a，b之间逻辑上是独立的，它们之间一点关系也没有，分别用来存储不同的数据，数据之间也没有关联。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中字段之间的内存布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1282258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rIkusicdpvzH08AqomqdzO2kTIoFr11Zgm4AD8321M6juwibgGibBZeJiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中的字段a,b在内存中是相邻存储，分别占用8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果恰好字段a，b被CPU读进了同一个缓存行，而此时有两个线程，线程a用来修改字段a，同时线程b用来读取字段b。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7330645161290322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rp7SqclFcyfHiaq64J2oQgXg8e9ictC2Er2TqjgGygFM9w9ToXhKakSxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding1.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在这种场景下，会对线程b的读取操作造成什么影响呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道声明了&lt;code&gt;volatile关键字&lt;/code&gt;的变量可以在多线程处理环境下，确保内存的可见性。计算机硬件层会保证对被volatile关键字修饰的共享变量进行写操作后的内存可见性，而这种内存可见性是由&lt;code&gt;Lock前缀指令&lt;/code&gt;以及&lt;code&gt;缓存一致性协议（MESI控制协议）&lt;/code&gt;共同保证的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Lock前缀指令可以使修改线程所在的处理器中的相应缓存行数据被修改后立马刷新回内存中，并同时&lt;code&gt;锁定&lt;/code&gt;所有处理器核心中缓存了该修改变量的缓存行，防止多个处理器核心并发修改同一缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存一致性协议主要是用来维护多个处理器核心之间的CPU缓存一致性以及与内存数据的一致性。每个处理器会在总线上嗅探其他处理器准备写入的内存地址，如果这个内存地址在自己的处理器中被缓存的话，就会将自己处理器中对应的缓存行置为&lt;code&gt;无效&lt;/code&gt;，下次需要读取的该缓存行中的数据的时候，就需要访问内存获取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于以上volatile关键字原则，我们首先来看第一种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7wY7nnNnOPoKmzuicta6VYXzeUqVyQ80rBPniabpvAhiaTFUqYFDDs4dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding2.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当线程a在处理器core0中对字段a进行修改时，&lt;code&gt;Lock前缀指令&lt;/code&gt;会将所有处理器中缓存了字段a的对应缓存行进行&lt;code&gt;锁定&lt;/code&gt;，&lt;strong&gt;这样就会导致线程b在处理器core1中无法读取和修改自己缓存行的字段b&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理器core0将修改后的字段a所在的缓存行刷新回内存中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到此时字段a的值在处理器core0的缓存行中以及在内存中已经发生变化了。但是处理器core1中字段a的值还没有变化，并且core1中字段a所在的缓存行处于&lt;code&gt;锁定状态&lt;/code&gt;，无法读取也无法写入字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述过程中我们可以看出即使字段a，b之间逻辑上是独立的，它们之间一点关系也没有，但是线程a对字段a的修改，导致了线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7693548387096775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnB60WxJJOpAyczIn2FuP2j5QgEgr2MNN0qOlBhDVAjFjib9bzo92wpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;faslesharding3.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当处理器core0将字段a所在的缓存行刷新回内存的时候，处理器core1会在总线上嗅探到字段a的内存地址正在被其他处理器修改，所以将自己的缓存行置为&lt;code&gt;失效&lt;/code&gt;。当线程b在处理器core1中读取字段b的值时，发现缓存行已被置为&lt;code&gt;失效&lt;/code&gt;，core1需要重新从内存中读取字段b的值即使字段b没有发生任何变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上两种影响我们看到字段a与字段b实际上并不存在共享，它们之间也没有相互关联关系，理论上线程a对字段a的任何操作，都不应该影响线程b对字段b的读取或者写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上线程a对字段a的修改导致了字段b在core1中的缓存行被锁定（Lock前缀指令），进而使得线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程a所在处理器core0将字段a所在缓存行同步刷新回内存后，导致字段b在core1中的缓存行被置为&lt;code&gt;失效&lt;/code&gt;（缓存一致性协议），进而导致线程b需要重新回到内存读取字段b的值无法利用CPU缓存的优势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于字段a和字段b在同一个缓存行中，导致了字段a和字段b事实上的共享（原本是不应该被共享的）。这种现象就叫做&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，这种伪共享的问题，会对程序性能造成非常大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程a对字段a进行修改，与此同时线程b对字段b也进行修改，这种情况对性能的影响更大，因为这会导致core0和core1中相应的缓存行相互失效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 False Sharing的解决方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然导致False Sharing出现的原因是字段a和字段b在同一个缓存行导致的，那么我们就要想办法让字段a和字段b不在一个缓存行中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么做才能够使得字段a和字段b一定不会被分配到同一个缓存行中呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，本小节的主题字节填充就派上用场了~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8之前我们通常会在字段a和字段b前后分别填充7个long型变量(缓存行大小64字节)，目的是让字段a和字段b各自独占一个缓存行避免&lt;code&gt;False Sharing&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们将一开始的实例代码修改成这个这样子，就可以保证字段a和字段b各自独占一个缓存行了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p1,p2,p3,p4,p5,p6,p7;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p8,p9,p10,p11,p12,p13,p14;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p15,p16,p17,p18,p19,p20,p21;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后的对象在内存中布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47580645161290325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUI6HrVY89690zicQejoWhiaIguq7jBiaujKzicrbqxjo3RJ53BGb45ozng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到为了解决False Sharing问题，我们将原本占用32字节的FalseSharding示例对象硬生生的填充到了200字节。这对内存的消耗是非常可观的。通常为了极致的性能，我们会在一些高并发框架或者JDK的源码中看到False Sharing的解决场景。因为在高并发场景中，任何微小的性能损失比如False Sharing，都会被无限放大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但解决False Sharing的同时又会带来巨大的内存消耗，所以即使在高并发框架比如disrupter或者JDK中也只是&lt;strong&gt;针对那些在多线程场景下被频繁写入的共享变量&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里笔者想强调的是在我们日常工作中&lt;/strong&gt;，我们不能因为自己手里拿着锤子，就满眼都是钉子，看到任何钉子都想上去锤两下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHkkic5QPnrIgdFMNicgPufSU5znYlN8rfUdVey7zP9GWl93fYqkdGO4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要清晰的分辨出一个问题会带来哪些影响和损失，这些影响和损失在我们当前业务阶段是否可以接受？是否是瓶颈？同时我们也要清晰的了解要解决这些问题我们所要付出的代价。一定要综合评估，讲究一个投入产出比。某些问题虽然是问题，但是在某些阶段和场景下并不需要我们投入解决。而有些问题则对于我们当前业务发展阶段是瓶颈，我们&lt;strong&gt;不得不&lt;/strong&gt;去解决。我们在架构设计或者程序设计中，方案一定要&lt;code&gt;简单&lt;/code&gt;，&lt;code&gt;合适&lt;/code&gt;。并预估一些提前量留有一定的&lt;code&gt;演化空间&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3.1 @Contended注解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8中引入了一个新注解&lt;code&gt;@Contended&lt;/code&gt;，用于解决False Sharing的问题，同时这个注解也会影响到Java对象中的字段排列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节的内容介绍中，我们通过手段填充字段的方式解决了False Sharing的问题，但是这里也有一个问题，因为我们在手动填充字段的时候还需要考虑CPU缓存行的大小，因为虽然现在所有主流的处理器缓存行大小均为64字节，但是也还是有处理器的缓存行大小为32字节，有的甚至是128字节。我们需要考虑很多硬件的限制因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8中通过引入@Contended注解帮我们解决了这个问题，我们不在需要去手动填充字段了。下面我们就来看下@Contended注解是如何帮助我们来解决这个问题的~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节介绍的手动填充字节是在共享变量前后填充64字节大小的空间，这样只能确保程序在缓存行大小为32字节或者64字节的CPU下独占缓存行。但是如果CPU的缓存行大小为128字节，这样依然存在False Sharing的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入@Contended注解可以使我们忽略底层硬件设备的差异性，做到Java语言的初衷：平台无关性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Contended注解默认只是在JDK内部起作用，如果我们的程序代码中需要使用到@Contended注解，那么需要开启JVM参数&lt;code&gt;-XX:-RestrictContended&lt;/code&gt;才会生效。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.FIELD, ElementType.TYPE})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Contended {&lt;br/&gt;    &lt;span&gt;//contention group tag&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Contended注解可以标注在类上也可以标注在类中的字段上，被@Contended标注的对象会独占缓存行，不会和任何变量或者对象共享缓存行。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类上表示该类对象中的&lt;code&gt;实例数据整体&lt;/code&gt;需要独占缓存行。不能与其他实例数据共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类中的字段上表示该字段需要独占缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除此之外@Contended还提供了分组的概念，注解中的value属性表示&lt;code&gt;contention group &lt;/code&gt;。属于统一分组下的变量，它们在内存中是连续存放的，可以允许共享缓存行。不同分组之间不允许共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分别看下@Contended注解在这三种使用场景下是怎样影响字段之间的排列的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在类上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当@Contended标注在FalseSharding示例类上时，表示FalseSharding示例对象中的&lt;code&gt;整个实例数据区&lt;/code&gt;需要独占缓存行，不能与其他对象或者变量共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下的内存布局：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1870967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rwE6v9iaC7nRQBSTl61ibVbibmqCUHkVrex4zbnwLMrzbJiblBuuKoUuk3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图中所示，FalseSharding示例类被标注了@Contended之后，JVM会在FalseSharding示例对象的实例数据区前后填充&lt;code&gt;128个字节&lt;/code&gt;，保证实例数据区内的字段之间内存是连续的，并且保证整个实例数据区独占缓存行，不会与实例数据区之外的数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;细心的朋友可能已经发现了问题，我们之前不是提到缓存行的大小为64字节吗？为什么这里会填充128字节呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且之前介绍的手动填充也是填充的&lt;code&gt;64字节&lt;/code&gt;，为什么@Contended注解会采用&lt;code&gt;两倍&lt;/code&gt;的缓存行大小来填充呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里的原因有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先第一个原因，我们之前也已经提到过了，目前大部分主流的CPU缓存行是64字节，但是也有部分CPU缓存行是32字节或者128字节，如果只填充64字节的话，在缓存行大小为32字节和64字节的CPU中是可以做到独占缓存行从而避免FalseSharding的，但在缓存行大小为&lt;code&gt;128字节&lt;/code&gt;的CPU中还是会出现FalseSharding问题，这里Java采用了悲观的一种做法，默认都是填充&lt;code&gt;128字节&lt;/code&gt;，虽然对于大部分情况下比较浪费，但是屏蔽了底层硬件的差异。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不过@Contended注解填充字节的大小我们可以通过JVM参数&lt;code&gt;-XX:ContendedPaddingWidth&lt;/code&gt;指定，有效值范围&lt;code&gt;0 - 8192&lt;/code&gt;，默认为&lt;code&gt;128&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第二个原因其实是最为核心的一个原因，主要是为了防止CPU Adjacent Sector Prefetch（CPU相邻扇区预取）特性所带来的FalseSharding问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU Adjacent Sector Prefetch：https://www.techarp.com/bios-guide/cpu-adjacent-sector-prefetch/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU Adjacent Sector Prefetch&lt;/strong&gt;是Intel处理器特有的BIOS功能特性，默认是enabled。主要作用就是利用&lt;code&gt;程序局部性原理&lt;/code&gt;，当CPU从内存中请求数据，并读取当前请求数据所在缓存行时，&lt;code&gt;会进一步预取&lt;/code&gt;与当前缓存行相邻的下一个缓存行，这样当我们的程序在顺序处理数据时，会提高CPU处理效率。&lt;strong&gt;这一点也体现了程序局部性原理中的空间局部性特征&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当CPU Adjacent Sector Prefetch特性被disabled禁用时，CPU就只会获取当前请求数据所在的缓存行，不会预取下一个缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在当&lt;code&gt;CPU Adjacent Sector Prefetch&lt;/code&gt;启用（enabled）的时候，CPU其实同时处理的是两个缓存行，在这种情况下，就需要填充两倍缓存行大小（128字节）来避免CPU Adjacent Sector Prefetch所带来的的FalseSharding问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在字段上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rYjQZSvYydAafvXRFNYjiciax54q8PDibqKWRPZH4ZCTksjmkAurvXd7sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将 @Contended注解标注在了FalseSharding示例类中的字段a和字段b上，这样带来的效果是字段a和字段b各自独占缓存行。从内存布局上看，字段a和字段b前后分别被填充了128个字节，来确保字段a和字段b不与任何数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而没有被@Contended注解标注字段c和字段d则在内存中连续存储，可以共享缓存行。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended分组&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;  c;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20967741935483872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r31YIiaAib4AemgAaw7rdkMDg478ibd9mt4B70FkK7YvsBEa7Eribqe6Ylg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将字段a与字段b放在同一content group下，字段c与字段d放在另一个content group下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样处在同一分组&lt;code&gt;group1&lt;/code&gt;下的字段a与字段b在内存中是连续存储的，可以共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理处在同一分组group2下的字段c与字段d在内存中也是连续存储的，也允许共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是分组之间是不能共享缓存行的&lt;/strong&gt;，所以在字段分组的前后各填充&lt;code&gt;128字节&lt;/code&gt;，来保证分组之间的变量不能共享缓存行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上内容我们了解到Java对象中的实例数据区字段需要进行内存对齐而导致在JVM中会被重排列以及通过填充缓存行避免false sharding的目的所带来的字节对齐填充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也了解到内存对齐不仅发生在对象与对象之间，也发生在对象中的字段之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在本小节中笔者将为大家介绍什么是内存对齐，在本节的内容开始之前笔者先来抛出两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为什么要进行内存对齐？如果就是头比较铁，就是不内存对齐，会产生什么样的后果？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Java 虚拟机堆中对象的起始地址为什么需要对齐至 &lt;code&gt;8&lt;/code&gt;的倍数？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这两个问题，下面我们正式开始本节的内容~~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 内存结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时所称的内存也叫随机访问存储器（random-access memory）也叫RAM。而RAM分为两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一类是静态RAM（&lt;code&gt;SRAM&lt;/code&gt;），这类SRAM用于前边介绍的CPU高速缓存L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为&lt;code&gt;1 - 30个&lt;/code&gt;时钟周期，但是容量小，造价高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;另一类则是动态RAM(&lt;code&gt;DRAM&lt;/code&gt;)，这类DRAM用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为&lt;code&gt;50 - 200个&lt;/code&gt;时钟周期，但是容量大，造价便宜些（相对高速缓存）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。常见的存储器模块通常以&lt;strong&gt;64位为单位（8个字节）&lt;/strong&gt;传输数据到存储控制器上或者从存储控制器传出数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42318840579710143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnrSgvb85ibv3U8g3LG5F8RVIA7kRicdROicicYCcnrISY4QFwhgakZhib0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示内存条上黑色的元器件就是存储器模块（memory module）。多个存储器模块连接到存储控制器上，就聚合成了主存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而前边介绍到的&lt;code&gt;DRAM芯片&lt;/code&gt;就包装在存储器模块中，每个存储器模块中包含&lt;code&gt;8个DRAM芯片&lt;/code&gt;，依次编号为&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每一个&lt;code&gt;DRAM芯片&lt;/code&gt;的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（&lt;code&gt;supercell&lt;/code&gt;），每个supercell大小为一个字节（&lt;code&gt;8 bit&lt;/code&gt;）。每个supercell都由一个坐标地址（i，j）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;i表示二维矩阵中的行地址，在计算机中行地址称为RAS(row access strobe，行访问选通脉冲)。j表示二维矩阵中的列地址，在计算机中列地址称为CAS(column access strobe,列访问选通脉冲)。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图中的supercell的RAS = 2，CAS = 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTpkjjIriaZlz2u5aBwkVibNANtyB4fF4X9NxbbUuuCLmwtAeAoY1LsibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DRAM芯片&lt;/code&gt;中的信息通过引脚流入流出DRAM芯片。每个引脚携带&lt;code&gt;1 bit&lt;/code&gt;的信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中DRAM芯片包含了两个地址引脚(&lt;code&gt;addr&lt;/code&gt;)，因为我们要通过RAS，CAS来定位要获取的&lt;code&gt;supercell&lt;/code&gt;。还有8个数据引脚（&lt;code&gt;data&lt;/code&gt;）,&lt;strong&gt;因为DRAM芯片的IO单位为一个字节（8 bit）&lt;/strong&gt;,所以需要8个data引脚从DRAM芯片传入传出数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里只是为了解释地址引脚和数据引脚的概念，实际硬件中的引脚数量是不一定的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 DRAM芯片的访问&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在就以读取上图中坐标地址为（2，2）的supercell为例，来说明访问DRAM芯片的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先存储控制器将行地址&lt;code&gt;RAS = 2&lt;/code&gt;通过地址引脚发送给&lt;code&gt;DRAM芯片&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片根据&lt;code&gt;RAS = 2&lt;/code&gt;将二维矩阵中的第二行的全部内容拷贝到&lt;code&gt;内部行缓冲区&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来存储控制器会通过地址引脚发送&lt;code&gt;CAS = 2&lt;/code&gt;到DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片从内部行缓冲区中根据&lt;code&gt;CAS = 2&lt;/code&gt;拷贝出第二列的supercell并通过数据引脚发送给存储控制器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DRAM芯片的IO单位为一个supercell，也就是一个字节(8 bit)。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 CPU如何读写主存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了内存的物理结构，以及如何访问内存中的DRAM芯片获取supercell中存储的数据（&lt;code&gt;一个字节&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们来介绍下CPU是如何访问内存的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4443548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBuTZIXQof8eoW6ibAYpcULFoibX0dKoES48Y3vG39BQibhEfbPtIuvMdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU与内存之间的总线结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中关于CPU芯片的内部结构我们在介绍false sharding的时候已经详细的介绍过了，这里我们主要聚焦在CPU与内存之间的总线架构上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 总线结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU与内存之间的数据交互是通过总线（bus）完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务（bus transaction）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数据从内存传送到CPU称之为&lt;code&gt;读事务（read transaction）&lt;/code&gt;，数据从CPU传送到内存称之为&lt;code&gt;写事务（write transaction）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前这个事务是到内存的？还是到磁盘的？或者是到其他IO设备的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个事务是读还是写？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总线上传输的地址信号（&lt;code&gt;内存地址&lt;/code&gt;），还是数据信号（&lt;code&gt;数据&lt;/code&gt;）？。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们前边讲到的MESI缓存一致性协议吗？当core0修改字段a的值时，其他CPU核心会在总线上&lt;code&gt;嗅探&lt;/code&gt;字段a的内存地址，如果嗅探到总线上出现字段a的内存地址，说明有人在修改字段a，这样其他CPU核心就会&lt;code&gt;失效&lt;/code&gt;自己缓存字段a所在的&lt;code&gt;cache line&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，其中系统总线是连接CPU与IO bridge的，存储总线是来连接IO bridge和主存的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO bridge&lt;/code&gt;负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到IO bridge其实起的作用就是转换不同总线上的电子信号。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 CPU从内存读取数据过程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设CPU现在要将内存地址为&lt;code&gt;A&lt;/code&gt;的内容加载到寄存器中进行运算。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rN11lLbPfeAJzGCk3REBStPEKsvn2pemCqM0ib5C8OKcnNp9IicOq0toA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU读取内存.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先CPU芯片中的&lt;code&gt;总线接口&lt;/code&gt;会在总线上发起读事务（&lt;code&gt;read transaction&lt;/code&gt;）。该读事务分为以下步骤进行：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将内存地址A放到系统总线上。随后&lt;code&gt;IO bridge&lt;/code&gt;将信号传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主存感受到存储总线上的&lt;code&gt;地址信号&lt;/code&gt;并通过存储控制器将存储总线上的内存地址A读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，从&lt;code&gt;DRAM芯片&lt;/code&gt;中取出内存地址A对应的&lt;code&gt;数据X&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器将读取到的&lt;code&gt;数据X&lt;/code&gt;放到存储总线上，随后IO bridge将&lt;code&gt;存储总线&lt;/code&gt;上的数据信号转换为&lt;code&gt;系统总线&lt;/code&gt;上的数据信号，然后继续沿着系统总线传递。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是CPU读取内存数据到寄存器中的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是其中还涉及到一个重要的过程，这里我们还是需要摊开来介绍一下，那就是存储控制器如何通过&lt;code&gt;内存地址A&lt;/code&gt;从主存中读取出对应的&lt;code&gt;数据X&lt;/code&gt;的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们结合前边介绍的内存结构以及从DRAM芯片读取数据的过程，来总体介绍下如何从主存中读取数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 如何根据内存地址从主存中读取数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边介绍到，当主存中的存储控制器感受到了存储总线上的&lt;code&gt;地址信号&lt;/code&gt;时，会将内存地址从存储总线上读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会通过内存地址定位到具体的存储器模块。还记得内存结构中的存储器模块吗？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每个存储器模块中包含了8个DRAM芯片，编号从&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储控制器会将内存地址转换为DRAM芯片中supercell在二维矩阵中的坐标地址(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将&lt;code&gt;RAS&lt;/code&gt;和&lt;code&gt;CAS&lt;/code&gt;广播到存储器模块中的所有&lt;code&gt;DRAM芯片&lt;/code&gt;。依次通过(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)从DRAM0到DRAM7读取到相应的supercell。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道一个supercell存储了&lt;code&gt;8 bit&lt;/code&gt;数据，这里我们从DRAM0到DRAM7
依次读取到了8个supercell也就是&lt;code&gt;8个字节&lt;/code&gt;，然后将这8个字节返回给存储控制器，由存储控制器将数据放到存储总线上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU总是以word size为单位从内存中读取数据，在64位处理器中的word size为8个字节。64位的内存也只能每次吞吐8个字节。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU每次会向内存读写一个&lt;code&gt;cache line&lt;/code&gt;大小的数据（&lt;code&gt;64个字节&lt;/code&gt;），但是内存一次只能吞吐&lt;code&gt;8个字节&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在内存地址对应的存储器模块中，&lt;code&gt;DRAM0芯片&lt;/code&gt;存储第一个低位字节（supercell），&lt;code&gt;DRAM1芯片&lt;/code&gt;存储第二个字节，......依次类推&lt;code&gt;DRAM7芯片&lt;/code&gt;存储最后一个高位字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;内存一次读取和写入的单位是8个字节。而且在程序员眼里连续的内存地址实际上在物理上是不连续的&lt;/strong&gt;。因为这连续的&lt;code&gt;8个字节&lt;/code&gt;其实是存储于不同的&lt;code&gt;DRAM芯片&lt;/code&gt;上的。每个DRAM芯片存储一个字节（supercell）。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 CPU向内存写入数据过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在假设CPU要将寄存器中的数据X写到内存地址A中。同样的道理，CPU芯片中的总线接口会向总线发起写事务（&lt;code&gt;write transaction&lt;/code&gt;）。写事务步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将要写入的内存地址A放入系统总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将内存地址A传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的地址信号，将内存地址A从存储总线上读取出来，并等待数据的到达。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将寄存器中的数据拷贝到系统总线上，通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将数据传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，最后将数据写入存储器模块中的8个DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 为什么要内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在了解了内存结构以及CPU读写内存的过程之后，现在我们回过头来讨论下本小节开头的问题：为什么要内存对齐？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面笔者从三个方面来介绍下要进行内存对齐的原因：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU读取数据的单位是根据&lt;code&gt;word size&lt;/code&gt;来的，在64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;，所以CPU向内存读写数据的单位为&lt;code&gt;8字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在64位内存中，内存IO单位为&lt;code&gt;8个字节&lt;/code&gt;，我们前边也提到内存结构中的存储器模块通常以64位为单位（8个字节）传输数据到存储控制器上或者从存储控制器传出数据。因为每次内存IO读取数据都是从数据所在具体的存储器模块中包含的这8个DRAM芯片中以相同的(&lt;code&gt;RAM&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;)依次读取一个字节，然后在存储控制器中聚合成&lt;code&gt;8个字节&lt;/code&gt;返回给CPU。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;由于存储器模块中这种由8个DRAM芯片组成的物理存储结构的限制，内存读取数据只能是按照地址顺序8个字节的依次读取----8个字节8个字节地来读取数据。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ribMl20O9znTgEfP42FRNnCSg4ELsbIIU6r0se5xGJs9cHfLeqWUqibyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存IO单位.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;假设我们现在读取&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;这段连续内存地址上的8个字节。由于内存读取是按照&lt;code&gt;8个字节&lt;/code&gt;为单位依次顺序读取的，&lt;strong&gt;而我们要读取的这段内存地址的起始地址是0（8的倍数）&lt;/strong&gt;，所以0x0000 - 0x0007中每个地址的坐标都是相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）。所以他可以在8个DRAM芯片中通过相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果我们现在读取&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;这段连续内存上的8个字节也是一样的，&lt;strong&gt;因为内存段起始地址为8（8的倍数）&lt;/strong&gt;，所以这段内存上的每个内存地址在DREAM芯片中的坐标地址（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）也是相同的，我们也可以一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;内存段中的坐标地址（RAS,CAS）与&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;内存段中的坐标地址（RAS,CAS）是不相同的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;但如果我们现在读取&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;这段连续内存上的8个字节情况就不一样了，由于起始地址&lt;code&gt;0x0007&lt;/code&gt;在DRAM芯片中的（RAS,CAS）与后边地址&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;的（RAS,CAS）不相同，所以CPU只能先从&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;读取8个字节出来先放入&lt;code&gt;结果寄存器&lt;/code&gt;中并左移7个字节（目的是只获取&lt;code&gt;0x0007&lt;/code&gt;），然后CPU在从&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;读取8个字节出来放入临时寄存器中并右移1个字节（目的是获取&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;）最后与结果寄存器&lt;code&gt;或运算&lt;/code&gt;。最终得到&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;地址段上的8个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上分析过程来看，当CPU访问内存对齐的地址时，比如&lt;code&gt;0x0000&lt;/code&gt;和&lt;code&gt;0x0008&lt;/code&gt;这两个起始地址都是对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU可以通过一次read transaction读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当CPU访问内存没有对齐的地址时，比如&lt;code&gt;0x0007&lt;/code&gt;这个起始地址就没有对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU就需要两次read transaction才能将数据读取出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得笔者在小节开头提出的问题吗  ？&quot;Java 虚拟机堆中对象的&lt;code&gt;起始地址&lt;/code&gt;为什么需要对齐至 &lt;code&gt;8的倍数&lt;/code&gt;？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&quot;
现在你能回答了吗？？？&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原子性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU可以原子地操作一个对齐的word size memory。64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尽量分配在一个缓存行中&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边在介绍&lt;code&gt;false sharding&lt;/code&gt;的时候我们提到目前主流处理器中的&lt;code&gt;cache line&lt;/code&gt;大小为&lt;code&gt;64字节&lt;/code&gt;，堆中对象的起始地址通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，可以让对象尽可能的分配到一个缓存行中。&lt;strong&gt;一个内存起始地址未对齐的对象可能会跨缓存行存储，这样会导致CPU的执行效率慢2倍&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中对象中字段内存对齐的其中一个重要原因也是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外在《2. 字段重排列》这一小节介绍的三种字段对齐规则，&lt;strong&gt;是保证在字段内存对齐的基础上使得实例数据区占用内存尽可能的小&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 压缩指针&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍完关于内存对齐的相关内容之后，我们来介绍下前边经常提到的压缩指针。可以通过JVM参数&lt;code&gt;XX:+UseCompressedOops&lt;/code&gt;开启，当然默认是开启的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本小节内容开启之前，我们先来讨论一个问题，&lt;strong&gt;那就是为什么要使用压缩指针？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们现在正在准备将32位系统切换到64位系统，起初我们可能会期望系统性能会立马得到提升，但现实情况可能并不是这样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中导致性能下降的最主要原因就是64位系统中的&lt;code&gt;对象引用&lt;/code&gt;。在前边我们也提到过，64位系统中对象的引用以及类型指针占用&lt;code&gt;64 bit&lt;/code&gt;也就是8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就导致了在64位系统中的对象引用占用的内存空间是32位系统中的两倍大小，因此间接的导致了在64位系统中更多的内存消耗以及更频繁的GC发生，GC占用的CPU时间越多，那么我们的应用程序占用CPU的时间就越少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个就是对象的引用变大了，那么CPU可缓存的对象相对就少了，增加了对内存的访问。综合以上几点从而导致了系统性能的下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从另一方面来说，在64位系统中内存的寻址空间为&lt;code&gt;2^48 = 256T&lt;/code&gt;，在现实情况中我们真的需要这么大的寻址空间吗？？好像也没必要吧~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;于是我们就有了新的想法：那么我们是否应该切换回32位系统呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们切换回32位系统，我们怎么解决在32位系统中拥有超过&lt;code&gt;4G&lt;/code&gt;的内存寻址空间呢？因为现在4G的内存大小对于现在的应用来说明显是不够的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想以上的这些问题，也是当初JVM的开发者需要面对和解决的，当然他们也交出了非常完美的答卷，那就是&lt;strong&gt;使用压缩指针可以在64位系统中利用32位的对象引用获得超过4G的内存寻址空间&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 压缩指针是如何做到的呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得之前我们在介绍对齐填充和内存对齐小节中提到的，在Java虚拟机堆中对象的起始地址必须对齐至&lt;code&gt;8的倍数&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于堆中对象的起始地址均是对齐至8的倍数，所以对象引用在开启压缩指针情况下的32位二进制的后三位始终是&lt;code&gt;0&lt;/code&gt;（因为它们始终可以被8整除）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然JVM已经知道了这些对象的内存地址后三位始终是0，那么这些无意义的0就没必要在堆中继续存储。相反，我们可以利用存储0的这3位bit存储一些有意义的信息，这样我们就多出&lt;code&gt;3位bit&lt;/code&gt;的寻址空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在存储的时候，JVM还是按照32位来存储，只不过后三位原本用来存储0的bit现在被我们用来存放有意义的地址空间信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当寻址的时候，JVM将这32位的对象引用&lt;code&gt;左移3位&lt;/code&gt;（后三位补0）。这就导致了在开启压缩指针的情况下，我们原本32位的内存寻址空间一下变成了&lt;code&gt;35位&lt;/code&gt;。可寻址的内存空间变为2^32 * 2^3 = 32G。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3604838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rV5yqCxeLpAbBDYhzdviaBKhfRic98w2ZC93tRwyBMHgg0Ku4iaQdjUicTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;压缩指针.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这样一来，JVM虽然额外的执行了一些位运算但是极大的提高了寻址空间，并且将对象引用占用内存大小降低了一半，节省了大量空间。况且这些位运算对于CPU来说是非常容易且轻量的操作&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过压缩指针的原理我挖掘到了&lt;strong&gt;内存对齐的另一个重要原因&lt;/strong&gt;就是通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，我们可以在64位系统中使用压缩指针通过32位的对象引用将寻址空间提升至&lt;code&gt;32G&lt;/code&gt;.&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从Java7开始，当maximum heap size小于32G的时候，压缩指针是默认开启的。但是当maximum heap size大于32G的时候，压缩指针就会关闭。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么我们如何在压缩指针开启的情况下进一步扩大寻址空间呢？？？&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 如何进一步扩大寻址空间&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到我们在Java虚拟机堆中对象起始地址均需要对其至&lt;code&gt;8的倍数&lt;/code&gt;，不过这个数值我们可以通过JVM参数&lt;code&gt;-XX:ObjectAlignmentInBytes &lt;/code&gt;来改变（默认值为8）。当然这个数值的必须是2的次幂，数值范围需要在&lt;code&gt;8 - 256之间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是因为对象地址对齐至8的倍数，才会多出3位bit让我们存储额外的地址信息，进而将4G的寻址空间提升至32G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的道理，如果我们将&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;的数值设置为16呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象地址均对齐至16的倍数，那么就会多出4位bit让我们存储额外的地址信息。寻址空间变为2^32 * 2^4 = 64G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上规律，我们就能知道，在64位系统中开启压缩指针的情况，寻址范围的计算公式：&lt;code&gt;4G * ObjectAlignmentInBytes = 寻址范围&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是笔者并不建议大家贸然这样做，因为增大了&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;虽然能扩大寻址范围，但是这同时也可能增加了对象之间的字节填充，导致压缩指针没有达到原本节省空间的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 数组对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边大量的篇幅我们都是在讨论Java普通对象在内存中的布局情况，最后这一小节我们再来说下Java中的数组对象在内存中是如何布局的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 基本类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rpzq9LdqXNnfBciatEr9eg01iaTDSTZ4vJNqPBDqKeoXOdLryulBJPPzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;基本类型数组内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是基本类型数组在内存中的布局，基本类型数组在JVM中用&lt;code&gt;typeArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;TypeArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的内存布局大体上和普通对象的内存布局差不多，唯一不同的是在数组类型对象头中多出了&lt;code&gt;4个字节&lt;/code&gt;用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;long&lt;/span&gt;[] longArrayLayout = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12016129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rXQQicaytwdQoSvqrB3XCyoK1odU5kU3pqUFASKOyS4n6kdPgs7nIsGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到红框部分即为数组类型对象头中多出来一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们示例中的long型数组只有一个元素，所以实例数据区的大小只有8字节。如果我们示例中的long型数组变为两个元素，那么实例数据区的大小就会变为16字节，以此类推................。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩  -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14919354838709678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rrKkFvaCtPYvpI7x4FYk4eibF6d4NnXuGr365gsJ7WXXSVXWusuykxUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭了指针压缩时，对象头中的MarkWord还是占用8个字节，但是类型指针从4个字节变为了8个字节。数组长度属性还是不变保持4个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们发现是实例数据区与对象头之间发生了对齐填充。大家还记得这是为什么吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前边在字段重排列小节介绍了三种字段排列规则在这里继续适用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则1&lt;/code&gt;：如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量OFFSET需要对齐至&lt;code&gt;NX&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则2&lt;/code&gt;：在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至&lt;code&gt;4N&lt;/code&gt;，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至&lt;code&gt;8N&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里基本数组类型的实例数据区中是long型，在关闭指针压缩的情况下，根据规则1和规则2需要对齐至8的倍数，所以要在其与对象头之间填充4个字节，达到内存对齐的目的，起始地址变为&lt;code&gt;24&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 引用类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rJsDCu7IWm5Lp5iaW2XTDpfRfQq8Fhuf4wGqPcgc2d7agzX7VGZhNxkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;引用类型数组的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是引用类型数组在内存中的布局，引用类型数组在JVM中用&lt;code&gt;objArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;ObjArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在引用类型数组的对象头中也会有一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ReferenceArrayLayout&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;short&lt;/span&gt; c;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ReferenceArrayLayout[] referenceArrayLayout = &lt;span&gt;new&lt;/span&gt; ReferenceArrayLayout[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1782258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rI0EhfK0wH5ZBVhiaeHn6PNB7xIhtpjgIEbGw5yWHstINGM9brJqh2KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用数组类型内存布局与基础数组类型内存布局最大的不同在于它们的实例数据区。由于开启了压缩指针，所以对象引用占用内存大小为&lt;code&gt;4个字节&lt;/code&gt;，而我们示例中引用数组只包含一个引用元素，所以这里实例数据区中只有4个字节。相同的到道理，如果示例中的引用数组包含的元素变为两个引用元素，那么实例数据区就会变为8个字节，以此类推......。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后由于Java对象需要内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，所以在该引用数组的实例数据区后填充了4个字节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩 -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16129032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rqryHvFaRNvVKp50Hb27F97WroKVW73r2sHr1gxTWHT5bU5WBn8LrKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭压缩指针时，对象引用占用内存大小变为了&lt;code&gt;8个字节&lt;/code&gt;，所以引用数组类型的实例数据区占用了8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据字段重排列规则2，在引用数组类型对象头与实例数据区中间需要填充&lt;code&gt;4个字节&lt;/code&gt;以保证内存对齐的目的。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者详细介绍了Java普通对象以及数组类型对象的内存布局，以及相关对象占用内存大小的计算方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及在对象内存布局中的实例数据区字段重排列的三个重要规则。以及后边由字节的对齐填充引出来的false sharding问题，还有Java8为了解决false sharding而引入的@Contented注解的原理及使用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了讲清楚内存对齐的底层原理，笔者还花了大量的篇幅讲解了内存的物理结构以及CPU读写内存的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后又由内存对齐引出了压缩指针的工作原理。由此我们知道进行内存对齐的四个原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;CPU访问性能&lt;/code&gt;：当CPU访问内存对齐的地址时，可以通过一个read transaction读取一个字长（word size）大小的数据出来。否则就需要两个read transaction。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;原子性&lt;/code&gt;：CPU可以原子地操作一个对齐的word size memory。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;尽可能利用CPU缓存&lt;/code&gt;：内存对齐可以使对象或者字段尽可能的被分配到一个缓存行中，避免跨缓存行存储，导致CPU执行效率减半。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;提升压缩指针的内存寻址空间：&lt;/code&gt; 对象与对象之间的内存对齐，可以使我们在64位系统中利用32位对象引用将内存寻址空间提升至32G。既降低了对象引用的内存占用，又提升了内存寻址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中我们顺带还介绍了和内存布局相关的几个JVM参数：-XX:+UseCompressedOops&lt;code&gt;,&lt;/code&gt; -XX +CompactFields &lt;code&gt;,&lt;/code&gt;-XX:-RestrictContended &lt;code&gt;,&lt;/code&gt;-XX:ContendedPaddingWidth&lt;code&gt;,&lt;/code&gt; -XX:ObjectAlignmentInBytes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后感谢大家能看到这里，我们下篇文章再见~~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>