<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>966b0d0b7e807909e32bfdeff3fbf301</guid>
<title>消息队列原理和选型：Kafka、RocketMQ 、RabbitMQ 和 ActiveMQ</title>
<link>https://toutiao.io/k/nuwnwro</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是可读性很差，不想让这篇文章被埋没，五一特意花了 7 个小时重新整理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列中间件重要吗？面试必问问题之一，你说重不重要。我有时会问同事，为啥你用 RabbitMQ，不用 Kafka，或者 RocketMQ 呢，他给我的回答 “因为公司用的就是这个，大家都这么用”，如果你去面试，直接就被 Pass，今天这篇文章，告诉你如何回答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章，我重点突出消息队列选型，弱化每种队列内部的实现细节，精华提炼，可读性更强！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的消息队列主要这 4 种，分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ，主要介绍前三，不BB，上思维导图！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6472081218274112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWdtp7WCQne2TOTXz0r8VzLk0GY0D4ibHy9ia4uAtGETaEhIK42glDhNFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消息队列基础&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是消息队列？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Producer：消息生产者，负责产生和发送消息到 Broker；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41192411924119243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWcBEyibNjZxtpKMyn15mlhyLmhu72ibTYCXKsg3WKDsIb0dKKIicNqmkOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30250990752972257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWXQuHVZm8lKSJE8sXh1LhIb9haBZv4S1RSrJIticpTRv7LSklO6xhlNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3006896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWjjkC0lhw5jQUB2moEqAjUiasmnqJA1oqibiaABnRHVlPscW6cpXhIx15Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列应用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用解耦&lt;/strong&gt;：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步处理&lt;/strong&gt;：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;流量削锋&lt;/strong&gt;：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志处理&lt;/strong&gt;：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息通讯&lt;/strong&gt;：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息广播&lt;/strong&gt;：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用消息队列&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以我们主要讲解 Kafka、RabbitMQ 和 RocketMQ。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，&lt;strong&gt;号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台&lt;/strong&gt;，它同时也是一款开源的基于发布订阅模式的消息引擎系统。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重要概念&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主题（Topic）&lt;/strong&gt;：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分区（partition）&lt;/strong&gt;：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;批次&lt;/strong&gt;：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消费者群组（Consumer Group）&lt;/strong&gt;：消费者群组指的就是由一个或多个消费者组成的群体。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker&lt;/strong&gt;: 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker 集群&lt;/strong&gt;：broker 集群由一个或多个 broker 组成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重平衡（Rebalance）&lt;/strong&gt;：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka 架构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWib3Ps4YpGDZqtsrO91SJFCcVtU0aicWeeFr2vG6DCSbeqnDiaTlPfzezA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka 工作原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息经过序列化后，通过不同的分区策略，找到对应的分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相同主题和分区的消息，会被存放在同一个批次里&lt;/strong&gt;，然后由一个独立的线程负责把它们发到 Kafka Broker 上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9593984962406015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWrHraTiaXibia2ajHL96OZsOJDLypatHeicllUJChN9zFvaq9TEq7sBtzXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41124260355029585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWjOHToZ2xQ999kjeeekY1s9Qvt6OCVGiap90XKqe9icKBVgSLbtFYfsEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 消费是通过消费群组完成，同一个消费者群组，&lt;strong&gt;一个消费者可以消费多个分区，但是一个分区，只能被一个消费者消费。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.445993031358885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWn85JWEMDGK1uzdJ0srWwD11ibl24kTg2vuk6qT3aoqWkSm0iayibE3v9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1148&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不同的消费群组互不干涉&lt;/strong&gt;，比如下图的 2 个消费群组，可以分别消费这 4 个分区的消息，互不影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6858552631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWBuugVw3OAeqFiaOI3lNiaJsPicXKHCiaicHor1dCkibAnZ8qlQHDqonS4BkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1216&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更多知识，详见 《原理初探之 Kafka》&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，&lt;strong&gt;具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，&lt;strong&gt;它对消息的可靠传输及事务性做了优化&lt;/strong&gt;，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog 分发等场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重要概念&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Name 服务器（NameServer）&lt;/strong&gt;：充当注册中心，类似 Kafka 中的 Zookeeper。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker&lt;/strong&gt;: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主题（Topic）&lt;/strong&gt;：消息的第一级类型，一条消息必须有一个 Topic。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;子主题（Tag）&lt;/strong&gt;：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分组（Group）&lt;/strong&gt;：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;队列（Queue）&lt;/strong&gt;：可以类比 Kafka 的分区 Partition。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RocketMQ 工作原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为了提高并发能力，一个 Topic 包含多个 Queue&lt;/strong&gt;，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：&lt;strong&gt;不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费 Queue 的过程中，通过偏移量记录消费的位置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4982014388489209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWpI26387ic8ctIbdS1N1GP3yUicXdiaqQt4ul6yJjyW1cZnn4Y6HiaAFZPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1668&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RocketMQ 架构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7048192771084337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaW3iaS9JIzjWhvibOA2ibWYE6eyeqODjhJGjKSdd9MF2mKotl3pIqj58NiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1660&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单提一下，Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，大家应该可以发现，RocketMQ 的设计和 Kafka 真的很像！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更多知识，详见 《原理初探之 RocketMQ》&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AMQP 的主要特征是面向消息、队列、路由、可靠性、安全。&lt;strong&gt;AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重要概念&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;信道（Channel）&lt;/strong&gt;：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;交换器（Exchange）&lt;/strong&gt;：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;路由键（RoutingKey）&lt;/strong&gt;：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;绑定（Binding）&lt;/strong&gt;：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RabbitMQ 工作原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者是连接到 Server，建立一个连接，开启一个信道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者也需要进行建立连接，开启信道等操作，便于接收消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者发送消息，发送到服务端中的虚拟主机。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订阅了消息队列的消费者就可以获取到消息，进行消费。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4993788819875776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaW5zXAZJV6ickiaKzfgpv1x5BzEkG0tLIxga6fr3DbrGyRH5d30mSuUaJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1610&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用交换器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ 常用的交换器类型有 direct、topic、fanout、headers 四种，每种方法的详细介绍看这篇《入门RabbitMQ，这一篇绝对够！》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的使用方法，可以参考官网：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;官网入口：https://www.rabbitmq.com/getstarted.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9128959276018099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWHbaEGicB8xLNNuwtd8LRXhPeFAtjjrMhfQZTpGUORLTxKaqPFVC3iceQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更多知识，详见 《入门RabbitMQ，这一篇绝对够！》&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消息队列对比&amp;amp;选型&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9122994652406418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWflltexd88iatDULGFQRN5AzJtmJTvQewFaDI0Rl4WcvFDv8XRx9Xxkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高吞吐、低延迟&lt;/strong&gt;：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高伸缩性&lt;/strong&gt;：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高稳定性&lt;/strong&gt;：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久性、可靠性、可回溯&lt;/strong&gt;：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息有序：通过控制能够保证所有消息被消费且仅被消费一次；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不支持消息路由，不支持延迟发送，不支持消息重试；&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;社区更新较慢。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RocketMQ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高吞吐&lt;/strong&gt;：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高伸缩性&lt;/strong&gt;：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高容错性&lt;/strong&gt;：通过ACK机制，保证消息一定能正常消费；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久化、可回溯&lt;/strong&gt;：消息可以持久化到磁盘中，支持消息回溯；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不支持消息路由，&lt;strong&gt;支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;社区活跃度一般。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RabbitMQ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支持几乎所有最受欢迎的编程语言&lt;/strong&gt;：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支持消息路由&lt;/strong&gt;：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息时序&lt;/strong&gt;：通过延时队列，可以指定消息的延时时间，过期时间TTL等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;社区活跃度高。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Erlang 开发，很难去看懂源码，不利于做二次开发和维护&lt;/strong&gt;，基本只能依赖于开源社区的快速维护和修复 bug；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RabbitMQ 吞吐量会低一些&lt;/strong&gt;，这是因为他做的实现机制比较重；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列选型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输，&lt;strong&gt;适合产生大量数据的互联网服务的数据收集业务&lt;/strong&gt;，大型公司建议可以选用，&lt;strong&gt;如果有日志采集功能，肯定是首选 kafka。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RocketMQ：&lt;strong&gt;天生为金融互联网领域而生，对于可靠性要求很高的场景&lt;/strong&gt;，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，&lt;strong&gt;如果你的业务有上述并发场景，建议可以选择 RocketMQ。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。&lt;strong&gt;如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少，&lt;strong&gt;较少在大规模吞吐的场景中使用。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU0OTE4MzYzMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk55KKLFaGCDRURMvFtPXf9fZXJOHOFsA3Ye8Qbibf3qHLkBQNpdjicAVpPf2T03EcakjAFbwqicjXSibXA/0?wx_fmt=png&quot; data-nickname=&quot;架构师社区&quot; data-alias=&quot;devabc&quot; data-signature=&quot;架构师社区，专注分享架构师技术干货，架构师行业秘闻，汇集各类奇妙好玩的架构师话题和流行的架构师动向！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad5592f9cb68f2937f5944650a81ad4e</guid>
<title>C# 中多态底层 (虚方法调用) 是怎么玩</title>
<link>https://toutiao.io/k/lwi1osh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;C++&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的虚方法调用实现原理，大概就是说在 class 的首位置存放着一个指向 &lt;/span&gt;&lt;code&gt;&lt;span&gt;vtable array&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指针数组 的指针，而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;vtable array&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的每一个指针元素指向的就是各自的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;虚方法&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，实现方式很有意思，哈哈，现在我很好奇 C# 中如何实现的。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、C# 中的多态玩法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、一个简单的 C# 例子&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了方便说明，我就定义一个 Person 类和一个 Chinese 类，详细代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Program&lt;/span&gt;  &lt;br/&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt;(&lt;span&gt;&lt;span&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;  &lt;br/&gt;    {  &lt;br/&gt;        Person person = &lt;span&gt;new&lt;/span&gt; Chinese();  &lt;br/&gt;&lt;br/&gt;        person.SayHello();  &lt;br/&gt;&lt;br/&gt;        Console.ReadLine();  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;  &lt;br/&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;SayHello&lt;/span&gt;()&lt;/span&gt;  &lt;br/&gt;    {  &lt;br/&gt;        Console.WriteLine(&lt;span&gt;&quot;sayhello&quot;&lt;/span&gt;);  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Chinese&lt;/span&gt;: &lt;span&gt;Person&lt;/span&gt;  &lt;br/&gt;{  &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;SayHello&lt;/span&gt;()&lt;/span&gt;  &lt;br/&gt;        {  &lt;br/&gt;            Console.WriteLine(&lt;span&gt;&quot;chinese&quot;&lt;/span&gt;);  &lt;br/&gt;        }  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、汇编代码分析&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来用 windbg 在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;person.SayHello()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 处下一个断点，观察一下它的反汇编代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;9&lt;/span&gt;:  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21b3 b93c5dce05      mov     ecx,&lt;span&gt;5&lt;/span&gt;CE5D3Ch (MT: ConsoleApp1.Chinese)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21b8 e8030f89fa      call    &lt;span&gt;005830&lt;/span&gt;c0 (JitHelp: CORINFO_HELP_NEWSFAST)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21bd &lt;span&gt;8945f&lt;/span&gt;4          mov     dword ptr [ebp&lt;span&gt;-0&lt;/span&gt;Ch],eax  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21c0 &lt;span&gt;8b&lt;/span&gt;4df4          mov     ecx,dword ptr [ebp&lt;span&gt;-0&lt;/span&gt;Ch]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21c3 e820fbffff      call    &lt;span&gt;05&lt;/span&gt;cf1ce8 (ConsoleApp1.Chinese..ctor(), mdToken: &lt;span&gt;0600000&lt;/span&gt;A)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21c8 &lt;span&gt;8b&lt;/span&gt;4df4          mov     ecx,dword ptr [ebp&lt;span&gt;-0&lt;/span&gt;Ch]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21cb &lt;span&gt;894&lt;/span&gt;df8          mov     dword ptr [ebp&lt;span&gt;-8&lt;/span&gt;],ecx  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;11&lt;/span&gt;:  &lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;05&lt;/span&gt;cf21ce &lt;span&gt;8b&lt;/span&gt;4df8          mov     ecx,dword ptr [ebp&lt;span&gt;-8&lt;/span&gt;]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d1 &lt;span&gt;8b&lt;/span&gt;45f8          mov     eax,dword ptr [ebp&lt;span&gt;-8&lt;/span&gt;]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d4 &lt;span&gt;8b&lt;/span&gt;00            mov     eax,dword ptr [eax]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d6 &lt;span&gt;8b&lt;/span&gt;4028          mov     eax,dword ptr [eax+&lt;span&gt;28&lt;/span&gt;h]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d9 ff5010          call    dword ptr [eax+&lt;span&gt;10&lt;/span&gt;h]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21dc &lt;span&gt;90&lt;/span&gt;              nop  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从汇编代码看，逻辑非常清晰，大体步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、&lt;/span&gt;&lt;code&gt;&lt;span&gt;eax,dword ptr [ebp-8]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从栈上(ebp-8)处获取 person 在堆上的首地址，如果不相信的话，可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;!do 027ea88c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 试试看。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dp ebp&lt;span&gt;-8&lt;/span&gt; L1  &lt;br/&gt;&lt;span&gt;0057f&lt;/span&gt;300  &lt;span&gt;027&lt;/span&gt;ea88c  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !&lt;span&gt;do&lt;/span&gt; &lt;span&gt;027&lt;/span&gt;ea88c  &lt;br/&gt;Name:        ConsoleApp1.Chinese  &lt;br/&gt;MethodTable: &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:     &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Size:        &lt;span&gt;12&lt;/span&gt;(&lt;span&gt;0xc&lt;/span&gt;) bytes  &lt;br/&gt;File:        D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;Fields:  &lt;br/&gt;None  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、&lt;/span&gt;&lt;code&gt;&lt;span&gt;eax,dword ptr [eax]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果大家了解 &lt;/span&gt;&lt;code&gt;&lt;span&gt;实例&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在堆上的内存布局的话，应该知道，这个首地址存放的就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;methodtable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指针,我们可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;!dumpmt 05ce5d3c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来验证下。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dp &lt;span&gt;027&lt;/span&gt;ea88c L1  &lt;br/&gt;&lt;span&gt;027&lt;/span&gt;ea88c  &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !dumpmt &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:         &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Module:          &lt;span&gt;05&lt;/span&gt;addb14  &lt;br/&gt;Name:            ConsoleApp1.Chinese  &lt;br/&gt;mdToken:         &lt;span&gt;02000007&lt;/span&gt;  &lt;br/&gt;File:            D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;BaseSize:        &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;ComponentSize:   &lt;span&gt;0x0&lt;/span&gt;  &lt;br/&gt;DynamicStatics:  &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;ContainsPointers &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;Slots &lt;span&gt;in&lt;/span&gt; VTable: &lt;span&gt;6&lt;/span&gt;  &lt;br/&gt;Number of IFaces &lt;span&gt;in&lt;/span&gt; IFaceMap: &lt;span&gt;0&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、&lt;/span&gt;&lt;code&gt;&lt;span&gt;eax,dword ptr [eax+28h]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那这句话是什么意思呢？如果你了解 CoreCLR 的话，你应该知道 methedtable 是由一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;class MethodTable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类来承载的，所以它取了 methodtable 偏移 &lt;/span&gt;&lt;code&gt;&lt;span&gt;0x28&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  位置的一个字段，那这个偏移字段是什么呢？我们先用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dt&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 把 methodtable 结构给导出来。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dt &lt;span&gt;05&lt;/span&gt;ce5d3c MethodTable  &lt;br/&gt;coreclr!MethodTable  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad96bc8 s_pMethodDataCache : &lt;span&gt;0x00639ec8&lt;/span&gt; MethodDataCache  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad96bc4 s_fUseParentMethodData : &lt;span&gt;0&lt;/span&gt;n1  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad96bcc s_fUseMethodDataCache : &lt;span&gt;0&lt;/span&gt;n1  &lt;br/&gt;   +&lt;span&gt;0x000&lt;/span&gt; m_dwFlags        : &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x004&lt;/span&gt; m_BaseSize       : &lt;span&gt;0x74088&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x008&lt;/span&gt; m_wFlags2        : &lt;span&gt;5&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x00a&lt;/span&gt; m_wToken         : &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x00c&lt;/span&gt; m_wNumVirtuals   : &lt;span&gt;0x5ccc&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x00e&lt;/span&gt; m_wNumInterfaces : &lt;span&gt;0x5ce&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x010&lt;/span&gt; m_pParentMethodTable : IndirectPointer&amp;lt;MethodTable *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x014&lt;/span&gt; m_pLoaderModule  : PlainPointer&amp;lt;Module *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x018&lt;/span&gt; m_pWriteableData : PlainPointer&amp;lt;MethodTableWriteableData *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x01c&lt;/span&gt; m_pEEClass       : PlainPointer&amp;lt;EEClass *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x01c&lt;/span&gt; m_pCanonMT       : PlainPointer&amp;lt;unsigned &lt;span&gt;long&lt;/span&gt;&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x020&lt;/span&gt; m_pPerInstInfo   : PlainPointer&amp;lt;PlainPointer&amp;lt;Dictionary *&amp;gt; *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x020&lt;/span&gt; m_ElementTypeHnd : &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x020&lt;/span&gt; m_pMultipurposeSlot1 : &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x024&lt;/span&gt; m_pInterfaceMap  : PlainPointer&amp;lt;InterfaceInfo_t *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x024&lt;/span&gt; m_pMultipurposeSlot2 : &lt;span&gt;0x5ce5d68&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad04c78 c_DispatchMapSlotOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot; $ (System.Private.CoreLib.dll&quot;&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad04c70 c_NonVirtualSlotsOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot; $ ($((, $ (System.Private.CoreLib.dll&quot;&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad04c60 c_ModuleOverrideOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot; $ ($((,$((,(,,0 $ ($((, $ (System.Private.CoreLib.dll&quot;&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad12838 c_OptionalMembersStartOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot;(((((((,(((,(,,0(((,(,,0(,,0,004&quot;&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 methodtable 的布局图来看, &lt;/span&gt;&lt;code&gt;&lt;span&gt;eax+28h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;m_pMultipurposeSlot2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 结构的第二个字段了，因为第一个字段是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;虚方法表指针&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，如果要验证的话，也很简单，用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;!dumpmt -md 05ce5d3c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 把所有的方法给导出来，然后结合 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dp 05ce5d3c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 看下 0x5ce5d68 之后是不是许多的方法。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !dumpmt -md &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:         &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Module:          &lt;span&gt;05&lt;/span&gt;addb14  &lt;br/&gt;Name:            ConsoleApp1.Chinese  &lt;br/&gt;mdToken:         &lt;span&gt;02000007&lt;/span&gt;  &lt;br/&gt;File:            D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;BaseSize:        &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;ComponentSize:   &lt;span&gt;0x0&lt;/span&gt;  &lt;br/&gt;DynamicStatics:  &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;ContainsPointers &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;Slots &lt;span&gt;in&lt;/span&gt; VTable: &lt;span&gt;6&lt;/span&gt;  &lt;br/&gt;Number of IFaces &lt;span&gt;in&lt;/span&gt; IFaceMap: &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;--------------------------------------  &lt;br/&gt;MethodDesc Table  &lt;br/&gt;   Entry MethodDe    JIT Name  &lt;br/&gt;&lt;span&gt;02610028&lt;/span&gt; &lt;span&gt;02605568&lt;/span&gt;   NONE System.Object.Finalize()  &lt;br/&gt;&lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02605574&lt;/span&gt;   NONE System.Object.ToString()  &lt;br/&gt;&lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02605580&lt;/span&gt;   NONE System.Object.Equals(System.Object)  &lt;br/&gt;&lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;026055&lt;/span&gt;ac   NONE System.Object.GetHashCode()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF1CE0 &lt;span&gt;05&lt;/span&gt;ce5d24   NONE ConsoleApp1.Chinese.SayHello()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF1CE8 &lt;span&gt;05&lt;/span&gt;ce5d30    JIT ConsoleApp1.Chinese..ctor()  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dp &lt;span&gt;05&lt;/span&gt;ce5d3c L10  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;span&gt;00000200&lt;/span&gt; &lt;span&gt;0000000&lt;/span&gt;c &lt;span&gt;00074088&lt;/span&gt; &lt;span&gt;00000005&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d4c  &lt;span&gt;05&lt;/span&gt;ce5ccc &lt;span&gt;05&lt;/span&gt;addb14 &lt;span&gt;05&lt;/span&gt;ce5d7c &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d5c  &lt;span&gt;05&lt;/span&gt;cf1ce8 &lt;span&gt;00000000&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;ce5d68 &lt;span&gt;02610028&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d6c  &lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;cf1ce0 &lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;仔细看输出，上面的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05ce5d68&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 后面的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;02610028&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;System.Object.Finalize()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，&lt;/span&gt;&lt;code&gt;&lt;span&gt;02610030&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对应着 &lt;/span&gt;&lt;code&gt;&lt;span&gt;System.Object.ToString()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、&lt;/span&gt;&lt;code&gt;&lt;span&gt;call dword ptr [eax+10h]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了前面的基础，这句话就好理解了，它是从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;m_pMultipurposeSlot2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 结构中找 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SayHello&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 所在的单元指针位置，然后做 call 调用。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !U &lt;span&gt;05&lt;/span&gt;cf1ce0  &lt;br/&gt;Unmanaged code  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce0 e88f9dde74      call    coreclr!PrecodeFixupThunk (&lt;span&gt;7&lt;/span&gt;aadba74)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce5 &lt;span&gt;5&lt;/span&gt;e              pop     esi  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce6 &lt;span&gt;0001&lt;/span&gt;            &lt;span&gt;add&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt; ptr [ecx],al  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce8 e913050000      jmp     &lt;span&gt;05&lt;/span&gt;cf2200  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ced &lt;span&gt;5f&lt;/span&gt;              pop     edi  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cee &lt;span&gt;0300&lt;/span&gt;            &lt;span&gt;add&lt;/span&gt;     eax,dword ptr [eax]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf0 &lt;span&gt;245&lt;/span&gt;d            and     al,&lt;span&gt;5&lt;/span&gt;Dh  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf2 ce              &lt;span&gt;into&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf3 &lt;span&gt;0500000000&lt;/span&gt;      &lt;span&gt;add&lt;/span&gt;     eax,&lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf8 &lt;span&gt;0000&lt;/span&gt;            &lt;span&gt;add&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt; ptr [eax],al &lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从汇编看，它还是一段 &lt;/span&gt;&lt;code&gt;&lt;span&gt;桩代码&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，言外之意就是该方法没有被 JIT 编译，如果编译完了，这里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05CF1CE0 05ce5d24 NONE ConsoleApp1.Chinese.SayHello()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  的 Entry (05CF1CE0) 也会被同步修改，验证一下很简单，我们继续 go 代码让其编译完成，然后再 dumpmt 。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;008&lt;/span&gt;&amp;gt; !dumpmt -md &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:         &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Module:          &lt;span&gt;05&lt;/span&gt;addb14  &lt;br/&gt;Name:            ConsoleApp1.Chinese  &lt;br/&gt;mdToken:         &lt;span&gt;02000007&lt;/span&gt;  &lt;br/&gt;File:            D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;BaseSize:        &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;ComponentSize:   &lt;span&gt;0x0&lt;/span&gt;  &lt;br/&gt;DynamicStatics:  &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;ContainsPointers &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;Slots &lt;span&gt;in&lt;/span&gt; VTable: &lt;span&gt;6&lt;/span&gt;  &lt;br/&gt;Number of IFaces &lt;span&gt;in&lt;/span&gt; IFaceMap: &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;--------------------------------------  &lt;br/&gt;MethodDesc Table  &lt;br/&gt;   Entry MethodDe    JIT Name  &lt;br/&gt;&lt;span&gt;02610028&lt;/span&gt; &lt;span&gt;02605568&lt;/span&gt;   NONE System.Object.Finalize()  &lt;br/&gt;&lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02605574&lt;/span&gt;   NONE System.Object.ToString()  &lt;br/&gt;&lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02605580&lt;/span&gt;   NONE System.Object.Equals(System.Object)  &lt;br/&gt;&lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;026055&lt;/span&gt;ac   NONE System.Object.GetHashCode()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF2270 &lt;span&gt;05&lt;/span&gt;ce5d24    JIT ConsoleApp1.Chinese.SayHello()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF1CE8 &lt;span&gt;05&lt;/span&gt;ce5d30    JIT ConsoleApp1.Chinese..ctor()  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;008&lt;/span&gt;&amp;gt; dp &lt;span&gt;05&lt;/span&gt;ce5d3c L10  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;span&gt;00000200&lt;/span&gt; &lt;span&gt;0000000&lt;/span&gt;c &lt;span&gt;00074088&lt;/span&gt; &lt;span&gt;00000005&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d4c  &lt;span&gt;05&lt;/span&gt;ce5ccc &lt;span&gt;05&lt;/span&gt;addb14 &lt;span&gt;05&lt;/span&gt;ce5d7c &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d5c  &lt;span&gt;05&lt;/span&gt;cf1ce8 &lt;span&gt;00000000&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;ce5d68 &lt;span&gt;02610028&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d6c  &lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;cf2270  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时可以看到它由 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05cf1ce0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变成了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05cf2270&lt;/span&gt;&lt;/code&gt;&lt;span&gt;， 这个就是 JIT 编译后的方法代码，我们用 !U 反编译下。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;008&lt;/span&gt;&amp;gt; !U &lt;span&gt;05&lt;/span&gt;cf2270  &lt;br/&gt;Normal JIT generated code  &lt;br/&gt;ConsoleApp1.Chinese.SayHello()  &lt;br/&gt;ilAddr &lt;span&gt;is&lt;/span&gt; &lt;span&gt;05E720&lt;/span&gt;D5 pImport &lt;span&gt;is&lt;/span&gt; &lt;span&gt;008F&lt;/span&gt;6E88  &lt;br/&gt;Begin &lt;span&gt;05&lt;/span&gt;CF2270, size &lt;span&gt;27&lt;/span&gt;  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;28&lt;/span&gt;:  &lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;05&lt;/span&gt;cf2270 &lt;span&gt;55&lt;/span&gt;              push    ebp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2271 &lt;span&gt;8b&lt;/span&gt;ec            mov     ebp,esp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2273 &lt;span&gt;50&lt;/span&gt;              push    eax  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2274 &lt;span&gt;894&lt;/span&gt;dfc          mov     dword ptr [ebp&lt;span&gt;-4&lt;/span&gt;],ecx  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2277 &lt;span&gt;833&lt;/span&gt;d74dcad0500  cmp     dword ptr ds:[&lt;span&gt;5&lt;/span&gt;ADDC74h],&lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf227e &lt;span&gt;7405&lt;/span&gt;            je      &lt;span&gt;05&lt;/span&gt;cf2285  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2280 e8cb2bf174      call    coreclr!JIT_DbgIsJustMyCode (&lt;span&gt;7&lt;/span&gt;ac04e50)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2285 &lt;span&gt;90&lt;/span&gt;              nop  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;29&lt;/span&gt;:  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2286 &lt;span&gt;8b&lt;/span&gt;0d74207e04    mov     ecx,dword ptr ds:[&lt;span&gt;47E2074&lt;/span&gt;h] (&lt;span&gt;&quot;chinese&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf228c e8dffbffff      call    &lt;span&gt;05&lt;/span&gt;cf1e70  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2291 &lt;span&gt;90&lt;/span&gt;              nop  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;30&lt;/span&gt;:  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2292 &lt;span&gt;90&lt;/span&gt;              nop  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2293 &lt;span&gt;8b&lt;/span&gt;e5            mov     esp,ebp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2295 &lt;span&gt;5&lt;/span&gt;d              pop     ebp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2296 c3              ret  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;终于这就是多态下的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ConsoleApp1.Chinese.SayHello&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法啦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本质上来说，CoreCLR 也是 C++ 写的，所以也逃不过用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;虚表&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来实现多态的玩法， 不过玩法也稍微复杂了一些，希望本篇对大家有帮助。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>85f107e085cc5f9eff9ba0e4fa826783</guid>
<title>实时预览组件效果，这个库让你方便到哭</title>
<link>https://toutiao.io/k/iwcb0r0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;strong&gt;零一&lt;/strong&gt;，看到一个好东西，忍不住来分享一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写需求时都会封装一些组件，然后会为该组件定义一些 &lt;code&gt;props&lt;/code&gt; ，使其跟业务分离，变得更通用。写完组件后需要验证一下组件的效果，也就需要简单 &lt;code&gt;mock&lt;/code&gt; 一下数据传进去，然后跑一下项目看一下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// components/card/index.tsx  Card 组件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 咱先来写个组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Card&lt;/span&gt; (&lt;span&gt;props&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { name } = props&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div&amp;gt;{name}&amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.tsx  项目根目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 组件写好了，找个地方引入一下，传点数据进去，免得项目崩了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Card form &lt;span&gt;&#x27;card&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Card name=&lt;span&gt;&quot;零一&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; &lt;span&gt;# 跑一下项目，看看刚才写的组件的效果&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yarn dev&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套流程，你是不是很熟悉？大家可能都是这么干的，看完效果后还要回过头去把刚刚不要的测试代码都删掉&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，我找到了一个非常好用的 &lt;strong&gt;Vscode 插件&lt;/strong&gt; 大大简化了这个流程！！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它就是 &lt;strong&gt;Preview.js&lt;/strong&gt; ，一个用于项目中组件实时预览的插件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它有什么&lt;strong&gt;优点&lt;/strong&gt;？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持 &lt;code&gt;React（v16+）&lt;/code&gt;、&lt;code&gt;Vue2&lt;/code&gt;、&lt;code&gt;Vue3&lt;/code&gt;、&lt;code&gt;SolidJS&lt;/code&gt;，并即将支持 &lt;code&gt;Preact&lt;/code&gt; 和 &lt;code&gt;Svelte&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无需启动项目，直接静态预览组件效果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动识别组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动生成 props 的 mock 数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时刷新，无需疯狂点保存触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以针对同一个组件生成多个预览，并可快速切换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持调整页面比例，以及切换不同分辨率的设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暗黑模式切换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接搜索项目中的其它组件，快速切换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;香不香？我反正已经上手使用过了，是真的香！之前我自己也做过组件库的项目，写完一个组件，就需要写一个 &lt;code&gt;example&lt;/code&gt; 去看看效果，要是用了这个插件，项目也不用跑，实时预览，该有多爽啊（正在开发组件库的同学看过来，福利啊）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再讲一下这个插件的&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;插件是刚出的，可能会有一些bug，这是难免的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上述优点中，6、7、8都是需要付费的，不过目前可以白嫖，等会讲&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;待发现...&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我目前用下来是没啥问题的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接下来带大家体验一下&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在 VsCode 的插件市场搜索：&lt;code&gt;Preview.js&lt;/code&gt;，安装即可&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23484848484848486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXlbZzZIGH5UyREr8fOEkMfMgjUyxpZQX1lSvj8OX6ia86rnUT7XAqREQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;figcaption&gt;安装插件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后最好重启一下 VsCode&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;emmmm，大多数同学应该会收到这样一条报错信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16373056994818652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXxY4e33SNicjW1noGK6tiarvb99RgfiaZEyCJFaL1XoictCpKrJUb01PBdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1930&quot;/&gt;&lt;figcaption&gt;npm 版本过低&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为重启后的初始化阶段，&lt;code&gt;Preview.js&lt;/code&gt; 插件会安装一些依赖包，并且它们最低支持的 &lt;code&gt;npm&lt;/code&gt; 版本是 &lt;code&gt;7+&lt;/code&gt;，估摸着大部分同学的 &lt;code&gt;npm&lt;/code&gt; 包都是小于 7 的，所以还是建议大家想要使用时切换一下 &lt;code&gt;node&lt;/code&gt; 版本，比如用 &lt;code&gt;nvm use 17.5.0&lt;/code&gt;，此时的 &lt;code&gt;npm&lt;/code&gt; 版本就到了 &lt;code&gt;8+&lt;/code&gt; 了，满足了需求，此时还需要重启一次&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微耐心等待几秒钟，等它的依赖包都装好就ok了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40804597701149425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXuX0AZo3VoefWCxYy9p5YYIsgVGj7NaUsaBPFLXR8QSImZTptU0YqOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;figcaption&gt;preview.js 依赖包安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本使用&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了方便起见，我就拿 &lt;code&gt;React&lt;/code&gt; 的代码来做示例了，但刚才提到那些库也都是支持的哈，大家可以自行尝试&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们随便找到项目中的一个组件打开&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6751968503937008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXK4KX5F4EhzyiaDMV1IPicT0FgLGreUmoOHUG69juxXYzjYCb0A3Xszicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，插件自动识别到了我的 &lt;code&gt;Card&lt;/code&gt; 组件，并在上方悬浮了一个 &lt;code&gt;Open Card in Preview.js&lt;/code&gt; 的灰色按钮，点击以后右边就会出来一个预览窗口了（此时咱们都还没启动项目）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4347442680776014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXLAGZicvdPVzrjIlxGymV1g7OEFfjnmmL2VhFVggQFribK03ia9Lo1A9Bg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还能看到，右下角也帮我们生成了该组件需要的 &lt;code&gt;props&lt;/code&gt; 的 mock 数据，不过这个前提条件是你项目是 TS 的，并且给 props 限定了类型才行，否则是不行的（我试过了）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切（新增组件、修改文本、修改样式...）的修改都是实时的（除了修改 props 类型），我们来看一下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43562610229276894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXvmkEichQYP8fLzz1Iq50uh6CrpkSCucN6oTobdT72yAD5rQBIIr5XJw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型修改不能实时也算是一个小缺点，希望后续可以改进一下。如果咱们改了类型，目前只需重启预览窗口就可以了，点底部的刷新是没用的&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Pro 级别的功能&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来是高级用户可以使用的功能，我看到他们官网是有申请 30 天免费体验资格的，为了本文的效果，我先申请了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请网址：https://previewjs.com/checkout&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;填一下自己的邮箱，就申请成功了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44224037339556593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXHcz0lmrJtPyr4wujjruNAhPicIjcomuYdaVJqRzLlc7syPxicGjd8XsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后它会把一个兑换码发到你的邮箱里&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.834319526627219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanX3KicO7kaAmxEO4NvHJPMiazSKE26N0j4yTzkQ7aVeVmyxqAPD7SYFp4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿着这个码去 VsCode 的 Preview.js 预览窗口里填写即可&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.875438596491228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXRhI7Zscv7Gq4yiaKibqIvmOg0yfrtQlTlnpBUTMzAVhe9SknibDribsZZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6686991869918699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXbstpk3ETvKM8mHBKwTpgxyouGUqIrpXhniaib7iclSUQqNjYtib69pG4KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就成功了，页面现在多了一堆功能&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8880994671403197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXH6QuCYGplYleMibCLJ0W0LJk034bdOtgwiaYw0kbgXSPEJ2ZXWj4NiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来统一体验一下吧&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8774422735346359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXATlTnfBrDE2VzbZIUWAKlmgTRCgz9ib4KEUPF30okR0IHe5KXfsfpKg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;563&quot;/&gt;&lt;figcaption&gt;体验pro付费功能&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说这个插件已经很 nice 了，即使不用付费版本的功能，也可以满足基本的需求，而且这个功能在写业务时非常有用，大大提高工作效率，&lt;strong&gt;真的真的强烈推荐！！！！&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Preview.js&lt;/strong&gt;: https://previewjs.com/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;296&quot; data-ratio=&quot;0.5299270072992701&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/5Q3ZxrD2qNDvxh93JHfZD80m7GhBmGicoYpnLCanxmxvpVm4ACYNms63xnCgKt1Py5rvMCEDkWebYCTpfDVBq7g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;685&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong/&gt;&lt;strong&gt;&lt;span&gt;彦祖，亦菲，&lt;/span&gt;&lt;span&gt;点个&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;「在看」&lt;/strong&gt;&lt;span&gt;吧&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c224edd0cf03f5fdc9fbc0bd769d479</guid>
<title>字节序探析：大端与小端的比较</title>
<link>https://toutiao.io/k/zet8l08</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;今天谈谈一个重要的计算机概念，大家可能都听说过它，但是很少深究，那就是字节序（Endianness）。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.54875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2m9DuQjibpgDIyhib9ooRQYKUGdDUDgnghdHEPGUWmaOaWswbo8QHZibFZQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;一、概念&lt;/h2&gt;&lt;p&gt;字节序指的是，&lt;strong&gt;多字节数据的内存排列顺序&lt;/strong&gt;。这样说比较抽象，使用图形解释就很好懂。&lt;/p&gt;&lt;p&gt;内存好比一排房间，每个字节是一间房。每间房都有门牌号（内存地址），从0号开始，然后是1号、2号……&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mO9iaPl68A1L0bK9ZcerlslDgncwPicAuiaNw9WmyvCMhWnJSyd2GxhvOQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;612&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;0号字节的地址小，称为低位内存；3号字节的地址大，称为高位内存。&lt;/p&gt;&lt;p&gt;现在有一个数值&lt;code&gt;abcd&lt;/code&gt;要放进这些房间，每个房间放一个数字，那么有两种放法。&lt;/p&gt;&lt;p&gt;第一种放法是，第一位&lt;code&gt;a&lt;/code&gt;放在低位地址（0号），最后一位&lt;code&gt;d&lt;/code&gt;放在高位地址（3号）。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3028571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2m0CTXJn49WYLAWNkJZxhZZMEJZ3e2icgGZGVIs8chcBYQjAUIUTSsyFg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种排列称为“&lt;strong&gt;大端序&lt;/strong&gt;”（big-endian，简称 BE），即大头在前，因为&lt;code&gt;a&lt;/code&gt;是&lt;code&gt;abcd&lt;/code&gt;的大头（最重要的数字）。&lt;/p&gt;&lt;p&gt;第二种放法是，第一位&lt;code&gt;a&lt;/code&gt;放在高位地址（3号地址），最后一位&lt;code&gt;d&lt;/code&gt;放在低位地址（0号地址）。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3028571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mtMYYU906PQ896TNAvxZFHxZzOicicdl8RX8BzZMart4o2BYHrnJ9tpuQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;700&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种排列称为“&lt;strong&gt;小端序&lt;/strong&gt;”（little-endian，简称 LE），即小头&lt;code&gt;d&lt;/code&gt;在前。&lt;/p&gt;&lt;p&gt;大端序和小端序合称字节序，这两个名字来自18世纪的英国小说《格列佛游记》。某国分成两派，一派认为鸡蛋应该从大头吃起，称为“大端派”；另一派认为，鸡蛋应该从小头吃起，称为“小端派”。两派相执不下，谁也无法说服谁，最后甚至为此交战。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.66625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XjGG4txZI4GMa5LicRSoWlXxG898kMl2m8J8yfzl3JqQwjaxeNpSfqW8Gyn16fy49qxESEJFiapvO4kfnEq3RuaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;二、可读性&lt;/h2&gt;&lt;p&gt;对于人类来说，不同字节序的可读性是不一样的。大部分国家的阅读习惯是从左到右阅读。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mvYicadUkM3FibSowM0SPh9g3B9Dqo7pDGlgiabIA1Gwgx8tyBeeVoiaKRg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;大端序的最高位在左边，最低位在右边，符合阅读习惯。所以，对于这些国家的人来说，&lt;strong&gt;从左到右的大端序的可读性更好。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;但是现实中，从右到左的小端序虽然可读性差，但应用更广泛，x86 和 ARM 这两种 CPU 架构都采用小端序，这是为什么？&lt;/p&gt;&lt;p&gt;或者换一种问法，两种不同的字节序为什么会并存，统一规定只使用一种，难道不是更方便吗？&lt;/p&gt;&lt;p&gt;原因是它们有各自的适用场景，某些场景大端序有优势，另一些场景小端序有优势，下面就逐一分析。&lt;/p&gt;&lt;h2&gt;三、检查奇偶性&lt;/h2&gt;&lt;p&gt;小端序优势最明显的，大概就是检查奇偶性，即通过查看个位数，确定某个数字是奇数还是偶数。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.39172749391727496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mSNH9oZTojibR1pep2IVEne1lEmkpl7HpjBRAXjVK899VqBUpHcsQQPw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;411&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;以&lt;code&gt;123456&lt;/code&gt;为例，大端序从左到右排列，计算机必须一直读到最后一位的个位数&lt;code&gt;6&lt;/code&gt;，才能确定这是偶数。&lt;/p&gt;&lt;p&gt;小端序是从右到左排列，个位数在第一位。所以，只要读取第一位，就能确定它是偶数。&lt;/p&gt;&lt;h2&gt;四、检查正负号&lt;/h2&gt;&lt;p&gt;一个类似的场景是检查正负号，确定一个数是正数还是负数。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mX6gqBoiaPLUJBPg2Iz9kmrCMg892MxZEahrvMeGBZlpdeUH0XFtia1Zg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;500&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;大端序的符号位在左边第一位，小端序的符号位在右边最后一位。所以，大端序有优势，只看第一位就能知道是不是负数。&lt;/p&gt;&lt;h2&gt;五、比较大小&lt;/h2&gt;&lt;p&gt;下一个操作是比较大小。现在有三个数字，需要比较大小：43662576，594，2。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1407035175879396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mic2ibTcw5craSEmNWOK74nlTwt1OTwuDJVOLibEmlBRZzwJwxc7T0YZ2g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;199&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图是大端序排列，因为是从左到右排列，所以三个数字在右边个位数对齐。比较大小时，计算机就不得不读取每一个数的所有位，直到个位数，再进行比较。&lt;/p&gt;&lt;p&gt;如果改成小端序，就是下面的排列方式。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1573604060913705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mgFbF2DtE2nYFKZyNnIBW4sIZOh7XGbc0h9QPGbYyQJ3EhOlfhiacoZQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;197&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;小端序是从右到左，所以三个数字在第一位对齐。计算机就不需要读取所有位，哪个数字先读不到下一位，就是最小的。比如，&lt;code&gt;2&lt;/code&gt;这个数字就没有第二位，所以读到第二位时，就知道它是最小的。&lt;/p&gt;&lt;p&gt;所以，比较大小时，小端序有优势。&lt;/p&gt;&lt;h2&gt;六、乘法&lt;/h2&gt;&lt;p&gt;接下来，再看乘法操作。&lt;/p&gt;&lt;p&gt;乘法是逐位相乘，每一轮乘法都要向前进位。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0686015831134565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2my5icf0gq1aq5F7l62nmu83ibicUxWdLZwE4QrrWU60KbI3ZhMDsN4CBdw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;379&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图是大端序的24165乘以3841。大端序的乘法是向左进位，也就是向左边扩展，必须等到每一轮的结果都出来（上例是四轮），再相加统一写入内存。&lt;/p&gt;&lt;p&gt;如果改成小端序的乘法，就不需要等待下一轮的结果，每一轮都可以直接写入内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9331797235023042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mR1NCQwXVvKFnjbib9XUyzyibpMwAGnfrWQUbUGsmHLVse1hv7vV6ncdw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;434&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图是小端序的24165乘以3841。小端序的乘法是向右进位，也就是向右边扩展，左边的边界不变。每一轮结果写入内存后，就不需要移动，后面有变化只需要改动对应的位就行了。&lt;/p&gt;&lt;p&gt;因此，小端序的乘法有明显优势。&lt;/p&gt;&lt;h2&gt;七、任意精度整数&lt;/h2&gt;&lt;p&gt;上一个例子的从低位开始计算的特性，对于任意精度整数特别有用。任意精度整数又称大整数，可以存放任意大小的整数。&lt;/p&gt;&lt;p&gt;它的内部实现是把整数分成一个个较小的单位，通常是 uint32（无符号32位整数）或 uint64（无符号64位整数），按顺序组合在一起。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2m1Qy7xptHOBrheOCx4vezaRbdxwJcH8VwNTIrgRF3GOwkRPEbymiakjg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果是大端序，第一个 u64 就是这个整数最大的部分。运算时，一旦这个数发生变化，需要进位，后面的所有位都必须移动和改写。小端序发生进位时，往往就不需要所有位移动。&lt;/p&gt;&lt;p&gt;小端序的另一个好处是，如果逐字节的运算从个位数开始（比如乘法和加法），可以从左到右依次运算一个个 u64，算完上一个再读取下一个。大端序就不行，必须读取整个数以后再进行运算。&lt;/p&gt;&lt;h2&gt;八、更改类型&lt;/h2&gt;&lt;p&gt;最后一个例子是，C 语言有一种 cast 操作，可以强制改变变量的数据类型，比如把32位整数强行改变为16位整数。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.265&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/XjGG4txZI4GMa5LicRSoWlXxG898kMl2mgvgs0iaTKOCJbBkzawuf3D1GvQEFib8iaKwnvtdgcZ7NYMNFBGIEsyOSQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图中，32位整数&lt;code&gt;0x00000001&lt;/code&gt;更改为16位整数&lt;code&gt;0x0001&lt;/code&gt;，大端序是截去前面两个字节，这时指向这个地址的指针必须向后移动两个字节。&lt;/p&gt;&lt;p&gt;小端序就没有这个问题，截去的是后面两个字节，第一位的地址是不变的，所以指针不需要移动。&lt;/p&gt;&lt;h2&gt;九、总结&lt;/h2&gt;&lt;p&gt;综上所述，大端序和小端序各自的优势如下。&lt;/p&gt;&lt;p&gt;如果需要逐位运算，或者需要到从个位数开始运算，都是小端序占优势。反之，如果运算只涉及到高位，或者数据的可读性比较重要，则是大端序占优势。&lt;/p&gt;&lt;h2&gt;十、参考链接&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;On Endianness&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;, Karl Stenerud&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（完）&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; On Endianness: &lt;em&gt;https://www.technicalsourcery.net/posts/on-endianness/&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>