<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3fbb6d11de8c4031ee549c0bf35c3cff</guid>
<title>2022过虎年新年春节大门立体对联大礼包，点击链接立即领取红包！</title>
<link>https://toutiao.io/k/mfp3pig</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c818ac75b54a17047499a165f5c3f8ea</guid>
<title>[推荐] 据说看完这篇 JVM 要一小时</title>
<link>https://toutiao.io/k/1dauixx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 的主要作用是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;VM 就是 Java Virtual Machine（Java虚拟机）的缩写，JVM 屏蔽了与具体操作系统平台相关的信息，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码 （字节码），就可以在不同的平台上运行。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你描述一下 Java 的内存区域？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 在执行 Java 程序的过程中会把它管理的内存分为若干个不同的区域，这些组成部分有些是线程私有的，有些则是线程共享的，Java 内存区域也叫做运行时数据区，它的具体划分如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7437092264678472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmH9aGibGUjlxTy3le1caYkicpKl6nB2tvY37G39bUyIGSu4mzoScJZPbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1073&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;虚拟机栈&lt;/code&gt; : Java 虚拟机栈是线程私有的数据区，Java 虚拟机栈的生命周期与线程相同，虚拟机栈也是局部变量的存储位置。方法在执行过程中，会在虚拟机栈中创建一个 &lt;code&gt;栈帧(stack frame)&lt;/code&gt;。每个方法执行的过程就对应了一个入栈和出栈的过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7777777777777777&quot; data-type=&quot;jpeg&quot; data-w=&quot;315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm3dmdg7jW9BViaBNL5Z449GBOuMDwXfPPjiaSfQDnnTVSFiaO7Yvk0k8vQ/640?wx_fmt=jpeg&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;本地方法栈&lt;/code&gt;: 本地方法栈也是线程私有的数据区，本地方法栈存储的区域主要是 Java 中使用 &lt;code&gt;native&lt;/code&gt; 关键字修饰的方法所存储的区域。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;程序计数器&lt;/code&gt;：程序计数器也是线程私有的数据区，这部分区域用于存储线程的指令地址，用于判断线程的分支、循环、跳转、异常、线程切换和恢复等功能，这些都通过程序计数器来完成。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;方法区&lt;/code&gt;：方法区是各个线程共享的内存区域，它用于存储虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;堆&lt;/code&gt;：堆是线程共享的数据区，堆是 JVM 中最大的一块存储区域，所有的对象实例都会分配在堆上。JDK 1.7后，字符串常量池从永久代中剥离出来，存放在堆中。&lt;/p&gt;&lt;p&gt;堆空间的内存分配（默认情况下）：&lt;/p&gt;&lt;p&gt;命令行上执行如下命令，会查看默认的 JVM 参数。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintFlagsFinal -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出的内容非常多，但是只有两行能够反映出上面的内存分配结果&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.026957637997432605&quot; data-type=&quot;jpeg&quot; data-w=&quot;1558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmTE6mPvUkFS94GmjBPr6O6bibMdpkFjGVUZsNxDUoYwW0mxQMpfIQ8uQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.025348542458808618&quot; data-type=&quot;jpeg&quot; data-w=&quot;1578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmMbrkQujCzJ36ZRFUIAKxx4zUgksBDFdM0VPxGkG2BnCbY79TLRm1mQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.16066838046272494&quot; data-type=&quot;jpeg&quot; data-w=&quot;1556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmqSu2icmh4TXibVQP9VPw7gxtDoiblbmOBQJWuicnL1RYW0nw848aomFMzw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;eden 区：8/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;survivor 0 : 1/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;survivor 1 : 1/10 的年轻代空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代 ：三分之二的堆空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;年轻代 ：三分之一的堆空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;运行时常量池&lt;/code&gt;：运行时常量池又被称为 &lt;code&gt;Runtime Constant Pool&lt;/code&gt;，这块区域是方法区的一部分，它的名字非常有意思，通常被称为 &lt;code&gt;非堆&lt;/code&gt;。它并不要求常量一定只有在编译期才能产生，也就是并非编译期间将常量放在常量池中，运行期间也可以将新的常量放入常量池中，String 的 intern 方法就是一个典型的例子。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你描述一下 Java 中的类加载机制？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机负责把描述类的数据从 Class 文件加载到系统内存中，并对类的数据进行&lt;strong&gt;校验、转换解析和初始化&lt;/strong&gt;，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称之为 Java 的&lt;code&gt;类加载机制&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个类从被加载到虚拟机内存开始，到卸载出内存为止，一共会经历下面这些过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35430038510911427&quot; data-type=&quot;jpeg&quot; data-w=&quot;779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmhtUXSic00Bagu6DFhheVwHP2rV3V5FVOJezDXME6sy6ePBVxibFeicuzA/640?wx_fmt=jpeg&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载机制一共有五个步骤，分别是&lt;strong&gt;加载、链接、初始化、使用和卸载&lt;/strong&gt;阶段，这五个阶段的顺序是确定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中链接阶段会细分成三个阶段，分别是验证、准备、解析阶段，这三个阶段的顺序是不确定的，这三个阶段通常交互进行。解析阶段通常会在初始化之后再开始，这是为了支持 Java 语言的运行时绑定特性（也被称为&lt;code&gt;动态绑定&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来聊一下这几个过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加载&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于什么时候开始加载这个过程，《Java 虚拟机规范》并没有强制约束，所以这一点我们可以自由实现。加载是整个类加载过程的第一个阶段，在这个阶段，Java 虚拟机需要完成三件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将这个字节流表示的一种存储结构转换为运行时数据区中方法区的数据结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在内存中生成一个 Class 对象，这个对象就代表了这个数据结构的访问入口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 虚拟机规范》并未规定全限定名是如何获取的，所以现在业界有很多获取全限定名的方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 ZIP 包中读取，最终会改变为 JAR、EAR、WAR 格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从网络中获取，最常见的应用就是 Web Applet。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行时动态生成，使用最多的就是动态代理技术。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由其他文件生成，比如 JSP 应用场景，由 JSP 文件生成对应的 Class 文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库中读取，这种场景就比较小了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以从加密文件中获取，这是典型的防止 Class 文件被反编译的保护措施。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载阶段既可以使用虚拟机内置的引导类加载器来完成，也可以使用用户自定义的类加载器来完成。程序员可以通过自己定义类加载器来控制字节流的访问方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的加载不需要通过类加载器来创建，它是直接在内存中分配，但是数组的元素类型（数组去掉所有维度的类型）最终还是要靠类加载器来完成加载。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;验证&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加载过后的下一个阶段就是验证，因为我们上一步讲到在内存中生成了一个 Class 对象，这个对象是访问其代表数据结构的入口，所以这一步验证的工作就是确保 Class 文件的字节流中的内容符合《Java 虚拟机规范》中的要求，保证这些信息被当作代码运行后，它不会威胁到虚拟机的安全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段主要分为四个阶段的检验：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件格式验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元数据验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字节码验证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;符号引用验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段可能会包含下面这些验证点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;魔数是否以 &lt;code&gt;0xCAFEBABE&lt;/code&gt; 开头。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主、次版本号是否在当前 Java 虚拟机接受范围之内。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常量池的常量中是否有不支持的常量类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上验证点远远不止有这些，上面这些只是从 HotSpot 源码中摘抄的一小段内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;元数据验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段主要是对字节码描述的信息进行语义分析，以确保描述的信息符合《Java 语言规范》，验证点包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;验证的类是否有父类（除了 Object 类之外，所有的类都应该有父类）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要验证类的父类是否继承了不允许继承的类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这个类不是抽象类，那么这个类是否实现了父类或者接口中要求的所有方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否覆盖了 final 字段，是否出现了不符合规定的重载等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要记住这一阶段只是对《Java 语言规范》的验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字节码验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节码验证阶段是最复杂的一个阶段，这个阶段主要是确定程序语意是否合法、是否是符合逻辑的。这个阶段主要是对类的方法体（Class 文件中的 Code 属性）进行校验分析。这部分验证包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确保操作数栈的数据类型和实际执行时的数据类型是否一致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证任何跳转指令不会跳出到方法体外的字节码指令上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，但是不能把父类数据类型赋值给子类等诸如此不安全的类型转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有通过字节码验证，就说明验证出问题。但是不一定通过了字节码验证，就能保证程序是安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;符号引用验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个阶段的校验行为发生在虚拟机将符号引用转换为直接引用的时候，这个转化将在连接的第三个阶段，即解析阶段中发生。符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验，这个验证主要包括&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;符号引用中的字符串全限定名是否能找到对应的类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;符号引用的类、字段方法的可访问性是否可被当前类所访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他验证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一阶段主要是确保解析行为能否正常执行，如果无法通过符号引用验证，就会出现类似 &lt;code&gt;IllegalAccessError&lt;/code&gt;、&lt;code&gt;NoSuchFieldError&lt;/code&gt;、&lt;code&gt;NoSuchMethodError&lt;/code&gt; 等错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证阶段对于虚拟机来说非常重要，如果能通过验证，就说明你的程序在运行时不会产生任何影响。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;准备&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备阶段是为类中的变量分配内存并设置其初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，在 JDK 7 之前，HotSpot 使用永久代来实现方法区，是符合这种逻辑概念的。而在 JDK 8 之后，变量则会随着 Class 对象一起存放在 Java 堆中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面通常情况下的基本类型和引用类型的初始值&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4858548585485855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm1Ch67QbW54ydQnWYMxRXKPScMyEPg9vgJe5dnyDHS9LUd7E6xLjickA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;813&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了&quot;通常情况&quot;下，还有一些&quot;例外情况&quot;，如果类字段属性中存在 &lt;code&gt;ConstantValue&lt;/code&gt; 属性，那就这个变量值在初始阶段就会初始化为 ConstantValue 属性所指定的初始值，比如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = &lt;span&gt;&quot;666&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译时就会把 value 的值设置为 666。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;符号引用&lt;/code&gt;：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;直接引用&lt;/code&gt;：直接引用可以直接指向目标的指针、相对便宜量或者一个能间接定位到目标的句柄。直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样说你可能还有点不明白，我再换一种说法：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在编译的时候一个每个 Java 类都会被编译成一个 class 文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java 虚拟机规范》并未规定解析阶段发生的时间，只要求了在 anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 putstatic 这 17 个用于操作符号引用的字节码指令之前，先对所使用的符号引用进行解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析也分为四个步骤&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化是类加载过程的最后一个步骤，在之前的阶段中，都是由 Java 虚拟机占主导作用，但是到了这一步，却把主动权移交给应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于初始化阶段，《Java 虚拟机规范》严格规定了只有下面这六种情况下才会触发类的初始化。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在遇到 new、getstatic、putstatic 或者 invokestatic 这四条字节码指令时，如果没有进行过初始化，那么首先触发初始化。通过这四个字节码的名称可以判断，这四条字节码其实就两个场景，调用 new 关键字的时候进行初始化、读取或者设置一个静态字段的时候、调用静态方法的时候。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在初始化类的时候，如果父类还没有初始化，那么就需要先对父类进行初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在使用 java.lang.reflect 包的方法进行反射调用的时候。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当虚拟机启动时，用户需要指定执行主类的时候，说白了就是虚拟机会先初始化 main 方法这个类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在使用 JDK 7 新加入的动态语言支持时，如果一个 jafva.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getstatic、REF_putstatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，需要先对其进行初始化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面只有前四个大家需要知道就好了，后面两个比较冷门。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果说要回答&lt;/span&gt;&lt;span&gt;类加载的话，其实聊到这里已经可以了，但是为了完整性，我们索性把后面两个过程也来聊一聊。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段没什么可说的，就是初始化之后的代码由 JVM 来动态调用执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卸载&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当代表一个类的 Class 对象不再被引用，那么 Class 对象的生命周期就结束了，对应的在方法区中的数据也会被卸载。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;⚠️但是需要注意一点：JVM 自带的类加载器装载的类，是不会卸载的，由用户自定义的类加载器加载的类是可以卸载的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;在 JVM 中，对象是如何创建的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要回答对象是怎么创建的，我们一般想到的回答是直接 &lt;code&gt;new&lt;/code&gt; 出来就行了，这个回答不仅局限于编程中，也融入在我们生活中的方方面面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是遇到面试的时候你只回答一个&quot;new 出来就行了&quot;显然是不行的，因为面试更趋向于让你解释当程序执行到 new 这条指令时，它的背后发生了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你需要从 JVM 的角度来解释这件事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当虚拟机遇到一个 new 指令时（其实就是字节码），首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析和初始化。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为此时很可能不知道具体的类是什么，所以这里使用的是符号引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发现这个类没有经过上面类加载的过程，那么就执行相应的类加载过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类检查完成后，接下来虚拟机将会为新生对象&lt;strong&gt;分配内存&lt;/strong&gt;，对象所需的大小在类加载完成后便可确定（我会在下面的面试题中介绍）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分配内存相当于是把一块固定的内存块从堆中划分出来。划分出来之后，虚拟机会将分配到的内存空间都初始化为零值，如果使用了 &lt;code&gt;TLAB&lt;/code&gt;（本地线程分配缓冲），这一项初始化工作可以提前在 TLAB 分配时进行。这一步操作保证了对象实例字段在 Java 代码中可以不赋值就能直接使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，Java 虚拟机还会对对象进行必要的设置，比如确定对象是哪个类的实例、对象的 hashcode、对象的 gc 分代年龄信息。这些信息存放在对象的对象头（Object Header）中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的工作都做完后，从虚拟机的角度来说，一个新的对象就创建完毕了；但是对于程序员来说，对象创建才刚刚开始，因为构造函数，即 Class 文件中的 &lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt; 方法还没有执行，所有字段都为默认的零值。new 指令之后才会执行 &lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt; 方法，然后按照程序员的意愿对对象进行初始化，这样一个对象才可能被完整的构造出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存分配方式有哪些呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类加载完成后，虚拟机需要为新生对象分配内存，为对象分配内存相当于是把一块确定的区域从堆中划分出来，这就涉及到一个问题，&lt;strong&gt;要划分的堆区是否规整&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 Java 堆中内存是规整的，所有使用过的内存放在一边，未使用的内存放在一边，中间放着一个指针，这个指针为分界指示器。那么为新对象分配内存空间就相当于是把指针向空闲的空间挪动对象大小相等的距离，这种内存分配方式叫做&lt;code&gt;指针碰撞(Bump The Pointer)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Java 堆中的内存并不是规整的，已经被使用的内存和未被使用的内存相互交错在一起，这种情况下就没有办法使用指针碰撞，这里就要使用另外一种记录内存使用的方式：&lt;code&gt;空闲列表(Free List)&lt;/code&gt;，空闲列表维护了一个列表，这个列表记录了哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，上述两种分配方式选择哪个，取决于 Java 堆是否规整来决定。在一些垃圾收集器的实现中，Serial、ParNew 等带压缩整理过程的收集器，使用的是指针碰撞；而使用 CMS 这种基于清除算法的收集器时，使用的是空闲列表，具体的垃圾收集器我们后面会聊到。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你说一下对象的内存布局？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;hotspot&lt;/code&gt; 虚拟机中，对象在内存中的布局分为三块区域：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;对象头(Header)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;实例数据(Instance Data)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;对齐填充(Padding)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三块区域的内存分布如下图所示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5553892215568862&quot; data-type=&quot;jpeg&quot; data-w=&quot;668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmwt0GFv70dlvtZVDNGSlN1va4spbg2Jib3RsZibIY59DMSdsRAsIGBFJg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来详细介绍一下上面对象中的内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对象头 Header&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象头 Header 主要包含 MarkWord 和对象指针 Klass Pointer，如果是数组的话，还要包含数组的长度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16253101736972705&quot; data-type=&quot;jpeg&quot; data-w=&quot;806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmdSiazv22SSjqa9qTicdtOaqEU6ysPu1aPm0ia5E9DJk5JUY1ibSGaKGwww/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位的虚拟机中 MarkWord ，Klass Pointer 和数组长度分别占用 32 位，也就是 4 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是 64 位虚拟机的话，MarkWord ，Klass Pointer 和数组长度分别占用 64 位，也就是 8 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 32 位虚拟机和 64 位虚拟机的 Mark Word 所占用的字节大小不一样，32 位虚拟机的 Mark Word 和 Klass Pointer 分别占用 32 bits 的字节，而 64 位虚拟机的 Mark Word 和 Klass Pointer 占用了64 bits 的字节，下面我们以 32 位虚拟机为例，来看一下其 Mark Word 的字节具体是如何分配的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7952261306532663&quot; data-type=&quot;jpeg&quot; data-w=&quot;796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmF7oQ1WDXyWnQ2vctT5zLDibH4A11ZOVQb9H7aSbaKVu9WHOLyicRR4YA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用中文翻译过来就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5868102288021534&quot; data-type=&quot;jpeg&quot; data-w=&quot;743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmFkK8j9Zq4XVUHHKwFaqiarAJmvDobibvjDTjojGFve00zwh3zjso09bQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无状态也就是&lt;code&gt;无锁&lt;/code&gt;的时候，对象头开辟 25 bit 的空间用来存储对象的 hashcode ，4 bit 用于存放分代年龄，1 bit 用来存放是否偏向锁的标识位，2 bit 用来存放锁标识位为 01。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;偏向锁&lt;/code&gt; 中划分更细，还是开辟 25 bit 的空间，其中 23 bit 用来存放线程ID，2bit 用来存放 epoch，4bit 存放分代年龄，1 bit 存放是否偏向锁标识， 0 表示无锁，1 表示偏向锁，锁的标识位还是 01。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;轻量级锁&lt;/code&gt;中直接开辟 30 bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为 00。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;重量级锁&lt;/code&gt;中和轻量级锁一样，30 bit 的空间用来存放指向重量级锁的指针，2 bit 存放锁的标识位，为 11&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;GC标记&lt;/code&gt;开辟 30 bit 的内存空间却没有占用，2 bit 空间存放锁标志位为 11。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1 bit 区分了这是无锁状态还是偏向锁状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于为什么这么分配的内存，我们可以从 &lt;code&gt;OpenJDK&lt;/code&gt; 中的markOop.hpp类中的枚举窥出端倪&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27560050568900124&quot; data-type=&quot;jpeg&quot; data-w=&quot;791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm96eGhUyYOWB0aUCSkb4KQZPHEI2gDibq9Pia7nOsNP3jvusH9G9uNDQg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来解释一下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;age_bits 就是我们说的分代回收的标识，占用4字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lock_bits 是锁的标志位，占用2个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;biased_lock_bits 是是否偏向锁的标识，占用1个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;max_hash_bits 是针对无锁计算的 hashcode 占用字节数量，如果是 32 位虚拟机，就是 32 - 4 - 2 -1 = 25 byte，如果是 64 位虚拟机，64 - 4 - 2 - 1 = 57 byte，但是会有 25 字节未使用，所以 64 位的 hashcode 占用 31 byte。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hash_bits 是针对 64 位虚拟机来说，如果最大字节数大于 31，则取 31，否则取真实的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cms_bits 我觉得应该是不是 64 位虚拟机就占用 0 byte，是 64 位就占用 1byte&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;epoch_bits 就是 epoch 所占用的字节大小，2 字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的虚拟机对象头分配表中，我们可以看到有几种锁的状态：无锁（无状态），偏向锁，轻量级锁，重量级锁，其中轻量级锁和偏向锁是 JDK1.6 中对 synchronized 锁进行优化后新增加的，其目的就是为了大大优化锁的性能，所以在 JDK 1.6 中，使用 synchronized 的开销也没那么大了。其实从锁有无锁定来讲，还是只有无锁和重量级锁，偏向锁和轻量级锁的出现就是增加了锁的获取性能而已，并没有出现新的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们的重点放在对 synchronized 重量级锁的研究上，当 monitor 被某个线程持有后，它就会处于锁定状态。在 HotSpot 虚拟机中，monitor 的底层代码是由 &lt;code&gt;ObjectMonitor&lt;/code&gt; 实现的，其主要数据结构如下（位于 HotSpot 虚拟机源码 ObjectMonitor.hpp 文件，C++ 实现的）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6672413793103448&quot; data-type=&quot;jpeg&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmibCm80Ch6SkLdCI5t5WWf9dyyA6ONK72jhw1KVa0M2ZF0ibo76dC29TQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段 C++ 中需要注意几个属性：_WaitSet 、 _EntryList 和 _Owner，每个等待获取锁的线程都会被封装称为 &lt;code&gt;ObjectWaiter&lt;/code&gt; 对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15234375&quot; data-type=&quot;jpeg&quot; data-w=&quot;768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmk3YshTalB5Hwd6Fiar6GlZcynMNp8jPFTMXAQYL5vOY7EBsuEUcAAQw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;_Owner 是指向了 ObjectMonitor 对象的线程，而 _WaitSet 和 _EntryList 就是用来保存每个线程的列表。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么这两个列表有什么区别呢？这个问题我和你聊一下锁的获取流程你就清楚了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁的两个列表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多个线程同时访问某段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的 monitor 之后，就会进入 _Owner 区域，并把 ObjectMonitor 对象的 _Owner 指向为当前线程，并使 _count + 1，如果调用了释放锁（比如 wait）的操作，就会释放当前持有的 monitor ，owner = null， _count - 1，同时这个线程会进入到 _WaitSet 列表中等待被唤醒。如果当前线程执行完毕后也会释放 monitor 锁，只不过此时不会进入 _WaitSet 列表了，而是直接复位 _count 的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5186721991701245&quot; data-type=&quot;jpeg&quot; data-w=&quot;723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmBkaHmIEibGZQNYvZxKVI44KjHm6f8h97E8lQ5QReUfjGyicIdKDvfqaQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Klass Pointer 表示的是类型指针，也就是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你可能不是很理解指针是个什么概念，你可以简单理解为指针就是指向某个数据的地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24173553719008264&quot; data-type=&quot;jpeg&quot; data-w=&quot;484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmg07SkwDltzz9neeE2KaZendKZ6fXemgDZkicSJDj0c550jUZsbkmribA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实例数据 Instance Data&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例数据部分是对象真正存储的有效信息，也是代码中定义的各个字段的字节大小，比如一个 byte 占 1 个字节，一个 int 占用 4 个字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对齐 Padding&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对齐不是必须存在的，它只起到了占位符(%d, %c 等)的作用。这就是 JVM 的要求了，因为 HotSpot JVM 要求对象的起始地址必须是 8 字节的整数倍，也就是说对象的字节大小是 8 的整数倍，不够的需要使用 Padding 补全。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对象访问定位的方式有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个对象的目的当然就是为了使用它，但是，一个对象被创建出来之后，在 JVM 中是如何访问这个对象的呢？一般有两种方式：&lt;strong&gt;通过句柄访问&lt;/strong&gt;和 &lt;strong&gt;通过直接指针访问&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果使用句柄访问方式的话，Java 堆中可能会划分出一块内存作为句柄池，引用（reference）中存储的是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自具体的地址信息。如下图所示。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5897079276773296&quot; data-type=&quot;jpeg&quot; data-w=&quot;719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmHgibj2NpibuUa5q2waiaW1IBIibGSVCLo0PK24xS5o9JIhvHTJ2av06Vvw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果使用直接指针访问的话，Java 堆中对象的内存布局就会有所区别，栈区引用指示的是堆中的实例数据的地址，如果只是访问对象本身的话，就不会多一次直接访问的开销，而对象类型数据的指针是存在于方法区中，如果定位的话，需要多一次直接定位开销。如下图所示&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5730180806675939&quot; data-type=&quot;jpeg&quot; data-w=&quot;719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmBv2RUQEwedibWN6J1au1sNtv7CwytYs7jsgv6McosWQ6ZKkyZzpRohA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种对象访问方式各有各的优势，使用句柄最大的好处就是引用中存储的是句柄地址，对象移动时只需改变句柄的地址就可以，而无需改变对象本身。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用直接指针来访问速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因为这类的开销也是值得优化的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面聊到了对象的两种数据，一种是对象的实例数据，这没什么好说的，就是对象实例字段的数据，一种是对象的类型数据，这个数据说的是对象的类型、父类、实现的接口和方法等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何判断对象已经死亡？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大家知道，基本上所有的对象都在堆中分布，当我们不再使用对象的时候，垃圾收集器会对无用对象进行回收♻️，那么 JVM 是如何判断哪些对象已经是&quot;无用对象&quot;的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两种判断方式，首先我们先来说第一种：&lt;strong&gt;引用计数法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数法的判断标准是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就会加一；当引用失效时，计数器的值就会减一；只要任何时刻计数器为零的对象就是不会再被使用的对象。虽然这种判断方式非常简单粗暴，但是往往很有用，不过，在 Java 领域，主流的 Hotspot 虚拟机实现并没有采用这种方式，因为引用计数法不能解决对象之间的循环引用问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;循环引用问题简单来讲就是两个对象之间互相依赖着对方，除此之外，再无其他引用，这样虚拟机无法判断引用是否为零从而进行垃圾回收操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种判断对象无用的方法就是&lt;strong&gt;可达性分析算法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前主流的 JVM 都采用了可达性分析算法来进行判断，这个算法的基本思路就是通过一系列被称为&lt;code&gt;GC Roots&lt;/code&gt;的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径被称为&lt;code&gt;引用链&lt;/code&gt;（Reference Chain），如果某个对象到 GC Roots 之间没有任何引用链相连接，或者说从 GC Roots 到这个对象不可达时，则证明此这个对象是无用对象，需要被垃圾回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引用方式如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6780626780626781&quot; data-type=&quot;jpeg&quot; data-w=&quot;702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmibo27syf4OQQJTcBLlJd8qGxwuGFhVdBNvfpxiaPZg1Cz6aozFz22hdw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，从枚举根节点 GC Roots 开始进行遍历，object 1 、2、3、4 是存在引用关系的对象，而 object 5、6、7 之间虽然有关联，但是它们到 GC Roots 之间是不可达的，所以被认为是可以回收的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 技术体系中，可以作为 GC Roots 进行检索的对象主要有&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方法区中类静态属性引用的对象，比如 Java 类的引用类型静态变量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;方法区中常量引用的对象，比如字符串常量池中的引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在本地方法栈中 JNI 引用的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM 内部的引用，比如基本数据类型对应的 Class 对象，一些异常对象比如 NullPointerException、OutOfMemoryError 等，还有系统类加载器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;所有被 synchronized 持有的对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;还有一些 JVM 内部的比如 JMXBean、JVMTI 中注册的回调，本地代码缓存等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据用户所选的垃圾收集器以及当前回收的内存区域的不同，还可能会有一些对象临时加入，共同构成 GC Roots 集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们上面提到了两种判断对象回收的方法，但无论是引用计数法还是判断 GC Roots 都离不开&lt;code&gt;引用&lt;/code&gt;这一层关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里涉及到到强引用、软引用、弱引用、虚引用的引用关系，你可以阅读作者的这一篇文章&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;amp;mid=2247495968&amp;amp;idx=1&amp;amp;sn=48de091f4fabdf682a9f8b5ddd8db936&amp;amp;chksm=c04ae67ef73d6f68935382dcaa0bd4d538a9e0b45ee49500ee7e2356cc24dba750b197960477&amp;amp;token=1191632986&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;小心点，别被当成垃圾回收了。&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何判断一个不再使用的类？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断一个类型属于&quot;不再使用的类&quot;需要满足下面这三个条件&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个类所有的实例已经被回收，也就是 Java 堆中不存在该类及其任何这个类字类的实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载这个类的类加载器已经被回收，但是类加载器一般很难会被回收，除非这个类加载器是为了这个目的设计的，比如 OSGI、JSP 的重加载等，否则通常很难达成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个类对应的 Class 对象没有任何地方被引用，无法在任何时刻通过反射访问这个类的属性和方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机允许对满足上面这三个条件的无用类进行回收操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM 分代收集理论有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般商业的虚拟机，大多数都遵循了&lt;strong&gt;分代收集&lt;/strong&gt;的设计思想，分代收集理论主要有两条假说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个是&lt;strong&gt;强分代假说&lt;/strong&gt;，强分代假说指的是 JVM 认为绝大多数对象的生存周期都是朝生夕灭的；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个是&lt;strong&gt;弱分代假说&lt;/strong&gt;，弱分代假说指的是只要熬过越多次垃圾收集过程的对象就越难以回收（看来对象也会长心眼）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是基于这两个假说理论，JVM 将&lt;code&gt;堆&lt;/code&gt;区划分为不同的区域，再将需要回收的对象根据其熬过垃圾回收的次数分配到不同的区域中存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JVM 根据这两条分代收集理论，把堆区划分为新生代(Young Generation)和&lt;/span&gt;&lt;span&gt;老年代(Old Generation)这两个区域。&lt;/span&gt;&lt;span&gt;在新生代中，每次垃圾收集时都发现有大批对象死去，剩下没有死去的对象会直接晋升到老年代中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这两个假说没有考虑对象的引用关系，而事实情况是，对象之间会存在引用关系，基于此又诞生了第三个假说，即&lt;strong&gt;跨代引用假说(Intergeneration Reference Hypothesis)&lt;/strong&gt;，跨代引用相比较同代引用来说仅占少数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常来说存在相互引用的两个对象应该是同生共死的，不过也会存在特例，如果一个新生代对象跨代引用了一个老年代的对象，那么垃圾回收的时候就不会回收这个新生代对象，更不会回收老年代对象，然后这个新生代对象熬过一次垃圾回收进入到老年代中，这时候跨代引用才会消除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据跨代引用假说，我们不需要因为老年代中存在少量跨代引用就去直接扫描整个老年代，也不用在老年代中维护一个列表记录有哪些跨代引用，实际上，可以直接在新生代中维护一个&lt;strong&gt;记忆集(Remembered Set)&lt;/strong&gt;，由这个记忆集把老年代划分称为若干小块，标识出老年代的哪一块会存在跨代引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记忆集的图示如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3736842105263158&quot; data-type=&quot;jpeg&quot; data-w=&quot;760&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmjJ9x4892ccaD2Cks5hjiaHRXH9TrbWR5DibfOPPrcgs1CTjKKX67PWrA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到，记忆集中的每个元素分别对应内存中的一块连续区域是否有跨代引用对象，如果有，该区域会被标记为“脏的”（dirty），否则就是“干净的”（clean）。这样在垃圾回收时，只需要扫描记忆集就可以简单地确定跨代引用的位置，是个典型的空间换时间的思路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;聊一聊 JVM 中的垃圾回收算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在聊具体的垃圾回收算法之前，需要明确一点，哪些对象需要被垃圾收集器进行回收？也就是说需要先判断哪些对象是&quot;垃圾&quot;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断的标准我在上面&lt;strong&gt;如何判断对象已经死亡&lt;/strong&gt;的问题中描述了，有两种方式，一种是引用计数法，这种判断标准就是给对象添加一个引用计数器，引用这个对象会使计数器的值 + 1，引用失效后，计数器的值就会 -1。但是这种技术无法解决对象之间的循环引用问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种方式是 GC Roots，GC Roots 这种方式是以 Root 根节点为核心，逐步向下搜索每个对象的引用，搜索走过的路径被称为引用链，如果搜索过后这个对象不存在引用链，那么这个对象就是无用对象，可以被回收。GC Roots 可以解决循环引用问题，所以一般 JVM 都采用的是这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决循环引用代码描述：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[]args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        A a = &lt;span&gt;new&lt;/span&gt; A();&lt;br/&gt;        B b = &lt;span&gt;new&lt;/span&gt; B();&lt;br/&gt;        a=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        b=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; B b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; A a;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 GC Roots 的这种思想，发展出了很多垃圾回收算法，下面我们就来聊一聊这些算法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-清除算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除(Mark-Sweep)这个算法可以说是最早最基础的算法了，标记-清除顾名思义分为两个阶段，即标记和清除阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。当然也可以标记存活的对象，回收未被标记的对象。这个标记的过程就是垃圾判定的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续大部分垃圾回收算法都是基于标记-算法思想衍生的，只不过后续的算法弥补了标记-清除算法的缺点，那么它有什么缺点呢？主要有两个&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;执行效率不稳定&lt;/strong&gt;，因为假如说堆中存在大量无用对象，而且大部分需要回收的情况下，这时必须进行大量的标记和清除，导致标记和清除这两个过程的执行效率随对象的数量增长而降低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存碎片化&lt;/strong&gt;，标记-清除算法会在堆区产生大量不连续的内存碎片。碎片太多会导致在分配大对象时没有足够的空间，不得不进行一次垃圾回收操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记算法的示意图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6547277936962751&quot; data-type=&quot;jpeg&quot; data-w=&quot;698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm8AemwmWaUPnRysSxqyplddlib4UjMRJiadSqMxK049A1snJyxaBj3GoA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-复制算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于标记-清除算法极易产生内存碎片，研究人员提出了标记-复制算法，标记-复制算法也可以简称为复制算法，复制算法是一种&lt;strong&gt;半区复制&lt;/strong&gt;，它会将内存大小划分为相等的两块，每次只使用其中的一块，用完一块再用另外一块，然后再把用过的一块进行清除。虽然解决了部分内存碎片的问题，但是复制算法也带来了新的问题，即&lt;strong&gt;复制开销&lt;/strong&gt;，不过这种开销是可以降低的，如果内存中大多数对象是无用对象，那么就可以把少数的存活对象进行复制，再回收无用的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过复制算法的缺陷也是显而易见的，那就是内存空间缩小为原来的一半，空间浪费太明显。标记-复制算法示意图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.598937583001328&quot; data-type=&quot;jpeg&quot; data-w=&quot;753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYm82CwrSX0SzxshZPJ7XpofasKBOBgicWOkg328AeIKLXn1qOqK8FDIZw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在 Java 虚拟机大多数都是用了这种算法来回收新生代，因为经过研究表明，新生代对象 98% 都熬不过第一轮收集，因此不需要按照 1 ：1 的比例来划分新生代的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，研究人员提出了一种 Appel 式回收，Appel 式回收的具体做法是把新生代分为一块较大的 &lt;em&gt;Eden&lt;/em&gt; 空间和两块 &lt;em&gt;Survivor&lt;/em&gt; 空间，每次分配内存都只使用 Eden 和其中的一块 Survivor 空间，发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已使用过的 Survivor 空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主流的 HotSpot 虚拟机中，默认的 Eden 和 Survivor 大小比例是 8：1，也就是每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间，所以会浪费掉 10% 的空间。这个 8：1 只是一个理论值，也就是说，不能保证每次都有不超过 10% 的对象存活，所以，当进行垃圾回收后如果 Survivor 容纳不了可存活的对象后，就需要其他内存空间来进行&lt;strong&gt;帮助&lt;/strong&gt;，这种方式就叫做&lt;strong&gt;内存担保(Handle Promotion)&lt;/strong&gt; ，通常情况下，作为担保的是老年代。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标记-整理算法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法虽然解决了内存碎片问题，但是没有解决复制对象存在大量开销的问题。为了解决复制算法的缺陷，充分利用内存空间，提出了标记-整理算法。该算法标记阶段和标记-清除一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6557142857142857&quot; data-type=&quot;jpeg&quot; data-w=&quot;700&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmFBJDpzuH8wmQMDM4kVXrSdTQ6fcYVjJpx56uCj7o0mU1WAWsD6H7Aw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是记忆集，什么是卡表？记忆集和卡表有什么关系？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决跨代引用问题，提出了记忆集这个概念，记忆集是一个在新生代中使用的数据结构，它相当于是记录了一些指针的集合，指向了老年代中哪些对象存在跨代引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记忆集的实现有不同的粒度&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;字长精度&lt;/strong&gt;：每个记录精确到一个字长，机器字长就是处理器的寻址位数，比如常见的 32 位或者 64 位处理器，这个精度决定了机器访问物理内存地址的指针长度，字中包含跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;对象精度&lt;/strong&gt;：每个记录精确到一个对象，该对象里含有跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;卡精度&lt;/strong&gt;：每个记录精确到一块内存区域，区域内含有跨代指针。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中卡精度是使用了卡表作为记忆集的实现，关于记忆集和卡表的关系，大家可以想象成是 HashMap 和 Map 的关系。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是卡页？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卡表其实就是一个字节数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CARD_TABLE[&lt;span&gt;this&lt;/span&gt; address &amp;gt;&amp;gt; &lt;span&gt;9&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节数组 CARD_TABLE 的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块就是&lt;strong&gt;卡页&lt;/strong&gt;，一般来说，卡页都是 2 的 N 次幂字节数，通过上面的代码我们可以知道，卡页一般是 2 的 9 次幂，这也是 HotSpot 中使用的卡页，即 512 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个卡页的内存通常包含不止一个对象，只要卡页中有一个对象的字段存在跨代指针，那就将对应卡表的数组元素的值设置为 1，称之为这个元素变&lt;code&gt;脏&lt;/code&gt;了，没有标示则为 0 。在垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，然后把他们加入 GC Roots 进行扫描。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，卡页和卡表主要用来解决跨代引用问题的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是写屏障？写屏障带来的问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有其他分代区域中对象引用了本区域的对象，那么其对应的卡表元素就会变脏，这个引用说的就是对象赋值，也就是说卡表元素会变脏发生在对象赋值的时候，那么如何在对象赋值的时候更新维护卡表呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 HotSpot 虚拟机中使用的是&lt;strong&gt;写屏障(Write Barrier)&lt;/strong&gt; 来维护卡表状态的，这个写屏障和我们内存屏障完全不同，希望读者不要搞混了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个写屏障其实就是一个 Aop 切面，在引用对象进行赋值时会产生一个&lt;strong&gt;环形通知(Around)&lt;/strong&gt;，环形通知就是切面前后分别产生一个通知，因为这个又是写屏障，所以在赋值前的部分写屏障叫做写前屏障，在赋值后的则叫做写后屏障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写屏障会带来两个问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无条件写屏障带来的性能开销&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，扫描整个老年代相比较，这个开销就低得多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，在高并发环境下，写屏障又带来了伪共享（false sharing）问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高并发下伪共享带来的性能开销&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发情况下，频繁的写屏障很容易发生伪共享（false sharing），从而带来性能开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 CPU 缓存行大小为 64 字节，由于一个卡表项占 1 个字节，这意味着，64 个卡表项将共享同一个缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot 每个卡页为 512 字节，那么一个缓存行将对应 64 个卡页一共 64*512 = 32K B。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不同线程对对象引用的更新操作，恰好位于同一个 32 KB 区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为脏的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 JDK  7 中引入的解决方法，引入了一个新的 JVM 参数 &lt;em&gt;-XX:+UseCondCardMark&lt;/em&gt;，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单理解如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (CARD_TABLE [this address &amp;gt;&amp;gt; 9] != 0)&lt;br/&gt;  CARD_TABLE [this address &amp;gt;&amp;gt; 9] = 0;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与原来的实现相比，只是简单的增加了一个判断操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然开启 &lt;em&gt;-XX:+UseCondCardMark&lt;/em&gt; 之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现伪共享问题（false sharing）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是三色标记法？三色标记法会造成哪些问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据可达性算法的分析可知，如果要找出存活对象，需要从 GC Roots 开始遍历，然后搜索每个对象是否可达，如果对象可达则为存活对象，在 GC Roots 的搜索过程中，按照&lt;strong&gt;对象和其引用是否被访问过&lt;/strong&gt;这个条件会分成下面三种颜色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;白色：白色表示 GC Roots 的遍历过程中没有被访问过的对象，出现白色显然在可达性分析刚刚开始的阶段，这个时候所有对象都是白色的，如果在分析结束的阶段，仍然是白色的对象，那么代表不可达，可以进行回收。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灰色：灰色表示对象已经被访问过，但是这个对象的引用还没有访问完毕。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;黑色：黑色表示此对象已经被访问过了，而且这个对象的引用也已经被访问了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三色标记法会造成两种问题，这两种问题所出现的环境都是由于&lt;strong&gt;用户环境和收集器并行工作造成的&lt;/strong&gt; 。当用户线程正在修改引用关系，此时收集器在回收引用关系，此时就会造成把原本已经消亡的对象标记为存活，如果出现这种状况的话，问题不大，下次再让收集器重新收集一波就完了，但是还有一种情况是把存活的对象标记为死亡，这种状况就会造成不可预知的后果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上面这两种对象消失问题，业界有两种处理方式，一种是&lt;strong&gt;增量更新(Incremental Update)&lt;/strong&gt; ，一种是&lt;strong&gt;原是快照(Snapshot At The Beginning, SATB)&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请你介绍一波垃圾收集器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器是面试的常考，也是必考点，只要涉及到 JVM 的相关问题，都会围绕着垃圾收集器来做一波展开，所以，有必要了解一下这些垃圾收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器有很多，不同商家、不同版本的 JVM 所提供的垃圾收集器可能会有很大差别，我们主要介绍 HotSpot 虚拟机中的垃圾收集器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾收集器是垃圾回收算法的具体实现，我们上面提到过，垃圾回收算法有标记-清除算法、标记-整理、标记-复制，所以对应的垃圾收集器也有不同的实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，HotSpot 虚拟机中的垃圾收集都是分代回收的，所以根据不同的分代，可以把垃圾收集器分为&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代收集器：Serial、ParNew、Parallel Scavenge；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老年代收集器：Serial Old、Parallel Old、CMS；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整堆收集器：G1；&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Serial 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Serial 收集器是一种新生代的垃圾收集器，它是一个单线程工作的收集器，使用复制算法来进行回收，单线程工作不是说这个垃圾收集器只有一个，而是说这个收集器在工作时，必须暂停其他所有工作线程，这种暴力的暂停方式就是 &lt;strong&gt;Stop The World&lt;/strong&gt;，Serial 就好像是寡头垄断一样，只要它一发话，其他所有的小弟（线程）都得给它让路。Serial 收集器的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5209059233449478&quot; data-type=&quot;jpeg&quot; data-w=&quot;574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmZ3BbmNV9XmU92S53CoX5j4bSEticcJt77oYXQAqpicLRFmA7cBZVsXMg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;SefePoint 全局安全点：它就是代码中的一段特殊的位置，在所有用户线程到达 SafePoint 之后，用户线程挂起，GC 线程会进行清理工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Serial 有 STW 这种显而易见的缺点，不过，从其他角度来看，Serial 还是很讨喜的，它还有着优于其他收集器的地方，那就是简单而高效，对于内存资源首先的环境，它是所有收集器中额外内存消耗最小的，对于单核处理器或者处理器核心较少的环境来说，Serial 收集器由于没有线程交互开销，所以 Serial 专心做垃圾回收效率比较高。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ParNew 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ParNew 是 Serial 的多线程版本，除了同时使用多条线程外，其他参数和机制（STW、回收策略、对象分配规则）都和 Serial 完全一致，ParNew 收集器的示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5993150684931506&quot; data-type=&quot;jpeg&quot; data-w=&quot;584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmPxHcC0semKUibicnjjuSjSkbo8VXdpcs3yZPBw3IQc71u25f8u54iabIw/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 ParNew 使用了多条线程进行垃圾回收，但是在单线程环境下它绝对不会比 Serial 收集效率更高，因为多线程存在线程交互的开销，但是随着可用 CPU 核数的增加，ParNew 的处理效率会比 Serial 更高效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Parallel Scavenge 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的，而且它也能够并行收集，这么看来，表面上 Parallel Scavenge 与 ParNew 非常相似，那么它们之间有什么区别呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Parallel Scavenge 的关注点主要在&lt;strong&gt;达到一个可控制的吞吐量上面&lt;/strong&gt;。吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比。也就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17894736842105263&quot; data-type=&quot;jpeg&quot; data-w=&quot;665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmscYdWaDzFkxkO3WPSDB9v2OQSHecPmiauKjCEDZyBhmOCLE40bMVETQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给大家举一个吞吐量的例子，如果执行用户代码的时间 + 运行垃圾收集的时间总共耗费了 100 分钟，其中垃圾收集耗费掉了 1 分钟，那么吞吐量就是 99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量，良好的响应速度可以提升用户体验，而高吞吐量可以最高效率利用处理器资源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Serial Old 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍了一下 Serial，我们知道它是一个新生代的垃圾收集，使用了标记-复制算法。而这个 Serial Old 收集器却是 Serial 的老年版本，它同样也是一个单线程收集器，使用的是&lt;strong&gt;标记-整理&lt;/strong&gt;算法，Serial Old 收集器有两种用途：一种是在 JDK 5 和之前的版本与 Parallel Scavenge 收集器搭配使用，另外一种用法就是作为 &lt;code&gt;CMS&lt;/code&gt; 收集器的备选，CMS 垃圾收集器我们下面说，Serial Old 的收集流程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4251207729468599&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmsr5qnsJKzjvNXjXNCrib8u5HbWlEUWwNPadXLAib7wYHnDL1QP9Gq7jg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Parallel Old 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们介绍了 Parallel Scavenge 收集器，现在来介绍一下 Parallel Old 收集器，它是 Parallel Scavenge 的老年版本，支持多线程并发收集，基于标记 - 整理算法实现，JDK 6 之后出现，吞吐量优先可以考虑 Parallel Scavenge + Parallel Old 的搭配&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43103448275862066&quot; data-type=&quot;jpeg&quot; data-w=&quot;812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmmumuGg3XajNzH8jGictWpG83p0CcRbfoic3OI0dlEsMqZiawe6Ww2jS4Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CMS 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CMS&lt;/code&gt;收集器的主要目标是获取最短的回收停顿时间，它的全称是 &lt;em&gt;Concurrent Mark Sweep&lt;/em&gt;，从这个名字就可以知道，这个收集器是基于标记 - 清除算法实现的，而且支持并发收集，它的运行过程要比上面我们提到的收集器复杂一些，它的工作流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始标记（CMS initial mark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发标记（CMS concurrent mark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新标记（CMS remark）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发清除（CMS concurrent sweep）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于上面这四个步骤，初始标记和并发标记都需要 &lt;em&gt;Stop The World&lt;/em&gt;，初始标记只是标记一下和 GC Roots 直接关联到的对象，速度较快；并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程。这个过程时间比较长但是不需要停顿用户线程，也就是说与垃圾收集线程一起并发运行。并发标记的过程中，可能会有错标或者漏标的情况，此时就需要在重新标记一下，最后是并发清除阶段，清理掉标记阶段中判断已经死亡的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS 的收集过程如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3606936416184971&quot; data-type=&quot;jpeg&quot; data-w=&quot;865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmfffkneclx5D1bAnFbSukKgEWYScjqsrxYZwmMBkvOy4Nkib9tPEOaGQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS 是一款非常优秀的垃圾收集器，但是没有任何收集器能够做到完美的程度，CMS 也是一样，CMS 至少有三个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 对处理器资源非常敏感，在并发阶段，虽然不会造成用户线程停顿，但是却会因为占用一部分线程而导致应用程序变慢，降低总吞吐量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 无法处理&lt;strong&gt;浮动垃圾&lt;/strong&gt;，有可能出现&lt;em&gt;Concurrent Mode Failure&lt;/em&gt;失败进而导致另一次完全 &lt;em&gt;Stop The World&lt;/em&gt;的 &lt;em&gt;Full GC&lt;/em&gt; 产生。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是浮动垃圾呢？由于并发标记和并发清理阶段，用户线程仍在继续运行，所以程序自然而然就会伴随着新的垃圾不断出现，而且这一部分垃圾出现在标记结束之后，CMS 无法处理这些垃圾，所以只能等到下一次垃圾回收时在进行清理。这一部分垃圾就被称为浮动垃圾。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CMS 最后一个缺点是并发-清除的通病，也就是会有大量的空间碎片出现，这将会给分配大对象带来困难。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Garbage First 收集器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Garbage First 又被称为 &lt;em&gt;G1 收集器&lt;/em&gt;，它的出现意味着垃圾收集器走过了一个里程碑，为什么说它是里程碑呢？因为 G1 这个收集器是一种面向局部的垃圾收集器，HotSpot 团队开发这个垃圾收集器为了让它替换掉 CMS 收集器，所以到后来，JDK 9 发布后，G1 取代了 Parallel Scavenge + Parallel Old 组合，成为服务端默认的垃圾收集器，而 CMS 则不再推荐使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的垃圾收集器存在回收区域的局限性，因为之前这些垃圾收集器的目标范围要么是整个新生代、要么是整个老年代，要么是整个 Java 堆（Full GC），而 G1 跳出了这个框架，它可以面向堆内存的任何部分来组成&lt;strong&gt;回收集(Collection Set，CSet)&lt;/strong&gt;，衡量垃圾收集的不再是哪个分代，这就是 G1 的 &lt;em&gt;Mixed GC&lt;/em&gt; 模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 是基于 Region 来进行回收的，Region 就是堆内存中任意的布局，每一块 Region 都可以根据需要扮演 Eden 空间、Survivor 空间或者老年代空间，收集器能够对不同的 Region 角色采用不同的策略来进行处理。Region 中还有一块特殊的区域，这块区域就是 &lt;em&gt;Humongous&lt;/em&gt; 区域，它是专门用来存储大对象的，G1 认为只要大小超过了 Region 容量一半的对象即可判定为大对象。如果超过了 Region 容量的大对象，将会存储在连续的 Humongous Region 中，G1 大多数行为都会把 Humongous Region 作为老年代来看待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 保留了新生代（Eden Suvivor）和老年代的概念，但是新生代和老年代不再是固定的了。它们都是一系列区域的动态集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 收集器的运作过程可以分为以下四步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初始标记：这个步骤也仅仅是标记一下 GC Roots 能够直接关联到的对象；并修改 TAMS 指针的值（每一个 Region 都有两个 RAMS 指针），使得下一阶段用户并发运行时，能够在可用的 Region 中分配对象，这个阶段需要暂停用户线程，但是时间很短。这个停顿是借用 Minor GC 的时候完成的，所以可以忽略不计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象。当对象图扫描完成后，重新处理 SATB 记录下的在并发时有引用的对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段结束后遗留下来的少量 &lt;em&gt;SATB&lt;/em&gt; 记录（一种原始快照，用来记录并发标记中某些对象）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择多个 Region 构成回收集，然后把决定要回收的那一部分 Region 存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作设计对象的移动，所以必须要暂停用户线程，由多条收集器线程并行收集&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面这几个步骤可以看出，除了并发标记外，其余三个阶段都需要暂停用户线程，所以，这个 G1 收集器并非追求&lt;strong&gt;低延迟&lt;/strong&gt;，官方给出的设计目标是&lt;strong&gt;在延迟可控的情况下尽可能的提高吞吐量&lt;/strong&gt;，担任全功能收集器的重任。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 G1 回收的示意图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375&quot; data-type=&quot;jpeg&quot; data-w=&quot;864&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmOticPic3nnyPXRDCMfc6JIOjbSW9QE1y2KVLicsazGK9CDrlps3MOHAAg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;G1 收集器同样也有缺点和问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个问题就是 Region 中存在跨代引用的问题，我们之前知道可以用记忆集来解决跨代引用问题，不过 Region 中的跨代引用要复杂很多；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二个问题就是如何保证收集线程与用户线程互不干扰的运行？CMS 使用的是增量更新算法，G1 使用的是原始快照（SATB），G1 为 Region 分配了两块 TAMS 指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须在这两个指针位置以上。如果内存回收速度赶不上内存分配速度，G1 收集器也要冻结用户线程执行，导致 Full GC 而产生长时间的 STW。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三个问题是无法建立可预测的停顿模型。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM 常用命令介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍一下 JVM 中常用的调优、故障处理等工具。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jps&lt;/em&gt; ：虚拟机进程工具，全称是 &lt;em&gt;JVM Process Status Tool&lt;/em&gt;，它的功能和 Linux 中的 &lt;em&gt;ps&lt;/em&gt; 类似，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类 &lt;em&gt;Main Class&lt;/em&gt; 所在的本地虚拟机唯一 ID，虽然功能比较单一，但是这个命令绝对是使用最高频的一个命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jstat&lt;/em&gt;：虚拟机统计信息工具，用于监视虚拟机各种运行状态的信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jinfo&lt;/em&gt;：Java 配置信息工具，全称是 &lt;em&gt;Configuration Info for Java&lt;/em&gt;，它的作用是可以实时调整虚拟机各项参数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jmap&lt;/em&gt;：Java 内存映像工具，全称是 &lt;em&gt;Memory Map For Java&lt;/em&gt;，它用于生成转储快照，用来排查内存占用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jhat&lt;/em&gt;：虚拟机堆转储快照分析工具，全称是 &lt;em&gt;JVM Heap Analysis Tool&lt;/em&gt;，这个指令通常和 jmap 一起搭配使用，jhat 内置了一个 HTTP/Web 服务器，生成转储快照后可以在浏览器中查看。不过，一般还是 jmap 命令使用的频率比较高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;jstack&lt;/em&gt;：Java 堆栈跟踪工具，全称是 &lt;em&gt;Stack Trace for Java&lt;/em&gt; ，顾名思义，这个命令用来追踪堆栈的使用情况，用于虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条正在执行的方法堆栈的集合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是双亲委派模型？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 类加载默认使用的是&lt;strong&gt;双亲委派模型&lt;/strong&gt;，那么什么是双亲委派模型呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们需要先介绍一下三种类加载器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;启动类加载器，&lt;em&gt;Bootstrap Class Loader&lt;/em&gt;，这个类加载器是 C++ 实现的，它是 JVM 的一部分，这个类加载器负责加载存放在 &lt;em&gt;&amp;lt;JAVA_HOME&amp;gt;\lib&lt;/em&gt; 目录，启动类加载器无法被 Java 程序直接引用。这也就是说，JDK 中的常用类的加载都是由启动类加载器来完成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展类加载器，&lt;em&gt;Extension Class Loader&lt;/em&gt;，这个类加载器是 Java 实现的，它负责加载 &lt;em&gt;&amp;lt;JAVA_HOME&amp;gt;\lib\ext&lt;/em&gt; 目录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序类加载器，&lt;em&gt;Application Class Loader&lt;/em&gt;，这个类加载器是由 &lt;em&gt;sum.misc.Launcher$AppClassLoader&lt;/em&gt; 来实现，它负责加载 &lt;em&gt;ClassPath&lt;/em&gt; 上所有的类库，如果应用程序中没有定义自己的类加载器，默认使用就是这个类加载器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们的 Java 应用程序都是由这三种类加载器来相互配合完成的，当然，用户也可以自己定义类加载器，即 &lt;em&gt;User Class Loader&lt;/em&gt;，这几个类加载器的模型如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7843137254901961&quot; data-type=&quot;jpeg&quot; data-w=&quot;1377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaTTaoE1HA8uE2z8agCUWibYmtI4ta2xo6xGOr0kbMvQOcJcibLLYZVxwS0ZOtNtHCJSwaKDhC1eRmgg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这几类类加载器构成了不同的层次结构，当我们需要加载一个类时，子类加载器并不会马上去加载，而是依次去请求父类加载器加载，一直往上请求到最高类加载器：启动类加载器。当启动类加载器加载不了的时候，依次往下让子类加载器进行加载。这就是双亲委派模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;双亲委派模型的缺陷？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在双亲委派模型中，子类加载器可以使用父类加载器已经加载的类，而父类加载器无法使用子类加载器已经加载的。这就导致了双亲委派模型并不能解决所有的类加载器问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 提供了很多外部接口，这些接口统称为 &lt;em&gt;Service Provider Interface, SPI&lt;/em&gt;，允许第三方实现这些接口，而这些接口却是 Java 核心类提供的，由 Bootstrap Class Loader 加载，而一般的扩展接口是由 Application Class Loader 加载的，Bootstrap Class Loader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 Application Class Loader，因为它是最顶层的类加载器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;双亲委派机制的三次破坏&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然双亲委派机制是 Java 强烈推荐给开发者们的类加载器的实现方式，但是并没有强制规定你必须就要这么实现，所以，它一样也存在被破坏的情况，实际上，历史上一共出现三次双亲委派机制被破坏的情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第一次被破坏发生在双亲委派机制出现之前，由于双亲委派机制 JDK 1.2 之后才引用的，但类加载的概念在 Java 刚出现的时候就有了，所以引用双亲委派机制之前，设计者们必须兼顾开发者们自定义的一些类加载器的代码，所以在 JDK 1.2 之后的 java.lang.ClassLoader 中添加了一个新的 &lt;em&gt;findClass&lt;/em&gt; 方法，引导用户编写类加载器逻辑的时候重写这个 findClass 方法，而不是基于 &lt;em&gt;loadClass&lt;/em&gt;编写。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第二次被破坏是由于它自己模型导致的，由于它只能向上（基础）加载，越基础的类越由上层加载器加载，所以如果基础类型又想要调用用户的代码，该怎么办？这也就是我们上面那个问题所说的 SPI 机制。那么 JDK 团队是如何做的呢？它们引用了一个 &lt;strong&gt;线程上下文类加载器(Thread Context ClassLoader)&lt;/strong&gt;，这个类加载器可以通过 java.lang.Thread 类的 &lt;em&gt;setContextClassLoader&lt;/em&gt; 进行设置，如果创建时线程还未设置，它将会从父线程中继承，如果全局没有设置类加载器的话，这个 ClassLoader 就是默认的类加载器。这种行为虽然是一种犯规行为，但是 Java 代码中的 &lt;strong&gt;JNDI、JDBC&lt;/strong&gt; 等都是使用这种方式来完成的。直到 JDK 6 ，引用了 &lt;em&gt;java.util.ServiceLoader&lt;/em&gt;，使用 &lt;strong&gt;META-INF/services&lt;/strong&gt; + 责任链的设计模式，才解决了 SPI 的这种加载机制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双亲委派机制第三次被破坏是由于用户对程序的动态需求使热加载、热部署的引入所致。由于时代的变化，我们希望 Java 能像鼠标键盘一样实现热部署，即时加载（load class），引入了 OSGI，OSGI 实现热部署的关键在于它自定义类加载器机制的实现，OSGI 中的每一个 &lt;em&gt;Bundle&lt;/em&gt; 也就是模块都有一个自己的类加载器。当需要更换 Bundle 时，就直接把 Bundle 连同类加载器一起替换掉就能够实现热加载。在 OSGI 环境下，类加载器不再遵从双亲委派机制，而是使用了一种更复杂的加载机制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见的 JVM 调优参数有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;-Xms256m：初始化堆大小为 256m；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmx2g：最大内存为 2g；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-Xmn50m：新生代的大小50m；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+PrintGCDetails 打印 gc 详细信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+HeapDumpOnOutOfMemoryError  在发生OutOfMemoryError错误时，来 dump 出堆快照；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewRatio=4    设置年轻的和老年代的内存比例为 1:4；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:SurvivorRatio=8 设置新生代 Eden 和 Survivor 比例为 8:2；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseSerialGC   新生代和老年代都用串行收集器 Serial + Serial Old&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParNewGC 指定使用 ParNew + Serial Old 垃圾回收器组合；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelGC  新生代使用 Parallel Scavenge，老年代使用 Serial Old&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseParallelOldGC：新生代 ParallelScavenge + 老年代 ParallelOld 组合；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:+UseConcMarkSweepGC：新生代使用 ParNew，老年代使用 CMS；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:NewSize：新生代最小值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxNewSize：新生代最大值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MetaspaceSize 元空间初始化大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-XX:MaxMetaspaceSize 元空间最大值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章是 JVM 面试题的第二版，新增了很多内容，写的时间也比较长了，如果你觉得文章还不错的话，大家&lt;span&gt;三连&lt;/span&gt;走起！&lt;span&gt;另外，分享到朋友圈是对我莫大的支持，感谢&lt;/span&gt;！不骗你，看完真的需要一小时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508525&amp;amp;idx=1&amp;amp;sn=7fc6ce143c3a600ea7defa896707d4b2&amp;amp;chksm=bd25a3528a522a448304c6baf7877af993464eb39c839ef30392457677f74fd58b5cdf562b04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;空降的大厂 CTO，半年内成功把团队带垮了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;空降的大厂 CTO，半年内成功把团队带垮了！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508525&amp;amp;idx=2&amp;amp;sn=c11a048bd986b2ac897b74fd9b492c6c&amp;amp;chksm=bd25a3528a522a44118d1065aee8c5cdb2a8299d6b3cf1174ac9a8b1eeaa828dd13c36d3b508&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何设计API返回码（错误码）？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如何设计API返回码（错误码）？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508521&amp;amp;idx=2&amp;amp;sn=fd61ee0009a89aff50ab87d60be4b4d8&amp;amp;chksm=bd25a3568a522a40484bf60ef51c01ca8641f91750ebc58f34744677f81199f426471ade4bf6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;看一遍就理解：零拷贝详解&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;看一遍就理解：零拷贝详解&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed3d9fa7bba99675b1043635ce0d67d2</guid>
<title>[推荐] 网络编程怎么做才算是优雅？</title>
<link>https://toutiao.io/k/zylzzpi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据说，web2.0的魅力在于由静态资源变成交互性资源，web3.0的魅力在于其去中心化的资源，大家都可以参与其中得享时代的福利。但是，无论上层概念玩的再花哨，最下层的通信还是基于web1.0所形成的技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的终极目标，其实就是打着去中心化的名义，做实际上的中心化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当流量增加到一定程度，网络编程会发生各种怪异的场景。下面将以十几个实际的案例，来说明xjjdog平常在工作中遇到的与网络相关的高频问题，希望能够助你一臂之力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 大量客户端上线注意躲避&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论你的服务器能力多强，在大批量连接到来，进行业务服务的时候，都会产生瞬时的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，如果你的MQTT服务器连接了几十万台设备。当你的MQTT服务器宕机重启的时候，就要接受几十万的并发，这几乎没有任何服务能够受得了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在xjjdog以往的经验中，因为服务端重启问题而造成的阻塞事故，数不胜数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个场景，其实和缓存的击穿概念非常的相似。当缓存中的热点数据集中失效的时候，请求就会全部击穿到数据库层面，造成问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4798807749627422&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLr2VuKPZxnONlCFrhAIg0Agc6t3LlnbibUrKk6UCDUnCzAfqntNh0mz60QcMVpNHaDPMFfyDp0aj5A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，解决缓存击穿问题就是给每个key加个失效时间的随机值，让它们不要在同一时间失效。类似的，我们可以在客户端重连服务端的时候，加上一个随机的时间。随机数是个好东西，它能让我们的海量连接在随机时间窗口内保持类线性的增长。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 多网卡队列&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类似openstack等虚拟平台上假设的虚拟机，往往因为网卡能力不强而造成流量在达到一定程度之后，服务发生卡顿。这是因为单个cpu在处理中断时，产生了瓶颈。通过dstat或者iftop命令，可以看到当前的网络流量。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4381551362683438&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2HSibZc6bRbZyvIKzHKsczuuwpRuviamELTCT78oUQaUkmZzLnvPXricYQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，Kafka新机器上线之后，会进行大规模的数据拷贝，这个时候如果你去ping相关的机器，会发现ping值变的非常大。同时，&lt;code&gt;Recv-Q&lt;/code&gt;和&lt;code&gt;Send-Q&lt;/code&gt;的值也会增大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，就需要开启网卡多队列模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;ethtool&lt;/code&gt;可以看到网卡的队列信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -l eth0 | grep &lt;span&gt;&#x27;Combined&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Combined: 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，通过下面的命令，可以增加网卡的队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ethtool -L eth0 combined 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议同时开启中断平衡服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;systemctl start irqbalance&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 不定时的切断一下长连接&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果客户端和服务端连接上了，并一直保持连接不关闭对方，那么它就是一条长连接。长连接可以避免频繁的连接创建所产生的开销。从HTTP1到HTTP2再到HTTP3，一直在向减少连接，复用连接方面去努力。通常情况下，长连接是第一选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有一些特殊情况，我们希望长连接并不要一直在那里保持着，需要给它增加TTL。这种情况通常发生在负载均衡场景里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如LVS、HAProxy等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果后端有A、B、C三台机器，经过LVS负载之后，90条连接被分散到三台机器。但某个时刻，A宕机了，它所持有的30个连接就会被重新负载到B、C上，这时候它们都持有45条连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当A重启之后，它却再也拿不到新的连接。如果LVS运算一次再平衡的话，产生的影响也比较大。所以我们希望创建的长连接能够有一个生存时长的属性，在某个时间间隔内达到渐进式的再平衡。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. k8s端口范围&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了k8s和别的程序不起冲突，默认端口的范围是 30000-32767。如果你在使用k8s平台，配置了nodeport但是无法访问到，要注意是不是设置的端口号太小了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. TIME_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT是主动关闭连接的一方保持的状态，像nginx、爬虫服务器，经常发生大量处于time_wait状态的连接。TCP一般在主动关闭连接后，会等待2MS，然后彻底关闭连接。由于HTTP使用了TCP协议，所以在这些频繁开关连接的服务器上，就积压了非常多的TIME_WAIT状态连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些系统通过dmesg可以看到以下信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;__ratelimit: 2170 callbacks suppressed&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;TCP: time &lt;span&gt;wait&lt;/span&gt; bucket table overflow&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sysctl命令可以设置这些参数，如果想要重启生效的话，加入/etc/sysctl.conf文件中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 修改阈值&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_max_tw_buckets = 50000 &lt;br/&gt;&lt;span&gt;# 表示开启TCP连接中TIME-WAIT sockets的快速回收&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_reuse = 1&lt;br/&gt;&lt;span&gt;#启用timewait 快速回收。这个一定要开启，默认是关闭的。&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_tw_recycle= 1   &lt;br/&gt;&lt;span&gt;# 修改系統默认的TIMEOUT时间,默认是60s&lt;/span&gt;&lt;br/&gt;net.ipv4.tcp_fin_timeout = 10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试参数的话，可以使用 sysctl -w net.ipv4.tcp_tw_reuse = 1 这样的命令。如果是写入进文件的，则使用sysctl -p生效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. CLOSE_WAIT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CLOSE_WAIT一般是由于对端主动关闭，而我方没有正确处理的原因引起的。说白了，就是程序写的有问题，属于危害比较大的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道TCP的连接是三次握手四次挥手，这是由于TCP连接允许单向关闭。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0374707259953162&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2Hic8Rj6p5VFicDO6n01u1CNMWO3db3SdCibKMqOz8u3yv9wOicoWyS5sPQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，当一个连接发起主动关闭之后，它将进入fin_wait_1状态。同时，收到fin报文的被动关闭方，进入close_wait状态，然后回复ack后，主动关闭方进入fin_wait_2状态。这就是单向的关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果被动关闭方因为某些原因，没有发送fin报文给主动关闭方，那么它就会一直处于close_wait状态。比如，收到了EOF但没有发起close操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，这多数是一种编程bug，只能通过代码review来解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 一个进程能够打开的网络连接&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4233576642335766&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLraeg3qV1NqYqicNYpXMukH2hIibPMZfiaXutYUhHiaqpYdg2bKY24g6Nj96l0KpdV7JUC1041pEO0Aiag/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux即使放开一个端口，能够接受的连接也是海量的。这些连接的上限，受到单进程文件句柄数量和操作系统文件句柄数量的限制，也就是ulimit和file-max。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够将参数修改持久化，我们倾向于将改动写入到文件里。进程的文件句柄限制，可以放在&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;中，它的上限受到&lt;code&gt;fs.nr_open&lt;/code&gt;的制约；操作系统的文件句柄限制，可以放到&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;文件中。最后，别忘了在&lt;code&gt;/proc/$id/limits&lt;/code&gt;文件中，确认修改是否对进程生效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;/etc/security/limits.conf配置案例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;root soft nofile 1000000&lt;br/&gt;root hard nofile 1000000&lt;br/&gt;* soft nofile 1000000&lt;br/&gt;* hard nofile 1000000&lt;br/&gt;es  -  nofile  65535&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. SO_KEEPALIVE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将这个Socket选项打开，客户端Socket每隔段的时间（大约两个小时）就会利用空闲的连接向服务器发送一个数据包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个数据包并没有其它的作用，只是为了检测一下服务器是否仍处于活动状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器未响应这个数据包，在大约11分钟后，客户端Socket再发送一个数据包，如果在12分钟内，服务器还没响应，那么客户端Socket将关闭。如果将Socket选项关闭，客户端Socket在服务器无效的情况下可能会长时间不会关闭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9. SO_REUSEADDR是为了解决什么问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在网络开发时，时常会碰到&lt;code&gt;address already in use&lt;/code&gt;的异常，这是由于关闭应用程序时，还有对应端口的网络连接处于&lt;code&gt;TIME_WAIT&lt;/code&gt;状态而造成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT状态通常会持续一段时间（2ML），设置SO_REUSEADDR可以支持快速端口复用，支持应用的快速重启。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10. 健康检查采用应用心跳&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自身的keepalived机制非常的鸡肋，它静悄悄的在底层运行，无法产生应用层的语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的想象里，连接就应该是一条线。但其实，它只是2个点，而且每次走的路径都可能不一样。一个点，需要在发出心跳包然后收到回复之后，才能知道对方是否存活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp自带的心跳机制，仅仅能知道对方是否存活，对于服务是否可用，健康状况这些东西一概不知，而且超时配置常常与超时重传机制相冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，有确切含义的应用层心跳是必要的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11. SO_LINGER&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个Socket选项可以影响close方法的行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，当调用close方法后，将立即返回；如果这时仍然有未被送出的数据包，那么这些数据包将被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger参数设为一个正整数n时（n的值最大是65，535），在调用close方法后，将最多被阻塞n秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这n秒内，系统将尽量将未送出的数据包发送出去；如果超过了n秒，如果还有未发送的数据包，这些数据包将全部被丢弃；而close方法会立即返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将linger设为0，和关闭SO_LINGER选项的作用是一样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12. SO_TIMEOUT&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这个选项来设置读取数据超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当输入流的read方法被阻塞时，如果设置timeout（timeout的单位是毫秒），那么系统在等待了timeout毫秒后会抛出一个InterruptedIOException例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在抛出例外后，输入流并未关闭，你可以继续通过read方法读取数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13. SO_SNDBUF，SO_RCVBUF&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下，输出流的发送缓冲区是8096个字节（8K）。这个值是Java所建议的输出缓冲区的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个默认值不能满足要求，可以用setSendBufferSize方法来重新设置缓冲区的大小。但最好不要将输出缓冲区设得太小，否则会导致传输数据过于频繁，从而降低网络传输的效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14. SO_OOBINLINE&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这个Socket选项打开，可以通过Socket类的sendUrgentData方法向服务器发送一个单字节的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个单字节数据并不经过输出缓冲区，而是立即发出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在客户端并不是使用OutputStream向服务器发送数据，但在服务端程序中这个单字节的数据是和其它的普通数据混在一起的。因此，在服务端程序中并不知道由客户端发过来的数据是由OutputStream还是由sendUrgentData发过来的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我非常惊讶的发现，现在有些网络环境，依然还是千兆网卡，包括一些比较专业的测试环境。当在这些环境上进行实际的压测时，当流量突破了网卡的限制，应用响应将会变的异常缓慢。计算机系统是一个整体，CPU、内存、网络、IO，任何一环出现瓶颈，都会造成问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，网络是一个非常重要的因素。但由于它相对来说比较底层，所以大多数开发对其了解较少。加上现在各种云原生组件的流行，接触这些底层设施的机会就越来越少。但如果系统真的发生了问题，在排除掉其他最可能出问题的组件后，千万别忘了--&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有网络这一摊子等着你。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0da1155c5a03b45ce44d3f834361c69a</guid>
<title>[推荐] 关于代码质量退化的思考</title>
<link>https://toutiao.io/k/zzaz6vu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;p&gt;一个软件项目从探索阶段到发展方向明确阶段，会经历从简单到复杂的一个过程，需求的不断叠加，会让系统越来越庞大，功能繁多，公司业务的扩展也让软件系统的生命周期变的更长。在业务变复杂软的过程中，各种原因的驱使，代码质量会退化，维护和开发新功能的成本也会相应的变高，推倒重新开发的成本也是高的吓人。&lt;/p&gt;
&lt;h2 id=&quot;代码质量退化的步骤&quot;&gt;代码质量退化的步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;大多情况下编码设计质量最高的时候是根据第一版需求进行编码实现的时候&lt;/strong&gt;，但只要需求一变更，就会打乱原来的编码设计，软件质量也就会越来越差。或者就没有了设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144131123-305134580.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了项目中期，有新的功能或者bug的修复，老板就给我了一天时间，让我写好处理代码？逾期是要被骂的；这个没用的功能，做了也没人用，随便写吧，早点结束，早去干别的；我手上现在这么多活，你又插进来个新功能，我只能乱搞了，团队内人员水平的不同写的代码更是天差地别，等等，这都是我们实际工作中会遇到的问题。责任心让我们也会想先这样写，以后再重构，&lt;strong&gt;一般以后重构表示永远不会重构&lt;/strong&gt;。&lt;br/&gt;
上面说的这些都会让我们增加糟糕的代码，混乱的业务逻辑分布在我们系统的各个地方，部门人员变动，新的员工更不可能理解那些杂乱无章的东西，再接着推糟糕的代码，想要理清楚一个业务逻辑，非常容易在混乱的代码中迷路。最直接的后果就是这些混乱的代码会增加新功能的开发周期，领导层问为啥现在开发个功能这么慢？是不是人手不够，再招几个人吧。这杂乱的项目，不是新员工能理的清的，你会发现，&lt;strong&gt;虽然员工变多了。但开发效率还是上不去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144221410-1475304617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们重新来做一个新的系统完全替代这个老项目吧，我们可以用最新的框架，更好的实现方式去完成这个系统，这种天真的想法会在团队成员的脑海里无数次出现，旧的系统业务很复杂，新的系统在兼容旧系统逻辑的同时，旧的系统也在更新需求，增加功能，在新系统完全可以抗衡旧系统之前，旧的系统会一直运行。如果你的新系统开发的时间过长，等完成的时候，可能员工都已经不知道换了几批了，代码又乱成了一锅粥，周而复始。&lt;/p&gt;
&lt;p&gt;软件的退化变的越来越严重的过程中，我们也在思考和改变现有的系统，如何才能让系统的在拥有更长的生命周期的同时，提高代码的质量，不让其退化，并拥有更好的可维护性和扩展性？那就是根据需求的变化去调整架构、代码，不断的打破原来的设计，保持清晰，而不是让他烂在那里。&lt;/p&gt;
&lt;h2 id=&quot;渐进式架构&quot;&gt;渐进式架构&lt;/h2&gt;
&lt;p&gt;大多数人能想到的最直接的方案是从架构入手，引入多维度的架构，微服务化，领域驱动模型(DDD)等等&lt;br/&gt;
从顶层设计出发引入新的架构模型，或者说根据需求的变动不断的调整代码的分层和模块，加上理论知识的应用，会让业务代码在结构归属上更清晰。分层的严密能让整体的&lt;strong&gt;业务边界&lt;/strong&gt;更明确，前提是我们要从多维度去审视系统的构架，思考如何去现有的架构做出合理的改动。&lt;/p&gt;
&lt;h3 id=&quot;从不同的角度去分析和改进现有架构&quot;&gt;从不同的角度去分析和改进现有架构&lt;/h3&gt;
&lt;p&gt;比如在项目初期业务比较简单，最简单的分层架构就实现了项目需求，观察我们的架构可能是这样子的，从上而下的松散分层架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144305648-1556510597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来又加入了缓存，又加入了消息队列，业务的不断扩张又加入了不同的数据库nosql,业务的升级有了v2.0,v3.0,新业务要兼容旧功能等等，如果还是原来的分层结构，很快就会出现逻辑代码堆积的问题，业务层之间引用杂乱，一个代码文件几千行代码，需求变动时牵一发动全身，及时调整架构的必要性就体现出来了。&lt;br/&gt;
一定要复用好&lt;strong&gt;依赖倒置原则&lt;/strong&gt;,层与层之间不应该依赖实现，要依赖于抽象，比如我们的基础设施层要为其他三层提供支持，基础设施层可以实现其他层定义的接口来进行抽象，从这个角度来开的话我们的基础设施层应该在最上面，也可以是左边或者右边&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144331003-1956239261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用依赖倒置后，我们调用的是抽象接口，你会发现层的概念没有了，层的概念被打破了，我们可以更激进一点把基础设施层剥离出去用各种适配器去接入各种组件，把层的关系拉平，把架构调整为&lt;strong&gt;六边形构架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144346648-1137144759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不要固化自己的思维，根据业务和系统的发展去调整你的系统架构，能让系统能更高的可扩展和可维护性。&lt;br/&gt;
对于非常老的项目调整架构是痛苦的，一定要得到管理层充分的支持下再去做改造，这样的工作只能是从上往下推进，痛苦的过程终会换来后期维护的喜悦。&lt;/p&gt;
&lt;h2 id=&quot;代码层面&quot;&gt;代码层面&lt;/h2&gt;
&lt;p&gt;在团队内除了要有代码规范，所有人都要遵守，这样代码的风格才能更统一，和使用Lint工具去检查代码，各种语言lint工具，能在早期查检出你代码中不合理的地方。还有下面一些办法&lt;/p&gt;
&lt;h3 id=&quot;功能模块化&quot;&gt;功能模块化&lt;/h3&gt;
&lt;p&gt;程序员最喜欢的就是编码实现具体的功能，在这里才是我们真正秀内功的地方，可以应用各种模式把代码和逻辑写的很漂亮，但是放到整个项目结构里，被调用和使用的过程又感觉那么的不协调，根源是我们模块划分不正确，模块之间的依赖耦合性太强。&lt;br/&gt;
这就是典型的&lt;strong&gt;写的很优雅，使用的很粗糙&lt;/strong&gt;。依赖倒置原则，依然适用于模块间的划分，模块与模块之间的依赖是倒置的，用依赖注入的方式去解耦，模块对外暴露出尽可能少的接口，之间的调用依赖于接口。抽象的好处能让你把模块的边界定义的更明确。&lt;/p&gt;
&lt;h3 id=&quot;对象之间是协作关系不是纠缠&quot;&gt;对象之间是协作关系，不是纠缠&lt;/h3&gt;
&lt;p&gt;业务越复杂，需要操作的对象也就越多，对象的边界不明确就会出现纠缠不清的情况，要不就是一个对象负责的东西过多；要不就是几个对象同时做一件事，逻辑杂乱。&lt;br/&gt;
当你发现你的对象之前不再是协作关系时就要停下来，从高处去看你组织的代码，把大对象分解，职责界线理清楚也就是&lt;strong&gt;功能单一原则&lt;/strong&gt;，很多同学不知道如何确定一个对象的职责，不清楚一个属性是不是属于某个对象，最简单的方法就是，判断这个属性的变动会不影响某个对象，如果没有就不属于这个对象。&lt;br/&gt;
还有就是，面对新的业务需求&lt;strong&gt;敢于打破原有的代码设计，不破不立。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;不要过度开发删除没用的代码&quot;&gt;不要过度开发，删除没用的代码&lt;/h3&gt;
&lt;p&gt;定期要检查和删除没用的代码。少写或者不写感觉未来可能会用到的方法，这些多出来的代码会成为将来重构的绊脚石，会浪费精力在这些没有用到的代码上，查找有没有地方在使用他。&lt;/p&gt;
&lt;h3 id=&quot;solid-原则&quot;&gt;SOLID 原则&lt;/h3&gt;
&lt;p&gt;不能不提的，就是Bob大叔（Robert C. Martin）的SOLID编码原则，他是设计模式的基石，要不断的去应用和实践。&lt;br/&gt;
随着编码时间的增长，越来越感觉SOLID真的是一盏明灯，当你在黑暗中找不到方向的时候，指引你回归正确的道路。&lt;br/&gt;
如果你对SOLID原则应用的比较熟练，我上面说的几项完全都可以忽略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则(Single Responsibility Principle)&lt;br/&gt;
每个对象只有一个职责，明确对象的边界,文章上面说的对象之间是协作关系，不是纠缠里就说过如何确定一个属性是否属于某个对象。&lt;/li&gt;
&lt;li&gt;开闭原则(Open Closed Principle)&lt;br/&gt;
即可扩展(extension)，不可修改(modification)原则，抽取出代码中不变的逻辑，封装可变的代码，&lt;br/&gt;
策略模式就很好的表达这个原则的模式，可以查看之前的博客: &lt;a href=&quot;https://www.cnblogs.com/li-peng/archive/2013/02/18/2915594.html&quot; target=&quot;_blank&quot;&gt;策略模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;里氏替换原则(Liskov Substitution Principle)&lt;br/&gt;
继承必须确保超类所拥有的性质在子类中仍然成立，里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。关于里氏替换原则的例子，最有名的是“正方形不是长方形&lt;/li&gt;
&lt;li&gt;接口隔离原则(Interface Segregation Principle)&lt;br/&gt;
尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含调用方感兴趣的方法，这也是我们把复杂功能分模块的应用法则。&lt;br/&gt;
接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，但两者是不同的：&lt;br/&gt;
单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。&lt;br/&gt;
单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。&lt;/li&gt;
&lt;li&gt;依赖倒置原则(Dependence Inversion Principle)&lt;br/&gt;
抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象（接口）编程，而不是针对实现细节编程。上面在说改进架构的时候有说这个原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的代码示例这篇帖子就不写了。&lt;br/&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144429253-693163030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被bob大叔指到的你，一定能写出更完美的代码&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;重构代码&quot;&gt;重构代码&lt;/h3&gt;
&lt;p&gt;新功能的开发的同时要重构之前逻辑，坚持开闭原则，能达到事半功倍的效果。&lt;br/&gt;
工作闲暇时间去浏览现有的代码逻辑，我们每天都在成长，对系统的认知也在改变，思维方式也在不断的变化，用现在的眼光去审视旧的代码逻辑，大多数是能找可以优化的地方，或者隐藏的bug，重构他，不要以为这些只是一些挤牙膏式的调优，所有的事情都有一个从质变到量变的过程。&lt;/p&gt;
&lt;h2 id=&quot;代码评审code-review&quot;&gt;代码评审(code review)&lt;/h2&gt;
&lt;p&gt;代码评审在团队里还是很有必要的，代码评审不是口水战，也不是批斗大会，如果只是走形式code review的意义也就不存在了。&lt;br/&gt;
你写的代码是需要让团队的成员能看明白的，将来也是会有新的员工来维护你写的功能的，code review是一个能让团队内的其他成员快速了解新代码意图的办法。&lt;br/&gt;
大多数团队里程序员的水平参差不齐的，对业务和系统的理解深度也是不一样的，让团队内不同的人去code review能及时发现代码中的不足之处，哪些地方逻辑上有问题，哪里的业务没有考虑全面。&lt;br/&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/342595/202201/342595-20220107144445467-1134347927.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一次提交的代码太多时，一下子是看不完，也可能理解不了，就要很评审整体思路，再review实现主干逻辑，最后才是实现细节。&lt;br/&gt;
需说明一下的是，&lt;strong&gt;code review 并不能完全发现代码中隐藏的bug，不要把找bug的任务和他混在一起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习多少构架或者框架知识，都不能阻止我们写烂代码。但当你沉下心来去打磨产品或者认真去实现一个功能时，你会在意你写的代码，会主动去写更清晰的逻辑，并改变和想办法去并处理糟糕的代码，希望这篇帖子有能帮助到你的地方。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c23d048cdaa3a668d501f399e25bacf1</guid>
<title>[推荐] 再见了 VMware，一款更轻量级的虚拟机！</title>
<link>https://toutiao.io/k/xw2lnva</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;section class=&quot;js_darkmode__1&quot;&gt;&lt;span&gt;公众号关注&lt;/span&gt;&lt;span&gt; “GitHubDaily”&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;设为 “&lt;/span&gt;&lt;span&gt;星标&lt;/span&gt;&lt;span&gt;”，每天带你逛 GitHub！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8C07b1Ih2doNmiaicSttMccejE1onYNcszau24r6lIzHr6Fib3XlicibHcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大家好，我是小 G。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，打算在 &lt;/span&gt;&lt;strong&gt;Mac&lt;/strong&gt;&lt;span&gt; 电脑上安装一个虚拟机，用来学习 &lt;/span&gt;&lt;strong&gt;K8S&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先想到的是 &lt;strong&gt;Vmware&lt;/strong&gt; 和 &lt;strong&gt;Parallels Desktop&lt;/strong&gt;，然后打开浏览器找了找，发现都只提供付费版本，只有 &lt;strong&gt;Parallels Desktop&lt;/strong&gt; 提供了 &lt;strong&gt;14&lt;/strong&gt; 天的免费试用。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsCKOCmkQFvjvr9uqCL45fUVicA4uFf5iaNiaicY6kcTXK9rxfOWicwicWwh4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;无法白嫖&quot;/&gt;&lt;figcaption&gt;无法白嫖&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;然后，开始尝试使用免费 &lt;strong&gt;VirtualBox&lt;/strong&gt;，但是在安装 &lt;strong&gt;CentOS&lt;/strong&gt; 的时候，貌似因为 &lt;strong&gt;MacOS&lt;/strong&gt; 最新版本的原因，总是报错，花费了好几天的时间，试过各种方案，最终解决无果，就放弃了。。&lt;/p&gt;&lt;p&gt;就在陌溪要放弃的时候，突然在 &lt;strong&gt;Ubuntu&lt;/strong&gt; 官网进行冲浪的时候，发现了一款叫 &lt;strong&gt;Multipass&lt;/strong&gt; 的东西。&lt;/p&gt;&lt;p&gt;它可以快速在电脑上快速搭建一个轻量级的虚拟机，并且相比于 &lt;strong&gt;Vmware&lt;/strong&gt; 更加轻量，只需一行命令快速创建 &lt;strong&gt;Ubuntu&lt;/strong&gt; 虚拟机。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Multipass&lt;/strong&gt; 是一个轻量虚拟机管理器，是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 运营公司 &lt;strong&gt;Canonical&lt;/strong&gt; 所推出的开源项目。运行环境支持 &lt;strong&gt;Linux&lt;/strong&gt;、&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt;。在不同的操作系统上，使用的是不同的虚拟化技术。在 &lt;strong&gt;Linux&lt;/strong&gt; 上使用的是 &lt;strong&gt;KVM&lt;/strong&gt;、&lt;strong&gt;Window&lt;/strong&gt; 上使用 &lt;strong&gt;Hyper-V&lt;/strong&gt;、&lt;strong&gt;macOS&lt;/strong&gt; 中使用 &lt;strong&gt;HyperKit&lt;/strong&gt; 以最小开销运行VM，支持在笔记本模拟小型云。&lt;/p&gt;&lt;p&gt;同时，&lt;strong&gt;Multipass&lt;/strong&gt; 提供了一个命令行界面来启动和管理 &lt;strong&gt;Linux&lt;/strong&gt; 实例。下载一个全新的镜像需要几秒钟的时间，并且在几分钟内就可以启动并运行 &lt;strong&gt;VM&lt;/strong&gt;。（直呼好家伙，大大降低的我们安装虚拟机的成本了）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Multipass官网：https://multipass.run/&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5435185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsQ45NQiaofsON9YRJTedbwFRuqjGRIxDJ3icaxa7jicJRXoxrI4iapRSyGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;Multipass官网&quot;/&gt;&lt;figcaption&gt;Multipass官网&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;开始使用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在使用 &lt;strong&gt;Multipass&lt;/strong&gt; 之前 ，首先需要安装 &lt;strong&gt;Multipass&lt;/strong&gt; 工具，可以打开官网进行下载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//multipass.run/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择对应的操作系统，因为我的是 &lt;strong&gt;Mac&lt;/strong&gt; 电脑，所以选择 MacOS，点击 &lt;strong&gt;Download&lt;/strong&gt; 开始下载&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36018518518518516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsw2biaGewZU8V4TKK2tE67EnX91WqwFBhLu1lbMewrialrl419NIdwfIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211120120019913&quot;/&gt;&lt;figcaption&gt;选择对应版本安装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果电脑装了 &lt;strong&gt;brew&lt;/strong&gt; 可以直接命令行下载安装:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;brew&lt;/span&gt; cask install multipass&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载安装成功后, 执行以下命令可以查看当前软件版本:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; --version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装成功后，点击运行，即可打开 &lt;strong&gt;Multipass&lt;/strong&gt; 客户端，这里能够快速的通过 &lt;strong&gt;Open Shell&lt;/strong&gt; 创建和启动一个虚拟机&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7735849056603774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcs8hqCKQmRFhia7ic3pgBhtL2gd9M55Rf0Gib3icFE6YeqZ28P2b7hiaNyf5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot; title=&quot;Multipass客户端&quot;/&gt;&lt;figcaption&gt;Multipass客户端&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;下面，我们来介绍如何通过命令的方式，创建一台虚拟机&lt;/p&gt;&lt;h2&gt;&lt;span&gt;创建Ubuntu虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先，通过以下指令查看可供下载的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; find&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行成功后，可以看到下面的这些镜像列表，包含各种版本的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Image&lt;/span&gt;                       &lt;span&gt;Aliases&lt;/span&gt;           &lt;span&gt;Version&lt;/span&gt;          &lt;span&gt;Description&lt;/span&gt;&lt;br/&gt;&lt;span&gt;core&lt;/span&gt;                        &lt;span&gt;core16&lt;/span&gt;            20200818         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 16&lt;br/&gt;&lt;span&gt;core18&lt;/span&gt;                                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Core&lt;/span&gt; 18&lt;br/&gt;18&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;bionic&lt;/span&gt;            20211109         &lt;span&gt;Ubuntu&lt;/span&gt; 18&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;20&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;focal&lt;/span&gt;,&lt;span&gt;lts&lt;/span&gt;         20211118         &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.04&lt;/span&gt;                       &lt;span&gt;hirsute&lt;/span&gt;           20211119         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.04&lt;/span&gt;&lt;br/&gt;21&lt;span&gt;.10&lt;/span&gt;                       &lt;span&gt;impish&lt;/span&gt;            20211103         &lt;span&gt;Ubuntu&lt;/span&gt; 21&lt;span&gt;.10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:adguard-home&lt;/span&gt;                        20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;AdGuard&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:mosquitto&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Mosquitto&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:nextcloud&lt;/span&gt;                           20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Nextcloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:openhab&lt;/span&gt;                             20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;openHAB&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;appliance&lt;/span&gt;&lt;span&gt;:plexmediaserver&lt;/span&gt;                     20200812         &lt;span&gt;Ubuntu&lt;/span&gt; &lt;span&gt;Plex&lt;/span&gt; &lt;span&gt;Media&lt;/span&gt; &lt;span&gt;Server&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;anbox-cloud-appliance&lt;/span&gt;                         &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;Anbox&lt;/span&gt; &lt;span&gt;Cloud&lt;/span&gt; &lt;span&gt;Appliance&lt;/span&gt;&lt;br/&gt;&lt;span&gt;minikube&lt;/span&gt;                                      &lt;span&gt;latest&lt;/span&gt;           &lt;span&gt;minikube&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;Kubernetes&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载最新版的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像并运行，初次创建时需要下载 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像，网络畅通的情况下，稍等片刻即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; launch -n vm01 -c &lt;span&gt;1&lt;/span&gt; -m &lt;span&gt;1G&lt;/span&gt; -d &lt;span&gt;10G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义配置创建可以参考如下方式:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;-n, --name: 名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-c, --cpus: cpu核心数, 默认: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-m, --mem: 内存大小, 默认: 1G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d, --disk: 硬盘大小, 默认: 5G&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;操作虚拟机&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机列表&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;虚拟机创建完成后，可以使用 &lt;strong&gt;multipass list&lt;/strong&gt; 命令进行查看虚拟机列表&lt;/p&gt;&lt;pre&gt;&lt;code&gt;% &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;                    &lt;span&gt;State&lt;/span&gt;             &lt;span&gt;IPv4&lt;/span&gt;             &lt;span&gt;Image&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vm01&lt;/span&gt;                    &lt;span&gt;Running&lt;/span&gt;           192&lt;span&gt;.168.64.2&lt;/span&gt;     &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到目前正在运行一台 &lt;strong&gt;Ubuntu 20.04&lt;/strong&gt; 版本的虚拟机，并且对应的 &lt;strong&gt;IP&lt;/strong&gt; 地址为 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;外部操作虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass exec&lt;/strong&gt; 命令在实例内执行给定的命令。第一个参数是运行命令的实例，也就是 &lt;strong&gt;vm01&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们通过 &lt;strong&gt;exec&lt;/strong&gt; 命令，就可以在外部操作刚刚创建的虚拟机，例如查看内部所处的目录，执行 &lt;strong&gt;pwd&lt;/strong&gt; 命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; multipass &lt;span&gt;exec&lt;/span&gt; vm01 &lt;span&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;/home/ubuntu&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;查看虚拟机信息&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass info&lt;/strong&gt; 命令，即可查看当前运行的虚拟机信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# &lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;info&lt;/span&gt; &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Name&lt;/span&gt;:           &lt;span&gt;vm01&lt;/span&gt;&lt;br/&gt;&lt;span&gt;State&lt;/span&gt;:          &lt;span&gt;Running&lt;/span&gt;&lt;br/&gt;&lt;span&gt;IPv4&lt;/span&gt;:           192&lt;span&gt;.168.64.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Release&lt;/span&gt;:        &lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04.3&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Image&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;:     91740&lt;span&gt;d72ffff&lt;/span&gt; (&lt;span&gt;Ubuntu&lt;/span&gt; 20&lt;span&gt;.04&lt;/span&gt; &lt;span&gt;LTS&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;Load&lt;/span&gt;:           0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt; 0&lt;span&gt;.00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Disk&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:     1&lt;span&gt;.3G&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 9&lt;span&gt;.5G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Memory&lt;/span&gt; &lt;span&gt;usage&lt;/span&gt;:   170&lt;span&gt;.9M&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; 1&lt;span&gt;.9G&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mounts&lt;/span&gt;:         &lt;span&gt;--&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;进入虚拟机&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过 &lt;strong&gt;multipass shell&lt;/strong&gt; 命令，即可进入到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; shell vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行后的结果如下所示，可以看到目前虚拟机的一些系统配置信息，以及内存和磁盘的使用情况&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7129629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcskVp6KUe7Mm9HbLT6dmUhJzpnabyPt7rKHAbulLKO6ib1UUMNrsN0xXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121085114961&quot;/&gt;&lt;figcaption&gt;进入虚拟机内部&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;同时会运行一个新的 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统，此时便进入到了&lt;strong&gt;Ubuntu&lt;/strong&gt; 环境中, 在里面可以执行相关的 &lt;strong&gt;linux&lt;/strong&gt; 指令&lt;/p&gt;&lt;p&gt;当然如果不想进入系统内部，也可以通过上述提到的 &lt;strong&gt;multipass exce&lt;/strong&gt; 命令，来操作 &lt;strong&gt;Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;&lt;p&gt;首先执行下面命令，给系统设置一个 &lt;strong&gt;root&lt;/strong&gt; 密码，设置好密码后，使用 &lt;strong&gt;su root&lt;/strong&gt; 切换到 &lt;strong&gt;root&lt;/strong&gt; 用户&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 设置密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sudo&lt;/span&gt; passwd&lt;br/&gt;&lt;span&gt;# 切换 root&lt;/span&gt;&lt;br/&gt;su root&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;ubuntu&lt;/strong&gt; 是使用 &lt;strong&gt;apt-get&lt;/strong&gt; 来进行包管理的，首先更新一下 &lt;strong&gt;apt-get&lt;/strong&gt;，然后安装 &lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 更新apt&lt;/span&gt;&lt;br/&gt;apt-get &lt;span&gt;update&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 安装 nginx&lt;/span&gt;&lt;br/&gt;apt-&lt;span&gt;get&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好 &lt;strong&gt;nginx&lt;/strong&gt; 后，可以到 /etc/nginx 目录即可看到刚刚的 &lt;strong&gt;nginx&lt;/strong&gt; 配置信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@vm01&lt;span&gt;:/lost+found&lt;/span&gt;&lt;span&gt;# cd /etc/nginx/&lt;/span&gt;&lt;br/&gt;root@vm01&lt;span&gt;:/etc/nginx&lt;/span&gt;&lt;span&gt;# ls&lt;/span&gt;&lt;br/&gt;conf.d        fastcgi_params  koi-win     modules-available  nginx.conf    scgi_params      sites-enabled  uwsgi_params&lt;br/&gt;fastcgi.conf  koi-utf         mime.types  modules-enabled    proxy_params  sites-available  snippets       win-utf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面我们可以测试一下，&lt;strong&gt;nginx&lt;/strong&gt; 是否安装成功，在 &lt;strong&gt;mac&lt;/strong&gt; 上打开浏览器，输入虚拟机的 &lt;strong&gt;ip&lt;/strong&gt; 地址 &lt;strong&gt;192.168.64.2&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsUBdjGbOeCEodmicmTpQIYIe9oBNlhExhKudlB5HqryPI1YeAa5UKvGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;image-20211121094727506&quot;/&gt;&lt;figcaption&gt;nginx安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;可以看出，目前 &lt;strong&gt;nginx&lt;/strong&gt; 已经成功运行了，后续的话，可能会考虑在上面部署更多的应用，感兴趣的小伙伴欢迎关注～&lt;/p&gt;&lt;h3&gt;&lt;span&gt;挂载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;multipass&lt;/strong&gt; 还提供和 &lt;strong&gt;Docker&lt;/strong&gt; 一样的挂载数据卷的功能，能够与外部宿主机的文件保持同步。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 挂载格式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; mount 宿主机目录  实例名:虚拟机目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面，我在用户的目录下，创建一个 &lt;strong&gt;hello&lt;/strong&gt; 目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 创建hello目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;mkdir&lt;/span&gt; hello&lt;br/&gt;&lt;span&gt;# 挂载&lt;/span&gt;&lt;br/&gt;multipass mount /Users/moxi/hello  vm01:/hello&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挂载完成后，我们回到实例 vm01 中，可以看出多了一个 &lt;strong&gt;hello&lt;/strong&gt; 文件夹，说明已经成功挂载～&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hF2fd05UOzDVjd2wZ7hMcsWKnic6p04c1vu5iaTib7bziaz2iaZwXCZutNm18U6wng3t7ljIBUldLHiayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot; title=&quot;image-20211121110217283&quot;/&gt;&lt;figcaption&gt;挂载成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;因此，以后在 &lt;strong&gt;vm01&lt;/strong&gt; 的 &lt;strong&gt;hello文件夹&lt;/strong&gt; 中创建的文件，都会在的宿主机的 &lt;strong&gt;hello 文件夹&lt;/strong&gt;同步显示&lt;/p&gt;&lt;h3&gt;&lt;span&gt;卸载数据卷&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果以后不需要用到挂载了，可以使用 &lt;strong&gt;unmount&lt;/strong&gt; 命令卸载&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#卸载数据卷&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multipass&lt;/span&gt; umount 容器名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;传输文件&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;除了使用上述的 &lt;strong&gt;mount&lt;/strong&gt; 挂载卷的方式实现文件的交互，同时还可以通过 transfer 命令，将宿主机的文件，发送到虚拟机内部&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; transfer 主机文件 容器名:容器目录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，将 &lt;strong&gt;hello.txt&lt;/strong&gt; 发送到&lt;/p&gt;&lt;pre&gt;&lt;code&gt;multipass transfer hello.txt vm01:&lt;span&gt;/home/ubuntu/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;删除和释放实例&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用下面的命令，可以开启、停止、删除和释放实例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 启动实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;start&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 停止实例&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;stop&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 删除实例（删除后，还会存在）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;delete&lt;/span&gt; vm01&lt;br/&gt;&lt;span&gt;# 释放实例（彻底删除）&lt;/span&gt;&lt;br/&gt;multipass &lt;span&gt;purge&lt;/span&gt; vm01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;容器配置自动化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;为了保持开发环境和线上环境一致性 同时节省部署时间 &lt;strong&gt;multipass&lt;/strong&gt; 给我们提供了 &lt;strong&gt;--cloud-init&lt;/strong&gt; 选项进行容器启动初始化配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;multipass&lt;/span&gt; &lt;span&gt;launch&lt;/span&gt; &lt;span&gt;--name&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt; &lt;span&gt;--cloud-init&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;&lt;span&gt;.yaml&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面 &lt;strong&gt;config.yaml&lt;/strong&gt; 则是容器的初始化配置文件，例如，我们想在初始化容器的时候，自动下载安装 &lt;strong&gt;Node.js&lt;/strong&gt;，内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#cloud-config&lt;/span&gt;&lt;br/&gt;runcmd:&lt;br/&gt;  - curl -sL https:&lt;span&gt;//deb.nodesource.com/setup_12.x | sudo -E bash -&lt;/span&gt;&lt;br/&gt;  - sudo apt-&lt;span&gt;get&lt;/span&gt; install -y nodejs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;runcmd&lt;/code&gt; 可以指定容器 &lt;strong&gt;首次启动&lt;/strong&gt; 时运行的命令&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;凡是用户自定义的cloud-init的配置文件,必须以#cloud-config开头，这是cloud-init识别它的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;yaml&lt;/strong&gt; 配置文件可以参考下面的文章&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https://cloudinit.readthedocs.io/en/latest/topics/examples.html?highlight=&lt;span&gt;lock&lt;/span&gt;-passwd&lt;span&gt;#including-users-and-groups&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多关于 &lt;strong&gt;multipass&lt;/strong&gt; 的高阶的技巧，欢迎访问 &lt;strong&gt;multipass&lt;/strong&gt; 官方文档&lt;/p&gt;&lt;pre&gt;&lt;code&gt;https:&lt;span&gt;//m&lt;/span&gt;ultipass.run&lt;span&gt;/docs/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，本期关于 &lt;strong&gt;Multipass&lt;/strong&gt; 的基础学习就到这里了，感兴趣的小伙伴环境下载自己动手学习呢～&lt;/p&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;使用了一阵子后，&lt;strong&gt;Multipass&lt;/strong&gt; 在使用起来很简洁直观，在整体操作上和 &lt;strong&gt;docker&lt;/strong&gt; 类似，如果想在自己电脑上快速搭建一个 &lt;strong&gt;Linux&lt;/strong&gt; 系统用于学习的话，选择使用 &lt;strong&gt;Multipass&lt;/strong&gt; 还是非常方便的。&lt;/p&gt;&lt;p&gt;唯一不足的地方就是，&lt;strong&gt;Multipass&lt;/strong&gt; 是由 &lt;strong&gt;Ubuntu&lt;/strong&gt; 背后的 &lt;strong&gt;Canonical&lt;/strong&gt; 公司开发的，因此 &lt;strong&gt;Multipass&lt;/strong&gt; 所使用的镜像也都是 &lt;strong&gt;Ubuntu&lt;/strong&gt; 镜像（这也可以理解，毕竟支持自家的产品），不过对于习惯了使用 &lt;strong&gt;CentOS&lt;/strong&gt; 的用户来说，还是用些许不太习惯。&lt;/p&gt;&lt;p&gt;不过瑕不掩瑜，&lt;strong&gt;Multipass&lt;/strong&gt; 在我看来还是一款非常棒的软件～&lt;/p&gt;&lt;p&gt;另外，它的代码也在 GitHub 开源了，需要进一步研究的小伙伴也可以看下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;GitHub：https://github.com/canonical/multipass&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxOTcxNTIwNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28ia8xsyOClt8NDDCTAZNaDsEic4EEpUG1FPduFr5TUMK1GbDiaFX0qNCJiaS2XPfHzWlFicK95v1a9ic7Vg/0?wx_fmt=png&quot; data-nickname=&quot;GitHubDaily&quot; data-alias=&quot;GitHubDaily&quot; data-signature=&quot;专注于分享 GitHub 上知名的 Python、Java、Web、AI、数据分析等多个领域的优质学习资源、开源项目及开发者工具，为 GitHub 开发者提供优质编程资讯。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>