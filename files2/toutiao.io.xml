<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6ad8eb69fa201af24eae03771c91af6f</guid>
<title>2022年最受欢迎的5大开源自动化和编排技术</title>
<link>https://toutiao.io/k/fj7m6x8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;出品 | OSC开源社区（ID：oschina2013）&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;DevOps 一直是开发者的重点关注领域，外媒 openlogic 联合 OSI 统计了各行各业 2600 多名开源用户的数据，得出了一份 2022 年开源状态报告，根据统计的数据总结了 2022 年最受欢迎的 5 大开源自动化和编排技术，以及开发团队选择这些技术的标准和常见问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于&lt;strong&gt;自动化和编排技术&lt;/strong&gt;的调查范围，本次参与调查的工具主要有 Puppet、Ansible、Chef、Salt、Kubespray、Terraform、Rancher 和 Zabbix ，而 GitHub Actions、GitLab、Jenkins X、Jenkins、Spinnaker、Travis CI、Tekton、 Zuul 被视作 CI/CD 工具，不作统计。 &lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2022 年最受欢迎的 5 大开源自动化和编排技术&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1、Puppet&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2022 年的调查发现，Puppet 是自动化和编配技术中被采用最多的技术，26.6% 的受访者使用该软件。上一次调查 Puppet 仅有 16%  的占比，可谓是迅猛增加。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2、Ansible&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Ansible 的采用率第二，24.8% 的受访者表示使用了该软件，上次调查是 24 % 占比，较为稳定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3、Chef&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; 23.4% 的人使用 Chef 作为自动化和编排工具。自上次调查以来，Chef 使用量增加了 10%，也是被市场认可的工具。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4、Salt&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Salt 的增长率位居第二，占比从 7% 提高到 21.9%，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;5、Kubespray&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;排名第五的 Kubespray 增长百分比最高，在之前的调查中，Kubespray 占比仅 5%，2022 年增长到 21.4%。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;选择开源自动化和编排工具的原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45661157024793386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRcUoYeP8wph5fF55thQfUD1ZIicJWL8e5B8FZMLa6RYzicvDTFv2l4yabg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;968&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调查结果显示，大型组织选择自动化和编排工具的主要原因是新特性和功能、安全访问和控制，而小型组织选择自动化和编排工具的关键原因是客户群的不断扩展，需要自动化工具来维持产品的安全和稳定。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源自动化和编排技术面临的主要问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4483837330552659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRKibMkIxZD11PiaYXJBZqJiaSRc6h8eyRrYIdyXqSNs98v5uJ8NW4T9YAMWERJYw4XAYibs5YQ0vDZ6pwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;959&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;安装、升级和配置问题是开源自动化和编排技术的最大挑战：并非每个组织都拥有熟悉自动化和编排工具的 DevOps 团队。对很多开发者来说 DevOps 其实是一项从未接触过的新工具，很容易在复杂的安装和配置过程中陷入困境，然后花费大量的时间查资料解决问题，这对小型组织来说是非常昂贵的人力资源和学习成本。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;从统计结果来看， DevOps 领域内采用开源技术变得更加普遍。openlogic 之前的调查发现 50% 的开发者从未使用过任何开源自动化和编排技术。而 2022 年的调查中这一数据仅剩 16% 。但采用并不意味着能掌握，大部分采用这些开源技术的组织在安装、配置、升级以及熟练部署方面都遇到了困难，这意味着开源自动化和编排技术的资料和教程仍需进一步完善。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;感兴趣的朋友可以查看 openlogic 的开源调查报告和开源自动化和编排技术排行博客。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;开源调查报告：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;https://www.openlogic.com/resources/2022-open-source-report&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;编排技术排行博客：&lt;span&gt;https://www.openlogic.com/blog/top-open-source-automation-and-orchestration-trends-2022&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;https://www.openlogic.com/resources/2022-open-source-report&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;---END---&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3NDA4OTk1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/UDxcwVqYKV9IOTr5rggNKcaXwzBdaq9EG6A3Jib6YGFIWjCh0rpwGlapib9GGcr9TeSRcEqasuom6dLibqswdq1Mw/0?wx_fmt=png&quot; data-nickname=&quot;数据库开发&quot; data-alias=&quot;DataBase1024&quot; data-signature=&quot;分享数据库开发、原理和应用，涵盖MySQL、PostgreSQL、MS SQL Sever、Oracle等主流关系数据库的应用和原理，以及MongoDB、Redis、Memcached等NoSQL数据库和缓存技术。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>788f5af52a2d9dc44a67a7814e9f0b71</guid>
<title>正确复制、重写别人的代码，为什么是件很酷的事情</title>
<link>https://toutiao.io/k/li8d566</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx2q9iciaNlK44cAQ5icVeTJeTCU7HqkpFu4oRQOHSzDP7lCH4gvaOPqvbg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;
作者 | Erik Hermansen&lt;/section&gt;&lt;section&gt;
译者 | Sambodhi&lt;/section&gt;&lt;section&gt;
策划 | 闫园园&lt;/section&gt;&lt;p&gt;我最近在一篇文章提到，工程师应该怎样避免使用大量的库、包以及其他依赖关系。我建议的另一种方案是，如果你没有达到重用第三方代码的阈值时，那么你就可以自己编写代码。&lt;/p&gt;&lt;p&gt;在本文中，我将讨论一个在重用和从头开始编写之间的抉择。这些技术能为你提供良好的综合优势。你将会听到我提到的一些在不同编程语言 / 环境下的例子。但是，这篇文章的层次足够高，而且说实话，你在什么环境下工作，并不重要。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5578571428571428&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxGzexT7cibibA3W7ibQv0C8F8m9SKJhTfqNC2ibPKv3QsYXLqPuOUFKSiaEg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们一再要求她把字写得小一点。她浪费了那么多纸张。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 四种编码技术&lt;/section&gt;&lt;p&gt;设想你所处的情况是这样的，你希望你的软件能够完成当前无法完成的任务。比如，你也许想要一份 PDF 格式的报告，方便打印。但是你的软件并不会输出 PDF。作为一名工程师，你要做的工作就是解决这个问题。&lt;/p&gt;&lt;p&gt;下图展示了四种不同的技术来添加这个功能。我并没有提到“这四种技术”。当然，我肯定还有更多的技术，包括镖靶和猴子。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31285714285714283&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx7j3anMPVL2dZ1I8yYJMXCicEtTwyuoMPu9JlcmtibU7RgCZYkG81Azew/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;为什么这么多决定都要权衡利弊呢？这真的很让人恼火。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重用&lt;/strong&gt;：根据你的环境，你可能会在 lib 中建立链接，或者在 &lt;code&gt;pom.xml&lt;/code&gt; 或 &lt;code&gt;package.json&lt;/code&gt; 中添加一个条目。不管你怎么做，“重用”就是抓取别人的代码，通过它的接口来使用，而不去关心它的内部结构。这段代码还可能会“偷渡”到一群横向的依赖关系中去，这会给你带来麻烦。最少的努力，带来的是最少的控制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;复制&lt;/strong&gt;：从 Github repo、代码片段集或者其他地方，选择你所需要的代码。然后把它直接粘贴到你的项目中。这段代码已经存在于你的代码库中，而不再是一个依赖关系。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重写&lt;/strong&gt;：采用一些适合你的第三方代码，通过重写，使其成为你自己的代码。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;编写&lt;/strong&gt;：你自己编写所有的代码，用自己的脑子，不借用任何人的东西。Ayn Rand 和 Casey Muratori 将尊重你的决定。最大的努力，将得到最大限度的控制。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了确保我上面的图表给人留下正确的印象，我给了它两把斧子——一把是努力，一把是控制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5064285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx9nuiacfib4BUyuNnobZqVlOU9YO8Wzic3UAwXlTicYC3IYhfdYEPS3JuSg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;另一方面，这家伙的两把斧子也让人印象深刻。&lt;/p&gt;&lt;p&gt;所有这四种技术都是在努力和控制之间的权衡。&lt;/p&gt;&lt;p&gt;你可以通过重用快速地获取大量的功能，然后以软件膨胀、黑盒调试、安全修补和耦合升级的形式遭受缺乏控制的痛苦。在重用的情况下，你不一定会面临这些问题，但是这样做的风险会增大。在你的项目中添加的每一行代码就好像是一张彩票，会“赢得”一个非常糟糕的问题。&lt;/p&gt;&lt;p&gt;或者在这张图的另一端，你从头开始编写所有的代码，你将会对进入项目的新代码进行完全的控制。不过，你可以花些无聊的时间去把所有的东西都按你的想法去编写，而你却成了编程的天后。&lt;/p&gt;&lt;p&gt;在我以前的一篇文章《多编写，少重用》（Write More, Reuse Less）中，我已经详细地阐述了重用和编写之间的权衡。&lt;/p&gt;&lt;p&gt;我将会深入探讨两种中间技术（复制和重写）。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 复制&lt;/section&gt;&lt;p&gt;有许多可以复制代码的好地方。如果你要完成的任务可以用一句话来完成，而且代码不超过 100 行即可实现，那么，你只需把问题输入到搜索引擎，就能轻松地找到。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6350245499181669&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxZrnXsJ52PCBVpJ0OibB4cabOJp7dTuSOibvh8Sw3msibRud5mtsafPRGw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;与 DuckDuckGo 相比，谷歌最大的优势在于：“DuckDuckGo”作为动词，在会话中会让人感到难堪。&lt;/p&gt;&lt;p&gt;用这种方式来搜索一些简单的代码任务的问题，你将很快就能找到代码的天堂。&lt;/p&gt;&lt;p&gt;我从 StackOverflow、W3Schools、MDN、Unity Answers 和各种我懒得记住的地方复制了很多代码。我总是先从搜索引擎开始，在那里提出问题。通常情况下，我会先从我工作的语言 / 平台开始，然后再提问。在我敲代码的时候，看一下自动完成的内容往往很有帮助。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; GitHub Copilot&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4635714285714286&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxLNrh62keCMgaLupcVOsqy2oWHJorPExeCADLZu8atXDZeIthIH2Q4Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;从复制人类答案的机器人那里复制你的答案。&lt;/p&gt;&lt;p&gt;如果你更愿意相信由复杂的人工智能为你编写的代码片段，可以试试 GitHub Copilot。这是一个集成到 IDE 中的插件。基本上，你并不需要在搜索引擎中输入你想要的东西，而是将该文本输入一个略微详细的源码注释即可。然后，实现的源代码就会自动填充在下面。&lt;/p&gt;&lt;p&gt;是真的！我不是在开玩笑。请看一些关于它的视频。&lt;/p&gt;&lt;p&gt;&lt;span&gt;视频地址：https://youtu.be/FHwnrYm0mNc&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这使我既害怕又激动。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 超越代码片段&lt;/section&gt;&lt;p&gt;如果你想要为更大的功能部分复制代码，那么只要：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;寻找包含这些功能的开源项目；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将所需的文件复制过来。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我刚才提出的一种做法，不是很傻就是很疯狂。我真心希望你能想到下面那个问题。别让我跟你扯淡。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;5&lt;/span&gt; “什么时候从第三方项目中复制会比直接导入更好？”&lt;/section&gt;&lt;p&gt;如果你仅仅想将一个依赖关系的所有未改变的文件复制到你的项目中，那么我将会发现这种复制方法的缺陷。你复制的源码不会轻易地被更新到依赖关系的新版本。这就意味着你会错过 Bug 修复、新功能和安全补丁。&lt;/p&gt;&lt;p&gt;尽管在一些情况下，对某个特定版本的代码进行快照非常有价值，但是你可以通过构建清单（例如 Java 中的 &lt;code&gt;pom.xml&lt;/code&gt;，Node 中的 &lt;code&gt;package.json&lt;/code&gt;）使用固定版本来完成同样的事情。而且如果你决定要升级的话，那么你可以轻易地更新一个固定版本。&lt;/p&gt;&lt;p&gt;另外一个潜在的复制理由是，你可能需要对项目的源码进行修改。如果你要进行增量更改，你可以最好这样做：1. 从原项目中创建一个复刻项目；或者 2. 把你的更改贡献给原项目。这样可以让你在以后更容易从原项目中收到修改。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4928571428571429&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxgPSpmezstQJYYulht2kzx3ViapSg4AWuEYypwroDFeAg7T1GQqPZCDg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有三种不同的方式可以让你在你的项目中修改他人的代码。最上面的一种做法是不好的。&lt;/p&gt;&lt;p&gt;这也许是你大规模、全面地修改你的代码库。你准备在以后的合并项目中，把一切后路都堵死。那真是太好了。这往往是有正当理由的。但是我在本文中所提供的定义是，对源码的大规模结构性的修改属于“重写”技术，下面我会详细讨论。&lt;/p&gt;&lt;p&gt;我唯一能想到的一个很好的理由就是，将第三方项目的代码复制（而非重写）到你的项目中：你只需在这个项目中得到一些源码即可。&lt;/p&gt;&lt;p&gt;而这种理由出现的频率超出了你的想象。大型 Node 包，如 Lodash 和 TurfJS，都是非常聪明的，它们会提供子集包，这些子集包只是为了你需要的特定功能在函数级颗粒度来导入。不过，在野外中也有很多臃肿的怪物。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxLkruib1ocAO5wFVmnXib8WF746PG252qhbPgP46XARTic6sbK6KUJPoWA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;Nodelerfish 需要你的爱。但不要让它进入你的项目中。&lt;/p&gt;&lt;p&gt;你也许只需要使用 50 行代码就可以完成的库 API。但是单体导入的库，可能会拉来数十万行代码，特别是那些具有横向依赖关系。在这种情况下，将一个子集复制下来，而非将其导入到整个该死的烂摊子中，这完全是很合理的。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;6&lt;/span&gt; 开源许可证&lt;/section&gt;&lt;p&gt;我不是一个律师。既然我不是律师，我就会把我在开源许可方面的实践告诉你。你可以咨询顶级律师团队，以达成你自己的决策。&lt;/p&gt;&lt;p&gt;笔者作为非律师，是如何做的：&lt;/p&gt;&lt;p&gt;如果我把源码复制到我的项目中，我把它和导入代码一样对待，并遵循所有的许可条款。在开源软件许可的条款中，一般都是指分发源码或者从许可源码中构建的行为。如果复制的代码是我发布版本的一部分，那么它也算作分发。对于我使用的确切的开源许可证，我也非常谨慎，例如，GPL 可能会要求我使用 GPL 许可证来许可我自己的代码库，而 MIT 许可证几乎不要求我做任何事情。&lt;/p&gt;&lt;p&gt;我还喜欢将复制的代码归入“第三方”目录（例如 Github 上的例子），然后在文档的顶部添加注释，这样就可以保证所有的内容都是一致的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2757142857142857&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxianDy2PEqT2920FqJq5eNHsHbia8bbTepiagvaianYCQhrJjMcHeDHHdJA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;他们不认识我，但 Matt Daly 和 Chris Anderson 是我的代码兄弟。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;7&lt;/span&gt; 重写的优点&lt;/section&gt;&lt;p&gt;你知道你正在复制的代码里有什么吗？它是适合你的代码吗？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4542857142857143&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxxeO9NF537Yzn5NYqZ2GqdkeOeanpic8FMfM4L3952UuM697PSJxuaMA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于某些测试，复制别人的答案效果并不好。&lt;/p&gt;&lt;p&gt;你能够而且应当对其他人的代码进行判断。或许不要对这段代码做出无情的评论。但是，请务必为自己的利益，私下评估第三方代码。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;8&lt;/span&gt; 重写代码片段&lt;/section&gt;&lt;p&gt;如果是 200 行以内的代码片段，或者是复制的代码，我一定会逐行重写代码，这样可以了解到这些代码是如何工作的，并且做一些改动，使之更适合我的项目。这是为数不多的几次在其他方面进行毫无意义的、风格化的编辑，是有价值的。&lt;/p&gt;&lt;p&gt;我要举一个具体的例子来说明。现在，我要从互联网上某个地方随机找出一个代码片段，然后进行重写。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24928571428571428&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxG4Rv2DCC90uI7bTLX5n1ekQgZKdTjwdgs14QbJjDFoUJMKNbfiaj82w/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;左边的代码是原来的。右边的代码是我重写的。&lt;/p&gt;&lt;p&gt;我重写的 代码片段 是由 StackOverflow 上一位名叫“Mark”的人发布的。他的代码通过对每一个点与它的左右邻居进行平均，使折线图中参差不齐的高峰和低谷变得平滑。&lt;/p&gt;&lt;p&gt;概括地说，在重写代码中，我做了以下的改动：&lt;/p&gt;&lt;p&gt;我编写代码的风格并不比 Mark 的好。它只不过是碰巧以正确的方式触动了我的大脑。这并不足以让 Mark 的代码发生改变。下面是重写他的代码片段的真实益处：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;我学会了这个算法。我现在完全明白这个折线图平滑的工作原理了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我创建的代码对我而言更易于维护，即使对 Mark 来说并不是这样。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我可以把那些和我需求无关的部分代码删除掉。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我确认了代码没有任何错误，比如，无限循环。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我已经确认了没有引入安全漏洞，比如在 DOM 中注入一个 &lt;code&gt;querystring&lt;/code&gt; 变量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我已经确认了，这些代码没有添加任何额外的依赖关系，比如某些统计库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我了解到另外一位工程师很享受编写代码的乐趣，并且有机会把他的实践为我自己所用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以，这种浅重写是一种很好的方式，可以把别人的代码导入到你的项目中。有些问题是可以避免的。你可以根据你的用例和其他需求对代码进行调整。另外，你还可以在学习新的算法和实践中，成长为一名工程师。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;9&lt;/span&gt; 重写的许可考虑因素&lt;/section&gt;&lt;p&gt;笔者作为非律师，是如何做的：&lt;/p&gt;&lt;p&gt;我想，完全的逐行重写应该可以免除几乎所有开源软件许可的法律义务。但是我始终坚持着开源的理念，例如，在源码的注释中引用原作，或者为原项目提供帮助。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;10&lt;/span&gt; 更深入的重写和修剪&lt;/section&gt;&lt;p&gt;有时候，你希望导入多个文档或数千行的源码，并做大量的改动，以让新代码适合你的项目。尤其是，修剪掉你实际上不需要的东西，是很好的做法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6142857142857143&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx94wMVAGv5wBG72mX6rRIfsLZGstkLBjmIceqjPBCLbyUz7EQQXEqwQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;当攀爬到一棵树上修剪时，我建议你在面向树干的那一侧坐下来进行修剪。&lt;/p&gt;&lt;p&gt;下面是一个简单的复制和修剪的方法：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将所有的依赖源文件复制到你的项目中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;确保你所需的功能能够在实践中起作用。单元测试一般都是非常有用的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;把你不需要的部分删除。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重复第 2 和第 3 步，直至剩余的代码能够符合你的需求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;至少对剩余的代码进行一次浅重写，这样才能保证你能够了解并从中得到其他的益处。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;你的 IDE 的选择和配置应该能够很好地支持你完成这项任务，包括提示、语法高亮和通知功能，这些功能可以向你显示：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;哪些代码在调用函数。（修剪它们？)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;哪些函数从未被调用。（修剪它们！)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;哪些变化会破坏你的构建。（取消修剪！)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果你的 IDE 没有为你对这些进行适配，可以花点时间去做更好的设置。&lt;/p&gt;&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 可以让你设定一个很好的状态，在你因过度修剪而破坏一些东西的时候，能够恢复到之前的状态。这是一张很好的安全网，可以使你的工作速度更快。&lt;/p&gt;&lt;p&gt;我都能听见你想说什么了……&lt;/p&gt;&lt;section&gt;
&lt;span&gt;11&lt;/span&gt; “可是，要重写代码的话，实在是太费事了！”&lt;/section&gt;&lt;p&gt;我不是说你一定要重写。只有在一些情况下，如果你这么做，就能得到很好的回报。我来告诉你一个真实的案例，我重写了一个第三方项目，并且从中获益良多。&lt;/p&gt;&lt;p&gt;我先从依赖树开始，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxeibYm6yY76mUPWM7ObEDo19mocgy0yNjOEuibadDaVnyPNm3wefzfMUw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;在花了半天时间完成重写之后，我去掉了 5 个依赖关系的需求，最后得到了如下结果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21642857142857144&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxZQ6uI6HvzicOrDbzm7k6o5sy60IYrpWIPvticdcwnvhfdcwCljf4mLlQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有一个名为“microphone-stream”的 NPM 包，我在 Web 应用中使用它来发送从麦克风捕获的样本缓冲区到语音识别包（Cieran O&#x27;Reilly 的 vosk-browser，如果你有兴趣的话）中的一个接口。&lt;/p&gt;&lt;p&gt;我最初是在“让它工作”的开发阶段使用 &lt;code&gt;microphone-stream&lt;/code&gt;。它包含在一个示例 Web 应用项目中，我已经将其复制到我的项目中。&lt;code&gt;microphone-stream&lt;/code&gt; 运行得很好，直到我升级了一个构建工具（Webpack），这破坏了 &lt;code&gt;readable-stream&lt;/code&gt; 的构建，这是一个更高级别的依赖包。我研究了对这两个第三方库中任何一个可能的 PR 修复。不过，向仓库提交一个好的修改需要花费好几天时间。我由于种种理由而拒绝了其他的变通方案。&lt;/p&gt;&lt;p&gt;通过查看 &lt;code&gt;microphone-stream&lt;/code&gt; 的代码，我意识到我并不需要该库的核心功能：一个 Node.js 风格的流接口。因此，我认真地重写了那些我真正需要的那部分代码，把那些我不想要的东西删除掉。&lt;/p&gt;&lt;p&gt;一路走来，我在源码中发现了这样的宝藏：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18571428571428572&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxszrsEOXJpuLTVTuz04tnWKjrtquRObCVBGEndBOG8C1ibgJnhicJdOqQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;还有这个：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0MckxD582Afia9UqibhGnrPMlr0egKCXBOVxIVicbDtMiapibAibpibnTrfDylqSVg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;我很感激地将这些想法合并到我重写的代码中。&lt;/p&gt;&lt;p&gt;作者 Nathan Friedly 在这样的源码注释中阐述了他的思考过程。也许他拯救了我，可能让我以后不用再找漏洞来修复了。从这个角度来看，重写比从头开始编写要好。你可以“捕捉”到别人来之不易的知识。&lt;/p&gt;&lt;p&gt;因此，对我来说，这是一个明显的案例，重写，而非重用，可以节约我的时间，并且让我得到更好的结果。重写也比从头开始编写要好，因为这样可以让我了解其他工程师的真实经验，否则我可能会错过这些经验。&lt;/p&gt;&lt;p&gt;复制和重写——试试吧！&lt;/p&gt;&lt;p&gt;这是好东西。这算不上作弊。&lt;/p&gt;&lt;p&gt;只要遵循开源许可的条款，和你的工程师伙伴成为好邻居吧。&lt;/p&gt;&lt;p&gt;你不希望复制或重写所有的东西。但是要学习辨别哪些情况值得你这么做。&lt;/p&gt;&lt;p&gt;并享受与其他人工作中的联系。那些数以百万计的项目，都是由伟大的头脑构建的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6414285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfMjJNVYekGvvqOXAgy0Mckx59cPsDu8kjWCaNSrM48vA463B0EwDRsVFHcTwY1r1c7pjUwwIwVbLw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;好吧，这个特别的孩子可能复制得太多了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者介绍：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Erik Hermansen，博主，撰写关于工程、技术，以及人机共同构成的系统的文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://levelup.gitconnected.com/copying-other-peoples-code-is-very-cool-717e8a72aa3b&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt; 今日文章推荐&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247526287&amp;amp;idx=1&amp;amp;sn=40ccfa506d54ac807f42ccec549f9426&amp;amp;chksm=e8d4984ddfa3115bbf70989c1bcab4f8ed1bd0e969eba46629b2157e2a94734676c317e290f5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;谷歌工作十年，我总结了这些工程师必备软技能&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;谷歌工作十年，我总结了这些工程师必备软技能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247526174&amp;amp;idx=1&amp;amp;sn=523a1c69928eaf3d5228d124450f49cf&amp;amp;chksm=e8d498dcdfa311ca4692a85d1be0b3def9d826cbb6c8aadfcd24a435f765404dfe126703311c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;InfoQ 2022 年趋势报告：DevOps 与云计算篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;InfoQ 2022 年趋势报告：DevOps 与云计算篇&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt; 活动推荐&lt;/section&gt;&lt;/section&gt;&lt;p&gt;云原生环境下，混沌的微服务架构、多语言的应用、多种网络调用协议并存给可观测性带来埋点成本上升、观测数据割裂、问题定位麻烦等挑战。&lt;/p&gt;&lt;p&gt;7 月 15-16 日 ArchSummit 全球架构师峰会将落地深圳，大会设置了「可观测性技术落地探索」专题，邀请到了阿里、PingCAP、微众银行、TT 语音等公司的嘉宾向大家分享可观测性技术落地的相关实践经验，点击阅读原文查看大会更多精彩内容。&lt;/p&gt;&lt;p&gt;大会已进入倒计时，现场席位有限，了解大会详情或预订门票请咨询小助手：18514549229（微信同电话)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9907407407407407&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfM309BBOzAe3aB7ERfdIqkRGPkc2pJIHicvQG0vsgRMatSKlbqnS1DcVouWsQYCJ8eHhribcxwahZuQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3943f00f34fad794ad60b273b92948cb</guid>
<title>如何使用Go调用Kubernetes API？</title>
<link>https://toutiao.io/k/ctnjr3u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;官方的Kubernetes Go客户端装载了高级抽象——Clientset、Informers、Cache、Scheme、Discovery，哦，天哪！当我尝试在没有学习移动部分的情况下使用它时，我遇到了大量的新概念。这是一次不愉快的经历，但更重要的是，它削弱了我在代码中做出明智决定的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，我决定通过对客户端组件的彻底研究来解开这个谜。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但是从哪里开始呢？在剖析client-go本身之前，了解它的两个主要依赖项可能是一个好主意，k8s.io/api和k8s.io/apimachinery模块。这将简化主要任务，但这不是唯一的好处。&lt;/span&gt;&lt;span&gt;这两个模块被分离出来是有原因的——它们不仅可以被客户端使用，也可以被服务器端使用，或者被处理Kubernetes对象的任何其他软件使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I5xhIIhlIRZE5OVDzdJofMOvicUKCKEbt43r6XFK4wDl8H7sCBvzFgFuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4722222222222222&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API资源、类和对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;首先，快速&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;amp;mid=2247544647&amp;amp;idx=2&amp;amp;sn=721d6dcfc8f9eb6e5f4c95b528757375&amp;amp;chksm=c03b6554f74cec42de34bfdba9f0c2424726fbaf02b7cf8fcc98312c11a72e78072be01d4db6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;回顾一下&lt;/a&gt;。熟悉以下概念对进一步讨论的成功至关重要：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;资源类型——一个由Kubernetes API端点服务的实体：Pod、Deployment、ConfigMap等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API组——资源类型被组织成版本化的逻辑组：apps/v1、batch/v1、storage.k8s.io/v1beta1等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对象——一个资源实例——每个API端点都处理特定资源类型的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类——API返回或接受的每个对象都必须符合一个对象模式——由其类型定义的属性的特定组合Pod、Deployment、ConfigMap等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;同样重要的是要区分广义对象和Kubernetes的“一级”对象——像Pod、Service或Secret这样的持久实体，它们作为集群的意图的记录。虽然为了序列化和反序列化，每个API对象都必须有一个API版本和类型属性，但并不是每个API对象都是“一级”Kubernetes对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I58BchNCCxpgYbJZg4tAeXLK57fdIo5zBibLOOZiaibw6aDmhvBmrADIibxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5287037037037037&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;2&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Go是一种静态类型的编程语言。那么，与Pod、ConfigMap、Secret和其他一级Kubernetes对象对应的所有结构在哪里呢？对，在k8s.io/api。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尽管命名松散，k8.io/api模块似乎只用于API类型定义。它充满了固定结构，与我们都知道和喜爱的YAML体现的那些内容非常相似：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt;  &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  appsv1 &lt;span&gt;&quot;k8s.io/api/apps/v1&quot;&lt;/span&gt;&lt;br/&gt;  corev1 &lt;span&gt;&quot;k8s.io/api/core/v1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  deployment := appsv1.Deployment{&lt;br/&gt;    Spec: appsv1.DeploymentSpec{&lt;br/&gt;      Template: corev1.PodTemplateSpec{&lt;br/&gt;        Spec: corev1.PodSpec{&lt;br/&gt;          Containers: []corev1.Container{&lt;br/&gt;            { Name:  &lt;span&gt;&quot;web&quot;&lt;/span&gt;, Image: &lt;span&gt;&quot;nginx:1.21&quot;&lt;/span&gt; },&lt;br/&gt;          },&lt;br/&gt;        },&lt;br/&gt;      },&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;%#v&quot;&lt;/span&gt;, &amp;amp;deployment)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个模块不仅定义了顶层的Kubernetes对象，就像上面的部署一样，还为它们的内部属性定义了许多辅助类型：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// PodSpec is a description of a pod.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PodSpec struct {&lt;br/&gt;  Volumes []Volume `json:&lt;span&gt;&quot;volumes,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge,retainKeys&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,1,rep,name=volumes&quot;&lt;/span&gt;`&lt;br/&gt;  &lt;br/&gt;  InitContainers []Container `json:&lt;span&gt;&quot;initContainers,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,20,rep,name=initContainers&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;br/&gt;  Containers []Container `json:&lt;span&gt;&quot;containers&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,2,rep,name=containers&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;  EphemeralContainers []EphemeralContainer `json:&lt;span&gt;&quot;ephemeralContainers,omitempty&quot;&lt;/span&gt; patchStrategy:&lt;span&gt;&quot;merge&quot;&lt;/span&gt; patchMergeKey:&lt;span&gt;&quot;name&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,34,rep,name=ephemeralContainers&quot;&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;  RestartPolicy RestartPolicy `json:&lt;span&gt;&quot;restartPolicy,omitempty&quot;&lt;/span&gt; protobuf:&lt;span&gt;&quot;bytes,3,opt,name=restartPolicy,casttype=RestartPolicy&quot;&lt;/span&gt;`&lt;br/&gt;    &lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kubernetes中定义的所有结构k8s.io/api模块自带JSON和Protobuf注解。但要注意：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;专业提示&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：如果你去阅读源码，你会看到k8s.io/apimachery通过对提供的对象调用标准的json.marshal()来实现JSON的序列化。因此，不要害怕，只要需要转储API对象，就使用json.Marshal()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结一下，k8s.io/api模块：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/apimachinery模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不像简单的k8s.io/api模块，k8s.io/apimachery模块是相当复杂的。README[2]将其目的描述为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个库是服务器和客户端使用Kubernetes API基础设施的共享依赖项，不需要直接的类型依赖项。它的第一批消费者是k8s.io/kubernetes、k8s.io/client-go、k8s.io/apiserver。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要在一篇文章中涵盖apimachinery模块的所有职责是很困难的。因此，我将讨论这个模块中最常见的包、类型和功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;有用的结构和接口&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api模块专注于具体的高级类型，如Deployment、Secret、Pod，k8s.io/apimachery是低层但更通用的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，Kubernetes对象的所有这些公共属性：apiVersion、kind、name、uid、ownerReferences、creationTimestamp等。如果我要构建自己的Kubernetes自定义资源，我就不需要自己为这些属性定义数据类型——这要感谢apimachery模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/apimachery/pkg/apis/meta包定义了两个方便的结构体：TypeMeta和ObjectMeta，它们可以嵌入到用户定义的结构体中，使其看起来像任何其他Kubernetes对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;此外，TypeMeta和ObjectMeta结构实现了meta.Type和meta.Object接口，可用于以通用方式指向任何兼容对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49537037037037035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I5MHlxKlAA7VCpT4spaFGHVias6wI0zlxGGiaiaStOzKGYuJJ1fsk8kJD7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在apimachery模块中定义的另一个方便的类型是接口runtime.Object。由于其简单的定义，它可能看起来毫无用处：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// pkg/runtime&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Object interface {&lt;br/&gt;  GetObjectKind() schema.ObjectKind&lt;br/&gt;  DeepCopyObject() Object&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但实际上，它被用得很多！Kubernetes的代码是在Go获得真正泛型支持之前很久编写的。因此，runtime.Object很像传统的接口——它是一个泛型接口，在代码库中广泛地进行类型断言和类型切换。而实际的类型可以通过检查底层对象的类型来获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;runtime.Object实例可以指向任何具有kind属性的对象——成熟的Kubernetes对象、不携带元数据的更简单的API资源，或者具有定义良好的对象方案的任何其他类型的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，虽然看起来相似，但meta.Object不能安全地向下转换到相应的Kubernetes对象，因为它的结构偏移量不为零。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;更有用的apimachery类型：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;PartialObjectMetadata结构——meta.TypeMeta和meta.ObjectMeta作为一种通用的方法来表示任何具有元数据的对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;APIVersions、APIGroupList、APIGroup结构体——还记得kubectl get的&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg5Mjc3MjIyMA==&amp;amp;mid=2247544676&amp;amp;idx=2&amp;amp;sn=a5584d8a3101e59a8ef2bd5878f20708&amp;amp;chksm=c03b6577f74cec61efe3303d911894c6e886e9f840ce45dd2ecc1a16f0cbbdcd5698a63fcd41&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;API探索练习吗&lt;/a&gt;？原始API这些和类似的结构用于Kubernetes，API资源的类型，但不是Kubernetes对象（例如，它们有kind和apiVersion属性，但没有真正的Object元数据）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;GetOptions、ListOptions、UpdateOptions等等——这些结构体代表了客户端对资源的相应动作的参数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;GroupKind、GroupVersionKind、GroupResource、GroupVersionResource等——简单的数据传输对象，包含组、版本、类型或资源字符串的元组。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在讨论Scheme和RESTMapper之前，请记住GroupVersionKind和GroupVersionResource——他们的知识将派上用场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;非结构化的结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;是的，你没听错。撇开玩笑不谈，它是另一种重要且广泛使用的数据类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用固定k8s.io/api类型处理Kubernetes对象很方便，但如果：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你需要以通用的方式使用Kubernetes对象？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你不想或不能依赖于API模块？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;你需要使用API模块中没有定义的自定义资源？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;非结构化，用于救援的非结构化结构！这个结构体允许没有注册Go结构体的对象被操作为通用的JSON类对象：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; Unstructured struct {&lt;br/&gt;  // Object is a JSON compatible map with&lt;br/&gt;  // string, &lt;span&gt;float&lt;/span&gt;, int, bool, []interface{}, or&lt;br/&gt;  // map[string]interface{} children.&lt;br/&gt;  Object map[string]interface{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// And &lt;span&gt;for&lt;/span&gt; the list of objects you can &lt;br/&gt;// use the UnstructuredList struct.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UnstructuredList struct {&lt;br/&gt;  Object map[string]interface{}&lt;br/&gt;&lt;br/&gt;  Items []Unstructured&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;实际上，这两个结构只是map[string]interface{}。不过，它们附带了一堆方便的方法，简化了嵌套属性访问和JSON序列化/反序列化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/blob/5b220c4572d65ea8bf0ad68e369e015902e7521c/crud-dynamic-simple/main.go#L36&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类型转换——非结构化到类型化，反之亦然&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;自然的，需要将非结构化对象转换为具体k8s.io/api类型（反之亦然）。runtime.UnstructuredConverter接口及其默认实现DefaultUnstructuredConverter可以帮助你：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; UnstructuredConverter interface {&lt;br/&gt;  ToUnstructured(obj interface{}) (map[string]interface{}, error)&lt;br/&gt;  FromUnstructured(u map[string]interface{}, obj interface{}) error&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/tree/main/convert-unstructured-typed&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对象序列化为JSON、YAML或Protobuf&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在处理来自静态类型语言的API时，另一项乏味的任务是将数据结构编组和解组到它们的连线表示中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;大量的apimachery代码都用于此任务‍‍：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// pkg/runtime&lt;br/&gt;&lt;br/&gt;// Encoder writes objects to a serialized form&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Encoder interface {&lt;br/&gt;  Encode(obj Object, w io.Writer) error&lt;br/&gt;  Identifier() Identifier&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Decoder attempts to load an object from data.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Decoder interface {&lt;br/&gt;  Decode(&lt;br/&gt;    data []byte,&lt;br/&gt;    defaults *schema.GroupVersionKind,&lt;br/&gt;    into Object&lt;br/&gt;  ) (Object, *schema.GroupVersionKind, error)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Serializer interface {&lt;br/&gt;  Encoder&lt;br/&gt;  Decoder&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;注意到上面的代码片段中的这些对象了吗？是的，这些是runtime.Object，也就是Kind-able接口实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例子:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-typed-json&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-typed-yaml&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-unstructured-json&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/serialize-unstructured-yaml&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;模式和RESTMapper&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Schema在使用client-go时，模式概念随处出现，特别是在编写处理自定义资源的控制器（或操作符）时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;我花了一段时间才明白它的目的。但是，按照正确的顺序处理事情会有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;考虑一下非结构化到类型化转换的潜在实现：有一个类似json的对象，以及一些具体k8s.io/api类型需要从它创建。也许，第一步就是要弄清楚如何使用kind字符串创建一个空的类型化对象实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一个简单的方法可能看起来像一个巨大的switch语句，覆盖所有可能的类型（实际上是API组）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;import (&lt;br/&gt;  appsv1 &lt;span&gt;&quot;k8s.io/api/apps/v1&quot;&lt;/span&gt;&lt;br/&gt;  corev1 &lt;span&gt;&quot;k8s.io/api/core/v1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func New(apiVersion, kind string) runtime.Object {&lt;br/&gt;  switch (apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind) {  &lt;br/&gt;  &lt;span&gt;case&lt;/span&gt;: &lt;span&gt;&quot;v1/Pod&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;corev1.Pod{}&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt;: &lt;span&gt;&quot;apps/v1/Deployment&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;appsv1.Deployment{}&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;更聪明的方法是使用反射。不是开关，而是映射[字符串]反射。类型可以为所有注册类型维护：&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;type&lt;/span&gt; Registry struct {&lt;br/&gt;  map[string]reflect.Type types&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *Registry) Register(apiVersion, kind string, typ reflect.Type) {&lt;br/&gt;  r.types[apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind] = typ&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (r *Registry) New(apiVersion, kind string) runtime.Object {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; r.types[apiVersion + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + kind].New().(runtime.Object)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这种方法的优点是不需要生成代码，并且可以在运行时添加新的类型映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;现在，考虑一个反序列化问题：需要将一段YAML或JSON转换为一个类型化对象。第一步——对象创建——将非常类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;事实证明，通过API组和类型创建空对象是一项非常频繁的任务，以至于它在apimachery模块——运行时中获得了自己的模块——runtime.Schema：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// Scheme defines methods &lt;span&gt;for&lt;/span&gt; serializing and deserializing API objects, a &lt;span&gt;type&lt;/span&gt;&lt;br/&gt;// registry &lt;span&gt;for&lt;/span&gt; converting group, version, and kind information to and from Go&lt;br/&gt;// schemas, and mappings between Go schemas of different versions. &lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Scheme struct {&lt;br/&gt;  gvkToType map[schema.GroupVersionKind]reflect.Type&lt;br/&gt;  &lt;br/&gt;  typeToGVK map[reflect.Type][]schema.GroupVersionKind&lt;br/&gt;  &lt;br/&gt;  unversionedTypes map[reflect.Type]schema.GroupVersionKind&lt;br/&gt;  &lt;br/&gt;  unversionedKinds map[string]reflect.Type&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Scheme结构就是这样一个注册表，它包含了所有Kubernetes对象的kind到type和type到kind的映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;记住，GroupVersionKind只是一个元组，即DTO结构，对吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;runtime.Scheme结构实际上是非常强大的，它有一大堆方法和实现一些基本的接口，如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// ObjectTyper contains methods &lt;span&gt;for&lt;/span&gt; extracting &lt;br/&gt;// the APIVersion and Kind of objects.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ObjectTyper interface {&lt;br/&gt;  ObjectKinds(runtime.Object) ([]schema.GroupVersionKind, bool, error)&lt;br/&gt;  Recognizes(gvk schema.GroupVersionKind) bool&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// ObjectCreater contains methods &lt;span&gt;for&lt;/span&gt; instantiating&lt;br/&gt;// an object by kind and version.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ObjectCreater interface {&lt;br/&gt;  New(kind schema.GroupVersionKind) (out Object, err error)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;然而，runtime.Schema不是万能的。它有从kind到type的映射，但是如果不是只有资源名已知而不是类型呢?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这就是RESTMapper的作用所在：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;type&lt;/span&gt; RESTMapper interface {&lt;br/&gt;  // KindFor takes a partial resource and returns the single match.  Returns an error &lt;span&gt;if&lt;/span&gt; there are multiple matches&lt;br/&gt;  KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)&lt;br/&gt;&lt;br/&gt;  // KindsFor takes a partial resource and returns the list of potential kinds &lt;span&gt;in&lt;/span&gt; priority order&lt;br/&gt;  KindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error)&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt;  &lt;br/&gt;  ResourceSingularizer(resource string) (singular string, err error)&lt;br/&gt;}&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;RESTMapper也是某种注册表。但是，它维护资源到种类的映射。因此，向映射器提供一个像apps/v1/Deployment这样的字符串，就会得到API Group apps/v1和部署类型。RESTMapper还可以处理资源快捷方式和奇点化: po、pod和pods可以注册为相同资源的别名。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.487962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzC9vlNS5jTmI3X1lJiaicP0I55JWfn1RIIDmulBO0000F26E6z8hppQOiaWgB2sev5ib6mHW5T4RQHLkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通常情况下，会有一个全局的单例运行时。然而，似乎apimachery模块本身试图避免状态——它定义了RESTMapper和Scheme结构，但没有实例化它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不像运行时。该方案被apimachery模块本身广泛使用，RESTMapper在内部没有使用，至少目前没有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;字段和标签选择器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;字段和标签的类型、创建和匹配逻辑也存在于apimachery模块中。例如，这里是k8s.io/apimachinery/pkg/labels包：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;lbl := labels.Set{&lt;span&gt;&quot;foo&quot;&lt;/span&gt;: &lt;span&gt;&quot;bar&quot;&lt;/span&gt;}&lt;br/&gt;sel, _ = labels.Parse(&lt;span&gt;&quot;foo==bar&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; sel.Matches(lbl) {&lt;br/&gt;  fmt.Printf(&lt;span&gt;&quot;Selector %v matched label set %v\n&quot;&lt;/span&gt;, sel, lbl)&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例子:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/label-selectors&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;https://github.com/iximiuz/client-go-examples/tree/main/field-selectors&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;API错误处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在代码中使用Kubernetes API是不可能的，除非正确处理它的错误。API服务器可能完全消失，请求可能未经授权，对象可能丢失，并发更新可能发生冲突。幸运的是，k8s.io/apimachery /pkg/api/errors包定义了一些方便的实用函数来处理API错误。下面是一个例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;_, err = client.&lt;br/&gt;  CoreV1().&lt;br/&gt;  ConfigMaps(&lt;span&gt;&quot;default&quot;&lt;/span&gt;).&lt;br/&gt;  Get(&lt;br/&gt;    context.Background(),&lt;br/&gt;    &lt;span&gt;&quot;this_name_definitely_does_not_exist&quot;&lt;/span&gt;,&lt;br/&gt;    metav1.GetOptions{},&lt;br/&gt;  )&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; !errors.IsNotFound(err) {&lt;br/&gt;  panic(err.Error())&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例：https://github.com/iximiuz/client-go-examples/tree/main/error-handling&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其他&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;最后但并非最不重要的是，apimachery/pkg/util包充满了有用的东西。下面是一些例子:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;4&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;k8s.io/api和k8s.io/apimachery包是学习如何在Go中使用Kubernetes对象的一个很好的起点。如果你需要编写你的第一个控制器，直接跳到client-go，甚至跳到controller-runtime或kubebuilder可能会让你的学习经历变得太复杂——可能会有太多的知识缺口。不过，先看看API和apimachery包，然后再尝试一下，这将帮助你在接下来的旅程中保持平和的心态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;相关链接：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/kubernetes/api/tree/35d41aaac2bf55a353ccade31b852d466b2495c2#recommended-use&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://github.com/kubernetes/apimachinery/tree/3d7c63b4de4fdee1917284129969901d4777facc#purpose&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击下方卡片关注&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分布式实验室&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，和&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;我们&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一起&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注分布式最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5Mjc3MjIyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzCwsauR1olj2b0tyPJXRBicSkuNEiaBuN8AQ61xkz4dH9DBr1PypYtFlEnczVkAeQvLz7rjsjttotCg/0?wx_fmt=png&quot; data-nickname=&quot;分布式实验室&quot; data-alias=&quot;DistributedLab&quot; data-signature=&quot;关注分布式相关的开源项目和基础架构，致力于分析并报道这些新技术是如何以及将会怎样影响企业的软件构建方式。&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▲&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;点击上方卡片关注分布式实验室，掌握前沿分布式技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有想一起学习K8s、考CKA证书吗？来，这里有最好的学习方案，&lt;/span&gt;&lt;span&gt;线下3天封闭式培训，15人小班课，考不过免费复训&lt;/span&gt;&lt;span&gt;。Kubernetes实战班，7月22日在深圳开课，扫描下方二维码咨询详情。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzDGnTiaw7Teu5bSfO5NUAibEHyvmB2iaJArRBNbhOCawDQg6x23yR12zmh5B4sFCMv8eyq5LpuNTFU2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66ce12b5c95af1042d0a7777c67da45b</guid>
<title>多线程使用不当导致的 OOM</title>
<link>https://toutiao.io/k/67rtbou</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;事故描述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 6 点 32 分开始少量用户访问 App 时会出现首页访问异常，到 7 点 20 分首页服务大规模不可用，7 点 36 分问题解决。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-1&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-id=&quot;heading-1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;整体经过&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6:58  发现报警，同时发现群里反馈首页出现网络繁忙，考虑到前几日晚上门店列表服务上线发布过，所以考虑回滚代码紧急处理问题。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7:07 开始先后联系 XXX 查看解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;7:36  代码回滚完，服务恢复正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;事故根本原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事故代码模拟：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Executor executor = Executors.newFixedThreadPool(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CompletionService&amp;lt;String&amp;gt; service = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;&amp;gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        service.submit(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;HelloWorld--&quot;&lt;/span&gt; + Thread.currentThread().getName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;根源就在于 ExecutorCompletionService 结果没调用take、poll方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正确的写法如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Executor executor = Executors.newFixedThreadPool(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CompletionService&amp;lt;String&amp;gt; service = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;&amp;gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    service.submit(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;HelloWorld--&quot;&lt;/span&gt; + Thread.currentThread().getName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    service.take().get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一行代码引发的血案，而且不容易被发现。因为 OOM 是一个内存缓慢增长的过程，稍微粗心大意就会忽略。如果是这个代码块的调用量少的话，很可能几天甚至几个月后暴雷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;操作人回滚或者重启服务器确实是最快的方式。但是如果不是事后快速分析出 &lt;span&gt;OOM &lt;/span&gt;的代码，而且不巧回滚的版本也是带 &lt;span&gt;OOM &lt;/span&gt;代码的，就比较悲催了。如刚才所说，流量小了、回滚或者重启都可以释放内存；但是流量大的情况下，除非回滚到正常的版本，否则 GG。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;探寻问题根源&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了更好的理解 ExecutorCompletionService 的 “套路”，我们用 ExecutorService 来作为对比，可以让我们更好地清楚什么场景下用 ExecutorCompletionService。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看 ExecutorService 代码（建议下载后自己跑一跑）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test1&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws Exception&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutorService executorService = Executors.newCachedThreadPool();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ArrayList&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futureArrayList = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;公司让你通知大家聚餐 你开车去接人&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Future&amp;lt;String&amp;gt; future10 = executorService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：我在家上大号 我最近拉肚子比较慢 要蹲1个小时才能出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：1小时了 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    futureArrayList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(future10);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Future&amp;lt;String&amp;gt; future3 = executorService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：我在家上大号 我比较快 要蹲3分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：3分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    futureArrayList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(future3);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Future&amp;lt;String&amp;gt; future6 = executorService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：我在家上大号  要蹲10分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：10分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    futureArrayList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(future6);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;都通知完了,等着接吧。&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (Future&amp;lt;String&amp;gt; future : futureArrayList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            String returnStr = future.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(returnStr + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;，你去接他&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread.currentThread().&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三个任务，每个任务执行时间分别是 10s、3s、6s 。通过 JDK 线程池的 submit 提交这三个 Callable 类型的任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一步：主线程把三个任务提交到线程池里面去，把对应返回的 Future 放到 List 里面存起来，然后执行“都通知完了,等着接吧。”这行输出语句；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二步：在循环里面执行 future.get() 操作，阻塞等待。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7463175122749591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zL0icanklE7x5mSD3qpMiaQSsb4JYjYKUA6D977IkVagRT76OsPvmS15A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先通知到总裁，也是先接总裁 足足等了 1 个小时，接到总裁后再去接研发和中层管理，尽管他们早就完事儿了，也得等总裁上完厕所~~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;耗时最久的-10s 异步任务最先进入 list 执行。所以在循环过程中获取这个 10 s的任务结果的时候，get 操作会一直阻塞，直到 10s 异步任务执行完毕。即使 3s、5s 的任务早就执行完了也得阻塞，等待 10s 任务执行完。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这里，尤其是做&lt;strong&gt;网关业务&lt;/strong&gt;的同学可能会产生共鸣。一般来说，网关 RPC 会调用下游 N 多个接口，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43148148148148147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zfzyAWezuMwgUblYT1CP2yzVgf8kzuZJxGcibyj4iaicrj5WPbLBkxicqaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果都按照 ExecutorService 这种方式，并且恰巧前几个任务调用的接口耗时比较久，同时阻塞等待，那就比较悲催了。所以 ExecutorCompletionService 应景而出。它作为任务线程的合理管控者，“任务规划师”的称号名副其实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相同场景 ExecutorCompletionService 代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test2&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws Exception&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutorService executorService = Executors.newCachedThreadPool();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExecutorCompletionService&amp;lt;String&amp;gt; completionService = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;&amp;gt;(executorService);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;公司让你通知大家聚餐 你开车去接人&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    completionService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：我在家上大号 我最近拉肚子比较慢 要蹲1个小时才能出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁：1小时了 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;总裁上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    completionService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：我在家上大号 我比较快 要蹲3分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发：3分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;研发上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    completionService.submit(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：我在家上大号  要蹲10分钟就可以出来 你等会来接我吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理：10分钟 我上完大号了。你来接吧&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;中层管理上完大号了&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;都通知完了,等着接吧。&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String returnStr = completionService.take().&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(returnStr + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;，你去接他&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Thread.currentThread().&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跑完结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7018927444794952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55z5icCLCTBOVgQdwXsmawDc8u7ndiaAz7w5AKZuic1vcqpUomGFsEa2uicPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这次就相对高效了一些。虽然先通知的总裁，但是根据大家上大号的速度，谁先拉完先去接谁，不用等待上大号最久的总裁了（现实生活里建议采用第一种，不等总裁的后果 emmm 哈哈哈）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;放在一起对比下输出结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3602533650039588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55z6oNK35cW7PibnBEHp3F6002qfahBLIagh21ruW9PIx1MrJPicTEhicHuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2526&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两段代码的差异非常小 获取结果的时候 ExecutorCompletionService 使用了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;completionService&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.take&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要用 take() 然后再 get() 呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看看源码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CompletionService 接口以及接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、ExecutorCompletionService 是 CompletionService 接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5581967213114755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zQm6sJ3hVklvxoX0BsXX9lSdjesRn5tdqMj4PTWEbumXdgfjIN4wt9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、接着跟一下 ExecutorCompletionService 的构造方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到入参需要传一个线程池对象，默认使用的队列是 LinkedBlockingQueue，不过还有另外一个构造方法可以指定队列类型，如下两张图，有两个构造方法。&lt;/span&gt;&lt;span&gt;默认 LinkedBlockingQueue 的构造方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48872180451127817&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zNo6jeVpsLlpfricEwzPy1enXOckzyv6jbNM5KXf469AtBDC9ibxXU7Sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1862&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可选队列类型的构造方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3760245901639344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zSmPbX5tVtTLRt0gICGwE2hYOJ3Tmiaq77ymoUPx6SddMo3Ugw5f9C6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1952&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、Submit 任务提交的两种方式，都是有返回值的，我们例子中用到的就是第一种 Callable 类型的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5482717520858165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zpvVBaicnDMZicnvqEUKI4yuA8cBT9bD2h4vfjYAYuNobiafiaBU4uCa4Gg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1678&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、对比ExecutorService 和 ExecutorCompletionService 的 submit 方法可以看出区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5312117503059975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55z3BsaZ1kS8f9JEGC8NODLWO83wZd3iaNuLJibFnFLB8ZyXeqFrY9Hw8aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1634&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; （1）ExecutorService&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35685752330226367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zick3QFcBGnicygia5cSuKzxrq9gejT7wJzWEX672INbUZCYN03OoShVXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1502&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）ExecutorCompletionService&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、差异就在 &lt;strong&gt;QueueingFuture。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个到底作用是啥，我们继续跟进去看：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;QueueingFuture 继承自 FutureTask，而且红线部分标注的位置，重写了 done() 方法；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;把 task 放到 completionQueue 队列里面。当任务执行完成后，task 就会被放到队列里面去了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;此时此刻，completionQueue 队列里面的 task 都是已经 done() 完成了的 task。而这个 task 就是我们拿到的一个个的 future 结果；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果调用 completionQueue 的 task 方法，会阻塞等待任务。等到的一定是完成了的 future，我们调用  .get() 方法 就能立马获得结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6790393013100436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zLUkBicWNicaj0Lia4tLMibia1iaoicVkPU1nrQGPH4WnODy3gNZicbkc4IKicBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1832&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这里，相信大家伙都应该多少明白点了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们在使用 ExecutorService submit 提交任务后需要关注每个任务返回的 future。然而 CompletionService 对这些 future 进行了追踪，并且重写了 done 方法，让你等的 completionQueue 队列里面一定是完成了的 task；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;作为网关 RPC 层，我们不用因为某一个接口的响应慢拖累所有的请求，可以在处理最快响应的业务场景里使用 CompletionService。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是&lt;strong&gt;请注意&lt;/strong&gt;！也是本次事故的核心问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有调用了 ExecutorCompletionService 下面的 3 个方法的任意一个时，阻塞队列中的 task 执行结果才会从队列中移除掉，释放堆内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于该业务不需要使用任务的返回值，&lt;strong&gt;没有调用 take、poll 方法&lt;/strong&gt;，从而导致没有释放堆内存。堆内存会随着调用量的增加一直增长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4687116564417178&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eZzl4LXykQxobdPTK1ErJSSpb06Ik55zUNBaZ4O8M3TnfCjtib58TSZsPyvMyplnrRXjUofaUPB48PuUvyzKpkw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1630&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，业务场景中不需要使用任务返回值的，别没事儿使用 CompletionService。假如使用了，记得一定要从阻塞队列中移除掉 task 执行结果，避免 OOM！&lt;/span&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-4&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-id=&quot;heading-4&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知道事故的原因，我们来总结下方法论。毕竟孔子他老人家说过：自省吾身，常思己过，善修其身！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;上线前&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;严格的代码 review 习惯，一定要交给 back 人去看，毕竟自己写的代码自己是看不出问题的，相信每个程序猿都有这个自信；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上线记录：备注好上一个可回滚的包版本（给自己留一个后路）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上线前确认回滚后，业务是否可降级。如果不可降级，一定要严格拉长这次上线的监控周期。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;上线后&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;持续关注内存增长情况（这部分极容易被忽略，大家对内存的重视度不如 CPU 使用率）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;持续关注 &lt;span&gt;CPU &lt;/span&gt;使用率增长情况&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GC 情况、线程数是否增长、是否有频繁的 Full GC 等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关注服务性能报警，TP99、999 、MAX 是否出现明显的增高。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;45&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;转自：树洞君，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：juejin.cn/post/7064376361334358046&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651489176&amp;amp;idx=1&amp;amp;sn=372225b68021cd8e19380527dfc985c8&amp;amp;chksm=bd25efe78a5266f156f6235d221c674ad13e6c49e6133869806a283a7760bbe427a8a0273525&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;线程池运用不当的一次线上事故&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;线程池运用不当的一次线上事故&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651481184&amp;amp;idx=1&amp;amp;sn=83c6ac6b4f7743042787f22a60ecbf65&amp;amp;chksm=bd25081f8a5281094497f394d63f0597c4c0b8c52214f5afb73234456a2cb5c1a21f8b708da4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;干货！一次 kafka 卡顿事故排查过程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;干货！一次 kafka 卡顿事故排查过程&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651481184&amp;amp;idx=1&amp;amp;sn=83c6ac6b4f7743042787f22a60ecbf65&amp;amp;chksm=bd25081f8a5281094497f394d63f0597c4c0b8c52214f5afb73234456a2cb5c1a21f8b708da4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;干货！一次 kafka 卡顿事故排查过程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651513163&amp;amp;idx=1&amp;amp;sn=aabba4f4d206119f811550fbc0d74906&amp;amp;chksm=bd258d348a520422a17602d22f71e590d34a23822d5a499c55a7865db31cee55ba8a7089968c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring 官方推荐的 @Transactional 还能导致生产事故？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring 官方推荐的 @Transactional 还能导致生产事故？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>687010981dcc4e228d8bff66d11181ef</guid>
<title>月活 12.8 亿的微信，海量请求下是如何防止崩溃的？</title>
<link>https://toutiao.io/k/fflgnsh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;一、背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;最近在研究过载保护，微信是一个国民级的应用，月活用户过 10 亿，而且经常过年过节消息量暴增，服务很容易出现过载，但微信的服务一直比较稳定，他们是怎么做的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文以微信 2018 年发表于 Socc 会议上的文章，《Overload Control for Scaling Wechat Microservices》 为基础，介绍了微信大规模微服务的过载保护策略，其中很多方法很有借鉴意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是对这篇文章做的一些解读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、过载保护基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、什么是服务过载?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;服务过载就是服务的请求量超过服务所能承受的最大值，从而导致服务器负载过高，响应延迟加大，用户侧表现就是无法加载或者加载缓慢，这会引起用户进一步的重试，服务一直在处理过去的无效请求，导致有效请求跌 0，甚至导致整个系统产生雪崩。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、为什么会发生服务过载？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;互联网天生就会有突发流量，秒杀，抢购，突发大事件，节日，甚至恶意攻击等，都会造成服务承受平时数倍的压力，微博经常出现某明星官宣结婚或者离婚导致服务器崩溃的场景，这就是服务过载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、过载保护的好处&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;主要是为了提升用户体验，保障服务质量，在发生突发流量时仍然能够提供一部分服务能力，而不是整个系统瘫痪，系统瘫痪就意味着用户流失，口碑变差，夫妻吵架，甚至威胁生命安全（假如腾讯文档崩溃，这个文档正好用于救灾）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、微信中的过载场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;微信采用的是微服务，说是微服务，其实我理解就是采用统一的 RPC 框架搭建的一个个独立的服务，服务之间互相调用，实现各种各样的功能，这也是现代服务的基本架构。毕竟谁也不想看到我朋友圈崩了，导致我聊天也不行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微信这边的服务是分三层，接入服务，逻辑服务，基础服务，大多数服务属于逻辑服务，接入服务比如登录，发消息，支付服务，每日请求量在 10 亿-100 亿之间，入口协议触发对逻辑服务和基础服务更多的请求，核心服务每秒要处理上亿次的请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;339&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5962962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YRTHwf3iaCWE5MQQBtKhgkTNs5bjOxTXgdViczPa5icHCicPJC8Fy9uup79TExicZh3NHz6PSng8l7OjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大规模微服务场景下，过载会变得比较复杂，如果是单体服务，一个事件只用一个请求，但微服务下，一个事件可能要请求很多的服务，任何一个服务过载失败，就会造成其他的请求都是无效的。如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;190&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.33425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YRTHwf3iaCWE5MQQBtKhgkTpt1QHMzRnPQsLFJfsbgWfT3G7NnmseDMsCPGlM7kxrJGF4ic82icXcAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在一个转账服务下，需要查询分别两者的卡号， 再查询 A 时成功了，但查询 B 失败，对于查卡号这个事件就算失败了，比如查询成功率只有 50%， 那对于查询两者卡号这个成功率只有 50% * 50% = 25% 了， 一个事件调用的服务次数越多，那成功率就会越低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、如何判断过载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;通常判断过载可以使用吞吐量，延迟，CPU 使用率，丢包率，待处理请求数，请求处理事件等等。微信使用在请求在队列中的平均等待时间作为判断标准，就是从请求到达，到开始处理的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为啥不使用响应时间？因为响应时间是跟服务相关的，很多微服务是链式调用，响应时间是不可控的，也是无法标准化的，很难作为一个统一的判断依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那为什么不使用 CPU 负载作为判断标准呢， 因为 CPU 负载高不代表服务过载，因为一个服务请求处理及时，CPU 处于高位反而是比较良好的表现。实际上 CPU 负载高，监控服务是会告警出来，但是并不会直接进入过载处理流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;腾讯微服务默认的超时时间是 500ms，通过计算每秒或每 2000 个请求的平均等待时间是否超过 20ms，判断是否过载，这个 20ms 是根据微信后台 5 年摸索出来的门槛值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用平均等待时间还有一个好处，是这个是独立于服务的，可以应用于任何场景，而不用关联于业务，可以直接在框架上进行改造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当平均等待时间大于 20ms 时，以一定的降速因子过滤调部分请求，如果判断平均等待时间小于 20ms，则以一定的速率提升通过率，一般采用快降慢升的策略，防止大的服务波动，整个策略相当于一个负反馈电路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;263&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.4638888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YRTHwf3iaCWE5MQQBtKhgkTKkzLSpLar6kGzUkmCWq7uIPAk038NDVF6OkfybxiagiaiaoCVFERZNXqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、过载保护策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一旦检测到服务过载，需要按照一定的策略对请求进行过滤，前面分析过，对于链式调用的微服务场景，随机丢弃请求会导致整体服务的成功率很低。所以请求是按照优先级进行控制的， 优先级低的请求会优先丢弃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、业务优先级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;对于不同的业务场景优先级是不同的， 比如登录场景是最重要的业务，不能登录一切都白瞎，另外支付消息比普通消息优先级高，因为用户对金钱是更敏感的，但普通消息又比朋友圈消息优先级高，所以在微信内是天然存在业务优先级的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户的每个请求都会分配一个优先级，并且在微服务的链式调用下，下游请求的优先级也是继承的，比如我请求登录，那么检查账号密码等一系列的的后续请求都是继承登录优先级的，这就保证了优先级的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个后台服务维护了业务优先级的 hash 表，微信的业务太多了，不是每个业务都记录在表里，不在表里的业务就是最低优先级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.562037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YRTHwf3iaCWE5MQQBtKhgkTsZd3k5QvzQiauVM4pJml612A7SZMGFSyY9rLe7Oo2qNDdM9wKo30b2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、用户优先级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;很明显，只基于业务优先级的控制是不够的，首先不可能因为负载高，丢弃或允许通过一整个业务的请求，因为每个业务的请求量很大，那一定会造成负载的大幅波动，另外如果在业务中随机丢弃请求，在过载情况下还是会导致整体成功率很低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决这个问题，可以引入用户优先级，首先用户优先级也不应该相同，对于普通人来说通过 hash 用户唯一 ID，计算用户优先级，为了防止出现总是打豆豆的现象，hash 函数每小时更换，跟业务优先级一样，单个用户的访问链条上的优先级总是一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里有个疑问，为啥不采用会话 ID 计算优先级呢，从理论上来说采用会话 ID 和用户 ID 效果是一样的，但是采用会话 ID 在用户重新登录时刷新，这个时候可能用户的优先级可能变了，在过载的情况下，他可能因为提高了优先级就恢复了，这样用户会养成坏习惯，在服务有问题时就会重新登录，这样无疑进一步加剧了服务的过载情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为引入了用户优先级，那就和业务优先级组成了一个二维控制平面，根据负载情况，决定这台服务器的准入优先级(B,U)，当过来的请求业务优先级大于 B，或者业务优先级等于 B，但用户优先级高于 U 时，则通过，否则决绝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;190&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.33425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YRTHwf3iaCWE5MQQBtKhgkTpt1QHMzRnPQsLFJfsbgWfT3G7NnmseDMsCPGlM7kxrJGF4ic82icXcAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、自适应优先级调整&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在大规模微服务场景下，服务器的负载是变化非常频繁的，所以服务器的准入优先级是需要动态变化的，微信分了几十个业务优先级，每个业务优先级下有 128 个用户优先级，所以总的优先级是几千个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何根据负载情况调整优先级呢？最简单的方式是从右到左遍历，每调整一次判断下负载情况，这个时间复杂度是 O(n), 就算使用二分法，时间复杂度也为 O(logn)，在数千个优先级下，可能需要数十次调整才能确定一个合适的优先级，每次调整好再统计优先级，可能几十秒都过去了，这个方法无疑是非常低效的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微信提出了一种基于直方图统计的方法快速调整准入优先级，服务器上维护者目前准入优先级下，过去一个周期的（1s 或 2000 次请求）每个优先级的请求量，当过载时，通过消减下一个周期的请求量来减轻负载，假设上一个周期所有优先级的通过的请求总和是 N，下一个周期的请求量要减少 N*a，怎么去减少呢，每提升一个优先级就减少一定的请求量，一直提升到 减少的数目大于目标量，恢复负载使用相反的方法，只不是系数为 b ，比 a 小，也是为了快降慢升。根据经验值 a 为 5%，b 为 1%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;428&quot; data-backw=&quot;560&quot; data-ratio=&quot;0.7642857142857142&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YRTHwf3iaCWE5MQQBtKhgkTTDnGrL0gAnCsCslk2MDHjMjXzzLH8blvZoqJ4fPg0m8AEZrY89s4MQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了进一步减轻过载机器的压力，能不能在下游过载的情况下不把请求发到下游呢？否则下游还是要接受请求，解包，丢弃请求，白白的浪费带宽，也加重了下游的负载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了实现这个能力，在每次请求下游服务时，下游把当前服务的准入优先级返回给上游，上游维护下游服务的准入优先级，如果发现请求优先级达不到下游服务的准入门槛，直接丢弃，而不再请求下游，进一步减轻下游的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;微信整个负载控制的流程如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;484&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.8527777777777777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8YRTHwf3iaCWE5MQQBtKhgkT0NWF4Itb0KtkTMIiaQibOo56rIXib1ibib8ibknZHlLuROkVoQuKBmMb7bxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当用户从微信发起请求，请求被路由到接入层服务，分配统一的业务和用户优先级，所有到下游的字请求都继承相同的优先级。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据业务逻辑调用 1 个或多个下游服务，当服务收到请求，首先根据自身服务准入优先级判断请求是接受还是丢弃。服务本身根据负载情况周期性的调整准入优先级。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当服务需要再向下游发起请求时，判断本地记录的下游服务准入优先级，如果小于则丢弃，如果没有记录或优先级大于记录则向下游发起请求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;下游服务返回上游服务需要的信息，并且在信息中携带自身准入优先级。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上游接受到返回后解析信息，并更新本地记录的下游服务准入优先级。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;整个过载保护的策略有以下三个特点：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;业务无关的，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;使用请求等待时间而不是响应时间，制定用户和业务优先级，这些都与业务本身无关。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;独立控制和联合控制结合，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;准入优先级取决于独立的服务，但又可以联合下游服务的情况，优化服务过载时的表现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;高效且公平，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 请求链条的优先级是一致的，并且会定时改变 hash 函数调整用户优先级，过载情况下，不会总是影响固定的用户。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85988&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨alexccdong&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：腾讯技术工程（ID：Tencent_TEG）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>