<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/5fkxdkk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e40612db8263f63026cc75f080194e7</guid>
<title>Go语言如何应对供应链攻击</title>
<link>https://toutiao.io/k/o0h7bt0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;现代软件工程是协作进行的，且基于对开源软件的复用，因此容易受到供应链攻击，即通过破坏软件项目的依赖对其进行攻击。无论采取什么流程或技术措施，每个依赖都不可避免地基于一种信任关系。不过，Go 语言的工具和设计可以帮助我们在各个阶段降低风险。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;所有构建都是“锁定的”（locked）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;任何外部变化（例如某个依赖发布了一个新版本）都不会自动影响 Go 程序的构建。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;与大多数其他包管理器不同，Go module 没有单独的约束关系列表或者一个锁定特定版本的 lock 文件。任意 Go 构建里的每个依赖的版本完全由 main module 的 go.mod 文件确定。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;从 Go 1.16 开始，这种确定性是默认的行为，如果 go.mod 不完整，构建命令（go build, go test, go install, go run, ...）就会失败。唯一能改变 go.mod（从而改变构建）的命令是 go get 和 go mod tidy。这两个命令不是用来自动运行或者在 CI 里运行的，所以对依赖树的改动必须是有意为之，还有机会经过代码审查。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;这对于安全性非常重要，当一个 CI 系统或者在新机器上运行 go build 时，已经 check in 的代码才最终决定哪些东西会被构建。第三方无法影响这一点。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;此外，当使用 go get 添加依赖时，由于使用了最小版本选择（minimal version selection）方法，它会按照依赖的 go.mod 文件中指定的版本添加传递依赖（transitive dependencies），而不是按照最新版本添加。运行 go install example.com/cmd/devtoolx@latest 的时候也一样。在某些生态系统中（比如 NPM），运行这样的安装命令会绕过锁定的版本。而在 Go 里面，虽然它会获取最新版本的 example.com/cmd/devtoolx ，但所有的依赖的版本都是由用户的 go.mod 决定的。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;如果某个 module 遭到破坏，发布了一个恶意的新版本，不会有人受到影响，除非他们明确要更新那个依赖。我们有机会去审查这样的改动，整个生态也有时间去发现这种恶意事件。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;版本内容永远不变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;确保构建不被第三方影响的另一个关键性质是一个 module 版本的内容是不可变的。否则如果攻击者能在入侵某个依赖以后还能重新上传一个已有的版本，那他就能直接入侵所有依赖它的项目了。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;这时就体现出了 go.sum 文件的作用。go.sum 文件中包含了构建所需的每个依赖的加密哈希值列表。与 go.mod 类似，不完整的 go.sum 会导致错误，而且只有 go get 和 go mod tidy 能够对其进行修改，所以它的任何改动都必将伴随着对依赖的有意改变。其他情况下的构建都保证有一套完整的校验值。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;大多数 lock 文件都有这一特性，但 Go 通过校验数据库（简称 sumdb）更进一步。sumdb 是一个全局的、只允许追加的（append-only）、可以加密验证的 go.sum 条目的列表。当 go get 需要在 go.sum 文件中添加一个条目时，它从 sumdb 中获取该条目，同时获取 sumdb 完整性的加密证明。这不仅确保了某个 module 的每个构建都使用相同的依赖内容，还确保了每个 module 都使用相同的依赖内容。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;sumdb 使得被破坏的依赖，甚至是 Google 运行的 Go 的基础设施，都不可能用篡改过的源代码来攻击某个特定依赖。这就保证了你使用的代码与其他人的代码完全一样，并且已经过审查。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;最后，我最喜欢的 sumdb 特性是：无需由 module 的作者来管理密钥，而且与 Go module 的去中心化特性完美契合。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;VCS 是真实的信息来源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;大多数项目都是通过使用一些版本控制系统（Version Control System，VCS）来开发的。在其他语言的生态中，这些项目需要上传到指定的软件仓库（package repository，比如 NPM）。这意味着有两个账户可能被入侵：一个是 VCS 主机，另一个是软件仓库，而后者的使用次数更少，更容易被忽视。这也意味着上传到仓库的版本中更容易隐藏恶意代码，尤其是作为上传过程的一个步骤，需要例行修改源码时，比如 minimize 代码。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;Go 不存在软件仓库账户。package 的 import 路径已经包含了 go mod download 所需要的信息，可以直接从 VCS 中获取对应的 module，而 VCS 里保存的 tag 就确定了版本。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;确实有一个东西叫做 Go Module Mirror，但它只是一个代理。module 的作者不需要注册账户，也不需要向代理上传版本。这个代理使用与 go 工具相同的逻辑（事实上，代理运行 go mod download）来获取、缓存一个版本。由于校验数据库确保一个特定的 module 版本只能有一个源码树，每个使用代理的人看到的结果与绕过代理直接从 VCS 获取的结果相同。如果该版本在 VCS 中不再可用，或者内容发生了变化，获取时将直接导致错误，而从代理获取可能仍然有效，这样提高了可用性，并且保护生态系统免受 “left-pad” 问题（“删库跑路”）的影响。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在客户端运行 VCS 工具会暴露相当大的攻击面。这是另一处 Go Module Mirror 有用的地方：代理上的 go 工具在一个强大的沙盒中运行，并且经过配置，支持所有的 VCS 工具，而默认的配置则只能支持两个主要的 VCS 系统（git 和 Mercurial）。使用代理的人仍然可以获取由其他 VCS 系统所发布的代码，但在大多数客户端环境中，攻击者都无法直接碰到这些代码。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;构建但不执行代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;Go 的工具链有一个明确的安全设计目标，即获取和构建代码时都不会执行代码，无论代码是否是不受信任的恶意代码。这与大多数其他的生态系统不同，它们很多都原生支持在获取 package 的时候运行代码。在一个依赖被入侵以后，这些 post-install hooks（安装后运行的钩子）可以轻易入侵开发者的机器，进而对 module 作者进行蠕虫攻击。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;不过话说回来，获取代码往往意味着会在不久之后执行它，要么是作为开发者机器上的测试的一部分，要么是作为生产环境的二进制文件的一部分，所以缺乏 post-install hooks 只能延缓攻击。构建的结果里是没有安全边界的：构建所用到的任何 package 都可以定义一个 init 函数。尽管如此，它作为一个降低风险的措施是有意义的，因为你执行的一个二进制文件或测试的一个 package 可能只用了这个 module 的一部分依赖。比如如果你在 macOS 上构建并执行 example.com/cmd/devtoolx，那么针对 Windows 的依赖或 example.com/cmd/othertool 的依赖就不可能危害到你的机器。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在 Go 中，某个构建没有用到的 module 对安全没有影响。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;&lt;strong&gt;A little copying is better than a little dependency&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;在 Go 的生态中，最后一个或许也是最重要的一个应对供应链风险的措施，同时也是最没有技术含量的一个，就是 Go 从文化上拒绝大型的依赖树，宁愿稍微复制一点代码，也不愿增加新的依赖。这可以追溯到 Go 的一句谚语：“A little copying is better than a little dependency”。高质量、可复用的 Go 模块往往有着光荣的“零依赖”标签。如果你只是需要一个库，通常不会面临需要依赖其他几十个 module 的情况。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;丰富的标准库和附加模块（golang.org/x/...）也使“零依赖”成为可能，它们提供了常用的上层基本功能，比如 HTTP、TLS、JSON。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;所有这些意味着只需少量的依赖就可以建立丰富、复杂的应用程序。但无论工具有多好，都不能消除复用代码的风险，所以最有力的应对措施永远都是一个比较小的依赖树。&lt;/span&gt;&lt;/p&gt;&lt;p dir=&quot;ltr&quot;&gt;&lt;span&gt;👇 点击查看原文&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a01c45fc692e81dcc8e1edb796c7b9bb</guid>
<title>用最简的方式学Vuex</title>
<link>https://toutiao.io/k/xfa0qtk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;冲！！！！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;一、基础&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex是一个专为Vue.js应用程序开发的状态管理模式，采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化，每一个Vuex应用的核心是store（仓库）。为了使用Vuex，首先需要安装该包，执行如下命令完成该安装过程。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install vuex@next --save&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、核心概念&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex中核心概念主要有五个：State、Getters、Mutations、Actions、Modules，每一部分都有自己的功用，下面先来看一段简单的代码，该代码中涉及到了这些核心概念，然后在该代码的基础上进一步理解。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.js文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {createStore} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {moduleA} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./module/moduleA&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; store = createStore({&lt;br/&gt;    &lt;span&gt;// Vuex允许将store分割成模块（module），每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 访问moduleA的状态：store.state.moduleA&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;modules&lt;/span&gt;: {&lt;br/&gt;        moduleA&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// module/moduleA.js文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 对于模块内部的mutation和getter，接收的第一个参数是模块的局部状态对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 对于模块内部的action，局部状态通过context.state暴露出来，根节点状态则为context.rootState&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 对于模块内部的getter，根节点状态会作为第三个参数暴露出来&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在带命名空间的模块内访问全局内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果希望使用全局state和getter，rootState和rootGetters会作为第三和第四个参数传入getter，也会通过context对象的属性传入action&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 若需要在全局命名空间内分发action或提交mutation，将{root: true}作为第三个参数传给dispatch或commit即可。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; moduleA = {&lt;br/&gt;    &lt;span&gt;// 默认情况下，模块内部的action、mutation和getter是注册在全局命名空间的，如果希望模块具有更高的封装度和复用性，可以通过添加namespaced:true的方式使其成为带命名空间的模块&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;namespaced&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;state&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;testState1&lt;/span&gt;: &lt;span&gt;&#x27;xxxx&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;testState2&lt;/span&gt;: {&lt;br/&gt;            &lt;span&gt;a&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;b&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;testState3&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 有的时候需要从store中的state中派生出一些状态，此时可以将该部分抽象出一个函数供多处使用。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Vuex允许在store中定义getter，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当他的依赖值发生了改变才会被重新计算&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;getters&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;// getter接收state作为其第一个参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;testGetter1&lt;/span&gt;: &lt;span&gt;&lt;span&gt;state&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; state.testState1 + state.testState3;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;// getter可以接受其他getter作为第二个参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;testGetter2&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;state, getters&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; getters.testGetter1.length;&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 更改Vuex的store中的状态的唯一方法是提交mutation，每个mutation都有一个字符串的事件类型和一个回调函数，该回调函数接收state作为第一个参数，提交的载荷作为第二个参数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 以相应的type调用store.commit方法来触发相应的回调函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Mutation必须是同步函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;mutations&lt;/span&gt;: {&lt;br/&gt;        testMutation1(state) {&lt;br/&gt;            &lt;span&gt;// 变更状态&lt;/span&gt;&lt;br/&gt;            state.testState3++;&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;// 第二个参数是载荷&lt;/span&gt;&lt;br/&gt;        testMutation2(state, payload) {&lt;br/&gt;            state.testState1 += payload.content;&lt;br/&gt;        }&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// Action提交的是mutation，而不是直接变更状态&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Action可以包含任意异步操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Action函数接受一个与store实例具有相同方法和属性的context对象，因此可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Action通过store.dispatch方法触发&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;actions&lt;/span&gt;: {&lt;br/&gt;        testAction1(context) {&lt;br/&gt;            setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                context.commit(&lt;span&gt;&#x27;testMutation1&#x27;&lt;/span&gt;);&lt;br/&gt;            }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        },&lt;br/&gt;        testAction2({commit}, payload) {&lt;br/&gt;            setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                commit({&lt;br/&gt;                    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;testMutation2&#x27;&lt;/span&gt;,&lt;br/&gt;                    &lt;span&gt;content&lt;/span&gt;: payload.content&lt;br/&gt;                });&lt;br/&gt;            }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;State&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex使用单一状态树保存所有数据，作为唯一数据来源。如上所示代码，其包含了testState1、testState2、testState3，在组件中如何获取这些数据呢？（Vue3.x语法）&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testState1}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testState2}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testState3}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;import {computed} from &#x27;vue&#x27;;&lt;br/&gt;import {useStore} from &#x27;vuex&#x27;;&lt;br/&gt;// 通过useStore函数来访问store，与选项式API&lt;br/&gt;const store = useStore();&lt;br/&gt;&lt;br/&gt;// 从store中读取状态并显示到Vue组件中最简单的办法是将其绑定到计算属性上&lt;br/&gt;// 如果想读取某一模块中的状态值，则需要store.state.模块名.状态名&lt;br/&gt;const testState1 = computed(() =&amp;gt; store.state.moduleA.testState1);&lt;br/&gt;const testState2 = computed(() =&amp;gt; store.state.moduleA.testState2.a + store.state.moduleA.testState2.b);&lt;br/&gt;const testState3 = computed(() =&amp;gt; store.state.moduleA.testState3);&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Getters&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有的时候需要从store中的state中派生出一些状态，此时可以将该部分抽象出一个函数供多处使用。Vuex允许在store中定义getter，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当他的依赖值发生了改变才会被重新计算。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&amp;lt;p&amp;gt;{{testGetter1}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;{{testGetter2}}&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;import {computed} from &#x27;vue&#x27;;&lt;br/&gt;import {useStore} from &#x27;vuex&#x27;;&lt;br/&gt;// 通过useStore函数来访问store，与选项式API&lt;br/&gt;const store = useStore();&lt;br/&gt;&lt;br/&gt;// ……&lt;br/&gt;&lt;br/&gt;// 在computed函数中访问getter&lt;br/&gt;// 如果访问非模块中的getter，直接store.getters.名称&lt;br/&gt;// 如果访问模块中的getter，通过store.getters[&#x27;getter路径&#x27;]&lt;br/&gt;const testGetter1 = computed(() =&amp;gt; store.getters[&#x27;moduleA/testGetter1&#x27;]);&lt;br/&gt;const testGetter2 = computed(() =&amp;gt; store.getters[&#x27;moduleA/testGetter2&#x27;]);&lt;br/&gt;&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Mutations&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更改Vuex的store中的状态的唯一方法是提交mutation，每个mutation都有一个字符串的事件类型和一个回调函数，该回调函数接收state作为第一个参数，提交的载荷作为第二个参数。（注意：Mutation必须是同步函数）&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&amp;lt;button @click=&quot;handleMutationsClick&quot;&amp;gt;改变&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&lt;br/&gt;// 与mutations相应的type调用store.commit方法来触发相应的回调函数&lt;br/&gt;const handleMutationsClick = () =&amp;gt; {&lt;br/&gt;    store.commit(&#x27;moduleA/testMutation1&#x27;);&lt;br/&gt;    store.commit(&#x27;moduleA/testMutation2&#x27;, {&lt;br/&gt;        content: &#x27;content&#x27;&lt;br/&gt;    });&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Actions&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Actions类似于mutation，但是仍然有一些不同点，一方面其提交的是mutation，而不是直接变更状态；另一方面Action可以包含任意异步操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;组件三&amp;lt;/h1&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&amp;lt;button @click=&quot;handleActionsClick&quot;&amp;gt;改变Action&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;// ……&lt;br/&gt;&lt;br/&gt;// Action函数接受一个与store实例具有相同方法和属性的context对象，因此可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。&lt;br/&gt;// Action通过store.dispatch方法触发&lt;br/&gt;const handleActionsClick = () =&amp;gt; {&lt;br/&gt;    store.dispatch(&#x27;moduleA/testAction1&#x27;);&lt;br/&gt;    store.dispatch(&#x27;moduleA/testAction2&#x27;, {&lt;br/&gt;        content: &#x27;test&#x27;&lt;br/&gt;    });&lt;br/&gt;};&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;style lang=&quot;less&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Modules&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于使用单一状态树，应用的所有状态都会集中到一个较大的对象，当应用变的复杂时store会变的很难维护，为了解决该问题，Vuex允许将store分割成模块（module），每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块，具体使用可见第二节中开头部分的代码，其中包含了其常见的使用方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、插件&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 插件基础&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex在实例化store的时候可以接受plugins选项，该选项可以添加一系列的插件，插件就可以帮助我们完成一系列的工作，节省人力和物力，下面我们自定义一个简单的插件并调用该插件。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// plugins/myPlugin.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 插件接收唯一的参数store&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; myPlugin = &lt;span&gt;&lt;span&gt;store&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// store上有一系列的方法，可以用在插件中https://next.vuex.vuejs.org/zh/api/#commit&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 注册一个动态模块用registerModule&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 替换store的根状态用replaceState&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 监听mutation的变化，该处理函数会在每个mutation完成后调用，接收mutation和经过mutation后的状态作为参数&lt;/span&gt;&lt;br/&gt;    store.subscribe(&lt;span&gt;(&lt;span&gt;mutation, state&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(mutation);&lt;br/&gt;    });&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; myPlugin;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; {createStore} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; myPlugin &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./plugins/myPlugin&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; store = createStore({&lt;br/&gt;    &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 一个数组，包含应用在store上的插件方法，这些插件直接接收store作为唯一参数，可以监听mutation或者提交mutation&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;plugins&lt;/span&gt;: [myPlugin]&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 数据持久化插件&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Vuex的状态存储并不能持久化，只要一刷新页面数据就丢失了，此时可引入vuex-persist插件来解决该问题，其会将状态保存至cookie或者localStorage中。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; {createStore} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; VuexPersistence &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vuex-persist&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; myPlugin &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./plugins/myPlugin&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 利用该插件可实现对store数据的持久化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vuexLocal = &lt;span&gt;new&lt;/span&gt; VuexPersistence({&lt;br/&gt;    &lt;span&gt;storage&lt;/span&gt;: &lt;span&gt;window&lt;/span&gt;.localStorage&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; store = createStore({&lt;br/&gt;    &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 一个数组，包含应用在store上的插件方法，这些插件直接接收store作为唯一参数，可以监听mutation或者提交mutation&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;plugins&lt;/span&gt;: [myPlugin, vuexLocal.plugin]&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>449ef624e0b83851b42eb2eef5c27abd</guid>
<title>Apache Doris 在有赞的初步尝试</title>
<link>https://toutiao.io/k/mgymcz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666667&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR79PE4l6LL8jUWcdBYy5LpgK4iaCKhqM0heACgGpu24ob9CSFe9KthkuyIn9uQCoQJgrObS18psSXyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;点击关注“&lt;span&gt;有赞coder&lt;/span&gt;”&lt;/p&gt;&lt;p&gt;获取更多技术干货哦～&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;作者:&lt;/span&gt;&lt;span&gt;郑生俊&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;有赞OLAP&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;有赞作为一家商家服务公司，OLAP对有赞非常重要，从商家后台的数据看板，再到最近有赞门罗发布会上的有赞贾维斯，都离不开OLAP。&lt;span&gt;具体到技术栈，有赞的MOLAP采用Apache Kylin（&lt;/span&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwODE3ODU5MA==&amp;amp;mid=2653082536&amp;amp;idx=1&amp;amp;sn=bfb919943201c2a32174519a58850c89&amp;amp;chksm=80a4ad59b7d3244f13bccc19a2ff4e9b89315ede3d78d0d375c0e404f39dfbb5a4cb324c7ee7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;有赞出品｜升级 Kylin 4 最强攻略！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;有赞出品｜升级 Kylin 4 最强攻略！&lt;/span&gt;&lt;/a&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;ROLAP 采用了ClickHouse&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxOTY5MDMxNA==&amp;amp;mid=2455762137&amp;amp;idx=1&amp;amp;sn=0b7bd5536bfb0de350e1d12aed677820&amp;amp;chksm=8c6872fcbb1ffbea37ece218a8e7184bc9b09c17ad1f3ebc67a3dc44273d112f00fa6b7834c3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ClickHouse 在有赞的实践之路&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ClickHouse 在有赞的实践之路&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;Apache Kylin在有赞内部已经非常稳定了，支撑了大量的高QPS的场景，并且它的存储计算分离架构能够很好地做到弹性伸缩来应对流量的高峰低谷。而ClickHouse作为ROLAP引擎最主要的问题有两块，一是扩缩容麻烦，二是单机的Join性能差。其中扩缩容的高成本是有赞数据团队在ROLAP最为头疼的问题，比如有赞门罗发布会发布了MA的优惠之后，因为ClickHouse扩容的时效性和复杂度，我们需要提前准备较多的硬件为ClickHouse扩容，以应对有可能的业务剧增。尤其是如果ClickHouse之上又有实时写入的场景、做了数据正交分布时，扩容就难上加难了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;试水Apache Doris&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了解决上面的问题，团队也尝试了ClickHouse on Apache Doris，但后来因为一些计划变动没有继续投入。欣慰的是Apache Doris在今年推出了向量化引擎，也在6月15号正式孵化为Apache顶级项目，它的设计上能够解决ClickHouse上述的问题。进而细看了Apache Doris的向量化引擎，基本上借鉴了前辈ClickHouse的做法。既然是站在巨人的肩膀上，我们觉得它应该是能够承载ClickHouse之上的业务。为此我们做了初步的性能测试和与Druid的兼容性测试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;查询性能：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在初步的性能测试过程中，结果还是比较惊喜的，比Druid快很多，也比之前非向量化的版本快很多，有些场景和ClickHouse差不多。查询这块主要分享一下我们最近在2phase aggregate做的优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;背景是我们测试在merge aggregate的过程中，发现第二阶段的聚合比第一阶段的聚合速度慢很多。首先解释一下merge aggregate，对于分布式聚合查询，数据通常都需要在某个算子预聚合后，再汇聚到下一个算子进行merge聚合。但我们从Doris的执行信息看到第二阶段的聚合比第一阶段的聚合慢不少，而测试场景下，二阶段聚合的数据量比第一阶段的聚合少很多，反而二阶段聚合的耗时还更高了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先尝试使用perftools来分析瓶颈点，找到核心的耗时代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;144&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhQS3B50nowBHKNrSUIKnUIWV9uJKqDibpjdtBH3sKOAVDMibUEpic0zNiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们找到上面代码，看了一下二阶段聚合的大致流程，大概有这么几步：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;反序列化一阶段的聚合结果，得到StringColumn&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将StringColumn，反序列化为对应列的数据类型（double、long、hll 等数据结构）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将对应的数据列（double、long、hll 等数据结构），转换为临时用来聚合的数据类型（AggregateData）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将临时的聚合对象与Hash表中存放的最终结果（也是AggregateData）进行聚合运算&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;销毁3步骤产生的临时聚合对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结合上面的perf采样图，我们可以看到大量的CPU消耗在：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将StringColumn反序列化为对应的数据类型，比如long、int、hll 等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将聚合的输入数据（long、int、hll）等转换为聚合需要的AggregateData，这里就有大量临时 对象/内存 的频繁创建和销毁&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决上述第一个问题，尝试了在第一阶段聚合结束之后，直接将结果转换为第二个阶段需要的数据类型。这样第二阶段的数据读取，只需要做对应指针类型的强制类型转换即可，而不需要再从StringColumn反序列化获得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决第二个问题，起初我尝试着分配整个块内存来存放要聚合的临时数据，然后最后释放整块内存，以此减少频繁的内存创建和销毁过程，但收效甚微。这时候我们去看看第一阶段聚合的代码为啥会更快，把原因说的通俗点就是：AggregateData可以直接与Block中的数据（double、long、hll 等数据结构）进行聚合运算，不需要将其转换为聚合的相同数据类型（AggregateData）进行聚合运算即可，这样避免大量 对象/内存 频繁的创建、销毁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照上面的思路改完代码之后，我们拿一个测试环境的例子看看性能提升，这是一个涉及到600w+数据读取的查询。查询了多次让磁盘数据进操作系统的cache之后比较RT，查询总耗时优化前810ms，优化后560ms，提升了30%的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化前：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;194&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.33515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhgNZMrzlmVIvOXUDQGJuiaDY4WROSqUSgxKzbNAGKQevcegRA54l53Kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;优化后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;181&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.31328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhcYOMvMmQK3pOgGSDN5ia5gmNIGVHqcRTDZUk1ia7SZQt4DzBRRfyo0oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然这个case从整体上看RT提升250ms，看着好像可有可无，但这是在降低了资源消耗的情况下达成，往往就意味着系统能够有更高的吞吐。而且数据量大了、查询更复杂之后会有更大的提升，毕竟Aggregate在OLAP中是一个高频操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从整体查询RT的视角，RT容易会有波动，但算子内MergeTime的指标统计不会，因为MergeTime指标统计的都是针对一个内存中Block的聚合耗时，排除了很多网络、IO的干扰因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化前：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0700934579439252&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhlpOpfsBMziaaQpbCzVZQIRybjImVgp87mKpHpTukhaKHoREibcqMCnEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;优化后：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1422018348623852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/PfMGv3PxR7ibO6HveicDsKMDSuG06qWvPhlWKQvm5fVwaocONgexxlnd91cdLOhXmLOibh1EKgNYS1AAxPajwjkZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可以看到MergeTime也大大降低了（其中 ExecTime 指标的变化可以忽略，因为走了不同的代码逻辑，是包含在MergeTime的统计之中的）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好在Doris的代码写的挺合理的，所以这个优化涉及到的代码量不多，有兴趣可以参考代码：&lt;/span&gt;&lt;span&gt;https://github.com/apache/doris/pull/10618/files。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;由于我们第一阶段的目标是将Doris替换Apache Druid，因此我们基于Druid场景做了一些兼容性测试。对于平台型团队而言，一旦上层有较多的业务，要推动底层的技术栈迭代和替换是比较困难的，因为通常业务方也很难抽出时间和我们陪跑做全面的兼容性测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此我们在Druid Broker处理完查询之后，将一个查询的SQL、RT记录数等信息发送到Kafka。然后由一个Kafka消费者消费上Druid的请求，做SQL改写，将Druid SQL转换为Doris的查询语句发往Doris进行流量回放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一些SQL的基本语法都是相同的，比较大的区别是  builtin 函数。有一些Druid  Function 的函数的参数入参含义、个数，都和Apache Doris有较大不同，这导致SQL改写的过程繁琐一些，但这对于平台型的服务团队通常是不得不做的过程。通过流量回放一来可以知道哪些不兼容的SQL语句要做什么样的调整，二来可以通过模拟线上查询情况的过程中确定哪些性能不符合性能预期、哪些查询是有Bug的，比如Druid时序数据查询中经常使用到的time_round_function计算有误（参考代码：https://github.com/apache/doris/pull/9712/files）。确定了上述的各方面的性能和兼容性没问题后，我们才能更高效地协调业务方做一些改造工作。目前我们已经回放了一部分线上查询，整体的业务改动点还好，性能也有较大提升。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;后续计划&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;至于后续的计划，我们的目标是视资源情况推进Doris在有赞落地，尽量将ClickHouse、Druid的技术栈收敛为Apache Doris，解决前面提到的问题，同时也做技术栈的收敛、迭代。当然这还有一些工作要做，包括兼容性测试、性能测试，确保业务上Doris与ClickHouse、Druid有相当的体验，为此我们也在尝试一些手写SIMD优化关键执行代码，希望最终能够借助Apache Doris解决我们ROLAP的痛点问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;‍‍&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7089bab4abe40fc0d174ef1200eb9290</guid>
<title>不知道这4种缓存模式，敢说懂缓存吗？</title>
<link>https://toutiao.io/k/nn8m95b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;h2 data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统架构中，缓存可谓提供系统性能的最简单方法之一，稍微有点开发经验的同学必然会与缓存打过交道，最起码也实践过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用得当，缓存可以减少响应时间、减少数据库负载以及节省成本。但如果缓存使用不当，则可能出现一些莫名其妙的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不同的场景下，所使用的缓存策略也是有变化的。如果在你的印象和经验中，缓存还只是简单的查询、更新操作，那么这篇文章真的值得你学习一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，为大家系统地讲解4种缓存模式以及它们的使用场景、流程以及优缺点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存策略的选择&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上来讲，&lt;strong&gt;缓存策略取决于数据和数据访问模式&lt;/strong&gt;。换句话说，数据是如何写和读的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;系统是写多读少的吗？（例如，基于时间的日志）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据是否是只写入一次并被读取多次？（例如，用户配置文件）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回的数据总是唯一的吗？（例如，搜索查询）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择正确的缓存策略才是提高性能的关键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的缓存策略有以下五种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Cache-Aside Pattern：旁路缓存模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Read Through Cache Pattern：读穿透模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Write Through Cache Pattern：写穿透模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Write Behind Pattern：又叫Write Back，异步缓存写入模式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述缓存策略的划分是基于对数据的读写流程来区分的，有的缓存策略下是应用程序仅和缓存交互，有的缓存策略下应用程序同时与缓存和数据库进行交互。因为这个是策略划分比较重要的一个维度，所以在后续流程学习时大家需要特别留意一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cache Aside&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache Aside是最常见的缓存模式，应用程序可直接与缓存和数据库对话。Cache Aside可用来读操作和写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;读操作&lt;/strong&gt;的流程图：&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p data-style=&quot;white-space: normal; background-color: rgb(255, 255, 255); color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 16px; text-align: right;&quot; class=&quot;js_darkmode__159&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6998535871156661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CmnN7FKTMS7PxgBaWAsa1cts9FAtr2j8ecV8FUwEZwjiazREAbp1HTJlZRA0B7xwBVJffx32NSia8dsYBwTPQVMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;Cache Aside Pattern&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读操作的流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;应用程序接收到数据查询（读）请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序所需查询的数据是否在缓存上：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果存在（Cache hit），从缓存上查询出数据，直接返回；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不存在（Cache miss），则从数据库中检索数据，并存入缓存中，返回结果数据；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们需要留意一个操作的边界，也就是数据库和缓存的操作均由应用程序直接进行操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;写操作&lt;/strong&gt;的流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36577181208053694&quot; data-type=&quot;jpeg&quot; data-w=&quot;1192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CmnN7FKTMS7PxgBaWAsa1cts9FAtr2j8DxFjDcwEVomcKMicQCPm920KDeF3D9BzXmpUPrnweX8coOicXIaRRg6g/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;Cache Aside Pattern&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的写操作，包括创建、更新和删除。在写操作的时候，Cache Aside模式是先更新数据库（增、删、改），然后直接删除缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache Aside模式可以说适用于大多数的场景，通常为了应对不同类型的数据，还可以有两种策略来加载缓存：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;使用时加载缓存&lt;/strong&gt;：当需要使用缓存数据时，从数据库中查询出来，第一次查询之后，后续请求从缓存中获得数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;预加载缓存&lt;/strong&gt;：在项目启动时或启动后通过程序预加载缓存信息，比如”国家信息、货币信息、用户信息，新闻信息“等不是经常变更的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache Aside适用于读多写少的场景，比如用户信息、新闻报道等，一旦写入缓存，几乎不会进行修改。该模式的缺点是可能会出现缓存和数据库双写不一致的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache Aside也是一个标准的模式，像Facebook便是采用的这种模式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Read Through&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Read-Through和Cache-Aside很相似，不同点在于程序不需要关注从哪里读取数据（缓存还是数据库），它只需要从缓存中读数据。而缓存中的数据从哪里来是由缓存决定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。Read-Through的优势是让程序代码变得更简洁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就涉及到我们上面所说的应用程序操作边界问题了，直接来看流程图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6762295081967213&quot; data-type=&quot;jpeg&quot; data-w=&quot;1464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CmnN7FKTMS7PxgBaWAsa1cts9FAtr2j8RPKAhNibp9hRZ7Yib4R1ZdPphHgod3bdNcEW6K3T8f5h1nFclmQpntrw/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;Read Through&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述流程图中，重点关注一下虚线框内的操作，这部分操作不再由应用程序来处理，而是由缓存自己来处理。也就是说，当应用从缓存中查询某条数据时，如果数据不存在则由缓存来完成数据的加载，最后再由缓存返回数据结果给应用程序。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;Write Through&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Cache Aside中，应用程序需要维护两个数据存储：一个缓存，一个数据库。这对于应用程序来说，有一些繁琐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through模式下，所有的写操作都经过缓存，每次向缓存中写数据时，缓存会把数据持久化到对应的数据库中去，且这两个操作在一个事务中完成。因此，只有两次都写成功了才是最终写成功了。坏处是有写延迟，好处是保证了数据的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以理解为，应用程序认为后端就是一个单一的存储，而存储自身维护自己的Cache。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为程序只和缓存交互，编码会变得更加简单和整洁，当需要在多处复用相同逻辑时这点就变得格外明显。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6141592920353982&quot; data-type=&quot;jpeg&quot; data-w=&quot;1130&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CmnN7FKTMS7PxgBaWAsa1cts9FAtr2j8KlThygrj2EaIAEo3suKzZ9vhTf20ytCvnBSEVoeRypPkntVD7VLHAw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;figcaption&gt;Write Through&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用Write-Through时，一般都配合使用Read-Through来使用。Write-Through的潜在使用场景是银行系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Through适用情况有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要频繁读取相同数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不能忍受数据丢失（相对Write-Behind而言）和数据不一致&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用Write-Through时要特别注意的是缓存的有效性管理，否则会导致大量的缓存占用内存资源。甚至有效的缓存数据被无效的缓存数据给清除掉。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;Write-Behind&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Write-Behind和Write-Through在”程序只和缓存交互且只能通过缓存写数据“这方面很相似。不同点在于Write-Through会把数据立即写入数据库中，而Write-Behind会在一段时间之后（或是被其他方式触发）把数据一起写入数据库，这个异步写操作是Write-Behind的最大特点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库写操作可以用不同的方式完成，其中一个方式就是收集所有的写操作并在某一时间点（比如数据库负载低的时候）批量写入。另一种方式就是合并几个写操作成为一个小批次操作，接着缓存收集写操作一起批量写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步写操作极大地降低了请求延迟并减轻了数据库的负担。同时也放大了数据不一致的。比如有人此时直接从数据库中查询数据，但是更新的数据还未被写入数据库，此时查询到的数据就不是最新的数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;小结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的缓存模式有不同的考量点和特征，根据应用程序需求场景的不同，需要灵活的选择适配的缓存模式。在实践的过程中往往也是多种模式相结合来使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;完&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend-list&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2650187171_1&quot; data-recommend-article-time=&quot;1657071000&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/6fuT3emWI5Jp0Ifs7gsMRLrrB7v06Injpw4ypDIxYDnOJQYBrFFnvrQv4kEm4icmLrkVdGXKLVHUiaaRnQh9iauaw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;新来个技术总监，把 RabbitMQ 讲的那叫一个透彻，佩服！&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650187171&amp;amp;idx=1&amp;amp;sn=4d4052394b18928f844c183763019081&amp;amp;chksm=f368b882c41f319466632749c12aa890ffb107bf76c03ff9f65beeefa458014e3a6e5265c6bd#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650187171&amp;amp;idx=1&amp;amp;sn=4d4052394b18928f844c183763019081&amp;amp;chksm=f368b882c41f319466632749c12aa890ffb107bf76c03ff9f65beeefa458014e3a6e5265c6bd&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;4&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.9983361064891847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5Jp0Ifs7gsMRLrrB7v06Injpw4ypDIxYDnOJQYBrFFnvrQv4kEm4icmLrkVdGXKLVHUiaaRnQh9iauaw/640?wx_fmt=jpeg&quot; data-w=&quot;601&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;新来个技术总监，把 RabbitMQ 讲的那叫一个透彻，佩服！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2650187171_2&quot; data-recommend-article-time=&quot;1657071000&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/6fuT3emWI5Jp0Ifs7gsMRLrrB7v06InjUib0RIHDnbWM6JicvicF3IOzABtCrupDZIuxFJek4REDDSjrQZFSDI2xg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;SQL优化的魅力！从 30248s 到 0.001s&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650187171&amp;amp;idx=2&amp;amp;sn=6b63ae86113339a0a3c32032eb71d546&amp;amp;chksm=f368b882c41f3194c452786932963b1768fb7e1af80c778a31421bbdf4d911bc0f5c9c90e44e#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650187171&amp;amp;idx=2&amp;amp;sn=6b63ae86113339a0a3c32032eb71d546&amp;amp;chksm=f368b882c41f3194c452786932963b1768fb7e1af80c778a31421bbdf4d911bc0f5c9c90e44e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;4&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9969418960244648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5Jp0Ifs7gsMRLrrB7v06InjUib0RIHDnbWM6JicvicF3IOzABtCrupDZIuxFJek4REDDSjrQZFSDI2xg/640?wx_fmt=jpeg&quot; data-w=&quot;327&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;SQL优化的魅力！从 30248s 到 0.001s&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2650187171_3&quot; data-recommend-article-time=&quot;1657071000&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/6fuT3emWI5Jp0Ifs7gsMRLrrB7v06Injg3Izhr7OictbntsgianbAuBCZV3J82a6QTwxFheFSaxm03zvDRcThyUQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;消息队列消息丢失和消息重复发送的处理策略&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650187171&amp;amp;idx=3&amp;amp;sn=79fec13b451ffa1dda66429930cb0356&amp;amp;chksm=f368b882c41f3194385d8a9744bedfd1f90d4f4edc69a5b3d786420b35414475ae33102c70ba#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650187171&amp;amp;idx=3&amp;amp;sn=79fec13b451ffa1dda66429930cb0356&amp;amp;chksm=f368b882c41f3194385d8a9744bedfd1f90d4f4edc69a5b3d786420b35414475ae33102c70ba&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-type=&quot;normal&quot; data-recommend-tid=&quot;4&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5Jp0Ifs7gsMRLrrB7v06Injg3Izhr7OictbntsgianbAuBCZV3J82a6QTwxFheFSaxm03zvDRcThyUQ/640?wx_fmt=jpeg&quot; data-w=&quot;558&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;消息队列消息丢失和消息重复发送的处理策略&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2257492907_2&quot; data-recommend-article-time=&quot;1611021600&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md4XPLDBXjntlR9hjI9MLmLqSL5JQYichQQWibXIWj5Jm5cdzcJ4wOpO0I1K79rKzNlV9ckc4jWTWfiaw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;JDK 16 即将发布，新特性速览！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257492907&amp;amp;idx=2&amp;amp;sn=e53286471aa6a03b60cc446e4e0258bf&amp;amp;chksm=a447180c9330911a289223ef42ed3541f1fa0bda9a42012ab73d36bea64aafb88f0adce0e3bb#rd&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-from=&quot;yb-recommend&quot; data-recommend-article-type=&quot;normal&quot; data-recomment-template-id=&quot;4&quot; data-recommend-article-id=&quot;2257492907_2&quot; data-recommend-article-time=&quot;1611021600&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/1Fk759B8md4XPLDBXjntlR9hjI9MLmLqSL5JQYichQQWibXIWj5Jm5cdzcJ4wOpO0I1K79rKzNlV9ckc4jWTWfiaw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;JDK 16 即将发布，新特性速览！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257492907&amp;amp;idx=2&amp;amp;sn=e53286471aa6a03b60cc446e4e0258bf&amp;amp;chksm=a447180c9330911a289223ef42ed3541f1fa0bda9a42012ab73d36bea64aafb88f0adce0e3bb#rd&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-style=&quot;white-space: normal; background-color: rgb(255, 255, 255); color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 16px;&quot; class=&quot;js_darkmode__155&quot;&gt;&lt;p&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 13px;&quot; class=&quot;js_darkmode__156&quot;&gt;有道无术，术可成；有术无道，止于术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 13px;&quot; class=&quot;js_darkmode__157&quot;&gt;欢迎大家关注&lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;Java之道&lt;/strong&gt;&lt;/span&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 13px;&quot; class=&quot;js_darkmode__158&quot;&gt;公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Fk759B8md4yPF1ZAnySd6Xqparsv06tG4FibicFOr7moddq2D3087xicOrF9l54yOVLQkkiaWUBheSzFfibyGMgeug/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-style=&quot;white-space: normal; background-color: rgb(255, 255, 255); color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 16px; text-align: right;&quot; class=&quot;js_darkmode__159&quot;&gt;&lt;span data-style=&quot;color: rgb(0, 0, 0); font-size: 14px; letter-spacing: 2px; word-spacing: 2px;&quot; class=&quot;js_darkmode__160&quot;&gt;好文章，我&lt;/span&gt;&lt;span&gt;&lt;span&gt;在看&lt;/span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>