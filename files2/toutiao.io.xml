<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8eac27e8ac73fb4af476210845acda44</guid>
<title>4.23世界读书日，推荐9本好书｜附读书笔记</title>
<link>https://toutiao.io/k/d8e0mjw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;40&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.23世界读书日，推荐9本好书。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;喜欢，也欢迎转发给您的朋友们，好东西要分享哦～&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、《横向领导力》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;270&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.3942505133470227&quot; data-type=&quot;jpeg&quot; data-w=&quot;974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFFtWsoPAicr3xgbptSUJ56rYpj2m8EmtJZZdKXM2R04vKQxLicOZNbsOw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与人合作绝对是世界上最难的事情之一，时间往往在摩擦中白白消耗，分到与自身能力不相称的任务，或是由于某种差异而冲突不断，长达数小时但结果欠奉的会议可以说是司空见惯。有时我们磨合团队所花的时间甚至远远超出完成实质性工作的周期。大多数人宁可多花一些工夫独立完成任务，也不愿意与他人合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有“一把手”才能领导，这是职场最大的误区和陷阱！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;罗杰·费希尔，谈判、沟通领域久负盛名的权威专家，汇聚哈佛大学肯尼迪政府学院、哈佛大学谈判项目的核心资源，砥砺七年，终于成就这部职场沟通经典:你无须拥有高于同事的权力，就能游刃有余地完成比难更难的事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFqOpMMwL3kGuNEX4lkPk9qgdt1Tiauw0KKmbmHBxBFUD8xFPUmrqgNtA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、《工作、消费主义和新穷人》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;270&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.382867132867133&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFXYU1hhibicuLL0Q5DM6LVVmzym6sHumCpyLa6FqiaUahAc0YdB6c7GccA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在生产者和普遍就业的社会中，贫穷是一回事。在消费者社会中，穷人是另一回事。在后者社会中，生活项目围绕消费者的选择而建立，而不是围绕工作、专业技能而建立。“贫穷”曾经与失业联系在一起，如今，它主要指向有缺陷消费者的困境。这种差异改变了贫穷的体验方式，对于拯救苦难产生重大影响。著名社会学家和思想家鲍曼的这部作品，对于消费者社会及其影响进行了反思和论述。在本书中，鲍曼书追溯现代历史上发生的这种变化，对其社会后果进行盘点，并考虑了与贫困作斗争和减轻困苦的各种方式的有效性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;社会学、政治学和社会政策学的研究者会发现，这是关于含义不断变化的一个持久社会问题的一本无价之书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFaXTkcBVz5ibev4T9FicBDSGTYjIdMuYpiaicHnMyW4NkCPqTELX1lUjWbA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、《也许你该找个人聊聊》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.5105932203389831&quot; data-type=&quot;jpeg&quot; data-w=&quot;472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhF6hqcadzBHj43GkUNBT83sfxbicmHIlJ4GSZdqaRQGFYM7ibJ5JsI7M6g/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一位心理治疗师的回忆录，讲述了发生在诊室中的故事。在这个小小的密闭空间里，人们会展现出最真实、最脆弱的一面；也是在这里，人们获得了陪伴和倾听，也获得了宝贵的觉察、成长与改变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在书中，我们会看到四个来访者的故事，他们是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个四十多岁、事业成功、自以为是，认为身边所有人都是蠢货的好莱坞制片人；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个三十多岁、刚刚新婚就被诊断出患有绝症，时日不多的大学女教师；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个六十九岁、离过三次婚，感觉孤独绝望，声称生活再不好转就要在七十岁生日当天自杀的老太太；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个二十多岁、有原生家庭创伤和酗酒问题，在爱情中频频受挫的姑娘。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时，书中还有第五个寻求帮助的人，那就是治疗师自己。她是一个单身的职场妈妈，四十多岁时遭遇失恋，几乎崩溃。有朋友对她说“或许你该找个人聊聊”，于是她也给自己找了一位心理治疗师。当她切换到来访者的位置，坐到另一位心理治疗师的沙发上诉说自己内心的脆弱与悲伤，就更能感受到心理治疗为何具有治愈和改变的力量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这本书从治疗师和来访者的双重视角展现了心理治疗的过程，让我们发现：无论身份背景有多相异，人类面对的烦恼其实都相通——爱与被爱、遗憾、选择、控制、不确定、死亡，这些都是我们身而为人必须共同学习面对的议题。我们在现实生活中所遭遇的切肤之痛和生命困境，都能在这本书中得到共鸣、找到希望。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFq5lNQDR1F1x4ibkRYe2sYcmiab4qGyWwvicVpKNsS5hicyU5ia4Ma31NDUQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、《爱的五种语言》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;0.850925925925926&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFib5tCRP71laOBspm50VlpIibv2kJRiceHhO9vzkRhc4Rw0pRia963jCvLQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全球婚恋辅导经典之作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一本关系建造的精彩指南&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;帮助无数的婚姻从危机当中扭转局面，并有美好结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;连续17年名列【纽约时报排行榜】，并数次荣登。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全球突破1000万册，译成50国语言！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFaAHBsibVvLzqzA7bqbH4kibQviaqC9qre798qKYLfc9fRntolF1iaOsGYg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入我们，一起读好书！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;即刻加入，立享9折，仅此一天！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;52&quot; data-cropselx2=&quot;324&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;377&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFK6MbK8O0IXjObLicvHLPHkhBhgRzlj11MQleMJeA02qHbKM9ptrWRNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、《终身成长》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.3876923076923078&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFXQia0SAfSlsfDljBvdNpK6K7HxicCAFrZwqPc5ma6I9SbOAvbJ3ODrRg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对成功的数十年研究后，斯坦福大学心理学家卡罗尔·德韦克发现了思维模式的力量。她在《终身成长》中表明，我们获得的成功并不是能力和天赋决定的，更受到我们在追求目标的过程中展现的思维模式的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;她介绍了两种思维模式：固定型与成长型，它们体现了应对成功与失败、成绩与挑战时的两种基本心态。你认为才智和努力哪个重要，能力能否通过努力改变，决定了你是会满足于既有成果还是会积极探索新知。只有用正确的思维模式看待问题，才能更好地达成人生和职业目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;德韦克揭示的成功法则已被很多具有发展眼光的父母、老师、运动员和管理者应用，并在实践中得到了验证。通过了解自己的思维模式并做出改变，人们能以最简单的方式培养对学习的热情，和在任何领域内取得成功都需要的抗压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFL456uVbuCLtRvVPqTUgEo7ULGhicbqwqia2a1ppqZRk3sO96ukmDVA1A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、《麦肯锡工作法》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.40702947845805&quot; data-type=&quot;jpeg&quot; data-w=&quot;882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhF66XicicUF1b2ibcTzG4M6NLMEic5j1f1icNQV7BiaWLUQqYGt7rZl2rsTbew/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“麦肯锡人”总带着闪耀的光环，但他们在这家全球顶级管理咨询公司的平均工作年限仅是3~5年。为何他们从麦肯锡毕业后，还能活跃于各个行业，取得非凡的成绩？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原因就在于麦肯锡独特的工作法，7堂课让员工的竞争力大大提升，并且终生受用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;麦肯锡资深培训师大嶋祥誉在《麦肯锡工作法》中拆解了公司内部的秘密武器：麦肯锡的专业作风、解决问题的技巧、分析框架的养成、处理信息的能力、提升自我的策略、展现成果的方法，还有麦肯锡式的思考方式。学会《麦肯锡工作法》，让你不进麦肯锡也能变成优秀的“麦肯锡人”，在团队中脱颖而出！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFyBiaO2tPyibnNV7sF7E0T9nMBicISr5IS1ibV6ZPBuTW8J966sYsJ9ibeIQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7、《蛤蟆先生去看心理医生》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.3046875&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFUloV0Sr6vDCggZQqR4iaCI9UAVgibN8KLiaz5rpjsnMdATDo0AicpLIJOQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;蛤蟆先生一向爱笑爱闹，如今却一反常态地郁郁寡欢，他一个人躲在屋里，连起床梳洗的力气都没有。朋友们非常担心他，建议他去做心理咨询。在10次心理咨询中，蛤蟆在咨询师苍鹭的带领下，勇敢地探索了自己的内心世界，也逐渐找回了信心与希望……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这并不是一本写给孩子看的书，而是一本非常有深度的心理疗愈读物。出版20多年来，已成为英国国民级心理咨询入门书。它基于TA沟通分析心理学的理论，讲述了一个抑郁症病人通过十次心理咨询，终于找回快乐和自信的全过程。在书中，可以看到心理咨询的倾听、共情、沟通技巧，也可以看到一个标准的心理咨询流程的模板。读者犹如亲临现场，体验心理咨询的每一个细节，见证疗愈和改变的发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这本书里，作者借由蛤蟆和心理咨询师苍鹭的互动，探索了蛤蟆自卑、软弱、爱炫耀的个性与抑郁的情绪究竟来源于何处，让读者看到童年经历对人格的深刻影响，以及如何才能在心理上真正长大成人，独立、自信、充满希望地生活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFjEAeoaxhQgxjncibYchfoVavB0iaG9gVCibHgs0ibcYCzicL2jPyCbbf5lg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8、《谈判》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.4285714285714286&quot; data-type=&quot;jpeg&quot; data-w=&quot;280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFMP7TPckwIhtOu23hqJiaPcmULYibUkV0icEBUxOm1U7bSGUj8EOJFJ2pw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书从第一版至今已畅销35年，是全世界亿万富翁的枕边书，全球十余种版本累积销售已超200万册。在本次全新版本中，不仅回顾了前三个版本的全部内容，还增补了适应当前商业谈判的新的策略和案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;寸步不让，除非交换！不要接受对方的第一次出价！谈判最有利的两个字是什么？最有用的问题是什么？寓教于乐的谈判学权威读物，25个有趣实用的策略和自我测试，以四两拨千斤的技巧，在博弈中获得更多，让全世界都听你的！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFiargL4qu3TNXGKTPAMjET9cicGRXgPJQs4lLQicjlSgR6hibX1NhgxI3RQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9、《一生的旅程》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;272&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;1.4678899082568808&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFiclPrEPDSZrVGMKKicp7dA9ReuEIGSfcaM0ebXQ2qOz4RwYsEc5Lt3gA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【内容简介】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为迪士尼的董事长兼首席执行官，罗伯特·艾格在书中回顾了自己45年的职业生涯，分享了《复仇者联盟》《星球大战》《黑豹》等超级IP的诞生过程，记录了他与乔布斯惺惺相惜的深厚友谊，分析了并购皮克斯、漫威、卢卡斯影业以及二十一世纪福克斯的前因后果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2005年，内忧外患中的迪士尼面临着被出售的风险，艾格在一片争议声中赴任，将迪士尼的未来之路聚焦为三个方向：打造高质量品牌内容；拥抱科技；着眼全球。他邀请乔布斯加入董事会，招募创意天才拉塞特、技术专家卡特姆拯救迪士尼动画，深耕漫威宇宙，续写《星球大战》科幻史诗，全程参与创建上海迪士尼乐园，成功推出流媒体Disney+ ，让迪士尼的快乐魔法遍布全世界每个角落。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【读书笔记】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;422&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.5616113744075829&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFUghpSYnZW1NFRdUlexlKBoibb5qx8ib5Mu6ib8VGciaHvzCy7Eqaicfyp4w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入我们，一起读好书！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;即刻加入，立享9折，仅此一天！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;52&quot; data-cropselx2=&quot;324&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;377&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavicCxFCn1O6dLssq32qiaTRhFK6MbK8O0IXjObLicvHLPHkhBhgRzlj11MQleMJeA02qHbKM9ptrWRNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6358ae4acfe92b7b08e52a24bc802de9</guid>
<title>Kubernetes 网络模型基础指南</title>
<link>https://toutiao.io/k/1w97stn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 是为运行分布式集群而建立的，分布式系统的本质使得网络成为 Kubernetes 的核心和必要组成部分，了解 Kubernetes 网络模型可以使你能够正确运行、监控和排查应用程序故障。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgxXjFVCRuH7qy64U3chiaiahczklvicicPLs7TpRKqLNds92VMUXiaEC2iaJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络是非常复杂的，拥有许多概念，对于不熟悉这个领域的用户来说，这可能会有一定的难度，这里面有很多概念需要理解，并且还需要把这些概念整合起来形成一个连贯的整体，比如网络命名空间、虚拟接口、IP 转发、NAT 等概念。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 中对任何网络实现都规定了以下的一些要求：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;所有 Pod 都可以在不使用 NAT 的情况下与所有其他 Pod 进行通信&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;所有节点都可以在没有 NAT 的情况下与所有 Pod 进行通信&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 自己的 IP 与其他 Pod 看到的 IP 是相同的&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;鉴于这些限制，我们需要解决几个不同的网络问题：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;容器到容器的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 到 Pod 的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 到 Service 的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;互联网到 Service 的网络&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来我们将来讨论这些问题及其解决方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器到容器网络&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下我们将虚拟机中的网络通信视为直接与以太网设备进行交互，如图1所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgCV9T9zxQ7pfMHEiauW3V6z9TiaUIrm4TfdVibb5hNJMJO7OticAOK1v6Ng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图1.网络设备的理想视图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际的情况肯定比这要复杂，在 Linux 中，每个正在运行的进程都在一个网络命名空间内进行通信，该命名空间提供了一个具有自己的路由、防火墙规则和网络设备的逻辑网络栈，从本质上讲，网络命名空间为命名空间内的所有进程提供了一个全新的网络堆栈。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 用户可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令创建网络命名空间。例如，以下命令将创建一个名为 ns1 的网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ip netns add ns1 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;命名空间创建后，会在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/run/netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 下面为其创建一个挂载点，即使没有附加任何进程，命名空间也是可以保留的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以通过列出 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/run/netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 下的所有挂载点或使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令来列出可用的命名空间。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ls /var/run/netns&lt;/span&gt;&lt;br/&gt;ns1&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ip netns&lt;/span&gt;&lt;br/&gt;ns1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认情况下，Linux 将为每个进程分配到 root network namespace，以提供访问外部的能力，如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgoTjJmceqShbEoZ6ibwMOA1VZOV2yYQmN6z9BovoSiafExusQt9dpyu0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图2.root network namespace&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于 Docker 而言，一个 Pod 会被构建成一组共享网络命名空间的 Docker 容器，Pod 中的容器都有相同的 IP 地址和端口空间，它们都是通过分配给 Pod 的网络命名空间来分配的，并且可以通过 localhost 访问彼此，因为它们位于同一个命名空间中。这是使用 Docker 作为 Pod 容器来实现的，它持有网络命名空间，而应用容器则通过 Docker 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-net=container:sandbox-container&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 功能加入到该命名空间中，图3显示了每个 Pod 如何由共享网络命名空间内的多个 Docker 容器（&lt;/span&gt;&lt;code&gt;&lt;span&gt;ctr*&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）组成的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgx14N89bgPKjXwqTDV2ia9FbbLyLP2fGEvBrMUT5U4ibvq87nySmZ1xTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图3.每个 Pod 的网络命名空间&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外 Pod 中的容器还可以访问共享卷，这些卷被定义为 Pod 的一部分，并且可以挂载到每个容器的文件系统中。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Pod 网络&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Kubernetes 中，每个 Pod 都有一个真实的 IP 地址，每个 Pod 都使用该 IP 地址与其他 Pod 进行通信。接下来我们将来了解 Kubernetes 如何使用真实的 IP 来实现 Pod 与 Pod 之间的通信的。我们先来讨论同一节点上的 Pod 通信的方式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Pod 的角度来看，它存在于自己的网络命名空间中，需要与同一节点上的其他网络命名空间进行通信。值得庆幸的时候，命名空间可以使用 Linux 虚拟以太网设备或由两个虚拟接口组成的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对进行连接，这些虚拟接口可以分布在多个命名空间上。要连接 Pod 命名空间，我们可以将 veth 对的的一侧分配给 root network namespace，将另一侧分配给 Pod 的网络命名空间。每个 veth 对就像一根网线，连接两侧并允许流量在它们之间流动。这种设置可以复制到节点上的任意数量的 Pod。图4显示了连接虚拟机上每个 Pod 的 root network namespace 的 veth 对。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014245014245015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgiav7goAhdM2Fg40BpBNia6OmnP1yZJ0O2aD9ajK98r46EfkGxIfMYJzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图4.Pod 的 veth 对&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在 Pod 都有自己的网络命名空间，这样它们就有自己的网络设备和 IP 地址，并且它们连接到节点的 root 命名空间，现在我们希望 Pod 能够通过 root 命名空间进行通信，那么我们将要使用一个网络 &lt;em&gt;bridge（网桥）&lt;/em&gt;来实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux bridge 是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC 地址学习等。因此我们可以把 veth pair 等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。bridge 的工作方式是通过检查通过它的数据包目的地，并决定是否将数据包传递给连接到网桥的其他网段，从而在源和目的地之间维护一个转发表。bridge 通过查看网络中每个以太网设备的唯一 MAC 地址来决定是桥接数据还是丢弃数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Bridges 实现了 ARP 协议来发现与指定 IP 地址关联的链路层 MAC 地址。当 bridge 接收到数据帧的时候，bridge 将该帧广播给所有连接的设备（原始发送者除外），响应该帧的设备被存储在一个查找表中，未来具有相同 IP 地址的通信使用查找表来发现正确的 MAC 地址来转发数据包。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5584045584045584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgaC5x2L2NGESEDibAC2J9Y4cSics1zvr3vlQEubR88po8icKdIZnzVDGag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;figcaption&gt;图5.使用桥接连接命名空间&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同节点 Pod 通信&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络命名空间将每个 Pod 隔离到自己的网络堆栈中，虚拟以太网设备将每个命名空间连接到根命名空间，以及一个将命名空间连接在一起的网桥，这样我们就准备好在同一节点上的 Pod 之间发送流量了，如下图6所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4390467461044913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgbMZZruJE0xAuacLiaia0y3HtN4ic5QJWsCEEpHgfoWsQMboak31eaeXOg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1091&quot;/&gt;&lt;figcaption&gt;同节点上的Pod间的数据包移动&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这上图中，pod1 向自己的网络设备 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 发送了一个数据包，对于 pod1 来说，&lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 通过虚拟网络设备连接到 root netns 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth0(1)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，网桥 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cbr0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 被配置为与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 一端相连，一旦数据包到达网桥，网桥就会使用 ARP 协议将数据包发送到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth1(3)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。当数据包到达虚拟设备 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时，它被直接转发到 pod2 的命名空间内的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0(4)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备。这整个过程中，每个 Pod 仅与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进行通信，流量就会被路由到正确的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 的网络模型决定了 Pod 必须可以通过其 IP 地址跨节点访问，也就是说，一个 Pod 的 IP 地址始终对网络中的其他 Pod 是可见的，每个 Pod 看待自己的 IP 地址的方式与其他 Pod 看待它的方式是相同的。接下来我们来看看不同节点上的 Pod 之间的流量路由问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;跨节点 Pod 通信&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在研究了如何在同一节点上的 Pod 之间路由数据包之后，接下来我们来看下不同节点上的 Pod 之间的通信。Kubernetes 网络模型要求 Pod 的 IP 是可以通过网络访问的，但它并没有规定必须如何来实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通常集群中的每个节点都分配有一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，用来指定该节点上运行的 Pod 可用的 IP 地址。一旦以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为目的地的流量到达节点，节点就会将流量转发到正确的 Pod。图7展示了两个节点之间的网络通信，假设网络可以将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的流量转发到正确的节点。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0342205323193916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgvHLovL3sZSEtEia3tKWIDCS43V6PLN4kxIjdLnMugfW32fl4ZfHmwSg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1052&quot;/&gt;&lt;figcaption&gt;图7.不同节点上的Pod间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上图一样和图6相同的地方开始请求，但是这次目标 Pod（绿色标注）与源 Pod（蓝色标注）位于不同的节点上。数据包首先通过 pod1 的网络设备发送，该设备与 root netns（1）中的虚拟网络设备配对，最终数据包到达 root netns 的网桥（2）上。这个时候网桥上的 ARP 会失败，因为与网桥相连的没有正确的数据包 MAC 地址。一旦失败，网桥会将数据包发送到默认路由上 - root netns 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备，此时就会路由离开节点，进入网络（3）。我们现在假设网络可以根据分配给节点的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 将数据包路由到正确的节点（4）。数据包进入目标节点的 root netns（VM2 上的 eth0），这那里它通过网桥路由到正确的虚拟设备（5）。最后，路由通过位于 pod4 的命名空间（6）中的虚拟设备 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来完成。一般来说，每个节点都知道如何将数据包传递给其内部运行的 Pod，一旦数据包到达目标节点，数据包的流动方式与同一节点上的 Pod 间通信方式一样。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们这里没有介绍如何配置网络来将 Pod IPs 的流量路由到负责这些 IP 的正确节点，这和特定的网络有关系，比如 AWS 就维护了一个 Kubernetes 容器网络插件，该插件允许在 AWS 的 VPC 环境中使用 [容器网络接口（&lt;/span&gt;&lt;code&gt;&lt;span&gt;CNI&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）插件]（https://github.com/aws/amazon-vpc-cni-k8s）来进行节点到节点的网络通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 EC2 中，每个实例都绑定到一个弹性网络接口 (ENI)，并且所有 ENI 都连接在一个 VPC 内 —— ENI 无需额外操作即可相互访问。默认情况下，每个 EC2 实例部署一个 ENI，但你可以创建多个 ENI 并将它们部署到 EC2 实例上。Kubernetes 的 AWS CNI 插件会为节点上的每个 Pod 创建一个新的 ENI，因为 VPC 中的 ENI 已经连接到了现有 AWS 基础设施中，这使得每个 Pod 的 IP 地址可以在 VPC 内自然寻址。当 CNI 插件被部署到集群时，每个节点（EC2 实例）都会创建多个弹性网络接口，并为这些实例分配 IP 地址，从而为每个节点形成了一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CIDR&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 块。当部署 Pod 时，有一个小的二进制文件会作为 DaemonSet 部署到 Kubernetes 集群中，从节点本地的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubelet&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进程接收任何添加 Pod 到网络的请求，这个二进制文件会从节点的可用 ENI 池中挑选一个可用的 IP 地址，并通过在 Linux 内核中连接虚拟网络设备和网桥将其分配给 Pod，和在同一节点内容的 Pod 通信一样，有了这个，Pod 的流量就可以跨集群内的节点进行通信了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Service&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面我们已经介绍了如何在 Pod 和它们相关的 IP 地址之间的通信。但是 Pod 的 IP 地址并不是固定不变的，会随着应用的扩缩容、应用崩溃或节点重启而出现或消失，这些都可能导致 Pod IP 地址发生变化，Kubernetes 中可以通过 &lt;em&gt;Service&lt;/em&gt; 对象来解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes Service 管理一组 Pod，允许你跟踪一组随时间动态变化的 Pod IP 地址，Service 作为对 Pod 的抽象，为一组 Pod 分配一个虚拟的 VIP 地址，任何发往 Service VIP 的流量都会被路由到与其关联的一组 Pod。这就允许与 Service 相关的 Pod 集可以随时变更 - 客户端只需要知道 Service VIP 即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建 Service 时候，会创建一个新的虚拟 IP（也称为 clusterIP），这集群中的任何地方，发往虚拟 IP 的流量都将负载均衡到与 Service 关联的一组 Pod。实际上，Kubernetes 会自动创建并维护一个分布式集群内的负载均衡器，将流量分配到 Service 相关联的健康 Pod 上。接下来让我们仔细看看它是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;netfilter 与 iptables&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了在集群中执行负载均衡，Kubernetes 会依赖于 Linux 内置的网络框架 - &lt;/span&gt;&lt;code&gt;&lt;span&gt;netfilter&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。Netfilter 是 Linux 提供的一个框架，它允许以自定义处理程序的形式实现各种与网络相关的操作，Netfilter 为数据包过滤、网络地址转换和端口转换提供了各种功能和操作，它们提供了引导数据包通过网络所需的功能，以及提供禁止数据包到达计算机网络中敏感位置的能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;iptables&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一个用户空间程序，它提供了一个基于 table 的系统，用于定义使用 netfilter 框架操作和转换数据包的规则。在 Kubernetes 中，iptables 规则由 kube-proxy 控制器配置，该控制器会 watch kube-apiserver 的变更，当对 Service 或 Pod 的变化更新了 Service 的虚拟 IP 地址或 Pod 的 IP 地址时，iptables 规则会被自动更新，以便正确地将指向 Service 的流量路由到支持 Pod。iptables 规则会监听发往 Service VIP 的流量，并且在匹配时，从可用 Pod 集中选择一个随机 Pod IP 地址，并且 iptables 规则将数据包的目标 IP 地址从 Service 的 VIP 更改为所选的 Pod IP。当 Pod 启动或关闭时，iptables 规则集也会更新以反映集群的变化状态。换句话说，iptables 已经在节点上做了负载均衡，以将指向 Service VIP 的流量路由到实际的 Pod 的 IP 上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在返回路径上，IP 地址来自目标 Pod，在这种情况下，iptables 再次重写 IP 头以将 Pod IP 替换为 Service 的 IP，以便 Pod 认为它一直只与 Service 的 IP 通信。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;IPVS&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 新版本已经提供了另外一个用于集群负载均衡的选项：IPVS， IPVS 也是构建在 netfilter 之上的，并作为 Linux 内核的一部分实现了传输层的负载均衡。IPVS 被合并到了 LVS（Linux 虚拟服务器）中，它在主机上运行并充当真实服务器集群前面的负载均衡器，IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务作为虚拟服务出现在一个 IP 地址上。这使得 IPVS 非常适合 Kubernetes 服务。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这部署 kube-proxy 时，可以指定使用 iptables 或 IPVS 来实现集群内的负载均衡。IPVS 专为负载均衡而设计，并使用更高效的数据结构（哈希表），与 iptables  相比允许更大的规模。在使用 IPVS 模式的 Service 时，会发生三件事：在 Node 节点上创建一个虚拟 IPVS 接口，将 Service 的 VIP 地址绑定到虚拟 IPVS 接口，并为每个 Service VIP 地址创建 IPVS 服务器。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Service 通信&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6936758893280632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgO80nIibbUc6npiblqjuW8RAqlU6MhtBDUSRCwf4D1K81Wc9jdzwhnr8w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1012&quot;/&gt;&lt;figcaption&gt;图8. Pod 与 Service 之间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当这 Pod 和 Service 之间路由一个数据包时，流量和以前开始的方式一样，数据包首先通过连接到 Pod 的网络命名空间（1）的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 离开 Pod，。然后它通过虚拟网络设备到达网桥（2）。网桥上运行的 ARP 是不知道 Service 地址的，所以它通过默认路由 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（3）将数据包传输出去。到这里会有一些不同的地方了，在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接收之前，该数据包会被 iptables 过滤，在收到数据包后，iptables 使用 kube-proxy 在节点上安装的规则来响应 Service 或 Pod 事件，将数据包的目的地从 Service VIP 改写为特定的 Pod IP（4）。该数据包现在就要到达 pod4 了，而不是 Service 的 VIP，iptables 利用内核的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;conntrack&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 工具来记录选择的 Pod，以便将来的流量会被路由到相同的 Pod。从本质上讲，iptables 直接从节点上完成了集群内的负载均衡，然后流量流向 Pod，剩下的就和前面的 Pod 到 Pod 通信一样的了（5）。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Service 到 Pod 通信&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6936758893280632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgtV3KndqR2yoKUjoRlicMAwVOAnRzQn1lzibNE7ndyQpNHQ3UoeF0toiag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1012&quot;/&gt;&lt;figcaption&gt;图9.在 Service 和 Pod 之间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相应的回包的时候，收到该数据包的 Pod 将响应，将源 IP 标记为自己的 IP，将目标 IP 标记为最初发送数据包的 Pod(1)。进入节点后，数据包流经 iptables，它使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;conntrack&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记住它之前所做的选择，并将数据包的源重写为 Service 的 VIP 而不是现在 Pod 的 IP(2)。从这里开始，数据包通过网桥流向与 Pod 的命名空间配对的虚拟网络设备 (3)，然后流向我们之前看到的 Pod 的虚拟网络设备 (4)。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外网到 Service 通信&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到这里我们已经了解了 Kubernetes 集群内的流量是如何路由的，但是更多的时候我们需要将服务暴露到外部去。这个时候会涉及到两个主要的问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将流量从 Kubernetes 服务路由到互联网上去&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将流量从互联网传到你的 Kubernetes 服务&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来我们就来讨论这些问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;出流量&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从节点到公共 Internet 的路由流量也是和特定的网络有关系的，这取决于你的网络如何配置来发布流量的。这里我们以 AWS VPC 为例来进行说明。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 AWS 中，Kubernetes 集群在 VPC 中运行，每个节点都分配有一个私有 IP 地址，该地址可从 Kubernetes 集群内访问。要从集群外部访问服务，你可以在 VPC 上附加一个外网网关。外网网关有两个用途：在你的 VPC 路由表中为可路由到外网的流量提供目标，以及为已分配公共 IP 地址的实例执行网络地址转换 (NAT)。NAT 转换负责将集群节点的内部 IP 地址更改为公网中可用的外部 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了外网网关，VM 就可以自由地将流量路由到外网。不过有一个小问题，Pod 有自己的 IP 地址，与运行 Pod 的节点 IP 地址不同，并且外网网关的 NAT 转换仅适用于 VM IP 地址，因为它不知道哪些 Pod 在哪些 VM 上运行 —— 网关不支持容器。让我们看看 Kubernetes 是如何使用 iptables 来解决这个问题的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在下图中，数据包源自 Pod 的命名空间 (1)，并经过连接到根命名空间 (2) 的 veth 对。一旦进入根命名空间，数据包就会从网桥移动到默认设备，因为数据包上的 IP 与连接到网桥的任何网段都不匹配。在到达根命名空间的网络设备 (3) 之前，iptables 会破坏数据包 (3)。在这种情况下，数据包的源 IP 地址是 Pod，如果我们将源保留为 Pod，外网网关将拒绝它，因为网关 NAT 只了解连接到 VM 的 IP 地址。解决方案是&lt;strong&gt;让 iptables 执行源 NAT&lt;/strong&gt; —— 更改数据包源，使数据包看起来来自 VM 而不是 Pod。有了正确的源 IP，数据包现在可以离开 VM (4) 并到达外网网关 (5) 了。外网网关将执行另一个 NAT，将源 IP 从 VM 内部 IP 重写为公网IP。最后，数据包将到达互联网上 (6)。在返回的路上，数据包遵循相同的路径，并且任何源 IP 的修改都会被取消，这样系统的每一层都会接收到它理解的 IP 地址：节点或 VM 级别的 VM 内部，以及 Pod 内的 Pod IP命名空间。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgGaUDVlu2VesbE999GjqtA1WthWLBRF47ZDQ6XttQMqkjq9fc1YE3kg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图10.从Pod到互联网通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;入流量&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让流量进入你的集群是一个非常难以解决的问题。同样这也和特定的网络环境有关系，但是一般来说入流量可以分为两种解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Service LoadBalancer&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Ingress 控制器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;LoadBalancer&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你创建一个 Kubernetes Service时，你可以选择指定一个 LoadBalancer 来使用它。LoadBalancer 有为你提供服务的云供应商负责创建负载均衡器，创建服务后，它将暴露负载均衡器的 IP 地址。终端用户可以直接通过该 IP 地址与你的服务进行通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;LoadBalancer 到 Service&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在部署了 Service 后，你使用的云提供商将会为你创建一个新的 LoadBalancer（1）。因为 LoadBalancer 不支持容器，所以一旦流量到达 LoadBalancer，它就会分布在集群的各个节点上（2）。每个节点上的 iptables 规则会将来自 LoadBalancer 的传入流量路由到正确的 Pod 上（3）。从 Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有 LoadBalancer 的 IP 地址。正如我们之前看到的，iptables 和 conntrack 被用来在返回路径上正确重写 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下图展示的就是托管 Pod 的三个节点前面的负载均衡器。传入流量（1）指向 Service 的 LoadBalancer，一旦 LoadBalancer 接收到数据包（2），它就会随机选择一个节点。我们这里的示例中，我们选择了没有运行 Pod 的节点 VM2（3）。在这里，运行在节点上的 iptables 规则将使用 kube-proxy 安装到集群中的内部负载均衡规则，将数据包转发到正确的 Pod。iptables 执行正确的 NAT 并将数据包转发到正确的 Pod（4）。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0273348519362187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgjicHYRZia3uYzyTenTbsnsCcUaKZYt1PeIj69MYh8uNic3oziaicIZeFKmQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;878&quot;/&gt;&lt;figcaption&gt;图11.外网访问 Service&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Ingress 控制器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在七层网络上 Ingress 在 HTTP/HTTPS 协议范围内运行，并建立在 Service 之上。启用 Ingress 的第一步是使用 Kubernetes 中的 NodePort 类型的 Service，如果你将 Service 设置成 NodePort 类型，Kubernetes master 将从你指定的范围内分配一个端口，并且每个节点都会将该端口代理到你的 Service，也就是说，任何指向节点端口的流量都将使用 iptables 规则转发到 Service。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将节点的端口暴露在外网，可以使用一个 Ingress 对象，Ingress 是一个更高级别的 HTTP 负载均衡器，它将 HTTP 请求映射到 Kubernetes Service。根据控制器的实现方式，Ingress 的使用方式会有所不同。HTTP 负载均衡器，和四层网络负载均衡器一样，只了解节点 IP（而不是 Pod IP），因此流量路由同样利用由 kube-proxy 安装在每个节点上的 iptables 规则提供的内部负载均衡。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 AWS 环境中，ALB Ingress 控制器使用 AWS 的七层应用程序负载均衡器提供 Kubernetes 入口。下图详细介绍了此控制器创建的 AWS 组件，它还演示了 Ingress 流量从 ALB 到 Kubernetes 集群的路由。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.53198127925117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgdr38KkXPhd9AKtGnrYhn2SxGDKy0fbjFWIrfrgzXaXCzjicEIjrWzRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;figcaption&gt;图12.Ingress 控制器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建后，(1) Ingress Controller 会 watch 来自 Kubernetes APIServer 的 Ingress 事件。当它找到满足其要求的 Ingress 资源时，它会开始创建 AWS 资源。AWS 将 Application Load Balancer (ALB) (2) 用于 Ingress 资源。负载均衡器与用于将请求路由到一个或多个注册节点的 TargetGroup一起工作。(3) 在 AWS 中为 Ingress 资源描述的每个唯一 Kubernetes Service 创建 TargetGroup。(4) Listener 是一个 ALB 进程，它使用你配置的协议和端口检查连接请求。Listener 由 Ingress 控制器为你的 Ingress 资源中描述的每个端口创建。最后，为 Ingress 资源中指定的每个路径创建 TargetGroup 规则。这可以保证到特定路径的流量被路由到正确的 Kubernetes 服务上 (5)。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Ingress 到 Service&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;流经 Ingress 的数据包的生命周期与 LoadBalancer 的生命周期非常相似。主要区别在于 Ingress 知道 URL 的路径（可以根据路径将流量路由到 Service）Ingress 和节点之间的初始连接是通过节点上为每个服务暴露的端口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部署 Service 后，你使用的云提供商将为你创建一个新的 Ingress 负载均衡器 (1)。因为负载均衡器不支持容器，一旦流量到达负载均衡器，它就会通过为你的服务端口分布在组成集群 (2) 的整个节点中。每个节点上的 iptables 规则会将来自负载均衡器的传入流量路由到正确的 Pod (3)。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7768959435626103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgB6f7ZsmsiamnMF10mxPp1NvlmMw5sHGfqAQ0MKnkYTxlMKpjkI6Gctg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;figcaption&gt;图13.从 Ingress 到 Service&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文介绍了 Kubernetes 网络模型以及如何实现常见网络任务。网络知识点既广泛又很深，所以我们这里不可能涵盖所有的内容，但是你可以以本文为起点，然后去深入了解你感兴趣的主题。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e64c81ad40e2372240c2a68a28098054</guid>
<title>Go+ SSA 引擎的开发进展</title>
<link>https://toutiao.io/k/xav0prh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;Go+ SSA  ( https://github.com/goplus/gossa ) 是一个基于 SSA  实现的 Go 语言解释器，可以直接从 Go/Go+ 源码运行程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在去年的 Go+ 公开课上我分享了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNTAxNjc2OQ==&amp;amp;mid=2247483705&amp;amp;idx=1&amp;amp;sn=608f67722f9b79383d77e9cc56e60c18&amp;amp;chksm=9b225c97ac55d58111f3053c991cc2c070e8b0eb020d8df6d15067731f880f182b8dcaf3e4ca&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go+ SSA 脚本引擎简介丨Go+ 公开课 · 第8期&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go+ SSA 脚本引擎简介丨Go+ 公开课 · 第8期&lt;/a&gt;，简要介绍了 gossa 主要功能和如何使用，当时在使用上还存在一些限制，无法支持 Go 1.17 amd64 上新的基于寄存器的函数调用方式。&lt;/p&gt;&lt;p&gt;经过了几个月的开发迭代，目前 gossa 重构了部分设计实现，在平台支持和运行效率上有了很大的提高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;完全支持 Go 1.17/Go1.18 新的基于寄存器的函数调用方式。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对这些的平台支持与 Go1.17/Go1.18 保持一致，使用 qemu 模拟对应平台测试通过。&lt;/p&gt;&lt;p&gt;函数调用支持实际由 reflectx ( https://github.com/goplus/reflectx ) 库实现。在 reflectx 中实现了对 &lt;span&gt;ABI0&lt;/span&gt; ( 基于堆栈的调用方式）和 &lt;span&gt;ABIInternal&lt;/span&gt; （基于寄存器调用方式）的支持，ABI0 的支持我使用了 reflect/unsafe 直接计算实现，而对于 ABIInternal 的支持则是使用 asm 做了一个调用转发。 核心思想就是将对方法的调用转化为对函数（通过 reflect.MakeFunc 动态生成）的调用。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;func&lt;/span&gt; (t *T) Call(args) =&amp;gt; func(t *T, args)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 脚本运行速度有了较大的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gossa 之前是使用解释器执行的方式，即将生成的 ssa ir 代码按顺序解释运行，运行速度慢。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Go&lt;/span&gt; 源码 -&amp;gt; AST -&amp;gt; SSA IR -&amp;gt; 直接解释执行&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;目前重构为将 ssa ir 序列代码预编译为 closure 闭包函数列表，之后执行闭包函数列表的方式实现，类似于 VM 的 bytecode 方式，但 gossa 这里没有 bytecode ，只有闭包列表。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;Go&lt;/span&gt; 源码 -&amp;gt; AST -&amp;gt; SSA IR -&amp;gt; closure list -&amp;gt; 执行 closure&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了测试脚本运行速度，我使用 fib(35) 函数进行测试，我使用了本机上的 python2.7，python 3.9 ，lua 5.4， go-lua，gopher-lua，yaegi，tengo 进行测试，lua 和 python 具有典型代表性，后四个则同样是由 Go 语言实现的脚本引擎，使用官方最新版本。gossa 使用最新版本 v0.3.20 。&lt;/p&gt;&lt;p&gt;fib 算法的 Go 源码表示如下，lua 和 python 版本类似。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(n &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; n &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; n&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; fib(n&lt;span class=&quot;code-snippet__number&quot;&gt;-2&lt;/span&gt;) + fib(n&lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过 time gossa run fib.go 的方式运行，统计结果如下。(本结果只展示上述 fib 算法本机测试，选择不同的算法或运行环境结果会不同）&lt;/p&gt;&lt;table cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;程序&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;运行时间&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;lua&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;0.91s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;ossa&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;2.71s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;python2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.97s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;python3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;4.86s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;tengo&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.95s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;lua&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;4.15s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gopher-lua&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;5.04s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;yaegi&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;22.08s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;运行最快为 lua 0.91s，gossa 排在第 2 用时 2.71 s，用时约为 lua 的 3 倍。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下表为 gossa 开发迭代过程中，经历的不同版本运行 fib (35) 时间统计&lt;/p&gt;&lt;table cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa git tag &lt;/span&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;运行时间&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.9&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;1m39s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.10&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;31.91s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.11&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;31.14s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.12&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;27.33s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.13&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;13.25s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.14~v0.3.16&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;12.20s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.17&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;12.05s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.18&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.90s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;gossa v0.3.19&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;3.52s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;ossa&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;v0.&lt;/span&gt;&lt;span&gt;3.20&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;2.71s&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;这个表格可以看到迭代优化带来的效果还是相当明显的，最新的 gossa 在运行 fib(35) 上用时大约为 lua 的 3 倍。&lt;/span&gt;&lt;span&gt;当然，&lt;/span&gt;&lt;span&gt;目前对 gossa 的优化仍在继续进行中，比如 &amp;lt;&amp;lt; 和 &amp;gt;&amp;gt; 运算符执行较慢，还没有做针对优化处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad58db239af2134289f33aa1f6650b95</guid>
<title>java日志那些事儿-日志野史</title>
<link>https://toutiao.io/k/xfjpack</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;        今天不聊技术点儿，聊一聊技术背后那些事儿，日志作为我们日常开发中非常重要的一员，每天都会被使用无数次，java日志框架众多，但仔细梳理一下，其实也就那几个。&lt;/p&gt;&lt;p&gt;        了解一下各种日志的由来，也能有助于日志的选型，没有最好的，只有最合适。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicn2ib8qQuXLdyYhGNoXdxDnuD7oFYoYIzQRCsCqByIYuvvOmCFdu9d7EQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; 追溯时间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n3&quot; mdtype=&quot;table&quot;&gt;&lt;table align=&quot;center&quot;&gt;&lt;thead&gt;&lt;tr cid=&quot;n4&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;日志&lt;/th&gt;&lt;th&gt;归属&lt;/th&gt;&lt;th&gt;出生时间&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n8&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n9&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;System.out&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n10&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;java&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n11&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1995&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n12&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n13&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Log4J&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n14&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache/Ceki Gülcü&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n15&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2001&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n16&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n17&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;JUL(Java Util Logging)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n18&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;java1.4&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n19&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2002.2&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n20&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n21&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;JCL(Jakarta Commons Logging)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n22&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n23&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2002.8&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n24&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n25&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Slf4j(Simple Logging Facade for Java)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n26&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Ceki Gülcü&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n27&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2005&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n28&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n29&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Logback&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n30&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Ceki Gülcü&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n31&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2006&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n32&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n33&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Log4j2&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n34&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n35&quot; mdtype=&quot;table_cell&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2012&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;span/&gt;&lt;strong&gt; 纷争开始了&lt;/strong&gt;&lt;/p&gt;&lt;p cid=&quot;n38&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        最早大家都用System.out或error来打印日志，但错误严重性有高有低，无法区分。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        1996年，一个欧盟赞助的 &lt;/span&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SEMPER&lt;/span&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;项目打算记录操作API的行为，以便于追溯问题。N. Asokan、Ceki Gülcü 和 Michael Steiner 就提出了分层记录器的想法，这也就是日志级别的由来。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        历史总是会留下某个人，然后其他人就没有然后了，哈哈。这个叫切基古尔库的哥们跟他同事一起开发了第一个日志框架Log4j，分层记录的思想是Log4j的核心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6714975845410628&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnJa7scf1b3xawB3rMbTo0icMoIg4c75dPz6Ha4c3zD7ljWaaIhvXCHEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;207&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        2001年，切基古尔库公开了Log4j，拉开了大战的序幕，Log4j加入Apache，切基古尔库也成为了Apache中的一员，大树下面好乘凉，Log4j迅猛发展。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        这时的Java还没有自己的日志系统，Apache盯上了Java，建议Sun把Log4j加入到Java体系中。Sun当然拒绝了，卧榻之侧，岂容他人鼾睡，Sun早就坐不住了，在2002年2月发布了Java1.4，在util加入了自己的Logging，JUL腾空出世，想与Log4J一比高下，奈何JUL功效上稍逊三分，无法干掉Log4j，但是依托java庞大的用户群，还是吸引了一些流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnIpiakJNyUgnaq4SCENUEa5QVEnwfPcsibSIicV9Wn7VFHDvmQco7IwD3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;225&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;span&gt;        此时的Apache心急如焚，眼看着大把的流量被切走，为了捍卫自己的江湖地位，于2002年8月推出一套interface，Jakarta Commons Logging开始面世，JCL可以让使用者在Log4J和JUL之间来回切换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnBUa9aVvbqpWrXXAtvvbSdP9wYQ1Np91DiaHzewedkQ1NrbialguZfD0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;        JCL面世以后，网友猜测，切基古尔库越来越难以掌控Log4j这个项目，加上Log4j使用不规范导致的一些效能问题，还有一些历史遗留问题难以推动解决，他在2005年离开了Apache，并且自立门户，随即推出了另一款Interface，也就是鼎鼎大名的Simple Logging Facade for Java，Slf4j是一套接口的规范，现在不都讲究面向接口编程嘛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4262295081967213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicngcedcnGYRubsn71XFZM25hocMloJbS0fWVFQODicaVPw0ffXahuic0ow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;305&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        切基古尔库先拿JCL开刀，为了让JCL的使用者方面使用这套Slf4j，他来了个狸猫换太子，开发了jcl-over-slf4j.jar，接着为了方便Log4j的使用者，把Log4j当做Slf4j的实现类，他加了一层适配器，实现了Slf4j-log4j12.jar。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        到现在为止，一共有两套接口(JCL和Slf4j)，两套实现(Log4j和JUL)，为了一统江湖，切基古尔库又开发了log4j-over-slf4j.jar，可以用来替换掉log4j这个实现，进而改为自己的实现。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        JUL虽比不过log4j，但是那又怎能放过，2008年的时候，他也在JUL上加了一层适配器，实现了slf4j-jdk14.jar。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.70703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnGuFAHTSNUiaLFKwicrMcx5e9eO15Fo7JTlZPWrasMK8RUBgmYMxAXBog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        Slf4j只是一套接口规则，想要胜出，还是要拿出实际的东西来，切基古尔库深谙这个理儿，从2006年开始，他就着手开发一套属于Slf4j自己的实现，自己亲自开发Log4j，对于其不合理和遗留的问题他太熟悉了，第三套实现Logback也顺理成章的出世了，关键功效上比Log4j更胜一筹&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5384615384615384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnEX6ibGibTibvg8ibVaW0dNRic6hDicsYQR3LPAjiaVjYB2g0oOw1NhXtlL9Rg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;260&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        Slf4j和Logback大行其道，Apache也不会坐以待毙，既然你想靠一个Slf4j称霸，那我也搞一个东西出来一统江湖，2012年Log4j2终于问世，但是Log4j2也算是Log4j的直接升级版，但这两的架构相差甚远。但Log4j2的分层方式又能看到Logback的影子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnPmUztbia8K1zbcolthLtA3kcJSUVoXdlIibnZsEhUcIAOKbkbsJqziazg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n51&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;        至此，java世界的Log之争暂时先告一段落。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt; 关于日志选型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;        &lt;span/&gt;&lt;/strong&gt;&lt;span&gt;JCL和Slf4j是接口，log4j、log4j2、logback都是实现，&lt;span&gt;日常开发&lt;/span&gt;一般会选择接口+实现的方式来作为项目日志的集成方式，网上很多关于log4j2与logback各种性能参数的对比，大都是基于特定的版本，这也从侧面告诉我们，在实际开发过程中，要结合自己项目，在确定jdk或者spring版本的基础上，再去选择对比各日志性能的优劣。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        具体各版本的性能对比，可以参考官方文档，&lt;span&gt;Ceki Gülcü在前一段时间也更新了logback压测项目代码，感兴趣的可以参考https://github.com/ceki/logback-perf&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibtXlkYgk5nlXuC8ZeRGwplqSF7VTnLicnCicvaNS5wCz1sewibuIiasoMXTYvjV0aCxoG1QswlmyEertWnC2A5d9Ig/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;460&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ce&lt;/span&gt;&lt;span&gt;ki Gülcü&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NzgyODc1Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ibtXlkYgk5nkfMR8jIdDMBaicx5IaEQEicxheyqWdKmULWRebqHutmdSyWah0OOGpClJjnichGJFqGHmhwjCrrHFUA/0?wx_fmt=png&quot; data-nickname=&quot;bugCoder&quot; data-alias=&quot;bugCoder&quot; data-signature=&quot;计算机编程自学成才，技术分享，共同进步&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7eae014cdc9c99ff5a243601dff7fffc</guid>
<title>[推荐] 技术开发人员如何制定自己的OKR</title>
<link>https://toutiao.io/k/zq8oiet</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;最近是Q2刚开始，又到了制定季度OKR的时候了，我发现很多技术开发小伙伴依然不知道怎么制定自己的OKR。要么就写“持续做每个迭代”，要么就“持续维护某个系统”，要么就是“积极响应产品需求”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前提：这里假定你对OKR已经有了一定的认识，假定你已对OKR制定要遵循的通用原则SMART比较熟悉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术OKR为什么难写？&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;好多技术主要是跟迭代做需求。这时候想的是我只要按时把需求完成就可以了。但日常迭代本来就是你应该做的事情，你应该去想你如何才能更好地更快地完成你的工作。由于技术OKR不像业务OKR有明确的业务指标且最终是指向用户价值的，久而久之技术OKR有时候就会沦为形式。这些形式化的OKR其实没有任何的指导意义，反而浪费大家时间，这样的OKR要趁早删掉。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;全程“虚词”，没法衡量&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;技术OKR和通用OKR一样不能只有虚词，要有可衡量的指标或者数据。全程“持续、大力、全力、快速”的话，复盘的时候你自己都不知道怎么衡量“全力”是使出了多少力气。这些虚词可以有，但也要附带可衡量的内容。要么是上线个什么功能，要么是把目前存在的什么问题给解决掉，要么把某某的xx率提高到多少？要么是持续做某件事几次。总之得有个实际的内容可以衡量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;OKR制定原则&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;O要制定的有挑战性，要有远方的感觉。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;能量化尽量量化 ：就是要有数字指标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不能量化要细化：不能量化的你就写工作内容本身。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不能细化要流程化：有的工作内容是重复性很高的工作。程序员有时候会时不时的接到一些类似取数据的工作，那么这些工作怎么体现在OKR里呢？这时候你可以把这个取数工作给流程化、文档化，这样就能体现出你的价值了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;明确完成时间。最好明确完成时间，这样你的关键结果更具体。比如：4月5日前完成xxx项目上线。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;OKR参与原则&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本着自下而上和自上而下相结合的原则。有的公司的OKR完全是自上而下对齐结果，这样就会让一线员工没有参与感，也不鼓舞人心。所以自下而上的OKR比例至少占到40%。先让每个员工自己去盘点当下遇到的问题，我们要去往哪里，然后把这些写入自己的OKR。这样做的另外一个好处就是，往往一些细节上的问题只有操作者自己才知道的，通过这样的方式让整个企业运作在Deep Dive的层面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;日常类重复工作怎么写入OKR&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个是很多人经常提到的问题，所以这里专门说一下。对于日常持续重复的类似取数等工作，自己可以写把脚本文档化之类的，总之就是让重复的事情变得尽量不去重复，甚至提供一个通用的能力让这些事情花的时间更少，对于这类日常工作可以考虑遵循DRY原则来制定你的OKR。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以参考的几个OKR制定方向&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;下面给大家提供一些不同方向的技术OKR思路供参考：&lt;/p&gt;&lt;p&gt;1、功能交付类。比如上线某个项目或某个功能等；&lt;/p&gt;&lt;p&gt;2、性能优化类。比如当下你的项目某些API性能较差，可以写降低某某API响应时间从300ms到200ms等；&lt;/p&gt;&lt;p&gt;3、代码优化类。比如完成xxx模块的重构，抽离xxx组件供所有模块使用等；&lt;/p&gt;&lt;p&gt;4、代码质量类。比如线上bug小于1个等；&lt;/p&gt;&lt;p&gt;5、迭代交付类。比如迭代交付平均周期小于8天；&lt;/p&gt;&lt;p&gt;6、技术文化类。比如至少输出5篇技术博客，至少做3次技术分享；&lt;/p&gt;&lt;p&gt;7、指标完善类。比如增加bug来源字段到bug统计中等；&lt;/p&gt;&lt;p&gt;8、组件开发类。比如至少20个业务方接入；&lt;/p&gt;&lt;p&gt;9、团队管理类。比如至少3人轮岗，每周与一位技术小伙伴对话，培养1-2位自驱闭环的产研负责人等；&lt;/p&gt;&lt;p&gt;10、规范标准类。比如制定CodeReview规范。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之你就记住一个原则：当下存在哪些问题，你要去往哪里。这样你就不愁你的OKR写不出来了。&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>