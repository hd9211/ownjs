<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2fc8817ef976116c28cdbb3b39e106cc</guid>
<title>厉害了！国外顶级计算机大神耗时两年时间整理出来这份 2000 页深入理解计算机系统笔记</title>
<link>https://toutiao.io/k/4hjd6qw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;h1&gt;&lt;strong&gt;计算机系统类别的课程一直是计算机科学与技术专业的主要教学内容之一。由于历史原因，我国的计算机专业的课程体系曾广泛参考ACM和 IEEE 制订的计算机科学与技术专业教学计划(Computing Curricula)设计，计算机系统类课程也参照该计划分为汇编语言、操作系统、组成原理、体系结构、计算机网络等多门课程。应该说，该课程体系在历史上对我国的计算机专业教育起很好的引导作用。&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;进入新世纪以来，计算技术发生了重要的发展和变化，我国的信息技术和产业也得到了迅猛发展，对计算机专业的毕业生提出了更高要求。重新审视原来我们参照 ACM/IEEE计算机专业计划的课程体系，会发现存在以下几个方面的主要问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;1)课程体系中缺乏一门独立的能够贯穿整个计算机系统的基础课程。计算机系统方面的基础知识被分成了很多门独立的课程，课程内容彼此之间缺乏关联和系统性。学生学习之后，虽然在计算机系统的各个部分理解了很多概念和方法，但往往会忽视各个部分之间的关联，难以系统性地理解整个计算机系统的工作原理和方法。&lt;/li&gt;&lt;li&gt;2)现有课程往往偏重理论，和实践关联较少。如现有的系统课程中通常会介绍函数调用过程中的压缩和退栈方式，但较少和实践关联来理解压栈和退栈过程的主要作用。实际上，压栈和退栈与理解C等高级语言的工作原理息息相关，也是常用的攻击手段 Buffer Overflow的主要技术基础。&lt;/li&gt;&lt;li&gt;3）教学内容比较传统和陈旧，基本上是早期PC时代的内容。比如，现在的主流台式机CPU都已经是x86-64指令集，但较多课程还在教授80386 甚至更早的指令集。对于近年来出现的多核/众核处理器、SSD硬盘等实际应用中遇到的内容更是涉及较少。&lt;/li&gt;&lt;li&gt;4）课程大多数从设计者的角度出发，而不是从使用者的角度出发。对于大多数学生来说，毕业之后并不会成为专业的CPU设计人员、操作系统开发人员等，而是会成为软件开发工程师。对他们而言,最重要的是理解主流计算机系统的整体设计以及这些设计因素对于应用软件开发和运行的影响。&lt;/li&gt;&lt;/ul&gt;
&lt;h1&gt;因此小编找出了一系列计算机相关书籍，给大家分享出来：&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/1c0a6d8c89d741a3b9c0d857e140cd3e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;需要获取的小伙伴可以直接私信（学习）获取&lt;/p&gt; 
&lt;h1&gt;《深入理解计算机系统》775页&lt;/h1&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/db42d51bd30a2f052779c7c5b162632d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;本书从程序员的视角详细阐述计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。全书共12章，主要包括信息的表示和处理、程序的机器级表示、处理器体系结构、优化程序性能、存储器层次结构、链接、异常控制流、虚拟存储器、系统级1/O、网络编程、并发编程等内容。书中提供了大量的例子和练习题，并给出部分答案，有助于读者加深对正文所述概念和知识的理解。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h1&gt;内容介绍&lt;/h1&gt; 
&lt;h1&gt;第一部分程序结构和执行&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第1章计算机系统漫游&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/733227c2df8e90f4b507e1289e7369f3.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第2章信息的表示和处理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/71621d9db998a6c05e1c75930fe0093b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章程序的机器级表示&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/3ff25eeb229627f7b8fa92c076223a93.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章处理器体系结构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/c737f539a90e4e10a1481d1cfe01e159.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第5章优化程序性能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/fb6555bbcd4a8573201181ba7dc25ed5.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章存储器层次结构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/cdef5b312ae2704fb1a9798e7a05f5fc.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;第二部分在系统上运行程序&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第7章链接&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/70d5adf258f81ea4580dbf5fec513d03.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第8章异常控制流&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d16e568aa4216e22a167c56929581828.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章虚拟内存&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f32439db6d77c65287fa69efdae8661b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;第三部分程序间的交互和通信&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第10章系统级i/O&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7c0ad8147c69c64e864344663673b235.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章网络编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ad4dbc387f59065c84f430a25d044c73.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章并发编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/257113b58614996b5663806590565dd5.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;因为这份文档有700多页下面还有很多需要展示。就不给大家一一展示了，需要获取的小伙伴可以直接转发+关注后添加小助理vx：maxiaoanan&lt;/strong&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/2020112115595614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzU5MjA=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;《逻辑与计算机设计基础》500页&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/34ca9f7448c8c5db403cf173920a9c88.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;除了提供完整的数字和计算机设计内容之外，第5版还特别强调现代设计的基本原理。从简单的组合逻辑应用到在RISC核上构建CISC结构，多个例子的清晰解释和渐进式的设计过程可以诠释书中内容。完整的传统内容包括计算机辅助设计、问题形式化、解决方案验证，以及综合能力培养，而灵活性则体现在可选的逻辑设计、数字系统设计和计算机设计,以及硬件描述语言的相关内容中(不选、选用VHDL或选用Verilog)。&lt;/strong&gt;&lt;/p&gt; 
&lt;h1&gt;内容介绍&lt;/h1&gt; 
&lt;h1&gt;逻辑设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第1章介绍数字计算机、计算机系统抽象层次、嵌入式系统，以及包括数制、算术运算和编码在内的信息表示。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d88d685d80b1117b5d47532e2cce0c2d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第⒉章研究门电路和它们的类型，以及设计和成本优化的基本方法。概念包括布尔代数、代数优化和卡诺图优化、传播延迟，以及在VHDL和Verilog 中使用结构和数据流模型表示的门级硬件描述语言模型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/1cb8d36a92d5cede5d3003d263957612.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章从一个现代逻辑设计过程的概述开始，设计过程的详细步骤包括问题形式化、逻辑优化、用于非门和或非门进行工艺映射，组合逻辑设计的实例中还包括验证。另外，这一章还包括函数和构建组合设计模块，包括使能和输入定值、译码、编码、代码转换、选择、分配、加法、减法、递增、递减、填充、扩展和移位以及它们的实现。本章还包括许多逻辑模块的VHDL和Verilog模型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/e074d5d45603143fc62990abd61c9f72.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章包括时序电路分析和设计。讨论了锁存器和边沿触发式触发器，并着重讲解了D触发器。本章的重点是状态机图和状态表的形式化表示。时序电路完整的设计过程包括规格说明、形式化、状态分配、触发器输入和输出方程确定、优化、工艺映射以及验证。时序电路通常都太复杂，不能用传统的状态图来表示，但可以用状态机图模型来表示，这一章通过现实世界的两个例子来阐述和说明这一观点。这一章包括用VHDL 和 Verilog来描述触发器和时序电路，介绍了VHDL和 Verilog程序行为的语言结构以及用于验证的测试程序。本章最后介绍了时序电路的延迟和定时，以及异步输入的同步和亚稳态问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ca82efbac23826d32dd5f7c9c3628935.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;数字系统设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第5章重点介绍当前技术的各个方面，包括MOS晶体管和CMOS电路，以及可编程逻辑技术。可编程逻辑包括只读存储器、可编程逻辑阵列、可编程阵列逻辑和FPGA。这一章包括一些例子，它们用一个简单的FPGA结构来解释在更为复杂的商用FPGA硬件中出现的各种各样的可编程元器件。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/384b6bd71e033390ed5a8945d4023020.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章讲解寄存器及其应用。移位寄存器和计数器的设计基于第3章和第4章所讲解的触发器和某些函数及其实现。只有行波计数器作为--个全新的概念加以介绍。讨论了寄存器传输的并行和串行方式，以及如何权衡时间与空间开销。其中有一节侧重于执行多种运算的多功能寄存器的寄存器单元设计。数据通路和控制单元的协同设计过程使用了寄存器传输语言和状态截图，并且用现实世界的两个例子对其进行了解释。对所选的寄存器类型也用Verilog和VHDL语言进行了描述。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/2832cbd579efcab38fd25af2f315df95.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第7章介绍静态随机访问存储器（SRAM）和动态随机访问存储器（DRAM)，以及基本存储器系统,还简单地介绍了动态随机访问存储器的各种不同类型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/fbdc7459391a69dde5ae7e261c0723bb.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;计算机设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第8章讲述寄存器文件、功能单元、数据通路，以及两种简单计算机——单周期计算机和多周期计算机。重点讨论数据通路和控制单元设计的形式化概念，以及用它们来设计具有特定指令和指令集的单周期和多周期计算机。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d114fef46455e2bfe1e8e2e1142615f3.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章介绍与指令集结构相关的许多内容，包括地址计算、寻址模式、指令结构和类型，并讲解浮点数表示法和浮点运算，以及程序控制方法，包括过程调用与中断。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/31613ef3488d442902db7aee58d3beab.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第10章讨论一些高性能处理器的概念，如流水式RISC和CISC处理器。通过将微编码硬件添加到修改了的RISC处理器上，CISC处理器可以使用RISC的流水线来执行CISC指令集，这是当今CISC处理器中使用的一种方法。除此之外，还介绍了高性能CPU在概念和结构方面的创新，其中包括两个多CPU微处理器的例子。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/193f202708f5414c0d5ffdb951539438.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章讲解如何在CPU和内存之间、输入/输出接口和外围设备之间进行数据传送。讨论了键盘、液晶显示器（LCD)、硬盘驱动器等外部设备和键盘接口，以及包括通用串行总线(USB）在内的串行通信和中断系统的实现。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b5f46d8effbb16b3e5b5d97009e75096.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章重点讨论存储器的分层。介绍了“访问的局部性”的概念，并通过cache和内存之间、内存和硬盘之间的关系对其进行了详细讲解。分析了cache设计的各种参数。存储器管理重点关注分页管理和支持虚拟存储的传输后备缓冲器&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/52ba02cf9821ee200a0ce806f0f4ab70.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;《计算机文化》534页&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7e3f2f1dd4beb8e82c219c225988ae65.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第1章计算机和数字基础知识&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/5b820a3abc02490ba926f0f9d80ecf1a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第2章计算机硬件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/171461a384a60fab5051744cc54c899a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章计算机软件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/af05bcf784e0cecb7501b4efeeb3f5e0.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章操作系统和文件管理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f0a5786be3cd11fe880e0f082a829f28.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第5章局域网&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7f274302024290dbd0e1b30a1cffae84.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章因特网&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d1b6784a1bcdf0a255b755e606329a48.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第7章Web 和电子邮件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/241173941142fe5bb7ca2d758e8a5bf0.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第8章数字媒体&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d9ad4a1729be775163fcc414b5710f09.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章计算机产业:历史、职业和道德&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f70d11967db8b8b6835cb13eddc5b192.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第10章信息系统的分析与设计&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7554c578c6aa02aac7b5eec12c357ba6.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章数据库&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b90eab47eaa28d24cd25b6e7a37e2cbe.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章计算机编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d5fe5603fee7b47e2c83f037a5b153f9.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;因为这份文档有700多页，下面还有很多需要展示。就不给大家一一展示了，需要获取的小伙伴可以直接转发+关注后&lt;/strong&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/20201121160021406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzU5MjA=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e665ab28b13fc87c4fd4fb843fa9ff8a</guid>
<title>用 WebRTC 和 Node.js 开发实时视频聊天应用</title>
<link>https://toutiao.io/k/5shq47n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;话不多说，我们直奔主题。这篇文章教大家如何编写一个视频聊天应用，使已连接的两用户端能共享视频和音频。操作很简单，非常适合JavaScript语言训练——更准确地说是WebRTC技术和&lt;a href=&quot;https://tsh.io/services/web-development/node/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/services/web-development/node/&quot;&gt;Node.js&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;什么是WebRTC&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;Web Real-Time Communications 网页实时通信，简称WebRTC。WebRTC是一个HTML5规范，它允许用户在浏览器之间直接进行实时通信，不需要任何第三方插件。WebRTC可用于多种情境（比如文件共享），但端对端实时音频和视频通信是其主要功能。本文将着重为大家介绍这两项。&lt;/p&gt;



&lt;p&gt;WebRTC所做的就是允许接入设备。你可以借WebRTC来实时使用麦克风、摄像头和分享你的屏幕。&lt;/p&gt;



&lt;p&gt;所以，WebRTC可以用最简单的方式在网页中实现音频和视频通信。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC JavaScript API&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC说起来很复杂，它涉及到很多技术。但建立连接、通信和传输数据的操作是通过一套JS API来实现的，还比较简单。其中主要的API包括：&lt;/p&gt;



&lt;p&gt;RTCPeerConnection：创建和导航端对端连接。&lt;/p&gt;



&lt;p&gt;RTCSessionDescription：描述连接（或潜在连接）的一端，以及它的配置方式。&lt;/p&gt;



&lt;p&gt;navigator.getUserMedia：捕捉音频和视频。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;为什么选择Node.js&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;若要在两个或多个设备之间进行远程连接，你就需要一个服务器。在这种情况下，你也需要一个处理实时通信的服务器。Node.js是为实时可扩展的应用而构建的。要开发自由数据交换的双向连接应用程序，你可能会用到WebSockets，它允许在客户端和服务器之间建立一个会话窗口。来自客户端的请求会以循环的方式，更准确的说是事件循环进行处理，这时Node.js是我们很好的一个选择，因为它采取 “非阻塞（non-blocking） “的方式来解决请求。这样我们在这该过程中就能实现低延迟和高吞吐量。&lt;/p&gt;



&lt;p&gt;如果你对开发微服务感兴趣的话，一定要看看查看我们内含650多位微服务专家意见的&lt;a href=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot;&gt;2020年微服务状态报告&lt;/a&gt;！&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;思路拓展：我们要创建的是什么？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们会创建一个非常简单的应用程序，它能让我们将音频和视频流传输到连接的设备——一个基础款视频聊天应用程序。我们会用到的技术有:&lt;/p&gt;



&lt;p&gt;Express库，提供静态文件，比如代表用户界面（UI）的HTML文件；&lt;/p&gt;



&lt;p&gt;socket.io库，在两个设备之间用WebSockets建立连接；&lt;/p&gt;



&lt;p&gt;WebRTC，允许媒体设备（摄像头和麦克风）在连接的设备之间传输音频和视频流。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;实现视频会话&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们要做的第一件事是给我们的应用程序提供一个作为UI的HTML文件。让我们通过运行：npm init.js来初始化新的node.js项目。然后，我们需要通过运行：npm i -D typescript ts-node nodemon @types/express @types/socket.io安装一些开发依赖项，运行：npm i express socket.io安装生产依赖项。&lt;/p&gt;



&lt;p&gt;之后我们就可以在package.json文件中定义脚本，来运行我们的项目了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;{
 &quot;scripts&quot;: {
   &quot;start&quot;: &quot;ts-node src/index.ts&quot;,
   &quot;dev&quot;: &quot;nodemon --watch &#x27;src/**/*.ts&#x27; --exec &#x27;ts-node&#x27; src/index.ts&quot;
 },
 &quot;devDependencies&quot;: {
   &quot;@types/express&quot;: &quot;^4.17.2&quot;,
   &quot;@types/socket.io&quot;: &quot;^2.1.4&quot;,
   &quot;nodemon&quot;: &quot;^1.19.4&quot;,
   &quot;ts-node&quot;: &quot;^8.4.1&quot;,
   &quot;typescript&quot;: &quot;^3.7.2&quot;
 },
 &quot;dependencies&quot;: {
   &quot;express&quot;: &quot;^4.17.1&quot;,
   &quot;socket.io&quot;: &quot;^2.3.0&quot;
 }
}&lt;/pre&gt;



&lt;p&gt;当我们运行npm run dev命令时，nodemon会监控src文件夹中每个以.ts结尾的文件有无任何变化。现在，我们要创建一个src文件夹。在这个文件夹中，我们会创建两个typescript文件：index.ts和server.ts。&lt;/p&gt;



&lt;p&gt;在server.ts中，我们会创建server类，并使其与express和socket.io一起工作。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import express, { Application } from &quot;express&quot;;
import socketIO, { Server as SocketIOServer } from &quot;socket.io&quot;;
import { createServer, Server as HTTPServer } from &quot;http&quot;;
 
export class Server {
 private httpServer: HTTPServer;
 private app: Application;
 private io: SocketIOServer;
 
 private readonly DEFAULT_PORT = 5000;
 
 constructor() {
   this.initialize();
 
   this.handleRoutes();
   this.handleSocketConnection();
 }
 
 private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 }
 
 private handleRoutes(): void {
   this.app.get(&quot;/&quot;, (req, res) =&amp;gt; {
     res.send(`&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;`); 
   });
 }
 
 private handleSocketConnection(): void {
   this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     console.log(&quot;Socket connected.&quot;);
   });
 }
 
 public listen(callback: (port: number) =&amp;gt; void): void {
   this.httpServer.listen(this.DEFAULT_PORT, () =&amp;gt;
     callback(this.DEFAULT_PORT)
   );
 }
}&lt;/pre&gt;



&lt;p&gt;为正常运行服务器，我们需要在index.ts文件中创建一个新的Server类实例并调用listen方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import { Server } from &quot;./server&quot;;
 
const server = new Server();
 
server.listen(port =&amp;gt; {
 console.log(`Server is listening on http://localhost:${port}`);
});&lt;/pre&gt;



&lt;p&gt;现在，如果我们运行：npm run dev会看到下面这样的情景：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-1_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;当打开浏览器，输入&lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000&lt;/a&gt;，我们应该注意到左上的 “Hello World “信息。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-2_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们就可以在public/index.html中创建一个新的HTML文件了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
 &amp;lt;head&amp;gt;
   &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
   &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;
   &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt;
   &amp;lt;title&amp;gt;Dogeller&amp;lt;/title&amp;gt;
   &amp;lt;link
     href=&quot;https://fonts.googleapis.com/css?family=Montserrat:300,400,500,700&amp;amp;display=swap&quot;
     rel=&quot;stylesheet&quot;
   /&amp;gt;
   &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&amp;gt;
   &amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;container&quot;&amp;gt;
     &amp;lt;header class=&quot;header&quot;&amp;gt;
       &amp;lt;div class=&quot;logo-container&quot;&amp;gt;
         &amp;lt;img src=&quot;./img/doge.png&quot; alt=&quot;doge logo&quot; class=&quot;logo-img&quot; /&amp;gt;
         &amp;lt;h1 class=&quot;logo-text&quot;&amp;gt;
           Doge&amp;lt;span class=&quot;logo-highlight&quot;&amp;gt;ller&amp;lt;/span&amp;gt;
         &amp;lt;/h1&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/header&amp;gt;
     &amp;lt;div class=&quot;content-container&quot;&amp;gt;
       &amp;lt;div class=&quot;active-users-panel&quot; id=&quot;active-user-container&quot;&amp;gt;
         &amp;lt;h3 class=&quot;panel-title&quot;&amp;gt;Active Users:&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
       &amp;lt;div class=&quot;video-chat-container&quot;&amp;gt;
         &amp;lt;h2 class=&quot;talk-info&quot; id=&quot;talking-with-info&quot;&amp;gt; 
           Select active user on the left menu.
         &amp;lt;/h2&amp;gt;
         &amp;lt;div class=&quot;video-container&quot;&amp;gt;
           &amp;lt;video autoplay class=&quot;remote-video&quot; id=&quot;remote-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
           &amp;lt;video autoplay muted class=&quot;local-video&quot; id=&quot;local-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
         &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;script src=&quot;./scripts/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;



&lt;p&gt;在这个新文件中，我们创建了两个视频元素：一个用于远程视频连接，另一个用于本地视频。你可能已经注意到我们也在导入本地脚本了。现在我们就来创建一个新的文件夹“脚本”，并在这个目录下创建index.js文件。至于样式，你可以从&lt;a href=&quot;https://github.com/Miczeq22/simple-chat-app&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;GitHub库&lt;/a&gt;中下载它们。&lt;/p&gt;



&lt;p&gt;接下来你需要给浏览器提供index.html。首先，你需要告诉express你想提供哪些静态文件。为了实现这一点，我们决定在Server类中实现一个新方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private configureApp(): void {
   this.app.use(express.static(path.join(__dirname, &quot;../public&quot;)));
 }&lt;/pre&gt;



&lt;p&gt;不要忘记在initialize中调用configureApp。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 
   this.configureApp();
   this.handleSocketConnection();
 }&lt;/pre&gt;



&lt;p&gt;当你输入&lt;a href=&quot;http://localhost:5000&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;http://localhost:5000&lt;/a&gt;后，你应该能看到你的index.html文件在运行。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-3_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;下一步要实现的是允许摄像头和视频访问并将其流式传输到local-video元素。要做到这一点，你需要打开public/scripts/index.js文件，并用以下方法实现它。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;当回到浏览器时，界面会出现一个提示请求访问你的媒体设备，在接受请求后，你电脑的摄像头就开始工作了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-4_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;更多细节详见&lt;a href=&quot;https://tsh.io/blog/simple-guide-concurrency-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;A simple guide to concurrency in Node.js and a few traps that come with it&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;如何处理socket&lt;/strong&gt;&lt;strong&gt;连接？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;接下来我们讲讲如何处理socket连接。我们需要将客户端与服务器连接起来。为此，我们将使用socket.io。在public/scripts/index.js中，添加以下代码：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;页面刷新后，电脑会弹出一条消息，显示 “Socket已连接”&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-5_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们回到server.ts中，把已连接的socket存储在内存中，这只是为了保留唯一连接。所以，我们需要在Server类中添加一个新的私有字段，如下：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private activeSockets: string[] = [];&lt;/pre&gt;



&lt;p&gt;然后我们需要在socket连接中检查socket是否已经存在。如果不存在，把新的socket推送到内存中，并向已连接的用户发送数据。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;你还需要在socket断开连接时及时响应，所以在socket连接中，你需要添加：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;disconnect&quot;, () =&amp;gt; {
   this.activeSockets = this.activeSockets.filter(
     existingSocket =&amp;gt; existingSocket !== socket.id
   );
   socket.broadcast.emit(&quot;remove-user&quot;, {
     socketId: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;客户端(即public/scripts/index.js)这边，你需要妥善处理那些信息：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;update-user-list&quot;, ({ users }) =&amp;gt; {
 updateUserList(users);
});
 
socket.on(&quot;remove-user&quot;, ({ socketId }) =&amp;gt; {
 const elToRemove = document.getElementById(socketId);
 
 if (elToRemove) {
   elToRemove.remove();
 }
});&lt;/pre&gt;



&lt;p&gt;以下是 updateUserList 函数：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function updateUserList(socketIds) {
 const activeUserContainer = document.getElementById(&quot;active-user-container&quot;);
 
 socketIds.forEach(socketId =&amp;gt; {
   const alreadyExistingUser = document.getElementById(socketId);
   if (!alreadyExistingUser) {
     const userContainerEl = createUserItemContainer(socketId);
     activeUserContainer.appendChild(userContainerEl);
   }
 });
}&lt;/pre&gt;



&lt;p&gt;以及createUserItemContainer函数:&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function createUserItemContainer(socketId) {
 const userContainerEl = document.createElement(&quot;div&quot;);
 
 const usernameEl = document.createElement(&quot;p&quot;);
 
 userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user&quot;);
 userContainerEl.setAttribute(&quot;id&quot;, socketId);
 usernameEl.setAttribute(&quot;class&quot;, &quot;username&quot;);
 usernameEl.innerHTML = `Socket: ${socketId}`;
 
 userContainerEl.appendChild(usernameEl);
 
 userContainerEl.addEventListener(&quot;click&quot;, () =&amp;gt; {
   unselectUsersFromList();
   userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user active-user--selected&quot;);
   const talkingWithInfo = document.getElementById(&quot;talking-with-info&quot;);
   talkingWithInfo.innerHTML = `Talking with: &quot;Socket: ${socketId}&quot;`;
   callUser(socketId);
 }); 
 return userContainerEl;
}&lt;/pre&gt;



&lt;p&gt;需要注意的是，我们给用户容器元素添加了一个可以调用callUser函数的点击监听器——但现在，它可以是一个空的函数。接下来，当运行两个浏览器窗口（其中一个作为私人窗口）时，你应该注意到你的Web应用程序中有两个已经连接的socket。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-6_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;点击列表中的活跃用户，这时我们需要调用callUser函数。但是在实现之前，你还需要在window对象中声明两个类。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;const { RTCPeerConnection, RTCSessionDescription } = window;&lt;/pre&gt;



&lt;p&gt;我们会在callUser函数用到这两个类：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;async function callUser(socketId) {
 const offer = await peerConnection.createOffer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(offer));
 
 socket.emit(&quot;call-user&quot;, {
   offer,
   to: socketId
 });
}&lt;/pre&gt;



&lt;p&gt;现在我们要创建一个本地请求并发送给选定的用户。服务器会监听一个叫做call-user的事件、拦截请求并将其转发给选定的用户。让我们用server.ts来实现该操作：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-user&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;call-made&quot;, {
     offer: data.offer,
     socket: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，你需要就call-made事件作出调整：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.offer)
 );
 const answer = await peerConnection.createAnswer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(answer));
 
 socket.emit(&quot;make-answer&quot;, {
   answer,
   to: data.socket
 });
});&lt;/pre&gt;



&lt;p&gt;之后，在你从服务器得到的请求上设置一个远程描述，并为这个请求创建一个答复。对于服务器端，你只需要将适当的数据传递给选定的用户即可。然后我们再在server.ts里面添加一个监听器。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;make-answer&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;answer-made&quot;, {
     socket: socket.id,
     answer: data.answer
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，我们需要处理 answer-made 事件。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;answer-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.answer)
 );
 
 if (!isAlreadyCalling) {
   callUser(data.socket);
   isAlreadyCalling = true;
 }
});&lt;/pre&gt;



&lt;p&gt;我们可以使用标志isAlreadyCalling，它能帮助确保我们只需调用一次用户。&lt;/p&gt;



&lt;p&gt;最后你需要做的是添加本地轨道，包括音频和视频到你的连接端。只有做到这一点，我们才能够与连接的用户共享视频和音频。要做到这一点，我们需要在navigator.getMediaDevice回调中调用peerConnection对象的addTrack函数。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 
   stream.getTracks().forEach(track =&amp;gt; peerConnection.addTrack(track, stream));
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;另外，我们还需要为ontrack事件添加一个适当的处理程序。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;peerConnection.ontrack = function({ streams: [stream] }) {
 const remoteVideo = document.getElementById(&quot;remote-video&quot;);
 if (remoteVideo) {
   remoteVideo.srcObject = stream;
 }
};&lt;/pre&gt;



&lt;p&gt;如图示，我们已经从传递的对象中获取了流，并改变了远程视频中的srcObject来使用接收到的流。所以现在当你点击活跃用户后，你应该建立一个视频和音频连接，像下图这样：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-7_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;欲了解细节，请参阅：&lt;a href=&quot;https://tsh.io/blog/dependency-injection-in-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Node.js and dependency injection – friends or foes?&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;现在你知道如何编写一个视频聊天应用了吧！&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC是一个很大的话题，内容非常庞杂。如果你想了解它的运作原理，就需要花很大功夫。幸运的是，我们可以访问易于使用的JavaScript API，它可以帮助我们创建很简洁的应用程序，例如视频共享、聊天应用程序等等。&lt;/p&gt;



&lt;p&gt;如果你想深入了解WebRTC，点击此&lt;a href=&quot;http://Node.js%20and%20dependency%20injection%20–%20friends%20or%20foes%3F&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;WebRTC官方文档的链接&lt;/a&gt;。另外，我也推荐你阅读&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;MDN的文档说明&lt;/a&gt;，它能帮助你更加了解此技术。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：Mikołaj Wargowski&lt;/p&gt;&lt;/blockquote&gt;



&lt;p/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6aa0e6fc86d2bc5e7d45a54f3da88db9</guid>
<title>[推荐] 刨根问底，Kafka 消息中间件到底会不会丢消息</title>
<link>https://toutiao.io/k/17q9ijl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为避免上面类似情况的发生，除了做好补偿措施，更应该在系设计的时候充分考虑各种异常，设计一个稳定、高可用的消息系统。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;认识Kafka&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下维基百科的定义&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。&lt;/p&gt;&lt;p&gt;Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;kafka架构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka的整体架构非常简单，是显式分布式架构，主要由producer、broker（kafka）和consumer组成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41169590643274856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CcicjWevmX0FVRXZwexWyd4xPeEyiaSpXCVlqvyOhTF2lrCZmvTQd6DVicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;figcaption&gt;Kafka架构（精简版）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer&lt;/strong&gt;（生产者）可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(如记录中的key)来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Consumer&lt;/strong&gt;（消费者）使用一个consumer group（消费组）名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例。消费者实例可以分布在多个进程中或者多个机器上。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka到底会不会丢失消息？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讨论kafka是否丢消息前先来了解一下什么是&lt;strong&gt;消息传递语义&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.311614730878187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Cc4Rr3ibFmXY650cR6zyfKKSP5ey95z4cVvj8CkABrB3Ua4SdTOzDhJbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot;/&gt;&lt;figcaption&gt;消息传递语义&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;message delivery semantic 也就是消息传递语义，简单说就是消息传递过程中消息传递的保证性。主要分为三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;at most once&lt;/strong&gt;：最多一次。消息可能丢失也可能被处理，但最多只会被处理一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;at least once&lt;/strong&gt;：至少一次。消息不会丢失，但可能被处理多次。可能重复，不会丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;exactly once&lt;/strong&gt;：精确传递一次。消息被处理且只会被处理一次。不丢失不重复就一次。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想情况下肯定是希望系统的消息传递是严格exactly once，也就是保证不丢失、只会被处理一次，但是很难做到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到主角Kafka，Kafka有三次消息传递的过程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者发消息给Kafka Broker。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker 消息同步和持久化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker 将消息传递给消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这三步中每一步都有可能会丢失消息，下面详细分析为什么会丢消息，如何最大限度避免丢失消息。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生产者丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先介绍一下生产者发送消息的一般流程（部分流程与具体配置项强相关，这里先忽略）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者是与leader直接交互，所以先从集群获取topic对应分区的leader元数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取到leader分区元数据后直接将消息发给过去；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker对应的leader分区收到消息后写入文件持久化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower拉取Leader消息与Leader的数据保持一致；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower消息拉取完毕需要给Leader回复ACK确认消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Leader和Follower分区同步完，Leader分区会给生产者回复ACK确认消息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3728813559322034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CceLDlQ1mY0LcoiakHWrS2icgKncMSb465JlMMDS2sYWJFf7HbNjBGnWfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;figcaption&gt;生产者发送数据流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘。消息写入Leader后，Follower是主动与Leader进行同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka通过配置request.required.acks属性来确认消息的生产：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;0表示不进行消息接收是否成功的确认；不能保证消息是否发送成功，生成环境基本不会用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1表示当Leader接收成功时确认；只要Leader存活就可以保证不丢失，保证了吞吐量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-1或者all表示Leader和Follower都接收成功时确认；可以最大限度保证消息不丢失，但是吞吐量低。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka producer 的参数acks 的默认值为1，所以默认的producer级别是at least once，并不能exactly once。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果acks配置为0，发生网络抖动消息丢了，生产者不校验ACK自然就不知道丢了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果acks配置为1保证leader不丢，但是如果leader挂了，恰好选了一个没有ACK的follower，那也丢了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;all：保证leader和follower不丢，但是如果网络拥塞，没有收到ACK，会有重复发的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka Broker丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka Broker 接收到数据后会将数据进行持久化存储，你以为是下面这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5754189944134078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Cc3R8l6vVib3crFZ6tY36BAx45VEdHwQmoB7MicQLPqw9A8gaia40Zt0xXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;figcaption&gt;消息持久化，无cache&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7117750439367311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CcLTpX0ctRRzTX5eVWeh89ic9Vgx2DwQJLcIiafe4vZ9C2JPUKGgWNLMQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;figcaption&gt;消息持久化，有cache&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统本身有一层缓存，叫做 Page Cache，当往磁盘文件写入的时候，系统会先将数据流写入缓存中，至于什么时候将缓存的数据写入文件中是由操作系统自行决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka提供了一个参数 producer.type 来控制是不是主动flush，如果Kafka写入到mmap之后就立即 flush 然后再返回 Producer 叫同步 (sync)；写入mmap之后立即返回 Producer 不调用 flush 叫异步 (async)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka通过多分区多副本机制中已经能最大限度保证数据不会丢失，如果数据已经写入系统 cache 中但是还没来得及刷入磁盘，此时突然机器宕机或者掉电那就丢了，当然这种情况很极端。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消费者丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者通过pull模式主动的去 kafka 集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找leader分区去拉取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id。同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会出现多个消费者消费同一分区的数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4226950354609929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Ccd3ZE38bwHmgdr7Ih3xqFrpjuC5THTZWgZiaB0picutRgLNb3v0LO6vNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;消费者群组消费消息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者消费的进度通过offset保存在kafka集群的__consumer_offsets这个topic中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费消息的时候主要分为两个阶段：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、标识消息已被消费，commit offset坐标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、处理消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景一：先commit再处理消息。如果在处理消息的时候异常了，但是offset 已经提交了，这条消息对于该消费者来说就是丢失了，再也不会消费到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景二：先处理消息再commit。如果在commit之前发生异常，下次还会消费到该消息，重复消费的问题可以通过业务保证消息幂等性来解决。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，kafka到底会不会丢消息？答案是：会！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka可能会在三个阶段丢失消息：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）生产者发送数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Kafka Broker 存储数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）消费者消费数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产环境中严格做到exactly once其实是难的，同时也会牺牲效率和吞吐量，最佳实践是业务侧做好补偿机制，万一出现消息丢失可以兜底。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>96745a693e4f07817eb94d89cda83ee7</guid>
<title>[推荐] 自定义注解！绝对是程序员装逼的利器</title>
<link>https://toutiao.io/k/gnbzbuw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;相信很多人对Java中的注解都很熟悉，比如我们经常会用到的一些如@Override、@Autowired、@Service等，这些都是JDK或者诸如Spring这类框架给我们提供的。&lt;/p&gt;
&lt;p&gt;在以往的面试过程中，我发现，关于注解的知识很多程序员都仅仅停留在使用的层面上，很少有人知道注解是如何实现的，更别提使用自定义注解来解决实际问题了。&lt;/p&gt;
&lt;p&gt;但是其实，我觉得一个好的程序员的标准就是懂得如何优化自己的代码，那在代码优化上面，如何精简代码，去掉重复代码就是一个至关重要的话题，在这个话题领域，自定义注解绝对可以算得上是一个大大的功臣。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;在我看来，会使用自定义注解 ≈ 好的程序员。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，本文，就来介绍几个，作者在开发中实际用到的几个例子，向你介绍下如何使用注解来提升你代码的逼格。&lt;/p&gt;
&lt;h3&gt;基本知识&lt;/h3&gt;
&lt;p&gt;在Java中，注解分为两种，元注解和自定义注解。&lt;/p&gt;
&lt;p&gt;很多人误以为自定义注解就是开发者自己定义的，而其它框架提供的不算，但是其实上面我们提到的那几个注解其实都是自定义注解。&lt;/p&gt;
&lt;p&gt;关于”元”这个描述，在编程世界里面有都很多，比如”元注解”、”元数据”、”元类”、”元表”等等，这里的”元”其实都是从meta翻译过来的。&lt;/p&gt;
&lt;p&gt;一般我们把&lt;strong&gt;元注解理解为描述注解的注解&lt;/strong&gt;，&lt;strong&gt;元数据理解为描述数据的数据&lt;/strong&gt;，&lt;strong&gt;元类理解为描述类的类&lt;/strong&gt;…&lt;/p&gt;
&lt;p&gt;所以，在Java中，除了有限的几个固定的”描述注解的注解”以外，所有的注解都是自定义注解。&lt;/p&gt;
&lt;p&gt;在JDK中提供了4个标准的用来对注解类型进行注解的注解类（元注解），他们分别是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target
@Retention
@Documented
@Inherited
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了以上这四个，所有的其他注解全部都是自定义注解。&lt;/p&gt;
&lt;p&gt;这里不准备深入介绍以上四个元注解的作用，大家可以自行学习。&lt;/p&gt;
&lt;p&gt;本文即将提到的几个例子，都是作者在日常工作中真实使用到的场景，这例子有一个共同点，那就是都用到了Spring的AOP技术。&lt;/p&gt;
&lt;p&gt;什么是AOP以及他的用法相信很多人都知道，这里也就不展开介绍了。&lt;/p&gt;
&lt;h3&gt;使用自定义注解做日志记录&lt;/h3&gt;
&lt;p&gt;不知道大家有没有遇到过类似的诉求，就是希望在一个方法的入口处或者出口处做统一的日志处理，比如记录一下入参、出参、记录下方法执行的时间等。&lt;/p&gt;
&lt;p&gt;如果在每一个方法中自己写这样的代码的话，一方面会有很多代码重复，另外也容易被遗漏。&lt;/p&gt;
&lt;p&gt;这种场景，就可以使用自定义注解+切面实现这个功能。&lt;/p&gt;
&lt;p&gt;假设我们想要在一些web请求的方法上，记录下本次操作具体做了什么事情，比如新增了一条记录或者删除了一条记录等。&lt;/p&gt;
&lt;p&gt;首先我们自定义一个注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Operate Log 的自定义注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface OpLog {

    /**
     * 业务类型，如新增、删除、修改
     *
     * @return
     */
    public OpType opType();

    /**
     * 业务对象名称，如订单、库存、价格
     *
     * @return
     */
    public String opItem();

    /**
     * 业务对象编号表达式，描述了如何获取订单号的表达式
     *
     * @return
     */
    public String opItemIdExpression();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们不仅要在日志中记录本次操作了什么，还需要知道被操作的对象的具体的唯一性标识，如订单号信息。&lt;/p&gt;
&lt;p&gt;但是每一个接口方法的参数类型肯定是不一样的，很难有一个统一的标准，那么我们就可以借助Spel表达式，即在表达式中指明如何获取对应的对象的唯一性标识。&lt;/p&gt;
&lt;p&gt;有了上面的注解，接下来就可以写切面了。主要代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * OpLog的切面处理类，用于通过注解获取日志信息，进行日志记录
 *
 * @author Hollis
 */
@Aspect
@Component
public class OpLogAspect {

    private static final Logger LOGGER = LoggerFactory.getLogger(OpLogAspect.class);

    @Autowired
    HttpServletRequest request;

    @Around(&quot;@annotation(com.hollis.annotation.OpLog)&quot;)
    public Object log(ProceedingJoinPoint pjp) throws Exception {

        Method method = ((MethodSignature)pjp.getSignature()).getMethod();
        OpLog opLog = method.getAnnotation(OpLog.class);

        Object response = null;

        try {
            // 目标方法执行
            response = pjp.proceed();
        } catch (Throwable throwable) {
            throw new Exception(throwable);
        } 

        if (StringUtils.isNotEmpty(opLog.opItemIdExpression())) {
            SpelExpressionParser parser = new SpelExpressionParser();
            Expression expression = parser.parseExpression(opLog.opItemIdExpression());

            EvaluationContext context = new StandardEvaluationContext();
            // 获取参数值
            Object[] args = pjp.getArgs();

            // 获取运行时参数的名称
            LocalVariableTableParameterNameDiscoverer discoverer
                = new LocalVariableTableParameterNameDiscoverer();
            String[] parameterNames = discoverer.getParameterNames(method);

            // 将参数绑定到context中
            if (parameterNames != null) {
                for (int i = 0; i &amp;lt; parameterNames.length; i++) {
                    context.setVariable(parameterNames[i], args[i]);
                }
            }

            // 将方法的resp当做变量放到context中，变量名称为该类名转化为小写字母开头的驼峰形式
            if (response != null) {
                context.setVariable(
                    CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, response.getClass().getSimpleName()),
                    response);
            }

            // 解析表达式，获取结果
            String itemId = String.valueOf(expression.getValue(context));

            // 执行日志记录
            handle(opLog.opType(), opLog.opItem(), itemId);
        }

        return response;
    }


    private void handle(OpType opType,  String opItem, String opItemId) {
      // 通过日志打印输出
      LOGGER.info(&quot;opType = &quot; + opType.name() +&quot;,opItem = &quot; +opItem + &quot;,opItemId = &quot; +opItemId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上切面中，有几个点需要大家注意的：&lt;/p&gt;
&lt;p&gt;1、使用@Around注解来指定对标注了OpLog的方法设置切面。 2、使用Spel的相关方法，通过指定的表示，从对应的参数中获取到目标对象的唯一性标识。 3、再方法执行成功后，输出日志。&lt;/p&gt;
&lt;p&gt;有了以上的切面及注解后，我们只需要在对应的方法上增加注解标注即可，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#id&quot;)
public @ResponseBody
HashMap view(@RequestParam(name = &quot;id&quot;) String id)
    throws Exception {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这种是入参的参数列表中已经有了被操作的对象的唯一性标识，直接使用&lt;code&gt;#id&lt;/code&gt;指定即可。&lt;/p&gt;
&lt;p&gt;如果被操作的对象的唯一性标识不在入参列表中，那么可能是入参的对象中的某一个属性，用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#orderVo.id&quot;)
public @ResponseBody
HashMap update(OrderVO orderVo)
    throws Exception {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，即可从入参的OrderVO对象的id属性的值获取。&lt;/p&gt;
&lt;p&gt;如果我们要记录的唯一性标识，在入参中没有的话，应该怎么办呢？最典型的就是插入方法，插入成功之前，根本不知道主键ID是什么，这种怎么办呢？&lt;/p&gt;
&lt;p&gt;我们上面的切面中，做了一件事情，就是我们把方法的返回值也会使用表达式进行一次解析，如果可以解析得到具体的值，可以是可以。如以下写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})
@OpLog(opType = OpType.QUERY, opItem = &quot;order&quot;, opItemIdExpression = &quot;#insertResult.id&quot;)
public @ResponseBody
InsertResult insert(OrderVO orderVo)
    throws Exception {

    return orderDao.insert(orderVo);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是一个简单的使用自定义注解+切面进行日志记录的场景。下面我们再来看一个如何使用注解做方法参数的校验。&lt;/p&gt;
&lt;h3&gt;使用自定义注解做前置检查&lt;/h3&gt;
&lt;p&gt;当我们对外部提供接口的时候，会对其中的部分参数有一定的要求，比如某些参数值不能为空等。大多数情况下我们都需要自己主动进行校验，判断对方传入的值是否合理。&lt;/p&gt;
&lt;p&gt;这里推荐一个使用HibernateValidator + 自定义注解 + AOP实现参数校验的方式。&lt;/p&gt;
&lt;p&gt;首先我们会有一个具体的入参类，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private String idempotentNo;
    @NotNull(
        message = &quot;userName can&#x27;t be null&quot;
    )
    private String userName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，对userName参数注明不能为null。&lt;/p&gt;
&lt;p&gt;然后再使用hibernate validator定义一个工具类，用于做参数校验。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 参数校验工具
 *
 * @author Hollis
 */
public class BeanValidator {

    private static Validator validator = Validation.byProvider(HibernateValidator.class).configure().failFast(true)
        .buildValidatorFactory().getValidator();

    /**
     * @param object object
     * @param groups groups
     */
    public static void validateObject(Object object, Class&amp;lt;?&amp;gt;... groups) throws ValidationException {
        Set&amp;lt;ConstraintViolation&amp;lt;Object&amp;gt;&amp;gt; constraintViolations = validator.validate(object, groups);
        if (constraintViolations.stream().findFirst().isPresent()) {
            throw new ValidationException(constraintViolations.stream().findFirst().get().getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码，会对一个bean进行校验，一旦失败，就会抛出ValidationException。&lt;/p&gt;
&lt;p&gt;接下来定义一个注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * facade接口注解， 用于统一对facade进行参数校验及异常捕获
 * &amp;lt;pre&amp;gt;
 *      注意，使用该注解需要注意，该方法的返回值必须是BaseResponse的子类
 * &amp;lt;/pre&amp;gt;
 */

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Facade {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个注解里面没有任何参数，只用于标注那些方法要进行参数校验。&lt;/p&gt;
&lt;p&gt;接下来定义切面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Facade的切面处理类，统一统计进行参数校验及异常捕获
 *
 * @author Hollis
 */
@Aspect
@Component
public class FacadeAspect {

    private static final Logger LOGGER = LoggerFactory.getLogger(FacadeAspect.class);

    @Autowired
    HttpServletRequest request;

    @Around(&quot;@annotation(com.hollis.annotation.Facade)&quot;)
    public Object facade(ProceedingJoinPoint pjp) throws Exception {

        Method method = ((MethodSignature)pjp.getSignature()).getMethod();
        Object[] args = pjp.getArgs();

        Class returnType = ((MethodSignature)pjp.getSignature()).getMethod().getReturnType();

        //循环遍历所有参数，进行参数校验
        for (Object parameter : args) {
            try {
                BeanValidator.validateObject(parameter);
            } catch (ValidationException e) {
                return getFailedResponse(returnType, e);
            }
        }

        try {
            // 目标方法执行
            Object response = pjp.proceed();
            return response;
        } catch (Throwable throwable) {
            return getFailedResponse(returnType, throwable);
        }
    }

    /**
     * 定义并返回一个通用的失败响应
     */
    private Object getFailedResponse(Class returnType, Throwable throwable)
        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {

        //如果返回值的类型为BaseResponse 的子类，则创建一个通用的失败响应
        if (returnType.getDeclaredConstructor().newInstance() instanceof BaseResponse) {
            BaseResponse response = (BaseResponse)returnType.getDeclaredConstructor().newInstance();
            response.setSuccess(false);
            response.setResponseMessage(throwable.toString());
            response.setResponseCode(GlobalConstant.BIZ_ERROR);
            return response;
        }

        LOGGER.error(
            &quot;failed to getFailedResponse , returnType (&quot; + returnType + &quot;) is not instanceof BaseResponse&quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码，和前面的切面有点类似，主要是定义了一个切面，会对所有标注@Facade的方法进行统一处理，即在开始方法调用前进行参数校验，一旦校验失败，则返回一个固定的失败的Response，特别需要注意的是，这里之所以可以返回一个固定的BaseResponse，是因为我们会要求我们的所有对外提供的接口的response必须继承BaseResponse类，这个类里面会定义一些默认的参数，如错误码等。&lt;/p&gt;
&lt;p&gt;之后，只需要对需要参数校验的方法增加对应注解即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Facade
public TestResponse query(User user) {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，有了以上注解和切面，我们就可以对所有的对外方法做统一的控制了。&lt;/p&gt;
&lt;p&gt;其实，以上这个facadeAspect我省略了很多东西，我们真正使用的那个切面，不仅仅做了参数检查，还可以做很多其他事情。比如异常的统一处理、错误码的统一转换、记录方法执行时长、记录方法的入参出参等等。&lt;/p&gt;
&lt;p&gt;总之，使用切面+自定义注解，我们可以统一做很多事情。除了以上的这几个场景，我们还有很多相似的用法，比如：&lt;/p&gt;
&lt;p&gt;统一的缓存处理。如某些操作需要在操作前查缓存、操作后更新缓存。这种就可以通过自定义注解+切面的方式统一处理。&lt;/p&gt;
&lt;p&gt;代码其实都差不多，思路也比较简单，就是通过自定义注解来标注需要被切面处理的累或者方法，然后在切面中对方法的执行过程进行干预，比如在执行前或者执行后做一些特殊的操作。&lt;/p&gt;
&lt;p&gt;使用这种方式可以大大减少重复代码，大大提升代码的优雅性，方便我们使用。&lt;/p&gt;
&lt;p&gt;但是同时也不能过度使用，因为注解看似简单，但是其实内部有很多逻辑是容易被忽略的。就像我之前写过一篇《&lt;a href=&quot;https://www.hollischuang.com/archives/5608&quot;&gt;Spring官方都推荐使用的@Transactional事务，为啥我不建议使用！&lt;/a&gt;》中提到的观点一样，无脑的使用切面和注解，可能会引入一些不必要的问题。&lt;/p&gt;
&lt;p&gt;不管怎么说，自定义注解却是是一个很好的发明，可以减少很多重复代码。快快在你的项目中用起来吧。&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1a31aa13fb5976a0b0e3b4d69a96f168</guid>
<title>[推荐] 几乎刷完了力扣所有的链表题，我发现了这些东西。。。</title>
<link>https://toutiao.io/k/b2q9ajw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjy10z1yfrc6oKVIxFMy227Xib0ZbtodBqgFh9keDE1icfgeOBGa1HCUjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;span/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上下本文的提纲，这个是我用 mindmap 画的一个脑图，之后我后继续完善，将其他专题逐步完善起来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;大家也可以使用 vscode blink-mind 打开源文件查看，里面有一些笔记可以点开查看。源文件可以去我的公众号《力扣加加》回复脑图获取，以后脑图也会持续更新更多内容。vscode 插件地址：https://marketplace.visualstudio.com/items?itemName=awehook.vscode-blink-mind&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 lucifer。今天给大家带来的专题是《链表》。很多人觉得链表是一个很难的专题。实际上，只要你掌握了诀窍，它并没那么难。接下来，我们展开说说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链表标签&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;在 leetcode 一共有 &lt;strong&gt;「54 道题」&lt;/strong&gt;。为了准备这个专题，我花了几天时间将 leetcode 几乎所有的链表题目都刷了一遍。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjQZ4Z3D10wgCK09GQv4hUqica5fUGLsPgiaRB1D4kUeMLibJyOiaxdD5bnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，除了六个上锁的，其他我都刷了一遍。而实际上，这六个上锁的也没有什么难度，甚至和其他 48 道题差不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过集中刷这些题，我发现了一些有趣的信息，今天就分享给大家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各种数据结构，不管是队列，栈等线性数据结构还是树，图的等非线性数据结构，从根本上底层都是数组和链表。不管你用的是数组还是链表，用的都是计算机内存，物理内存是一个个大小相同的内存单元构成的，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjsNGZGHvdK6ZdMun9ISeBoEk1F33VzbEc3n1Gf4NibXUJyZmkQNU14Lg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图 1. 物理内存）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而数组和链表虽然用的都是物理内存，都是两者在对物理的使用上是非常不一样的，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjIoYbpVSrFFDk82HqpF737wva3K8DDhGDbNJtnIULibPec9zLh7TgHNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图 2. 数组和链表的物理存储图）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不难看出，数组和链表只是使用物理内存的两种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组是连续的内存空间，通常每一个单位的大小也是固定的，因此可以按下标随机访问。而链表则不一定连续，因此其查找只能依靠别的方式，一般我们是通过一个叫 next 指针来遍历查找。链表其实就是一个结构体。比如一个可能的单链表的定义可以是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; ListNode&amp;lt;T&amp;gt; {&lt;br/&gt;  data: T;&lt;br/&gt;  next: ListNode;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;data 是数据域，存放数据，next 是一个指向下一个节点的指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的物理结构图可以看出数组是一块连续的空间，数组的每一项都是紧密相连的，因此如果要执行插入和删除操作就很麻烦。对数组头部的插入和删除时间复杂度都是&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，而平均复杂度也是&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，只有对尾部的插入和删除才是&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。简单来说”数组对查询特别友好，对删除和添加不友好“。为了解决这个问题，就有了链表这种数据结构。链表适合在数据需要有一定顺序，但是又需要进行频繁增删除的场景，具体内容参考后面的《链表的基本操作》小节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjQ7wCAVIC8wIhLPlEY86OEtBVKsVJjTjCSZyYffA9lq00SRoYeIWjCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（图 3. 一个典型的链表逻辑表示图）&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;后面所有的图都是基于逻辑结构，而不是物理结构&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表只有一个后驱节点 next，如果是双向链表还会有一个前驱节点 pre。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;有没有想过为啥只有二叉树，而没有一叉树。实际上链表就是特殊的树，即一叉树。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;链表的基本操作&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想写出链表的题目， 熟悉链表的各种基本操作和复杂度是必须的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;插入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插入只需要考虑要插入位置前驱节点和后继节点（双向链表的情况下需要更新后继节点）即可，其他节点不受影响，因此在给定指针的情况下插入的操作时间复杂度为&lt;code&gt;O(1)&lt;/code&gt;。这里给定指针中的指针指的是插入位置的前驱节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;temp = 待插入位置的前驱节点.next&lt;br/&gt;待插入位置的前驱节点.next = 待插入指针&lt;br/&gt;待插入指针.next = temp&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有给定指针，我们需要先遍历找到节点，因此最坏情况下时间复杂度为 &lt;code&gt;O(N)&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;提示 1: 考虑头尾指针的情况。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;提示 2: 新手推荐先画图，再写代码。等熟练之后，自然就不需要画图了。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;删除&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑&lt;strong&gt;「边界条件」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;待删除位置的前驱节点.next = 待删除位置的前驱节点.next.next&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;提示 1: 考虑头尾指针的情况。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;提示 2: 新手推荐先画图，再写代码。等熟练之后，自然就不需要画图了。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;遍历&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遍历比较简单，直接上伪代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;迭代伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;当前指针 =  头指针&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; 当前节点不为空 {&lt;br/&gt;   &lt;span&gt;print&lt;/span&gt;(当前节点)&lt;br/&gt;   当前指针 = 当前指针.next&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个前序遍历的递归的伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dfs(cur) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; 当前节点为空 &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    print(cur.val)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dfs(cur.next)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;链表和数组到底有多大的差异？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉我的小伙伴应该经常听到我说过一句话，那就是&lt;strong&gt;「数组和链表同样作为线性的数组结构，二者在很多方便都是相同的，只在细微的操作和使用场景上有差异而已」&lt;/strong&gt;。而使用场景，很难在题目中直接考察。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;实际上，使用场景是可以死记硬背的。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，对于我们做题来说，&lt;strong&gt;「二者的差异通常就只是细微的操作差异」&lt;/strong&gt;。这么说大家可能感受不够强烈，我给大家举几个例子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的遍历：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.size();i++) {&lt;br/&gt;    print(arr[i])&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表的遍历：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (ListNode cur = head; cur != &lt;span&gt;null&lt;/span&gt;; cur = cur.next) {&lt;br/&gt;    print(cur.val)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很像？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**可以看出二者逻辑是一致的，只不过细微操作不一样。**比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数组是索引 ++&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;链表是 cur = cur.next&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们需要逆序遍历呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = arr.size() - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; - &lt;span&gt;1&lt;/span&gt;;i--) {&lt;br/&gt;    print(arr[i])&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是链表，通常需要借助于双向链表。而双向链表在力扣的题目很少，因此大多数你没有办法拿到前驱节点，这也是为啥很多时候会自己记录一个前驱节点 pre 的原因。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (ListNode cur = tail; cur != &lt;span&gt;null&lt;/span&gt;; cur = cur.pre) {&lt;br/&gt;    print(cur.val)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果往数组末尾添加一个元素就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;arr.push(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表的话，很多语言没有内置的数组类型。比如力扣通常使用如下的类来模拟。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ListNode&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; val;&lt;br/&gt;      ListNode next;&lt;br/&gt;      ListNode() {}&lt;br/&gt;      ListNode(&lt;span&gt;int&lt;/span&gt; val) { &lt;span&gt;this&lt;/span&gt;.val = val; }&lt;br/&gt;      ListNode(&lt;span&gt;int&lt;/span&gt; val, ListNode next) { &lt;span&gt;this&lt;/span&gt;.val = val; &lt;span&gt;this&lt;/span&gt;.next = next; }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们是不能直接调用 push 方法的。想一下，如果当你实现这个，你怎么做？你可以先自己想一下，再往下看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3...2...1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ok，其实很简单。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 假设 cur 是链表的尾部节点&lt;/span&gt;&lt;br/&gt;tail.next = &lt;span&gt;new&lt;/span&gt; ListNode(&lt;span&gt;&#x27;lucifer&#x27;&lt;/span&gt;)&lt;br/&gt;tail = tail.next&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面两行代码之后， tail 仍然指向尾部节点。是不是很简单，你学会了么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这有什么用？比如有的题目需要你复制一个新的链表， 你是不是需要开辟一个新的链表头，然后不断拼接（push）复制的节点？这就用上了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于数组的底层也是类似的，一个可能的数组 push 底层实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;arr.length += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;arr[arr.length - &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;&#x27;lucifer&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下， 数组和链表逻辑上二者有很多相似之处，不同的只是一些使用场景和操作细节，对于做题来说，我们通常更关注的是操作细节。关于细节，接下来给大家介绍，这一小节主要让大家知道二者在思想和逻辑的&lt;strong&gt;「神相似」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴做链表题先把链表换成数组，然后用数组做，本人不推荐这种做法，这等于是否认了链表存在的价值，小朋友不要模仿。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;链表题难度几何？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表题真的不难。说链表不难是有证据的。就拿 LeetCode 平台来说，处于困难难度的题目只有两个。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjCqPc7LtRNB88JpeexVXVPgiaQdHicehbqmLo3NeBQRDX3M0ELvwK2fiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 第 23 题基本没有什么链表操作，一个常规的“归并排序”即可搞定，而合并两个有序链表是一个简单题。如果你懂得数组的归并排序和合并两个有序链表，应该轻松拿下这道题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;合并两个有序数组也是一个简单题目，二者难度几乎一样。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于第 25 题， 相信你看完本节的内容，也可以做出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，话虽这么说，但是还是有很多小朋友给我说 ”指针绕来绕去就绕晕了“， ”老是死循环“ 。。。。。。链表题目真的那么难么？我们又该如何破解？lucifer 给大家准备了一个口诀 &lt;strong&gt;「一个原则， 两种题型，三个注意，四个技巧」&lt;/strong&gt;，让你轻松搞定链表题，再也不怕手撕链表。我们依次来看下这个口诀的内容。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个原则&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个原则就是 &lt;strong&gt;「画图」&lt;/strong&gt;，尤其是对于新手来说。不管是简单题还是难题一定要画图，这是贯穿链表题目的一个准则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画图可以减少我们的认知负担，这其实和打草稿，备忘录道理是一样的，将存在脑子里的东西放到纸上。举一个不太恰当的例子就是你的脑子就是 CPU，脑子的记忆就是寄存器。寄存器的容量有限，我们需要把不那么频繁使用的东西放到内存，把寄存器用在真正该用的地方，这个内存就是纸或者电脑平板等一切你可以画图的东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画的好看不好看都不重要，能看清就行了。用笔随便勾画一下， 能看出关系就够了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两个考点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把力扣的链表做了个遍。发现一个有趣的现象，那就是链表的考点很单一。除了设计类题目，其考点无法就两点：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;指针的修改&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中指针修改最典型的就是链表反转。其实链表反转不就是修改指针么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于数组这种支持随机访问的数据结构来说， 反转很容易， 只需要头尾不断交换即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;reverseArray&lt;/span&gt;(&lt;span&gt;arr&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; left = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; right = arr.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (left &amp;lt; right) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; temp = arr[left];&lt;br/&gt;    arr[left++] = arr[right];&lt;br/&gt;    arr[right--] = temp;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arr;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于链表来说，就没那么容易了。力扣关于反转链表的题简直不要太多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我给大家写了一个最完整的链表反转，以后碰到可以直接用。当然，前提是大家要先理解再去套。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我要实现的一个反转&lt;strong&gt;「任意一段链表」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;reverse(self, head: ListNode, tail: ListNode)。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 head 指的是需要反转的头节点，tail 是需要反转的尾节点。不难看出，如果 head 是整个链表的头，tail 是整个链表的尾，那就是反转整个链表，否则就是反转局部链表。接下来，我们就来实现它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们要做的就是画图。这个我在&lt;strong&gt;「一个原则」&lt;/strong&gt;部分讲过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，是我们需要反转的部分链表：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBj9xceMRTDwNOCx3hlE49WbkooSUw3jCUeonhr3GH5WmIT7p44qGXycA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们期望反转之后的长这个样子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjXgUIZIQWjicbPHTQEZY7XbUawd0kWx1mibib8dWwezc3CDB3zvK2LzZ4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不难看出， &lt;strong&gt;「最终返回 tail 即可」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于链表的递归性，实际上，我们只要反转其中相邻的两个，剩下的采用同样的方法完成即可。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;链表是一种递归的数据结构，因此采用递归的思想去考虑往往事半功倍，关于递归思考链表将在后面《三个注意》部分展开。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBj0kMevwJVVTVwlGKawqUicZ3HeqNiacdjUDGiabkr7qjfHibL6dkmiclW95A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于两个节点来说，我们只需要下修改一次指针即可，这好像不难。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cur.next = pre&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBj0yTNZvgHcZ9k8AJFUNwazvamstmbcAe4OTNowIBFlibIXTbP5BxWQSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这一个操作，不仅硬生生有了环，让你死循环。还让不应该一刀两断的它们分道扬镳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于分道扬镳这个不难解决， 我们只需要反转前，记录一下下一个节点即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;next = cur.next&lt;br/&gt;cur.next = pre&lt;br/&gt;&lt;br/&gt;cur = next&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjC9Zb1S6MQ7hDWF2CDrBI6rNk7FAb8BkGnVXha5v8pTnWb8340sBuag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么环呢？实际上， 环不用解决。因为如何我们是从前往后遍历，那么实际上，前面的链表已经被反转了，因此上面我的图是错的。正确的图应该是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjTvVjialReO4Ioo8nEKfXicw1uRxccMCI0TiabtB1kjoUIFbX22YODG7TQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此为止，我们可以写出如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;# 翻转一个子链表，并返回新的头与尾&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;reverse&lt;/span&gt;&lt;span&gt;(self, head: ListNode, tail: ListNode)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        cur = head&lt;br/&gt;        pre = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; cur != tail:&lt;br/&gt;            &lt;span&gt;# 留下联系方式&lt;/span&gt;&lt;br/&gt;            next = cur.next&lt;br/&gt;            &lt;span&gt;# 修改指针&lt;/span&gt;&lt;br/&gt;            cur.next = pre&lt;br/&gt;            &lt;span&gt;# 继续往下走&lt;/span&gt;&lt;br/&gt;            pre = cur&lt;br/&gt;            cur = next&lt;br/&gt;        &lt;span&gt;# 反转后的新的头尾节点返回出去&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; tail, head&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你仔细观察，会发现，我们的 tail 实际上是没有被反转的。解决方法很简单，将 tail 后面的节点作为参数传进来呗。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 翻转一个子链表，并且返回新的头与尾&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;reverse&lt;/span&gt;&lt;span&gt;(self, head: ListNode, tail: ListNode, terminal:ListNode)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        cur = head&lt;br/&gt;        pre = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; cur != terminal:&lt;br/&gt;            &lt;span&gt;# 留下联系方式&lt;/span&gt;&lt;br/&gt;            next = cur.next&lt;br/&gt;            &lt;span&gt;# 修改指针&lt;/span&gt;&lt;br/&gt;            cur.next = pre&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;# 继续往下走&lt;/span&gt;&lt;br/&gt;            pre = cur&lt;br/&gt;            cur = next&lt;br/&gt;         &lt;span&gt;# 反转后的新的头尾节点返回出去&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; tail, head&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信你对反转链表已经有了一定的了解。后面我们还会对这个问题做更详细的讲解，大家先留个印象就好。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;链表的拼接&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家有没有发现链表总喜欢穿来穿去（拼接）的？比如反转链表 II，再比如合并有序链表等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为啥链表总喜欢穿来穿去呢？实际上，这就是链表存在的价值，这就是设计它的初衷呀！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表的价值就在于其&lt;strong&gt;「不必要求物理内存的连续性，以及对插入和删除的友好」&lt;/strong&gt;。这在文章开头的链表和数组的物理结构图就能看出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此链表的题目很多拼接的操作。如果上面我讲的链表基本操作你会了，我相信这难不倒你。除了环，边界 等 。。。^_^。这几个问题我们后面再看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三个注意&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表最容易出错的地方就是我们应该注意的地方。链表最容易出的错 90 % 集中在以下三种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;出现了环，造成死循环。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分不清边界，导致边界条件出错。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;搞不懂递归怎么做&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们一一来看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;环&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;环的考点有两个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;题目就有可能环，让你判断是否有环，以及环的位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;题目链表没环，但是被你操作指针整出环了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们只讨论第二种，而第一种可以用我们后面提到的&lt;strong&gt;「快慢指针算法」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免出现环最简单有效的措施就是画图，如果两个或者几个链表节点构成了环，通过图是很容易看出来的。因此一个简单的&lt;strong&gt;「实操技巧就是先画图，然后对指针的操作都反应在图中」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是链表那么长，我不可能全部画出来呀。其实完全不用，上面提到了链表是递归的数据结构， 很多链表问题天生具有递归性，比如反转链表，因此&lt;strong&gt;「仅仅画出一个子结构就可以了。&lt;strong&gt;「这个知识，我们放在后面的」&lt;/strong&gt;前后序」&lt;/strong&gt;部分讲解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;边界&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人错的是没有考虑边界。一个考虑边界的技巧就是看题目信息。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果题目的头节点可能被移除，那么考虑使用虚拟节点，这样&lt;strong&gt;「头节点就变成了中间节点」&lt;/strong&gt;，就不需要为头节点做特殊判断了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;题目让你返回的不是原本的头节点，而是尾部节点或者其他中间节点，这个时候要注意指针的变化。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上两者部分的具体内容，我们在稍微讲到的虚拟头部分讲解。老规矩，大家留个印象即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;前后序&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ok，是时候填坑了。上面提到了链表结构天生具有递归性，那么使用递归的解法或者递归的思维都会对我们解题有帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 二叉树遍历 部分，我讲了二叉树的三种流行的遍历方法，分别是前序遍历，中序遍历和后序遍历。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前中后序实际上是指的当前节点相对子节点的处理顺序。如果先处理当前节点再处理子节点，那么就是前序。如果先处理左节点，再处理当前节点，最后处理右节点，就是中序遍历。后序遍历自然是最后处理当前节点了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际过程中，我们不会这么扣的这么死。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;traverse&lt;/span&gt;&lt;span&gt;(root)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    print(&lt;span&gt;&#x27;pre&#x27;&lt;/span&gt;)&lt;br/&gt;    traverse(root.left)&lt;br/&gt;    traverse(root.righ)&lt;br/&gt;    print(&lt;span&gt;&#x27;post&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上代码，我们既在&lt;strong&gt;「进入左右节点前」&lt;/strong&gt;有逻辑， 又在&lt;strong&gt;「退出左右节点之后」&lt;/strong&gt;有逻辑。这算什么遍历方式呢？一般意义上，我习惯只看主逻辑的位置，如果你的主逻辑是在后面就是后序遍历，主逻辑在前面就是前序遍历。这个不是重点，对我们解题帮助不大，对我们解题帮助大的是接下来要讲的内容。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;绝大多数的题目都是单链表，而单链表只有一个后继指针。因此只有前序和后序，没有中序遍历。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以上面讲的经典的反转链表来说。如果是前序遍历，我们的代码是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dfs&lt;/span&gt;&lt;span&gt;(head, pre)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; head: &lt;span&gt;return&lt;/span&gt; pre&lt;br/&gt;    next = head.next&lt;br/&gt;    &lt;span&gt;# # 主逻辑（改变指针）在后面&lt;/span&gt;&lt;br/&gt;    head.next = pre&lt;br/&gt;    dfs(next, head)&lt;br/&gt;&lt;br/&gt;dfs(head, &lt;span&gt;None&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续遍历的代码是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dfs&lt;/span&gt;&lt;span&gt;(head)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; head &lt;span&gt;or&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; head.next: &lt;span&gt;return&lt;/span&gt; head&lt;br/&gt;    res = dfs(head.next)&lt;br/&gt;    &lt;span&gt;# 主逻辑（改变指针）在进入后面的节点的后面，也就是递归返回的过程会执行到&lt;/span&gt;&lt;br/&gt;    head.next.next = head&lt;br/&gt;    head.next = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，这两种写法不管是边界，入参，还是代码都不太一样。为什么会有这样的差异呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答这个问题也不难，大家只要记住一个很简单的一句话就好了，那就是&lt;strong&gt;「如果是前序遍历，那么你可以想象前面的链表都处理好了，怎么处理的不用管」&lt;/strong&gt;。相应地&lt;strong&gt;「如果是后续遍历，那么你可以想象后面的链表都处理好了，怎么处理的不用管」&lt;/strong&gt;。这句话的正确性也是毋庸置疑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，是前序遍历的时候，我们应该画的图。大家把注意力集中在中间的框（子结构）就行了，同时注意两点。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前面的已经处理好了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后面的还没处理好&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjz0fCWS6P41vmANyVvEialvKTUhgwIU8sfVq4T2wOl25IiaVVstcUUVJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据此，我们不难写出以下递归代码，代码注释很详细，大家看注释就好了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dfs&lt;/span&gt;&lt;span&gt;(head, pre)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; head: &lt;span&gt;return&lt;/span&gt; pre&lt;br/&gt;    &lt;span&gt;# 留下联系方式（由于后面的都没处理，因此可以通过 head.next 定位到下一个）&lt;/span&gt;&lt;br/&gt;    next = head.next&lt;br/&gt;    &lt;span&gt;# 主逻辑（改变指针）在进入后面节点的前面（由于前面的都已经处理好了，因此不会有环）&lt;/span&gt;&lt;br/&gt;    head.next = pre&lt;br/&gt;    dfs(next, head)&lt;br/&gt;&lt;br/&gt;dfs(head, &lt;span&gt;None&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是后序遍历呢？老规矩，秉承我们的一个原则，&lt;strong&gt;「先画图」&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBj74jdQcdJY6HDIcToM3vJDXHZnELSr84TeCUUQcbDiasZdfe8NhEuHhQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不难看出，我们可以通过 head.next 拿到下一个元素，然后将下一个元素的 next 指向自身来完成反转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用代码表示就是:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;head.next.next = head&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjSiaD5tXJkGu3BYFf88wGchz4XBicgv0ibiax89jSicWRaDpGniaYatSNicpxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画出图之后，是不是很容易看出图中有一个环？现在知道画图的好处了吧？就是这么直观，当你很熟练了，就不需要画了，但是在此之前，请不要偷懒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们需要将 head.next 改为不会造成环的一个值，比如置空。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjFq2Q4YxwRoib7SV77Igib7iaK1Q4hqWeawic0K38Cn4E8fpJabvPETpZBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dfs&lt;/span&gt;&lt;span&gt;(head)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; head &lt;span&gt;or&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; head.next: &lt;span&gt;return&lt;/span&gt; head&lt;br/&gt;    &lt;span&gt;# 不需要留联系方式了，因为我们后面已经走过了，不需走了，现在我们要回去了。&lt;/span&gt;&lt;br/&gt;    res = dfs(head.next)&lt;br/&gt;    &lt;span&gt;# 主逻辑（改变指针）在进入后面的节点的后面，也就是递归返回的过程会执行到&lt;/span&gt;&lt;br/&gt;    head.next.next = head&lt;br/&gt;    &lt;span&gt;# 置空，防止环的产生&lt;/span&gt;&lt;br/&gt;    head.next = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，&lt;strong&gt;「前序遍历很容易改造成迭代，因此推荐大家使用前序遍历」&lt;/strong&gt;。我拿上面的迭代和这里的前序遍历给大家对比一下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjwibkNwfdrxsG09SJ2kMDJ7ekGic4NiaUJL7iboYA8gNdzpu13Gz4XqjzkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么&lt;strong&gt;「前序遍历很容易改造成迭代」&lt;/strong&gt;呢？实际上，这句话我说的不准确，准确地说应该是&lt;strong&gt;「前序遍历容易改成不需要栈的递归，而后续遍历需要借助栈来完成」&lt;/strong&gt;。这也不难理解，由于后续遍历的主逻辑在函数调用栈的弹出过程，而前序遍历则不需要。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这里给大家插播一个写递归的技巧，那就是想象我们已经处理好了一部分数据，并把他们用手挡起来，但是还有一部分等待处理，接下来思考”如何根据已经处理的数据和当前的数据来推导还没有处理的数据“就行了。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四个技巧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上面的考点和注意点，我总结了四个技巧来应对，这都是在平时做题中非常实用的技巧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;虚拟头&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来了解虚拟头的意义之前，先给大家做几个小测验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Q1: 如下代码 ans.next 指向什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ans = ListNode(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;ans.next = head&lt;br/&gt;head = head.next&lt;br/&gt;head = head.next&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A1: 最开始的 head。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Q2：如下代码 ans.next 指向什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ans = ListNode(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;head = ans&lt;br/&gt;head.next = ListNode(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;head.next = ListNode(&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A2: ListNode(4)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;似乎也不难，我们继续看一道题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Q3: 如下代码 ans.next 指向什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ans = ListNode(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;head = ans&lt;br/&gt;head.next = ListNode(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;head = ListNode(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;head.next = ListNode(&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A3: ListNode(3)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果三道题你都答对了，那么恭喜你，这一部分可以跳过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你没有懂也没关系，我这里简单解释一下你就懂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「ans.next 指向什么取决于最后切断 ans.next 指向的地方在哪」&lt;/strong&gt;。比如 Q1，ans.next 指向的是 head，我们假设其指向的内存编号为 &lt;code&gt;9527&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjXJ3MdqLHicNlnc0R7ADc8ZWKAbTOwyAUdX0YzlpHbTQ2EXQGd4Jyuow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后执行 &lt;code&gt;head = head.next&lt;/code&gt; （ans 和 head 被切断联系了），此时的内存图：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;我们假设头节点的 next 指针指向的节点的内存地址为 10200&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjfYjy0obPe9tiaPea1DOdz9fZXicp7CNyZ7icC5yoAgkv10yPiaJ3OdJRFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不难看出，ans 没变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于第二个例子。一开始和上面例子一样，都是指向 9527。而后执行了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;head.next = ListNode(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;head.next = ListNode(&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ans 和 head 又同时指向 ListNode(3) 了。如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjYzdJEHmOHJ0mFuGX3cGRx8JWP1f7K5ssFZmUYgBIoyM5qKiaRxzaaiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;head.next = ListNode(4)&lt;/code&gt; 也是同理。因此最终的指向 ans.next 是 ListNode(4)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看最后一个。前半部分和 Q2 是一样的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ans = ListNode(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;head = ans&lt;br/&gt;head.next = ListNode(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上面的分析，此时 head 和 ans 的 next 都指向 ListNode(3)。关键是下面两行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;head = ListNode(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;head.next = ListNode(&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjb5KiaSefEjZicfU9y6ibwPWwwQy59bgXtia75vhy3FMyH2Nt1QcQVucAPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指向了 &lt;code&gt;head = ListNode(2)&lt;/code&gt; 之后， head 和 ans 的关系就被切断了，&lt;strong&gt;「当前以及之后所有的 head 操作都不会影响到 ans」&lt;/strong&gt;，因此 ans 还指向被切断前的节点，因此 ans.next 输出的是 ListNode(3)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;花了这么大的篇幅讲这个东西的原因就是，指针操作是链表的核心，如果这些基础不懂， 那么就很难做。接下来，我们介绍主角 - 虚拟头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信做过链表的小伙伴都听过这么个名字。为什么它这么好用？它的作用无非就两个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将头节点变成中间节点，简化判断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过在合适的时候断开链接，返回链表的中间节点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我上面提到了链表的三个注意，有一个是边界。头节点是最常见的边界，那如果&lt;strong&gt;「我们用一个虚拟头指向头节点，虚拟头就是新的头节点了，而虚拟头不是题目给的节点，不参与运算，因此不需要特殊判断」&lt;/strong&gt;，虚拟头就是这个作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果题目需要返回链表中间的某个节点呢？实际上也可借助虚拟节点。由于我上面提到的指针的操作，实际上，你可以新建一个虚拟头，然后让虚拟头在恰当的时候（刚好指向需要返回的节点）断开连接，这样我们就可以返回虚拟头的 next 就 ok 了。25. K 个一组翻转链表 就用到了这个技巧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅仅是链表， 二叉树等也经常用到这个技巧。比如我让你返回二叉树的最左下方的节点怎么做？我们也可以利用上面提到的技巧。新建一个虚拟节点，虚拟节点 next 指向当前节点，并跟着一起走，在递归到最左下的时候断开链接，最后返回 虚拟节点的 next 指针即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;快慢指针&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断链表是否有环，以及环的入口都是使用快慢指针即可解决。这种题就是不知道不会，知道了就不容易忘。不多说了，大家可以参考我之前的题解 https://github.com/azl397985856/leetcode/issues/274#issuecomment-573985706 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这个，求链表的交点也是快慢指针，算法也是类似的。不这都属于不知道就难，知道了就容易。且下次写不容易想不到或者出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分大家参考我上面的题解理一下， 写一道题就可以掌握。接下来，我们来看下&lt;strong&gt;「穿针引线」&lt;/strong&gt;大法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外由于链表不支持随机访问，因此如果想要获取数组中间项和倒数第几项等特定元素就需要一些特殊的手段，而这个手段就是快慢指针。比如要找链表中间项就&lt;strong&gt;「搞两个指针，一个大步走（一次走两步），一个小步走（一次走一步）」&lt;/strong&gt;，这样快指针走到头，慢指针刚好在中间。如果要求链表倒数第 2 个，那就&lt;strong&gt;「让快指针先走一步，慢指针再走」&lt;/strong&gt;，这样快指针走到头，慢指针刚好在倒数第二个。这个原理不难理解吧？这种技巧属于&lt;strong&gt;「会了就容易，且不容易忘。不会就很难想出的类型」&lt;/strong&gt;，因此大家学会了拿几道题练一下就可以放下了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;穿针引线&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是链表的第二个考点 - &lt;strong&gt;「拼接链表」&lt;/strong&gt;。我在 25. K 个一组翻转链表，61. 旋转链表 和 92. 反转链表 II都用了这个方法。穿针引线是我自己起的一个名字，起名字的好处就是方便记忆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法通常不是最优解，但是好理解，方便书写，不易出错，推荐新手用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以反转链表为例，只不过这次是&lt;code&gt;反转链表的中间一部分&lt;/code&gt;，那我们该怎么做？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjmq4Kc1PgDuzFOIyKfG9WLgpF4JxRuuLTpaSPwHcibd9yt3Q5vNOxDLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反转前面我们已经讲过了，于是我假设链表已经反转好了，那么如何将反转好的链表拼后去呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjR0iaM5AQGmX7jYJlOicD7pA9JTovibNiczgtbSxw8Zfl18K5VYs70icvlYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想要的效果是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjOOvhQYtictSQ3YCzCiafQQicYw3sBGviaAgXe0iaQlrq6dppq89NUEZ5Hgw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么达到图上的效果呢？我的做法是从做到右给断点编号。如图有两个断点，共涉及到四个节点。于是我给它们依次编号为 a，b，c，d。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 a，d 分别是需要反转的链表部分的前驱和后继（不参与反转），而 b 和 c 是需要反转的部分的头和尾（参与反转）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此除了 cur， 多用两个指针 pre 和 next 即可找到 a，b，c，d。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到后就简单了，直接&lt;strong&gt;「穿针引线」&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a.next = c&lt;br/&gt;b.next = d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjJeibAnKTWHhwvJ3v0YBk1kT8k6mfW7RKO9mWpaHGEQnCyq72RWmfPyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不就好了么？我记得的就有 25 题，61 题 和 92 题都是这么做的，清晰不混乱。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;先穿再排后判空&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是四个技巧的最后一个技巧了。虽然是最后讲，但并不意味着它不重要。相反，它的实操价值很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续回到上面讲的链表反转题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cur = head&lt;br/&gt;pre = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; cur != tail:&lt;br/&gt;    &lt;span&gt;# 留下联系方式&lt;/span&gt;&lt;br/&gt;    next = cur.next&lt;br/&gt;    &lt;span&gt;# 修改指针&lt;/span&gt;&lt;br/&gt;    cur.next = pre&lt;br/&gt;    &lt;span&gt;# 继续往下走&lt;/span&gt;&lt;br/&gt;    pre = cur&lt;br/&gt;    cur = next&lt;br/&gt;&lt;span&gt;# 反转后的新的头尾节点返回出去&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么时候需要判断 next 是否存在，上面两行代码先写哪个呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是这样？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    next = cur.next&lt;br/&gt;    cur.next = pre&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是这样？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    cur.next = pre&lt;br/&gt;    next = cur.next&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;先穿&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我给你的建议是：先穿。这里的穿是修改指针，包括反转链表的修改指针和穿针引线的修改指针。&lt;strong&gt;「先别管顺序，先穿」&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;再排&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;穿完之后，代码的总数已经确定了，无非就是排列组合让代码没有 bug。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此第二步考虑顺序，那上面的两行代码哪个在前？应该是先 next = cur.next ，原因在于后一条语句执行后 cur.next 就变了。由于上面代码的作用是反转，那么其实经过 cur.next = pre 之后链表就断开了，后面的都访问不到了，也就是说此时你&lt;strong&gt;「只能返回头节点这一个节点」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，有假如有十行&lt;strong&gt;「穿」&lt;/strong&gt;的代码，我们很多时候没有必要全考虑。我们&lt;strong&gt;「需要考虑的仅仅是被改变 next 指针的部分」&lt;/strong&gt;。比如 cur.next = pre 的 cur 被改了 next。因此下面用到了 cur.next 的地方就要考虑放哪。其他代码不需要考虑。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span/&gt;后判空&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面的原则类似，穿完之后，代码的总数已经确定了，无非就是看看哪行代码会空指针异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面的技巧一样，我们很多时候没有必要全考虑。我们&lt;strong&gt;「需要考虑的仅仅是被改变 next 指针的部分」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如这样的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; cur:&lt;br/&gt;    cur = cur.next&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们考虑 cur 是否为空呢？很明显不可能，因为 while 条件保证了，因此不需判空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何是这样的代码呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; cur:&lt;br/&gt;    next = cur.next&lt;br/&gt;    n_next = next.next&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上代码有两个 next，第一个不用判空，上面已经讲了。而第二个是需要的，因为 next 可能是 null。如果 next 是 null ，就会引发空指针异常。因此需要修改为类似这样的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; cur:&lt;br/&gt;    next = cur.next&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; next: &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;    n_next = next.next&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我们给大家的四个技巧了。相信有了这四个技巧，写链表题就没那么艰难啦~ ^_^&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;题目推荐&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后推荐几道题给大家，用今天学到的知识解决它们吧~&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;21. 合并两个有序链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;82. 删除排序链表中的重复元素 II&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;83. 删除排序链表中的重复元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;86. 分隔链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;92. 反转链表 II&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;138. 复制带随机指针的链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;141. 环形链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;142. 环形链表 II&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;143. 重排链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;148. 排序链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;206. 反转链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;234. 回文链表&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组和栈从逻辑上没有大的区别，你看基本操作都是差不多的。如果是单链表，我们无法在 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 的时间拿到前驱节点，这也是为什么我们遍历的时候老是维护一个前驱节点的原因。但是本质原因其实是链表的增删操作都依赖前驱节点。这是链表的基本操作，是链表的特性天生决定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有的同学有这样的疑问”考点你只讲了指针的修改和链表拼接，难道说链表就只会这些就够了？那我做的题怎么还需要我会前缀和啥的呢？你是不是坑我呢？“&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我前面说了，所有的数据结构底层都是数组和链表中的一种或两种。而我们这里讲的链表指的是考察链表的基本操作的题目。因此如果题目中需要你使用归并排序去合并链表，那其实归并排序这部分已经不再本文的讨论范围了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，你去力扣或者其他 OJ 翻链表题会发现他们的链表题大都指的是入参是链表，且你需要对链表进行一些操作的题目。再比如树的题目大多数是入参是树，你需要在树上进行搜索的题目。也就是说需要操作树（比如修改树的指针）的题目很少，比如有一道题让你给树增加一个 right 指针，指向同级的右侧指针，如果已经是最右侧了，则指向空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表的基本操作就是增删查，牢记链表的基本操作和复杂度是解决问题的基本。有了这些基本还不够，大家要牢记我的口诀”一个原则，两个考点，三个注意，四个技巧“。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做链表的题，要想入门，无它，唯画图尔。能画出图，并根据图进行操作你就入门了，甭管你写的代码有没有 bug 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而链表的题目核心的考察点只有两个，一个是指针操作，典型的就是反转。另外一个是链表的拼接。这两个既是链表的精髓，也是主要考点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了考点肯定不够，我们写代码哪些地方容易犯错？要注意什么？这里我列举了三个容易犯错的地方，分别是环，边界和前后序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中环指的是节点之间的相互引用，环的题目如果题目本身就有环， 90 % 双指针可以解决，如果本身没有环，那么环就是我们操作指针的时候留下的。如何解决出现环的问题？那就是&lt;strong&gt;「画图，然后聚焦子结构，忽略其他信息。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了环，另外一个容易犯错的地方往往是边界的条件， 而边界这块链表头的判断又是一个大头。克服这点，我们需要认真读题，看题目的要求以及返回值，另外一个很有用的技巧是虚拟节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家用递归去解链表的题， 一定要注意自己写的是前序还是后序。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果是前序，那么&lt;strong&gt;「只思考子结构即可，前面的已经处理好了，怎么处理的，不用管。非要问，那就是同样方法。后面的也不需考虑如何处理，非要问，那就是用同样方法」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是后续，那么&lt;strong&gt;「只思考子结构即可，后面的已经处理好了，怎么处理的，不用管。非要问，那就是同样方法。前面的不需考虑如何处理。非要问，那就是用同样方法」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想递归和迭代都写， 我推荐你用前序遍历。因为前序遍历容易改成不用栈的递归。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是链表专题的全部内容了。大家对此有何看法，欢迎给我留言，我有时间都会一一查看回答。更多算法套路可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。目前已经 37K star 啦。大家也可以关注我的公众号《力扣加加》带你啃下算法这块硬骨头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我整理的 1000 多页的电子书已经开发下载了，大家可以去我的公众号《力扣加加》后台回复电子书获取。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjq6qANsfUxlzaibhM61Ucgiciaibc6DiblKEqhzPGc9QP1f46KnjGdT0rx4w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/liaT5dytkaTdIIUUoh8P2v7gW2tiahdUBjLkswNzuZXXWf8ibuGLnRAgoQJW8koNLG6GfYKgkjk60HzXpxCU3d96A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;链表标签: &lt;span&gt;https://leetcode-cn.com/tag/linked-list/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>