<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb21a54e3d1e2c47c9ff0efe661df0c8</guid>
<title>MySQL 的 join 功能弱爆了？</title>
<link>https://toutiao.io/k/031qbdy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;点击上方&quot;&lt;span&gt;程序员历小冰&lt;/span&gt;&quot;，选择“置顶或者星标”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   你的关注意义重大!&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n868&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大家好，我是历小冰，今天我们来学习和吐槽一下 MySQL 的 Join 功能。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n870&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;关于MySQL 的 join，大家一定了解过很多它的“轶事趣闻”，比如两表 join 要小表驱动大表，阿里开发者规范禁止三张表以上的 join 操作，MySQL 的 join 功能弱爆了等等。这些规范或者言论亦真亦假，时对时错，需要大家自己对 join 有深入的了解后才能清楚地理解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n871&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们就来全面的了解一下 MySQL 的 join 操作。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n873&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n875&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在日常数据库查询时，我们经常要对多表进行连表操作来一次性获得多个表合并后的数据，这是就要使用到数据库的 join 语法。join 是在数据领域中十分常见的将两个数据集进行合并的操作，如果大家了解的多的话，会发现 MySQL，Oracle，PostgreSQL 和 Spark 都支持该操作。本篇文章的主角是 MySQL，下文没有特别说明的话，就是以 MySQL 的 join 为主语。而 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Oracle ，PostgreSQL 和 Spark 则可以算做将其吊打的大boss，其对 join 的算法优化和实现方式都要优于 MySQL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n876&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n877&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MySQL 的 join 有诸多规则，可能稍有不慎，可能一个不好的 join 语句不仅会导致对某一张表的全表查询，还有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;可能会影响数据库的缓存，导致大部分热点数据都被替换出去，拖累整个数据库性能。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n878&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n879&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;所以，业界针对 MySQL 的 join 总结了很多规范或者原则，比如说小表驱动大表和禁止三张表以上的 join 操作。下面我们会依次介绍 MySQL join 的算法，和 Oracle 和 Spark 的 join 实现对比，并在其中穿插解答为什么会形成上述的规范或者原则。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n880&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n881&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;对于 join 操作的实现，大概有 Nested Loop Join (循环嵌套连接)，Hash Join(散列连接) 和 Sort Merge Join(排序归并连接) 三种较为常见的算法&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;，它们各有优缺点和适用条件，接下来我们会依次来介绍。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n886&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;MySQL 中的 Nested Loop Join 实现&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n887&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Nested Loop Join 是扫描驱动表，每读出一条记录，就根据 join 的关联字段上的索引去被驱动表中查询对应数据。它适用于被连接的数据子集较小的场景，它也是 MySQL join 的唯一算法实现，关于它的细节我们接下来会详细讲解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n888&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MySQL 中有两个 Nested Loop Join 算法的变种，分别是 Index Nested-Loop Join 和 Block Nested-Loop Join。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n889&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Index Nested-Loop Join 算法&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n890&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们先来初始化一下相关的表结构和数据&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n892&quot; mdtype=&quot;fences&quot;&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;CREATE TABLE `t1` (&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `id` int(11) NOT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `a` int(11) DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  `b` int(11) DEFAULT NULL,&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  KEY `a` (`a`)&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;) ENGINE=InnoDB;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;delimiter ;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 定义存储过程来初始化t1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;create procedure init_data()&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;begin&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  declare i int;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  set i=1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  while(i&amp;lt;=10000)do&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    insert into t1 values(i, i, i);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    set i=i+1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;  end while;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;end;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;delimiter ;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 调用存储过来来初始化t1&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;call init_data();&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;# 创建并初始化t2&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;create table t2 like t1;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;insert into t2 (select * from t1 where id&amp;lt;=500)&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n893&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;有上述命令可知，这两个表都有一个主键索引 id 和一个索引 a，字段 b 上无索引。存储过程 init_data 往表 t1 里插入了 10000 行数据，在表 t2 里插入的是 500 行数据。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1079&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n894&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;为了避免 MySQL 优化器会自行选择表作为驱动表，影响分析 SQL 语句的执行过程，我们直接使用 straight_join 来让 MySQL 使用固定的连接表顺序进行查询，如下语句中，t1是驱动表，t2是被驱动表。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n895&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select * from t2 straight_join t1 on (t2.a=t1.a);&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用我们之前&lt;a spellcheck=&quot;false&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;amp;mid=2247484242&amp;amp;idx=1&amp;amp;sn=119c2972357d57b6575fb790f8a25a4d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;文章&lt;/span&gt;&lt;/a&gt;介绍的 explain 命令查看一下该语句的执行计划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNMUcEv1V6eIjpqaW4icDC63FvAiabuGyzgO8337XeTs3Sa65QuGK9uzHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n898&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;从上图可以看到，t1 表上的 a 字段是由索引的，join 过程中使用了该索引，因此该 SQL 语句的执行流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这个流程我们就称之为 Index Nested-Loop Join，简称 NLJ，它对应的流程图如下所示。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n909&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;http://cdn.remcarpediem.net/2020-11-10-145533.png&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNb59c86YWzMkWQVz1TlE7MJnolPNGicibyRKuf1bT1yWKZFlmtVMxSgOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6940418679549114&quot; data-w=&quot;621&quot;/&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n910&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要注意的是，在第二步中，根据 a 字段去表t1中查询时，使用了索引，所以每次扫描只会扫描一行(从explain结果得出，根据不同的案例场景而变化)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n911&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n912&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;假设驱动表的行数是N，被驱动表的行数是 M。因为在这个 join 语句执行过程中，驱动表是走全表扫描，而被驱动表则使用了索引，并且驱动表中的每一行数据都要去被驱动表中进行索引查询，所以整个 join 过程的近似复杂度是 N&lt;em&gt;2&lt;/em&gt;log2M。显然，N 对扫描行数的影响更大，因此这种情况下应该让小表来做驱动表。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n913&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n914&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然，这一切的前提是 join 的关联字段是 a，并且 t1 表的 a 字段上有索引。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n915&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果没有索引时，再用上图的执行流程时，每次到 t1 去匹配的时候，就要做一次全表扫描。这也导致整个过程的时间复杂度编程了 N * M，这是不可接受的。所以，当没有索引时，MySQL 使用 Block Nested-Loop Join 算法。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n917&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Block Nested-Loop Join&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n919&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Block Nested-Loop Join的算法，简称 BNL，它是 MySQL 在被驱动表上无可用索引时使用的 join 算法，其具体流程如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n926&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;比如下面这条 SQL&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n927&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select * from t2 straight_join t1 on (t2.b=t1.b);&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n928&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这条语句的 explain 结果如下所示。可以看出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.30078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNMlI7EH23UYB3ACyuR4UOmHfvfMkC9cmxf59qlR238Hp6L9Ql9mmzAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n929&quot; mdtype=&quot;paragraph&quot;&gt;可以看出，这次 join 过程对 t1 和 t2 都做了一次全表扫描，并且将表 t2 中的 500 条数据全部放入内存 join_buffer 中，并且对于表 t1 中的每一行数据，都要去 join_buffer 中遍历一遍，都要做 500 次对比，所以一共要进行 500 * 10000 次内存对比操作，具体流程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8668885191347754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNe5TjXlIrqNqubPg6jU2rbKuIUZUibf3LHgH77JFbmzMATlJQAia6x7TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n933&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;主要注意的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;第一步中，并不是将表 t2 中的所有数据都放入 join_buffer，而是根据具体的 SQL 语句，而放入不同行的数据和不同的字段&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;比如下面这条 join 语句则只会将表 t2 中符合 b &amp;gt;= 100 的数据的 b 字段存入 join_buffer。&lt;/span&gt;&lt;/p&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;&quot; cid=&quot;n934&quot; mdtype=&quot;fences&quot;&gt;&lt;span role=&quot;presentation&quot;&gt;select t2.b,t1.b from t2 straight_join t1 on (t2.b=t1.b) where t2.b &amp;gt;= 100;&lt;/span&gt;&lt;/pre&gt;&lt;p cid=&quot;n935&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;join_buffer 并不是无限大的，由 join_buffer_size 控制，默认值为 256K。当要存入的数据过大时，就只有分段存储了，整个执行过程就变成了：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n936&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n938&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;扫描表 t2，将符合条件的数据行存入 join_buffer，因为其大小有限，存到100行时满了，则执行第二步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n940&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;扫描表 t1，每取出一行数据，就跟 join_buffer 中的数据进行对比，满足 join 条件的，则放入结果集；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n942&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;清空 join_buffer；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n944&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;再次执行第一步，直到全部数据被扫描完，由于 t2 表中有 500行数据，所以一共重复了 5次&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n945&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这个流程体现了该算法名称中 Block 的由来，分块去执行 join 操作。因为表 t2 的数据被分成了 5 次存入 join_buffer，导致表 t1 要被全表扫描 5次。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n946&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n947&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n949&quot; mdtype=&quot;table_cell&quot;&gt;全部存入&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n950&quot; mdtype=&quot;table_cell&quot;&gt;分5次存入&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n951&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n952&quot; mdtype=&quot;table_cell&quot;&gt;内存操作&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n953&quot; mdtype=&quot;table_cell&quot;&gt;10000 * 500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n954&quot; mdtype=&quot;table_cell&quot;&gt;10000 * (100 * 5)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n955&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n956&quot; mdtype=&quot;table_cell&quot;&gt;扫描行数&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n957&quot; mdtype=&quot;table_cell&quot;&gt;10000 + 500&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n958&quot; mdtype=&quot;table_cell&quot;&gt;10000 *  5 + 500&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n963&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;如上所示，和表数据可以全部存入 join_buffer 相比，内存判断的次数没有变化，都是两张表行数的乘积，也就是 10000 * 500，但是被驱动表会被多次扫描，每多存入一次，被驱动表就要扫描一遍，影响了最终的执行效率。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n964&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n965&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于上述两种算法，我们可以得出下面的结论，这也是网上大多数对 MySQL join 语句的规范。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n971&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n972&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;因为上述两个 join 算法的时间复杂度&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;至少&lt;/span&gt;&lt;/strong&gt;也和涉及表的行数成一阶关系，并且要花费大量的内存空间，所以阿里开发者规范所说的严格禁止三张表以上的 join 操作也是可以理解的了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n973&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但是上述这两个算法只是 join 的算法之一，还有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;更加高效的 join 算法，比如 Hash Join 和 Sorted Merged join。可惜这两个算法 MySQL 的主流版本中目前都不提供，而 Oracle ，PostgreSQL 和 Spark 则都支持，这也是网上吐槽 MySQL 弱爆了的原因&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;(MySQL 8.0 版本支持了 Hash join，但是8.0目前还不是主流版本)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n974&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;其实阿里开发者规范也是在从 Oracle 迁移到 MySQL 时，因为 MySQL 的 join 操作性能太差而定下的禁止三张表以上的 join 操作规定的 。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n975&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Hash Join 算法&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n976&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Hash Join 是扫描驱动表，利用 join 的关联字段在内存中建立散列表，然后扫描被驱动表，每读出一行数据，并从散列表中找到与之对应数据。它是大数据集连接操时的常用方式，适用于驱动表的数据量较小，可以放入内存的场景，它对于&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;没有索引的大表&lt;/span&gt;&lt;/strong&gt;和并行查询的场景下能够提供最好的性能。可惜它只适用于等值连接的场景，比如 on a.id = where b.a_id。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1083&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;还是上述两张表 join 的语句，其执行过程如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8668885191347754&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNicswJwpEaHDncHQsERVxIrXFHb6CQtkY6IDIudygG9oAWy5ibRoZU4sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n977&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;可以看出，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;该算法和 Block Nested-Loop Join 有类似之处，只不过是将无序的 Join Buffer 改为了散列表 hash table，从而让数据匹配不再需要将 join buffer 中的数据全部遍历一遍，而是直接通过 hash，以接近 O(1) 的时间复杂度获得匹配的行&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，这极大地提高了两张表的 join 速度。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不过由于 hash 的特性，该算法只能适用于等值连接的场景，其他的连接场景均无法使用该算法。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n978&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Sorted Merge Join 算法&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n979&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Sort Merge Join 则是先根据 join 的关联字段将两张表排序(如果已经排序好了，比如字段上有索引则不需要再排序)，然后在对两张表进行一次归并操作。如果两表已经被排过序，在执行排序合并连接时不需要再排序了，这时Merge Join的性能会优于Hash Join。Merge Join可适于于非等值Join（&amp;gt;，&amp;lt;，&amp;gt;=，&amp;lt;=，但是不包含!=，也即&amp;lt;&amp;gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;需要注意的是，如果连接的字段已经有索引，也就说已经排好序的话，可以直接进行归并操作，但是如果连接的字段没有索引的话，则它的执行过程如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5522388059701493&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtcPKcRIjNYP0dkic8Yu9crGNuUTmPgYY5IRfnuNEBesMVktGMzHwHvNEjJm35FB3K41zlF1LGqgdtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n1119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Sorted Merge Join 算法的主要时间消耗在于对两个表的排序操作，所以如果两个表已经按照连接字段排序过了，该算法甚至比 Hash Join 算法还要快。在一边情况下，该算法是比 Nested Loop Join 算法要快的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n980&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;下面，我们来总结一下上述三种算法的区别和优缺点。&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n982&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n983&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n985&quot; mdtype=&quot;table_cell&quot;&gt;Nested Loop Join&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n986&quot; mdtype=&quot;table_cell&quot;&gt;Hash Join&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span cid=&quot;n987&quot; mdtype=&quot;table_cell&quot;&gt;Sorted Merge Join&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n988&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n989&quot; mdtype=&quot;table_cell&quot;&gt;连接条件&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n990&quot; mdtype=&quot;table_cell&quot;&gt;适用于任何条件&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n991&quot; mdtype=&quot;table_cell&quot;&gt;只适用于等值连接（=）&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n992&quot; mdtype=&quot;table_cell&quot;&gt;等值或非等值连接(&amp;gt;，&amp;lt;，=，&amp;gt;=，&amp;lt;=)，‘&amp;lt;&amp;gt;’除外&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n993&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n994&quot; mdtype=&quot;table_cell&quot;&gt;主要消耗资源&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n995&quot; mdtype=&quot;table_cell&quot;&gt;CPU、磁盘I/O&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n996&quot; mdtype=&quot;table_cell&quot;&gt;内存、临时空间&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n997&quot; mdtype=&quot;table_cell&quot;&gt;内存、临时空间&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n998&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n999&quot; mdtype=&quot;table_cell&quot;&gt;特点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1000&quot; mdtype=&quot;table_cell&quot;&gt;当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1001&quot; mdtype=&quot;table_cell&quot;&gt;当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。通常比 Merge Join 快。在数据仓库环境下，如果表的纪录数多，效率高&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1002&quot; mdtype=&quot;table_cell&quot;&gt;当缺乏索引或者索引条件模糊时，Sort Merge Join 比 Nested Loop 有效。当连接字段有索引或者提前排好序时，比 hash join 快，并且支持更多的连接条件&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1003&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1004&quot; mdtype=&quot;table_cell&quot;&gt;缺点&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1005&quot; mdtype=&quot;table_cell&quot;&gt;无索引或者表记录多时效率低&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1006&quot; mdtype=&quot;table_cell&quot;&gt;建立哈希表需要大量内存，第一次的结果返回较慢&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1007&quot; mdtype=&quot;table_cell&quot;&gt;所有的表都需要排序。它为最优化的吞吐量而设计，并且在结果没有全部找到前不返回数据&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n1008&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span cid=&quot;n1009&quot; mdtype=&quot;table_cell&quot;&gt;需要索引&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1010&quot; mdtype=&quot;table_cell&quot;&gt;是(没有索引效率太差)&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1011&quot; mdtype=&quot;table_cell&quot;&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span cid=&quot;n1012&quot; mdtype=&quot;table_cell&quot;&gt;否&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 cid=&quot;n1020&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;对于 Join 操作的理解&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n1022&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;讲完了 Join 相关的算法，我们这里也聊一聊对于 join 操作的业务理解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1023&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在业务不复杂的情况下，大多数join并不是无可替代。比如订单记录里一般只有订单用户的 user_id，返回信息时需要取得用户姓名，可能的实现方案有如下几种：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n1024&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1026&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一次数据库操作，使用  join 操作，订单表和用户表进行 join，连同用户名一起返回；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1028&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;两次数据库操作，分两次查询，第一次获得订单信息和 user_id，第二次根据 user_id 取姓名，使用代码程序进行信息合并；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1030&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使用冗余用户名称或者从 ES 等非关系数据库中读取。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n1036&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上述方案都能解决数据聚合的问题，而且基于程序代码来处理，比数据库 join 更容易调试和优化，比如取用户姓名不从数据库中取，而是先从缓存中查找。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1043&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n1045&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然， join 操作也不是一无是处，所以技术都有其使用场景，&lt;/span&gt;&lt;span&gt;上边这些方案或者规则都是互联网开发团队总结出来的，适用于高并发、轻写重读、分布式、业务逻辑简单的情况，这些场景一般对数据的一致性要求都不高，甚至允许脏读&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1046&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但是，&lt;/span&gt;&lt;span&gt;在金融银行或者财务等企业应用场景，join 操作则是不可或缺的&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;，这些应用一般都是低并发、频繁复杂数据写入、CPU密集而非IO密集，主要业务逻辑通过数据库处理甚至包含大量存储过程、对一致性与完整性要求很高的系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-关注我&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5075921908893709&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9QbuglRCMtehL5KdOC0Uib7CdHkxwGibQdibjs4kC3FpEO9ehCCjHwFa1ZSS8QoEgb9AtomP8cDZmz8jC1gR8qvzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5b556afc497eb90a4c3f5708211d86f0</guid>
<title>小团队如何落地敏捷开发</title>
<link>https://toutiao.io/k/hg0jmdy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;_2rhmJa&quot;&gt;&lt;h1&gt;小团队如何落地敏捷开发&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;You can&#x27;t manage what you don&#x27;t measure. - Peter Drucker&lt;/p&gt;
&lt;p&gt;你如果无法度量它，就无法管理它。&lt;/p&gt;
&lt;p&gt;这是现代管理学之父，彼得·德鲁克的一句名言。项目管理、敏捷开发的前提，还是需要把数据串起来，进行可视化、数据化，这样才能看到它，管理它。&lt;/p&gt;
&lt;p&gt;本文将以公司SaaS产品为例，介绍下“小团队”是如何进行敏捷研发的落地的。&lt;/p&gt;
&lt;h1&gt;为什么要实施&lt;/h1&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;需求的进展不透明，不知道现在到哪里了&lt;/li&gt;
&lt;li&gt;需求延期发布成为了家常便饭，不知道什么时候会发布上线&lt;/li&gt;
&lt;li&gt;需求发布上线后，心里总是忐忑不安，不知道什么时候会出现问题和故障&lt;/li&gt;
&lt;li&gt;团队沟通成本太高，经常性出现RD、FE、QA、PM信息不一致&lt;/li&gt;
&lt;li&gt;需求插入随意、频繁，不计成本&lt;/li&gt;
&lt;li&gt;不清楚，研发团队的工作量，是正常、超负荷、还是有人不饱和&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在互联网初创公司里，需求和有限的资源，永远是矛盾命题，如何在矛盾中寻找平衡，把有限的资源专注于符合公司战略的需求，保持团队的节奏和良好的情绪，就是要实施敏捷管理的痛点，也是我们为什么要实施，敏捷管理也可以很好的回答上面出现的各种问题，给出答案。&lt;/p&gt;
&lt;h1&gt;使用的工具&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;下面是我们所使用的工具，Confluence主要是知识库和文档的汇集，JIRA是项目管理工具和BUG管理工具，下面是之前写的如何搭建这些工具的文章，大家可以参考&lt;/p&gt;
&lt;h2&gt;✔️Atlassian Confluence&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bda2638fdbc2&quot; target=&quot;_blank&quot;&gt;创业公司基础设施如何搭建（三） -- Confluence（Docker版本）&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;✔️Atlassian Jira&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/093cf14361ed&quot; target=&quot;_blank&quot;&gt;创业公司基础设施如何搭建（四） -- Jira（Docker版本）&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;如何做好这件事情&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;需求评审 ➡️ 设计评审 ➡️ 研发实现 ➡️ 测试 ➡️ 验收 ➡️ 发布 ➡️ 后评估&lt;/p&gt;
&lt;p&gt;为了让产品和研发过程可视化，更加可控，信息互通，我们采用&lt;strong&gt;&lt;em&gt;4个看板&lt;/em&gt;&lt;/strong&gt;模型进行敏捷管理实践，看板名称和功能如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;公开需求看板（Kanban Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;通过「看板」建立一个公开需求池，向跨部门成员广泛收集需求，一切市场反馈及时传递到位。看板类型为Kanban Board。&lt;/p&gt;
&lt;br/&gt;

&lt;blockquote&gt;
&lt;p&gt;需求看板（Kanban Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;为需求生命周期搭建流程，按「Backlog - 评审 - 排期 - 设计 - 开发 - 发布」设立多个阶段，需求流转可视化。&lt;/p&gt;
&lt;br/&gt;

&lt;blockquote&gt;
&lt;p&gt;任务效能看板（Scrum Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;为需求预设好发版时间，所有人都可以及时预知逾期风险；产品、开发和需求提出者随时发起沟通，及时同步需求变化或者开发进展。&lt;/p&gt;
&lt;br/&gt;

&lt;blockquote&gt;
&lt;p&gt;BUG看板（Kanban Board）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;通过看板查询，迭代中的各种类型的BUG数量情况，清楚明了。&lt;/p&gt;
&lt;br/&gt;

&lt;h1&gt;公开需求管理&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;公司属于教育类SaaS，其公开需求主要来源有下面几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重要客户（学校）&lt;/li&gt;
&lt;li&gt;用户日常使用反馈（教师、学生、家长）&lt;/li&gt;
&lt;li&gt;销售渠道&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;甄别和过滤伪需求和次要或者不符合战略的需求，在这里进行，但是“业务方”提出的众多的需求如何管理，也是一件头疼的事情，这里主要流程发生有下列几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户使用体验  ➡️ 客户成功同学  ➡️ 记录问题  ➡️ 反馈处理结果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;大客户需求&lt;/strong&gt;  &lt;strong&gt;➡️ 客户成功同学  ➡️ 记录问题  ➡️ 反馈处理结果&lt;/strong&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户成功同学、销售同学或者其他干系人，都可以在这个看板内，提交原始需求问题，产品同学会过滤、调研，转化为产品需求，到产品需求池内，下面是&lt;strong&gt;&lt;em&gt;公开需求看板&lt;/em&gt;&lt;/strong&gt;，卡片的内容主要包含了：需求描述、问题类型、解决状态、经办人&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;判断价值很低或者肯定不会做的需求，直接拖到已完成&lt;/li&gt;
&lt;li&gt;判断有一定价值或需要在分析的需求，拖到调研讨论，最终确定后，再拖到已完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;产品研发需求管理&lt;/h1&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;需求分类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;产品研发内部，我们把需求分成2类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品需求：PM提出的迭代、紧急、日常类需求&lt;/li&gt;
&lt;li&gt;技术需求：研发内部为了稳定性、扩展性、维护性而进行的技术重构类需求&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;需求等级&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;古语云：师出有名，需求的提出也是如此，为了让研发同学知道需求的重要和紧急程度，需求等级划分是特别需要的一件事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产品需求等级划分&lt;/p&gt;
&lt;p&gt;P0：紧急任务，必须穷尽所能，最短时间完成；可以调人支援，可以停止其他项目，需要加班&lt;/p&gt;
&lt;p&gt;P1：非常重要任务，有Deadline，并且不可以Delay；如遇到P0，那么就需要加班保证P1的Deadline&lt;/p&gt;
&lt;p&gt;P2：重要、有影响力的任务，有Deadline，如遇到P0和P1，可以顺延（应该是大部分任务）&lt;/p&gt;
&lt;p&gt;P3：锦上添花的正常任务，优先级最低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术需求等级划分&lt;/p&gt;
&lt;p&gt;T0：重大性能和漏洞，需要加班加点进行修复&lt;/p&gt;
&lt;p&gt;T1：扩展性和性能风险问题，一般是单独任务进行修复&lt;/p&gt;
&lt;p&gt;T2：设计或者一般性能缺陷，一般是随着迭代进行相关改进&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;产品需求管理（需求看板）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;PM和研发同学，通过PRD的方式进行沟通和交流，研发同学最终也是通过PRD进行开发、测试工作，所以第一步是需要创建PRD，PRD的管理方式采用相对灵活的方式，PM写PRD的工具有的是蓝湖，有的墨刀，我们这里为了统一归档，在Confluence做了归档的统一管理（PRD的详细链接可以是任何工具的链接）， 在Confluence创建时选择模板创建，见下图：&lt;/p&gt;
&lt;br/&gt;


&lt;p&gt;主要包含了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;技术需求管理（需求看板）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类似数据结构的变更、技术架构的改进，比如：更换配置中心为Apollo，这类需要简称技术需求，其数据显示和看板功能，和产品需求基本一致，也显示在&lt;strong&gt;&lt;em&gt;需求看板&lt;/em&gt;&lt;/strong&gt;内，看板如下：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;h1&gt;技术任务管理（任务效能看板）&lt;/h1&gt;
&lt;p&gt;这个阶段，主要是从需求阶段进入到了研发阶段，这个阶段主要包含如下类型的任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发任务：RD、FE&lt;/li&gt;
&lt;li&gt;开发自测：RD、FE&lt;/li&gt;
&lt;li&gt;测试用例编写：QA&lt;/li&gt;
&lt;li&gt;测试用例执行：QA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术任务类型的问题，主要来源于2个方面&lt;/p&gt;

&lt;p&gt;对于此类任务管理，我们使用的看板是&lt;strong&gt;&lt;em&gt;任务效能看板&lt;/em&gt;&lt;/strong&gt;。在开始之前，我们需要在Backlog内，拖动需要进行迭代的技术需求或产品需求，如下图：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;p&gt;然后，以产品需求和技术需求为父任务，在&lt;strong&gt;&lt;em&gt;需求看板&lt;/em&gt;&lt;/strong&gt;内，创建子任务，界面如下：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;p&gt;创建好后，可以查看父子任务详情，并有工作量体现&lt;/p&gt;
&lt;br/&gt;

&lt;p&gt;点击开始Sprint，并设置好时间，如下图：&lt;/p&gt;
&lt;br/&gt;

&lt;p&gt;RD &amp;amp; QA &amp;amp; FE，在每天下班前，填写其任务的工作量即可达到任务工作量跟踪的效果，如下图：&lt;/p&gt;
&lt;br/&gt;

&lt;h1&gt;测试BUG管理（BUG看板）&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;在Sprint中产生的BUG都会显示在&lt;strong&gt;&lt;em&gt;BUG看板&lt;/em&gt;&lt;/strong&gt;中，工作流主要是打开 ➡️ 处理中 ➡️ 已解决 ➡️  已关闭，如下图：&lt;br/&gt;
&lt;/p&gt;&lt;p/&gt;
&lt;p&gt;我们所采用的BUG类的问题类型有以下几种：&lt;/p&gt;

&lt;h1&gt;小结&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;需求和效能的生命周期管理，这里仅仅是按照目前产品和团队的需求和阶段，规定了一些适合我们的方法，这个周期管理，还是需要随着人员和阶段的不同而进行不断的改造和演进的，下面是我们在JIRA和Confluence使用的一些核心流程和方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;4个看板&lt;/p&gt;
&lt;p&gt;公开需求看板：处理市场、销售前端部门提出的“大客户需求”和“用户使用体验问题”&lt;/p&gt;
&lt;p&gt;需求看板：主要是管理技术需求和产品需求&lt;/p&gt;
&lt;p&gt;任务效能看板：主要是管理开发阶段，RD &amp;amp; FE &amp;amp; QA的任务和工作量，跟踪其任务合理性&lt;/p&gt;
&lt;p&gt;BUG看板：主要是管理迭代内产生的5类BUG问题，功能优化 &amp;amp; 功能错误 &amp;amp; 界面优化 &amp;amp; 性能问题 &amp;amp; 安全相关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2个模板&lt;/p&gt;
&lt;p&gt;产品需求模板：产品需求的管理&lt;/p&gt;
&lt;p&gt;测试报告模块：迭代后，针对BUG和其他问题，进行的测试相关的总结&lt;/p&gt;
&lt;p&gt;目前，敏捷相关的管理，这个阶段也仅仅是做了一小部分，还有很多实践方法，在后续的变化中，会加入和实施&lt;/p&gt;
&lt;p&gt;敏捷管理是为了快速、稳定的交付产品而服务的，切忌不要为了追求敏捷工具的使用而耽误了实际要达成的目标。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>22a3e160411ab16611e0df4d96388b02</guid>
<title>80%人都理解错误的 Event Loop</title>
<link>https://toutiao.io/k/58l8j37</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;/&gt; 前言 🎤&lt;/h2&gt;
&lt;p&gt;本文的目的在于，一次性推翻80%人构建好的关于Event Loop的知识体系和一次性的完整的理解Nodejs(13以上)和浏览器中的Event Loop。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;h2 id=&quot;划分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#划分&quot;/&gt; 划分&lt;/h2&gt;
&lt;p&gt;首先进行一下基础概念的划分。&lt;br/&gt;
Node下特有的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immediate&lt;/li&gt;
&lt;li&gt;process.nextTick&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器中特有的:🈚️&lt;/p&gt;
&lt;p&gt;双方共有的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;queueMicroTask (nodejs &amp;gt; v11)&lt;/li&gt;
&lt;li&gt;setTimeout&lt;/li&gt;
&lt;li&gt;setInterval&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;宏任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#宏任务&quot;/&gt; 宏任务&lt;/h3&gt;
&lt;p&gt;这里补充一下宏任务&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Browser&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;setTimeout&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setInterval&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setImmediate&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mouseover(之类的事件)&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Web API大部分异步返回方法(XHR,fetch)&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;逗知识：其实setTimeout和setInterval也属于Web API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;宏任务注意️️️️️浏览器中&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#宏任务注意️️️️️浏览器中&quot;/&gt; 宏任务：注意⚠️⚠️⚠️⚠️⚠️(浏览器中)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;和&lt;code&gt;render&lt;/code&gt;不为宏任务，也不为微任务。他们两个的触发时机在宏任务和微任务之外。&lt;br/&gt;
&lt;code&gt;requestAnimationFrame&lt;/code&gt;的触发时机在&lt;code&gt;render&lt;/code&gt;之前。而&lt;code&gt;render&lt;/code&gt;的触发时机在&lt;strong&gt;所有微任务处理结束&lt;/strong&gt;之后。&lt;br/&gt;
但是他们的触发顺序为&lt;code&gt;microTask-&amp;gt;requestAnimationFrame-&amp;gt;render&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;requestAnimationFrame(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;animation&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;animation&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;微任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微任务&quot;/&gt; 微任务&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Browser&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Promise.then catch finally&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MutationObserver&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;queueMicrotask&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;微任务注意️️️️️&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微任务注意️️️️️&quot;/&gt; 微任务：注意⚠️⚠️⚠️⚠️⚠️&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;process.nextTick&lt;/code&gt;不是微任务&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;process.nextTick(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;i am not micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;i am not micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果以上两个注意，都让你原有的知识大厦倾倒，那么请继续往下看，看完后你将会得到一切的答案。&lt;/p&gt;
&lt;h2 id=&quot;nodejs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#nodejs&quot;/&gt; Nodejs&lt;/h2&gt;
&lt;p&gt;先看官方定义&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-14-11-56.png&quot; class=&quot;&quot;/&gt;
&lt;blockquote&gt;
&lt;p&gt;阶段概述&lt;br/&gt;
定时器：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。&lt;br/&gt;
待定回调：执行延迟到下一个循环迭代的 I/O 回调。&lt;br/&gt;
idle, prepare：仅系统内部使用。&lt;br/&gt;
轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。&lt;br/&gt;
检测：setImmediate() 回调函数在这里执行。&lt;br/&gt;
关闭的回调函数：一些关闭的回调函数，如：socket.on(‘close’, …)。&lt;br/&gt;
在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说就是我都不知道他在说什么，😄。&lt;br/&gt;
所以我特意找了一张比较容易看懂的图，来简单的概括一下这些学术语言。&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-13-00-10.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;图片来自互联网&lt;/p&gt;
&lt;p&gt;细心的同学已经看出来了，在图片的中间的红色区域写着&lt;code&gt;process.nextTick&lt;/code&gt;和&lt;code&gt;microTasks&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;第一个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一个重点&quot;/&gt; 第一个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在Node中，nextTick和microTask会在每一个阶段执行结束后被立刻执行。&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他们不属于任何阶段，但是他们又属于任何阶段 ——Box&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的来说，在Node中，每一个处理阶段结束，都会执行并清空&lt;code&gt;nextTick&lt;/code&gt;和&lt;code&gt;microTask&lt;/code&gt;的任务。&lt;br/&gt;
而Node中，分为四个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setTimeout和setInterval的到期回调执行阶段&lt;/li&gt;
&lt;li&gt;IO轮询阶段&lt;/li&gt;
&lt;li&gt;处理setImmediate的回调阶段&lt;/li&gt;
&lt;li&gt;处理某些关闭句柄的回掉阶段&lt;br/&gt;
反复执行。&lt;br/&gt;
所以说，在这个四个阶段执行间隔中，只要出现了任何&lt;code&gt;nextTick&lt;/code&gt;或者&lt;code&gt;microTask&lt;/code&gt;都会被执行知道清空&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第二个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第二个重点&quot;/&gt; 第二个重点&lt;/h3&gt;
&lt;p&gt;先说重点然后看代码：&lt;strong&gt;在处理nextTick和microTask时，会一直循环直到两个任务队列清空，如果你在他们的逻辑中循环创建了新的任务，那么将无法离开这个阶段&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// flag 1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    process.nextTick(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;next timeout&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; loop = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;/&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        process.nextTick(loop)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    process.nextTick(loop)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// flag 2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; micro = &lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{queueMicrotask(micro)}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    queueMicrotask(micro)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;setImmediate(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;immediate&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以尝试把flag1或者flag2处的true改成false，只要有任何一个循环存在，那么都无法离开这个&lt;strong&gt;尾部处理阶段&lt;/strong&gt;——我自己编的名词。&lt;/p&gt;
&lt;h3 id=&quot;第三个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第三个重点&quot;/&gt; 第三个重点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每个尾部处理阶段一定会执行，就算当前阶段什么都没做，但是依然会执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾部处理阶段顺序是nextTick-&amp;gt;queueMicroTask 也就是 tickTask-&amp;gt;microTask，并且这个顺序是固定的，不可以翻转，也不可以回退&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    process.nextTick(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{ &lt;span class=&quot;comment&quot;&gt;// 在microTask之前执行的tickTask一旦执行完成，那么在同一个尾部阶段是不会继续被执行的。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;next&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;setImmediate(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;immediate&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;timeout&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;next&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;immediate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;第四个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第四个重点&quot;/&gt; 第四个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事件循环有一种维持在poll阶段的倾向&lt;/strong&gt;&lt;br/&gt;
在poll阶段时，会进行一些判定处理，比如会进行计算，大概会在这个阶段停留多久——一般根据下一个要被执行的&lt;code&gt;setTimeout&lt;/code&gt;或者&lt;code&gt;setInterval&lt;/code&gt;来决定。&lt;br/&gt;
然后会在可停留时间中进行等待。直到需要执行&lt;code&gt;timer&lt;/code&gt;的时候才会退出。&lt;br/&gt;
举个例子，假设进入poll时，又一个100ms以后的才会被执行的setTimeout，那么，就会尝试在这100ms之中，尽可能的等待IO事件触发，并处理。每当处理完后依然会判断，是否需要退出。&lt;br/&gt;
所以在大多数情况下，Nodejs都会在poll阶段运行。并且，会尝试清空所有返回的IO事件的回调（这个不是无限制的，有一个硬性限制）。&lt;/p&gt;
&lt;p&gt;与此同时，这里有出现来个新问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果回调队列中有大量的回调完成事件并且他们会堵塞100ms以上，那么setTimeout(fn,10)会怎么样&lt;br/&gt;
这里就是一个很有趣的地方了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#x27;fs&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;start&#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; globalStart = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;callback&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    fs.readFile(__filename, callback);&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;i++&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    call(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; start = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now() - start &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`done:&lt;span class=&quot;subst&quot;&gt;${i}&lt;/span&gt;`&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    })&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`&lt;span class=&quot;subst&quot;&gt;${&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()-globalStart}&lt;/span&gt;ms`&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;},&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码中模拟了每次IO调用超过100ms，并且触发了20次，同时也创建了一个timeout为10ms的任务。感兴趣的可以猜一猜他的运行结果？&lt;br/&gt;
运行结果&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-15-18-42.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;很明显，在有些情况下，还没等poll中回调全部执行完成，就直接开始进入了下一个循环，而有些情况，又是执行完了全部的回调才进入下一个阶段。&lt;br/&gt;
不过这里不是我们讨论的重点，因为这个想说的是&lt;code&gt;pending callbacks&lt;/code&gt;这个阶段。我们可以看到有些&lt;code&gt;done:x&lt;/code&gt;是在已经打印了timeout之后才出现。那么也就可以说明，已经从poll阶段循环到了timer阶段，最后在&lt;code&gt;pending callbacks&lt;/code&gt;触发回调。所以这个就是&lt;code&gt;pending callbacks&lt;/code&gt;阶段的作用。&lt;br/&gt;
有些人可能保持怀疑的态度，认为并没有进入&lt;code&gt;pending callbacks&lt;/code&gt;，可能之前的&lt;code&gt;read&lt;/code&gt;事件并没有返回，所以重新进入了poll进行等待。我只能告诉你，我确实也无法证明他们究竟是在&lt;code&gt;pending callbacks&lt;/code&gt;还是&lt;code&gt;poll&lt;/code&gt;阶段被执行，如果有更好的方法，还请多多赐教。&lt;/p&gt;
&lt;h3 id=&quot;第五个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第五个重点&quot;/&gt; 第五个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;setImmediate也没有那么的immediate&lt;/strong&gt;&lt;br/&gt;
所有人都知道&lt;code&gt;setImmediate&lt;/code&gt;的执行一般会比&lt;code&gt;setTimeout&lt;/code&gt;优先，但是其实他们也存在相反的情况。有时候是&lt;code&gt;immediate&lt;/code&gt;快，有时候是&lt;code&gt;timeout&lt;/code&gt;快，这种情况在直接写出&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;timeout&#x27;&lt;/span&gt;)},&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;setImmediate(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;immediate&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;有时候&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;timeout&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;immediate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;有时候&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;immediate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;timeout&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种毫无意义的代码下会更容易出现。所以为什么会有这种情况？&lt;/p&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-15-59-29.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://medium.com/softup-technologies/node-js-internals-event-loop-in-action-59cde8ff7e8d&quot;&gt;图片来源&lt;/a&gt;&lt;br/&gt;
简单的来说，在进入事件循环之前，你只需要进行js代码执行。那么这里也会产生耗时，所以，这里的运算时间就充满了不确定性。也许在运行&lt;code&gt;setTimeout(fn,1)&lt;/code&gt;的那一瞬间，当前的ms可能为10，但是当node执行完所有代码之后，导入了一大堆杂七杂八的库，此时的ms可能已经成为了14，很明显，&lt;code&gt;setTimeout&lt;/code&gt;被优先执行。那么如果说，当前的ms可能还是10，那么就会跳过&lt;code&gt;timer&lt;/code&gt;阶段，所以看起来就像是&lt;code&gt;setImmediate&lt;/code&gt;优先执行。那么有人可能会问，为啥要&lt;code&gt;setTimeout(fn,1)&lt;/code&gt;，而不是&lt;code&gt;setTimeout(fn,0)&lt;/code&gt;？这就是下一个重点。&lt;/p&gt;
&lt;h3 id=&quot;第六个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第六个重点&quot;/&gt; 第六个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在Nodejs下，&lt;code&gt;setTimeout&lt;/code&gt;的最小延迟数是1，最大数为2147483647，如果小于或者大于最大，那么都会被修改为1&lt;/strong&gt;&lt;br/&gt;
这里其实没啥好说的，就是这么设计的。不过有趣的是，最小为1其实是向浏览器看齐而这么做的。（源码的注释中是这么写的😄）&lt;/p&gt;
&lt;h3 id=&quot;第七个重点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第七个重点&quot;/&gt; 第七个重点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Promise.then中使用的微任务，和microTask为同一等级&lt;/strong&gt;（存疑）&lt;br/&gt;
为什么有个存疑🤨，因为从表现上来看，没有错误，但是我并没有去阅读详细的代码来证明它的确定性。&lt;br/&gt;
运行代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.resolve(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;v&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(v)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(&lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#x27;micro2&#x27;&lt;/span&gt;)})&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;micro2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，根据这个结论来看，&lt;code&gt;Promise.then&lt;/code&gt;就是一个微任务。并没有高人一等。&lt;/p&gt;
&lt;h2 id=&quot;browser&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#browser&quot;/&gt; Browser&lt;/h2&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-16-30-53.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;是不是看起来和Node的Event loop有很大的不同？如果我告诉你可以这么理解，会不会更好？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Browser中，去除了&lt;code&gt;pending callbacks&lt;/code&gt;,&lt;code&gt;poll&lt;/code&gt;,&lt;code&gt;check&lt;/code&gt;,&lt;code&gt;close callbacks&lt;/code&gt;,并全部塞入&lt;code&gt;timer&lt;/code&gt;，微任务处理时机不变&lt;br/&gt;
但是有一点小问题，就是事件循环的结束时机。但是等会会讲。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而浏览器中的执行顺序是这样。&lt;code&gt;one macroTask-&amp;gt;all microTask-&amp;gt;requestAnimationFrame-&amp;gt;render&lt;/code&gt;。&lt;br/&gt;
而且，和Node相似的是，他们的&lt;code&gt;setTimeout&lt;/code&gt;或者&lt;code&gt;setInterval&lt;/code&gt;都是尽可能的执行（时间无法保证完全符合预期）。&lt;br/&gt;
还有一点，那就是&lt;code&gt;Web API&lt;/code&gt;，在浏览器中，所有涉及到&lt;code&gt;Web API&lt;/code&gt;的内容都交给C++引擎进行处理。也就是说，当你的&lt;code&gt;setTimeout&lt;/code&gt;到底预计时间了，就算你的js引擎被某个&lt;code&gt;while(true)&lt;/code&gt;给堵住了，这个&lt;code&gt;setTimeout&lt;/code&gt;的内容依然会被推入到一个&lt;code&gt;TaskQueue&lt;/code&gt;之中。等待下一次&lt;code&gt;Event Loop&lt;/code&gt;的取出。&lt;/p&gt;
&lt;h3 id=&quot;重点一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重点一&quot;/&gt; 重点一&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在浏览器中，微任务的执行时机是在调用栈清空时&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;浏览器中一次性只执行一个宏任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器中的宏任务处理方式和Node稍微有一点点不同，Node会在一个阶段把所有到期任务都执行完成。而浏览器中，是会在执行完成一个宏观任务时清空微任务队列。而且微任务队列不会收到网络相应或者其他类型的回掉任务干扰。也就是说，和Node一样，如果你在微任务中无限创建新的微任务，那么你基本可以和这个页面说再见了👋。&lt;br/&gt;
如果不信，可以试试这个。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; call = &lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{queueMicrotask(call)}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;queueMicrotask(call)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;重点二&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重点二&quot;/&gt; 重点二&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;setTimeout&lt;/code&gt;的最小时间为1ms，而当嵌套等级达到一定时（跟随浏览器，3-5层），为4ms&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; startTime = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now()&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; call = &lt;span class=&quot;function&quot;&gt;()=&amp;gt;&lt;/span&gt;{&lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(call);&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`&lt;span class=&quot;subst&quot;&gt;${&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now() - startTime}&lt;/span&gt;`&lt;/span&gt;)}&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;call()&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;/images/Eventloop-Timeout-Immediate-Interval-QueueMicrotask-2020-11-11-19-11-53.png&quot; class=&quot;&quot;/&gt;
&lt;p&gt;不要问1到哪去了，如果实在不懂可以重新看文章，还是不懂可以悄悄问我，咱们别丢人。&lt;/p&gt;
&lt;h3 id=&quot;重点三&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重点三&quot;/&gt; 重点三&lt;/h3&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#总结&quot;/&gt; 总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;process.nextTick不是微任务&lt;/li&gt;
&lt;li&gt;requestAnimationFrame也不是微任务&lt;/li&gt;
&lt;li&gt;Promise.then中的创建方式就是创建微任务，并且和queueMicrotask同级&lt;/li&gt;
&lt;li&gt;setTimeout(fn,0)并不是0，最小为1&lt;/li&gt;
&lt;li&gt;如果你还不懂，可以直接问我，如果你有更好的想法，那么我们一起构建更好的文章，如果你不懂而且也不问我，那么我直接切腹自尽😭。&lt;/li&gt;
&lt;li&gt;有些内容我可能没有写出来，或者你有任何疑问，我都会补充在文章之中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6ca0b6733336ed722dd67a20c0e6c2b</guid>
<title>10 个有用的 HTML 文件上传技巧</title>
<link>https://toutiao.io/k/fo6wjj6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;上传文件的能力是许多Web和移动应用的关键需求，从将照片上传到社交媒体上到将简历发布到工作门户网站上，文件上传无处不在。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为一名Web开发人员，我们一定知道HTML提供了原生文件上传的支持，并借助于JavaScript的一点帮助。在HTML5中，File API被添加到DOM中。利用它，我们可以读取 &lt;/span&gt;&lt;code&gt;&lt;span&gt;FileList&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和其中的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，这就解决了文件的多种用例，即在本地加载文件或通过网络发送到服务器进行处理等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本文中，我们将讨论HTML文件上传支持的10种用法，希望你觉得它有用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在任何时候，如果您想使用这些文件上传功能，都可以在这里找到：&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;HTML文件上传演示：https://html-file-upload.netlify.app/&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;该演示的源代码在我的Github存储库中，✋请随时关注我，并通过示例不断更新代码，如果您觉得有用，请给一个⭐。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;源代码仓库：https://github.com/atapas/html-file-upload&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1.单个文件上传&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们可以将输入类型指定为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;file&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，以在Web应用程序中使用文件上传器功能。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;输入文件类型使用户可以通过按钮上传一个或多个文件，默认情况下，它允许使用操作系统的本地文件浏览器上传单个文件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上传成功后，&lt;/span&gt;&lt;code&gt;&lt;span&gt;File API&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以使用简单的JavaScript代码读取 &lt;/span&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象。要读取 &lt;/span&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，我们需要监听文件上传器的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;change&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 事件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，通过ID获取文件上传器实例&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后添加一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;change&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 事件侦听器，以在上传完成后读取文件对象，我们从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;event.target.files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性获取上传的文件信息。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;files&#x27;&lt;/span&gt;, files);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在浏览器控制台中观察输出，注意 &lt;/span&gt;&lt;code&gt;&lt;span&gt;FileList&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 数组中的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象拥有上传文件的所有元数据信息。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5615141955835962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsYVXEsGW4d5picOiaR9ZqYZreDgfrJTia9RF12RJtk31gPYl716g9VfyxQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面是相同示例的代码页，供您进一步研究&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/rNLOyRm&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;单个文件上传&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;上传文件，并在浏览器控制台中查看输出。&lt;span&gt;&amp;lt;/&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;p&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;feedback&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;files&#x27;&lt;/span&gt;, files);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; feedback = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;feedback&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; msg = &lt;span&gt;`File &lt;span&gt;${files[&lt;span&gt;0&lt;/span&gt;].name}&lt;/span&gt; uploaded successfully!`&lt;/span&gt;;&lt;br/&gt;  feedback.innerHTML = msg;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.多文件上传&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们可以一次上传多个文件。为此，我们只需要在输入文件标签中添加一个名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的属性即可。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;multiple&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;现在，文件浏览器将允许您上传一个或多个要上传的文件。就像前面的例子一样，你可以添加一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;change&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 事件处理程序来捕获上传文件的信息。您是否注意到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;FileList&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一个数组？对，对于多个文件上传，数组将具有以下信息：&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19954389965792474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsY8ON94kDicfsDFHOcezdJJHvyAWktib5Z8IE7zgaNdJAnibe8SkqHnxx1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面是CodePen链接，用于探索多个文件上传。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CodePen：https://codepen.io/atapas/pen/MWeamYp&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;多文件上传&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;multiple&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;上传多个文件并在浏览器控制台中查看输出&lt;span&gt;&amp;lt;/&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;p&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;feedback&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;files&#x27;&lt;/span&gt;, files);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// show the upload feedback&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; feedback = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;feedback&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; msg = &lt;span&gt;`&lt;span&gt;${files.length}&lt;/span&gt; file(s) uploaded successfully!`&lt;/span&gt;;&lt;br/&gt;            feedback.innerHTML = msg;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.了解文件元数据&lt;/h2&gt;&lt;section&gt;&lt;span&gt;每当我们上传一个文件时，&lt;/span&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象都有元数据信息，如文件名、大小、最后更新时间、类型等，此信息对于进一步的验证和决策很有用。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 通过id获取文件上传者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 监听 change 事件并读取元数据&lt;/span&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 获取FileList数组&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 循环浏览文件并获取元数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; file &lt;span&gt;of&lt;/span&gt; files) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; name = file.name;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; type = file.type ? file.type: &lt;span&gt;&#x27;NA&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; size = file.size;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; lastModified = file.lastModified;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log({ file, name, type, size, lastModified });&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是单个文件上传的输出：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17925925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsYXQMib2FIouSibOPJpaCSvFXrZK6SAqnuKdlBMqj2BxkvUkheSbZrXKuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用此CodePen进行进一步探索&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/gOMaRJv&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Read File Metadata&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;p&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;feedback&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;files&#x27;&lt;/span&gt;, files);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; file &lt;span&gt;of&lt;/span&gt; files) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; name = file.name;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; type = file.type ? file.type : &lt;span&gt;&#x27;NA&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; size = file.size;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; lastModified = file.lastModified;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log({file, name, type, size, lastModified});&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; feedback = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;feedback&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; msg = &lt;span&gt;` File Name: &lt;span&gt;${name}&lt;/span&gt; &amp;lt;br/&amp;gt;&lt;br/&gt;              File Size: &lt;span&gt;${size}&lt;/span&gt; &amp;lt;br/&amp;gt;&lt;br/&gt;              File type: &lt;span&gt;${type}&lt;/span&gt; &amp;lt;br/&amp;gt;&lt;br/&gt;              File Last Modified: &lt;span&gt;${&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(lastModified)}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;              &lt;br/&gt;    feedback.innerHTML = msg;&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.了解文件 accept属性&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;accept&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性来限制要上传的文件的类型，您可能希望在用户上传个人资料图片时，只显示允许浏览png格式图片类型。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;=&lt;span&gt;&quot;.jpg, .png&quot;&lt;/span&gt; &lt;span&gt;multiple&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的代码中，文件浏览器将只允许扩展名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;jpg&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;png&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1604845740379&quot; data-category_id_list=&quot;48|8|5|24|37|11|54|53|43|16|51&quot; data-id=&quot;1604845740379&quot;/&gt;&lt;span&gt;请注意，在这种情况下，文件浏览器会自动将文件选择类型设置为自定义而不是全部。但是，如果需要，您始终可以将其更改回所有文件。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11465892597968069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsYalFfSN6WtAQOItBZ3DXamDL9y5NoEok5Xqlqk6dxl6meBtcrdLOCmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1378&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用此CodePen探索 &lt;/span&gt;&lt;code&gt;&lt;span&gt;accept&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/OJXymRP&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;只能选择.png和.jpg文件&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;=&lt;span&gt;&quot;.jpg, .png&quot;&lt;/span&gt; &lt;span&gt;multiple&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Upload files and see the output in browser console&lt;span&gt;&amp;lt;/&lt;span&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;files&#x27;&lt;/span&gt;, files);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;5.管理文件内容&lt;/h2&gt;&lt;section&gt;&lt;span&gt;您可以在成功上传文件后显示文件内容。对于个人资料图片，如果上传后不立即向用户展示上传的图片，会造成混乱。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;FileReader&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象将文件转换为二进制字符串。然后添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;load&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 事件侦听器，以在成功上传文件时获取二进制字符串。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 获取FileReader的实例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; file = files[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 上传后获取文件对象并读取&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 数据作为URL二进制字符串&lt;/span&gt;&lt;br/&gt;  reader.readAsDataURL(file);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 加载后，对字符串进行处理&lt;/span&gt;&lt;br/&gt;  reader.addEventListener(&lt;span&gt;&#x27;load&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 在这里我们创建一个图像标签并添加图片&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; img = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;    imageGrid.appendChild(img);&lt;br/&gt;    img.src = event.target.result;&lt;br/&gt;    img.alt = file.name;&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;尝试在下面的CodePen中选择一个图像文件，然后查看其渲染。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/zYBvdjZ&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;显示文件内容&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;=&lt;span&gt;&quot;.jpg, .jpeg, .png&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;image-grid&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; imageGrid = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;image-grid&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; file = files[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;  reader.readAsDataURL(file);&lt;br/&gt;  &lt;br/&gt;  reader.addEventListener(&lt;span&gt;&#x27;load&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; img = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;    imageGrid.appendChild(img);&lt;br/&gt;    img.src = event.target.result;&lt;br/&gt;    img.alt = file.name;&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;6.验证文件大小&lt;/h2&gt;&lt;section&gt;&lt;span&gt;如我们所见，我们可以读取文件的大小元数据，实际上可以将其用于文件大小验证，您可能允许用户上传最大1MB的图像文件。让我们看看如何实现这一目标。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 文件上传change事件的侦听器&lt;/span&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 读取文件大小&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; file = event.target.files[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; size = file.size;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; msg = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 检查文件大小是否大于1MB，并准备一条消息。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (size &amp;gt; &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;) {&lt;br/&gt;      msg = &lt;span&gt;`&amp;lt;span style=&quot;color:red;&quot;&amp;gt;The allowed file size is 1MB. The file you are trying to upload is of &lt;span&gt;${returnFileSize(size)}&lt;/span&gt;&amp;lt;/span&amp;gt;`&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      msg = &lt;span&gt;`&amp;lt;span style=&quot;color:green;&quot;&amp;gt; A &lt;span&gt;${returnFileSize(size)}&lt;/span&gt; file has been uploaded successfully. &amp;lt;/span&amp;gt;`&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 向用户显示消息&lt;/span&gt;&lt;br/&gt;  feedback.innerHTML = msg;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;尝试上传不同大小的文件，以查看验证的工作原理&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/pobjMKv&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;检查文件大小&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;feedback&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;  &lt;br/&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; feedback = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;feedback&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; file = event.target.files[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;file&#x27;&lt;/span&gt;, file);&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; size = file.size;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;size&#x27;&lt;/span&gt;, size);&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; msg = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (size &amp;gt; &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;) {&lt;br/&gt;    msg = &lt;span&gt;`&amp;lt;span style=&quot;color:red;&quot;&amp;gt;The allowed file size is 1MB. The file you are trying to upload is of &lt;span&gt;${returnFileSize(size)}&lt;/span&gt;&amp;lt;/span&amp;gt;`&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    msg = &lt;span&gt;`&amp;lt;span style=&quot;color:green;&quot;&amp;gt; A &lt;span&gt;${returnFileSize(size)}&lt;/span&gt; file has been uploaded successfully. &amp;lt;/span&amp;gt;`&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  feedback.innerHTML = msg;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;returnFileSize&lt;/span&gt;(&lt;span&gt;number&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(number &amp;lt; &lt;span&gt;1024&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; number + &lt;span&gt;&#x27;bytes&#x27;&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(number &amp;gt;= &lt;span&gt;1024&lt;/span&gt; &amp;amp;&amp;amp; number &amp;lt; &lt;span&gt;1048576&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (number/&lt;span&gt;1024&lt;/span&gt;).toFixed(&lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;&#x27;KB&#x27;&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(number &amp;gt;= &lt;span&gt;1048576&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (number/&lt;span&gt;1048576&lt;/span&gt;).toFixed(&lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;&#x27;MB&#x27;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;7.显示文件上传进度&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更好的可用性是让你的用户知道文件上传的进程。现在，我们知道了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;FileReader&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和读取和加载文件的事件。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;FileReader&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 有另一个事件，称为进度(&lt;/span&gt;&lt;code&gt;&lt;span&gt;progress&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)，知道已加载了多少。我们可以使用HTML5的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;progress&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 标签来创建带有此信息的进度栏。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;reader.addEventListener(&lt;span&gt;&#x27;progress&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (event.loaded &amp;amp;&amp;amp; event.total) {&lt;br/&gt;    &lt;span&gt;// 计算完成百分比&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; percent = (event.loaded / event.total) * &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 将值设置为进度组件&lt;/span&gt;&lt;br/&gt;    progress.value = percent;&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;不如你试着上传一个大一点的文件，看看下面的CodePen中的进度条工作情况如何？试试吧。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/eYzpwYj&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4934895833333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsYicdsQjeNonrUv0rNZKaOBGqj7lQ14LB5GF5VbLw9WMGia05NPBAaOLrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1536&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;File upload progress&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;feedback&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;label&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;progress-label&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;progress&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;label&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;progress&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;progress&quot;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;&quot;0&quot;&lt;/span&gt; &lt;span&gt;max&lt;/span&gt;=&lt;span&gt;&quot;100&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;progress&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; feedback = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;feedback&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; progress = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;progress&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; file = files[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;  reader.readAsDataURL(file);&lt;br/&gt;  &lt;br/&gt;  reader.addEventListener(&lt;span&gt;&#x27;progress&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (event.loaded &amp;amp;&amp;amp; event.total) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; percent = (event.loaded / event.total) * &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;      progress.value = percent;&lt;br/&gt;      &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;progress-label&#x27;&lt;/span&gt;).innerHTML = &lt;span&gt;Math&lt;/span&gt;.round(percent) + &lt;span&gt;&#x27;%&#x27;&lt;/span&gt;;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (percent === &lt;span&gt;100&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; msg = &lt;span&gt;`&amp;lt;span style=&quot;color:green;&quot;&amp;gt;File &amp;lt;u&amp;gt;&amp;lt;b&amp;gt;&lt;span&gt;${file.name}&lt;/span&gt;&amp;lt;/b&amp;gt;&amp;lt;/u&amp;gt; has been uploaded successfully.&amp;lt;/span&amp;gt;`&lt;/span&gt;;&lt;br/&gt;        feedback.innerHTML = msg;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;8.目录上传呢？&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们可以上传整个目录吗？好吧，这是可能的，但有一些限制。有一个叫做 &lt;/span&gt;&lt;code&gt;&lt;span&gt;webkitdirectory&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的非标准属性（至少在写这篇文章的时候是这样），允许我们上传整个目录。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;虽然最初只针对基于WebKit的浏览器实现，但webkitdirectory也可以在Microsoft Edge以及Firefox 50和更高版本中使用。但是，即使它具有相对广泛的支持，它仍然不是标准的，除非您别无选择，否则不应该使用它。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;您可以将此属性指定为&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;webkitdirectory&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这将允许您选择一个文件夹（又名目录）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1151603498542274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsY8rroCBAOMtvibx9JxyIArrrINeUgVXqmwfzFNHNd90m1ZdNEPIKnOWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户必须提供确认信息才能上传目录，&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30523255813953487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsY1TfDjBJRbE8GP8vUYq2iaPRdlF6wD12edZ9LV2rKmDclicfACQHUQM5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1376&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;用户单击“Upload”按钮后，就会进行上传。这里要注意的重要一点：&lt;/span&gt;&lt;code&gt;&lt;span&gt;FileList&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 数组将以平面结构的形式包含有关上载目录中所有文件的信息。但关键是，对于每个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，&lt;/span&gt;&lt;code&gt;&lt;span&gt;webkitRelativePath&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性都会有目录路径。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，让我们考虑一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;main&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 目录及其下的其他文件夹和文件，&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9811320754716981&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsYCzzLHs7zE2s0lgBEBQY5uagbRatHJb9mzq0wVzCLcicNHNnw7tQicZVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在，&lt;/span&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象将将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;webkitRelativePath&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 填充为&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4956268221574344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsYFxcGc6Ez9By3KVwUM2bhP4dpu93MpZicE4sHIP2XBSrnB4uZe4G6mibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;您可以使用它在您选择的任何UI结构中呈现文件夹和文件。使用此CodePen进行进一步探索。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/dyXYRKp&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Upload directories&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;webkitdirectory&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;ul&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;pathList&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; pathList = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;pathList&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;removeAllChildNodes&lt;/span&gt;(&lt;span&gt;parent&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (parent.firstChild) {&lt;br/&gt;        parent.removeChild(parent.firstChild);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;files&#x27;&lt;/span&gt;, files);&lt;br/&gt;  &lt;br/&gt;  removeAllChildNodes(pathList);&lt;br/&gt;  &lt;br/&gt;  [...files].forEach(&lt;span&gt;(&lt;span&gt;file, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; path = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;li&#x27;&lt;/span&gt;);&lt;br/&gt;    path.innerHTML = file.webkitRelativePath;&lt;br/&gt;    pathList.appendChild(path);&lt;br/&gt;  });&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;9.让我们拖放上传&lt;/h2&gt;&lt;section&gt;&lt;span&gt;不支持拖放功能进行文件上传是一种古老的方式，不是吗？让我们看看如何通过几个简单的步骤来实现这一目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，创建一个放置区和一个可选的区域以显示上传的文件内容。我们将使用图像作为文件拖放到此处。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Drag &amp;amp; Drop an Image&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;drop-zone&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    DROP HERE&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Your image to appear here..&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;通过它们各自的ID获取拖拽和内容区域。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; dropZone = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;drop-zone&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; content = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;content&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;添加一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dragover&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 事件处理程序，以显示将要复制的内容的效果，&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;dropZone.addEventListener(&lt;span&gt;&#x27;dragover&#x27;&lt;/span&gt;, event =&amp;gt; {&lt;br/&gt;  event.stopPropagation();&lt;br/&gt;  event.preventDefault();&lt;br/&gt;  event.dataTransfer.dropEffect = &lt;span&gt;&#x27;copy&#x27;&lt;/span&gt;;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8564231738035264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANHO8ZVBicYFg8aUA4TxFRsYWliaNkPGSPQlrXKAwhQsPnZiceIjSuDF3h1OGIw2MfVK2KkRYzCOBebw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;接下来，定义放置图像时我们要做什么，我们将需要一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;drop&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 事件监听器来处理。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;dropZone.addEventListener(&lt;span&gt;&#x27;drop&#x27;&lt;/span&gt;, event =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 获取文件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.dataTransfer.files;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 现在，我们可以尽一切可能来展示文件内容在一个HTML元素中，如，DIV。&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;尝试在下面的CodePen示例中拖放图像文件，并查看其工作原理，不要忘记查看代码以渲染拖放的图像。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;CodePen：https://codepen.io/atapas/pen/ExyVoXN&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Drag &amp;amp; Drop an Image&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;drop-zone&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; DROP HERE &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Your image to appear here.. &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; dropZone = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;drop-zone&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; content = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;content&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;window&lt;/span&gt;.FileList &amp;amp;&amp;amp; &lt;span&gt;window&lt;/span&gt;.File) {&lt;br/&gt;  dropZone.addEventListener(&lt;span&gt;&#x27;dragover&#x27;&lt;/span&gt;, event =&amp;gt; {&lt;br/&gt;    event.stopPropagation();&lt;br/&gt;    event.preventDefault();&lt;br/&gt;    event.dataTransfer.dropEffect = &lt;span&gt;&#x27;copy&#x27;&lt;/span&gt;;&lt;br/&gt;  });&lt;br/&gt;  &lt;br/&gt;  dropZone.addEventListener(&lt;span&gt;&#x27;drop&#x27;&lt;/span&gt;, event =&amp;gt; {&lt;br/&gt;    content.innerHTML = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;    event.stopPropagation();&lt;br/&gt;    event.preventDefault();&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; files = event.dataTransfer.files;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(files);&lt;br/&gt;    &lt;br/&gt;    reader.readAsDataURL(files[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;  &lt;br/&gt;    reader.addEventListener(&lt;span&gt;&#x27;load&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;      content.innerHTML = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; img = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;      img.style.height = &lt;span&gt;&#x27;400px&#x27;&lt;/span&gt;;&lt;br/&gt;      img.style.width = &lt;span&gt;&#x27;400px&#x27;&lt;/span&gt;;&lt;br/&gt;      content.appendChild(img);&lt;br/&gt;      img.src = event.target.result;&lt;br/&gt;      img.alt = file.name;&lt;br/&gt;      &lt;br/&gt;    });&lt;br/&gt;  }); &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;10.使用objectURLs处理文件&lt;/h2&gt;&lt;section&gt;&lt;span&gt;有一个称为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;URL.createObjectURL()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的特殊方法，可以从文件创建唯一的URL，您也可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;URL.revokeObjectURL()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法释放它。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;DOM &lt;/span&gt;&lt;code&gt;&lt;span&gt;URL.createObjectURL()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;URL.revokeObjectURL()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法让你可以创建简单的URL字符串，这些字符串可以用来引用任何可以使用DOM文件对象引用的数据，包括用户计算机上的本地文件。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对象URL的简单用法是：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;img.src = URL.createObjectURL(file);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用此CodePen可以进一步浏览对象URL。提示：将此方法与前面#5中提到的方法进行比较。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Use Object URL&lt;span&gt;&amp;lt;/&lt;span&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;file&quot;&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;file-uploader&quot;&lt;/span&gt; &lt;span&gt;accept&lt;/span&gt;=&lt;span&gt;&quot;.jpg, .jpeg, .png&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;image-grid&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fileUploader = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;file-uploader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt; FileReader();&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; imageGrid = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;image-grid&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;fileUploader.addEventListener(&lt;span&gt;&#x27;change&#x27;&lt;/span&gt;, (event) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; files = event.target.files;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; file = files[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; img = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;  imageGrid.appendChild(img);&lt;br/&gt;  img.src = URL.createObjectURL(file);&lt;br/&gt;  img.alt = file.name;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;结束&lt;/h2&gt;&lt;section&gt;&lt;span&gt;很多时候，原生HTML功能足以让我们处理手中的用例。我发现，文件上传默认情况下提供了许多不错的选择。&lt;/span&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://dev.to/atapas/10-useful-html-file-upload-tips-for-web-developers-2d1d&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更多文章&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;粉丝福利&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;122期留言中奖用户：暂无&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;临走前留下，&lt;span&gt;今天的福利&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;福利1：&lt;/span&gt;&lt;span&gt;《Node.js网络爬虫开发2019新版》&lt;span&gt;视频教程&lt;/span&gt; &lt;/span&gt;&lt;span&gt;获取地址请在公众号对话框中回复关键字：&lt;/span&gt;&lt;span&gt;004&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;福利2：&lt;/span&gt;&lt;span&gt;在看+留言&lt;/span&gt;&lt;span&gt;，张张会在留言区随机抽取一位认真留言的小伙伴，给他发一个红包奖励&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;走心的分享更容易被抽中~&lt;br/&gt;开奖时间 下期文末&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞 + 在看 + 留言&lt;br/&gt;下一个幸运儿就是你&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>