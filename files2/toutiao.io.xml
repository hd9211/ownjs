<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>38218c2e5d03bf32839f8fd37202bce5</guid>
<title>高吞吐、低延迟 Java 应用的 GC 优化实践</title>
<link>https://toutiao.io/k/92nisj7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;p&gt;“以下信息节选自涤生的翻译内容”&lt;/p&gt;
&lt;p&gt;本篇原文作者是 LinkedIn 的 Swapnil Ghike，这篇文章讲述了 LinkedIn 的 Feed 产品的 GC 优化过程，虽然文章写作于 April 8, 2014，但其中的很多内容和知识点非常有学习和参考意义。&lt;/p&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;高性能应用构成了现代网络的支柱。LinkedIn 内部有许多高吞吐量服务来满足每秒成千上万的用户请求。为了获得最佳的用户体验，以低延迟响应这些请求是非常重要的。&lt;/p&gt;
&lt;p&gt;例如，我们的用户经常使用的产品是 Feed —— 它是一个不断更新的专业活动和内容的列表。Feed 在 LinkedIn 的系统中随处可见，包括公司页面、学校页面以及最重要的主页资讯信息。基础 Feed 数据平台为我们的经济图谱（会员、公司、群组等）中各种实体的更新建立索引，它必须高吞吐低延迟地实现相关的更新。如下图，LinkedIn Feeds 信息展示：&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/233863&quot; alt=&quot;5.jpg&quot;/&gt;&lt;br/&gt;
为了将这些高吞吐量、低延迟类型的 Java 应用程序用于生产，开发人员必须确保在应用程序开发周期的每个阶段都保持一致的性能。确定最佳垃圾收集（Garbage Collection, GC）配置对于实现这些指标至关重要。&lt;/p&gt;
&lt;p&gt;这篇博文将通过一系列步骤来明确需求并优化 GC，它的目标读者是对使用系统方法进行 GC 优化来实现应用的高吞吐低延迟目标感兴趣的开发人员。在 LinkedIn 构建下一代 Feed 数据平台的过程中，我们总结了该方法。这些方法包括但不限于以下几点：并发标记清除（Concurrent Mark Sweep，CMS（参考[2]） 和 G1（参考 [3]） 垃圾回收器的 CPU 和内存开销、避免长期存活对象导致的持续 GC、优化 GC 线程任务分配提升性能，以及可预测 GC 停顿时间所需的 OS 配置。&lt;/p&gt;
&lt;h1&gt;优化 GC 的正确时机？&lt;/h1&gt;
&lt;p&gt;GC 的行为可能会因代码优化以及工作负载的变化而变化。因此，在一个已实施性能优化的接近完成的代码库上进行 GC 优化非常重要。而且在端到端的基本原型上进行初步分析也很有必要，该原型系统使用存根代码并模拟了可代表生产环境的工作负载。这样可以获取该架构延迟和吞吐量的真实边界，进而决定是否进行纵向或横向扩展。&lt;/p&gt;
&lt;p&gt;在下一代 Feed 数据平台的原型开发阶段，我们几乎实现了所有端到端的功能，并且模拟了当前生产基础设施提供的查询工作负载。这使我们在工作负载特性上有足够的多样性，可以在足够长的时间内测量应用程序性能和 GC 特征。&lt;/p&gt;
&lt;h1&gt;优化 GC 的步骤&lt;/h1&gt;
&lt;p&gt;下面是一些针对高吞吐量、低延迟需求优化 GC 的总体步骤。此外，还包括在 Feed 数据平台原型实施的具体细节。尽管我们还对 G1 垃圾收集器进行了试验，但我们发现 ParNew/CMS 具有最佳的 GC 性能。&lt;/p&gt;
&lt;h2&gt;1. 理解 GC 基础知识&lt;/h2&gt;
&lt;p&gt;由于 GC 优化需要调整大量的参数，因此理解 GC 工作机制非常重要。Oracle 的 Hotspot JVM 内存管理白皮书（参考 [4] ）是开始学习 Hotspot JVM GC 算法非常好的资料。而了解 G1 垃圾回收器的理论知识，可以参阅（参考 [3]）。&lt;/p&gt;
&lt;h2&gt;2. 仔细考量 GC 需求&lt;/h2&gt;
&lt;p&gt;为了降低对应用程序性能的开销，可以优化 GC 的一些特征。像吞吐量和延迟一样，这些 GC 特征应该在长时间运行的测试中观察到，以确保应用程序能够在经历多个 GC 周期中处理流量的变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stop-the-world 回收器回收垃圾时会暂停应用线程。停顿的时长和频率不应该对应用遵守 SLA 产生不利的影响。&lt;/li&gt;
&lt;li&gt;并发 GC 算法与应用线程竞争 CPU 周期。这个开销不应该影响应用吞吐量。&lt;/li&gt;
&lt;li&gt;非压缩 GC 算法会引起堆碎片化，进而导致的 Full GC 长时间 Stop-the-world，因此，堆碎片应保持在最小值。&lt;/li&gt;
&lt;li&gt;垃圾回收工作需要占用内存。某些 GC 算法具有比其他算法更高的内存占用。如果应用程序需要较大的堆空间，要确保 GC 的内存开销不能太大。&lt;/li&gt;
&lt;li&gt;要清楚地了解 GC 日志和常用的 JVM 参数，以便轻松地调整 GC 行为。因为 GC 运行随着代码复杂性增加或工作负载特性的改变而发生变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用 Linux 操作系统、Hotspot Java7u51、32GB 堆内存、6GB 新生代（Young Gen）和 -XX:CMSInitiatingOccupancyFraction 值为 70（Old GC 触发时其空间占用率）开始实验。设置较大的堆内存是用来维持长期存活对象的对象缓存。一旦这个缓存生效，晋升到 Old Gen 的对象速度会显著下降。&lt;/p&gt;
&lt;p&gt;使用最初的 JVM 配置，每 3 秒发生一次 80ms 的 Young GC 停顿，超过 99.9% 的应用请求延迟 100ms（999线）。这样的 GC 效果可能适合于 SLA 对延迟要求不太严格应用。然而，我们的目标是尽可能减少应用请求的 999 线。GC 优化对于实现这一目标至关重要。&lt;/p&gt;
&lt;h2&gt;3. 理解 GC 指标&lt;/h2&gt;
&lt;p&gt;衡量应用当前情况始终是优化的先决条件。了解 GC 日志的详细细节（参考 [5]）（使用以下选项）：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps 
-XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;可以对该应用的 GC 特征有总体的把握。&lt;/p&gt;
&lt;p&gt;在 LinkedIn 的内部监控 inGraphs 和报表系统 Naarad，生成了各种有用的指标可视化图形，比如 GC 停顿时间百分比、一次停顿最大持续时间以及长时间内 GC 频率。除了 Naarad，有很多开源工具比如 gclogviewer 可以从 GC 日志创建可视化图形。在此阶段，可以确定 GC 频率和暂停持续时间是否满足应用程序满足延迟的要求。&lt;/p&gt;
&lt;h2&gt;4. 降低 GC 频率&lt;/h2&gt;
&lt;p&gt;在分代 GC 算法中，降低 GC 频率可以通过：(1) 降低对象分配/晋升率；(2) 增加各代空间的大小。&lt;/p&gt;
&lt;p&gt;在 Hotspot JVM 中，Young GC 停顿时间取决于一次垃圾回收后存活下来的对象的数量，而不是 Young Gen 自身的大小。增加 Young Gen 大小对于应用性能的影响需要仔细评估：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果更多的数据存活而且被复制到 Survivor 区域，或者每次 GC 更多的数据晋升到 Old Gen，增加 Young Gen 大小可能导致更长的 Young GC 停顿。较长的 GC 停顿可能会导致应用程序延迟增加和(或)吞吐量降低。&lt;/li&gt;
&lt;li&gt;另一方面，如果每次垃圾回收后存活对象数量不会大幅增加，停顿时间可能不会延长。在这种情况下，降低 GC 频率可能会使整个应用总体延迟降低和(或)吞吐量增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于大部分为短期存活对象的应用，仅仅需要控制上述的参数；对于长期存活对象的应用，就需要注意，被晋升的对象可能很长时间都不能被 Old GC 周期回收。如果 Old GC 触发阈值（Old Gen 占用率百分比）比较低，应用将陷入持续的 GC 循环中。可以通过设置高的 GC 触发阈值可避免这一问题。&lt;/p&gt;
&lt;p&gt;由于我们的应用在堆中维持了长期存活对象的较大缓存，将 Old GC 触发阈值设置为&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;-XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSInitiatingOccupancyOnly
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;来增加触发 Old GC 的阈值。我们也试图增加 Young Gen 大小来减少 Young GC 频率，但是并没有采用，因为这增加了应用的 999 线。&lt;/p&gt;
&lt;h2&gt;5. 缩短 GC 停顿时间&lt;/h2&gt;
&lt;p&gt;减少 Young Gen 大小可以缩短 Young GC 停顿时间，因为这可能导致被复制到 Survivor 区域或者被晋升的数据更少。但是，正如前面提到的，我们要观察减少 Young Gen 大小和由此导致的 GC 频率增加对于整体应用吞吐量和延迟的影响。Young GC 停顿时间也依赖于 tenuring threshold （晋升阈值）和 Old Gen 大小（如步骤 6 所示）。&lt;/p&gt;
&lt;p&gt;在使用 CMS GC 时，应将因堆碎片或者由堆碎片导致的 Full GC 的停顿时间降低到最小。通过控制对象晋升比例和减小 -XX:CMSInitiatingOccupancyFraction 的值使 Old GC 在低阈值时触发。所有选项的细节调整和他们相关的权衡，请参考 Web Services 的 Java 垃圾回收（参考 [5] ）和 Java 垃圾回收精粹（参考 [6]）。&lt;/p&gt;
&lt;p&gt;我们观察到 Eden 区域的大部分 Young Gen 被回收，几乎没有 3-8 年龄对象在 Survivor 空间中死亡，所以我们将 tenuring threshold 从 8 降低到 2 (使用选项：-XX:MaxTenuringThreshold=2 ),以降低 Young GC 消耗在数据复制上的时间。&lt;/p&gt;
&lt;p&gt;我们还注意到 Young GC 暂停时间随着 Old Gen 占用率上升而延长。这意味着来自 Old Gen 的压力使得对象晋升花费更多的时间。为解决这个问题，将总的堆内存大小增加到 40GB，减小 -XX:CMSInitiatingOccupancyFraction 的值到 80，更快地开始 Old GC。尽管 -XX:CMSInitiatingOccupancyFraction 的值减小了，增大堆内存可以避免频繁的 Old GC。在此阶段，我们的结果是 Young GC 暂停 70ms，应用的 999 线在 80ms。&lt;/p&gt;
&lt;h2&gt;6. 优化 GC 工作线程的任务分配&lt;/h2&gt;
&lt;p&gt;为了进一步降低 Young GC 停顿时间，我们决定研究 GC 线程绑定任务的参数来进行优化。&lt;/p&gt;
&lt;p&gt;-XX:ParGCCardsPerStrideChunk 参数控制 GC 工作线程的任务粒度，可以帮助不使用补丁而获得最佳性能，这个补丁用来优化 Young GC 中的 Card table（卡表）扫描时间（参考[7]）。有趣的是，Young GC 时间随着 Old Gen 的增加而延长。将这个选项值设为 32678，Young GC 停顿时间降低到平均 50ms。此时应用的 999 线在 60ms。&lt;/p&gt;
&lt;p&gt;还有一些的参数可以将任务映射到 GC 线程，如果操作系统允许的话，-XX:+BindGCTaskThreadsToCPUs 参数可以绑定 GC 线程到个别的 CPU 核（见解释 [1]）。使用亲缘性 -XX:+UseGCTaskAffinity 参数可以将任务分配给 GC 工作线程（见解释 [2]）。然而，我们的应用并没有从这些选项带来任何好处。实际上，一些调查显示这些选项在 Linux 系统不起作用。&lt;/p&gt;
&lt;h2&gt;7. 了解 GC 的 CPU 和内存开销&lt;/h2&gt;
&lt;p&gt;并发 GC 通常会增加 CPU 使用率。虽然我们观察到 CMS 的默认设置运行良好，但是 G1 收集器的并发 GC 工作会导致 CPU 使用率的增加，显著降低了应用程序的吞吐量和延迟。与 CMS 相比，G1 还增加了内存开销。对于不受 CPU 限制的低吞吐量应用程序，GC 导致的高 CPU 使用率可能不是一个紧迫的问题。&lt;/p&gt;
&lt;p&gt;下图是 ParNew/CMS 和 G1 的 CPU 使用百分比：相对来说 CPU 使用率变化明显的节点使用 G1 参数 -XX:G1RSetUpdatingPauseTimePercent=20：&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/233872&quot; alt=&quot;6.jpg&quot;/&gt;&lt;br/&gt;
下图是 ParNew/CMS 和 G1 每秒服务的请求数：吞吐量较低的节点使用 G1 参数 -XX:G1RSetUpdatingPauseTimePercent=20&lt;br/&gt;
&lt;img src=&quot;https://a.perfma.net/img/233885&quot; alt=&quot;7.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;8. 为 GC 优化系统内存和 I/O 管理&lt;/h2&gt;
&lt;p&gt;通常来说，GC 停顿有两种特殊情况：(1) 低 user time，高 sys time 和高 real time (2) 低 user time，低 sys time 和高 real time。这意味着基础的进程/OS设置存在问题。情况 (1) 可能意味着 JVM 页面被 Linux 窃取；情况 (2) 可能意味着 GC 线程被 Linux 用于磁盘刷新，并卡在内核中等待 I/O。在这些情况下，如何设置参数可以参考该 PPT（参考 [8]）。&lt;/p&gt;
&lt;p&gt;另外，为了避免在运行时造成性能损失，我们可以使用 JVM 选项 -XX:+AlwaysPreTouch 在应用程序启动时先访问所有分配给它的内存，让操作系统把内存真正的分配给 JVM。我们还可以将 vm.swappability 设置为0，这样操作系统就不会交换页面到 swap（除非绝对必要）。&lt;/p&gt;
&lt;p&gt;可能你会使用 mlock 将 JVM 页固定到内存中，这样操作系统就不会将它们交换出去。但是，如果系统用尽了所有的内存和交换空间，操作系统将终止一个进程来回收内存。通常情况下，Linux 内核会选择具有高驻留内存占用但运行时间不长的进程（OOM 情况下杀死进程的工作流（参考[9]）进行终止。在我们的例子中，这个进程很有可能就是我们的应用程序。优雅的降级是服务优秀的属性之一，不过服务突然终止的可能性对于可操作性来说并不好 —— 因此，我们不使用 mlock，只是通过 vm.swapability 来尽可能避免交换内存页到 swap 的惩罚。&lt;/p&gt;
&lt;p&gt;LinkedIn 动态信息数据平台的 GC 优化&lt;/p&gt;
&lt;p&gt;对于该 Feed 平台原型系统，我们使用 Hotspot JVM 的两个 GC 算法优化垃圾回收：&lt;/p&gt;
&lt;p&gt;Young GC 使用 ParNew，Old GC 使用 CMS。&lt;br/&gt;
Young Gen 和 Old Gen 使用 G1。G1 试图解决堆大小为 6GB 或更大时，暂停时间稳定且可预测在 0.5 秒以下的问题。在我们用 G1 实验过程中，尽管调整了各种参数，但没有得到像 ParNew/CMS 一样的 GC 性能或停顿时间的可预测值。我们查询了使用 G1 发生内存泄漏相关的一个 bug（见解释[3]），但还不能确定根本原因。&lt;br/&gt;
使用 ParNew/CMS，应用每三秒进行一次 40-60ms 的 Young GC 和每小时一个 CMS GC。JVM 参数如下：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;// JVM sizing options
-server -Xms40g -Xmx40g -XX:MaxDirectMemorySize=4096m -XX:PermSize=256m -XX:MaxPermSize=256m   
// Young generation options
-XX:NewSize=6g -XX:MaxNewSize=6g -XX:+UseParNewGC -XX:MaxTenuringThreshold=2 -XX:SurvivorRatio=8 -XX:+UnlockDiagnosticVMOptions -XX:ParGCCardsPerStrideChunk=32768
// Old generation  options
-XX:+UseConcMarkSweepGC -XX:CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+CMSClassUnloadingEnabled  -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly   
// Other options
-XX:+AlwaysPreTouch -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -XX:-OmitStackTraceInFastThrow
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;使用这些参数，对于成千上万读请求的吞吐量，我们应用程序的 999 线降低到 60ms。&lt;/p&gt;
&lt;p&gt;解释&lt;/p&gt;
&lt;p&gt;[1] -XX:+BindGCTaskThreadsToCPUs 参数似乎在Linux 系统上不起作用，因为 hotspot/src/os/linux/vm/oslinux.cpp 的 distributeprocesses 方法在 JDK7 或 JDK8 中没有实现。&lt;/p&gt;
&lt;p&gt;[2] -XX:+UseGCTaskAffinity 参数在 JDK7 和 JDK8 的所有平台似乎都不起作用，因为任务的亲缘性属性永远被设置为 sentinelworker = (uint) -1。源码见 hotspot/src/share/vm/gcimplementation/parallelScavenge/{gcTaskManager.cpp，gcTaskThread.cpp, gcTaskManager.cpp}。&lt;/p&gt;
&lt;p&gt;[3] G1 存在一些内存泄露的 bug，可能 Java7u51 没有修改。这个 bug 仅在 Java 8 修正了。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1efcacbcec32a60205fcdb6d321062d</guid>
<title>一文读懂 Raft 一致性协议算法并理解其中的关键设计</title>
<link>https://toutiao.io/k/c68ccw6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2&gt;&lt;span&gt;什么是一致性算法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;为了避免单个机器可能出现的数据丢失、单点故障等问题，人们想出了通过复制数据到多个机器上的方式来解决。但是有多个机器时，带来的另一个问题就是如何保证这些机器之间的数据是一致的呢？不能因为某个机器故障或错误，导致各个机器之前数据混乱或丢失。这就是分布式一致性算法要解决的问题。&lt;/p&gt;&lt;p&gt;业界比较有名的分布式算法是paxos，不过可惜的是它比较晦涩难懂，难懂的代价就是很少有人能掌握它然后基于它做出可靠的实现。不过幸好raft及时出现，raft的特点是易于理解，并且已经有非常多的实际系统是基于raft算法实现的了，比如tikv、etcd等。文章末尾我们还会解释一下raft的名字。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;介绍raft&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;raft的易懂性的一个重要方式就是对问题进行拆分，让大家能够独立理解每个子问题。raft的分布式一致性问题可以拆分成哪些子问题呢？&lt;/p&gt;&lt;p&gt;可以分为&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;leader选举&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;log复制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性保证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;log compaction、membership change等优化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;leader选举&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;raft把分布式系统抽象成了分布式的状态机，每个状态机有一个log队列，log队列中存放的是状态机的指令，只要保证各个节点的log队列的数据顺序和值一致，就能保证状态机最终的状态是一致的。&lt;/p&gt;&lt;p&gt;在raft，节点一共有3种角色，leader、follower、candidate。在raft系统中，同一时间只会有一个leader，leader负责处理客户端的请求，并且同步log给follower, leader定期通过给follower发送心跳，保持自己的leader地位。&lt;/p&gt;&lt;p&gt;初始时所有的节点都处于follower状态，当follower一段时间(election timeout)内没有接收到leader的请求时(log复制或心跳)，就会把自己转变为candidate角色，candidate是成为leader前的准备状态，candidate会向其他节点发送RequestVote请求，请求其他节点为自己投票，如果某个candidate获得了半数以上（包括自己）的节点的投票支持后，就可以成为这一届的leader。这里为了防止节点可能同时唤醒成为candidate，会增加一个随机机制，让超时时间随机，减少冲突概率，即使出现了冲突（多个candiate且都获得相同的投票），会在一段时间后进行下一轮投票。每一轮的选举会有一个term（任期）的值，term会从1开始递增，每一个follower在一个任期内只会投票给一个节点，这样加上半数以上机制就能保证同一个term内最多只会出现一个leader。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;log复制(log replication)&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;成为leader之后，就可以接收客户端的请求，leader接收客户端请求后，会写入本地log，并同步给所有的follower(通过AppendEntries的RPC请求)，follower会写入本地log，返回给leader成功，leader接收到半数以上（包括自己）的写入成功后，会进行commit，commit后这个修改就会应用到状态机中，并且返回给客户端请求成功。AppendEntries请求中会包含当前leader的term和日志的index。每次AppendEntries请求中会带上leader的commitIndex，这样follower就知道哪些log可以被应用到状态机上了。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;raft的安全性关键设计-leader故障重新选举&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果某个时刻leader故障了，而leader刚刚同步的log并没有同步给全部follower，则这时一个没有完成同步的follower如果成为下一个leader，则会导致前一任leader已经commit的数据丢失，这是不能接受的。&lt;/p&gt;&lt;p&gt;在raft中是如何解决这个问题的呢？raft中巧妙的实现了必须拥有已经commit的log的节点才能成为下一个leader，当follower收到一个candidate的RequestVote时，RequestVote中包含term、lastLogTerm、lastLogIndex，term是这个candiate的发起新的leader选举的term，lastLogTerm是candidate上最后一个log的term，lastLogIndex是最后一个log的index，term和index能够共同定位出唯一一个log。如果candidate的lastLogTerm小于当前follower的最后一个log的term,则会拒绝这个RequestVote请求。如果candidate的lastLogIndex小于当前follower的最后一个log的index，则会拒绝这个RequsetVote的请求。&lt;/p&gt;&lt;p&gt;通过这个限制，就能够保证选举出的新leader，是不会丢掉已经commit的数据的。并且当leader给follower同步数据(AppendEntries请求)时，会带上上一个log的term和index，如果follower的上一个log的term和index不相同，follower会返回错误，leader会进行回溯，这样就可以将follower的数据和leader进行校准。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;raft优化-log compaction&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;系统持续运行log可能会持续增加，持续增加的log带来的问题有，1是占用过多的磁盘空间，2是如果有新节点加入，则需要同步的数据会非常多。因此raft中提出了log compaction的机制，就是做快照，这个与mysql中的redo log类似。程序在特定时间（比如定时或log到达一定长度）后会对状态机保存快照，这样这个状态机之前的log就可以丢弃了，只需要持久化、传输这个快照就可以了。一般快照都比log会小很多。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;raft优化-membership change&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;服务在运行过程中，可能出现要添加修改删除节点的情况，比如某个机器坏了，我们就需要给集群换一个机器，再比如我们想提高集群的故障容忍度，可能就需要添加节点。&lt;/p&gt;&lt;p&gt;raft中提出的修改membership的方法为joint（联合） consensus&lt;/p&gt;&lt;figure&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.4781021897810219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfAhkMkS9hOUibaABLlXG4gqsJnStia5y5m6drvBLVzV8sP8LiafJ9p64Pr35TOPwsNZCHTxnwgplfG1kU5O7CekA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;p&gt;我们把raft集群节点的列表称为配置，当要进行节点修改时，就是从一个旧的配置(C-old)修改到新的配置(C-new),当leader收到要进行集群配置修改的请求后，会创建一个C old-new的配置（旧集群和新集群合并），作为raft log发送给follower，当follower收到C old-new后，会立刻使用C new配置。一旦C old-new被commit后，Cold和Cnew必须联合起来做决定（包括log复制和leader选举)，两个集群配置不能做单边决定，然后leader会再发送一个C new的配置，C new的配置commit后，old配置就失效了，old配置中的节点也可以安全关闭了。这个机制能够保证C old和C new不会做单边决定，从而保证了安全性。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;raft的名字&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;最后，关于raft这个名字的理解, raft为什么叫raft呢? 官网和google上并没有明确的答案。下面是我的理解。&lt;/p&gt;&lt;img data-ratio=&quot;0.5846153846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfAhkMkS9hOUibaABLlXG4gqsJnStia5y5JXczDIRfAmle8KvoaDyicwa3VqORxJJBQcUqGemibicdNyH7DKrvEVcRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;390&quot;/&gt;&lt;p&gt;raft在英文中的名字是木筏的意思，从raft的logo可以看出，它是有三个木头组成，那么木头在英文中有什么名字呢，log的意思也是木头。3个木头代表3个log，分布式的replicate log，是不是很巧妙？&lt;/p&gt;&lt;h2&gt;&lt;span&gt;其他参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;raft&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深入浅出 Raft - 基本概念&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Making sense of the RAFT Distributed Consensus Algorithm&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9b2218bb1871dc5b7acfc3b5921bbc0</guid>
<title>细数 ThreadLocal 三大坑，内存泄露仅是小儿科</title>
<link>https://toutiao.io/k/gtp5csf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p&gt;&lt;span&gt;我在参加Code Review的时候不止一次听到有同学说：&lt;/span&gt;&lt;span&gt;我写的这个上下文工具没问题，在线上跑了好久了。&lt;/span&gt;&lt;span&gt;其实这种想法是有问题的，&lt;/span&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;span&gt;写错难，但是用错就很容易，本文将会详细总结&lt;/span&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;span&gt;容易用错的三个坑：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内存泄露&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池中线程上下文丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并行流中线程上下文丢失&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;内存泄露&lt;/h2&gt;&lt;section&gt;由于&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;是弱引用，因此如果使用后不调用&lt;code&gt;remove&lt;/code&gt;清理的话会导致对应的&lt;code&gt;value&lt;/code&gt;内存泄露。&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testThreadLocalMemoryLeaks&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ThreadLocal&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; localCache = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;   List&amp;lt;Integer&amp;gt; cacheInstance = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;10000&lt;/span&gt;);&lt;br/&gt;    localCache.set(cacheInstance);&lt;br/&gt;    localCache = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;当&lt;code&gt;localCache&lt;/code&gt;的值被重置之后&lt;code&gt;cacheInstance&lt;/code&gt;被&lt;code&gt;ThreadLocalMap&lt;/code&gt;中的&lt;code&gt;value&lt;/code&gt;引用，无法被GC，但是其&lt;code&gt;key&lt;/code&gt;对&lt;code&gt;ThreadLocal&lt;/code&gt;实例的引用是一个弱引用，本来&lt;code&gt;ThreadLocal&lt;/code&gt;的实例被&lt;code&gt;localCache&lt;/code&gt;和&lt;code&gt;ThreadLocalMap&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;同时引用，但是当&lt;code&gt;localCache&lt;/code&gt;的引用被重置之后，则&lt;code&gt;ThreadLocal&lt;/code&gt;的实例只有&lt;code&gt;ThreadLocalMap&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;这样一个弱引用了，此时这个实例在GC的时候能够被清理。&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4xfJbk4AmfjWImbjAuEDxAaUmzknXeLe7yjJLic9ZC5zYGPvHm204A89nib4TrE951uEicndeibiba8OK5CibPbeJ0BQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;715&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;其实看过&lt;code&gt;ThreadLocal&lt;/code&gt;源码的同学会知道，&lt;code&gt;ThreadLocal&lt;/code&gt;本身对于&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;的&lt;code&gt;Entity&lt;/code&gt;有自清理的过程，但是这个过程是依赖于后续对&lt;code&gt;ThreadLocal&lt;/code&gt;的继续使用，假如上面的这段代码是处于一个秒杀场景下，会有一个瞬间的流量峰值，这个流量峰值也会将集群的内存打到高位(或者运气不好的话直接将集群内存打满导致故障)，后面由于峰值流量已过，对&lt;code&gt;ThreadLocal&lt;/code&gt;的调用也下降，会使得&lt;code&gt;ThreadLocal&lt;/code&gt;的自清理能力下降，造成内存泄露。&lt;code&gt;ThreadLocal&lt;/code&gt;的自清理是锦上添花，千万不要指望他雪中送碳。&lt;/section&gt;&lt;section&gt;相比于&lt;code&gt;ThreadLocal&lt;/code&gt;中存储的&lt;code&gt;value&lt;/code&gt;对象泄露，&lt;code&gt;ThreadLocal&lt;/code&gt;用在&lt;code&gt;web&lt;/code&gt;容器中时更需要注意其引起的&lt;code&gt;ClassLoader&lt;/code&gt;泄露。&lt;/section&gt;&lt;section&gt;&lt;code&gt;Tomcat&lt;/code&gt;官网对在&lt;code&gt;web&lt;/code&gt;容器中使用&lt;code&gt;ThreadLocal&lt;/code&gt;引起的内存泄露做了一个总结，详见：https://cwiki.apache.org/confluence/display/tomcat/MemoryLeakProtection，这里我们列举其中的一个例子。&lt;/section&gt;&lt;section&gt;熟悉&lt;code&gt;Tomcat&lt;/code&gt;的同学知道，Tomcat中的web应用由&lt;code&gt;Webapp Classloader&lt;/code&gt;这个类加载器的，并且&lt;code&gt;Webapp Classloader&lt;/code&gt;是破坏双亲委派机制实现的，即所有的&lt;code&gt;web&lt;/code&gt;应用先由&lt;code&gt;Webapp classloader&lt;/code&gt;加载，这样的好处就是可以让同一个容器中的&lt;code&gt;web&lt;/code&gt;应用以及依赖隔离。&lt;/section&gt;&lt;section&gt;下面我们看具体的内存泄露的例子：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyCounter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;increment&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  count++;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCount&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyThreadLocal&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;MyCounter&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LeakingServlet&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HttpServlet&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyThreadLocal myThreadLocal = &lt;span&gt;new&lt;/span&gt; MyThreadLocal();&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doGet&lt;/span&gt;&lt;span&gt;(HttpServletRequest request,&lt;br/&gt;   HttpServletResponse response)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException, IOException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  MyCounter counter = myThreadLocal.get();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (counter == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   counter = &lt;span&gt;new&lt;/span&gt; MyCounter();&lt;br/&gt;   myThreadLocal.set(counter);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  response.getWriter().println(&lt;br/&gt;    &lt;span&gt;&quot;The current thread served this servlet &quot;&lt;/span&gt; + counter.getCount()&lt;br/&gt;      + &lt;span&gt;&quot; times&quot;&lt;/span&gt;);&lt;br/&gt;  counter.increment();&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;需要注意这个例子中的两个非常关键的点：&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MyCounter&lt;/code&gt;以及&lt;code&gt;MyThreadLocal&lt;/code&gt;必须放到&lt;code&gt;web&lt;/code&gt;应用的路径中，保被&lt;code&gt;Webapp Classloader&lt;/code&gt;加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;类一定得是&lt;code&gt;ThreadLocal&lt;/code&gt;的继承类，比如例子中的&lt;code&gt;MyThreadLocal&lt;/code&gt;，因为&lt;code&gt;ThreadLocal&lt;/code&gt;本来被&lt;code&gt;Common Classloader&lt;/code&gt;加载，其生命周期与&lt;code&gt;Tomcat&lt;/code&gt;容器一致。&lt;code&gt;ThreadLocal&lt;/code&gt;的继承类包括比较常见的&lt;code&gt;NamedThreadLocal&lt;/code&gt;，注意不要踩坑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;假如&lt;code&gt;LeakingServlet&lt;/code&gt;所在的&lt;code&gt;Web&lt;/code&gt;应用启动，&lt;code&gt;MyThreadLocal&lt;/code&gt;类也会被&lt;code&gt;Webapp Classloader&lt;/code&gt;加载，如果此时web应用下线，而线程的生命周期未结束(比如为&lt;code&gt;LeakingServlet&lt;/code&gt;提供服务的线程是一个线程池中的线程)，那会导致&lt;code&gt;myThreadLocal&lt;/code&gt;的实例仍然被这个线程引用，而不能被GC，期初看来这个带来的问题也不大，因为&lt;code&gt;myThreadLocal&lt;/code&gt;所引用的对象占用的内存空间不太多，问题在于&lt;code&gt;myThreadLocal&lt;/code&gt;间接持有加载web应用的&lt;code&gt;webapp classloader&lt;/code&gt;的引用（通过&lt;code&gt;myThreadLocal.getClass().getClassLoader()&lt;/code&gt;可以引用到），而加载web应用的&lt;code&gt;webapp classloader&lt;/code&gt;有持有它加载的所有类的引用，这就引起了&lt;code&gt;Classloader&lt;/code&gt;泄露，它泄露的内存就非常可观了。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;线程池中线程上下文丢失&lt;/h2&gt;&lt;section&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;不能在父子线程中传递，因此最常见的做法是把父线程中的&lt;code&gt;ThreadLocal&lt;/code&gt;值拷贝到子线程中，因此大家会经常看到类似下面的这段代码：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;for&lt;/span&gt;(value in valueList){&lt;br/&gt;     Future&amp;lt;?&amp;gt; taskResult = threadPool.submit(&lt;span&gt;new&lt;/span&gt; BizTask(ContextHolder.get()));&lt;span&gt;//提交任务，并设置拷贝Context到子线程&lt;/span&gt;&lt;br/&gt;     results.add(taskResult);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(result in results){&lt;br/&gt;    result.get();&lt;span&gt;//阻塞等待任务执行完成&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;提交的任务定义长这样：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BizTask&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;  &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String session = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;BizTask&lt;/span&gt;&lt;span&gt;(String session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.session = session;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ContextHolder.set(&lt;span&gt;this&lt;/span&gt;.session);&lt;br/&gt;            &lt;span&gt;// 执行业务逻辑&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt;(Exception e){&lt;br/&gt;            &lt;span&gt;//log error&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            ContextHolder.remove(); &lt;span&gt;// 清理 ThreadLocal 的上下文，避免线程复用时context互串&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;对应的线程上下文管理类为：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ContextHolder&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; localThreadCache = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(String cacheValue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        localThreadCache.set(cacheValue);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; localThreadCache.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        localThreadCache.remove();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;这么写倒也没有问题，我们再看看线程池的设置：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;ThreadPoolExecutor executorPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span&gt;40&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; XXXThreadFactory(), ThreadPoolExecutor.CallerRunsPolicy);&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;其中最后一个参数控制着当线程池满时，该如何处理提交的任务，内置有4种策略&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;ThreadPoolExecutor.AbortPolicy &lt;span&gt;//直接抛出异常&lt;/span&gt;&lt;br/&gt;ThreadPoolExecutor.DiscardPolicy &lt;span&gt;//丢弃当前任务&lt;/span&gt;&lt;br/&gt;ThreadPoolExecutor.DiscardOldestPolicy &lt;span&gt;//丢弃工作队列头部的任务&lt;/span&gt;&lt;br/&gt;ThreadPoolExecutor.CallerRunsPolicy &lt;span&gt;//转串行执行&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;可以看到，我们初始化线程池的时候指定如果线程池满，则新提交的任务转为串行执行，那我们之前的写法就会有问题了，串行执行的时候调用&lt;code&gt;ContextHolder.remove();&lt;/code&gt;会将主线程的上下文也清理，即使后面线程池继续并行工作，传给子线程的上下文也已经是&lt;code&gt;null&lt;/code&gt;了，而且这样的问题很难在预发测试的时候发现。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;并行流中线程上下文丢失&lt;/h2&gt;&lt;section&gt;如果&lt;code&gt;ThreadLocal&lt;/code&gt;碰到并行流，也会有很多有意思的事情发生，比如有下面的代码：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParallelProcessor&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;process&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; dataList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 先校验参数，篇幅限制先省略不写&lt;/span&gt;&lt;br/&gt;        dataList.parallelStream().forEach(entry -&amp;gt; {&lt;br/&gt;            doIt();&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doIt&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String session = ContextHolder.get();&lt;br/&gt;        &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;这段代码很容易在线下测试的过程中发现不能按照预期工作，因为并行流底层的实现也是一个&lt;code&gt;ForkJoin&lt;/code&gt;线程池，既然是线程池，那&lt;code&gt;ContextHolder.get()&lt;/code&gt;可能取出来的就是一个&lt;code&gt;null&lt;/code&gt;。我们顺着这个思路把代码再改一下：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParallelProcessor&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String session;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ParallelProcessor&lt;/span&gt;&lt;span&gt;(String session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.session = session;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;process&lt;/span&gt;&lt;span&gt;(List&amp;lt;T&amp;gt; dataList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 先校验参数，篇幅限制先省略不写&lt;/span&gt;&lt;br/&gt;        dataList.parallelStream().forEach(entry -&amp;gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ContextHolder.set(session);&lt;br/&gt;                &lt;span&gt;// 业务处理&lt;/span&gt;&lt;br/&gt;                doIt();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;                &lt;span&gt;// log it&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                ContextHolder.remove();&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doIt&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String session = ContextHolder.get();&lt;br/&gt;        &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;修改完后的这段代码可以工作吗？如果运气好，你会发现这样改又有问题，运气不好，这段代码在线下运行良好，这段代码就顺利上线了。不久你就会发现系统中会有一些其他很诡异的bug。原因在于并行流的设计比较特殊，父线程也有可能参与到并行流线程池的调度，那如果上面的&lt;code&gt;process&lt;/code&gt;方法被父线程执行，那么父线程的上下文会被清理。导致后续拷贝到子线程的上下文都为&lt;code&gt;null&lt;/code&gt;，同样产生丢失上下文的问题。&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651495981&amp;amp;idx=1&amp;amp;sn=f36af4c1f0a3873cb879c6f95c455bc8&amp;amp;chksm=bd25f2528a527b4413e40d35510260c7fae3350ec2bc2edb95fee1b78f14dcd084500f2d3a9f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring新版本抛弃JVM，可独立部署，网友：要自立门户？？？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651495976&amp;amp;idx=1&amp;amp;sn=c9fd8885a1a31b7e3415dde818291c53&amp;amp;chksm=bd25f2578a527b4102c332229cd8f1c8020a1089be23a93e5782f618c49c462293cec9306ef5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试题：a==1 &amp;amp;&amp;amp; a==2 &amp;amp;&amp;amp; a==3 是 true 还是 false？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651495976&amp;amp;idx=2&amp;amp;sn=c2f18cab0069840902df30fab279a80d&amp;amp;chksm=bd25f2578a527b418b576e7cb5849091de8e753bd6c2f2b2193d46f525bae931f9d7330bd83d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL 中的反斜杠 \\，真是太坑了！！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2c8d54e4e75a17eaa7a322ed5faa38ff</guid>
<title>比开源快 30 倍的自研 SQL Parser 设计与实践</title>
<link>https://toutiao.io/k/0aw815r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKmmDW8ABWYRJNbO5bRGfShd4IoZMhD2C7sqytMGPHg63icC4C6czTeiaLkA4QcZicQGxHYyTDoAtf5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL（Structured Query Language）作为一种领域语言（编程语言），最早用于关系型数据库，方便管理结构化数据；SQL由多种不同的类型的语言组成，包括数据定义语言，数据控制语言、数据操作语言；各数据库产品都有不同的声明和实现；用户可以很方便的使用SQL操作数据，数据库系统中的词法语法分析器负责分析和理解SQL文本的含义，包括词法分析、语法分析、语义分析3部分。经过词法语法分析器生成AST（Abstract Syntax Tree），会被优化器处理生成生成执行计划，再由执行引擎执行，下图以MySQL架构为例展示词法语法分析器所处的位置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1569767441860466&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmmDW8ABWYRJNbO5bRGfShPWEbIk4pCtyzTxkyC8IUfYPa53hWHL9ib0LzRic25INRT5QlqLeZZdjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;688&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文通过介绍词法语法分析器技术和业界的做法，以及过去使用自动生成的词法语法分析器遇到的问题，分享自研SQL Parser的设计与实践，以及其带来的性能和功能的提升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;一  业界产品如何开发SQL Parser？&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照解析器代码开发方式，可分为以下两种：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1  自动生成&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为方便开发词法、语法分析的过程，业界有许多词法、语法分析工具，例如：Flex、Lex、Bison工具常用于生成以C、C++作为目标语言的词法、语法代码；如果以Java作为目标语言，可以使用比较流行的ANTLR和JavaCC等工具，ANTLR、JavaCC工具都以用户编写的词法语法规则文件作为输入，其中语法文件需要满足EBNF（extended Backus–Naur form）[1]语法规则， 这2个工具使用LL(k) (Left-to-right, Leftmost derivation)[2] 算法“自顶向下[3]”解析SQL文本并构建SQL AST， Presto，Spark、Hive等数据库和大数据系统多采用该方式生成。生成的代码包含词法和语法解析部分，语义分析还需要结合Meta数据，各数据库内核自己处理；更多自动生成工具的功能和算法对比[4]在参考文献中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2  手工编写&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与自动生成工具不同，InfluxDB、H2、Clickhouse等流行的数据库的SQL Parser组件均是手工编写而成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不足：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;二  问题与挑战&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1  复杂查询的性能问题&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在实时分析型数据库的实际生产环境中，经常需要处理数以千行的复杂查询请求或者深层嵌套的查询请求，自动生成的解析器，由于状态机管理复杂，线程堆栈太深，导致个别查询请求在词法语法解析阶段性能下降严重。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2  大批量写入吞吐问题&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分析型数据库要稳定处理大批量、高并发写入的场景，要求SQL Parser组件有很好的性能和稳定性，我们尝试使用过ANTLR，JavaCC等工具生成SQL 的词法语法解析器，大批量写入时，values子句在解析过程会产生太多AST临时对象，导致垃圾回收耗时的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3  Query Rewriting的灵活性问题&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;需要快速方便的遍历AST树，找到符合某种规则的叶子节点，修改改节点，自动生成的解析器并不能很灵活的支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自动生成的代码可读性差，排查问题成本高，复杂查询场景下，性能不足，影响系统稳定性和版本迭代速度；在设计之初，我们放弃了自动生成的技术方案，完全手工编写词法语法解析器。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;三  自研词法语法分析器的技术要点&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自动生成工具主要处理生成下图中左侧的 SQL Parser Core和 SQL Tree Nodes的部分，右侧featrues的部分需要开发同学处理，当右侧功能（例如：SQL rewriting）对左侧有的Tree nodes的更改功能有更多的需求时，想修改自动生成的代码，则无从下手。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKmmDW8ABWYRJNbO5bRGfShD8xjKeWn7SrmvNjjUagdAGzLBLdibl7NNVz5INMXe8arZoOVXtJxNmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自动生成工具是面向生成通用语法解析器而设计的，针对SQL这一特定领域语言，有特定的优化技术提升稳定性和性能，从设计之初，我们选择LL(k)作为语法分析的算法，其自顶向下的特性，在手工编写分析器时，逻辑清晰，代码易读，方便开发和维护，LL(k)的“左递归”问题，可通过手工判定循环编程的方式避免。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1  词法和语法分析&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;词法分析中，Lexer持续读取连续SQL 文本，将具有某特征的一段连续文本标识为Token，并标识Token的类别，比如赋值语句 x = 30，经过词法分析后x, = , 30 分别被标识为ID、等号操作符、数值常量；尤其在识别标识符（变量，表名，列名等）和保留字（TABLE，FROM，SELECT等）需要对字符串进行反复对比。自动生成工具在这一阶段使用DFA（Deterministic Finite Automaton）和预先定义的词法文件，确定每个Token的值和类型，手工编写解析器不需要额外维护一个状态机，使用分支预测，减少计算量和调用堆栈的深度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;语法分析器会使用词法分析中的Token作为输入，以SQL语法描述作为规则，自顶向下，依次将非叶子节点展开，构建语法树，整个过程就像是走迷宫，只有一个正确入口和出口，走完迷宫后，会生成一个正确的AST。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;快速Token比较&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;selECT&lt;/span&gt; c1 &lt;span class=&quot;code-snippet__keyword&quot;&gt;From&lt;/span&gt; T1;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于大部分数据库系统对大小写不敏感，上述query中 selECT 和 From 会被识别为保留字，c1和T1会被识别为标识符。识别2者的类型不同，字符串匹配操作是必不可少的，通常将字符统一转为大写或者小写，再比较字面值，是一个可行的方案。首先把数据库保留字按照&lt;/span&gt;&lt;span&gt;Map&amp;lt;String, Token&amp;gt;&lt;/span&gt;&lt;span&gt;初始化在内存里，key是保留字的大写字符串，value是Token类型；其中key在作大写转化时，可使用ASCII值+32的方法取代&lt;/span&gt;&lt;span&gt;toUpperCase()&lt;/span&gt;&lt;span&gt;方法，在不影响正确性的前提下，获得数倍性能提升。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;快速数值分析&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在解析常量值时，通常的做法是读取SQL中的字符串，把字符串作为参数，调用Java自带的&lt;/span&gt;&lt;span&gt;Integer.parseInt() / Float.parseFloat() / Long.parseLong()&lt;/span&gt;&lt;span&gt;，可以直接在原文本上边读取边计算数值，该过程只使用基础类型，避免构造字符串，可以节省内存，又提升了解析速度，该优化对大批量写入数值的场景优化非常明显。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;避免回溯&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SQL语法解析过程中，通常只需要预读一个Token，就可以决定如何构建语法节点的关系，或者构建哪种语法节&lt;/span&gt;&lt;span&gt;点，有些语法分支较多，需要预读2个及以上的Token才可以做出判断，预读多个Token可以降低回溯带来的性能消耗，极少情况下，2个以上的Token预读都也没有匹配到正确的语法分支，需要撤销预读，走其他分支；&lt;/span&gt;&lt;span&gt;为了提高撤销的速度，可以在预读前保存Token位点，撤销时，可以快速回到保存点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在insert into values语句中，出现常量字面值的概率比出现其他的token要高，通过分支预测可以减少判断逻辑，避免回溯，提升性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;表达式替换&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Query rewriting[6]技术基于“关系代数”修改AST，保证正确性的前提下，使新的AST在具备更好的执行性能，例如：A，B两张表的大小相差悬殊，而且错误的Join顺序对数据库系统不友好，通过更改A，B表的Join顺序可以获得更高的执行性能。使用工具生成的解析器，通常不允许直接更改AST的节点，每次更改AST某个节点都需要重新构建整个AST，性能并不好。自研的Parser中，每个AST节点类实现都replace接口，只需要修改AST中的子树就可以达到改写的目的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Replaceable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Node expr, Node target)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BetweenNode&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Replaceable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Node            beginExpr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Node            endExpr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{...}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{...}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(SQLExpr expr, SQLExpr target)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expr == beginExpr) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            setBeginExpr(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (expr == endExpr) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            setEndExpr(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;其他优化&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;abstract&lt;/span&gt; List&amp;lt;Node&amp;gt; getChildren()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BetweenNode&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Node            beginExpr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Node            endExpr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Node&amp;gt; getChildren() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Arrays.&amp;lt;Node&amp;gt;asList(beginExpr, &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.endExpr);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; BetweenNode clone() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        BetweenNode x = new BetweenNode();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (beginExpr != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            x.setBeginExpr(beginExpr.clone());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (endExpr != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            x.setEndExpr(endExpr.clone());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void setBeginExpr(Node beginExpr) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (beginExpr != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            beginExpr.setParent(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.beginExpr = beginExpr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void setEndExpr(Node endExpr) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (endExpr != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            endExpr.setParent(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;.endExpr = endExpr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2  语义分析&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;写入事件回调&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面提到大批量导入数据时，词法语法分析阶段会产生很多AST小对象，给垃圾回收带来压力，解决这个问题的核心是要尽量使用基础数据类型，尽量不要产生AST 节点对象。需要从词法分析阶段入手，避免进入语法分析阶段。在词法分析阶段，允许外部注册实现了写入接口的类，每当词法分析器解析出values中的每个具体值，或者完整解析出values中的一行，同时回调写入接口，实现数据库写入逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;InsertValueHandler&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;Object &lt;span class=&quot;code-snippet__title&quot;&gt;newRow&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws SQLException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processInteger&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, Number &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processString&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, String &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processDate&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, String &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processDate&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, java.util.Date &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processTimestamp&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, String &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processTimestamp&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, java.util.Date &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processTime&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, String &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processDecimal&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, BigDecimal &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processBoolean&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, boolean &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processNull&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processFunction&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; index, String funcName, Object... values&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processRow&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Object row&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;processComplete&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BatchInsertHandler&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;InsertValueHandler&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Application&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    BatchInsertHandler handler = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; BatchInsertHandler();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    parser.parseInsertHeader(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    parser.parseValues(handler); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Query Rewriting&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;手动编写的SQL Parser可以更灵活的与优化器配合，将Query rewriting 的部分优化能力前置化到SQL Parser中实现，使得优化器能更加专注于基于代价和成本的优化上。Parser可以结合Meta信息，利用“等价关系代数”，在AST上低成本实现Query Rewriting功能，以提升查询性能，例如：常量折叠、函数变换、条件下推或上提、类型推导、隐式转化、语义去重等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，需要设计一个结构存储catalog和table结构信息，包括库名，表名，列名，列类型等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，使用“访问者模式”编写Visitor程序，通过“深度优先”遍历AST，对字段、函数、表达式、操作符进行分析，结合表结构和类型信息，推断表达式类型，注意，嵌套的查询语句中，相同的表达式出现的位置不同，所属的作用域也不同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，AST会经过使用“等价关系代数”编写的RBO（Rule-Based Optimization）规则处理，达到优化器的目的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; T1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; c_week&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CAST&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;date_format&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;date_add&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;day&#x27;&lt;/span&gt;, -day_of_week(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20180605&#x27;&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                   &lt;span class=&quot;code-snippet__built_in&quot;&gt;date&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20180605&#x27;&lt;/span&gt;)), &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;%Y%m&amp;amp;d&#x27;&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;CAST&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;date_format&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;date_add&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;day&#x27;&lt;/span&gt;, -day_of_week(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20180606&#x27;&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                   &lt;span class=&quot;code-snippet__built_in&quot;&gt;date&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20180606&#x27;&lt;/span&gt;)), &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;%Y%m&amp;amp;d&#x27;&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;bigint&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; T1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; c_week &lt;span class=&quot;code-snippet__keyword&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;20180602&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;20180603&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; T1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DATE_FORMAT&lt;/span&gt;(t1.&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pay_time&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;%Y%m%d&#x27;&lt;/span&gt;) &amp;gt;= &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20180529&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DATE_FORMAT&lt;/span&gt;(t1.&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pay_time&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;%Y%m%d&#x27;&lt;/span&gt;) &amp;lt;= &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;20180529&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; T1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; t1.&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pay_time&quot;&lt;/span&gt; &amp;gt;= &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;2018-05-29 00:00:00&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;AND&lt;/span&gt; t1.&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pay_time&quot;&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;2018-05-30 00:00:00&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;四  最后&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;优化后的SQL Parser的性能和稳定性提升明显，以TPC-DS[7] 99个Query对比来看，手工编写的SQL Parser比ANTLR Parser（使用ANTLR生成）速度快20倍，比JSQLParser（使用JavaCC生成）速度快30倍，在批量Insert场景下，速度提升30~50倍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文通过介绍自动生成工具生成的词法语法分析器和自研分析器的利弊权衡和思考，结合OLAP的大吞吐，处理复杂SQL的业务特性，选择手工编写解析器。性能优化手段贴近SQL解析的特点；在语义分析层面，结合Schema信息沉淀了很多语义分析工具，在离线或在线SQL统计和特征分析方面更轻量化、便捷。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;关于我们&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎加入阿里云OLAP团队！我们专注于提供全球领先的OLAP产品AnalyticDB，AnalyticDB服务于阿里内外众多客户的核心业务，曾获得TPC-DS和TPC-H两项第一。如果你对数据库/大数据领域的产品技术、产品服务化、数据接入与分发、智能监控诊断感兴趣，欢迎联系 lijun.cailj@alibaba-inc.com，团队base地包括北京、杭州和深圳。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;参考文献&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;[1] Pattis, Richard E.&quot;EBNF: A Notation to Describe Syntax&quot;(PDF).ICS.UCI.edu.University of California, Irvine. p. 1. Retrieved 2021-02-26.&lt;/p&gt;&lt;p&gt;[2] Parr, Terence and Fisher, Kathleen (2011). &quot;LL (*) the foundation of the ANTLR parser generator&quot;.ACM SIGPLAN Notices.46(6): 425–436.doi:10.1145/1993316.1993548.&lt;/p&gt;&lt;p&gt;[3] Rosenkrantz, D. J.; Stearns, R. E. (1970).&quot;Properties of Deterministic Top Down Grammars&quot;.Information and Control.17(3): 226–256.doi:10.1016/s0019-9958(70)90446-8.&lt;/p&gt;&lt;p&gt;[4] Gurari, Eitan (1999).&quot;CIS 680: DATA STRUCTURES: Chapter 19: Backtracking Algorithms&quot;. Archived fromthe originalon 17 March 2007.&lt;/p&gt;&lt;p&gt;[5] Pirahesh, Hamid; Hellerstein, Joseph M.&quot;Extensible/Rule Based Query Rewrite Optimization in Starburst&quot;.citeseerx.ist.psu.edu. Retrieved 2020-04-06.&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;SQL Server on Linux入门教程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL Server数据库一直只提供Windows下的版本，2016年微软宣布推出可运行在Linux系统下的SQL Server数据库，该版本目前还是早期预览版本。本课程主要介绍SQL Server On Linux的基本知识。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;点击“阅读原文”，开始学习吧~&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b317e849c74c1f8e45dfec2481f85f61</guid>
<title>提高 VS Code 编辑器性能的 5 个技巧</title>
<link>https://toutiao.io/k/k62tnvn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDz5QkU1Jn5ib3XLQWj39hYRPUEwPQAcXuQFE973tLe8hdYUA9GIh9TXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;4000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Visual Studio Code于2015年11月18日发布。五年过去了，它已经成为世界上最成功的编辑之一。它是在MIT许可下发布的，这使得它可以免费使用。其成功的关键是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，VS Code 在以下平台上原生可用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;OS X Yosemite (10.10+)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Windows 7 (with .NET Framework 4.5.2), 8.0, 8.1 and 10 (32-bit and 64-bit)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux (Debian): Ubuntu Desktop 16.04, Debian 9&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux (Red Hat): Red Hat Enterprise Linux 7, CentOS 8, Fedora 24&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它也可以在任何现代浏览器中运行，但功能有限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其巨大的平台可用性是因为它是一个在Electron上发布的web应用程序。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Electron（以前称为 Atom Shell）是由 GitHub 开发和维护的开源软件框架。它允许使用 Web 技术开发桌面 GUI 应用程序：它结合了 Chromium 渲染引擎和 Node.js 应用程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唯一的缺点是 Electron 可能非常耗资源，而且效率低于基于原生的应用程序，这意味着如果您不小心，它可能会变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你的 VS Code 是不是感觉有点迟钝？您希望它以更高性能的方式运行吗？今天，我们将研究可以帮助您充分利用它的五个技巧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基本要求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始优化之前，让我们看看我们是否符合 Visual Studio Code 团队推荐的最低硬件要求。我们需要至少 200 MB 的磁盘空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理器和内存建议：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看更详细的列表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.禁用未使用的内置功能&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VS Code 具有丰富的功能。但是，您可能对其中一些不感兴趣。因此，您可以禁用它们以提高编辑器的性能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File &amp;gt; Preferences &amp;gt; Settings &amp;gt; Files:Exclude&lt;/code&gt;：添加您不希望 VS Code 在您的项目中使用的任何文件模式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File &amp;gt; Preferences &amp;gt; Text Editor &amp;gt; Minimap &amp;gt; Enabled&lt;/code&gt;：复选框禁用/启用小地图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File &amp;gt; Preferences &amp;gt; Text Editor &amp;gt; Suggestions&lt;/code&gt;：在这里，您可以微调与建议相关的任何内容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File &amp;gt; Preferences &amp;gt; Text Editor &amp;gt; From on save / Format on paste&lt;/code&gt;：例如，您可以在保存时禁用格式并将其推迟到预提交。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File &amp;gt; Preferences &amp;gt; Application &amp;gt; Telemetry&lt;/code&gt;：遥测技术可能会影响性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File &amp;gt; Preferences &amp;gt; Text Editor &amp;gt; Code lens&lt;/code&gt;：你可以禁用/启用代码透镜功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 做一个扩展极简主义者&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有大量的扩展程序可用。然而，这并不意味着你需要它们全部。只添加对你的日常生产生活有直接影响的那些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在添加任何扩展之前，问问自己：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这不是已经内置于VS Code中了吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这不仅仅是一件一次性的事情吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它真的对你的日常工作有影响吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这是适合你使用情况的最佳工具吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它有很好的评价吗？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 将扩展绑定到工作区&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在许多不同的项目上工作，有不同的代码栈，你可能会发现自己安装了很多扩展。这很容易对性能产生影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个技巧是将你的扩展与你的工作空间结合起来。这样，你就知道你只是在加载该工作区所需的插件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您需要做的就是浏览所有可用的插件并禁用特定工作区不需要的插件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30513176144244103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDLCWZuCd9T5wicJotz4hZu73Yfjx5zgBuTo7mOftc3Zl8l4ib3s9xXVVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot;/&gt;&lt;figcaption&gt;禁用工作区插件的示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始它可能看起来像是一项耗时的任务，但从长远来看它是值得的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1623398612243&quot; data-category_id_list=&quot;48|26|37|54|53|42|43&quot; data-id=&quot;1623398612243&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 监控插件的加载时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦你有了编码所需的最低限度的插件，你可以检查它们的性能。VS Code 附带了一些您可以利用的开发人员选项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您可以通过执行 &lt;code&gt;cmd + p &amp;gt; Developer: Show Running Extensions&lt;/code&gt; 轻松监控所有这些插件的启动时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17726161369193155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDaqW3RWm0oFG9jYiacZiaicehqqEDecNxg2Q9AbOWzSGZEhbfw7IKdgzNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;figcaption&gt;运行扩展命令的示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你将得到一个你所有的活动扩展和它们的激活时间的列表。作为一个一般的经验法则，你可能想仔细检查任何需要超过300毫秒的东西。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6145426114151681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDxuuI78UNJDGjqJKFb1FEOOQ8ibFFdVk8bMFlbU1JnAzwykEwycdYWgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;figcaption&gt;运行扩展命令的示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想更深入地了解，你可以通过点击记录按钮来分析他们中的任何一个。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2226233453670277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDHptxCLJLcAY8uJKWFwLQemLIYLnXU6y36WmhfhAibqTfXTMhUk4bQibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;&lt;figcaption&gt;分析扩展&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您想清楚地了解 VS Code 启动时发生的所有事情，您可能需要查看 &lt;code&gt;cmd + p &amp;gt; Developer Startup Performance&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.12375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDZCBnqKH771S8XSuZBDMo0ibozibDPTo5yXU3jpUic6H3f6dG91KqQGY2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;启动性能命令示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你将获得以下信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDxbjiago27KzCcRIGgWjK7oN9ZAOfp976AiabWVgp8icxiaZxXmicZDSjSFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它对你的VS Code的性能给出了一个很好的概述。当试图断定任何变化对性能的影响时，它很有用。做定期检查是一个很好的习惯，以确保一切都在顺利地运行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 微调你的配置运行时参数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些情况下，你可能需要进一步配置VS Code的启动。你可以通过在命令行中使用参数来做到这一点。在 &lt;code&gt;argv.json&lt;/code&gt; 文件中很容易进行配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行&lt;code&gt;CMD + Shift + P &amp;gt; Configure Runtime Arguments&lt;/code&gt;.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11412429378531073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlDcFrvuK0xvLv6iaiaKU5xKMmdDrs546dxibIzu1ZiaDz5HrCIsclomGug4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后用你所有的自定义配置编辑 &lt;code&gt;argv.json&lt;/code&gt; 文件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7320075757575758&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AMVKhNcvMS4CRhNa1nrlUlD0xzKlP9yQORTI42FkZlibXxIpXtVyQh7ysmd8QibReica66Zl6T2xd5Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;figcaption&gt;用于配置运行时参数的文件&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后的想法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VS Code是一个伟大的广泛使用的IDE。它非常灵活，可高度定制。然而，这也是有代价的。请确保你了解你正在添加的内容和你如何加载它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始，为你自己做的任何小任务添加插件似乎都比较容易。随着时间的推移，为了寻找更高性能的编辑器，这种扩展开始逐渐消失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我希望所有这些技巧都能帮助您加快 VS Code 编辑器的速度并享受更好的编码体验。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section&gt;&lt;span&gt;原文：https://betterprogramming.pub/5-tips-to-boost-the-performance-of-your-vs-code-editor-ff28dda68d9b&lt;br/&gt;&lt;span&gt;作者：Jose Granja&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>