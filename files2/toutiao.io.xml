<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2fc8817ef976116c28cdbb3b39e106cc</guid>
<title>厉害了！国外顶级计算机大神耗时两年时间整理出来这份 2000 页深入理解计算机系统笔记</title>
<link>https://toutiao.io/k/4hjd6qw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;h1&gt;&lt;strong&gt;计算机系统类别的课程一直是计算机科学与技术专业的主要教学内容之一。由于历史原因，我国的计算机专业的课程体系曾广泛参考ACM和 IEEE 制订的计算机科学与技术专业教学计划(Computing Curricula)设计，计算机系统类课程也参照该计划分为汇编语言、操作系统、组成原理、体系结构、计算机网络等多门课程。应该说，该课程体系在历史上对我国的计算机专业教育起很好的引导作用。&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;进入新世纪以来，计算技术发生了重要的发展和变化，我国的信息技术和产业也得到了迅猛发展，对计算机专业的毕业生提出了更高要求。重新审视原来我们参照 ACM/IEEE计算机专业计划的课程体系，会发现存在以下几个方面的主要问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;1)课程体系中缺乏一门独立的能够贯穿整个计算机系统的基础课程。计算机系统方面的基础知识被分成了很多门独立的课程，课程内容彼此之间缺乏关联和系统性。学生学习之后，虽然在计算机系统的各个部分理解了很多概念和方法，但往往会忽视各个部分之间的关联，难以系统性地理解整个计算机系统的工作原理和方法。&lt;/li&gt;&lt;li&gt;2)现有课程往往偏重理论，和实践关联较少。如现有的系统课程中通常会介绍函数调用过程中的压缩和退栈方式，但较少和实践关联来理解压栈和退栈过程的主要作用。实际上，压栈和退栈与理解C等高级语言的工作原理息息相关，也是常用的攻击手段 Buffer Overflow的主要技术基础。&lt;/li&gt;&lt;li&gt;3）教学内容比较传统和陈旧，基本上是早期PC时代的内容。比如，现在的主流台式机CPU都已经是x86-64指令集，但较多课程还在教授80386 甚至更早的指令集。对于近年来出现的多核/众核处理器、SSD硬盘等实际应用中遇到的内容更是涉及较少。&lt;/li&gt;&lt;li&gt;4）课程大多数从设计者的角度出发，而不是从使用者的角度出发。对于大多数学生来说，毕业之后并不会成为专业的CPU设计人员、操作系统开发人员等，而是会成为软件开发工程师。对他们而言,最重要的是理解主流计算机系统的整体设计以及这些设计因素对于应用软件开发和运行的影响。&lt;/li&gt;&lt;/ul&gt;
&lt;h1&gt;因此小编找出了一系列计算机相关书籍，给大家分享出来：&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/1c0a6d8c89d741a3b9c0d857e140cd3e.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;需要获取的小伙伴可以直接私信（学习）获取&lt;/p&gt; 
&lt;h1&gt;《深入理解计算机系统》775页&lt;/h1&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/db42d51bd30a2f052779c7c5b162632d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;本书从程序员的视角详细阐述计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。全书共12章，主要包括信息的表示和处理、程序的机器级表示、处理器体系结构、优化程序性能、存储器层次结构、链接、异常控制流、虚拟存储器、系统级1/O、网络编程、并发编程等内容。书中提供了大量的例子和练习题，并给出部分答案，有助于读者加深对正文所述概念和知识的理解。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h1&gt;内容介绍&lt;/h1&gt; 
&lt;h1&gt;第一部分程序结构和执行&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第1章计算机系统漫游&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/733227c2df8e90f4b507e1289e7369f3.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第2章信息的表示和处理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/71621d9db998a6c05e1c75930fe0093b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章程序的机器级表示&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/3ff25eeb229627f7b8fa92c076223a93.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章处理器体系结构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/c737f539a90e4e10a1481d1cfe01e159.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第5章优化程序性能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/fb6555bbcd4a8573201181ba7dc25ed5.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章存储器层次结构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/cdef5b312ae2704fb1a9798e7a05f5fc.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;第二部分在系统上运行程序&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第7章链接&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/70d5adf258f81ea4580dbf5fec513d03.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第8章异常控制流&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d16e568aa4216e22a167c56929581828.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章虚拟内存&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f32439db6d77c65287fa69efdae8661b.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;第三部分程序间的交互和通信&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第10章系统级i/O&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7c0ad8147c69c64e864344663673b235.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章网络编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ad4dbc387f59065c84f430a25d044c73.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章并发编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/257113b58614996b5663806590565dd5.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;因为这份文档有700多页下面还有很多需要展示。就不给大家一一展示了，需要获取的小伙伴可以直接转发+关注后添加小助理vx：maxiaoanan&lt;/strong&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/2020112115595614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzU5MjA=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt; 
&lt;h1&gt;《逻辑与计算机设计基础》500页&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/34ca9f7448c8c5db403cf173920a9c88.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;除了提供完整的数字和计算机设计内容之外，第5版还特别强调现代设计的基本原理。从简单的组合逻辑应用到在RISC核上构建CISC结构，多个例子的清晰解释和渐进式的设计过程可以诠释书中内容。完整的传统内容包括计算机辅助设计、问题形式化、解决方案验证，以及综合能力培养，而灵活性则体现在可选的逻辑设计、数字系统设计和计算机设计,以及硬件描述语言的相关内容中(不选、选用VHDL或选用Verilog)。&lt;/strong&gt;&lt;/p&gt; 
&lt;h1&gt;内容介绍&lt;/h1&gt; 
&lt;h1&gt;逻辑设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第1章介绍数字计算机、计算机系统抽象层次、嵌入式系统，以及包括数制、算术运算和编码在内的信息表示。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d88d685d80b1117b5d47532e2cce0c2d.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第⒉章研究门电路和它们的类型，以及设计和成本优化的基本方法。概念包括布尔代数、代数优化和卡诺图优化、传播延迟，以及在VHDL和Verilog 中使用结构和数据流模型表示的门级硬件描述语言模型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/1cb8d36a92d5cede5d3003d263957612.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章从一个现代逻辑设计过程的概述开始，设计过程的详细步骤包括问题形式化、逻辑优化、用于非门和或非门进行工艺映射，组合逻辑设计的实例中还包括验证。另外，这一章还包括函数和构建组合设计模块，包括使能和输入定值、译码、编码、代码转换、选择、分配、加法、减法、递增、递减、填充、扩展和移位以及它们的实现。本章还包括许多逻辑模块的VHDL和Verilog模型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/e074d5d45603143fc62990abd61c9f72.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章包括时序电路分析和设计。讨论了锁存器和边沿触发式触发器，并着重讲解了D触发器。本章的重点是状态机图和状态表的形式化表示。时序电路完整的设计过程包括规格说明、形式化、状态分配、触发器输入和输出方程确定、优化、工艺映射以及验证。时序电路通常都太复杂，不能用传统的状态图来表示，但可以用状态机图模型来表示，这一章通过现实世界的两个例子来阐述和说明这一观点。这一章包括用VHDL 和 Verilog来描述触发器和时序电路，介绍了VHDL和 Verilog程序行为的语言结构以及用于验证的测试程序。本章最后介绍了时序电路的延迟和定时，以及异步输入的同步和亚稳态问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/ca82efbac23826d32dd5f7c9c3628935.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;数字系统设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第5章重点介绍当前技术的各个方面，包括MOS晶体管和CMOS电路，以及可编程逻辑技术。可编程逻辑包括只读存储器、可编程逻辑阵列、可编程阵列逻辑和FPGA。这一章包括一些例子，它们用一个简单的FPGA结构来解释在更为复杂的商用FPGA硬件中出现的各种各样的可编程元器件。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/384b6bd71e033390ed5a8945d4023020.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章讲解寄存器及其应用。移位寄存器和计数器的设计基于第3章和第4章所讲解的触发器和某些函数及其实现。只有行波计数器作为--个全新的概念加以介绍。讨论了寄存器传输的并行和串行方式，以及如何权衡时间与空间开销。其中有一节侧重于执行多种运算的多功能寄存器的寄存器单元设计。数据通路和控制单元的协同设计过程使用了寄存器传输语言和状态截图，并且用现实世界的两个例子对其进行了解释。对所选的寄存器类型也用Verilog和VHDL语言进行了描述。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/2832cbd579efcab38fd25af2f315df95.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第7章介绍静态随机访问存储器（SRAM）和动态随机访问存储器（DRAM)，以及基本存储器系统,还简单地介绍了动态随机访问存储器的各种不同类型。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/fbdc7459391a69dde5ae7e261c0723bb.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;计算机设计&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;第8章讲述寄存器文件、功能单元、数据通路，以及两种简单计算机——单周期计算机和多周期计算机。重点讨论数据通路和控制单元设计的形式化概念，以及用它们来设计具有特定指令和指令集的单周期和多周期计算机。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d114fef46455e2bfe1e8e2e1142615f3.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章介绍与指令集结构相关的许多内容，包括地址计算、寻址模式、指令结构和类型，并讲解浮点数表示法和浮点运算，以及程序控制方法，包括过程调用与中断。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/31613ef3488d442902db7aee58d3beab.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第10章讨论一些高性能处理器的概念，如流水式RISC和CISC处理器。通过将微编码硬件添加到修改了的RISC处理器上，CISC处理器可以使用RISC的流水线来执行CISC指令集，这是当今CISC处理器中使用的一种方法。除此之外，还介绍了高性能CPU在概念和结构方面的创新，其中包括两个多CPU微处理器的例子。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/193f202708f5414c0d5ffdb951539438.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章讲解如何在CPU和内存之间、输入/输出接口和外围设备之间进行数据传送。讨论了键盘、液晶显示器（LCD)、硬盘驱动器等外部设备和键盘接口，以及包括通用串行总线(USB）在内的串行通信和中断系统的实现。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b5f46d8effbb16b3e5b5d97009e75096.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章重点讨论存储器的分层。介绍了“访问的局部性”的概念，并通过cache和内存之间、内存和硬盘之间的关系对其进行了详细讲解。分析了cache设计的各种参数。存储器管理重点关注分页管理和支持虚拟存储的传输后备缓冲器&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/52ba02cf9821ee200a0ce806f0f4ab70.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;h1&gt;《计算机文化》534页&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7e3f2f1dd4beb8e82c219c225988ae65.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第1章计算机和数字基础知识&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/5b820a3abc02490ba926f0f9d80ecf1a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第2章计算机硬件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/171461a384a60fab5051744cc54c899a.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第3章计算机软件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/af05bcf784e0cecb7501b4efeeb3f5e0.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第4章操作系统和文件管理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f0a5786be3cd11fe880e0f082a829f28.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第5章局域网&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7f274302024290dbd0e1b30a1cffae84.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第6章因特网&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d1b6784a1bcdf0a255b755e606329a48.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第7章Web 和电子邮件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/241173941142fe5bb7ca2d758e8a5bf0.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第8章数字媒体&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d9ad4a1729be775163fcc414b5710f09.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第9章计算机产业:历史、职业和道德&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/f70d11967db8b8b6835cb13eddc5b192.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第10章信息系统的分析与设计&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/7554c578c6aa02aac7b5eec12c357ba6.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第11章数据库&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/b90eab47eaa28d24cd25b6e7a37e2cbe.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第12章计算机编程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;世界级计算机大神花两年总结出2000页深入理解计算机系统文档&quot; src=&quot;https://img-blog.csdnimg.cn/img_convert/d5fe5603fee7b47e2c83f037a5b153f9.png&quot;/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;因为这份文档有700多页，下面还有很多需要展示。就不给大家一一展示了，需要获取的小伙伴可以直接转发+关注后&lt;/strong&gt;&lt;img alt=&quot;&quot; src=&quot;https://img-blog.csdnimg.cn/20201121160021406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzU5MjA=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e665ab28b13fc87c4fd4fb843fa9ff8a</guid>
<title>用 WebRTC 和 Node.js 开发实时视频聊天应用</title>
<link>https://toutiao.io/k/5shq47n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;话不多说，我们直奔主题。这篇文章教大家如何编写一个视频聊天应用，使已连接的两用户端能共享视频和音频。操作很简单，非常适合JavaScript语言训练——更准确地说是WebRTC技术和&lt;a href=&quot;https://tsh.io/services/web-development/node/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/services/web-development/node/&quot;&gt;Node.js&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;什么是WebRTC&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;Web Real-Time Communications 网页实时通信，简称WebRTC。WebRTC是一个HTML5规范，它允许用户在浏览器之间直接进行实时通信，不需要任何第三方插件。WebRTC可用于多种情境（比如文件共享），但端对端实时音频和视频通信是其主要功能。本文将着重为大家介绍这两项。&lt;/p&gt;



&lt;p&gt;WebRTC所做的就是允许接入设备。你可以借WebRTC来实时使用麦克风、摄像头和分享你的屏幕。&lt;/p&gt;



&lt;p&gt;所以，WebRTC可以用最简单的方式在网页中实现音频和视频通信。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;WebRTC JavaScript API&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC说起来很复杂，它涉及到很多技术。但建立连接、通信和传输数据的操作是通过一套JS API来实现的，还比较简单。其中主要的API包括：&lt;/p&gt;



&lt;p&gt;RTCPeerConnection：创建和导航端对端连接。&lt;/p&gt;



&lt;p&gt;RTCSessionDescription：描述连接（或潜在连接）的一端，以及它的配置方式。&lt;/p&gt;



&lt;p&gt;navigator.getUserMedia：捕捉音频和视频。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;为什么选择Node.js&lt;/strong&gt;&lt;strong&gt;？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;若要在两个或多个设备之间进行远程连接，你就需要一个服务器。在这种情况下，你也需要一个处理实时通信的服务器。Node.js是为实时可扩展的应用而构建的。要开发自由数据交换的双向连接应用程序，你可能会用到WebSockets，它允许在客户端和服务器之间建立一个会话窗口。来自客户端的请求会以循环的方式，更准确的说是事件循环进行处理，这时Node.js是我们很好的一个选择，因为它采取 “非阻塞（non-blocking） “的方式来解决请求。这样我们在这该过程中就能实现低延迟和高吞吐量。&lt;/p&gt;



&lt;p&gt;如果你对开发微服务感兴趣的话，一定要看看查看我们内含650多位微服务专家意见的&lt;a href=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://tsh.io/state-of-microservices/?utm_source=tsh.www&amp;amp;utm_medium=referral&amp;amp;utm_campaign=soms_report&amp;amp;utm_content=tshblogc2a&quot;&gt;2020年微服务状态报告&lt;/a&gt;！&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;思路拓展：我们要创建的是什么？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们会创建一个非常简单的应用程序，它能让我们将音频和视频流传输到连接的设备——一个基础款视频聊天应用程序。我们会用到的技术有:&lt;/p&gt;



&lt;p&gt;Express库，提供静态文件，比如代表用户界面（UI）的HTML文件；&lt;/p&gt;



&lt;p&gt;socket.io库，在两个设备之间用WebSockets建立连接；&lt;/p&gt;



&lt;p&gt;WebRTC，允许媒体设备（摄像头和麦克风）在连接的设备之间传输音频和视频流。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;实现视频会话&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们要做的第一件事是给我们的应用程序提供一个作为UI的HTML文件。让我们通过运行：npm init.js来初始化新的node.js项目。然后，我们需要通过运行：npm i -D typescript ts-node nodemon @types/express @types/socket.io安装一些开发依赖项，运行：npm i express socket.io安装生产依赖项。&lt;/p&gt;



&lt;p&gt;之后我们就可以在package.json文件中定义脚本，来运行我们的项目了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;{
 &quot;scripts&quot;: {
   &quot;start&quot;: &quot;ts-node src/index.ts&quot;,
   &quot;dev&quot;: &quot;nodemon --watch &#x27;src/**/*.ts&#x27; --exec &#x27;ts-node&#x27; src/index.ts&quot;
 },
 &quot;devDependencies&quot;: {
   &quot;@types/express&quot;: &quot;^4.17.2&quot;,
   &quot;@types/socket.io&quot;: &quot;^2.1.4&quot;,
   &quot;nodemon&quot;: &quot;^1.19.4&quot;,
   &quot;ts-node&quot;: &quot;^8.4.1&quot;,
   &quot;typescript&quot;: &quot;^3.7.2&quot;
 },
 &quot;dependencies&quot;: {
   &quot;express&quot;: &quot;^4.17.1&quot;,
   &quot;socket.io&quot;: &quot;^2.3.0&quot;
 }
}&lt;/pre&gt;



&lt;p&gt;当我们运行npm run dev命令时，nodemon会监控src文件夹中每个以.ts结尾的文件有无任何变化。现在，我们要创建一个src文件夹。在这个文件夹中，我们会创建两个typescript文件：index.ts和server.ts。&lt;/p&gt;



&lt;p&gt;在server.ts中，我们会创建server类，并使其与express和socket.io一起工作。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import express, { Application } from &quot;express&quot;;
import socketIO, { Server as SocketIOServer } from &quot;socket.io&quot;;
import { createServer, Server as HTTPServer } from &quot;http&quot;;
 
export class Server {
 private httpServer: HTTPServer;
 private app: Application;
 private io: SocketIOServer;
 
 private readonly DEFAULT_PORT = 5000;
 
 constructor() {
   this.initialize();
 
   this.handleRoutes();
   this.handleSocketConnection();
 }
 
 private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 }
 
 private handleRoutes(): void {
   this.app.get(&quot;/&quot;, (req, res) =&amp;gt; {
     res.send(`&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;`); 
   });
 }
 
 private handleSocketConnection(): void {
   this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     console.log(&quot;Socket connected.&quot;);
   });
 }
 
 public listen(callback: (port: number) =&amp;gt; void): void {
   this.httpServer.listen(this.DEFAULT_PORT, () =&amp;gt;
     callback(this.DEFAULT_PORT)
   );
 }
}&lt;/pre&gt;



&lt;p&gt;为正常运行服务器，我们需要在index.ts文件中创建一个新的Server类实例并调用listen方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;import { Server } from &quot;./server&quot;;
 
const server = new Server();
 
server.listen(port =&amp;gt; {
 console.log(`Server is listening on http://localhost:${port}`);
});&lt;/pre&gt;



&lt;p&gt;现在，如果我们运行：npm run dev会看到下面这样的情景：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-1_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;当打开浏览器，输入&lt;a href=&quot;http://localhost:5000/&quot;&gt;http://localhost:5000&lt;/a&gt;，我们应该注意到左上的 “Hello World “信息。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-2_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们就可以在public/index.html中创建一个新的HTML文件了。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
 &amp;lt;head&amp;gt;
   &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
   &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;
   &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt;
   &amp;lt;title&amp;gt;Dogeller&amp;lt;/title&amp;gt;
   &amp;lt;link
     href=&quot;https://fonts.googleapis.com/css?family=Montserrat:300,400,500,700&amp;amp;display=swap&quot;
     rel=&quot;stylesheet&quot;
   /&amp;gt;
   &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&amp;gt;
   &amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;container&quot;&amp;gt;
     &amp;lt;header class=&quot;header&quot;&amp;gt;
       &amp;lt;div class=&quot;logo-container&quot;&amp;gt;
         &amp;lt;img src=&quot;./img/doge.png&quot; alt=&quot;doge logo&quot; class=&quot;logo-img&quot; /&amp;gt;
         &amp;lt;h1 class=&quot;logo-text&quot;&amp;gt;
           Doge&amp;lt;span class=&quot;logo-highlight&quot;&amp;gt;ller&amp;lt;/span&amp;gt;
         &amp;lt;/h1&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/header&amp;gt;
     &amp;lt;div class=&quot;content-container&quot;&amp;gt;
       &amp;lt;div class=&quot;active-users-panel&quot; id=&quot;active-user-container&quot;&amp;gt;
         &amp;lt;h3 class=&quot;panel-title&quot;&amp;gt;Active Users:&amp;lt;/h3&amp;gt;
      &amp;lt;/div&amp;gt;
       &amp;lt;div class=&quot;video-chat-container&quot;&amp;gt;
         &amp;lt;h2 class=&quot;talk-info&quot; id=&quot;talking-with-info&quot;&amp;gt; 
           Select active user on the left menu.
         &amp;lt;/h2&amp;gt;
         &amp;lt;div class=&quot;video-container&quot;&amp;gt;
           &amp;lt;video autoplay class=&quot;remote-video&quot; id=&quot;remote-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
           &amp;lt;video autoplay muted class=&quot;local-video&quot; id=&quot;local-video&quot;&amp;gt;&amp;lt;/video&amp;gt;
         &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
     &amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;script src=&quot;./scripts/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;



&lt;p&gt;在这个新文件中，我们创建了两个视频元素：一个用于远程视频连接，另一个用于本地视频。你可能已经注意到我们也在导入本地脚本了。现在我们就来创建一个新的文件夹“脚本”，并在这个目录下创建index.js文件。至于样式，你可以从&lt;a href=&quot;https://github.com/Miczeq22/simple-chat-app&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;GitHub库&lt;/a&gt;中下载它们。&lt;/p&gt;



&lt;p&gt;接下来你需要给浏览器提供index.html。首先，你需要告诉express你想提供哪些静态文件。为了实现这一点，我们决定在Server类中实现一个新方法。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private configureApp(): void {
   this.app.use(express.static(path.join(__dirname, &quot;../public&quot;)));
 }&lt;/pre&gt;



&lt;p&gt;不要忘记在initialize中调用configureApp。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private initialize(): void {
   this.app = express();
   this.httpServer = createServer(this.app);
   this.io = socketIO(this.httpServer);
 
   this.configureApp();
   this.handleSocketConnection();
 }&lt;/pre&gt;



&lt;p&gt;当你输入&lt;a href=&quot;http://localhost:5000&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;http://localhost:5000&lt;/a&gt;后，你应该能看到你的index.html文件在运行。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-3_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;下一步要实现的是允许摄像头和视频访问并将其流式传输到local-video元素。要做到这一点，你需要打开public/scripts/index.js文件，并用以下方法实现它。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;当回到浏览器时，界面会出现一个提示请求访问你的媒体设备，在接受请求后，你电脑的摄像头就开始工作了。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-4_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;更多细节详见&lt;a href=&quot;https://tsh.io/blog/simple-guide-concurrency-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;A simple guide to concurrency in Node.js and a few traps that come with it&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;如何处理socket&lt;/strong&gt;&lt;strong&gt;连接？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;接下来我们讲讲如何处理socket连接。我们需要将客户端与服务器连接起来。为此，我们将使用socket.io。在public/scripts/index.js中，添加以下代码：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;页面刷新后，电脑会弹出一条消息，显示 “Socket已连接”&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-5_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;然后我们回到server.ts中，把已连接的socket存储在内存中，这只是为了保留唯一连接。所以，我们需要在Server类中添加一个新的私有字段，如下：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;private activeSockets: string[] = [];&lt;/pre&gt;



&lt;p&gt;然后我们需要在socket连接中检查socket是否已经存在。如果不存在，把新的socket推送到内存中，并向已连接的用户发送数据。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;this.io.on(&quot;connection&quot;, socket =&amp;gt; {
     const existingSocket = this.activeSockets.find(
       existingSocket =&amp;gt; existingSocket === socket.id
     );
 
     if (!existingSocket) {
       this.activeSockets.push(socket.id);
 
       socket.emit(&quot;update-user-list&quot;, {
         users: this.activeSockets.filter(
           existingSocket =&amp;gt; existingSocket !== socket.id
         )
       });
 
       socket.broadcast.emit(&quot;update-user-list&quot;, {
         users: [socket.id]
       });
     }
   }&lt;/pre&gt;



&lt;p&gt;你还需要在socket断开连接时及时响应，所以在socket连接中，你需要添加：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;disconnect&quot;, () =&amp;gt; {
   this.activeSockets = this.activeSockets.filter(
     existingSocket =&amp;gt; existingSocket !== socket.id
   );
   socket.broadcast.emit(&quot;remove-user&quot;, {
     socketId: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;客户端(即public/scripts/index.js)这边，你需要妥善处理那些信息：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;update-user-list&quot;, ({ users }) =&amp;gt; {
 updateUserList(users);
});
 
socket.on(&quot;remove-user&quot;, ({ socketId }) =&amp;gt; {
 const elToRemove = document.getElementById(socketId);
 
 if (elToRemove) {
   elToRemove.remove();
 }
});&lt;/pre&gt;



&lt;p&gt;以下是 updateUserList 函数：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function updateUserList(socketIds) {
 const activeUserContainer = document.getElementById(&quot;active-user-container&quot;);
 
 socketIds.forEach(socketId =&amp;gt; {
   const alreadyExistingUser = document.getElementById(socketId);
   if (!alreadyExistingUser) {
     const userContainerEl = createUserItemContainer(socketId);
     activeUserContainer.appendChild(userContainerEl);
   }
 });
}&lt;/pre&gt;



&lt;p&gt;以及createUserItemContainer函数:&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;function createUserItemContainer(socketId) {
 const userContainerEl = document.createElement(&quot;div&quot;);
 
 const usernameEl = document.createElement(&quot;p&quot;);
 
 userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user&quot;);
 userContainerEl.setAttribute(&quot;id&quot;, socketId);
 usernameEl.setAttribute(&quot;class&quot;, &quot;username&quot;);
 usernameEl.innerHTML = `Socket: ${socketId}`;
 
 userContainerEl.appendChild(usernameEl);
 
 userContainerEl.addEventListener(&quot;click&quot;, () =&amp;gt; {
   unselectUsersFromList();
   userContainerEl.setAttribute(&quot;class&quot;, &quot;active-user active-user--selected&quot;);
   const talkingWithInfo = document.getElementById(&quot;talking-with-info&quot;);
   talkingWithInfo.innerHTML = `Talking with: &quot;Socket: ${socketId}&quot;`;
   callUser(socketId);
 }); 
 return userContainerEl;
}&lt;/pre&gt;



&lt;p&gt;需要注意的是，我们给用户容器元素添加了一个可以调用callUser函数的点击监听器——但现在，它可以是一个空的函数。接下来，当运行两个浏览器窗口（其中一个作为私人窗口）时，你应该注意到你的Web应用程序中有两个已经连接的socket。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-6_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;点击列表中的活跃用户，这时我们需要调用callUser函数。但是在实现之前，你还需要在window对象中声明两个类。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;const { RTCPeerConnection, RTCSessionDescription } = window;&lt;/pre&gt;



&lt;p&gt;我们会在callUser函数用到这两个类：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;async function callUser(socketId) {
 const offer = await peerConnection.createOffer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(offer));
 
 socket.emit(&quot;call-user&quot;, {
   offer,
   to: socketId
 });
}&lt;/pre&gt;



&lt;p&gt;现在我们要创建一个本地请求并发送给选定的用户。服务器会监听一个叫做call-user的事件、拦截请求并将其转发给选定的用户。让我们用server.ts来实现该操作：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-user&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;call-made&quot;, {
     offer: data.offer,
     socket: socket.id
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，你需要就call-made事件作出调整：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;call-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.offer)
 );
 const answer = await peerConnection.createAnswer();
 await peerConnection.setLocalDescription(new RTCSessionDescription(answer));
 
 socket.emit(&quot;make-answer&quot;, {
   answer,
   to: data.socket
 });
});&lt;/pre&gt;



&lt;p&gt;之后，在你从服务器得到的请求上设置一个远程描述，并为这个请求创建一个答复。对于服务器端，你只需要将适当的数据传递给选定的用户即可。然后我们再在server.ts里面添加一个监听器。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;make-answer&quot;, data =&amp;gt; {
   socket.to(data.to).emit(&quot;answer-made&quot;, {
     socket: socket.id,
     answer: data.answer
   });
 });&lt;/pre&gt;



&lt;p&gt;对于客户端，我们需要处理 answer-made 事件。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;socket.on(&quot;answer-made&quot;, async data =&amp;gt; {
 await peerConnection.setRemoteDescription(
   new RTCSessionDescription(data.answer)
 );
 
 if (!isAlreadyCalling) {
   callUser(data.socket);
   isAlreadyCalling = true;
 }
});&lt;/pre&gt;



&lt;p&gt;我们可以使用标志isAlreadyCalling，它能帮助确保我们只需调用一次用户。&lt;/p&gt;



&lt;p&gt;最后你需要做的是添加本地轨道，包括音频和视频到你的连接端。只有做到这一点，我们才能够与连接的用户共享视频和音频。要做到这一点，我们需要在navigator.getMediaDevice回调中调用peerConnection对象的addTrack函数。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;navigator.getUserMedia(
 { video: true, audio: true },
 stream =&amp;gt; {
   const localVideo = document.getElementById(&quot;local-video&quot;);
   if (localVideo) {
     localVideo.srcObject = stream;
   }
 
   stream.getTracks().forEach(track =&amp;gt; peerConnection.addTrack(track, stream));
 },
 error =&amp;gt; {
   console.warn(error.message);
 }
);&lt;/pre&gt;



&lt;p&gt;另外，我们还需要为ontrack事件添加一个适当的处理程序。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;peerConnection.ontrack = function({ streams: [stream] }) {
 const remoteVideo = document.getElementById(&quot;remote-video&quot;);
 if (remoteVideo) {
   remoteVideo.srcObject = stream;
 }
};&lt;/pre&gt;



&lt;p&gt;如图示，我们已经从传递的对象中获取了流，并改变了远程视频中的srcObject来使用接收到的流。所以现在当你点击活跃用户后，你应该建立一个视频和音频连接，像下图这样：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://tsh.io/wp-content/uploads/2019/11/how-to-write-a-real-time-video-chat-app-7_.png&quot; alt=&quot;&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;欲了解细节，请参阅：&lt;a href=&quot;https://tsh.io/blog/dependency-injection-in-node-js/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Node.js and dependency injection – friends or foes?&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;现在你知道如何编写一个视频聊天应用了吧！&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;WebRTC是一个很大的话题，内容非常庞杂。如果你想了解它的运作原理，就需要花很大功夫。幸运的是，我们可以访问易于使用的JavaScript API，它可以帮助我们创建很简洁的应用程序，例如视频共享、聊天应用程序等等。&lt;/p&gt;



&lt;p&gt;如果你想深入了解WebRTC，点击此&lt;a href=&quot;http://Node.js%20and%20dependency%20injection%20–%20friends%20or%20foes%3F&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;WebRTC官方文档的链接&lt;/a&gt;。另外，我也推荐你阅读&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;MDN的文档说明&lt;/a&gt;，它能帮助你更加了解此技术。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://tsh.io/blog/how-to-write-video-chat-app-using-webrtc-and-nodejs/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：Mikołaj Wargowski&lt;/p&gt;&lt;/blockquote&gt;



&lt;p/&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bd9782dd26b3b5c105866e1cdcaf410f</guid>
<title>Apache Kylin 的实践与优化</title>
<link>https://toutiao.io/k/anqfsl4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;销售业务的特点是规模大、领域多、需求密。美团到店餐饮擎天销售系统（&lt;/span&gt;&lt;span&gt;以下简称“擎天”&lt;/span&gt;&lt;span&gt;）作为销售数据支持的主要载体，不仅涉及的范围较广，而且面临的技术场景也非常复杂（&lt;/span&gt;&lt;span&gt;多组织层级数据展示及鉴权、超过1/3的指标需要精准去重，峰值查询已经达到数万级别&lt;/span&gt;&lt;span&gt;）。在这样的业务背景下，建设稳定高效的OLAP引擎，协助分析人员快速决策，已经成为到餐擎天的核心目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://kylin.apache.org/cn/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Apache Kylin&lt;/span&gt;&lt;/a&gt;&lt;span&gt;是一个基于Hadoop大数据平台打造的开源OLAP引擎，它采用了多维立方体预计算技术，利用空间换时间的方法，将查询速度提升至亚秒级别，极大地提高了数据分析的效率，并带来了便捷、灵活的查询功能。基于技术与业务匹配度，擎天于2016年采用Kylin作为OLAP引擎，接下来的几年里，这套系统高效地支撑了我们的数据分析体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020年，美团到餐业务发展较快，数据指标也迅速增加。基于Kylin的这套系统，在构建和查询上均出现了严重的效率问题，从而影响到数据的分析决策，并给用户体验优化带来了很大的阻碍。技术团队经过半年左右的时间，对Kylin进行一系列的优化迭代，包括维度裁剪、模型设计以及资源适配等等等，帮助销售业绩数据SLA从90%提升至99.99%。基于这次实战，我们沉淀了一套涵盖了“原理解读”、“过程拆解”、“实施路线”的技术方案。希望这些经验与总结，能够帮助业界更多的技术团队提高数据产出与业务决策的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题与目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;销售作为衔接平台和商家的桥梁，包含销售到店和电话拜访两种业务模式，以战区、人力组织架构逐级管理，所有分析均需要按2套组织层级查看。在指标口径一致、数据产出及时等要求下，我们结合Kylin的预计算思想，进行了数据的架构设计。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;560&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;310&quot; data-ratio=&quot;0.5604395604395604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajnGbt0AEtI4BUI0uo5z0MPJN6xOtONQiahiaLQQZmXfSejyYM0t3kicaOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;而Kylin计算维度组合的公式是2^N（&lt;/span&gt;&lt;span&gt;N为维度个数&lt;/span&gt;&lt;span&gt;），官方提供维度剪枝的方式，减少维度组合个数。但由于到餐业务的特殊性，单任务不可裁剪的组合个数仍高达1000+。在需求迭代以及人力、战区组织变动的场景下，需要回溯全部历史数据，会耗费大量的资源以及超高的构建时长。而基于业务划分的架构设计，虽能够极大地保证数据产出的解耦，保证指标口径的一致性，但是对Kylin构建产生了很大的压力，进而导致资源占用大、耗时长。基于以上业务现状，我们归纳了Kylin的MOLAP模式下存在的问题，具体如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;效率问题命中难（实现原理）&lt;/strong&gt;：构建过程步骤多，各步骤之间强关联，仅从问题的表象很难发现问题的根本原因，无法行之有效地解决问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;构建引擎未迭代（构建过程）&lt;/strong&gt;：历史任务仍采用MapReduce作为构建引擎，没有切换到构建效率更高的Spark。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源利用不合理（构建过程）&lt;/strong&gt;：资源浪费、资源等待，默认平台动态资源适配方式，导致小任务申请了大量资源，数据切分不合理，产生了大量的小文件，从而造成资源浪费、大量任务等待。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;核心任务耗时长（实施路线）&lt;/strong&gt;：擎天销售交易业绩数据指标的源表数据量大、维度组合多、膨胀率高，导致每天构建的时长超过2个小时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;SLA质量不达标（实施路线）&lt;/strong&gt;：SLA的整体达成率未能达到预期目标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在认真分析完问题，并确定提效的大目标后，我们对Kylin的构建过程进行了分类，拆解出在构建过程中能提升效率的核心环节，通过“原理解读”、“层层拆解”、“由点及面”的手段，达成双向降低的目标。具体量化目标如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5688622754491018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajejUzZWWLib7rYRw3MAAwibn1kyYRibElr6kYPFssuMibFGicIKeVheFygjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;835&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优化前提-原理解读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决效率提升定位难、归因难的问题，我们解读了Kylin构建原理，包含了预计算思想以及By-layer逐层算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据维度组合出所有可能的维度，对多维分析可能用到的指标进行预计算，将计算好的结果保存成Cube。假设我们有4个维度，这个Cube中每个节点（&lt;/span&gt;&lt;span&gt;称作Cuboid&lt;/span&gt;&lt;span&gt;）都是这4个维度的不同组合，每个组合定义了一组分析的维度（&lt;/span&gt;&lt;span&gt;如group by&lt;/span&gt;&lt;span&gt;），指标的聚合结果就保存在每个Cuboid上。查询时，我们根据SQL找到对应的Cuboid，读取指标的值，即可返回。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.896875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajGOqBgGODE6bqB1skc3NlAfDIhcLy7MmibCWtxWFUq6of8Auoia8E1QRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;By-layer逐层算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个N维的Cube，是由1个N维子立方体、N个（N-1）维子立方体、N*(N-1)/2个(N-2)维子立方体、……N个1维子立方体和1个0维子立方体构成，总共有 2^N个子立方体。在逐层算法中，按照维度数逐层减少来计算，每个层级的计算（除了第一层，由原始数据聚合而来），是基于上一层级的计算结果来计算的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如：group by [A,B]的结果，可以基于group by [A,B,C]的结果，通过去掉C后聚合得来的，这样可以减少重复计算，当0维Cuboid计算出来的时候，整个Cube的计算也就完成了。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.39752650176678445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajoibrlicAr12Eibick9rn7oxTNy9r8uNbyGeibv0A5S33Wrib3S45jyicd3bCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程分析-层层拆解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在了解完Kylin的底层原理后，我们将优化的方向锁定在“引擎选择”、“数据读取”、“构建字典”、“分层构建”、“文件转换”五个环节，再细化各阶段的问题、思路及目标后，我们终于做到了在降低计算资源的同时降低了耗时。详情如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5307291666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajEHClNJuAYp70NuLxbZiaPhk54iazOxu4KvZoZQfAjEfmZP3iaLIGyCnqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;构建引擎选择&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，我们已经将构建引擎已逐步切换为&lt;/span&gt;&lt;a href=&quot;http://spark.apache.org/docs/2.2.1/configuration.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。擎天早在2016年就使用Kylin作为OLAP引擎，历史任务没有切换，仅仅针对MapReduce做了参数优化。其实在2017年，Kylin官网已启用Spark作为构建引擎（&lt;/span&gt;&lt;a href=&quot;http://kylin.apache.org/cn_blog/2017/02/25/v2.0.0-beta-ready/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;官网启用Spark构建引擎&lt;/span&gt;&lt;/a&gt;&lt;span&gt;），构建效率相较MapReduce提升1至3倍，还可通过Cube设计选择切换，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.18429661941112324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajcU4mT6oKwkA84WaOaNaRmw2ZV5gwq1W3K8tWErMgZBHhY1slPfSyEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1834&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;读取源数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin以外部表的方式读取Hive中的源数据，表中的数据文件（&lt;/span&gt;&lt;span&gt;存储在HDFS&lt;/span&gt;&lt;span&gt;）作为下一个子任务的输入，此过程可能存在小文件问题。当前，Kylin上游数据宽表文件数分布比较合理，无需在上游设置合并，如果强行合并反而会增加上游源表数据加工时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于项目需求，要回刷历史数据或增加维度组合，需要重新构建全部的数据，通常采用按月构建的方式回刷历史，加载的分区过多出现小文件问题，导致此过程执行缓慢。在Kylin级别重写配置文件，对小文件进行合并，减少Map数量，可有效地提升读取效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;合并源表小文件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：合并Hive源表中小文件个数，控制每个Job并行的Task个数。调整参数如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12760416666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajV5xiahnHzYia2uibHfco1biaTjiaCWd4GPjINDo1sMd5aRjYARZ9SjDgJDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kylin级别参数重写&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：设置Map读取过程的文件大小。调整参数如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.08177083333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajOiasC4k0W1Yekriagiaia30Vo7dYXplCkPr0nsfPN4W8nApqHib4tKgiccRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;构建字典&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin通过计算Hive表出现的维度值，创建维度字典，将维度值映射成编码，并保存保存统计信息，节约HBase存储资源。每一种维度组合，称为一个Cuboid。理论上来说，一个N维的Cube，便有2^N种维度组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;组合数量查看&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对维度组合剪枝后，实际计算维度组合难以计算，可通过执行日志（&lt;/span&gt;&lt;span&gt;截图为提取事实表唯一列的步骤中，最后一个Reduce的日志&lt;/span&gt;&lt;span&gt;），查看具体的维度组合数量。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajZLnRSpmYicpH2nA6eLJDGjQ5s8zpuialhVjelAEql2q38DdA93qSVCug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;全局字典依赖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;擎天有很多业务场景需要精确去重，当存在多个全局字典列时，可设置列依赖，例如：当同时存在“门店数量”、“在线门店数量”数据指标，可设置列依赖，减少对超高基维度的计算。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3269088213491475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajXsC8WgUr32uE98MVeuhmvme9fsM1t1G3few2vh4D0o3y2H0Oc7R9icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;计算资源配置&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当指标中存在多个精准去重指标时，可适当增加计算资源，提升对高基维度构建的效率。参数设置如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12447916666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajA697gZlCla7xD73Bhkic3gL03BeicY7IwTauOSuLw58HF5xTWmdLqpzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分层构建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此过程为Kylin构建的核心，切换Spark引擎后，默认只采用By-layer逐层算法，不再自动选择（&lt;/span&gt;&lt;span&gt;By-layer逐层算法、快速算法&lt;/span&gt;&lt;span&gt;）。Spark在实现By-layer逐层算法的过程中，从最底层的Cuboid一层一层地向上计算，直到计算出最顶层的Cuboid（&lt;/span&gt;&lt;span&gt;相当于执行了一个不带group by的查询&lt;/span&gt;&lt;span&gt;），将各层的结果数据缓存到内存中，跳过每次数据的读取过程，直接依赖上层的缓存数据，大大提高了执行效率。Spark执行过程具体内容如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Job阶段&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Job个数为By-layer算法树的层数，Spark将每层结果数据的输出，作为一个Job。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5479166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajcy1NQRUnNCiceSQ67Ad2xAiclDicrJBZzzmKASNgibyriamg8SpxJNcibSMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Stage阶段&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个Job对应两个Stage阶段，分为读取上层缓存数据和缓存该层计算后的结果数据。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajpZuseQmXoZb3m5fSML1IQHx5RoFbNHs5ricYfiadutsaA4UG2KvjlnXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Task并行度设置&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin根据预估每层构建Cuboid组合数据的大小（&lt;/span&gt;&lt;span&gt;可通过维度剪枝的方式，减少维度组合的数量，降低Cuboid组合数据的大小，提升构建效率，本文暂不详细介绍&lt;/span&gt;&lt;span&gt;）和分割数据的参数值计算出任务并行度。计算公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源申请计算&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;平台默认采用动态方式申请计算资源，单个Executor的计算能力包含：1个逻辑CPU（&lt;/span&gt;&lt;span&gt;以下简称CPU&lt;/span&gt;&lt;span&gt;）、6GB堆内内存、1GB的堆外内存。计算公式如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  =  kylin.engine.spark-conf.spark.executor.cores * 实际申请的Executors个数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; =（kylin.engine.spark-conf.spark.executor.memory + spark.yarn.executor.memoryOverhead）* 实际申请的Executors个数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;单个Executor的执行能力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; = kylin.engine.spark-conf.spark.executor.memory / kylin.engine.spark-conf.spark.executor.cores，即：1个CPU执行过程中申请的内存大小。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最大Executors个数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; = kylin.engine.spark-conf.spark.dynamicAllocation.maxExecutors，平台默认动态申请，该参数限制最大申请个数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在资源充足的情况下，若单个Stage阶段申请1000个并行任务，则需要申请资源达到7000GB内存和1000个CPU，即：&lt;/span&gt;&lt;code&gt;&lt;span&gt;CPU：1*1000=1000；内存：（6+1）*1000=7000GB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源合理化适配&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于By-layer逐层算法的特性，以及Spark在实际执行过程中的压缩机制，实际执行的Task任务加载的分区数据远远小于参数设置值，从而导致任务超高并行，占用大量资源，同时产生大量的小文件，影响下游文件转换过程。因此，合理的切分数据成为优化的关键点。通过Kylin构建日志，可查看各层级的Cuboid组合数据的预估大小，以及切分的分区个数（&lt;/span&gt;&lt;span&gt;等于Stage阶段实际生成的Task个数&lt;/span&gt;&lt;span&gt;）。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12552083333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajjsicEicGyEribIEJfibcqeVbDblynZTe3jxN80MQxiaVQsPKO6BKcDjLuUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;结合Spark UI可查看实执行情况，调整内存的申请，满足执行所需要的资源即可，减少资源浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 整体资源申请最小值大于Stage阶段Top1、Top2层级的缓存数据之和，保证缓存数据全部在内存。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1546875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajJb4WVTIAbwqy3WCOF5PFuSaSTm501Gyf0ibvR709bW1UBFbKvMuSa5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;计算公式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Stage阶段Top1、Top2层级的缓存数据之和 &amp;lt; kylin.engine.spark-conf.spark.executor.memory * kylin.engine.spark-conf.spark.memory.fraction *   spark.memory.storageFraction *最大Executors个数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 单个Task实际所需要的内存和CPU（&lt;/span&gt;&lt;span&gt;1个Task执行使用1个CPU&lt;/span&gt;&lt;span&gt;）小于单个Executor的执行能力。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.35833333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajgDrbts2cRpNecf9YsAjdSQMmicC7DxvZ7v1P4kebPF7QMb9YtcNOerw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;计算公式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单个Task实际所需要的内存 &amp;lt; kylin.engine.spark-conf.spark.executor.memory * kylin.engine.spark-conf.spark.memory.fraction *   spark.memory.st·orageFraction / kylin.engine.spark-conf.spark.executor.cores。参数说明如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajOZ0CL4GysqS4UqibPUYV3C8GLXlrkvPOVZANGEiagiawFCZHdkDTibwDrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;文件转换&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kylin将构建之后的Cuboid文件转换成HTable格式的Hfile文件，通过BulkLoad的方式将文件和HTable进行关联，大大降低了HBase的负载。此过程通过一个MapReduce任务完成，Map个数为分层构建阶段输出文件个数。日志如下：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.22014925373134328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiaj39xxanbmBwnlHiabrfU9Goowbics6Tsd23tUib1bTayHXHakBG5lsx71A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1608&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;此阶段可根据实际输入的数据文件大小（&lt;/span&gt;&lt;span&gt;可通过MapReduce日志查看&lt;/span&gt;&lt;span&gt;），合理申请计算资源，避免资源浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算公式：Map阶段资源申请 = kylin.job.mr.config.override.mapreduce.map.memory.mb * 分层构建阶段输出文件个数。具体参数如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiaj4NkvcbcFXvuF4s5SQAtnhiajvz3n5YDdTuIpuozOnn2Bia5Wspa9djgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实施路线-由点及面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;交易试点实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通过对Kylin原理的解读以及构建过程的层层拆解，选取销售交易核心任务进行试点实践。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5789902280130294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajsr4O1RU0Yqv70dYzmL26TJBVaMmyAzoiceNGSFfG0SicYoGldu7SP1sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;实践结果对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对销售交易核心任务进行实践优化，对比调整前后资源实际使用情况和执行时长，最终达到双向降低的目标。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5129725722757599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajC9Ib8BvicOjlQA2pRCzd2NJDCJH1CMoG0mneBwYIgTbiatYNAQpJB9icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;成果展示&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源整体情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;擎天现有20+的Kylin任务，经过半年时间持续优化迭代，对比Kylin资源队列月均CU使用量和Pending任务CU使用量，在同等任务下资源消耗已明显降低。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.545933734939759&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajRjYiatvGcom2mL59pTcICmfYs7w6lPARWCwCPcFujoa8sQSNaicOGk3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;SLA整体达成率&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过了由点及面的整体优化，擎天于2020年6月SLA达成率达到100%。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6075268817204301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWGPXNw7vljTibViaZviaOHIiajgibaMbNlprgdrtQAGy0yibCMGWT0rxGlszPub1mrMYicYfkU6jvVL1yiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Apache Kylin在2015年11月正式成为Apache基金会的顶级项目。从开源到成为Apache顶级项目，只花了13个月的时间，而且它也是第一个由中国团队完整贡献到Apache的顶级项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，美团采用比较稳定的V2.0版本，经过近4年的使用与积累，&lt;span&gt;到店餐饮技术团队&lt;/span&gt;在优化查询性能以及构建效率层面都积累了大量经验，本文主要阐述了在Spark构建过程的资源适配方法。值得一提的是，Kylin官方在2020年7月发布了V3.1版本，引入了Flink作为构建引擎，统一使用Flink构建核心过程，包含数据读取阶段、构建字典阶段、分层构建阶段、文件转换阶段，以上四部分占整体构建耗时的95%以上。此次版本的升级也大幅度提高了Kylin的构建效率。详情可查看：&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/KYLIN-3758&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Flink Cube Build Engine&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回顾Kylin构建引擎的升级过程，从MapReduce到&lt;/span&gt;&lt;a href=&quot;http://spark.apache.org/docs/2.2.1/configuration.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，再到如今的Flink，构建工具的迭代始终向更加优秀的主流引擎在靠拢，而且Kylin社区有很多活跃的优秀代码贡献者，他们也在帮助扩大Kylin的生态，增加更多的新功能，非常值得大家学习。最后，美团到店餐饮技术团队再次表达对Apache Kylin项目团队的感谢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;岳庆，2019年加入美团，到店餐饮研发中心工程师。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d13eb8383f4251824bbc04c3ec69766e</guid>
<title>优秀！一鼓作气学会 “一致性哈希”，就靠这 18 张图了</title>
<link>https://toutiao.io/k/4jzvanq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，好久不见啦。最近快年底了，公司、部门事情太多：冲刺 KPI、做部门预算……所以忙东忙西的，写文章就被耽搁了。再加上这篇文章比较硬，我想给大家讲得通俗易懂，着实花了很多时间琢磨怎么写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，小故事开始。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当架构师大刘看到实习生小李提交的&lt;strong&gt;记账流水乱序&lt;/strong&gt;的问题的时候，他知道没错了：这一次，大刘又要用一致性哈希这个老伙计来解决这个问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯，一致性哈希，分布式架构师必备良药，让我们一起来尝尝它。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 满眼都是自己二十年前的样子，让我们从哈希开始&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 N 年前，互联网的分布式架构方兴未艾。大刘所在的公司由于业务需要，引入了一套由 IBM 团队设计的业务架构。&lt;img data-ratio=&quot;0.3036551077788191&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D7sIlpicJLic12SYwcaNu4Uic5QYTXGYyWJUjjzxhO2HSHtHfmPLYToa0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2134&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套架构采用了分布式的思想，通过 RabbitMQ 的消息中间件来通信。这套架构，在当时的年代里，算是思想超前，技术少见的黑科技架构了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，由于当年分布式技术落地并不广泛，有很多尚不成熟的地方。所以，这套架构在经年日久的使用中，一些问题逐渐突出。其中，最典型的问题有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RabbitMQ 是个单点，它一坏掉，整个系统就会全部瘫痪。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收、发消息的业务系统也是单点。任何一点出现问题，对应队列的消息要么无从消费，要么海量消息堆积。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论哪种问题，最终是整套分布式系统都无法使用，后续处理非常麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 RabbitMQ 的单点问题，由于当时 RabbitMQ 的集群功能非常弱，普通模式有 queue 本身的单点问题，所以，最终使用了 Keepalived 配合了两台无关系的 RabbitMQ 搞出了高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于业务系统单点问题，从一开始着手解决的时候就出现了波折。一般来说，我们要解决单点问题，方法就是堆机器，堆应用。收发是单点，我们直接多部署几个应用就可以了。如果仅仅从技术上看，无非就是多个收发消息的应用大家一起竞争往 MQ 中放消息拿消息而已。&lt;img data-ratio=&quot;0.4117117117117117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D8BSZJAUgQic7XeJPFMNMhq00ApJ1kaheS5y9YwA8zb3dleHrH6wEVnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2220&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，恰恰就是在把收发消息的应用集群化后，系统出现了问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本身这套系统架构会被应用到公司的多类业务上，有些业务对消息的顺序有着苛刻的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，公司内部的 IM 应用，不管是点对点的聊天还是群聊消息，都需要对话消息严格有序。而当我们把生产消息和消费消息的应用集群化后，问题出现了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;聊天记录出现了乱序&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A 和 B 对话，会出现某些消息没有严格按照 A 发出的先后顺序被 B 接收，于是整个聊天顺序乱成了一锅粥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过排查，发现问题的根源就在于应用集群上。由于没有对应用集群收发消息做特殊的处理，当 A 发出一条聊天信息给B时，发送到 RabbitMQ 中的信息会被在 B 处的消费端所争抢。如果 A 在短时间内发出了几条信息，那么就可能会被集群中的不同应用抢走。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，乱序的问题就出现了。虽然应用业务逻辑是相同的，但是这些集群中的应用依然可能在处理信息速度上出现差异，最终导致用户看到的聊天信息错乱。&lt;img data-ratio=&quot;0.23345817727840198&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DUcPyQibryFGWpl6P1KxYNdaTZrMV42P4BlNkbJtrlVD2F2JicJxFGib4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1602&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题找到了，解决办法是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们说过了，消息顺序错乱是因为集群中不同应用抢消息然后处理速度不一样导致的。如果我们能保证 A 和 B 会话，从开始之后到会话结束之前，永远只会被 B 所在的消费消息集群应用中的同一个应用消费，那么我们就能保证消息有序。这样一来，我们就可以在消费消息的那个应用中，对抢到的消息进行排队，然后依次处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这种保证怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们在 RabbitMQ 中会建立有相同前缀的队列，后面跟着队列编号。然后，集群中的不同应用会分别监听这两个有着不同编号的队列。当在 A 发送信息时，我们会对信息做一次简单的哈希:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;m = hash(id) mod n&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，id 是用户的标识。n 是集群中 B 所在业务系统部署的数量。最终的 m 是我们需要发送到的目的队列编号。&lt;img data-ratio=&quot;0.22372528616024975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DzqFWE2y63npKberQ7A28iaw8Clicia6DvxRFEZqr86HbOAIU4ia9WIEwMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1922&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设，hash(id) 的结果为 2000，n 为 2，经过计算 m = 0。此时，A 就会把他和 B 的对话信息都发送到 chat00 的队列里。B 收到消息后，就会依次显示给终端用户。这样，聊天乱序的问题就解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，事情到此就结束了吗？这个解决方案是完美的吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 看来，我们需要增加应用数量了&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着公司的发展，公司的人数也急剧上升，公司内部的 IM 使用人数也跟着多了起来，新问题又随之出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最主要的问题是，人们收到聊天信息的速度变慢了。原因也很简单，收取聊天信息的集群机器不够用了。解决办法可以简单直接点，再加台机器就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，由于收消息的集群中新加入了一台机器，这时候，我们还需要额外多做一些事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们需要为新加入的这台机器上的应用额外再多增加一个队列 chat02。&lt;img data-ratio=&quot;0.566350710900474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DEry4OmAH7pSz8NhpbH48ACxlePK89S6YARQxicSqOs7pYteuj7IcCmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;422&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们还需要修改下我们的分配消息的规则，把原来的 hash(id) mod 2 修改为 hash(id) mod 3。&lt;img data-ratio=&quot;0.7585365853658537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DZ0CbFRiajCtpDGphjtyFXdMjXscA6rFrd6BNB2QjLngzKm7ppZs4TYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;410&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重新启动发送消息的项目，以便修改的规则生效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;把收消息的应用部署到新机器上。&lt;img data-ratio=&quot;1.0997229916897506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DJSJ2QSl17x2icLrUJicdiaKYjO3LjlOwrB9oUu8Hc57hMvUgQzeviaP04A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这时，一切还都在可控范围。开发人员只需要在需要的时候，新增加个队列，然后把我们的分配规则小小的修改下即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，他们不知道的是，暴风雨就要来了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 新的问题来了，也许这就是人生吧&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于公司内部很多人在使用这个 IM 工具。有些时候，为了方便，公司的客户还有一些合作方也用起了这个 IM。这让事情变得复杂了起来。起初，开发人员还是像往常一样，每当人们抱怨说收消息过慢的时候，他们就会加一台机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最糟糕的是，公司的客户也会抱怨，他们发现 IM 有时候彻底不可用。这可不是小事情。公司内部人员的问题还可以内部沟通解决。但是公司客户的问题，大意不得，因为这关系到公司产品的名誉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这到底是怎么一回事呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来，根本原因还在于每次修改完配置规则后的重启服务。每次修改完配置规则，就需要规划好一个恰当的停机时间，去重新对项目做个上线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这种方法在公司的客户也使用这个 IM 后就行不通了。因为公司的客户有不少是在国外的。也就是说，不管白天还是深夜，很可能总是有人在使用这个 IM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就迫使开发人员们，在增加机器时，还需要去和多方协调沟通出一个上线时间，然后发布公告，再去上线。这种反复沟通，再上线，再反复沟通，再上线直接把开发人员们折腾了个半死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往往沟通完，上线时间直接被放到了半个月以后。而在这半个月里，开发人员还要承受无数内部 IM 使用人的口水。费心竭力的沟通，声嘶力竭的解释，缺眠少觉的上线，这一切的一切推动着开发人员们必须对眼前这套技术方案作出改变了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 思路转起来，队列环起来&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的技术方案的需求本质就是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是分配消息规则变化还是集群机器添加都不能停机停服务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种情况，一个很好的解决方案就是如果我们对项目配置文件进行动态的定时检测，当发现变动时，刷新配置规则即可。&lt;img data-ratio=&quot;0.2762691853600944&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DiaAIZpUuTEA848bt4hcxfK9qU1l7Y3kGw7ME48qKTHQdJzQJT1R295Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切看上去很美好，采用了动态的定时检测后，每当我们需要新增集群中的机器时，我们只需要如下三个步骤了:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;增加一个队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改分配消息的规则&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署新的机器&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户毫无感知，开发人员们也不需要和用户们协调沟通出专门的上线安排。可是，这个方案也存在一些问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;随着我们的系统部署越来越多，我们需要手工修改规则的系统也越来越多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果消费机器宕机了，我们需要删除队列，同时还需要去删除修改分配消息的规则，等到机器恢复了，我们还要再把分配消息的规则改回去。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个分配消息的规则真讨厌啊，每次有变动，就要去关心这个分配消息的规则。有没有什么办法能把这个分配变得更自动化一些呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们假设在 MQ 中有 100 个收发聊天信息的队列（100：这是对我们的IM不可能达到的一个数字），我们只需要在配置规则中配置成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;m = hash(id) mod 100&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我们的发送消息的应用启动后，去动态的探测出真实的所有收发聊天信息的队列信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们通过哈希算出的编号发现没有真实对应的队列存在时，就根据一定的规则，去找到一个真实存在的队列，这个队列，就是我们要发消息的队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们做到这样，那么以后，每次队列有变化，无论增多还是减少，我们都不需要再去考虑分配规则的事情了，只需要移除有问题的队列或者增加有对应消费者的队列即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个思想，就是一致性哈希的思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，我们假设有个 100 个收发聊天信息的队列，并且这些队列处于一个环上。&lt;img data-ratio=&quot;0.7205882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92Dlfpf0P0V9ZfxpMwTH9k4DywCOBnJrSaeg9hbbAaXkia0Nm4QXQA0Npw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，我们获取到真实的收发聊天信息的队列数量，假设有 5 个。&lt;img data-ratio=&quot;0.24251497005988024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D9P8t8ThlzcBaPb4jTfcNoohXEgyafZPHyHgYHh35Ww8wDoRYEsjw7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，我们把真实的队列映射到我们第一步假设的环中。&lt;img data-ratio=&quot;0.9688581314878892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DLduZpibxZ77xC7Hiabwrp4iaqttLkrmm7gHZelAHUZgvxTGib2feB7cmmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;289&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四步，我们通过分配规则 hash(id) mod 100 计算出对应的队列编号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 hash(id) 的结果为 2000，那么算出的队列编号 m = 0。这时候，我们一查，发现对应编号 0 的 chat00 队列确实存在，那么就直接发送消息到 chat00 中。&lt;img data-ratio=&quot;0.8716417910447761&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DSiaHsmkh07XiaiakcsgX9L0dMvMkaWNUxktwEakzibbeFZe0dsibrb95dVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;335&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们的 hash(id) 的结果为 1999，那么算出的队列编号 m = 99。此时，我们去查队列映射关系，发现 99 编号并没有对应的真实队列。这时候怎么办？很简单，我们顺时针继续往下找，找到谁了呢？0 对应的 chat00 队列，这是真实存在的，这时候，我们就将消息发送到 chat00 队列中。&lt;img data-ratio=&quot;0.6904231625835189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DunpSomDkibNWpw6PggrPwu5jytxvhcPhUBRmuQ5UCXTianG6BORmGHjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;449&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面四步就是一个基本的一致性哈希算法了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这套一致性哈希算法满足我们不想总是更新消息分配规则的需求吗？让我们验证一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;假设我们需要在消费信息端集群增加一台机器&lt;/strong&gt;&lt;br/&gt;我们如果要增加一台机器，那么同时我们也需要在 MQ 中增加一个队列。这时候，我们的分配规则是 hash(id) mod 100，增加了队列后，真实的队列数假设为 6。此时，如果 hash(id) mod 100 的结果小于 6，那么分配的规则和没有增加机器的时候规则一样，以前分配到哪个队列，现在还是分配到哪个队列。但是对于结果等于 6 的情况，则发生了变化。信息会被自动分配给 chat05。当分配给 chat05 后，新的消费者就会自动开始进入正常工作了，我们不需要做任何人工干预，也不需要考虑分配规则的变化。&lt;/p&gt;&lt;p&gt;增加机器以前：&lt;img data-ratio=&quot;0.6887550200803213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DTLJNwKCJJI6ogxMOtzgaRLbIIZZibavibjvRugbke1sDVkNIYcKBzsSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot;/&gt;&lt;/p&gt;&lt;p&gt;增加机器之后：&lt;img data-ratio=&quot;0.6405228758169934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92Dw3XrRZMMP6NTyklkcxVeIkg1jyufUxnuJGwfTlolvdG6RMb1bDK2Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;假设消费信息端集群一台机器宕机了&lt;/strong&gt;&lt;br/&gt;模拟宕机，此时我们会去减少一个队列。减少后的真实队列数量为 5，则正好和增加队列相反，m = 5 时，那么行为不会有任何变化，以前分到哪个队列，还是分到哪个队列。如果 m = 6，由于已经不存在真实的队列了，就会做顺时针查找，结果找到 chat00，以前会分到 chat05 的就会被分到 chat00。而此时，chat00 由于正好有消费者，所以，系统的用户是毫无感知的，我们也专心修复我们机器即可。当机器恢复后，就会和新增机器一样，计算结果为 6 的信息会被重新分配回 chat05。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，我们可以看到，当我们引入一致性哈希后，我们不管新增机器还是集群机器宕机，我只需要跟随着机器的状态，做一个操作即可：增加或者减少 MQ 中的队列。一切简单化了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这个方案是否依然还有问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 失衡的圆环，压垮骆驼的可能只是一根稻草&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们目前有 5 个队列存在，我们的分配规则是 m = hash(id) mod 100。那么，此时，问题就出来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 m 的值大于 5，由于没有对应的真实队列存在，系统就会顺时针顺着我们构造出来的哈希环找，最终会找到 chat00 这个队列上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，你会发现，只要是 m 值大于 5 的 id 对应用户发的信息，最终都会落入到 chat00 队列中。&lt;img data-ratio=&quot;0.8550420168067226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92Df5w0glkojPLey3Estb9T3t1LtibqzC5CCc3BNkjowFn5o8icSYTjxhAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;952&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在极端情况下，如果大量的信息涌入到 chat00 队列里，由于对应 chat00 的消费者处理不过来，很可能会导致这个消费者的崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，去除队列后，根据规则，又会有大量的信息涌入到 chat00 后续的队列 chat01 里，这些信息又会导致 chat01 对应应用的崩溃，最终引发整个集群的崩溃，这就是雪崩效应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要一种更巧妙的办法来解决这个问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 从实变虚，也许我们应该更敢想一些&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的论述，我们发现，我们在分配队列时，之所以失衡，是因为我们的队列在圆环上的分配失衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们所有的真实队列都是按照顺时针依次排布在圆环上的。在上面的场景里，我们只有 5 个队列。此时，我们假设会有 100 个队列。那么，m = hash(id) mod 100 这个公式里：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;m 大于 5 的概率为 95%&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们的 5 个队列是按照编号顺序依次排列的。那就说明所有 m 大于 5 的信息就都会映射到一个不存在的队列上，最终，根据规则，顺时针滑到了 0 对应的 chat00 队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果，我们可以让真实存在的队列均匀分布到环上，那么，这种严重失衡的现象还会再出现吗？&lt;img data-ratio=&quot;0.9032258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92DN45RRNDjjicVYv0gDHWR2ElrsYcJBP9MCXuVgXPChuj5WPOnRPFN8TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;img data-ratio=&quot;0.6612529002320185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D5U0gdyQy3l3PAmg529p53mLcTFLiabDjsyZOYx3GPZbic04brbkiblWLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图我们可以看出，如果我们能让真实的队列均匀的在圆环上分布，那么这种严重失衡的现象就会得到极大的缓解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何让这些队列能均匀的分布在这个圆环中呢？还记得我们在苦恼分配信息规则的不断修改时，我们大胆的假设了一个我们的 IM 系统永远也不可能达到的队列数字吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设了 MQ 中有 100 个队列，然后，我们去判断这些队列是否真实存在。不存在，我们就顺时针滑动一直找到真实存在的队列为止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们再大胆一点，偷偷的把我们的假设进一步优化，把一些本来需要判断为不存在的队列去映射到真正已经存在的队列上，那么我们是不是就等于把这些真正存在的队列均匀分布到这个圆环上了？&lt;img data-ratio=&quot;0.6085106382978723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KRibBrVgV21wXXhQTISGic92D1ScYNexrqybHjK8mhAJ8RulHbNRsekDyIMichicVPHkQgYdJY2q1Y0uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像上图这种，把已经存在的少量队列去映射到多个假设队列的方法，就是一致性哈希的虚拟节点办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于怎么让少量的队列映射到多个假设队列，是有多种实现算法存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们可以把真实存在的队列名加上一些编号去分别哈希一下, 像hash(chat00) mod 100，hash(chat00#1) mod 100，然后根据得到的余数，去把 chat00 这个真实队列和对应余数的环中的位置映射上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 hash(chat00) mod 100 = 31，那么 31 号的位置就对应于 chat00，以后所有 m = hash(id) mod 100 中 m = 31的所对应的消息就会直接被发送到 chat00 队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 hash(00#1) mod 100 = 56，则 m = 56对应的消息同样也会直接发送到 chat00 队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，我们就间接的把 MQ 中的真实存在的队列做了均匀化分布，从而大大减少了信息失衡的现象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 理解算法的思想胜于算法的实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，通过实际场景来对于一致性哈希的思想就暂时剖析到这里了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一致性哈希作为一种非常经典的算法思想，被广泛的用于各大分布式项目当中，用于解决各种分片问题，任务分发问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在这里，我要纠正一个观点：很多人都在网上说 redis 使用了一致性哈希。这是错的，redis 只是使用了一致性哈希的思想。比如一致性哈希中的环分布，再比如虚拟节点对应真实节点的思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 redis 并没有使用任何哈希算法去计算分布，如果有兴趣的读者，可以仔细去看下有关内容。从 redis 的例子上来说，我们可以看到，只有理解了算法的思想，我们才能更容易更灵活地因地制宜的分解、修正、改进算法，让算法能更切合实际的融入到我们的项目之中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这篇文章我们从哈希开始，一直到用到一致性哈希的虚拟节点分布，怎么样，您觉得一致性哈希这道良药味道如何呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次写图解的文章，大家包容一下直男的审美！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次写图解的文章，画图真是累吐血了！求大家看完点个&lt;strong&gt;在看&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;我准备了一些纯手打的高质量PDF：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;深入浅出Java多线程、HTTP超全汇总、Java基础核心总结、程序员必知的硬核知识大全、简历面试谈薪的超全干货。&lt;/section&gt;&lt;section&gt;别看数量不多，但篇篇都是干货，看完的都说很肝。&lt;/section&gt;&lt;section&gt;领取方式：扫码关注后，在公众号后台回复：666&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.440625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KSnObMQf98GBHlgrmrLrBjnEX3Dhrp6ibhSlBtM0zFXIgUb1Us6CXON4EMJwyCcKhDxLwTulgAb52Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我最近建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。&lt;/span&gt;&lt;span&gt;欢迎加&lt;/span&gt;&lt;span&gt;我微&lt;/span&gt;&lt;span&gt;信，&lt;/span&gt;&lt;span&gt;拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;智能人工推荐&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484826&amp;amp;idx=1&amp;amp;sn=35378fc344195edc643c5a68f896bc40&amp;amp;chksm=fcd8c9dbcbaf40cdcad84dd15b972afed8cf477f584748167ee67dc3a2a3532474497aa4d6c1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一个技术总监的忠告：精通那么多技术，你为何还是受不到重用？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484792&amp;amp;idx=1&amp;amp;sn=37b3953abb879837d3ab24a2f943dba5&amp;amp;chksm=fcd8c939cbaf402f82bc0a580212f410736614cc15f1d2061d24f47ca439fa9ae2c6f22e643f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;架构师说了：不想做背锅侠？生产问题要这样查&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484777&amp;amp;idx=1&amp;amp;sn=977e620df6c3b640985e20345aa80a12&amp;amp;chksm=fcd8c928cbaf403ed6e28e6b8aafaa851cd0a5a1404fbb34ba7eeb25b592b7a593852e9bd002&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;恕我直言，微服务挺好，但不适合你&lt;strong/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa3b5a82e372720712d3d2180af59e8a</guid>
<title>程序员是青春饭吗？30 岁后的发展方向和突破</title>
<link>https://toutiao.io/k/1gxzxw3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;前些年，有人说程序员只能干到 30，后来大家把年龄提到 35，最近好像又有提到 40 的迹象。最近 Python 创始人 Guido 入职微软了。&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;Guido 在 1989 年创造了 Python，无论从哪个角度看，都是绝对的高龄程序员了。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0b795578c05771b8c8eabc91d6c7ce4d&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序员是青春饭吗&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;2d503d3c68022eec01676ee099d2a72c&quot; data-wording=&quot;true&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2d503d3c68022eec01676ee099d2a72c&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;很多人都说写代码最多到 35 岁，妥妥的青春饭，然而科学分析不这么认为。《Is Programming Knowledge Related to Age?》论文对 1694981 名 StackOverflow 用户的研究发现，程序员的平均年龄是 30.3 岁，其中数据清洗后参与分析的用户是 84248 名程序员，平均年龄 29.02 岁。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2e728b3c621163d430ecf5e8160e5bd4&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1c2a51f3b71f4531f3c7bf9c516c7dca&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;在年龄分布中，人数最多的是 25 岁，中位数是 29 岁。然而分析发现，程序员的能力从 25 岁左右开始上升，一直到 50 岁后才会开始下降。论文还研究了程序员对新技术的跟进，发现不同年龄的程序员对新技术的学习并没有差太多。大龄程序员对某些新技术的学习甚至超过年轻程序员。所以论文得出的结论是，程序员的技术能力上升可以到 50 - 60 岁，并且大龄程序员跟进新技术的能力和年轻程序员相差不多。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;075ae2e04236f0c5ecef73235bbd0a1f&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1d273e584436996c0e46fdfd4dce1c3e&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;从身边的观察发现，30 岁的程序员积累了大量经验，可能才刚刚成为优秀的人才，架构设计能力、领导力需要大量的实践积累，不是能够轻松掌握的。互联网是&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;一个新兴行业，大部分从业者都是后期加入的，平均年龄要低于其他行业。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5a1f714581c6a9d649e432a494717fbb&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;30 岁后的职业规划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;1864378ec104ae4153310b2b427d4d5f&quot; data-wording=&quot;true&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;1864378ec104ae4153310b2b427d4d5f&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;一个程序员在 30 岁后，可能面临技术专家、技术 Leader&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;、架构师&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;三个发展方向的选择。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5e5cf284abf5091f792d65b280652239&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4d988d9a46496a423c6e3517bce54aab&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;技术专家很好理解，在一个领域深耕，对业务和代码都有很好深刻的理解，经验丰富，能够用技术解决公司遇到的实际问题。成为技术专家需要大量的实践积累，正常发展情况下差不多都要到 30 岁左右。正常来说，技术专家是人才梯队中非常重要的角色，对技术方案设计有很大影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;af439d43ca702df7f9c09db082e82bb3&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;05963a35f8e2a05c4bea0235be789cc0&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;前几天看到有个公众号转载一篇高并发的文章，一个看起来一年内工作经验的作者展示了漏洞百出的技术方案，还能发上线，可见技术专家对团队的重要作用。没有技术专家的团队，人才梯队很难建立起来，团队内成员的成长可能也会受影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5328d7bdea557f219cfce48d8f0a69f7&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f38d420ee4dca6007af2dadcb13e9596&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;技术 &lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;Leader &lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;会开始涉及技术管理方面的事务。注意这里是 Leader，不是 Manager。Manager 是管理者，而 Leader 更多是领导者。作为技术 Leader，需要重点保障核心业务、做技术建设、提升业务效果。为团队&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;设定合理的目标，做好排兵布阵，协调各个团队和资源。所以业内往往称为“技术管理”而不是“管理”。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e3afed50f7bea34d5b6f0419d3783692&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;7f61f4045e1fbc262300c9b5ae1da82e&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;技术 Leader 比团队其他同学视野更开阔，对长远的发展趋势看的更准，有技术前瞻性。虽然已经成为团队中最牛逼的程序员之一，但是也要逐渐学会借他人之手写代码，专注于写代码的时间比&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;以前减少很多，而这一点正是优秀程序员转变为技术 &lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;Leader &lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;所面临的最大挑战之一。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;71c455510398232aca6a5ec9d43491fc&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;17025399ca6163ad74046369a4f9ecd6&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;架构师是一个非常出名的称谓了，然而却很少有专门的架构师岗位。阿里前几年有架构师岗位，不过现在也回归“技术专家”这样的纯技术岗位了。架构师必须是最出色的程序员，拥有技术深度和广度，&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;有系统性的认知和技术前瞻性。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;04608391ed9b3bdc3a6aec3ee20c05b1&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;709ea791248af4dc9d0c5b103b252452&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;架构师通常和&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;技术 &lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;Leader 有部分重叠，尤其是在团队规模比较小的时候，两者往往是同一个人。随着软件规模的增大，架构师开始在比&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;技术 &lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;Leader 更高的高度上看待问题，这时候架构师和&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;技术 Leader 开始分化为不同的人。架构师也不一定是公司任命的权威领导者，但是在团队内部通常有非权威领导力，是团队内部非常信任的技术领导者。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;501c2f8b64e91de6ba02263388a2c363&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;852acfdff8ae9f8e7f854a54f88395d5&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;这三个发展方向可能会有重叠，对个人来说，还是最好想清楚侧重点是什么。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f43dc6460ddfced1adac596421f0b6ae&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;掌握软件系统方法论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;9c90e6da1c0f2429e789077b5476ebf5&quot; data-wording=&quot;true&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9c90e6da1c0f2429e789077b5476ebf5&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;越是到职业发展的后期，越不能依靠代码本身。所有人都使用着同样的开发语言，掌握着同样的语法和脚本。作为执行者很难体现出优势，总不能说掌握的语法和二方包比别人多吧。优秀的程序员能比别人写出更好的代码，主要还是在如何写代码，以及代码背后的思考，也就是程序员的方法论。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;85bde54f10b1e5074a622228157f0e09&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;bc65d274a8b5d6d2229a5809a1d31c98&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;方法论英文单词是 methodology，也就是说它是关于方法(method)的学问&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;，是关于人们认识世界、改造世界的方法的理&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;论，&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;是人们用什么样的方式、方法来观察事物和处理问题。简单地说，方法论是成熟的思维方式&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c7fe833fe4d9afb0e75b46094da3841d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;38a7c10736f9caf734fcf34dce3b93ad&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;成熟的方法论有很多。前面文章提到的黄金圈法则，是思考问题、分析问题的方法论。领域驱动设计是架构设计方面的方法论，能够帮助解决复杂问题。金字塔原理，是思考问题、解决问题、写作、PPT 演示方面的方法论&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;。系统化思维，是对复杂系统如何观察和分析的理论，也能指导设计复杂系统。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;75e957094726f87bf6e505d42cd19707&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;156beef5a2624aab9f086b4cf8a8e660&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;我们常说的“抓手”、“赋能”、“共建”、“打法”、“对焦”等看起来比较虚的东西，其实就出自于方法论，是方法论中对具体事物和行为背后的客观规律的总结。脉脉上很多人对此嗤之以鼻，成为了大家吐槽的对象，但是这都是很成熟的概念。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;de2d495eaad0f9b0b5e53c730ee6a889&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d08182322e0e93447c28d64d3a365b92&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;如果长期停留在使用框架的层面，容易陷入工具误区，把使用框架当做技术，思维方式也被局限在框架里。会有一种技术很牛逼的错觉，但是和其他人相比，却没有多少优势，容易被更年轻更有活力的后辈取代。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c690208595d287cd8978c5fadb12a9b6&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;形成自己的方法论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;24d99bcfa4f7e982db66d06ff7e58987&quot; data-wording=&quot;true&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;24d99bcfa4f7e982db66d06ff7e58987&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;方法论的形成需要长期的积累，可以借鉴学习圈理论。学习过程由具体经验、反思观察、抽象概括、主动实验四个阶段，并形成一个闭环。首先学习一个具体的东西，然后停下来对自己的经历进行复盘和思考，再对学习的内容进行抽象，概括成为真正能理解、能吸收的知识，最后再把学习的概念和理论应用于实践并解决现实的问题，如此往复循环。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e6f7f112fb8171a62fd5ac3d8d5a4478&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4be11d36c3b970477a0897fa5153fd48&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F261496%2F1605763530833-1d5a70aa-945b-4d26-96af-f0a517a711cb.png%22%2C%22originWidth%22%3A400%2C%22originHeight%22%3A240%2C%22name%22%3A%22image.png%22%2C%22size%22%3A22616%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A169.5161%2C%22y%22%3A11.3966675%2C%22width%22%3A63.402950000000004%2C%22height%22%3A16.3871225%2C%22text%22%3A%22%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%22%7D%2C%7B%22x%22%3A132.87766%2C%22y%22%3A94.92685%2C%22width%22%3A45.85647%2C%22height%22%3A17.044150000000002%2C%22text%22%3A%22%E8%A1%8C%E5%8A%A8%E8%80%85%22%7D%2C%7B%22x%22%3A222.66109%2C%22y%22%3A95.54752%2C%22width%22%3A44.87738999999999%2C%22height%22%3A15.203419999999994%2C%22text%22%3A%22%E7%90%86%E8%AE%BA%E8%80%85%22%7D%2C%7B%22x%22%3A25.310425%2C%22y%22%3A109.09499%2C%22width%22%3A63.533855%2C%22height%22%3A17.79834000000001%2C%22text%22%3A%22%E4%B8%BB%E5%8A%A8%E9%AA%8C%E8%AF%81%22%7D%2C%7B%22x%22%3A313.43204%2C%22y%22%3A109.38337%2C%22width%22%3A65.32690000000002%2C%22height%22%3A19.29074999999999%2C%22text%22%3A%22%E5%8F%8D%E6%80%9D%E8%A7%82%E5%AF%9F%22%7D%2C%7B%22x%22%3A132.8296%2C%22y%22%3A127.956085%2C%22width%22%3A45.414860000000004%2C%22height%22%3A16.690474999999992%2C%22text%22%3A%22%E5%86%B3%E7%AD%96%E8%80%85%22%7D%2C%7B%22x%22%3A223.3697%2C%22y%22%3A130.14539%2C%22width%22%3A43.21428%2C%22height%22%3A14.941210000000012%2C%22text%22%3A%22%E6%80%9D%E8%80%83%E8%80%85%22%7D%2C%7B%22x%22%3A167.50938%2C%22y%22%3A212.48047%2C%22width%22%3A66.41286%2C%22height%22%3A18.05095%2C%22text%22%3A%22%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%20%E8%A1%8C%E5%8A%A8%E8%80%85%20%E7%90%86%E8%AE%BA%E8%80%85%20%E4%B8%BB%E5%8A%A8%E9%AA%8C%E8%AF%81%20%E5%8F%8D%E6%80%9D%E8%A7%82%E5%AF%9F%20%E5%86%B3%E7%AD%96%E8%80%85%20%E6%80%9D%E8%80%83%E8%80%85%20%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A400%2C%22height%22%3A240%7D&quot;&gt;&lt;img data-height=&quot;240px&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3cfNeMrD2uwCztEicyp29HydSh3hTlpyGEOd0Q3LV48gbohBLTKFOMs90gmcyqQ0uxOjhy3V9ubcNAN6NTnFUlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot; title=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;453b546a7bbff33e3be60f9fc46480f0&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;61c67fc791802f140e18f9667b8234e2&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;定向钻研一个技术方向，可以加深技术深度，有助于形成方法论。比如，可以定一个目标，让需求上线的时间缩减一半或者同样成本支撑的需求数量翻倍。接下来就需要思考什么样的架构设计能够支撑翻倍的效能，很多情况下都会走向配置化、提升复用、热部署等，接下来你就可以总结出你的方法论了。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8759b5f80691ca58a4abc54a3b925c5f&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b937460d01c743e98cad1012e830a51a&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;亲自设计一个框架，也是一个不错的选择。既能在纵向深挖，又会有横向拓展的机会。不过这样的尝试一定要以足够的经验积累为前提，否则可能走入误区。跳出日常的习惯，拔高视野，很快就会有领悟，甚至推翻低层次的认知。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b3e4cd235a2de3bb5dc8d040d1d31832&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2cbb132f40327de4a45300c56f1d7647&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;复盘和反思有助于改造认知，实现认知升级。推荐使用黑匣子思维，记录下过程中的思考和问题，能够帮助更好地复盘。关于复盘的方法，推荐阅读《复盘:对过去的事情做思维演练》，书中讲了很多复盘的方法和技巧，是关于复盘的方法论。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f6d9c0f3a1d8e0b4f940c3cc75200945&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b4e22ae00a3e84b6a336a8a77ec4495d&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;经过思考和训练，你会得到很多经验和认知，会形成自己的思维方式，能够对一类问题形成体系化的深度思考，然后再总结出一些概念进行抽象，使经验适用于更广阔的共性问题，就实现了经验到理论的升华。把自己的理论应用于实践，观察实际效果，对比之前的预期，再领悟新的经验和思考，循环往复，就形成了方法论。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4d9af7751b49a52e0107098a828856cc&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b6e14023d404b1b8d1e370b3dbe7e175&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;以上就是本文的全部内容了，与君共勉。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b6e14023d404b1b8d1e370b3dbe7e175&quot; data-wording=&quot;true&quot;&gt;&lt;span data-mce-style=&quot;font-size: 12px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDE2NTgzNQ==&amp;amp;mid=2247486248&amp;amp;idx=1&amp;amp;sn=ba8ba06d006136e20ec7c14aefe893c5&amp;amp;chksm=9b31528cac46db9a42e8cb410216fdbe05d79f0a4feb719c94ecd86c545bb78d9e471edf5639&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;被黑客攻击了，登录流程要怎么做才安全&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDE2NTgzNQ==&amp;amp;mid=2247486242&amp;amp;idx=1&amp;amp;sn=51936b434b7cfe88fd073b9f22f77d7d&amp;amp;chksm=9b315286ac46db90c4919d179663d495fd40380d343ea418d085f788ea3d8190d0746cf14b22&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;天天写业务代码的程序员，怎么成为技术大牛&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDE2NTgzNQ==&amp;amp;mid=2247486236&amp;amp;idx=1&amp;amp;sn=dd9060690257c6f5fd4f6eb22327497b&amp;amp;chksm=9b3152b8ac46dbae00892d68e6c8d8a21ebcbd2e3eb626153929ae42187d3526341fb43d1822&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;走向卓越，领域驱动设计的思维方式&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2d3df6ebe009895b22060e5a29478d84&quot; data-wording=&quot;true&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6811352253756261&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3cfNeMrD2uzUXLTGibiabV4icAibOoeZKOIPBoIJoE8Mng1xZMGOpv0U4zdEI8nb5nKftA9TBLNiaez19lTLORB7hfg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>