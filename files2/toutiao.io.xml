<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d0821c894696406068a8ddb70b3fe678</guid>
<title>著名的 Java 并发编程大师都这么说了，你还不知道伪共享么</title>
<link>https://toutiao.io/k/3q7ujrr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;本文首发于公众号【看点代码再上班】，欢迎围观，第一时间获取最新文章。&lt;/strong&gt;
记得关注我，订阅更多好文！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;全文共计2163字18图，预计阅读时间13分钟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大家好，我是tin，这是我的第7篇原创文章
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0w55IaOhs_2BkC.jpeg&quot; alt=&quot;WechatIMG43.jpeg&quot;/&gt;
图拍摄于深圳桃园南山图书馆，年前某个阳光明媚的周六，看到挂满的灯笼，觉得甚是喜庆。文章较长，先上一个目录：上个全文目录：&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;一、Doug lea&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在微博上看到这么一句话，挺有意思的。
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0qsBhUu5Z_dtVh.png&quot; alt=&quot;image.png&quot;/&gt;
Doug Lea是谁？为什么这么说？估计还真挺多人不认识他吧。&lt;/p&gt;

&lt;p&gt;Doug Lea，中文名为道格·利。java.util.concurrent并发包的作者。说他是这个世界上对Java影响力最大的一个人，一点也不为过。因为两次Java历史上的大变革，他都间接或直接的扮演了举足轻重的角色。2004年所推出的Tiger。Tiger广纳了15项JSRs的语法及标准，其中一项便是JSR-166。JSR-166是来自于Doug编写的util.concurrent包，主要是关于J.U.C的技术规范。&lt;/p&gt;

&lt;p&gt;上文摘抄自百度百科：
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/xHzVVafB_LxYr.png&quot; alt=&quot;iShot2021-02-13 17.26.26.png&quot;/&gt;
JSRs(Java Specification Requests)，表示Java规范请求，由JCP成员向委员会提交的Java发展议案，经过一系列流程后，如果通过最终会体现在未来的Java中。&lt;/p&gt;

&lt;p&gt;JCP全称Java Community Process ，翻译中文即是：Java社区进程。JCP成立于1998年，官网地址&lt;a href=&quot;https://www.jcp.org%EF%BC%8C%E7%94%B1%E7%A4%BE%E4%BC%9A%E5%90%84%E7%95%8CJava%E7%BB%84%E6%88%90%E7%9A%84%E7%A4%BE%E5%8C%BA%EF%BC%8C%E4%B8%BB%E8%A6%81%E8%A7%84%E5%88%92%E5%92%8C%E9%A2%86%E5%AF%BCJava%E7%9A%84%E5%8F%91%E5%B1%95%E3%80%82&quot;&gt;https://www.jcp.org，由社会各界Java组成的社区，主要规划和领导Java的发展。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、CPU缓存架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;国内另一位大神，dubbo的创作者，曾经在他的ppt写过这样的一页
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/t9Nq5eZC_BnwJ.png&quot; alt=&quot;image.png&quot;/&gt;
或许有人已经猜到这ppt作者是谁的，有兴趣可自行了解（需要完整ppt也可联系我！）。ppt描述的背后原理就是伪共享问题。&lt;/p&gt;

&lt;p&gt;说起伪共享，还得从cpu的缓存架构说起。
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0mZZvXf77_f7FL.png&quot; alt=&quot;iShot2021-02-13 13.09.12.png&quot;/&gt;
CPU缓存可以分为一级缓存，二级缓存，三级缓存，每一级缓存中所储存的全部数据都是下一级缓存的一部分。当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。&lt;/p&gt;

&lt;p&gt;越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快，紧接着L2 大一些，也会慢一些，L3更慢，最后到主存，主存保存着程序运行的所有数据，由所有 CPU 核共享。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、CPU缓存行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU缓存由缓存行组成，缓存行长度为64字节，可以这么认为，缓存行是缓存更新的基本单位。缓存每次更新都从主内存中加载连续的 64 个字节。试想，如果在内存中有两个紧邻的long型变量a和b，当a加载到缓存时，b也可以一起被加载到缓存，下一次如果访问b则可以直接从缓存读取，这对读取的效率提升是非常大的。
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0BTrdAsJP_KswJ.png&quot; alt=&quot;image.png&quot;/&gt;
但是，正因为缓存都以缓存行为基本单位处理，如果cpu core1修改a变量，core1上包含a变量的缓存行将失效，同时其他core上包含a变量的缓存行也将失效。此时，如果core2要访问和a在同一缓存行上的b变量，会被告知缓存行失效，这时只能到主内存重新加载b变量。&lt;/p&gt;

&lt;p&gt;在《Java并发编程的艺术》一书中，第二章第11页如是说：
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0eGWQQXNt_tvxe.jpeg&quot; alt=&quot;WechatIMG44.jpeg&quot;/&gt;
Doug lea在jdk7的并发包里面新增一个队列集合类LinkedTransferQueue，它在使用volatie变量时，用一种追加字节的方式来优化队列出队和入队的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、伪共享&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存以缓存行为基本单位，当线程修改互相独立的变量时，如果这些变量在同一缓存行中，那么就会互相变量缓存值得有效性，从而影响访问性能，这就是伪共享。&lt;/p&gt;

&lt;p&gt;看一个单元测试源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.tin.example.falls.sharing;
​
import org.springframework.util.StopWatch;
​
/**
 * title: AutoIncrement
 * &amp;lt;p&amp;gt;
 * description: 多线程环境下，long变量自增
 *
 * @author tin @看点代码再上班 on 2021/2/17 下午1:28
 */
public class AutoIncrement {
​
 public static void main(String[] args) throws InterruptedException {
 StopWatch stopWatch = new StopWatch(&quot;@看点代码再上班&quot;);
 stopWatch.start();
 System.out.println(&quot;====== start to iterate ======&quot;);
 autoIncrement(new LongNumber());
​
 stopWatch.stop();
 System.out.println(&quot;cost &quot; + stopWatch.getTotalTimeMillis() + &quot;ms&quot;);
 }
​
 private static void autoIncrement(LongNumber longNumber) throws InterruptedException {
 Thread t1 = new Thread(() -&amp;gt; {
 for (int i = 0; i &amp;lt; 100000000; i++) {
 longNumber.n1++;
 }
 });
​
 Thread t2 = new Thread(() -&amp;gt; {
 for (int i = 0; i &amp;lt; 100000000; i++) {
 longNumber.n2++;
 }
 });
​
 t1.start();
 t2.start();
 t1.join();
 t2.join();
 }
​
 static class LongNumber {
//        @sun.misc.Contended
 volatile long n1;
 volatile long n2;
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我启用两个线程，分别自增1亿次n1和n2时，耗时大约3000+ms
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/qqAnrAud_XbEx.png&quot; alt=&quot;image.png&quot;/&gt;
当我在n1字段加上注解@sun.misc.Contended，重新跑程序，耗时变为800+ms
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/JwcsVnGd_2krY.png&quot; alt=&quot;image.png&quot;/&gt;
@sun.misc.Contended注解在Java 8后新增，其用来进行缓存行填充。它可以用于类级别的修饰，同时也可以用于字段级别的修饰，当应用于字段级别时，被注释的字段将和其他字段隔离开来，会被加载在独立的缓存行上。&lt;/p&gt;

&lt;p&gt;@sun.misc.Contended注解和上文ppt中提及的追加字节效果是等同的（注解要生效需在启动参数上加-XX:-RestrictContended）。除了加注解，如果在n1和n2中间增加16个对象引用也同样起到作用（一个对象引用4个字节）。&lt;/p&gt;

&lt;p&gt;我们要看一个对象所占的字节数大小怎么看？分享一个好东西，引用下面的包依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;0.9&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中显式打印对象即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ClassLayout.parseInstance(obj).toPrintable()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到打印出来的结果：
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0v5mCNnpj_Th8P.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、结语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是tin，一个在努力让自己变得更优秀的普通攻城狮。自己阅历有限、学识浅薄，如有发现文章不妥之处，非常欢迎加我提出，我一定细心推敲加以修改。&lt;/p&gt;

&lt;p&gt;看到这里请安排个点赞再走吧，坚持原创不容易，你的正反馈是我坚持输出的最强大动力，谢谢啦！
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202012/J4GcAzne_sx7V.gif&quot; alt=&quot;20190911181805AMQR5B8FDFDAXGLA.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;别忘了关注我哦！⏬⏬⏬&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>206c6ce3d4b33036369614a3705c5d8d</guid>
<title>生产力至少提升 5 倍，大厂火拼的低代码平台究竟还有哪些坑？</title>
<link>https://toutiao.io/k/ipuno05</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/DT8udUick9sINXn4zpQNM4Micy9ZNrBsLKSmrRN5HKibFiaXgmGnX0qQRDicmicmh8Rm8nRTicJkeAtoL3zEnsHicKYyXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-id=&quot;708&quot; data-style=&quot;max-width: 100%; color: rgba(255, 255, 255, 0.8); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; background-color: rgb(35, 35, 35); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;708&quot; data-style=&quot;max-width: 100%; box-sizing: border-box; background-color: rgb(255, 255, 255); color: rgb(62, 62, 62); letter-spacing: 0.544px; font-family: 微软雅黑; border-width: 0px; border-style: none; border-color: initial; visibility: visible; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;section data-style=&quot;padding: 35px; max-width: 100%; box-sizing: border-box; background-color: rgb(245, 245, 244); border-color: rgb(245, 245, 244); color: rgb(123, 123, 111); visibility: visible; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__2&quot;&gt;&lt;section&gt;&lt;section data-style=&quot;max-width: 100%; box-sizing: border-box; border-color: rgb(245, 245, 244); color: inherit; visibility: visible; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;section data-style=&quot;max-width: 100%; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-style=&quot;padding: 10px; max-width: 100%; box-sizing: border-box; color: rgb(62, 62, 62); line-height: 25.6px; display: inline-block; width: 670px; border-width: 2px; border-style: dashed; border-color: transparent; background-color: rgb(239, 239, 239); overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;随着数字化转型的不断加速，企业对IT系统的敏捷性要求越来越高，但开发人员的缺口一直补不上，无代码/低代码的开发技术优势逐渐凸显出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据 Gartner 数据，到2024年，65%的应用程序开发将是低代码。到2023年，超过50％的大中型企业将采用低代码应用程序平台（LCAP）作为其战略应用平台之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当下的低代码/无代码领域非常复杂，有许多的解决方案、平台和子市场。虽然低代码/无代码平台有很多好处（比如高效性和易用性，加快生产和效率），但它们也存在一些关键挑战。比如，企业文化改变、&lt;strong&gt;需要学习曲线（技术门槛并不低&lt;/strong&gt;）、缺乏社区和资源支持等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总体而言，行业处在早期，许多最佳实践才刚刚出现，相对来说还不成熟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编译 | &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;机器之能&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们最近都听到了关于低代码和无代码平台的宣传。无代码平台的承诺是，它们将使软件开发变得像使用Word或PowerPoint一样简单，这样的话，普通业务用户可以在不需要工程团队额外成本(金钱和时间)的情况下推进项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与无代码平台不同，低代码平台仍然需要编码技能，但允许开发人员使用预先编写的代码组件，从而加速软件开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据Gartner的数据，&lt;strong&gt;到2024年，65%的应用程序开发将是低代码。到2023年，超过50％的大中型企业将采用低代码应用程序平台（LCAP）作为其战略应用平台之一。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早在2017年，我就参与了传统开发(使用Java)和模型驱动的低代码/无代码开发项目之间的早期生产率基准测试比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结果令人印象深刻：&lt;strong&gt;低代码/无代码开发的生产力提高了5倍到7倍。2020年「无代码普查」(No-Code Census)的一项调查显示，与传统编程相比，生产率提高了4.6倍。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 一 &lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;低代码/无代码:一个分散的市场&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;低代码/无代码领域非常复杂，有许多的解决方案、平台和子市场。例如，有针对大型企业、中型企业和小型企业的子市场。企业低代码/无代码平台可以提供高可伸缩性，兼具性能与安全性的应用程序集成。它们往往更昂贵。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是Gartner为企业低代码平台设计的魔力象限:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/DT8udUick9sINXn4zpQNM4Micy9ZNrBsLKuXTM0qmKhfahGYJHPW3vtVKxwQzdjf5KFydHnMrMfxAibanCztVuaicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;企业低代码应用平台的魔力象限，资料来源：Gartner（2020年9月）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Gartner将低代码应用程序平台(LCAP)定义为，「使用声明性的高级编程抽象（例如模型驱动和基于元数据的编程语言）支持快速应用程序开发，一步部署、执行和管理的应用程序平台。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;G2为小型企业提供了类似的概况。小企业和企业低代码平台之间没有太多交集。一些小型平台供应商在企业中并不为人所知或被认可。同样的，中小型企业通常不购买企业平台，主要是因为它们的定价和复杂性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一点都不奇怪，许多低代码平台都是业务流程管理平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;这种&lt;/strong&gt;&lt;strong&gt;以过程为中心的低代码解决方案非常&lt;/strong&gt;&lt;strong&gt;受欢迎。&lt;/strong&gt;&lt;strong&gt;BPM低代码/无代码平台的例子包括Appian、Pega和Outsystems。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;但在低代码/无代码保护伞下还有其他的范例:&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;网站低代码/无代码平台&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;任何规模的企业都可以利用这些平台。主要的竞争者是WordPress、Wix、Squarespace和WebFlow。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据库管理低代码/无代码平台&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;span&gt;对于高端(企业)，有像Mendix这样的平台。对于较低端的，有Airtable。还有一些低代码/无代码的NoSQL数据库平台，如用于知识图的KgBase。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;自动集成低代码/无代码平台&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;在这个领域有一些令人兴奋的新兴平台，例如Zapier、Parabola和Integromat都属于这一类。企业可以通过这些工具相对快速地开发强大而复杂的集成流。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;以下是Parabola工作流的例子，它从一个API中提取数据，进行一些数据操作，然后将其发送到另一个API。&lt;/span&gt;&lt;span&gt;自动化的工作流可以按需运行、调度或通过webhook调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.36328125&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/DT8udUick9sINXn4zpQNM4Micy9ZNrBsLKT8eCPpFl7p9XSE4lxEH405ticagPguddfOdZ9ejjFvFNuxxHzAC1lHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中许多平台为特定类型的应用程序提供了丰富的插件和模板集合。低代码/无代码平台的其他类别针对特定的应用领域或细分市场:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;电子商务和网上商店&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;Shopify是这方面的领先案例。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;工作管理&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;Monday.com是这方面很好的例子。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;ERP应用&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;Zoho是这方面很有趣的例子，此前在Gartner的魔力象限表中列出。另一个对ERP和CRM有重要影响的平台是Salesforce。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;区块链和物联网&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;Atra是区块链方面的案例。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;人工智能&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;人工智能是低代码/无代码的一个迷人领域，当中就有C3 AI Ex Machina这个例子出现。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 二 &lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;低代码 /无代码的挑战&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;低代码/无代码平台有很多好处，但它们也存在一些挑战，需要学习曲线。&lt;strong&gt;许多最佳实践才刚刚出现，相对来说还不成熟。这是&lt;/strong&gt;&lt;strong&gt;至关重要的责任&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt; 使用传统编程，有大量的经验、强大的社区和有据可查的最佳实践。在许多方面，低代码/无代码还处于起步阶段，尽管MDD已经存在很长一段时间了，特别是在BPM平台上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是低代码/无代码的一些更关键挑战:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;它涉及到文化的改变&lt;/strong&gt;：低代码/无代码要求改变组织文化，无论该组织是企业还是初创企业。改变文化以消除「烟囱」并非易事。它需要执行的远见和认可。它还需要对低码/无码数字转换能力中心进行预算分配和授权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;学习这些平台需要时间和精力：低代码/无代码&lt;/strong&gt;&lt;strong&gt;可&lt;/strong&gt;&lt;strong&gt;提高速度和生产率。但这并不容易。这些工具和平台并不是微不足道的，而且开发一定程度的专业知识需要时间。这是低代码/无代码最容易被误解的方面之一。复杂的编程结构(如嵌套循环)在任何平台上都不是那么容易。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;您可能需要多个平台&lt;/strong&gt;：某些平台比其他平台更完整。例&lt;span&gt;如，Unqork和Bubble旨在用于任何用例，因此提供了许多与企业系统集成的选项。但是，他们可以从专门用于特定领域的其他组件中受益匪浅；例如，Bubble和Parabola或Zapier插件一起进行自动集成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与Bubble中的原生功能相比，Parabola或Zapier中的数据操作和集成功能更易于使用。还有其他插件或技术组件可通过其他技术补充低代码/无代码平台：例如，Unqork的技术合作伙伴或Bubble的插件综合列表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、&lt;strong&gt;资源和社区支持匮乏&lt;/strong&gt;：许多低代码/无代码平台相对不成熟。使用传统编程语言的开发人员有数百万，有时甚至数千万。许多在线和现场的课程、书籍和材料都是现成的，适用于Java或c#等语言。外包有很多社区和资源。对于低代码/无代码来说，这是一个完全不同的场景——特别是对于较新的平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、&lt;strong&gt;定价可能令人困惑&lt;/strong&gt;：企业低代码/无代码平台往往是不必要的昂贵。中小型市场的平台成本较低，但通常伸缩性较差。端到端解决方案涉及多个平台，使定价问题更加复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些只是一些关键的挑战。他们清楚地表明，低代码/无代码不是万灵药。然而，无论是对现有企业还是初创企业，开发创新解决方案仍是一个强劲趋势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着这个领域的不断成熟，我们应该会听到更多的挑战。也会有失败的项目。&lt;strong&gt;但优势——尤其是在加快发展和生产率方面——将赢得胜利。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你准备好了吗?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考链接:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://venturebeat.com/2021/02/14/no-code-low-code-why-you-should-be-paying-attention/&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;90835&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;机器之能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面向正在进行数字化转型及智能化升级的各领域产业方，为他们提供高质量信息、研究洞见、数据库、技术供应商调研及对接等服务，帮助他们更好的理解并应用技术。产业方对以上服务有任何需求，都可联系我们。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;zhaoyunfeng@jiqizhixin.com&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ed7b11627955ba3186f1c2d833a5c9a</guid>
<title>Java 8 为什么需要引入新的日期和时间库</title>
<link>https://toutiao.io/k/4bii1m0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java8为什么需要引入新的日期和时间库&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Date日期输出可读性较差&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Date date = new Date();&lt;br/&gt;System.out.println(date);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印输出的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Sat Nov 14 11:03:41 CST 2020&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Date日期的解析、格式化通过JDK自带的api实现较为麻烦，通常会使用第三方的日期时间库，比如：&lt;code&gt;joda-time&lt;/code&gt;, &lt;code&gt;commons-lang&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java8中提供了哪些日期和时间类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java.time包中提供了很多新的类，通常主要使用到的是&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;, &lt;code&gt;LocalDateTime&lt;/code&gt;, &lt;code&gt;ZoneId&lt;/code&gt;, &lt;code&gt;ZoneDateTime&lt;/code&gt;; 关系图如下：&lt;img data-ratio=&quot;0.48&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicfclm6Zzicicyic1PgJWokjcSP2PBT76a5doFXlxIZPngqic3QEkWibjsWAAUcIOnTnpUCh7QbkYFYrSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LocaDate这个类本身不包含时间和时区信息，只包含了日期信息；提供了很多方法来获取常用的值：星期几，几月 ...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的静态构造&lt;code&gt;LocaDate&lt;/code&gt;方法&lt;code&gt;LocalDate.of(2020, 11, 14); //指定年月日 LocalDate.of(2020, Month.NOVEMBER, 14); //指定年月日 使用Month枚举类 LocalDate.ofYearDay(2020, 10); //2020年第10天 =&amp;gt; 2020-01-10 LocalDate.now(); //当前时间 System.out.println(LocalDate.now()); // 比较好的可读性输出 =&amp;gt; 2020-11-14&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LocaDate&lt;/code&gt;常用实例方法&lt;code&gt;LocalDate now = LocalDate.of(2020, 11, 14); System.out.println(now.getMonth()); //月份的枚举 =&amp;gt; NOVEMBER System.out.println(now.getMonthValue()); //月份的数字 =&amp;gt; 11 System.out.println(now.getDayOfMonth()); //几号 =&amp;gt; 14 System.out.println(now.getDayOfYear()); // 一年中的第几天 =&amp;gt; 319 System.out.println(now.getDayOfWeek()); // 周几枚举 =&amp;gt; SATURDAY System.out.println(now.lengthOfMonth()); //本月多少天 =&amp;gt; 30 System.out.println(now.lengthOfYear()); //本年多少天 =&amp;gt; 366&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalTime.of(12, 9, 10); //时、分、秒&lt;br/&gt;LocalTime.now();&lt;br/&gt;LocalTime time = LocalTime.of(12, 9, 10);&lt;br/&gt;System.out.println(time.getHour());&lt;br/&gt;System.out.println(time.getMinute());&lt;br/&gt;System.out.println(time.getSecond());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LocalDateTime 从这个类的名字可以看出是合并了&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;，只包含日期和时间，不包含时区信息
构造的方式，可以直接使用静态方法创建，也可以通过&lt;code&gt;LocalDate&lt;/code&gt;，&lt;code&gt;LocalTime&lt;/code&gt;合并&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDateTime.of(LocalDate.now(), LocalTime.now());&lt;br/&gt;LocalDateTime.of(2020, 11, 14, 13, 10, 50);&lt;br/&gt;LocalDate.now().atTime(LocalTime.now());&lt;br/&gt;LocalTime.now().atDate(LocalDate.now());&lt;br/&gt;LocalDateTime.now();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;LocalDateTime&lt;/code&gt;是&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;的合并，所以&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;有的实例方法，基本在&lt;code&gt;LocalDateTime&lt;/code&gt;中都可以找到&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ZoneId 用来替代老版本&lt;code&gt;TimeZone&lt;/code&gt;, 每个&lt;code&gt;ZoneId&lt;/code&gt;都有一个特定的地区标识;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  ZoneId.of(&lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;);&lt;br/&gt;  ZoneId.systemDefault()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看所有的地区标识可以进入到&lt;code&gt;ZoneId&lt;/code&gt;源码&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ZoneDateTime带有日期、时间、时区信息，是&lt;code&gt;LocalDateTime&lt;/code&gt;和&lt;code&gt;ZoneId&lt;/code&gt;的组合&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ZonedDateTime zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());&lt;br/&gt;ZonedDateTime.of(LocalDate.now(),LocalTime.now(),ZoneId.of(&lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常我们会遇到需要求两个时间之间相差的时间, 如何实现呢？Java8也提供给了相应的API支持， &lt;code&gt;Duration&lt;/code&gt;、&lt;code&gt;Period&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Duration between = Duration.between(LocalTime.of(13, 0), LocalTime.of(14, 0)); &lt;br/&gt;between.getSeconds(); //返回两个时间相差的秒数 =&amp;gt; 3600&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;是通过秒和毫秒来记录时间的长短，所以只能处理两个&lt;code&gt;LocalTime&lt;/code&gt;, &lt;code&gt;DateLocalTime&lt;/code&gt;, &lt;code&gt;ZonedDateTime&lt;/code&gt;; 如果传入的是&lt;code&gt;LocalDate&lt;/code&gt;，将会抛出异常&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.time.temporal.UnsupportedTemporalTypeException: Unsupported unit: Seconds&lt;br/&gt;&lt;br/&gt; at java.time.LocalDate.until(LocalDate.java:1614)&lt;br/&gt; at java.time.Duration.between(Duration.java:475)&lt;br/&gt; at com.haixue.crm.stock.service.LocalTest.testDate(LocalTest.java:121)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt; at java.lang.reflect.Method.invoke(Method.java:498)&lt;br/&gt; at org.junit.runners.model.FrameworkMethod&lt;span&gt;$1&lt;/span&gt;.runReflectiveCall(FrameworkMethod.java:50)&lt;br/&gt; at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)&lt;br/&gt; at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)&lt;br/&gt; at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)&lt;br/&gt; at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)&lt;br/&gt; at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)&lt;br/&gt; at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)&lt;br/&gt; at org.junit.runners.ParentRunner&lt;span&gt;$3&lt;/span&gt;.run(ParentRunner.java:290)&lt;br/&gt; at org.junit.runners.ParentRunner&lt;span&gt;$1&lt;/span&gt;.schedule(ParentRunner.java:71)&lt;br/&gt; at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)&lt;br/&gt; at org.junit.runners.ParentRunner.access&lt;span&gt;$000&lt;/span&gt;(ParentRunner.java:58)&lt;br/&gt; at org.junit.runners.ParentRunner&lt;span&gt;$2&lt;/span&gt;.evaluate(ParentRunner.java:268)&lt;br/&gt; at org.junit.runners.ParentRunner.run(ParentRunner.java:363)&lt;br/&gt; at org.junit.runner.JUnitCore.run(JUnitCore.java:137)&lt;br/&gt; at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)&lt;br/&gt; at com.intellij.rt.execution.junit.IdeaTestRunner&lt;span&gt;$Repeater&lt;/span&gt;.startRunnerWithArgs(IdeaTestRunner.java:47)&lt;br/&gt; at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)&lt;br/&gt; at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下就可以使用&lt;code&gt;Period&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Period between1 = Period.between(LocalDate.of(2020, 11, 13), LocalDate.of(2020, 11, 13));&lt;br/&gt;between1.getDays();  //返回相差的天数 =&amp;gt; 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间日期的更高级的操作&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以为对时间日期的修改增加减少都是通过第三方依赖包操作，现在原生API已经支持&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDate now2 = LocalDate.of(2020, 11, 13);&lt;br/&gt;System.out.println(now2.plusDays(2));       //加2天   =&amp;gt; 2020-11-15&lt;br/&gt;System.out.println(now2.plusMonths(1));     //加1月   =&amp;gt; 2020-12-13&lt;br/&gt;System.out.println(now2.plusWeeks(1));      //加一周   =&amp;gt; 2020-11-20&lt;br/&gt;System.out.println(now2.minusDays(1));      //减一天   =&amp;gt; 2020-11-12&lt;br/&gt;System.out.println(now2.minusMonths(1));    //减一月   =&amp;gt; 2020-10-13&lt;br/&gt;System.out.println(now2.minusYears(1));     //减一年   =&amp;gt; 2019-11-13&lt;br/&gt;System.out.println(now2.withYear(2021));    //修改年   =&amp;gt; 2021-11-13&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有时候我们会遇到需要取本月的最后一天、本月的第一天、调整日期到下一个周日... ;这些需求也能够通过使用&lt;code&gt;TemporalAdjuster&lt;/code&gt;很好的实现，&lt;code&gt;TemporalAdjuster&lt;/code&gt; 能够实现很多定制化的日期操作，Java8在&lt;code&gt;TemporalAdjusters&lt;/code&gt;已经给提供了默认的很多实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDate now3 = LocalDate.of(2020, 11, 13);&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.firstDayOfYear())); // 本年的第一天 =&amp;gt; 2020-01-01&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.next(DayOfWeek.MONDAY))); //下一个周一 =&amp;gt; 2020-11-16&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.lastDayOfMonth())); // 本月的最后一天 =&amp;gt; 2020-11-30&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.lastDayOfYear())); // 本年的最后一天 =&amp;gt; 2020-12-31&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;自定义&lt;code&gt;TemporalAdjuster&lt;/code&gt;实现获取当天的开始时间和当天的最后时间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 13, 10, 10, 10);&lt;br/&gt;System.out.println(localDateTime);&lt;br/&gt;System.out.println(localDateTime.with((temporal) -&amp;gt; &lt;br/&gt;    temporal.with(ChronoField.SECOND_OF_DAY, 0))); // 当天的凌晨 =&amp;gt; 2020-11-13T00:00&lt;br/&gt;System.out.println(localDateTime.with((temporal) -&amp;gt;&lt;br/&gt;    temporal.with(ChronoField.SECOND_OF_DAY, temporal.range(ChronoField.SECOND_OF_DAY).getMaximum()))); // 当天的最后一刻时间 =&amp;gt; 2020-11-13T23:59:59&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解析、格式化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对日期的字符串解析和格式化的操作是常用的，首先看下不用第三方包如何简单的实现日期解析&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(LocalDateTime.parse(&lt;span&gt;&quot;2020-11-14T20:50:00&quot;&lt;/span&gt;)); // 输出：2020-11-14T20:50&lt;br/&gt;System.out.println(LocalDateTime.parse(&lt;span&gt;&quot;2020/11/14 20:50:00&quot;&lt;/span&gt;,&lt;br/&gt;        DateTimeFormatter.ofPattern(&lt;span&gt;&quot;yyyy/MM/dd HH:mm:ss&quot;&lt;/span&gt;))); // 输出：2020-11-14T20:50&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现格式化同样也简单&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDate now4 = LocalDate.of(2020, 11, 13);&lt;br/&gt;System.out.println(now4.format(DateTimeFormatter.ofPattern(&lt;span&gt;&quot;yyyy/MM/dd&quot;&lt;/span&gt;))); //输出：2020/11/13&lt;br/&gt;&lt;br/&gt;LocalDateTime localDateTime2 = LocalDateTime.of(2020, 11, 13, 10, 10, 10);&lt;br/&gt;System.out.println(localDateTime2.format(DateTimeFormatter.ofPattern(&lt;span&gt;&quot;yyyy/MM/dd HH:mm:ss&quot;&lt;/span&gt;))); //输出：2020/11/13 10:10:10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>029bf7760f7f6338f8a7338281eefa77</guid>
<title>身份认证之双因素认证 2FA</title>
<link>https://toutiao.io/k/4sfxuxd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCbgMd0YUHWP5kKRjiaaML5DyibzChE0Z0LQs7dVibFHNowjorlCcVAN8Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;身份认证&lt;/h2&gt;&lt;p&gt;这里所说的身份认证，指的是狭义上的在计算机及其网络系统中确认操作者身份的过程，从而确定用户是否具有访问或操作某种资源的权限。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCxHgtZvq6MUX9uFe4RFE0rNvNy4SkCls94hqgY9icJxEFaavqfgnSYWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;之所以要在互联网中进行身份认证，是为了防止攻击者假冒你的身份在系统中进行不利于你的操作。试想一下，万一哪天早晨起来你发现你的支付宝账号被盗了，你余额宝里的钱全没了，那岂不是亏大了。&lt;/p&gt;&lt;p&gt;只不过，和现实世界不同的是，网络世界中一切信息都是用一组特定的数据来表示的，计算机只能识别用户的数字身份，所以&lt;strong&gt;对用户的授权本质上就是针对用户数字身份的授权&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;因此，如何保证操作者的物理身份和数字身份相对应，就成了一个至关重要的议题了，身份认证也因此在互联网世界中起着举足轻重的作用了。本文将会介绍目前很多网站常用的一种方式——双因素认证（也叫两步验证，英语：Two-factor authentication，缩写为 2FA）。&lt;/p&gt;&lt;h2&gt;双因素认证 2FA&lt;/h2&gt;&lt;p&gt;虽然网络世界和真实世界对于身份的表示不尽相同，但是对于身份认证的手段与经验是可以相互借鉴的。在真实世界，对用户的身份认证基本依据可以分为这三种：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4098883572567783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQC41sSr8atqWfVmpwkJOVyiawYG09jCaYgWxDQIzRLybkZYJWDqTIdeSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上述三种认证依据被称为三种「因素」（factor）。因素越多，证明力就越强，身份就越可靠。&lt;/p&gt;&lt;p&gt;因此，在网络世界中，为了达到更高的身份认证安全性，某些场景会将上面 3 种挑选 2 种混合使用，即双因素认证。&lt;/p&gt;&lt;p&gt;在支付宝还没有在中华大地普及的时候，去银行通常需要准备一个叫「U 盾」的东西，在使用网上银行时，用户需要先插上 U 盾，然后再输入密码才能登录网上银行。在这一操作中，U 盾（you have）+密码（you know）这两种因素组合在一起就构成了一个双因素认证。&lt;/p&gt;&lt;p&gt;只是后来，随着移动互联网的普及，手机渐渐成为最离不开人身边的物品了，于是传统的「U 盾+密码」的组合方案就被「手机+密码」的组合替代了。&lt;/p&gt;&lt;p&gt;现如今，短信验证码在国内已经成为使用最广泛的两步验证方法之一了，虽然操作方便，不需要安装额外的 APP，但是验证码的下发&lt;strong&gt;依赖网络和运营商信号&lt;/strong&gt;，有被窃听的风险。试想一下，如果这种验证码的获取不需要依赖运营商和网络，哪怕手机处于飞行模式也可以获取验证码，那么安全性是不是就得到提升了？&lt;/p&gt;&lt;p&gt;而这也就是下面将要说的 TOTP，即&lt;strong&gt;“基于时间的一次性密码（Time-based One-time Password）”&lt;/strong&gt;。这是目前公认的可靠解决方案，已被纳入国际标准。&lt;/p&gt;&lt;h2&gt;TOTP&lt;/h2&gt;&lt;h3&gt;流程&lt;/h3&gt;&lt;p&gt;TOTP 的流程如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;服务器随机生成一个的密钥，并且把这个密钥保存在数据库中。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;服务端将该密钥下发，通常是在页面上显示一个二维码，内容中包含密钥。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;客户端扫描二维码，把密钥保存在客户端。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;客户端每 30 秒使用密钥和时间戳通过 TOTP 算法生成一个 6 位数字的一次性密码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其实利用 TOTP 验证的流程很简单，这里也只是介绍，如果想深入了解 TOTP 算法的具体实现过程，可以参考 👉&lt;span&gt; TOTP: Time-Based One-Time Password Algorithm&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过这种方式生成一次性验证码，除去第一次获取服务器下发的密钥外，对网络并无其他要求了，这样即使是在离线情况下也可以使用，而且由于由于这种动态生成的密码通常只会存在 30s，安全性也得到了较大的提升。&lt;/p&gt;&lt;p&gt;只是在实际过程中，肯定要额外考虑一些情况，比如如果有人想要暴力破解验证码时，我们可以对验证的错误次数进行限制；抑或是手机端时间和服务器时间不同步，我们需要通过算法的方式兼容服务器时间的前后 30s，从而有效的避免细微时间上差异而导致的验证失败。&lt;/p&gt;&lt;h3&gt;使用现状&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.682089552238806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCiaR3ZbsYVsU8x7vjly1k3Czicia61IZbPMY1VLduOmoakH0fqrt9gQoCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1340&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;目前 TOTP 验证 App 主要分为两类：“独占类”和“开放类”。所谓独占类指的是只支持自家账户登录的两步验证，比如 QQ 安全中心、Steam 验证令牌等。开放类则是一个纯粹的两步验证 App，通过一个 App 去作为多个网站的验证器，例如 &lt;code&gt;Google authenticator&lt;/code&gt; 就是一个开源的基于 TOTP 原理实现的一个生成一次性密码的工具。&lt;/p&gt;&lt;p&gt;Google Play Store 上就有许多第三方的基于 TOTP 原理实现的一次性验证码工具，只是由于国内用户使用习惯的问题，除非在一些特殊场合，例如找回密码时会用到 TOTP 验证外，其他大多数情况还是会使用短信验证码的方式，这也算国内外使用习惯的差异了。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4098073555166375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCwf5nmGmu6icEopvM6gjvIemm8r9zmAKLrObaEo9zsVYBYqMUWbmBYKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;总的来说，基于 TOTP 机制的两步验证 APP 有着比短信验证码高得多的安全性和相媲美的便利性，是一种能保障用户财产安全的工具。只是在登录时会多一步，费时且麻烦，可能会引起用户的不适。只是在重要数据面前，还是尽量使用两步验证吧，不然和 AntDesign 一样丢了代码库可就不好了。&lt;/p&gt;&lt;p&gt;以上就是本文的全部内容了，新年已到，想必大家也都已经复工了，在这里祝大家新年快乐，牛年大吉 🐂。如果你觉得我的文章对你有所帮助，还希望在新的一年里可以继续支持「01 二进制」，你们的支持是我更新原创的最大动力！&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; TOTP: Time-Based One-Time Password Algorithm: &lt;em&gt;https://tools.ietf.org/html/rfc6238&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6654547862f5b8d2a12f5e834a840845</guid>
<title>介绍一个小工具：网络策略可视化编辑器</title>
<link>https://toutiao.io/k/pkdp4sn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;引子&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;跳过本节不影响阅读&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;既然是牛年第一篇，总要写点废话起个头。另外写小工具系列经常面对的一个难题就是——怎样凑够 300 字的原创门槛。&lt;/p&gt;&lt;p&gt;2020 年有大半年我都在唠叨云原生安全的事情，现在的情况按照我的理解，有点像 2000 年附近的互联网——各种东西都在往新瓶子里装，那时候的新瓶子是互联网，现在的新瓶子是云原生；那时候的旧酒是邮件、留言板、传呼机，现在的旧酒除了这些生活内容之外，多了更多的 ToB/G 的内容；从前的较大规模的公开互联网服务多数是自建自维护的，现在的公开服务则往往会用到大量的公有云、SaaS/PaaS 服务以及第三方交付项目。&lt;/p&gt;&lt;p&gt;在 Kubernetes 来说：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;推出了 CKS 认证&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;OPA 毕业&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kyverno 进入沙箱&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Redhat 收购 StackRox&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;综上，经过轰轰烈烈的云原生运动之后，安全问题就已经被怼到了我们面前，很多时候一些重点服务一旦遭到破坏，虽说安全相关的黑产已经有了成熟的获利链条；然而在责任方来说，的确可以挤出一句——这不是钱的事儿。&lt;/p&gt;&lt;h2&gt;正文&lt;/h2&gt;&lt;p&gt;言归正传，今天要介绍的是一个&lt;strong&gt;安全相关&lt;/strong&gt;的网络策略&lt;strong&gt;小工具&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;网络策略是 Kubernetes 内置的重要安全机制之一，用它可以轻松地使用 Namespace、Label Selector、CIDR 等方式，限制 Pod 的 Ingress/Egress 访问，相对于 RBAC 来说，这东西其实更贴近传统网络策略的限制方式，但是目前应用还较少，也就显得比较难用了。Cilium 推出的这个可视化编辑器，是个很好的入门工具。&lt;/p&gt;&lt;p&gt;缺省界面如图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;31&quot; data-backw=&quot;61&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;61&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;22&quot; data-ratio=&quot;0.5063613231552163&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mbeSBYZpODzoZotRA1taGPbHwWr3bicmKJ74qWqG5HGpia9SC9M9YBicr1KbZPmNibCuZ94VKW0lN2e6iaYhoLV0ARg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3144&quot;/&gt;&lt;/p&gt;&lt;p&gt;整个界面分为几个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;A：&lt;/p&gt;&lt;p&gt;可视化编辑区：&lt;/p&gt;&lt;p&gt;区域中可以用点选的方式产生不同的 Ingress Egress 规则。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;B：&lt;/p&gt;&lt;p&gt;代码编辑区：&lt;/p&gt;&lt;p&gt;交互式编辑区产生的策略变更都会用 YAML 代码的形式反映在该区域，另外左上角还可以通过上传的方式载入现有 YAML 文件，上传的内容也会反向映射回到可视化编辑区中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;C：&lt;/p&gt;&lt;p&gt;该区域是教学区域，下拉菜单中包含了几个常用的策略的相关教学，注意这里的是教学，给出的可能是一个待修复的策略和修复方法，不要直接复制使用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可视化编辑区分为左中右三个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1：&lt;/p&gt;&lt;p&gt;这里可以定义策略的主体，例如命名空间、名称、策略对应的管理目标（Pod Selector），另外还可以定义 Ingress 和 Egress 的缺省行为，例如缺省 Deny 或者 Allow，这里可以看到，随着策略的变化，相应的连接线颜色会发生变化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2：&lt;/p&gt;&lt;p&gt;Ingress 区域，管理进入 Pod 的流量，分为集群外、集群内、本命名空间三种配置方法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3：&lt;/p&gt;&lt;p&gt;Egress 区域，管理从 Pod 发出的流量，和 Ingress 区域一样，分为三种配置。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;例如新建一个缺省禁止所有其它命名空间访问的策略，只要新建策略，在 1 区点击 &lt;code&gt;Ingress&lt;/code&gt;，将其设为 Default Deny，然后在 2 区点击 &lt;code&gt;In Namespace&lt;/code&gt;，在弹出窗口中选择 &lt;code&gt;Allow from any pod&lt;/code&gt; 即可。最终结果如图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;42&quot; data-backw=&quot;65&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;65&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;22&quot; data-ratio=&quot;0.6507258753202391&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mbeSBYZpODzoZotRA1taGPbHwWr3bicmKhXxNy1C2UC2MMj9ibhQe8O8Jlv0rE91Sw3HDlGFjH5ibjib4sLt6aadgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2342&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了 All 之外，编辑器还支持 namespaceSelector、podSelector 以及集群外 CIDR 等的源头选择。Egress 策略中也包括对目标端口的设置。&lt;/p&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;p&gt;这才能叫可视化吧。&lt;/p&gt;&lt;h2&gt;相关链接&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;工具地址：&lt;/p&gt;&lt;p&gt;&lt;code&gt;https://editor.cilium.io/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kubernetes Network Policies：&lt;/p&gt;&lt;p&gt;&lt;code&gt;https://kubernetes.io/docs/concepts/services-networking/network-policies/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>